commit 58ea1059df97c71c023ec9de3940040c2c9bbc64
Author: Haojian Wu <hokein.wu@gmail.com>
Date:   Thu Apr 23 11:14:01 2020 +0200

    [AST][RecoveryExpr] Build recovery expressions by default for C++.
    
    Reland https://reviews.llvm.org/D76696
    All known crashes have been fixed, another attemption.
    
    We have rolled out this to all internal users for a while, didn't see
    big issues, we consider it is stable enough.
    
    Reviewed By: sammccall
    
    Subscribers: rsmith, hubert.reinterpretcast, ebevhan, jkorous, arphaman, kadircet, usaxena95, cfe-commits
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D78350

diff --git a/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp b/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
index b060e67e848f..909ffce9df59 100644
--- a/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
+++ b/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
@@ -1163,47 +1163,49 @@ TEST(SignatureHelpTest, ActiveArg) {
 TEST(SignatureHelpTest, OpeningParen) {
   llvm::StringLiteral Tests[] = {// Recursive function call.
                                  R"cpp(
     int foo(int a, int b, int c);
     int main() {
       foo(foo $p^( foo(10, 10, 10), ^ )));
     })cpp",
                                  // Functional type cast.
                                  R"cpp(
     struct Foo {
       Foo(int a, int b, int c);
     };
     int main() {
       Foo $p^( 10, ^ );
     })cpp",
                                  // New expression.
                                  R"cpp(
     struct Foo {
       Foo(int a, int b, int c);
     };
     int main() {
       new Foo $p^( 10, ^ );
     })cpp",
                                  // Macro expansion.
                                  R"cpp(
     int foo(int a, int b, int c);
     #define FOO foo(
 
     int main() {
       // Macro expansions.
       $p^FOO 10, ^ );
     })cpp",
                                  // Macro arguments.
                                  R"cpp(
     int foo(int a, int b, int c);
     int main() {
     #define ID(X) X
-      ID(foo $p^( foo(10), ^ ))
+      // FIXME: figure out why ID(foo (foo(10), )) doesn't work when preserving
+      // the recovery expression.
+      ID(foo $p^( 10, ^ ))
     })cpp"};
 
   for (auto Test : Tests) {
     Annotations Code(Test);
     EXPECT_EQ(signatures(Code.code(), Code.point()).argListStart,
               Code.point("p"))
         << "Test source:" << Test;
   }
 }
diff --git a/clang/lib/Frontend/CompilerInvocation.cpp b/clang/lib/Frontend/CompilerInvocation.cpp
index 3aea9164046c..c7180779d973 100644
--- a/clang/lib/Frontend/CompilerInvocation.cpp
+++ b/clang/lib/Frontend/CompilerInvocation.cpp
@@ -2452,967 +2452,968 @@ static const StringRef GetInputKindName(InputKind IK) {
 static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
                           const TargetOptions &TargetOpts,
                           PreprocessorOptions &PPOpts,
                           DiagnosticsEngine &Diags) {
   // FIXME: Cleanup per-file based stuff.
   LangStandard::Kind LangStd = LangStandard::lang_unspecified;
   if (const Arg *A = Args.getLastArg(OPT_std_EQ)) {
     LangStd = LangStandard::getLangKind(A->getValue());
     if (LangStd == LangStandard::lang_unspecified) {
       Diags.Report(diag::err_drv_invalid_value)
         << A->getAsString(Args) << A->getValue();
       // Report supported standards with short description.
       for (unsigned KindValue = 0;
            KindValue != LangStandard::lang_unspecified;
            ++KindValue) {
         const LangStandard &Std = LangStandard::getLangStandardForKind(
           static_cast<LangStandard::Kind>(KindValue));
         if (IsInputCompatibleWithStandard(IK, Std)) {
           auto Diag = Diags.Report(diag::note_drv_use_standard);
           Diag << Std.getName() << Std.getDescription();
           unsigned NumAliases = 0;
 #define LANGSTANDARD(id, name, lang, desc, features)
 #define LANGSTANDARD_ALIAS(id, alias) \
           if (KindValue == LangStandard::lang_##id) ++NumAliases;
 #define LANGSTANDARD_ALIAS_DEPR(id, alias)
 #include "clang/Basic/LangStandards.def"
           Diag << NumAliases;
 #define LANGSTANDARD(id, name, lang, desc, features)
 #define LANGSTANDARD_ALIAS(id, alias) \
           if (KindValue == LangStandard::lang_##id) Diag << alias;
 #define LANGSTANDARD_ALIAS_DEPR(id, alias)
 #include "clang/Basic/LangStandards.def"
         }
       }
     } else {
       // Valid standard, check to make sure language and standard are
       // compatible.
       const LangStandard &Std = LangStandard::getLangStandardForKind(LangStd);
       if (!IsInputCompatibleWithStandard(IK, Std)) {
         Diags.Report(diag::err_drv_argument_not_allowed_with)
           << A->getAsString(Args) << GetInputKindName(IK);
       }
     }
   }
 
   if (Args.hasArg(OPT_fno_dllexport_inlines))
     Opts.DllExportInlines = false;
 
   if (const Arg *A = Args.getLastArg(OPT_fcf_protection_EQ)) {
     StringRef Name = A->getValue();
     if (Name == "full" || Name == "branch") {
       Opts.CFProtectionBranch = 1;
     }
   }
   // -cl-std only applies for OpenCL language standards.
   // Override the -std option in this case.
   if (const Arg *A = Args.getLastArg(OPT_cl_std_EQ)) {
     LangStandard::Kind OpenCLLangStd
       = llvm::StringSwitch<LangStandard::Kind>(A->getValue())
         .Cases("cl", "CL", LangStandard::lang_opencl10)
         .Cases("cl1.1", "CL1.1", LangStandard::lang_opencl11)
         .Cases("cl1.2", "CL1.2", LangStandard::lang_opencl12)
         .Cases("cl2.0", "CL2.0", LangStandard::lang_opencl20)
         .Cases("clc++", "CLC++", LangStandard::lang_openclcpp)
         .Default(LangStandard::lang_unspecified);
 
     if (OpenCLLangStd == LangStandard::lang_unspecified) {
       Diags.Report(diag::err_drv_invalid_value)
         << A->getAsString(Args) << A->getValue();
     }
     else
       LangStd = OpenCLLangStd;
   }
 
   Opts.SYCL = Args.hasArg(options::OPT_fsycl);
   Opts.SYCLIsDevice = Opts.SYCL && Args.hasArg(options::OPT_fsycl_is_device);
   if (Opts.SYCL) {
     // -sycl-std applies to any SYCL source, not only those containing kernels,
     // but also those using the SYCL API
     if (const Arg *A = Args.getLastArg(OPT_sycl_std_EQ)) {
       Opts.SYCLVersion = llvm::StringSwitch<unsigned>(A->getValue())
                              .Cases("2017", "1.2.1", "121", "sycl-1.2.1", 2017)
                              .Default(0U);
 
       if (Opts.SYCLVersion == 0U) {
         // User has passed an invalid value to the flag, this is an error
         Diags.Report(diag::err_drv_invalid_value)
             << A->getAsString(Args) << A->getValue();
       }
     }
   }
 
   Opts.IncludeDefaultHeader = Args.hasArg(OPT_finclude_default_header);
   Opts.DeclareOpenCLBuiltins = Args.hasArg(OPT_fdeclare_opencl_builtins);
 
   llvm::Triple T(TargetOpts.Triple);
   CompilerInvocation::setLangDefaults(Opts, IK, T, PPOpts, LangStd);
 
   // -cl-strict-aliasing needs to emit diagnostic in the case where CL > 1.0.
   // This option should be deprecated for CL > 1.0 because
   // this option was added for compatibility with OpenCL 1.0.
   if (Args.getLastArg(OPT_cl_strict_aliasing)
        && Opts.OpenCLVersion > 100) {
     Diags.Report(diag::warn_option_invalid_ocl_version)
         << Opts.getOpenCLVersionTuple().getAsString()
         << Args.getLastArg(OPT_cl_strict_aliasing)->getAsString(Args);
   }
 
   // We abuse '-f[no-]gnu-keywords' to force overriding all GNU-extension
   // keywords. This behavior is provided by GCC's poorly named '-fasm' flag,
   // while a subset (the non-C++ GNU keywords) is provided by GCC's
   // '-fgnu-keywords'. Clang conflates the two for simplicity under the single
   // name, as it doesn't seem a useful distinction.
   Opts.GNUKeywords = Args.hasFlag(OPT_fgnu_keywords, OPT_fno_gnu_keywords,
                                   Opts.GNUKeywords);
 
   Opts.Digraphs = Args.hasFlag(OPT_fdigraphs, OPT_fno_digraphs, Opts.Digraphs);
 
   if (Args.hasArg(OPT_fno_operator_names))
     Opts.CXXOperatorNames = 0;
 
   if (Args.hasArg(OPT_fcuda_is_device))
     Opts.CUDAIsDevice = 1;
 
   if (Args.hasArg(OPT_fcuda_allow_variadic_functions))
     Opts.CUDAAllowVariadicFunctions = 1;
 
   if (Args.hasArg(OPT_fno_cuda_host_device_constexpr))
     Opts.CUDAHostDeviceConstexpr = 0;
 
   if (Opts.CUDAIsDevice && Args.hasArg(OPT_fcuda_approx_transcendentals))
     Opts.CUDADeviceApproxTranscendentals = 1;
 
   Opts.GPURelocatableDeviceCode = Args.hasArg(OPT_fgpu_rdc);
   if (Args.hasArg(OPT_fgpu_allow_device_init)) {
     if (Opts.HIP)
       Opts.GPUAllowDeviceInit = 1;
     else
       Diags.Report(diag::warn_ignored_hip_only_option)
           << Args.getLastArg(OPT_fgpu_allow_device_init)->getAsString(Args);
   }
   Opts.HIPUseNewLaunchAPI = Args.hasArg(OPT_fhip_new_launch_api);
   if (Opts.HIP)
     Opts.GPUMaxThreadsPerBlock = getLastArgIntValue(
         Args, OPT_gpu_max_threads_per_block_EQ, Opts.GPUMaxThreadsPerBlock);
   else if (Args.hasArg(OPT_gpu_max_threads_per_block_EQ))
     Diags.Report(diag::warn_ignored_hip_only_option)
         << Args.getLastArg(OPT_gpu_max_threads_per_block_EQ)->getAsString(Args);
 
   if (Opts.ObjC) {
     if (Arg *arg = Args.getLastArg(OPT_fobjc_runtime_EQ)) {
       StringRef value = arg->getValue();
       if (Opts.ObjCRuntime.tryParse(value))
         Diags.Report(diag::err_drv_unknown_objc_runtime) << value;
     }
 
     if (Args.hasArg(OPT_fobjc_gc_only))
       Opts.setGC(LangOptions::GCOnly);
     else if (Args.hasArg(OPT_fobjc_gc))
       Opts.setGC(LangOptions::HybridGC);
     else if (Args.hasArg(OPT_fobjc_arc)) {
       Opts.ObjCAutoRefCount = 1;
       if (!Opts.ObjCRuntime.allowsARC())
         Diags.Report(diag::err_arc_unsupported_on_runtime);
     }
 
     // ObjCWeakRuntime tracks whether the runtime supports __weak, not
     // whether the feature is actually enabled.  This is predominantly
     // determined by -fobjc-runtime, but we allow it to be overridden
     // from the command line for testing purposes.
     if (Args.hasArg(OPT_fobjc_runtime_has_weak))
       Opts.ObjCWeakRuntime = 1;
     else
       Opts.ObjCWeakRuntime = Opts.ObjCRuntime.allowsWeak();
 
     // ObjCWeak determines whether __weak is actually enabled.
     // Note that we allow -fno-objc-weak to disable this even in ARC mode.
     if (auto weakArg = Args.getLastArg(OPT_fobjc_weak, OPT_fno_objc_weak)) {
       if (!weakArg->getOption().matches(OPT_fobjc_weak)) {
         assert(!Opts.ObjCWeak);
       } else if (Opts.getGC() != LangOptions::NonGC) {
         Diags.Report(diag::err_objc_weak_with_gc);
       } else if (!Opts.ObjCWeakRuntime) {
         Diags.Report(diag::err_objc_weak_unsupported);
       } else {
         Opts.ObjCWeak = 1;
       }
     } else if (Opts.ObjCAutoRefCount) {
       Opts.ObjCWeak = Opts.ObjCWeakRuntime;
     }
 
     if (Args.hasArg(OPT_fno_objc_infer_related_result_type))
       Opts.ObjCInferRelatedResultType = 0;
 
     if (Args.hasArg(OPT_fobjc_subscripting_legacy_runtime))
       Opts.ObjCSubscriptingLegacyRuntime =
         (Opts.ObjCRuntime.getKind() == ObjCRuntime::FragileMacOSX);
   }
 
   if (Arg *A = Args.getLastArg(options::OPT_fgnuc_version_EQ)) {
     // Check that the version has 1 to 3 components and the minor and patch
     // versions fit in two decimal digits.
     VersionTuple GNUCVer;
     bool Invalid = GNUCVer.tryParse(A->getValue());
     unsigned Major = GNUCVer.getMajor();
     unsigned Minor = GNUCVer.getMinor().getValueOr(0);
     unsigned Patch = GNUCVer.getSubminor().getValueOr(0);
     if (Invalid || GNUCVer.getBuild() || Minor >= 100 || Patch >= 100) {
       Diags.Report(diag::err_drv_invalid_value)
           << A->getAsString(Args) << A->getValue();
     }
     Opts.GNUCVersion = Major * 100 * 100 + Minor * 100 + Patch;
   }
 
   if (Args.hasArg(OPT_fgnu89_inline)) {
     if (Opts.CPlusPlus)
       Diags.Report(diag::err_drv_argument_not_allowed_with)
         << "-fgnu89-inline" << GetInputKindName(IK);
     else
       Opts.GNUInline = 1;
   }
 
   if (Args.hasArg(OPT_fapple_kext)) {
     if (!Opts.CPlusPlus)
       Diags.Report(diag::warn_c_kext);
     else
       Opts.AppleKext = 1;
   }
 
   if (Args.hasArg(OPT_print_ivar_layout))
     Opts.ObjCGCBitmapPrint = 1;
 
   if (Args.hasArg(OPT_fno_constant_cfstrings))
     Opts.NoConstantCFStrings = 1;
   if (const auto *A = Args.getLastArg(OPT_fcf_runtime_abi_EQ))
     Opts.CFRuntime =
         llvm::StringSwitch<LangOptions::CoreFoundationABI>(A->getValue())
             .Cases("unspecified", "standalone", "objc",
                    LangOptions::CoreFoundationABI::ObjectiveC)
             .Cases("swift", "swift-5.0",
                    LangOptions::CoreFoundationABI::Swift5_0)
             .Case("swift-4.2", LangOptions::CoreFoundationABI::Swift4_2)
             .Case("swift-4.1", LangOptions::CoreFoundationABI::Swift4_1)
             .Default(LangOptions::CoreFoundationABI::ObjectiveC);
 
   if (Args.hasArg(OPT_fzvector))
     Opts.ZVector = 1;
 
   if (Args.hasArg(OPT_pthread))
     Opts.POSIXThreads = 1;
 
   // The value-visibility mode defaults to "default".
   if (Arg *visOpt = Args.getLastArg(OPT_fvisibility)) {
     Opts.setValueVisibilityMode(parseVisibility(visOpt, Args, Diags));
   } else {
     Opts.setValueVisibilityMode(DefaultVisibility);
   }
 
   // The type-visibility mode defaults to the value-visibility mode.
   if (Arg *typeVisOpt = Args.getLastArg(OPT_ftype_visibility)) {
     Opts.setTypeVisibilityMode(parseVisibility(typeVisOpt, Args, Diags));
   } else {
     Opts.setTypeVisibilityMode(Opts.getValueVisibilityMode());
   }
 
   if (Args.hasArg(OPT_fvisibility_inlines_hidden))
     Opts.InlineVisibilityHidden = 1;
 
   if (Args.hasArg(OPT_fvisibility_global_new_delete_hidden))
     Opts.GlobalAllocationFunctionVisibilityHidden = 1;
 
   if (Args.hasArg(OPT_fapply_global_visibility_to_externs))
     Opts.SetVisibilityForExternDecls = 1;
 
   if (Args.hasArg(OPT_ftrapv)) {
     Opts.setSignedOverflowBehavior(LangOptions::SOB_Trapping);
     // Set the handler, if one is specified.
     Opts.OverflowHandler =
         std::string(Args.getLastArgValue(OPT_ftrapv_handler));
   }
   else if (Args.hasArg(OPT_fwrapv))
     Opts.setSignedOverflowBehavior(LangOptions::SOB_Defined);
 
   Opts.MSVCCompat = Args.hasArg(OPT_fms_compatibility);
   Opts.MicrosoftExt = Opts.MSVCCompat || Args.hasArg(OPT_fms_extensions);
   Opts.AsmBlocks = Args.hasArg(OPT_fasm_blocks) || Opts.MicrosoftExt;
   Opts.MSCompatibilityVersion = 0;
   if (const Arg *A = Args.getLastArg(OPT_fms_compatibility_version)) {
     VersionTuple VT;
     if (VT.tryParse(A->getValue()))
       Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)
                                                 << A->getValue();
     Opts.MSCompatibilityVersion = VT.getMajor() * 10000000 +
                                   VT.getMinor().getValueOr(0) * 100000 +
                                   VT.getSubminor().getValueOr(0);
   }
 
   // Mimicking gcc's behavior, trigraphs are only enabled if -trigraphs
   // is specified, or -std is set to a conforming mode.
   // Trigraphs are disabled by default in c++1z onwards.
   Opts.Trigraphs = !Opts.GNUMode && !Opts.MSVCCompat && !Opts.CPlusPlus17;
   Opts.Trigraphs =
       Args.hasFlag(OPT_ftrigraphs, OPT_fno_trigraphs, Opts.Trigraphs);
 
   Opts.DollarIdents = Args.hasFlag(OPT_fdollars_in_identifiers,
                                    OPT_fno_dollars_in_identifiers,
                                    Opts.DollarIdents);
   Opts.PascalStrings = Args.hasArg(OPT_fpascal_strings);
   Opts.setVtorDispMode(
       MSVtorDispMode(getLastArgIntValue(Args, OPT_vtordisp_mode_EQ, 1, Diags)));
   Opts.Borland = Args.hasArg(OPT_fborland_extensions);
   Opts.WritableStrings = Args.hasArg(OPT_fwritable_strings);
   Opts.ConstStrings = Args.hasFlag(OPT_fconst_strings, OPT_fno_const_strings,
                                    Opts.ConstStrings);
   if (Arg *A = Args.getLastArg(OPT_flax_vector_conversions_EQ)) {
     using LaxKind = LangOptions::LaxVectorConversionKind;
     if (auto Kind = llvm::StringSwitch<Optional<LaxKind>>(A->getValue())
                         .Case("none", LaxKind::None)
                         .Case("integer", LaxKind::Integer)
                         .Case("all", LaxKind::All)
                         .Default(llvm::None))
       Opts.setLaxVectorConversions(*Kind);
     else
       Diags.Report(diag::err_drv_invalid_value)
           << A->getAsString(Args) << A->getValue();
   }
   if (Args.hasArg(OPT_fno_threadsafe_statics))
     Opts.ThreadsafeStatics = 0;
   Opts.Exceptions = Args.hasArg(OPT_fexceptions);
   Opts.IgnoreExceptions = Args.hasArg(OPT_fignore_exceptions);
   Opts.ObjCExceptions = Args.hasArg(OPT_fobjc_exceptions);
   Opts.CXXExceptions = Args.hasArg(OPT_fcxx_exceptions);
 
   // -ffixed-point
   Opts.FixedPoint =
       Args.hasFlag(OPT_ffixed_point, OPT_fno_fixed_point, /*Default=*/false) &&
       !Opts.CPlusPlus;
   Opts.PaddingOnUnsignedFixedPoint =
       Args.hasFlag(OPT_fpadding_on_unsigned_fixed_point,
                    OPT_fno_padding_on_unsigned_fixed_point,
                    /*Default=*/false) &&
       Opts.FixedPoint;
 
   // Handle exception personalities
   Arg *A = Args.getLastArg(
       options::OPT_fsjlj_exceptions, options::OPT_fseh_exceptions,
       options::OPT_fdwarf_exceptions, options::OPT_fwasm_exceptions);
   if (A) {
     const Option &Opt = A->getOption();
     llvm::Triple T(TargetOpts.Triple);
     if (T.isWindowsMSVCEnvironment())
       Diags.Report(diag::err_fe_invalid_exception_model)
           << Opt.getName() << T.str();
 
     Opts.SjLjExceptions = Opt.matches(options::OPT_fsjlj_exceptions);
     Opts.SEHExceptions = Opt.matches(options::OPT_fseh_exceptions);
     Opts.DWARFExceptions = Opt.matches(options::OPT_fdwarf_exceptions);
     Opts.WasmExceptions = Opt.matches(options::OPT_fwasm_exceptions);
   }
 
   Opts.ExternCNoUnwind = Args.hasArg(OPT_fexternc_nounwind);
   Opts.TraditionalCPP = Args.hasArg(OPT_traditional_cpp);
 
   Opts.RTTI = Opts.CPlusPlus && !Args.hasArg(OPT_fno_rtti);
   Opts.RTTIData = Opts.RTTI && !Args.hasArg(OPT_fno_rtti_data);
   Opts.Blocks = Args.hasArg(OPT_fblocks) || (Opts.OpenCL
     && Opts.OpenCLVersion == 200);
   Opts.BlocksRuntimeOptional = Args.hasArg(OPT_fblocks_runtime_optional);
   Opts.Coroutines = Opts.CPlusPlus20 || Args.hasArg(OPT_fcoroutines_ts);
 
   Opts.ConvergentFunctions = Opts.OpenCL || (Opts.CUDA && Opts.CUDAIsDevice) ||
     Args.hasArg(OPT_fconvergent_functions);
 
   Opts.DoubleSquareBracketAttributes =
       Args.hasFlag(OPT_fdouble_square_bracket_attributes,
                    OPT_fno_double_square_bracket_attributes,
                    Opts.DoubleSquareBracketAttributes);
 
   Opts.CPlusPlusModules = Opts.CPlusPlus20;
   Opts.ModulesTS = Args.hasArg(OPT_fmodules_ts);
   Opts.Modules =
       Args.hasArg(OPT_fmodules) || Opts.ModulesTS || Opts.CPlusPlusModules;
   Opts.ModulesStrictDeclUse = Args.hasArg(OPT_fmodules_strict_decluse);
   Opts.ModulesDeclUse =
       Args.hasArg(OPT_fmodules_decluse) || Opts.ModulesStrictDeclUse;
   // FIXME: We only need this in C++ modules / Modules TS if we might textually
   // enter a different module (eg, when building a header unit).
   Opts.ModulesLocalVisibility =
       Args.hasArg(OPT_fmodules_local_submodule_visibility) || Opts.ModulesTS ||
       Opts.CPlusPlusModules;
   Opts.ModulesCodegen = Args.hasArg(OPT_fmodules_codegen);
   Opts.ModulesDebugInfo = Args.hasArg(OPT_fmodules_debuginfo);
   Opts.ModulesSearchAll = Opts.Modules &&
     !Args.hasArg(OPT_fno_modules_search_all) &&
     Args.hasArg(OPT_fmodules_search_all);
   Opts.ModulesErrorRecovery = !Args.hasArg(OPT_fno_modules_error_recovery);
   Opts.ImplicitModules = !Args.hasArg(OPT_fno_implicit_modules);
   Opts.CharIsSigned = Opts.OpenCL || !Args.hasArg(OPT_fno_signed_char);
   Opts.WChar = Opts.CPlusPlus && !Args.hasArg(OPT_fno_wchar);
   Opts.Char8 = Args.hasFlag(OPT_fchar8__t, OPT_fno_char8__t, Opts.CPlusPlus20);
   if (const Arg *A = Args.getLastArg(OPT_fwchar_type_EQ)) {
     Opts.WCharSize = llvm::StringSwitch<unsigned>(A->getValue())
                          .Case("char", 1)
                          .Case("short", 2)
                          .Case("int", 4)
                          .Default(0);
     if (Opts.WCharSize == 0)
       Diags.Report(diag::err_fe_invalid_wchar_type) << A->getValue();
   }
   Opts.WCharIsSigned = Args.hasFlag(OPT_fsigned_wchar, OPT_fno_signed_wchar, true);
   Opts.ShortEnums = Args.hasArg(OPT_fshort_enums);
   Opts.Freestanding = Args.hasArg(OPT_ffreestanding);
   Opts.NoBuiltin = Args.hasArg(OPT_fno_builtin) || Opts.Freestanding;
   if (!Opts.NoBuiltin)
     getAllNoBuiltinFuncValues(Args, Opts.NoBuiltinFuncs);
   Opts.NoMathBuiltin = Args.hasArg(OPT_fno_math_builtin);
   Opts.RelaxedTemplateTemplateArgs =
       Args.hasArg(OPT_frelaxed_template_template_args);
   Opts.SizedDeallocation = Args.hasArg(OPT_fsized_deallocation);
   Opts.AlignedAllocation =
       Args.hasFlag(OPT_faligned_allocation, OPT_fno_aligned_allocation,
                    Opts.AlignedAllocation);
   Opts.AlignedAllocationUnavailable =
       Opts.AlignedAllocation && Args.hasArg(OPT_aligned_alloc_unavailable);
   Opts.NewAlignOverride =
       getLastArgIntValue(Args, OPT_fnew_alignment_EQ, 0, Diags);
   if (Opts.NewAlignOverride && !llvm::isPowerOf2_32(Opts.NewAlignOverride)) {
     Arg *A = Args.getLastArg(OPT_fnew_alignment_EQ);
     Diags.Report(diag::err_fe_invalid_alignment) << A->getAsString(Args)
                                                  << A->getValue();
     Opts.NewAlignOverride = 0;
   }
   Opts.ConceptSatisfactionCaching =
       !Args.hasArg(OPT_fno_concept_satisfaction_caching);
   if (Args.hasArg(OPT_fconcepts_ts))
     Diags.Report(diag::warn_fe_concepts_ts_flag);
+  // Recovery AST still heavily relies on dependent-type machinery.
   Opts.RecoveryAST =
-      Args.hasFlag(OPT_frecovery_ast, OPT_fno_recovery_ast, false);
+      Args.hasFlag(OPT_frecovery_ast, OPT_fno_recovery_ast, Opts.CPlusPlus);
   Opts.RecoveryASTType =
-+      Args.hasFlag(OPT_frecovery_ast_type, OPT_fno_recovery_ast_type, false);
+      Args.hasFlag(OPT_frecovery_ast_type, OPT_fno_recovery_ast_type, false);
   Opts.HeinousExtensions = Args.hasArg(OPT_fheinous_gnu_extensions);
   Opts.AccessControl = !Args.hasArg(OPT_fno_access_control);
   Opts.ElideConstructors = !Args.hasArg(OPT_fno_elide_constructors);
   Opts.MathErrno = !Opts.OpenCL && Args.hasArg(OPT_fmath_errno);
   Opts.InstantiationDepth =
       getLastArgIntValue(Args, OPT_ftemplate_depth, 1024, Diags);
   Opts.ArrowDepth =
       getLastArgIntValue(Args, OPT_foperator_arrow_depth, 256, Diags);
   Opts.ConstexprCallDepth =
       getLastArgIntValue(Args, OPT_fconstexpr_depth, 512, Diags);
   Opts.ConstexprStepLimit =
       getLastArgIntValue(Args, OPT_fconstexpr_steps, 1048576, Diags);
   Opts.EnableNewConstInterp =
       Args.hasArg(OPT_fexperimental_new_constant_interpreter);
   Opts.BracketDepth = getLastArgIntValue(Args, OPT_fbracket_depth, 256, Diags);
   Opts.DelayedTemplateParsing = Args.hasArg(OPT_fdelayed_template_parsing);
   Opts.NumLargeByValueCopy =
       getLastArgIntValue(Args, OPT_Wlarge_by_value_copy_EQ, 0, Diags);
   Opts.MSBitfields = Args.hasArg(OPT_mms_bitfields);
   Opts.ObjCConstantStringClass =
       std::string(Args.getLastArgValue(OPT_fconstant_string_class));
   Opts.ObjCDefaultSynthProperties =
     !Args.hasArg(OPT_disable_objc_default_synthesize_properties);
   Opts.EncodeExtendedBlockSig =
     Args.hasArg(OPT_fencode_extended_block_signature);
   Opts.EmitAllDecls = Args.hasArg(OPT_femit_all_decls);
   Opts.PackStruct = getLastArgIntValue(Args, OPT_fpack_struct_EQ, 0, Diags);
   Opts.MaxTypeAlign = getLastArgIntValue(Args, OPT_fmax_type_align_EQ, 0, Diags);
   Opts.AlignDouble = Args.hasArg(OPT_malign_double);
   Opts.DoubleSize = getLastArgIntValue(Args, OPT_mdouble_EQ, 0, Diags);
   Opts.LongDoubleSize = Args.hasArg(OPT_mlong_double_128)
                             ? 128
                             : Args.hasArg(OPT_mlong_double_64) ? 64 : 0;
   Opts.PPCIEEELongDouble = Args.hasArg(OPT_mabi_EQ_ieeelongdouble);
   Opts.PICLevel = getLastArgIntValue(Args, OPT_pic_level, 0, Diags);
   Opts.ROPI = Args.hasArg(OPT_fropi);
   Opts.RWPI = Args.hasArg(OPT_frwpi);
   Opts.PIE = Args.hasArg(OPT_pic_is_pie);
   Opts.Static = Args.hasArg(OPT_static_define);
   Opts.DumpRecordLayoutsSimple = Args.hasArg(OPT_fdump_record_layouts_simple);
   Opts.DumpRecordLayouts = Opts.DumpRecordLayoutsSimple
                         || Args.hasArg(OPT_fdump_record_layouts);
   Opts.DumpVTableLayouts = Args.hasArg(OPT_fdump_vtable_layouts);
   Opts.SpellChecking = !Args.hasArg(OPT_fno_spell_checking);
   Opts.NoBitFieldTypeAlign = Args.hasArg(OPT_fno_bitfield_type_align);
   Opts.SinglePrecisionConstants = Args.hasArg(OPT_cl_single_precision_constant);
   Opts.FastRelaxedMath = Args.hasArg(OPT_cl_fast_relaxed_math);
   if (Opts.FastRelaxedMath)
     Opts.setDefaultFPContractMode(LangOptions::FPM_Fast);
   Opts.HexagonQdsp6Compat = Args.hasArg(OPT_mqdsp6_compat);
   Opts.FakeAddressSpaceMap = Args.hasArg(OPT_ffake_address_space_map);
   Opts.ParseUnknownAnytype = Args.hasArg(OPT_funknown_anytype);
   Opts.DebuggerSupport = Args.hasArg(OPT_fdebugger_support);
   Opts.DebuggerCastResultToId = Args.hasArg(OPT_fdebugger_cast_result_to_id);
   Opts.DebuggerObjCLiteral = Args.hasArg(OPT_fdebugger_objc_literal);
   Opts.ApplePragmaPack = Args.hasArg(OPT_fapple_pragma_pack);
   Opts.ModuleName = std::string(Args.getLastArgValue(OPT_fmodule_name_EQ));
   Opts.CurrentModule = Opts.ModuleName;
   Opts.AppExt = Args.hasArg(OPT_fapplication_extension);
   Opts.ModuleFeatures = Args.getAllArgValues(OPT_fmodule_feature);
   llvm::sort(Opts.ModuleFeatures);
   Opts.NativeHalfType |= Args.hasArg(OPT_fnative_half_type);
   Opts.NativeHalfArgsAndReturns |= Args.hasArg(OPT_fnative_half_arguments_and_returns);
   // Enable HalfArgsAndReturns if present in Args or if NativeHalfArgsAndReturns
   // is enabled.
   Opts.HalfArgsAndReturns = Args.hasArg(OPT_fallow_half_arguments_and_returns)
                             | Opts.NativeHalfArgsAndReturns;
   Opts.GNUAsm = !Args.hasArg(OPT_fno_gnu_inline_asm);
   Opts.Cmse = Args.hasArg(OPT_mcmse); // Armv8-M Security Extensions
 
   // __declspec is enabled by default for the PS4 by the driver, and also
   // enabled for Microsoft Extensions or Borland Extensions, here.
   //
   // FIXME: __declspec is also currently enabled for CUDA, but isn't really a
   // CUDA extension. However, it is required for supporting
   // __clang_cuda_builtin_vars.h, which uses __declspec(property). Once that has
   // been rewritten in terms of something more generic, remove the Opts.CUDA
   // term here.
   Opts.DeclSpecKeyword =
       Args.hasFlag(OPT_fdeclspec, OPT_fno_declspec,
                    (Opts.MicrosoftExt || Opts.Borland || Opts.CUDA));
 
   if (Arg *A = Args.getLastArg(OPT_faddress_space_map_mangling_EQ)) {
     switch (llvm::StringSwitch<unsigned>(A->getValue())
       .Case("target", LangOptions::ASMM_Target)
       .Case("no", LangOptions::ASMM_Off)
       .Case("yes", LangOptions::ASMM_On)
       .Default(255)) {
     default:
       Diags.Report(diag::err_drv_invalid_value)
         << "-faddress-space-map-mangling=" << A->getValue();
       break;
     case LangOptions::ASMM_Target:
       Opts.setAddressSpaceMapMangling(LangOptions::ASMM_Target);
       break;
     case LangOptions::ASMM_On:
       Opts.setAddressSpaceMapMangling(LangOptions::ASMM_On);
       break;
     case LangOptions::ASMM_Off:
       Opts.setAddressSpaceMapMangling(LangOptions::ASMM_Off);
       break;
     }
   }
 
   if (Arg *A = Args.getLastArg(OPT_fms_memptr_rep_EQ)) {
     LangOptions::PragmaMSPointersToMembersKind InheritanceModel =
         llvm::StringSwitch<LangOptions::PragmaMSPointersToMembersKind>(
             A->getValue())
             .Case("single",
                   LangOptions::PPTMK_FullGeneralitySingleInheritance)
             .Case("multiple",
                   LangOptions::PPTMK_FullGeneralityMultipleInheritance)
             .Case("virtual",
                   LangOptions::PPTMK_FullGeneralityVirtualInheritance)
             .Default(LangOptions::PPTMK_BestCase);
     if (InheritanceModel == LangOptions::PPTMK_BestCase)
       Diags.Report(diag::err_drv_invalid_value)
           << "-fms-memptr-rep=" << A->getValue();
 
     Opts.setMSPointerToMemberRepresentationMethod(InheritanceModel);
   }
 
   // Check for MS default calling conventions being specified.
   if (Arg *A = Args.getLastArg(OPT_fdefault_calling_conv_EQ)) {
     LangOptions::DefaultCallingConvention DefaultCC =
         llvm::StringSwitch<LangOptions::DefaultCallingConvention>(A->getValue())
             .Case("cdecl", LangOptions::DCC_CDecl)
             .Case("fastcall", LangOptions::DCC_FastCall)
             .Case("stdcall", LangOptions::DCC_StdCall)
             .Case("vectorcall", LangOptions::DCC_VectorCall)
             .Case("regcall", LangOptions::DCC_RegCall)
             .Default(LangOptions::DCC_None);
     if (DefaultCC == LangOptions::DCC_None)
       Diags.Report(diag::err_drv_invalid_value)
           << "-fdefault-calling-conv=" << A->getValue();
 
     llvm::Triple T(TargetOpts.Triple);
     llvm::Triple::ArchType Arch = T.getArch();
     bool emitError = (DefaultCC == LangOptions::DCC_FastCall ||
                       DefaultCC == LangOptions::DCC_StdCall) &&
                      Arch != llvm::Triple::x86;
     emitError |= (DefaultCC == LangOptions::DCC_VectorCall ||
                   DefaultCC == LangOptions::DCC_RegCall) &&
                  !T.isX86();
     if (emitError)
       Diags.Report(diag::err_drv_argument_not_allowed_with)
           << A->getSpelling() << T.getTriple();
     else
       Opts.setDefaultCallingConv(DefaultCC);
   }
 
   Opts.SemanticInterposition = Args.hasArg(OPT_fsemantic_interposition);
   // An explicit -fno-semantic-interposition infers dso_local.
   Opts.ExplicitNoSemanticInterposition =
       Args.hasArg(OPT_fno_semantic_interposition);
 
   // -mrtd option
   if (Arg *A = Args.getLastArg(OPT_mrtd)) {
     if (Opts.getDefaultCallingConv() != LangOptions::DCC_None)
       Diags.Report(diag::err_drv_argument_not_allowed_with)
           << A->getSpelling() << "-fdefault-calling-conv";
     else {
       llvm::Triple T(TargetOpts.Triple);
       if (T.getArch() != llvm::Triple::x86)
         Diags.Report(diag::err_drv_argument_not_allowed_with)
             << A->getSpelling() << T.getTriple();
       else
         Opts.setDefaultCallingConv(LangOptions::DCC_StdCall);
     }
   }
 
   // Check if -fopenmp is specified and set default version to 4.5.
   Opts.OpenMP = Args.hasArg(options::OPT_fopenmp) ? 45 : 0;
   // Check if -fopenmp-simd is specified.
   bool IsSimdSpecified =
       Args.hasFlag(options::OPT_fopenmp_simd, options::OPT_fno_openmp_simd,
                    /*Default=*/false);
   Opts.OpenMPSimd = !Opts.OpenMP && IsSimdSpecified;
   Opts.OpenMPUseTLS =
       Opts.OpenMP && !Args.hasArg(options::OPT_fnoopenmp_use_tls);
   Opts.OpenMPIsDevice =
       Opts.OpenMP && Args.hasArg(options::OPT_fopenmp_is_device);
   Opts.OpenMPIRBuilder =
       Opts.OpenMP && Args.hasArg(options::OPT_fopenmp_enable_irbuilder);
   bool IsTargetSpecified =
       Opts.OpenMPIsDevice || Args.hasArg(options::OPT_fopenmp_targets_EQ);
 
   if (Opts.OpenMP || Opts.OpenMPSimd) {
     if (int Version = getLastArgIntValue(
             Args, OPT_fopenmp_version_EQ,
             (IsSimdSpecified || IsTargetSpecified) ? 45 : Opts.OpenMP, Diags))
       Opts.OpenMP = Version;
     else if (IsSimdSpecified || IsTargetSpecified)
       Opts.OpenMP = 45;
     // Provide diagnostic when a given target is not expected to be an OpenMP
     // device or host.
     if (!Opts.OpenMPIsDevice) {
       switch (T.getArch()) {
       default:
         break;
       // Add unsupported host targets here:
       case llvm::Triple::nvptx:
       case llvm::Triple::nvptx64:
         Diags.Report(diag::err_drv_omp_host_target_not_supported)
             << TargetOpts.Triple;
         break;
       }
     }
   }
 
   // Set the flag to prevent the implementation from emitting device exception
   // handling code for those requiring so.
   if ((Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN())) ||
       Opts.OpenCLCPlusPlus) {
     Opts.Exceptions = 0;
     Opts.CXXExceptions = 0;
   }
   if (Opts.OpenMPIsDevice && T.isNVPTX()) {
     Opts.OpenMPCUDANumSMs =
         getLastArgIntValue(Args, options::OPT_fopenmp_cuda_number_of_sm_EQ,
                            Opts.OpenMPCUDANumSMs, Diags);
     Opts.OpenMPCUDABlocksPerSM =
         getLastArgIntValue(Args, options::OPT_fopenmp_cuda_blocks_per_sm_EQ,
                            Opts.OpenMPCUDABlocksPerSM, Diags);
     Opts.OpenMPCUDAReductionBufNum = getLastArgIntValue(
         Args, options::OPT_fopenmp_cuda_teams_reduction_recs_num_EQ,
         Opts.OpenMPCUDAReductionBufNum, Diags);
   }
 
   // Prevent auto-widening the representation of loop counters during an
   // OpenMP collapse clause.
   Opts.OpenMPOptimisticCollapse =
       Args.hasArg(options::OPT_fopenmp_optimistic_collapse) ? 1 : 0;
 
   // Get the OpenMP target triples if any.
   if (Arg *A = Args.getLastArg(options::OPT_fopenmp_targets_EQ)) {
 
     for (unsigned i = 0; i < A->getNumValues(); ++i) {
       llvm::Triple TT(A->getValue(i));
 
       if (TT.getArch() == llvm::Triple::UnknownArch ||
           !(TT.getArch() == llvm::Triple::aarch64 ||
             TT.getArch() == llvm::Triple::ppc ||
             TT.getArch() == llvm::Triple::ppc64 ||
             TT.getArch() == llvm::Triple::ppc64le ||
             TT.getArch() == llvm::Triple::nvptx ||
             TT.getArch() == llvm::Triple::nvptx64 ||
             TT.getArch() == llvm::Triple::amdgcn ||
             TT.getArch() == llvm::Triple::x86 ||
             TT.getArch() == llvm::Triple::x86_64))
         Diags.Report(diag::err_drv_invalid_omp_target) << A->getValue(i);
       else
         Opts.OMPTargetTriples.push_back(TT);
     }
   }
 
   // Get OpenMP host file path if any and report if a non existent file is
   // found
   if (Arg *A = Args.getLastArg(options::OPT_fopenmp_host_ir_file_path)) {
     Opts.OMPHostIRFile = A->getValue();
     if (!llvm::sys::fs::exists(Opts.OMPHostIRFile))
       Diags.Report(diag::err_drv_omp_host_ir_file_not_found)
           << Opts.OMPHostIRFile;
   }
 
   // Set CUDA mode for OpenMP target NVPTX/AMDGCN if specified in options
   Opts.OpenMPCUDAMode = Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN()) &&
                         Args.hasArg(options::OPT_fopenmp_cuda_mode);
 
   // Set CUDA mode for OpenMP target NVPTX/AMDGCN if specified in options
   Opts.OpenMPCUDAForceFullRuntime =
       Opts.OpenMPIsDevice && (T.isNVPTX() || T.isAMDGCN()) &&
       Args.hasArg(options::OPT_fopenmp_cuda_force_full_runtime);
 
   // Record whether the __DEPRECATED define was requested.
   Opts.Deprecated = Args.hasFlag(OPT_fdeprecated_macro,
                                  OPT_fno_deprecated_macro,
                                  Opts.Deprecated);
 
   // FIXME: Eliminate this dependency.
   unsigned Opt = getOptimizationLevel(Args, IK, Diags),
        OptSize = getOptimizationLevelSize(Args);
   Opts.Optimize = Opt != 0;
   Opts.OptimizeSize = OptSize != 0;
 
   // This is the __NO_INLINE__ define, which just depends on things like the
   // optimization level and -fno-inline, not actually whether the backend has
   // inlining enabled.
   Opts.NoInlineDefine = !Opts.Optimize;
   if (Arg *InlineArg = Args.getLastArg(
           options::OPT_finline_functions, options::OPT_finline_hint_functions,
           options::OPT_fno_inline_functions, options::OPT_fno_inline))
     if (InlineArg->getOption().matches(options::OPT_fno_inline))
       Opts.NoInlineDefine = true;
 
   Opts.FastMath =
       Args.hasArg(OPT_ffast_math) || Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.FiniteMathOnly = Args.hasArg(OPT_ffinite_math_only) ||
                         Args.hasArg(OPT_ffast_math) ||
                         Args.hasArg(OPT_cl_finite_math_only) ||
                         Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.UnsafeFPMath = Args.hasArg(OPT_menable_unsafe_fp_math) ||
                       Args.hasArg(OPT_ffast_math) ||
                       Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
                       Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.AllowFPReassoc = Args.hasArg(OPT_mreassociate) ||
                         Args.hasArg(OPT_menable_unsafe_fp_math) ||
                         Args.hasArg(OPT_ffast_math) ||
                         Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
                         Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.NoHonorNaNs =
       Args.hasArg(OPT_menable_no_nans) || Args.hasArg(OPT_ffinite_math_only) ||
       Args.hasArg(OPT_ffast_math) || Args.hasArg(OPT_cl_finite_math_only) ||
       Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.NoHonorInfs = Args.hasArg(OPT_menable_no_infinities) ||
                      Args.hasArg(OPT_ffinite_math_only) ||
                      Args.hasArg(OPT_ffast_math) ||
                      Args.hasArg(OPT_cl_finite_math_only) ||
                      Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.NoSignedZero = Args.hasArg(OPT_fno_signed_zeros) ||
                       Args.hasArg(OPT_menable_unsafe_fp_math) ||
                       Args.hasArg(OPT_ffast_math) ||
                       Args.hasArg(OPT_cl_no_signed_zeros) ||
                       Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
                       Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.AllowRecip = Args.hasArg(OPT_freciprocal_math) ||
                     Args.hasArg(OPT_menable_unsafe_fp_math) ||
                     Args.hasArg(OPT_ffast_math) ||
                     Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
                     Args.hasArg(OPT_cl_fast_relaxed_math);
   // Currently there's no clang option to enable this individually
   Opts.ApproxFunc = Args.hasArg(OPT_menable_unsafe_fp_math) ||
                     Args.hasArg(OPT_ffast_math) ||
                     Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
                     Args.hasArg(OPT_cl_fast_relaxed_math);
 
   if (Arg *A = Args.getLastArg(OPT_ffp_contract)) {
     StringRef Val = A->getValue();
     if (Val == "fast")
       Opts.setDefaultFPContractMode(LangOptions::FPM_Fast);
     else if (Val == "on")
       Opts.setDefaultFPContractMode(LangOptions::FPM_On);
     else if (Val == "off")
       Opts.setDefaultFPContractMode(LangOptions::FPM_Off);
     else
       Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;
   }
 
   auto FPRM = llvm::RoundingMode::NearestTiesToEven;
   if (Args.hasArg(OPT_frounding_math)) {
     FPRM = llvm::RoundingMode::Dynamic;
   }
   Opts.setFPRoundingMode(FPRM);
 
   if (Args.hasArg(OPT_ftrapping_math)) {
     Opts.setFPExceptionMode(LangOptions::FPE_Strict);
   }
 
   if (Args.hasArg(OPT_fno_trapping_math)) {
     Opts.setFPExceptionMode(LangOptions::FPE_Ignore);
   }
 
   LangOptions::FPExceptionModeKind FPEB = LangOptions::FPE_Ignore;
   if (Arg *A = Args.getLastArg(OPT_ffp_exception_behavior_EQ)) {
     StringRef Val = A->getValue();
     if (Val.equals("ignore"))
       FPEB = LangOptions::FPE_Ignore;
     else if (Val.equals("maytrap"))
       FPEB = LangOptions::FPE_MayTrap;
     else if (Val.equals("strict"))
       FPEB = LangOptions::FPE_Strict;
     else
       Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;
   }
   Opts.setFPExceptionMode(FPEB);
 
   Opts.RetainCommentsFromSystemHeaders =
       Args.hasArg(OPT_fretain_comments_from_system_headers);
 
   unsigned SSP = getLastArgIntValue(Args, OPT_stack_protector, 0, Diags);
   switch (SSP) {
   default:
     Diags.Report(diag::err_drv_invalid_value)
       << Args.getLastArg(OPT_stack_protector)->getAsString(Args) << SSP;
     break;
   case 0: Opts.setStackProtector(LangOptions::SSPOff); break;
   case 1: Opts.setStackProtector(LangOptions::SSPOn);  break;
   case 2: Opts.setStackProtector(LangOptions::SSPStrong); break;
   case 3: Opts.setStackProtector(LangOptions::SSPReq); break;
   }
 
   if (Arg *A = Args.getLastArg(OPT_ftrivial_auto_var_init)) {
     StringRef Val = A->getValue();
     if (Val == "uninitialized")
       Opts.setTrivialAutoVarInit(
           LangOptions::TrivialAutoVarInitKind::Uninitialized);
     else if (Val == "zero")
       Opts.setTrivialAutoVarInit(LangOptions::TrivialAutoVarInitKind::Zero);
     else if (Val == "pattern")
       Opts.setTrivialAutoVarInit(LangOptions::TrivialAutoVarInitKind::Pattern);
     else
       Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args) << Val;
   }
 
   if (Arg *A = Args.getLastArg(OPT_ftrivial_auto_var_init_stop_after)) {
     int Val = std::stoi(A->getValue());
     Opts.TrivialAutoVarInitStopAfter = Val;
   }
 
   // Parse -fsanitize= arguments.
   parseSanitizerKinds("-fsanitize=", Args.getAllArgValues(OPT_fsanitize_EQ),
                       Diags, Opts.Sanitize);
   // -fsanitize-address-field-padding=N has to be a LangOpt, parse it here.
   Opts.SanitizeAddressFieldPadding =
       getLastArgIntValue(Args, OPT_fsanitize_address_field_padding, 0, Diags);
   Opts.SanitizerBlacklistFiles = Args.getAllArgValues(OPT_fsanitize_blacklist);
   std::vector<std::string> systemBlacklists =
       Args.getAllArgValues(OPT_fsanitize_system_blacklist);
   Opts.SanitizerBlacklistFiles.insert(Opts.SanitizerBlacklistFiles.end(),
                                       systemBlacklists.begin(),
                                       systemBlacklists.end());
 
   // -fxray-instrument
   Opts.XRayInstrument = Args.hasArg(OPT_fxray_instrument);
   Opts.XRayAlwaysEmitCustomEvents =
       Args.hasArg(OPT_fxray_always_emit_customevents);
   Opts.XRayAlwaysEmitTypedEvents =
       Args.hasArg(OPT_fxray_always_emit_typedevents);
 
   // -fxray-{always,never}-instrument= filenames.
   Opts.XRayAlwaysInstrumentFiles =
       Args.getAllArgValues(OPT_fxray_always_instrument);
   Opts.XRayNeverInstrumentFiles =
       Args.getAllArgValues(OPT_fxray_never_instrument);
   Opts.XRayAttrListFiles = Args.getAllArgValues(OPT_fxray_attr_list);
 
   // -fforce-emit-vtables
   Opts.ForceEmitVTables = Args.hasArg(OPT_fforce_emit_vtables);
 
   // -fallow-editor-placeholders
   Opts.AllowEditorPlaceholders = Args.hasArg(OPT_fallow_editor_placeholders);
 
   Opts.RegisterStaticDestructors = !Args.hasArg(OPT_fno_cxx_static_destructors);
 
   if (Arg *A = Args.getLastArg(OPT_fclang_abi_compat_EQ)) {
     Opts.setClangABICompat(LangOptions::ClangABI::Latest);
 
     StringRef Ver = A->getValue();
     std::pair<StringRef, StringRef> VerParts = Ver.split('.');
     unsigned Major, Minor = 0;
 
     // Check the version number is valid: either 3.x (0 <= x <= 9) or
     // y or y.0 (4 <= y <= current version).
     if (!VerParts.first.startswith("0") &&
         !VerParts.first.getAsInteger(10, Major) &&
         3 <= Major && Major <= CLANG_VERSION_MAJOR &&
         (Major == 3 ? VerParts.second.size() == 1 &&
                       !VerParts.second.getAsInteger(10, Minor)
                     : VerParts.first.size() == Ver.size() ||
                       VerParts.second == "0")) {
       // Got a valid version number.
       if (Major == 3 && Minor <= 8)
         Opts.setClangABICompat(LangOptions::ClangABI::Ver3_8);
       else if (Major <= 4)
         Opts.setClangABICompat(LangOptions::ClangABI::Ver4);
       else if (Major <= 6)
         Opts.setClangABICompat(LangOptions::ClangABI::Ver6);
       else if (Major <= 7)
         Opts.setClangABICompat(LangOptions::ClangABI::Ver7);
       else if (Major <= 9)
         Opts.setClangABICompat(LangOptions::ClangABI::Ver9);
     } else if (Ver != "latest") {
       Diags.Report(diag::err_drv_invalid_value)
           << A->getAsString(Args) << A->getValue();
     }
   }
 
   Opts.CompleteMemberPointers = Args.hasArg(OPT_fcomplete_member_pointers);
   Opts.BuildingPCHWithObjectFile = Args.hasArg(OPT_building_pch_with_obj);
 
   Opts.MatrixTypes = Args.hasArg(OPT_fenable_matrix);
 
   Opts.MaxTokens = getLastArgIntValue(Args, OPT_fmax_tokens_EQ, 0, Diags);
 
   if (Arg *A = Args.getLastArg(OPT_msign_return_address_EQ)) {
     StringRef SignScope = A->getValue();
 
     if (SignScope.equals_lower("none"))
       Opts.setSignReturnAddressScope(
           LangOptions::SignReturnAddressScopeKind::None);
     else if (SignScope.equals_lower("all"))
       Opts.setSignReturnAddressScope(
           LangOptions::SignReturnAddressScopeKind::All);
     else if (SignScope.equals_lower("non-leaf"))
       Opts.setSignReturnAddressScope(
           LangOptions::SignReturnAddressScopeKind::NonLeaf);
     else
       Diags.Report(diag::err_drv_invalid_value)
           << A->getAsString(Args) << SignScope;
 
     if (Arg *A = Args.getLastArg(OPT_msign_return_address_key_EQ)) {
       StringRef SignKey = A->getValue();
       if (!SignScope.empty() && !SignKey.empty()) {
         if (SignKey.equals_lower("a_key"))
           Opts.setSignReturnAddressKey(
               LangOptions::SignReturnAddressKeyKind::AKey);
         else if (SignKey.equals_lower("b_key"))
           Opts.setSignReturnAddressKey(
               LangOptions::SignReturnAddressKeyKind::BKey);
         else
           Diags.Report(diag::err_drv_invalid_value)
               << A->getAsString(Args) << SignKey;
       }
     }
   }
 
   Opts.BranchTargetEnforcement = Args.hasArg(OPT_mbranch_target_enforce);
   Opts.SpeculativeLoadHardening = Args.hasArg(OPT_mspeculative_load_hardening);
 
   Opts.CompatibilityQualifiedIdBlockParamTypeChecking =
       Args.hasArg(OPT_fcompatibility_qualified_id_block_param_type_checking);
 
   Opts.RelativeCXXABIVTables =
       Args.hasFlag(OPT_fexperimental_relative_cxx_abi_vtables,
                    OPT_fno_experimental_relative_cxx_abi_vtables,
                    /*default=*/false);
 }
diff --git a/clang/test/AST/ast-dump-openmp-begin-declare-variant_namespace_1.cpp b/clang/test/AST/ast-dump-openmp-begin-declare-variant_namespace_1.cpp
index 3cad174feac0..3c94a8f1c4e2 100644
--- a/clang/test/AST/ast-dump-openmp-begin-declare-variant_namespace_1.cpp
+++ b/clang/test/AST/ast-dump-openmp-begin-declare-variant_namespace_1.cpp
@@ -61,102 +61,104 @@ int implicit2() {
 int main() {
   // Should return 0.
   return explicit1() + implicit2();
 }
 
 // CHECK:      |-NamespaceDecl [[ADDR_0:0x[a-z0-9]*]] <{{.*}}, line:7:1> line:3:11 A
 // CHECK-NEXT: | `-FunctionDecl [[ADDR_1:0x[a-z0-9]*]] <line:4:1, line:6:1> line:4:5 used foo 'int ({{.*}})'
 // CHECK-NEXT: |   `-CompoundStmt [[ADDR_2:0x[a-z0-9]*]] <col:15, line:6:1>
 // CHECK-NEXT: |     `-ReturnStmt [[ADDR_3:0x[a-z0-9]*]] <line:5:3, col:10>
 // CHECK-NEXT: |       `-IntegerLiteral [[ADDR_4:0x[a-z0-9]*]] <col:10> 'int' 0
 // CHECK-NEXT: |-NamespaceDecl [[ADDR_5:0x[a-z0-9]*]] <line:9:1, line:13:1> line:9:11 B
 // CHECK-NEXT: | `-FunctionDecl [[ADDR_6:0x[a-z0-9]*]] <line:10:1, line:12:1> line:10:5 used bar 'int ({{.*}})'
 // CHECK-NEXT: |   |-CompoundStmt [[ADDR_7:0x[a-z0-9]*]] <col:15, line:12:1>
 // CHECK-NEXT: |   | `-ReturnStmt [[ADDR_8:0x[a-z0-9]*]] <line:11:3, col:10>
 // CHECK-NEXT: |   |   `-IntegerLiteral [[ADDR_9:0x[a-z0-9]*]] <col:10> 'int' 1
 // CHECK-NEXT: |   `-OMPDeclareVariantAttr [[ADDR_10:0x[a-z0-9]*]] <<invalid sloc>> Implicit implementation={vendor(llvm)}
 // CHECK-NEXT: |     `-DeclRefExpr [[ADDR_11:0x[a-z0-9]*]] <line:34:1> 'int ({{.*}})' Function [[ADDR_12:0x[a-z0-9]*]] 'bar[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |-NamespaceDecl [[ADDR_13:0x[a-z0-9]*]] <line:15:1, line:19:1> line:15:11 C
 // CHECK-NEXT: | `-FunctionDecl [[ADDR_14:0x[a-z0-9]*]] <line:16:1, line:18:1> line:16:5 used baz 'int ({{.*}})'
 // CHECK-NEXT: |   |-CompoundStmt [[ADDR_15:0x[a-z0-9]*]] <col:15, line:18:1>
 // CHECK-NEXT: |   | `-ReturnStmt [[ADDR_16:0x[a-z0-9]*]] <line:17:3, col:10>
 // CHECK-NEXT: |   |   `-IntegerLiteral [[ADDR_17:0x[a-z0-9]*]] <col:10> 'int' 2
 // CHECK-NEXT: |   `-OMPDeclareVariantAttr [[ADDR_18:0x[a-z0-9]*]] <<invalid sloc>> Implicit implementation={vendor(llvm)}
 // CHECK-NEXT: |     `-DeclRefExpr [[ADDR_19:0x[a-z0-9]*]] <line:42:1> 'int ({{.*}})' Function [[ADDR_20:0x[a-z0-9]*]] 'baz[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |-FunctionDecl [[ADDR_21:0x[a-z0-9]*]] <line:24:1, col:13> col:5 implicit foo 'int ({{.*}})'
 // CHECK-NEXT: | |-OMPDeclareVariantAttr [[ADDR_22:0x[a-z0-9]*]] <<invalid sloc>> Implicit implementation={vendor(llvm)}
 // CHECK-NEXT: | | `-DeclRefExpr [[ADDR_23:0x[a-z0-9]*]] <col:1> 'int ({{.*}})' Function [[ADDR_24:0x[a-z0-9]*]] 'foo[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: | `-OMPDeclareVariantAttr [[ADDR_25:0x[a-z0-9]*]] <<invalid sloc>> Implicit implementation={vendor(llvm)}
 // CHECK-NEXT: |   `-DeclRefExpr [[ADDR_26:0x[a-z0-9]*]] <line:30:1> 'int ({{.*}})' Function [[ADDR_27:0x[a-z0-9]*]] 'foo[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |-FunctionDecl [[ADDR_24]] <line:24:1, line:26:1> line:24:1 foo[implementation={vendor(llvm)}] 'int ({{.*}})'
 // CHECK-NEXT: | `-CompoundStmt [[ADDR_28:0x[a-z0-9]*]] <col:15, line:26:1>
 // CHECK-NEXT: |   `-ReturnStmt [[ADDR_29:0x[a-z0-9]*]] <line:25:3, col:10>
 // CHECK-NEXT: |     `-IntegerLiteral [[ADDR_30:0x[a-z0-9]*]] <col:10> 'int' 3
 // CHECK-NEXT: |-NamespaceDecl [[ADDR_31:0x[a-z0-9]*]] prev [[ADDR_5]] <line:28:1, line:37:1> line:28:11 B
 // CHECK-NEXT: | |-original Namespace [[ADDR_5]] 'B'
 // CHECK-NEXT: | |-FunctionDecl [[ADDR_27]] <line:30:1, line:32:1> line:30:1 foo[implementation={vendor(llvm)}] 'int ({{.*}})'
 // CHECK-NEXT: | | `-CompoundStmt [[ADDR_32:0x[a-z0-9]*]] <col:15, line:32:1>
 // CHECK-NEXT: | |   `-ReturnStmt [[ADDR_33:0x[a-z0-9]*]] <line:31:3, col:10>
 // CHECK-NEXT: | |     `-IntegerLiteral [[ADDR_34:0x[a-z0-9]*]] <col:10> 'int' 4
 // CHECK-NEXT: | `-FunctionDecl [[ADDR_12]] <line:34:1, line:36:1> line:34:1 bar[implementation={vendor(llvm)}] 'int ({{.*}})'
 // CHECK-NEXT: |   `-CompoundStmt [[ADDR_35:0x[a-z0-9]*]] <col:15, line:36:1>
 // CHECK-NEXT: |     `-ReturnStmt [[ADDR_36:0x[a-z0-9]*]] <line:35:3, col:10>
 // CHECK-NEXT: |       `-IntegerLiteral [[ADDR_37:0x[a-z0-9]*]] <col:10> 'int' 0
 // CHECK-NEXT: |-UsingDirectiveDecl [[ADDR_38:0x[a-z0-9]*]] <line:39:1, col:17> col:17 Namespace [[ADDR_13]] 'C'
 // CHECK-NEXT: |-FunctionDecl [[ADDR_20]] <line:42:1, line:44:1> line:42:1 baz[implementation={vendor(llvm)}] 'int ({{.*}})'
 // CHECK-NEXT: | `-CompoundStmt [[ADDR_39:0x[a-z0-9]*]] <col:15, line:44:1>
 // CHECK-NEXT: |   `-ReturnStmt [[ADDR_40:0x[a-z0-9]*]] <line:43:3, col:10>
 // CHECK-NEXT: |     `-IntegerLiteral [[ADDR_41:0x[a-z0-9]*]] <col:10> 'int' 0
 // CHECK-NEXT: |-FunctionDecl [[ADDR_42:0x[a-z0-9]*]] <line:48:1, line:51:1> line:48:5 used explicit1 'int ({{.*}})'
 // CHECK-NEXT: | `-CompoundStmt [[ADDR_43:0x[a-z0-9]*]] <col:17, line:51:1>
 // CHECK-NEXT: |   `-ReturnStmt [[ADDR_44:0x[a-z0-9]*]] <line:50:3, col:39>
 // CHECK-NEXT: |     `-BinaryOperator [[ADDR_45:0x[a-z0-9]*]] <col:10, col:39> 'int' '+'
 // CHECK-NEXT: |       |-BinaryOperator [[ADDR_46:0x[a-z0-9]*]] <col:10, col:28> 'int' '+'
 // CHECK-NEXT: |       | |-CallExpr [[ADDR_47:0x[a-z0-9]*]] <col:10, col:17> 'int'
 // CHECK-NEXT: |       | | `-ImplicitCastExpr [[ADDR_48:0x[a-z0-9]*]] <col:10, col:13> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |       | |   `-DeclRefExpr [[ADDR_49:0x[a-z0-9]*]] <col:10, col:13> 'int ({{.*}})' {{.*}}Function [[ADDR_1]] 'foo' 'int ({{.*}})'
 // CHECK-NEXT: |       | `-PseudoObjectExpr [[ADDR_50:0x[a-z0-9]*]] <col:21, col:28> 'int'
 // CHECK-NEXT: |       |   |-CallExpr [[ADDR_51:0x[a-z0-9]*]] <col:21, col:28> 'int'
 // CHECK-NEXT: |       |   | `-ImplicitCastExpr [[ADDR_52:0x[a-z0-9]*]] <col:21, col:24> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |       |   |   `-DeclRefExpr [[ADDR_53:0x[a-z0-9]*]] <col:21, col:24> 'int ({{.*}})' {{.*}}Function [[ADDR_6]] 'bar' 'int ({{.*}})'
 // CHECK-NEXT: |       |   `-CallExpr [[ADDR_54:0x[a-z0-9]*]] <line:34:1, line:50:28> 'int'
 // CHECK-NEXT: |       |     `-ImplicitCastExpr [[ADDR_55:0x[a-z0-9]*]] <line:34:1> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |       |       `-DeclRefExpr [[ADDR_11]] <col:1> 'int ({{.*}})' Function [[ADDR_12]] 'bar[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |       `-PseudoObjectExpr [[ADDR_56:0x[a-z0-9]*]] <line:50:32, col:39> 'int'
 // CHECK-NEXT: |         |-CallExpr [[ADDR_57:0x[a-z0-9]*]] <col:32, col:39> 'int'
 // CHECK-NEXT: |         | `-ImplicitCastExpr [[ADDR_58:0x[a-z0-9]*]] <col:32, col:35> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |         |   `-DeclRefExpr [[ADDR_59:0x[a-z0-9]*]] <col:32, col:35> 'int ({{.*}})' {{.*}}Function [[ADDR_14]] 'baz' 'int ({{.*}})'
 // CHECK-NEXT: |         `-CallExpr [[ADDR_60:0x[a-z0-9]*]] <line:42:1, line:50:39> 'int'
 // CHECK-NEXT: |           `-ImplicitCastExpr [[ADDR_61:0x[a-z0-9]*]] <line:42:1> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |             `-DeclRefExpr [[ADDR_19]] <col:1> 'int ({{.*}})' Function [[ADDR_20]] 'baz[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |-FunctionDecl [[ADDR_62:0x[a-z0-9]*]] <line:53:1, line:59:1> line:53:5 used implicit2 'int ({{.*}})'
 // CHECK-NEXT: | `-CompoundStmt [[ADDR_63:0x[a-z0-9]*]] <col:17, line:59:1>
 // CHECK-NEXT: |   |-DeclStmt [[ADDR_64:0x[a-z0-9]*]] <line:54:3, col:20>
 // CHECK-NEXT: |   | `-UsingDirectiveDecl [[ADDR_65:0x[a-z0-9]*]] <col:3, col:19> col:19 Namespace [[ADDR_0]] 'A'
 // CHECK-NEXT: |   |-DeclStmt [[ADDR_66:0x[a-z0-9]*]] <line:55:3, col:20>
 // CHECK-NEXT: |   | `-UsingDirectiveDecl [[ADDR_67:0x[a-z0-9]*]] <col:3, col:19> col:19 Namespace [[ADDR_5]] 'B'
+// CHECK-NEXT: |   |-RecoveryExpr {{.*}} <line:57:3, col:7>
+// CHECK-NEXT: |   | `-UnresolvedLookupExpr {{.*}} <col:3>
 // CHECK-NEXT: |   `-ReturnStmt [[ADDR_68:0x[a-z0-9]*]] <line:58:3, col:22>
 // CHECK-NEXT: |     `-BinaryOperator [[ADDR_69:0x[a-z0-9]*]] <col:10, col:22> 'int' '+'
 // CHECK-NEXT: |       |-PseudoObjectExpr [[ADDR_70:0x[a-z0-9]*]] <col:10, col:14> 'int'
 // CHECK-NEXT: |       | |-CallExpr [[ADDR_71:0x[a-z0-9]*]] <col:10, col:14> 'int'
 // CHECK-NEXT: |       | | `-ImplicitCastExpr [[ADDR_72:0x[a-z0-9]*]] <col:10> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |       | |   `-DeclRefExpr [[ADDR_73:0x[a-z0-9]*]] <col:10> 'int ({{.*}})' {{.*}}Function [[ADDR_6]] 'bar' 'int ({{.*}})'
 // CHECK-NEXT: |       | `-CallExpr [[ADDR_74:0x[a-z0-9]*]] <line:34:1, line:58:14> 'int'
 // CHECK-NEXT: |       |   `-ImplicitCastExpr [[ADDR_75:0x[a-z0-9]*]] <line:34:1> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |       |     `-DeclRefExpr [[ADDR_11]] <col:1> 'int ({{.*}})' Function [[ADDR_12]] 'bar[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: |       `-PseudoObjectExpr [[ADDR_76:0x[a-z0-9]*]] <line:58:18, col:22> 'int'
 // CHECK-NEXT: |         |-CallExpr [[ADDR_77:0x[a-z0-9]*]] <col:18, col:22> 'int'
 // CHECK-NEXT: |         | `-ImplicitCastExpr [[ADDR_78:0x[a-z0-9]*]] <col:18> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |         |   `-DeclRefExpr [[ADDR_79:0x[a-z0-9]*]] <col:18> 'int ({{.*}})' {{.*}}Function [[ADDR_14]] 'baz' 'int ({{.*}})'
 // CHECK-NEXT: |         `-CallExpr [[ADDR_80:0x[a-z0-9]*]] <line:42:1, line:58:22> 'int'
 // CHECK-NEXT: |           `-ImplicitCastExpr [[ADDR_81:0x[a-z0-9]*]] <line:42:1> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT: |             `-DeclRefExpr [[ADDR_19]] <col:1> 'int ({{.*}})' Function [[ADDR_20]] 'baz[implementation={vendor(llvm)}]' 'int ({{.*}})'
 // CHECK-NEXT: `-FunctionDecl [[ADDR_82:0x[a-z0-9]*]] <line:61:1, line:64:1> line:61:5 main 'int ({{.*}})'
 // CHECK-NEXT:   `-CompoundStmt [[ADDR_83:0x[a-z0-9]*]] <col:12, line:64:1>
 // CHECK-NEXT:     `-ReturnStmt [[ADDR_84:0x[a-z0-9]*]] <line:63:3, col:34>
 // CHECK-NEXT:       `-BinaryOperator [[ADDR_85:0x[a-z0-9]*]] <col:10, col:34> 'int' '+'
 // CHECK-NEXT:         |-CallExpr [[ADDR_86:0x[a-z0-9]*]] <col:10, col:20> 'int'
 // CHECK-NEXT:         | `-ImplicitCastExpr [[ADDR_87:0x[a-z0-9]*]] <col:10> 'int (*)({{.*}})' <FunctionToPointerDecay>
 // CHECK-NEXT:         |   `-DeclRefExpr [[ADDR_88:0x[a-z0-9]*]] <col:10> 'int ({{.*}})' {{.*}}Function [[ADDR_42]] 'explicit1' 'int ({{.*}})'
 // CHECK-NEXT:         `-CallExpr [[ADDR_89:0x[a-z0-9]*]] <col:24, col:34> 'int'
 // CHECK-NEXT:           `-ImplicitCastExpr [[ADDR_90:0x[a-z0-9]*]] <col:24> 'int (*)({{.*}})' <FunctionToPointerDecay>
-// CHECK-NEXT:             `-DeclRefExpr [[ADDR_91:0x[a-z0-9]*]] <col:24> 'int ({{.*}})' {{.*}}Function [[ADDR_62]] 'implicit2' 'int ({{.*}})'
+// CHECK-NEXT:             `-DeclRefExpr [[ADDR_91:0x[a-z0-9]*]] <col:24> 'int ({{.*}})' {{.*}}Function [[ADDR_62]] 'implicit2' 'int ({{.*}})'
\ No newline at end of file
diff --git a/clang/test/CXX/class.access/p4.cpp b/clang/test/CXX/class.access/p4.cpp
index b110683f0be8..adc8bbe29583 100644
--- a/clang/test/CXX/class.access/p4.cpp
+++ b/clang/test/CXX/class.access/p4.cpp
@@ -130,137 +130,135 @@ namespace test2 {
 // Implicit destructor calls.
 namespace test3 {
   class A {
   private:
     ~A(); // expected-note 2 {{declared private here}}
     static A foo;
   };
 
   A a; // expected-error {{variable of type 'test3::A' has private destructor}}
   A A::foo;
 
   void foo(A param) { // okay
     A local; // expected-error {{variable of type 'test3::A' has private destructor}}
   }
 
 #if __cplusplus < 201103L && !defined(_MSC_VER)
   template <unsigned N> class Base { ~Base(); }; // expected-note 14 {{declared private here}}
   class Base2 : virtual Base<2> { ~Base2(); }; // expected-note 3 {{declared private here}} \
                                                // expected-error {{base class 'Base<2>' has private destructor}}
   class Base3 : virtual Base<3> { public: ~Base3(); }; // expected-error {{base class 'Base<3>' has private destructor}}
 
   // These don't cause diagnostics because we don't need the destructor.
   class Derived0 : Base<0> { ~Derived0(); };
   class Derived1 : Base<1> { };
 
   class Derived2 : // expected-error {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error {{inherited virtual base class 'Base<3>' has private destructor}}
     Base<0>,  // expected-error {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {
     ~Derived2() {}
   };
 
   class Derived3 : // expected-error 2 {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error 2 {{inherited virtual base class 'Base<3>' has private destructor}} \
                    // expected-note 2{{implicit default constructor}}
     Base<0>,  // expected-error 2 {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error 2 {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error 2 {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {};
   Derived3 d3; // expected-note{{implicit destructor}}} \
       // expected-note 3 {{implicit default constructor}}
 #elif __cplusplus < 201103L && defined(_MSC_VER)
   template <unsigned N> class Base { ~Base(); }; // expected-note 14 {{declared private here}}
   class Base2 : virtual Base<2> { ~Base2(); }; // expected-note 3 {{declared private here}} \
                                                // expected-error {{base class 'Base<2>' has private destructor}}
   class Base3 : virtual Base<3> { public: ~Base3(); }; // expected-error {{base class 'Base<3>' has private destructor}}
 
   // These don't cause diagnostics because we don't need the destructor.
   class Derived0 : Base<0> { ~Derived0(); };
   class Derived1 : Base<1> { };
 
   class Derived2 : // expected-error {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error {{inherited virtual base class 'Base<3>' has private destructor}}
     Base<0>,  // expected-error {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {
     ~Derived2() {} // expected-note 2{{in implicit destructor}}
   };
 
   class Derived3 : // expected-error 2 {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error 2 {{inherited virtual base class 'Base<3>' has private destructor}}
     Base<0>,  // expected-error 2 {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error 2 {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error 2 {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {};
   Derived3 d3; // expected-note{{implicit destructor}}} expected-note {{implicit default constructor}}
 #elif __cplusplus >= 201103L && !defined(_MSC_VER)
   template <unsigned N> class Base { ~Base(); }; // expected-note 4{{declared private here}}
   class Base2 : virtual Base<2> { ~Base2(); }; // expected-note 1{{declared private here}}
   class Base3 : virtual Base<3> { public: ~Base3(); };
 
   // These don't cause diagnostics because we don't need the destructor.
   class Derived0 : Base<0> { ~Derived0(); };
   class Derived1 : Base<1> { };
 
   class Derived2 : // expected-error {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error {{inherited virtual base class 'Base<3>' has private destructor}}
     Base<0>,  // expected-error {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {
     ~Derived2() {}
   };
 
   class Derived3 :
-    Base<0>, // expected-note 2{{deleted because base class 'Base<0>' has an inaccessible destructor}}
+    Base<0>, // expected-note {{deleted because base class 'Base<0>' has an inaccessible destructor}}
     virtual Base<1>,
     Base2,
     virtual Base3
   {};
-  Derived3 d3; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+  Derived3 d3; // expected-error {{implicitly-deleted default constructor}}
 #elif __cplusplus >= 201103L && defined(_MSC_VER)
-  template <unsigned N> class Base { ~Base(); }; // expected-note 9{{declared private here}}
+  template <unsigned N> class Base { ~Base(); }; // expected-note 6{{declared private here}}
   // expected-error@+1 {{inherited virtual base class 'Base<2>' has private destructor}}
   class Base2 : virtual Base<2> { ~Base2(); }; // expected-note 1{{declared private here}}
   // expected-error@+1 {{inherited virtual base class 'Base<3>' has private destructor}}
   class Base3 : virtual Base<3> { public: ~Base3(); };
 
   // These don't cause diagnostics because we don't need the destructor.
   class Derived0 : Base<0> { ~Derived0(); };
   class Derived1 : Base<1> { };
 
   class Derived2 : // expected-error {{inherited virtual base class 'Base<2>' has private destructor}} \
                    // expected-error {{inherited virtual base class 'Base<3>' has private destructor}}
     Base<0>,  // expected-error {{base class 'Base<0>' has private destructor}}
     virtual Base<1>, // expected-error {{base class 'Base<1>' has private destructor}}
     Base2, // expected-error {{base class 'test3::Base2' has private destructor}}
     virtual Base3
   {
     // expected-note@+2 {{in implicit destructor for 'test3::Base2' first required here}}
     // expected-note@+1 {{in implicit destructor for 'test3::Base3' first required here}}
     ~Derived2() {}
   };
 
-  class Derived3 : // expected-error 3{{has private destructor}}
+  class Derived3 :
     Base<0>, // expected-note {{deleted because base class 'Base<0>' has an inaccessible destructor}}
-             // expected-note@-1 {{destructor of 'Derived3' is implicitly deleted}}
     virtual Base<1>,
     Base2,
     virtual Base3
   {};
-  Derived3 d3; // expected-error {{implicitly-deleted default constructor}} expected-error {{use a deleted function}}
-               // expected-note@-1 {{implicit destructor for}}
+  Derived3 d3; // expected-error {{implicitly-deleted default constructor}}
 #else
 #error "missing case of MSVC cross C++ versions"
 #endif
 }
 
 // Conversion functions.
diff --git a/clang/test/CXX/special/class.ctor/p5-0x.cpp b/clang/test/CXX/special/class.ctor/p5-0x.cpp
index 3026f095ef8a..5fa61008e8b7 100644
--- a/clang/test/CXX/special/class.ctor/p5-0x.cpp
+++ b/clang/test/CXX/special/class.ctor/p5-0x.cpp
@@ -4,7 +4,7 @@ struct DefaultedDefCtor1 {};
 struct DefaultedDefCtor2 { DefaultedDefCtor2() = default; };
 struct DeletedDefCtor { DeletedDefCtor() = delete; DeletedDefCtor(int); }; // expected-note {{explicitly marked deleted here}}
 class PrivateDefCtor { PrivateDefCtor() = default; public: PrivateDefCtor(int); };
-struct DeletedDtor { ~DeletedDtor() = delete; }; // expected-note 8{{explicitly marked deleted here}}
+struct DeletedDtor { ~DeletedDtor() = delete; }; // expected-note 4{{explicitly marked deleted here}}
 class PrivateDtor { ~PrivateDtor() = default; };
 class Friend {
   Friend() = default; ~Friend() = default;
@@ -122,22 +122,22 @@ NotDeleted6c nd6c;
 // - any direct or virtual base class or non-static data member has a type with
 // a destructor that is deleted or inaccessible from the defaulted default
 // constructor.
-struct Deleted7a : DeletedDtor {}; // expected-note 2{{because base class 'DeletedDtor' has a deleted destructor}}
-Deleted7a d7a; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7b : virtual DeletedDtor {}; // expected-note 2{{because base class 'DeletedDtor' has a deleted destructor}}
-Deleted7b d7b; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7c { DeletedDtor a; }; // expected-note 2{{because field 'a' has a deleted destructor}}
-Deleted7c d7c; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7d { DeletedDtor a = {}; }; // expected-note 2{{because field 'a' has a deleted destructor}}
-Deleted7d d7d; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7e : PrivateDtor {}; // expected-note 2{{base class 'PrivateDtor' has an inaccessible destructor}}
-Deleted7e d7e; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7f : virtual PrivateDtor {}; // expected-note 2{{base class 'PrivateDtor' has an inaccessible destructor}}
-Deleted7f d7f; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7g { PrivateDtor a; }; // expected-note 2{{field 'a' has an inaccessible destructor}}
-Deleted7g d7g; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct Deleted7h { PrivateDtor a = {}; }; // expected-note 2{{field 'a' has an inaccessible destructor}}
-Deleted7h d7h; // expected-error {{implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+struct Deleted7a : DeletedDtor {}; // expected-note {{because base class 'DeletedDtor' has a deleted destructor}}
+Deleted7a d7a; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7b : virtual DeletedDtor {}; // expected-note {{because base class 'DeletedDtor' has a deleted destructor}}
+Deleted7b d7b; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7c { DeletedDtor a; }; // expected-note {{because field 'a' has a deleted destructor}}
+Deleted7c d7c; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7d { DeletedDtor a = {}; }; // expected-note {{because field 'a' has a deleted destructor}}
+Deleted7d d7d; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7e : PrivateDtor {}; // expected-note {{base class 'PrivateDtor' has an inaccessible destructor}}
+Deleted7e d7e; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7f : virtual PrivateDtor {}; // expected-note {{base class 'PrivateDtor' has an inaccessible destructor}}
+Deleted7f d7f; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7g { PrivateDtor a; }; // expected-note {{field 'a' has an inaccessible destructor}}
+Deleted7g d7g; // expected-error {{implicitly-deleted default constructor}}
+struct Deleted7h { PrivateDtor a = {}; }; // expected-note {{field 'a' has an inaccessible destructor}}
+Deleted7h d7h; // expected-error {{implicitly-deleted default constructor}}
 struct NotDeleted7i : Friend {};
 NotDeleted7i d7i;
 struct NotDeleted7j : virtual Friend {};
diff --git a/clang/test/CXX/stmt.stmt/stmt.iter/stmt.ranged/p1.cpp b/clang/test/CXX/stmt.stmt/stmt.iter/stmt.ranged/p1.cpp
index 494f001a9cde..01c758bef19a 100644
--- a/clang/test/CXX/stmt.stmt/stmt.iter/stmt.ranged/p1.cpp
+++ b/clang/test/CXX/stmt.stmt/stmt.iter/stmt.ranged/p1.cpp
@@ -17,50 +17,51 @@ struct null_t {
 namespace X {
   template<typename T>
     auto begin(T &&t) -> decltype(t.begin()) { return t.begin(); } // expected-note 2{{ignored: substitution failure}}
   template<typename T>
     auto end(T &&t) -> decltype(t.end()) { return t.end(); } // expected-note {{candidate template ignored: substitution failure [with T = }}
 
   template<typename T>
-    auto begin(T &&t) -> decltype(t.alt_begin()) { return t.alt_begin(); } // expected-note 2{{candidate template ignored: substitution failure [with T = }}
+    auto begin(T &&t) -> decltype(t.alt_begin()) { return t.alt_begin(); } // expected-note {{selected 'begin' template [with T = }} \
+                                                                           // expected-note 2{{candidate template ignored: substitution failure [with T = }}
   template<typename T>
     auto end(T &&t) -> decltype(t.alt_end()) { return t.alt_end(); } // expected-note {{candidate template ignored: substitution failure [with T = }}
 
   namespace inner {
     // These should never be considered.
     int begin(int);
     int end(int);
   }
 
   using namespace inner;
 
   struct A { // expected-note 2 {{candidate constructor}}
     A();
-    int *begin(); // expected-note {{selected 'begin' function with iterator type 'int *'}} expected-note {{'begin' declared here}}
+    int *begin(); // expected-note 3{{selected 'begin' function with iterator type 'int *'}} expected-note {{'begin' declared here}}
     int *end();
   };
 
   struct B {
     B();
     int *alt_begin();
     int *alt_end();
   };
 
   struct NoBeginADL {
     null_t alt_end();
   };
   struct NoEndADL {
     null_t alt_begin();
   };
 
   struct C {
     C();
     struct It {
       int val;
       operator int &() { return val; }
     };
     It begin();
     It end();
   };
 
   constexpr int operator*(const C::It &) { return 0; }
 }
diff --git a/clang/test/OpenMP/declare_variant_messages.cpp b/clang/test/OpenMP/declare_variant_messages.cpp
index f8271c999de3..ab683606b790 100644
--- a/clang/test/OpenMP/declare_variant_messages.cpp
+++ b/clang/test/OpenMP/declare_variant_messages.cpp
@@ -11,81 +11,81 @@ template <typename T>
 T foofoo();
 
 #pragma omp declare variant // expected-error {{expected '(' after 'declare variant'}}
 #pragma omp declare variant( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foo // expected-error {{expected ')'}} expected-error {{expected 'match' clause on 'omp declare variant' directive}} expected-note {{to match this '('}}
-#pragma omp declare variant(x) // expected-error {{use of undeclared identifier 'x'}}
+#pragma omp declare variant(x) // expected-error {{use of undeclared identifier 'x'}} expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foo) // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <int>) // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <int>) xxx // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <int>) match // expected-error {{expected '(' after 'match'}}
 #pragma omp declare variant(foofoo <int>) match( // expected-error {{expected ')'}} expected-warning {{expected identifier or string literal describing a context set; set skipped}} expected-note {{context set options are: 'construct' 'device' 'implementation' 'user'}} expected-note {{the ignored set spans until here}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match() // expected-warning {{expected identifier or string literal describing a context set; set skipped}} expected-note {{context set options are: 'construct' 'device' 'implementation' 'user'}} expected-note {{the ignored set spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation) // expected-warning {{expected '=' after the context set name "implementation"; '=' assumed}} expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation =) // expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = yyy) // expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{'yyy' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = yyy }) // expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{'yyy' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = {) // expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = {}) // expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = {vvv, vvv}) // expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation = {vvv} implementation) // expected-error {{expected ')'}} expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation = {vvv}) implementation // expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={xxx}) // expected-warning {{'xxx' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor}) // expected-warning {{the context selector 'vendor' in context set 'implementation' requires a context property defined in parentheses; selector ignored}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(}) // expected-error {{expected ')'}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor()}) // expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score ibm)}) // expected-error {{expected '(' after 'score'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(2 ibm)}) // expected-error {{expected ')'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{to match this '('}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(foofoo <int>()) ibm)}) // expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{score expressions in the OpenMP context selector need to be constant; foofoo<int>() is not and will be ignored}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(5): ibm), vendor(llvm)}) // expected-warning {{the context selector 'vendor' was used already in the same 'omp declare variant' directive; selector ignored}} expected-note {{the previous context selector 'vendor' used here}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(5): ibm), kind(cpu)}) // expected-warning {{the context selector 'kind' is not valid for the context set 'implementation'; selector ignored}} expected-note {{the context selector 'kind' can be nested in the context set 'device'; try 'match(device={kind(property)})'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={xxx}) // expected-warning {{'xxx' is not a valid context selector for the context set 'device'; selector ignored}} expected-note {{context selector options are: 'kind' 'isa' 'arch'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind}) // expected-warning {{the context selector 'kind' in context set 'device' requires a context property defined in parentheses; selector ignored}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(}) // expected-error {{expected ')'}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind()}) // expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score cpu)}) // expected-error {{expected '(' after 'score'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('<invalid>'); score ignored}}
-#pragma omp declare variant(foofoo <int>) match(device={kind(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('<invalid>'); score ignored}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
+#pragma omp declare variant(foofoo <int>) match(device={kind(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(2 gpu)}) // expected-error {{expected ')'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('2'); score ignored}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{to match this '('}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(foofoo <int>()) ibm)}) // expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('foofoo<int>()'); score ignored}} expected-warning {{'ibm' is not a valid context property for the context selector 'kind' and the context set 'device'; property ignored}} expected-note {{try 'match(implementation={vendor(ibm)})'}} expected-note {{the ignored property spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(5): host), kind(llvm)}) // expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('5'); score ignored}} expected-warning {{the context selector 'kind' was used already in the same 'omp declare variant' directive; selector ignored}} expected-note {{the previous context selector 'kind' used here}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(5): nohost), vendor(llvm)}) // expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('5'); score ignored}} expected-warning {{the context selector 'vendor' is not valid for the context set 'device'; selector ignored}} expected-note {{the context selector 'vendor' can be nested in the context set 'implementation'; try 'match(implementation={vendor(property)})'}} expected-note {{the ignored selector spans until here}}
 int bar();
 
 #pragma omp declare variant // expected-error {{expected '(' after 'declare variant'}}
 #pragma omp declare variant( // expected-error {{expected expression}} expected-error {{expected ')'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <T> // expected-error {{expected ')'}} expected-error {{expected 'match' clause on 'omp declare variant' directive}} expected-note {{to match this '('}}
-#pragma omp declare variant(x) // expected-error {{use of undeclared identifier 'x'}}
+#pragma omp declare variant(x) // expected-error {{use of undeclared identifier 'x'}} expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foo) // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo) // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <T>) // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <T>) xxx // expected-error {{expected 'match' clause on 'omp declare variant' directive}}
 #pragma omp declare variant(foofoo <T>) match // expected-error {{expected '(' after 'match'}}
 #pragma omp declare variant(foofoo <T>) match( // expected-error {{expected ')'}} expected-warning {{expected identifier or string literal describing a context set; set skipped}} expected-note {{context set options are: 'construct' 'device' 'implementation' 'user'}} expected-note {{the ignored set spans until here}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <T>) match() // expected-warning {{expected identifier or string literal describing a context set; set skipped}} expected-note {{context set options are: 'construct' 'device' 'implementation' 'user'}} expected-note {{the ignored set spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation) // expected-warning {{expected '=' after the context set name "implementation"; '=' assumed}} expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation =) // expected-warning {{expected '{' after the '=' that follows the context set name "implementation"; '{' assumed}} expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation = {) // expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-warning {{expected '}' after the context selectors for the context set "implementation"; '}' assumed}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation = {}) // expected-warning {{expected identifier or string literal describing a context selector; selector skipped}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation = {vvv, vvv}) // expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(user = {score(<expr>) : condition(<expr>)}) // expected-warning {{'score' is not a valid context selector for the context set 'user'; selector ignored}} expected-note {{context selector options are: 'condition'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(user = {score(<expr>) : condition(<expr>)}) // expected-warning {{'score' is not a valid context selector for the context set 'user'; selector ignored}} expected-note {{context selector options are: 'condition'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(user = {condition(<expr>)}) // expected-error {{expected expression}} expected-error {{use of undeclared identifier 'expr'}} expected-error {{expected expression}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(user = {condition(<expr>)}) // expected-error {{expected expression}} expected-error {{use of undeclared identifier 'expr'}} expected-error {{expected expression}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <T>) match(implementation = {vvv} implementation) // expected-error {{expected ')'}} expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <T>) match(implementation = {vvv}) xxx // expected-warning {{'vvv' is not a valid context selector for the context set 'implementation'; selector ignored}} expected-note {{context selector options are: 'vendor' 'extension' 'unified_address' 'unified_shared_memory' 'reverse_offload' 'dynamic_allocators' 'atomic_default_mem_order'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score ibm)}) // expected-error {{expected '(' after 'score'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(C ibm)}) // expected-error {{expected ')'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{to match this '('}} expected-note {{context property options are: 'amd' 'arm' 'bsc' 'cray' 'fujitsu' 'gnu' 'ibm' 'intel' 'llvm' 'pgi' 'ti' 'unknown'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(foofoo <int>()) ibm)}) // expected-warning {{expected '':'' after the score expression; '':'' assumed}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(C+5): ibm), vendor(llvm)}) // expected-warning {{the context selector 'vendor' was used already in the same 'omp declare variant' directive; selector ignored}} expected-note {{the previous context selector 'vendor' used here}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(implementation={vendor(score(5): ibm), kind(cpu)}) // expected-warning {{the context selector 'kind' is not valid for the context set 'implementation'; selector ignored}} expected-note {{the context selector 'kind' can be nested in the context set 'device'; try 'match(device={kind(property)})'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={xxx}) // expected-warning {{'xxx' is not a valid context selector for the context set 'device'; selector ignored}} expected-note {{context selector options are: 'kind' 'isa' 'arch'}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind}) // expected-warning {{the context selector 'kind' in context set 'device' requires a context property defined in parentheses; selector ignored}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(}) // expected-error {{expected ')'}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind()}) // expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score cpu)}) // expected-error {{expected '(' after 'score'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('<invalid>'); score ignored}}
-#pragma omp declare variant(foofoo <int>) match(device={kind(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('<invalid>'); score ignored}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
+#pragma omp declare variant(foofoo <int>) match(device={kind(score( ibm)}) // expected-error {{use of undeclared identifier 'ibm'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(C gpu)}) // expected-error {{expected ')'}} expected-error {{expected ')'}} expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('C'); score ignored}} expected-warning {{expected identifier or string literal describing a context property; property skipped}} expected-note {{to match this '('}} expected-note {{context property options are: 'host' 'nohost' 'cpu' 'gpu' 'fpga' 'any'}} expected-note {{to match this '('}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(foofoo <int>()) ibm)}) // expected-warning {{expected '':'' after the score expression; '':'' assumed}} expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('foofoo<int>()'); score ignored}} expected-warning {{'ibm' is not a valid context property for the context selector 'kind' and the context set 'device'; property ignored}} expected-note {{try 'match(implementation={vendor(ibm)})'}} expected-note {{the ignored property spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(C+5): host), kind(llvm)}) // expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('C + 5'); score ignored}} expected-warning {{the context selector 'kind' was used already in the same 'omp declare variant' directive; selector ignored}} expected-note {{the previous context selector 'kind' used here}} expected-note {{the ignored selector spans until here}}
 #pragma omp declare variant(foofoo <int>) match(device={kind(score(C+5): nohost), vendor(llvm)}) // expected-warning {{the context selector 'kind' in the context set 'device' cannot have a score ('C + 5'); score ignored}} expected-warning {{the context selector 'vendor' is not valid for the context set 'device'; selector ignored}} expected-note {{the context selector 'vendor' can be nested in the context set 'implementation'; try 'match(implementation={vendor(property)})'}} expected-note {{the ignored selector spans until here}}
diff --git a/clang/test/OpenMP/target_update_from_messages.cpp b/clang/test/OpenMP/target_update_from_messages.cpp
index eaf862a10582..141cfc38ffeb 100644
--- a/clang/test/OpenMP/target_update_from_messages.cpp
+++ b/clang/test/OpenMP/target_update_from_messages.cpp
@@ -58,23 +58,23 @@ struct S7 {
   int i;
   int a[50];
   float x;
   S6 s6[5];
   double *p;
   unsigned bfa : 4;
 };
 struct S8 {
   int *ptr;
   int a;
   struct S7* S;
   void foo() {
 #pragma omp target update from(*this) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
     {}
 #pragma omp target update from(*(this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(this->S->i+this->S->p)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(this->S->i+this->S->s6[0].pp)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(a+this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(*(this->ptr)+a+this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update from(*(this+this)) // expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}} expected-error {{invalid operands to binary expression ('S8 *' and 'S8 *')}}
+#pragma omp target update from(*(this+this)) // expected-error {{invalid operands to binary expression ('S8 *' and 'S8 *')}}
   }
 };
 
@@ -144,67 +144,67 @@ T tmain(T argc) {
 int main(int argc, char **argv) {
   const int d = 5;
   const int da[5] = { 0 };
   S4 e(4);
   S5 g(5);
   int i, t[20];
   int &j = i;
   int *k = &j;
   int x;
   int y;
   int from;
   const int (&l)[5] = da;
   int *m;
   S7 s7;
   int **BB, *offset;
   int ***BBB;
 
 #pragma omp target update from // expected-error {{expected '(' after 'from'}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from( // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from() // expected-error {{expected expression}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update() // expected-warning {{extra tokens at the end of '#pragma omp target update' are ignored}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(alloc) // expected-error {{use of undeclared identifier 'alloc'}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(x)
 #pragma omp target update from(t[:i])
 #pragma omp target update from(S2::S2s)
 #pragma omp target update from(S2::S2sc)
 #pragma omp target update from(from)
 #pragma omp target update from(y x) // expected-error {{expected ',' or ')' in 'from' clause}}
 #pragma omp target update from(argc > 0 ? x : y) // le50-error {{expected addressable lvalue in 'from' clause}} le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(S1) // expected-error {{'S1' does not refer to a value}}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}}
 #pragma omp target update from(ba)
 #pragma omp target update from(h) // expected-error {{threadprivate variables are not allowed in 'from' clause}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(k), to(k) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
 #pragma omp target update from(t), from(t[:5]) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
 #pragma omp target update from(da)
 #pragma omp target update from(da[:4])
 
 #pragma omp target update from(x, a[:2]) // expected-error {{subscripted value is not an array or pointer}}
 #pragma omp target update from(x, c[:]) // expected-error {{subscripted value is not an array or pointer}}
 #pragma omp target update from(x, (m+1)[2]) // // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}}
 #pragma omp target update from(s7.i, s7.a[:3])
 #pragma omp target update from(s7.s6[1].aa[0:5])
 #pragma omp target update from(x, s7.s6[:5].aa[6]) // expected-error {{OpenMP array section is not allowed here}}
 #pragma omp target update from(x, s7.s6[:5].aa[:6]) // expected-error {{OpenMP array section is not allowed here}}
 #pragma omp target update from(s7.p[:10])
 #pragma omp target update from(x, s7.bfa) // expected-error {{bit fields cannot be used to specify storage in a 'from' clause}}
 #pragma omp target update from(x, s7.p[:]) // expected-error {{section length is unspecified and cannot be inferred because subscripted value is not an array}}
 #pragma omp target update from(**(BB+*offset)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(**(BB+y)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(m+*offset)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(**(*offset+BB)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(**(y+BB)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(*offset+m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(**(-(*offset)+BB+*m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(**(*(*(&offset))+BB-*m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update from(*(x+*(y+*(**BB+BBB)+s7.i))) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update from(*(m+(m))) // expected-error {{invalid operands to binary expression ('int *' and 'int *')}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update from(*(1+y+y)) // expected-error {{indirection requires pointer operand ('int' invalid)}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
+#pragma omp target update from(*(m+(m))) // expected-error {{invalid operands to binary expression ('int *' and 'int *')}}
+#pragma omp target update from(*(1+y+y)) // expected-error {{indirection requires pointer operand ('int' invalid)}}
 #pragma omp target data map(to: s7.i)
   {
 #pragma omp target update from(s7.x)
   }
 
   return tmain<int, 3>(argc)+tmain<to, 4>(argc); // expected-note {{in instantiation of function template specialization 'tmain<int, 3>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<int, 4>' requested here}}
 }
 
diff --git a/clang/test/OpenMP/target_update_to_messages.cpp b/clang/test/OpenMP/target_update_to_messages.cpp
index 66ba9d3bb23f..832adc0dd4d0 100644
--- a/clang/test/OpenMP/target_update_to_messages.cpp
+++ b/clang/test/OpenMP/target_update_to_messages.cpp
@@ -61,23 +61,23 @@ struct S7 {
   int i;
   int a[50];
   float x;
   S6 s6[5];
   double *p;
   unsigned bfa : 4;
 };
 struct S8 {
   int *ptr;
   int a;
   struct S7* S;
   void foo() {
 #pragma omp target update to(*this) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
     {}
 #pragma omp target update to(*(this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(this->S->i+this->S->p)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(this->S->i+this->S->s6[0].pp)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(a+this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(*(this->ptr)+a+this->ptr)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update to(*(this+this)) // expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}} expected-error {{invalid operands to binary expression ('S8 *' and 'S8 *')}}
+#pragma omp target update to(*(this+this)) // expected-error {{invalid operands to binary expression ('S8 *' and 'S8 *')}}
     {}
   }
 };
@@ -146,68 +146,68 @@ T tmain(T argc) {
 int main(int argc, char **argv) {
   const int d = 5;
   const int da[5] = { 0 };
   S4 e(4);
   S5 g(5);
   int i, t[20];
   int &j = i;
   int *k = &j;
   int x;
   int y;
   int to;
   const int (&l)[5] = da;
   S7 s7;
   int *m;
   int **BB, *offset;
   int ***BBB;
 
 #pragma omp target update to // expected-error {{expected '(' after 'to'}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to( // expected-error {{expected ')'}} expected-note {{to match this '('}} expected-error {{expected expression}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to() // expected-error {{expected expression}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update() // expected-warning {{extra tokens at the end of '#pragma omp target update' are ignored}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(alloc) // expected-error {{use of undeclared identifier 'alloc'}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(x)
 #pragma omp target update to(t[:i])
 #pragma omp target update to(S2::S2s)
 #pragma omp target update to(S2::S2sc)
 #pragma omp target update to(to)
 #pragma omp target update to(y x) // expected-error {{expected ',' or ')' in 'to' clause}}
 #pragma omp target update to(argc > 0 ? x : y) // le50-error {{expected addressable lvalue in 'to' clause}} le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(S1) // expected-error {{'S1' does not refer to a value}}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(a, b, c, d, f) // expected-error {{incomplete type 'S1' where a complete type is required}}
 #pragma omp target update to(ba)
 #pragma omp target update to(h) // expected-error {{threadprivate variables are not allowed in 'to' clause}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(k), from(k) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
 #pragma omp target update to(t), to(t[:5]) // expected-error {{variable can appear only once in OpenMP 'target update' construct}} expected-note {{used here}}
 #pragma omp target update to(da)
 #pragma omp target update to(da[:4])
 
 #pragma omp target update to(x, a[:2]) // expected-error {{subscripted value is not an array or pointer}}
 #pragma omp target update to(x, c[:]) // expected-error {{subscripted value is not an array or pointer}}
 #pragma omp target update to(x, (m+1)[2]) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}}
 #pragma omp target update to(s7.i, s7.a[:3])
 #pragma omp target update to(s7.s6[1].aa[0:5])
 #pragma omp target update to(x, s7.s6[:5].aa[6]) // expected-error {{OpenMP array section is not allowed here}}
 #pragma omp target update to(x, s7.s6[:5].aa[:6]) // expected-error {{OpenMP array section is not allowed here}}
 #pragma omp target update to(s7.p[:10])
 #pragma omp target update to(x, s7.bfa) // expected-error {{bit fields cannot be used to specify storage in a 'to' clause}}
 #pragma omp target update to(x, s7.p[:]) // expected-error {{section length is unspecified and cannot be inferred because subscripted value is not an array}}
 #pragma omp target data map(to: s7.i)
   {
 #pragma omp target update to(s7.x)
   }
 
 #pragma omp target update to(**(BB+*offset)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(**(BB+y)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(m+*offset)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(**(*offset+BB)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(**(y+BB)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(*offset+m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(**(*offset+BB+*m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(**(*(*(&offset))+BB+*m)) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
 #pragma omp target update to(*(x+*(y+*(**BB+BBB)+s7.i))) // le45-error {{expected expression containing only member accesses and/or array sections based on named variables}} le45-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update to(*(m+(m))) // expected-error {{invalid operands to binary expression ('int *' and 'int *')}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
-#pragma omp target update to(*(1+y+y)) // expected-error {{indirection requires pointer operand ('int' invalid)}} expected-error {{expected at least one 'to' clause or 'from' clause specified to '#pragma omp target update'}}
+#pragma omp target update to(*(m+(m))) // expected-error {{invalid operands to binary expression ('int *' and 'int *')}}
+#pragma omp target update to(*(1+y+y)) // expected-error {{indirection requires pointer operand ('int' invalid)}}
   {}
   return tmain<int, 3>(argc)+tmain<from, 4>(argc); // expected-note {{in instantiation of function template specialization 'tmain<int, 3>' requested here}} expected-note {{in instantiation of function template specialization 'tmain<int, 4>' requested here}}
 }
 
diff --git a/clang/test/Parser/objcxx0x-lambda-expressions.mm b/clang/test/Parser/objcxx0x-lambda-expressions.mm
index 0f3e9481a722..396313816fe5 100644
--- a/clang/test/Parser/objcxx0x-lambda-expressions.mm
+++ b/clang/test/Parser/objcxx0x-lambda-expressions.mm
@@ -3,40 +3,42 @@
 class C {
   id get(int);
 
   void f() {
     int foo, bar, baz;
 
     // fail to parse as a lambda introducer, so we get objc message parsing errors instead
     [foo,+] {}; // expected-error {{expected expression}}
 
     []; // expected-error {{expected body of lambda expression}}
     [=,foo+] {}; // expected-error {{expected ',' or ']' in lambda capture list}}
-    [&this] {}; // expected-error {{cannot take the address of an rvalue of type 'C *'}}
+    [&this] {}; // expected-error {{cannot take the address of an rvalue of type 'C *'}} \
+                // expected-error {{expected identifier}}
     [] {}; 
     [=] (int i) {}; 
     [&] (int) mutable -> void {}; 
     [foo,bar] () { return 3; }; 
     [=,&foo] () {}; 
     [this] () {}; 
 
     [foo(bar)] () {};
     [foo = bar] () {};
     [foo{bar}] () {};
     [foo = {bar}] () {}; // expected-error {{<initializer_list>}}
 
-    [foo(bar) baz] () {}; // expected-error {{called object type 'int' is not a function}}
+    [foo(bar) baz] () {}; // expected-error {{called object type 'int' is not a function}} \
+                          // expected-error {{expected ';'}}
     [foo(bar), baz] () {}; // ok
 
     [foo = bar baz]; // expected-warning {{receiver type 'int'}} expected-warning {{instance method '-baz'}}
 
     [get(bar) baz]; // expected-warning {{instance method '-baz'}}
     [get(bar), baz]; // expected-error {{expected body of lambda}}
 
     [foo = bar ++ baz]; // expected-warning {{receiver type 'int'}} expected-warning {{instance method '-baz'}}
     [foo = bar + baz]; // expected-error {{expected body of lambda}}
     [foo = { bar, baz }]; // expected-error {{<initializer_list>}} expected-error {{expected body of lambda}}
     [foo = { bar } baz ]; // expected-warning {{receiver type 'int'}} expected-warning {{instance method '-baz'}}
     [foo = { bar }, baz ]; // expected-error {{<initializer_list>}} expected-error {{expected body of lambda}}
   }
 
 };
diff --git a/clang/test/Parser/objcxx11-invalid-lambda.cpp b/clang/test/Parser/objcxx11-invalid-lambda.cpp
index bdb4e880fd0b..221cae9b9070 100644
--- a/clang/test/Parser/objcxx11-invalid-lambda.cpp
+++ b/clang/test/Parser/objcxx11-invalid-lambda.cpp
@@ -1,10 +1,11 @@
 // RUN: %clang_cc1 -fsyntax-only -verify -x objective-c++ -std=c++11 %s
 
-void foo() {  // expected-note {{to match this '{'}}
+void foo() {
   int bar;
   auto baz = [
-      bar(  // expected-note {{to match this '('}} expected-note {{to match this '('}}
+      bar(  // expected-note 2{{to match this '('}}\
+            // expected-warning {{captures are a C++14 extension}}
         foo_undeclared() // expected-error{{use of undeclared identifier 'foo_undeclared'}}
       /* ) */
-    ] () { };   // expected-error{{expected ')'}}
-}               // expected-error{{expected ')'}} expected-error {{expected ',' or ']'}} expected-error{{expected ';' at end of declaration}} expected-error{{expected '}'}}
+    ] () { };   // expected-error 2{{expected ')'}}
+}
\ No newline at end of file
diff --git a/clang/test/SemaCXX/cast-conversion.cpp b/clang/test/SemaCXX/cast-conversion.cpp
index 4d5abfdcfb1e..e48d918f889b 100644
--- a/clang/test/SemaCXX/cast-conversion.cpp
+++ b/clang/test/SemaCXX/cast-conversion.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -fsyntax-only -triple x86_64-unknown-unknown -verify %s -std=c++11
+// RUN: %clang_cc1 -fsyntax-only -triple x86_64-unknown-unknown -verify %s -std=c++11 -Wno-unused
 
 struct R {
   R(int);
diff --git a/clang/test/SemaCXX/constant-expression-cxx11.cpp b/clang/test/SemaCXX/constant-expression-cxx11.cpp
index 084e9701464d..dd6d7ccba19f 100644
--- a/clang/test/SemaCXX/constant-expression-cxx11.cpp
+++ b/clang/test/SemaCXX/constant-expression-cxx11.cpp
@@ -877,7 +877,7 @@ static_assert((Derived*)(Base*)pb1 == (Derived*)pok2, "");
 // null pointer in C++11. Just check for an integer literal with value 0.
 constexpr Base *nullB = 42 - 6 * 7; // expected-error {{cannot initialize a variable of type 'Class::Base *const' with an rvalue of type 'int'}}
 constexpr Base *nullB1 = 0;
-static_assert((Bottom*)nullB == 0, ""); // expected-error {{static_assert expression is not an integral constant expression}}
+static_assert((Bottom*)nullB == 0, "");
 static_assert((Derived*)nullB1 == 0, "");
 static_assert((void*)(Bottom*)nullB1 == (void*)(Derived*)nullB1, "");
 Base *nullB2 = '\0'; // expected-error {{cannot initialize a variable of type 'Class::Base *' with an rvalue of type 'char'}}
diff --git a/clang/test/SemaCXX/constructor-initializer.cpp b/clang/test/SemaCXX/constructor-initializer.cpp
index 102ff1e80d03..df8991416712 100644
--- a/clang/test/SemaCXX/constructor-initializer.cpp
+++ b/clang/test/SemaCXX/constructor-initializer.cpp
@@ -238,22 +238,22 @@ namespace PR7402 {
 // <rdar://problem/8308215>: don't crash.
 // Lots of questionable recovery here;  errors can change.
 namespace test3 {
   class A : public std::exception {}; // expected-error {{undeclared identifier}} expected-error {{expected class name}}
   // expected-note@-1 {{candidate constructor (the implicit copy constructor) not viable}}
 #if __cplusplus >= 201103L // C++11 or later
   // expected-note@-3 {{candidate constructor (the implicit move constructor) not viable}}
 #endif
   // expected-note@-5 {{candidate constructor (the implicit default constructor) not viable}}
 
   class B : public A {
   public:
     B(const String& s, int e=0) // expected-error {{unknown type name}} 
       : A(e), m_String(s) , m_ErrorStr(__null) {} // expected-error {{no matching constructor}} expected-error {{does not name}}
     B(const B& e)
-      : A(e), m_String(e.m_String), m_ErrorStr(__null) { // expected-error {{does not name}} \
+      : A(e), m_String(e.m_String), m_ErrorStr(__null) { // expected-error 2{{does not name}} \
       // expected-error {{no member named 'm_String' in 'test3::B'}}
     }
   };
 }
 
 // PR8075
diff --git a/clang/test/SemaCXX/cxx0x-deleted-default-ctor.cpp b/clang/test/SemaCXX/cxx0x-deleted-default-ctor.cpp
index 7a43fb5437d8..feb483546c3e 100644
--- a/clang/test/SemaCXX/cxx0x-deleted-default-ctor.cpp
+++ b/clang/test/SemaCXX/cxx0x-deleted-default-ctor.cpp
@@ -8,9 +8,9 @@ struct non_trivial {
 };
 
 union bad_union {
-  non_trivial nt; // expected-note {{non-trivial default constructor}} expected-note {{destructor of 'bad_union' is implicitly deleted}}
+  non_trivial nt; // expected-note {{non-trivial default constructor}}
 };
-bad_union u; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+bad_union u; // expected-error {{call to implicitly-deleted default constructor}}
 union bad_union2 { // expected-note {{all data members are const-qualified}}
   const int i;
 };
@@ -18,10 +18,10 @@ bad_union2 u2; // expected-error {{call to implicitly-deleted default constructo
 
 struct bad_anon {
   union {
-    non_trivial nt; // expected-note {{non-trivial default constructor}} expected-note {{destructor of 'bad_anon' is implicitly deleted}}
+    non_trivial nt; // expected-note {{non-trivial default constructor}}
   };
 };
-bad_anon a; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+bad_anon a; // expected-error {{call to implicitly-deleted default constructor}}
 struct bad_anon2 {
   union { // expected-note {{all data members of an anonymous union member are const-qualified}}
     const int i;
@@ -62,7 +62,7 @@ struct no_default {
   no_default() = delete; // expected-note 5{{deleted here}}
 };
 struct no_dtor {
-  ~no_dtor() = delete; // expected-note 4{{deleted here}}
+  ~no_dtor() = delete; // expected-note 2{{deleted here}}
 };
 
 struct bad_field_default {
@@ -74,12 +74,12 @@ struct bad_base_default : no_default { // expected-note {{base class 'no_default
 bad_base_default bbd; // expected-error {{call to implicitly-deleted default constructor}}
 
 struct bad_field_dtor {
-  no_dtor nd; // expected-note {{field 'nd' has a deleted destructor}} expected-note {{destructor of 'bad_field_dtor' is implicitly deleted }}
+  no_dtor nd; // expected-note {{field 'nd' has a deleted destructor}}
 };
-bad_field_dtor bfx; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-struct bad_base_dtor : no_dtor { // expected-note {{base class 'no_dtor' has a deleted destructor}} expected-note {{destructor of 'bad_base_dtor' is implicitly deleted}}
+bad_field_dtor bfx; // expected-error {{call to implicitly-deleted default constructor}}
+struct bad_base_dtor : no_dtor { // expected-note {{base class 'no_dtor' has a deleted destructor}}
 };
-bad_base_dtor bbx; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+bad_base_dtor bbx; // expected-error {{call to implicitly-deleted default constructor}}
 
 struct ambiguous_default {
   ambiguous_default();
diff --git a/clang/test/SemaCXX/cxx1y-deduced-return-type.cpp b/clang/test/SemaCXX/cxx1y-deduced-return-type.cpp
index fafc6ead73c4..687ecf28ee3d 100644
--- a/clang/test/SemaCXX/cxx1y-deduced-return-type.cpp
+++ b/clang/test/SemaCXX/cxx1y-deduced-return-type.cpp
@@ -100,7 +100,7 @@ auto fac(int n) {
 auto fac_2(int n) { // expected-note {{declared here}}
   if (n > 2)
     return n * fac_2(n-1); // expected-error {{cannot be used before it is defined}}
-  return n;
+  return n; // expected-error {{cannot initialize return object of type 'auto'}}
 }
 
 auto void_ret() {}
diff --git a/clang/test/SemaCXX/cxx1z-copy-omission.cpp b/clang/test/SemaCXX/cxx1z-copy-omission.cpp
index a7133d79b463..eceac810e72a 100644
--- a/clang/test/SemaCXX/cxx1z-copy-omission.cpp
+++ b/clang/test/SemaCXX/cxx1z-copy-omission.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -std=c++1z -verify %s
+// RUN: %clang_cc1 -std=c++1z -verify -Wno-unused %s
 
 struct Noncopyable {
   Noncopyable();
@@ -74,64 +74,66 @@ NoncopyableAggr nc_aggr8{Convert<Noncopyable>()};
 void test_expressions(bool b) {
   auto lambda = [a = make()] {};
 
   take({});
   take(Noncopyable());
   take(Noncopyable{});
   take(make());
 
   Noncopyable &&dc1 = dynamic_cast<Noncopyable&&>(Noncopyable());
   Noncopyable &&dc2 = dynamic_cast<Noncopyable&&>(nc1);
   Noncopyable &&dc3 = dynamic_cast<Noncopyable&&>(Derived());
 
   Noncopyable sc1 = static_cast<Noncopyable>(Noncopyable());
   Noncopyable sc2 = static_cast<Noncopyable>(nc1); // expected-error {{deleted}}
   Noncopyable sc3 = static_cast<Noncopyable&&>(Noncopyable()); // expected-error {{deleted}}
   Noncopyable sc4 = static_cast<Noncopyable>(static_cast<Noncopyable&&>(Noncopyable())); // expected-error {{deleted}}
 
   Noncopyable cc1 = (Noncopyable)Noncopyable();
   Noncopyable cc2 = (Noncopyable)Derived(); // expected-error {{deleted}}
 
   Noncopyable fc1 = Noncopyable(Noncopyable());
   Noncopyable fc2 = Noncopyable(Derived()); // expected-error {{deleted}}
 
   // We must check for a complete type for every materialized temporary. (Note
   // that in the special case of the top level of a decltype, no temporary is
   // materialized.)
   make_incomplete(); // expected-error {{incomplete}}
   make_incomplete().a; // expected-error {{incomplete}}
   make_incomplete().*(int Incomplete::*)nullptr; // expected-error {{incomplete}}
   dynamic_cast<Incomplete&&>(make_incomplete()); // expected-error {{incomplete}}
   const_cast<Incomplete&&>(make_incomplete()); // expected-error {{incomplete}}
 
   sizeof(Indestructible{}); // expected-error {{deleted}}
   sizeof(make_indestructible()); // expected-error {{deleted}}
   sizeof(make_incomplete()); // expected-error {{incomplete}}
   typeid(Indestructible{}); // expected-error {{deleted}}
-  typeid(make_indestructible()); // expected-error {{deleted}}
-  typeid(make_incomplete()); // expected-error {{incomplete}}
+  typeid(make_indestructible()); // expected-error {{deleted}} \
+                                 // expected-error {{need to include <typeinfo>}}
+  typeid(make_incomplete()); // expected-error {{incomplete}} \
+                             // expected-error {{need to include <typeinfo>}}
 
   // FIXME: The first two cases here are now also valid in C++17 onwards.
   using I = decltype(Indestructible()); // expected-error {{deleted}}
   using I = decltype(Indestructible{}); // expected-error {{deleted}}
   using I = decltype(make_indestructible());
   using J = decltype(make_incomplete());
 
   Noncopyable cond1 = b ? Noncopyable() : make();
   Noncopyable cond2 = b ? Noncopyable() : Derived(); // expected-error {{incompatible}}
   Noncopyable cond3 = b ? Derived() : Noncopyable(); // expected-error {{incompatible}}
   Noncopyable cond4 = b ? Noncopyable() : nc1; // expected-error {{deleted}}
   Noncopyable cond5 = b ? nc1 : Noncopyable(); // expected-error {{deleted}}
   // Could convert both to an xvalue of type Noncopyable here, but we're not
   // permitted to consider that.
   Noncopyable &&cond6 = b ? Noncopyable() : Derived(); // expected-error {{incompatible}}
   Noncopyable &&cond7 = b ? Derived() : Noncopyable(); // expected-error {{incompatible}}
   // Could convert both to a const lvalue of type Noncopyable here, but we're
   // not permitted to consider that, either.
   const Noncopyable cnc;
   const Noncopyable &cond8 = b ? cnc : Derived(); // expected-error {{incompatible}}
   const Noncopyable &cond9 = b ? Derived() : cnc; // expected-error {{incompatible}}
 
   extern const volatile Noncopyable make_cv();
   Noncopyable cv_difference1 = make_cv();
   const volatile Noncopyable cv_difference2 = make();
 }
diff --git a/clang/test/SemaCXX/decltype-crash.cpp b/clang/test/SemaCXX/decltype-crash.cpp
index 1cebfcd72c86..1ffc525a2703 100644
--- a/clang/test/SemaCXX/decltype-crash.cpp
+++ b/clang/test/SemaCXX/decltype-crash.cpp
@@ -3,5 +3,8 @@
 int& a();
 
 void f() {
-  decltype(a()) c; // expected-warning {{'decltype' is a keyword in C++11}} expected-error {{use of undeclared identifier 'decltype'}}
+  decltype(a()) c; // expected-warning {{'decltype' is a keyword in C++11}} \
+                   // expected-error {{use of undeclared identifier 'decltype'}} \
+                   // expected-error {{expected ';' after expression}} \
+                   // expected-error {{use of undeclared identifier 'c'}}
 }
diff --git a/clang/test/SemaCXX/enable_if.cpp b/clang/test/SemaCXX/enable_if.cpp
index 50d898959c45..9c87ffebf83d 100644
--- a/clang/test/SemaCXX/enable_if.cpp
+++ b/clang/test/SemaCXX/enable_if.cpp
@@ -414,8 +414,8 @@ static_assert(templated<1>() == 1, "");
 
 template <int N> constexpr int callTemplated() { return templated<N>(); }
 
-constexpr int B = 10 + // the carat for the error should be pointing to the problematic call (on the next line), not here.
-    callTemplated<0>(); // expected-error{{initialized by a constant expression}} expected-error@-3{{no matching function for call to 'templated'}} expected-note{{in instantiation of function template}} expected-note@-10{{candidate disabled}}
+constexpr int B = 10 + // expected-error {{initialized by a constant expression}}
+    callTemplated<0>(); // expected-error@-3{{no matching function for call to 'templated'}} expected-note{{in instantiation of function template}} expected-note@-10{{candidate disabled}} expected-note {{in call to 'callTemplated()'}} expected-note@-3 {{subexpression not valid in a constant expression}}
 static_assert(callTemplated<1>() == 1, "");
 }
 
diff --git a/clang/test/SemaCXX/for-range-dereference.cpp b/clang/test/SemaCXX/for-range-dereference.cpp
index bd8bb5717362..de4958c31bce 100644
--- a/clang/test/SemaCXX/for-range-dereference.cpp
+++ b/clang/test/SemaCXX/for-range-dereference.cpp
@@ -61,28 +61,29 @@ void f() {
   DeletedEnd DE;
   for (auto i : DE) { } // expected-error{{attempt to use a deleted function}} \
 expected-note {{when looking up 'end' function for range expression of type 'DeletedEnd'}}
   DeletedEnd *pDE;
 
   for (auto i : pDE) { } // expected-error {{invalid range expression of type 'DeletedEnd *'; no viable 'begin' function available}}
 
   PrivateEnd PE;
   // FIXME: This diagnostic should be improved, as it does not specify that
   // the range is invalid.
   for (auto i : PE) { } // expected-error{{'end' is a private member of 'PrivateEnd'}}
 
   PrivateEnd *pPE;
   for (auto i : pPE) { }// expected-error {{invalid range expression of type 'PrivateEnd *'}}
   // expected-error@-1 {{'end' is a private member of 'PrivateEnd'}}
 
   DeletedADLBegin DAB;
   for (auto i : DAB) { } // expected-error {{call to deleted function 'begin'}}\
   expected-note {{when looking up 'begin' function for range expression of type 'DeletedADLBegin'}}
 
   OverloadedStar OS;
   for (auto i : *OS) { }
 
   for (auto i : OS) { } // expected-error {{invalid range expression of type 'OverloadedStar'; did you mean to dereference it with '*'?}}
 
   for (Data *p : pt) { } // expected-error {{invalid range expression of type 'T *'; did you mean to dereference it with '*'?}}
   // expected-error@-1 {{no viable conversion from 'Data' to 'Data *'}}
+  // expected-note@4 {{selected 'begin' function with iterator type 'Data *'}}
 }
diff --git a/clang/test/SemaCXX/recovery-default-init.cpp b/clang/test/SemaCXX/recovery-default-init.cpp
deleted file mode 100644
index 8ba3d8df58a3..000000000000
--- a/clang/test/SemaCXX/recovery-default-init.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-// RUN: %clang_cc1 %s -fsyntax-only -frecovery-ast -verify -std=c++11
-
-// NOTE: the test can be merged into existing tests once -frecovery-ast is on
-// by default.
-
-struct Foo { // expected-note {{candidate constructor (the implicit copy constructor) not viable}}
-  Foo(int); // expected-note {{candidate constructor not viable}}
-  ~Foo() = delete;
-};
-
-void test() {
-  // we expect the "attempt to use a deleted function" diagnostic is suppressed.
-  Foo foo; // expected-error {{no matching constructor for initialization of}}
-}
diff --git a/clang/test/SemaCXX/recovery-initializer.cpp b/clang/test/SemaCXX/recovery-initializer.cpp
deleted file mode 100644
index e1f35dbc1f93..000000000000
--- a/clang/test/SemaCXX/recovery-initializer.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-// RUN: %clang_cc1 -std=c++11 -fsyntax-only -frecovery-ast -verify %s
-
-// NOTE: these tests can be merged to existing tests after -frecovery-ast is
-// turned on by default.
-void test1() {
-  struct Data {};
-  struct T {
-    Data *begin();
-    Data *end();
-  };
-  T *pt;
-  for (Data *p : T()) {} // expected-error {{no viable conversion from 'Data' to 'Data *'}}
-                         // expected-note@-5 {{selected 'begin' function with iterator type}}
-}
-
-void test2() {
-  struct Bottom {
-    constexpr Bottom() {}
-  };
-  struct Base : Bottom {
-    constexpr Base(int a = 42, const char *b = "test") : a(a), b(b) {}
-    int a;
-    const char *b;
-  };
-  constexpr Base *nullB = 12; // expected-error {{cannot initialize a variable of type}}
-  // verify that the "static_assert expression is not an integral constant expr"
-  // diagnostic is suppressed.
-  static_assert((Bottom*)nullB == 0, "");
-}
diff --git a/clang/test/SemaCXX/varargs.cpp b/clang/test/SemaCXX/varargs.cpp
index f2f53dc2001f..625f1dce18f3 100644
--- a/clang/test/SemaCXX/varargs.cpp
+++ b/clang/test/SemaCXX/varargs.cpp
@@ -21,12 +21,13 @@ void no_params(...) {
 // Reject this. The __builtin_va_start would execute in Foo's non-variadic
 // default ctor.
 void record_context(int a, ...) {
   struct Foo {
-    // expected-error@+1 {{'va_start' cannot be used outside a function}}
+    // expected-error@+2 {{'va_start' cannot be used outside a function}}
+    // expected-error@+1 {{default argument references parameter 'a'}}
     void meth(int a, int b = (__builtin_va_start(ap, a), 0)) {}
   };
 }
 
 #if __cplusplus >= 201103L
 // We used to have bugs identifying the correct enclosing function scope in a
 // lambda.
diff --git a/clang/test/SemaCXX/virtual-base-used.cpp b/clang/test/SemaCXX/virtual-base-used.cpp
index ad0aa62a359c..aa19010e4cee 100644
--- a/clang/test/SemaCXX/virtual-base-used.cpp
+++ b/clang/test/SemaCXX/virtual-base-used.cpp
@@ -27,20 +27,19 @@ struct A {
 struct B : public virtual A {
 #if __cplusplus >= 201103L
 // expected-error@-2 {{deleted function '~B' cannot override a non-deleted function}}
 // expected-note@-3 {{overridden virtual function is here}}
 #endif
 
   NoDestroy x;
 #if __cplusplus <= 199711L
   // expected-error@-2 {{field of type 'NoDestroy' has private destructor}}
 #ifdef MSABI
   // expected-error@-4 {{field of type 'NoDestroy' has private destructor}}
 #endif
 #else
   // expected-note@-7 {{destructor of 'B' is implicitly deleted because field 'x' has an inaccessible destructor}}
 #ifdef MSABI
   // expected-note@-9 {{default constructor of 'B' is implicitly deleted because field 'x' has an inaccessible destructor}}
-  // expected-note@-10 {{destructor of 'B' is implicitly deleted}}
 #endif
 #endif
 };
@@ -48,32 +47,27 @@ struct B : public virtual A {
 struct D : public virtual B {
 #if __cplusplus <= 199711L
 #ifdef MSABI
 // expected-note@-3 {{implicit default constructor for 'B' first required here}}
 // expected-note@-4 {{implicit destructor for 'B' first required here}}
 #endif
 #else
 #ifdef MSABI
 // expected-note@-8 {{default constructor of 'D' is implicitly deleted because base class 'B' has a deleted default constructor}}
 #endif
 #endif
   virtual void foo();
   ~D();
 #if __cplusplus >= 201103L
   //expected-error@-2 {{non-deleted function '~D' cannot override a deleted function}}
-#ifdef MSABI
-//expected-error@-4 {{use a deleted function}}
-#else
-#endif
 #endif
 };
 
 #ifdef MSABI
 D d;
 #if __cplusplus <= 199711L
 // expected-note@-2 2{{implicit default constructor for 'D' first required here}}
 #else
-// expected-error@-4 {{call to implicitly-deleted default constructor of 'D'}}
-// expected-note@-5 {{implicit destructor for 'D' first required here}}
+// expected-error@-4 {{call to implicitly-deleted default constructor of 'D'}}
 #endif
 #else
 void D::foo() {
@@ -86,19 +80,18 @@ void D::foo() {
 struct E : public virtual A {
 #if __cplusplus >= 201103L
 // expected-error@-2 {{deleted function '~E' cannot override a non-deleted function}}
 #endif
 
   NoDestroy x;
 #if __cplusplus <= 199711L
   // expected-error@-2 {{field of type 'NoDestroy' has private destructor}}
 #ifdef MSABI
   // expected-error@-4 {{field of type 'NoDestroy' has private destructor}}
 #endif
 #else
   // expected-note@-7 {{destructor of 'E' is implicitly deleted because field 'x' has an inaccessible destructor}}
 #ifdef MSABI
   // expected-note@-9 {{default constructor of 'E' is implicitly deleted because field 'x' has an inaccessible destructor}}
-  // expected-note@-10 {{destructor of 'E' is implicitly deleted}}
 #endif
 #endif
 };
@@ -106,14 +99,13 @@ struct E : public virtual A {
 struct F : public E {
 #if __cplusplus <= 199711L
 // expected-note@-2 {{implicit destructor for 'E' first required here}}
 #ifdef MSABI
 // expected-note@-4 {{implicit default constructor for 'E' first required here}}
 #endif
 #else
 // expected-note@-7 {{overridden virtual function is here}}
 #ifdef MSABI
 // expected-note@-9 {{default constructor of 'F' is implicitly deleted because base class 'E' has a deleted default constructor}}
-// expected-note@-10 {{destructor of 'F' is implicitly deleted}}
 #endif
 #endif
 };
@@ -122,30 +114,26 @@ struct F : public E {
 struct G : public virtual F {
 #ifdef MSABI
 #if __cplusplus <= 199711L
 // expected-note@-3 {{implicit default constructor for 'F' first required here}}
 // expected-note@-4 {{implicit destructor for 'F' first required here}}
 #else
 // expected-note@-6 {{default constructor of 'G' is implicitly deleted because base class 'F' has a deleted default constructor}}
 #endif
 #endif
 
   virtual void foo();
   ~G();
 #if __cplusplus >= 201103L
   //expected-error@-2 {{non-deleted function '~G' cannot override a deleted function}}
-#ifdef MSABI
-  //expected-error@-4 {{use a deleted function}}
-#endif
 #endif
 };
 
 #ifdef MSABI
 G g;
 #if __cplusplus <= 199711L
 // expected-note@-2 2{{implicit default constructor for 'G' first required here}}
 #else
 // expected-error@-4 {{call to implicitly-deleted default constructor of 'G'}}
-// expected-note@-5 {{mplicit destructor for 'G' first required here}}
 #endif
 #else
 void G::foo() {
@@ -158,20 +146,19 @@ void G::foo() {
 struct H : public virtual A {
 #if __cplusplus >= 201103L
 // expected-error@-2 {{deleted function '~H' cannot override a non-deleted function}}
 // expected-note@-3 {{overridden virtual function is here}}
 #endif
 
   NoDestroy x;
 #if __cplusplus <= 199711L
   // expected-error@-2 {{field of type 'NoDestroy' has private destructor}}
 #ifdef MSABI
   // expected-error@-4 {{field of type 'NoDestroy' has private destructor}}
 #endif
 #else
   // expected-note@-7 {{destructor of 'H' is implicitly deleted because field 'x' has an inaccessible destructor}}
 #ifdef MSABI
   // expected-note@-9 {{default constructor of 'H' is implicitly deleted because field 'x' has an inaccessible destructor}}
-  // expected-note@-10 {{destructor of 'H' is implicitly deleted}}
 #endif
 #endif
 };
@@ -192,29 +179,23 @@ struct I : public virtual H {
 struct J : public I {
 #ifdef MSABI
 #if __cplusplus <= 199711L
 // expected-note@-3 {{implicit default constructor for 'H' first required here}}
 // expected-note@-4 {{implicit destructor for 'H' first required here}}
 #else
 // expected-note@-6 {{default constructor of 'J' is implicitly deleted because base class 'I' has a deleted default constructor}}
 #endif
 #endif
 
   virtual void foo();
   ~J();
-#ifdef MSABI
-#if __cplusplus >= 201103L
-//expected-error@-3 {{use a deleted function}}
-#endif
-#endif
 };
 
 #ifdef MSABI
 J j;
 #if __cplusplus <= 199711L
 // expected-note@-2 2{{implicit default constructor for 'J' first required here}}
 #else
 // expected-error@-4 {{call to implicitly-deleted default constructor of 'J'}}
-// expected-note@-5 {{implicit destructor for 'J' first required here}}
 #endif
 
 #else
diff --git a/clang/test/SemaObjCXX/arc-0x.mm b/clang/test/SemaObjCXX/arc-0x.mm
index 0e80b7baf2a1..734f28a65eb6 100644
--- a/clang/test/SemaObjCXX/arc-0x.mm
+++ b/clang/test/SemaObjCXX/arc-0x.mm
@@ -115,160 +115,156 @@ namespace test_err_arc_array_param_no_ownership {
 namespace test_union {
   // Implicitly-declared special functions of a union are deleted by default if
   // ARC is enabled and the union has an ObjC pointer field.
   union U0 {
-    id f0; // expected-note 7 {{'U0' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
+    id f0; // expected-note 6 {{'U0' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
   };
 
   union U1 {
-    __weak id f0; // expected-note 13 {{'U1' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
+    __weak id f0; // expected-note 12 {{'U1' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
     U1() = default; // expected-warning {{explicitly defaulted default constructor is implicitly deleted}} expected-note {{explicitly defaulted function was implicitly deleted here}}
-    ~U1() = default; // expected-warning {{explicitly defaulted destructor is implicitly deleted}} expected-note 2{{explicitly defaulted function was implicitly deleted here}}
+    ~U1() = default; // expected-warning {{explicitly defaulted destructor is implicitly deleted}} expected-note {{explicitly defaulted function was implicitly deleted here}}
     U1(const U1 &) = default; // expected-warning {{explicitly defaulted copy constructor is implicitly deleted}} expected-note 2 {{explicitly defaulted function was implicitly deleted here}}
     U1(U1 &&) = default; // expected-warning {{explicitly defaulted move constructor is implicitly deleted}}
     U1 & operator=(const U1 &) = default; // expected-warning {{explicitly defaulted copy assignment operator is implicitly deleted}} expected-note 2 {{explicitly defaulted function was implicitly deleted here}}
     U1 & operator=(U1 &&) = default; // expected-warning {{explicitly defaulted move assignment operator is implicitly deleted}}
   };
 
   id getStrong();
 
   // If the ObjC pointer field of a union has a default member initializer, the
   // implicitly-declared default constructor of the union is not deleted by
   // default.
   union U2 {
     id f0 = getStrong(); // expected-note 4 {{'U2' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
     ~U2();
   };
 
   // It's fine if the user has explicitly defined the special functions.
   union U3 {
     id f0;
     U3();
     ~U3();
     U3(const U3 &);
     U3(U3 &&);
     U3 & operator=(const U3 &);
     U3 & operator=(U3 &&);
   };
 
   // ObjC pointer fields in anonymous union fields delete the defaulted special
   // functions of the containing class.
   struct S0 {
     union {
-      id f0; // expected-note 7 {{'' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
+      id f0; // expected-note 6 {{'' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
       char f1;
     };
   };
 
   struct S1 {
     union {
-      union { // expected-note 7 {{'S1' is implicitly deleted because field '' has a deleted}}
-        id f0; // expected-note 3 {{'' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
+      union { // expected-note {{copy constructor of 'S1' is implicitly deleted because field '' has a deleted copy constructor}} expected-note {{copy assignment operator of 'S1' is implicitly deleted because field '' has a deleted copy assignment operator}} expected-note 4 {{'S1' is implicitly deleted because field '' has a deleted}}
+        id f0; // expected-note 2 {{'' is implicitly deleted because variant field 'f0' is an ObjC pointer}}
         char f1;
       };
       int f2;
     };
   };
 
   struct S2 {
     union {
       // FIXME: the note should say 'f0' is causing the special functions to be deleted.
-      struct { // expected-note 7 {{'S2' is implicitly deleted because variant field '' has a non-trivial}}
+      struct { // expected-note 6 {{'S2' is implicitly deleted because variant field '' has a non-trivial}}
         id f0;
         int f1;
       };
       int f2;
     };
     int f3;
   };
 
   U0 *x0;
   U1 *x1;
   U2 *x2;
   U3 *x3;
   S0 *x4;
   S1 *x5;
   S2 *x6;
 
-  static union { // expected-error {{call to implicitly-deleted default constructor of}} expected-error {{attempt to use a deleted function}}
-    id g0; // expected-note {{default constructor of '' is implicitly deleted because variant field 'g0' is an ObjC pointer}} \
-           // expected-note {{destructor of '' is implicitly deleted because}}
+  static union { // expected-error {{call to implicitly-deleted default constructor of}}
+    id g0; // expected-note {{default constructor of '' is implicitly deleted because variant field 'g0' is an ObjC pointer}}
   };
 
-  static union { // expected-error {{call to implicitly-deleted default constructor of}} expected-error {{attempt to use a deleted function}}
-    union { // expected-note {{default constructor of '' is implicitly deleted because field '' has a deleted default constructor}} \
-            // expected-note {{destructor of '' is implicitly deleted because}}
-      union { // expected-note {{default constructor of '' is implicitly deleted because field '' has a deleted default constructor}} \
-              // expected-note {{destructor of '' is implicitly deleted because}}
-        __weak id g1; // expected-note {{default constructor of '' is implicitly deleted because variant field 'g1' is an ObjC pointer}} \
-                      // expected-note {{destructor of '' is implicitly deleted because}}
+  static union { // expected-error {{call to implicitly-deleted default constructor of}}
+    union { // expected-note {{default constructor of '' is implicitly deleted because field '' has a deleted default constructor}}
+      union { // expected-note {{default constructor of '' is implicitly deleted because field '' has a deleted default constructor}}
+        __weak id g1; // expected-note {{default constructor of '' is implicitly deleted because variant field 'g1' is an ObjC pointer}}
         int g2;
       };
       int g3;
     };
     int g4;
   };
 
   void testDefaultConstructor() {
-    U0 t0; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-    U1 t1; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+    U0 t0; // expected-error {{call to implicitly-deleted default constructor}}
+    U1 t1; // expected-error {{call to implicitly-deleted default constructor}}
     U2 t2;
     U3 t3;
-    S0 t4; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-    S1 t5; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
-    S2 t6; // expected-error {{call to implicitly-deleted default constructor}} expected-error {{attempt to use a deleted function}}
+    S0 t4; // expected-error {{call to implicitly-deleted default constructor}}
+    S1 t5; // expected-error {{call to implicitly-deleted default constructor}}
+    S2 t6; // expected-error {{call to implicitly-deleted default constructor}}
   }
 
   void testDestructor(U0 *u0, U1 *u1, U2 *u2, U3 *u3, S0 *s0, S1 *s1, S2 *s2) {
     delete u0; // expected-error {{attempt to use a deleted function}}
     delete u1; // expected-error {{attempt to use a deleted function}}
     delete u2;
     delete u3;
     delete s0; // expected-error {{attempt to use a deleted function}}
     delete s1; // expected-error {{attempt to use a deleted function}}
     delete s2; // expected-error {{attempt to use a deleted function}}
   }
 
   void testCopyConstructor(U0 *u0, U1 *u1, U2 *u2, U3 *u3, S0 *s0, S1 *s1, S2 *s2) {
     U0 t0(*u0); // expected-error {{call to implicitly-deleted copy constructor}}
     U1 t1(*u1); // expected-error {{call to implicitly-deleted copy constructor}}
     U2 t2(*u2); // expected-error {{call to implicitly-deleted copy constructor}}
     U3 t3(*u3);
     S0 t4(*s0); // expected-error {{call to implicitly-deleted copy constructor}}
     S1 t5(*s1); // expected-error {{call to implicitly-deleted copy constructor}}
     S2 t6(*s2); // expected-error {{call to implicitly-deleted copy constructor}}
   }
 
   void testCopyAssignment(U0 *u0, U1 *u1, U2 *u2, U3 *u3, S0 *s0, S1 *s1, S2 *s2) {
     *x0 = *u0; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x1 = *u1; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x2 = *u2; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x3 = *u3;
     *x4 = *s0; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x5 = *s1; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x6 = *s2; // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
   }
 
   // The diagnostics below refer to the deleted copy constructors and assignment
   // operators since defaulted move constructors and assignment operators that are
   // defined as deleted are ignored by overload resolution.
 
   void testMoveConstructor(U0 *u0, U1 *u1, U2 *u2, U3 *u3, S0 *s0, S1 *s1, S2 *s2) {
     U0 t0(static_cast<U0 &&>(*u0)); // expected-error {{call to implicitly-deleted copy constructor}}
     U1 t1(static_cast<U1 &&>(*u1)); // expected-error {{call to implicitly-deleted copy constructor}}
     U2 t2(static_cast<U2 &&>(*u2)); // expected-error {{call to implicitly-deleted copy constructor}}
     U3 t3(static_cast<U3 &&>(*u3));
     S0 t4(static_cast<S0 &&>(*s0)); // expected-error {{call to implicitly-deleted copy constructor}}
     S1 t5(static_cast<S1 &&>(*s1)); // expected-error {{call to implicitly-deleted copy constructor}}
     S2 t6(static_cast<S2 &&>(*s2)); // expected-error {{call to implicitly-deleted copy constructor}}
   }
 
   void testMoveAssignment(U0 *u0, U1 *u1, U2 *u2, U3 *u3, S0 *s0, S1 *s1, S2 *s2) {
     *x0 = static_cast<U0 &&>(*u0); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x1 = static_cast<U1 &&>(*u1); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x2 = static_cast<U2 &&>(*u2); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x3 = static_cast<U3 &&>(*u3);
     *x4 = static_cast<S0 &&>(*s0); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x5 = static_cast<S1 &&>(*s1); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
     *x6 = static_cast<S2 &&>(*s2); // expected-error {{cannot be assigned because its copy assignment operator is implicitly deleted}}
   }
 }
diff --git a/clang/test/SemaOpenCLCXX/address-space-references.cl b/clang/test/SemaOpenCLCXX/address-space-references.cl
index 068318dfa141..66cd1c02e32f 100644
--- a/clang/test/SemaOpenCLCXX/address-space-references.cl
+++ b/clang/test/SemaOpenCLCXX/address-space-references.cl
@@ -11,7 +11,7 @@ int bar(const __global unsigned int &i); // expected-note{{passing argument to p
 int bar(const unsigned int &i);
 
 void foo() {
-  bar(1) // expected-error{{binding reference of type 'const __global unsigned int' to value of type 'int' changes address space}}
+  bar(1); // expected-error{{binding reference of type 'const __global unsigned int' to value of type 'int' changes address space}}
 }
 
 // Test addr space conversion with nested pointers
diff --git a/clang/test/SemaTemplate/instantiate-function-params.cpp b/clang/test/SemaTemplate/instantiate-function-params.cpp
index 505034d004d1..7dd5595de58a 100644
--- a/clang/test/SemaTemplate/instantiate-function-params.cpp
+++ b/clang/test/SemaTemplate/instantiate-function-params.cpp
@@ -3,32 +3,32 @@
 // PR6619
 template<bool C> struct if_c { };
 template<typename T1> struct if_ {
-  typedef if_c< static_cast<bool>(T1::value)> almost_type_; // expected-note 5{{in instantiation}}
+  typedef if_c< static_cast<bool>(T1::value)> almost_type_; // expected-note 7{{in instantiation}}
 };
 template <class Model, void (Model::*)()> struct wrap_constraints { };
 template <class Model> 
 inline char has_constraints_(Model* , // expected-note 3{{candidate template ignored}}
-                               wrap_constraints<Model,&Model::constraints>* = 0); // expected-note 2{{in instantiation}}
+                               wrap_constraints<Model,&Model::constraints>* = 0); // expected-note 4{{in instantiation}}
 
 template <class Model> struct not_satisfied {
   static const bool value = sizeof( has_constraints_((Model*)0)  == 1); // expected-error 3{{no matching function}} \
-  // expected-note 2{{while substituting deduced template arguments into function template 'has_constraints_' [with }}
+  // expected-note 4{{while substituting deduced template arguments into function template 'has_constraints_' [with }}
 };
 template <class ModelFn> struct requirement_;
 template <void(*)()> struct instantiate {
 };
-template <class Model> struct requirement_<void(*)(Model)>                           : if_<       not_satisfied<Model>         >::type { // expected-note 5{{in instantiation}}
+template <class Model> struct requirement_<void(*)(Model)>                           : if_<       not_satisfied<Model>         >::type { // expected-error 3{{no type named 'type' in}} expected-note 7{{in instantiation}}
 };
 template <class Model> struct usage_requirements {
 };
 template < typename TT > struct InputIterator                            {
-    typedef  instantiate< & requirement_<void(*)(usage_requirements<InputIterator> x)>::failed> boost_concept_check1; // expected-note {{in instantiation}}
+    typedef  instantiate< & requirement_<void(*)(usage_requirements<InputIterator> x)>::failed> boost_concept_check1; // expected-note 2{{in instantiation}}
 };
-template < typename TT > struct ForwardIterator                              : InputIterator<TT>                              { // expected-note {{in instantiation}}
-  typedef instantiate< & requirement_<void(*)(usage_requirements<ForwardIterator> x)>::failed> boost_concept_check2; // expected-note {{in instantiation}}
+template < typename TT > struct ForwardIterator                              : InputIterator<TT>                              { // expected-note 2{{in instantiation}}
+  typedef instantiate< & requirement_<void(*)(usage_requirements<ForwardIterator> x)>::failed> boost_concept_check2; // expected-note 2{{in instantiation}}
 
 };
-typedef instantiate< &requirement_<void(*)(ForwardIterator<char*> x)>::failed> boost_concept_checkX;// expected-note 3{{in instantiation}}
+typedef instantiate< &requirement_<void(*)(ForwardIterator<char*> x)>::failed> boost_concept_checkX;// expected-note 6{{in instantiation}}
 
 template<typename T> struct X0 { };
 template<typename R, typename A1> struct X0<R(A1 param)> { };
diff --git a/clang/test/SemaTemplate/instantiate-init.cpp b/clang/test/SemaTemplate/instantiate-init.cpp
index 6a4f65095dd5..dee0f4422e91 100644
--- a/clang/test/SemaTemplate/instantiate-init.cpp
+++ b/clang/test/SemaTemplate/instantiate-init.cpp
@@ -85,33 +85,33 @@ namespace PR10001 {
 namespace PR7985 {
   template<int N> struct integral_c { };
 
   template <typename T, int N>
   integral_c<N> array_lengthof(T (&x)[N]) { return integral_c<N>(); } // expected-note 2{{candidate template ignored: could not match 'T [N]' against 'const Data<}}
 
   template<typename T>
   struct Data {
     T x;
   };
 
   template<typename T>
   struct Description {
     static const Data<T> data[];
   };
 
   template<typename T>
   const Data<T> Description<T>::data[] = {{ 1 }}; // expected-error{{cannot initialize a member subobject of type 'int *' with an rvalue of type 'int'}}
 
   template<>
   const Data<float*> Description<float*>::data[];
 
   void test() {
     integral_c<1> ic1 = array_lengthof(Description<int>::data);
     (void)sizeof(array_lengthof(Description<float>::data));
 
-    sizeof(array_lengthof( // expected-error{{no matching function for call to 'array_lengthof'}}
+    (void)sizeof(array_lengthof( // expected-error{{no matching function for call to 'array_lengthof'}}
                           Description<int*>::data // expected-note{{in instantiation of static data member 'PR7985::Description<int *>::data' requested here}}
                           ));
 
     array_lengthof(Description<float*>::data); // expected-error{{no matching function for call to 'array_lengthof'}}
   }
 }
