commit 322716256d60e316c9a3b905a387be36d4e47368
Author: Ingo Berg <github_contact@beltoforion.de>
Date:   Thu Sep 17 00:21:02 2020 +0200

    fix for oss fuzz issue 25402
    
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=25402

diff --git a/include/muParserDef.h b/include/muParserDef.h
index f59dce9..7de46d2 100644
--- a/include/muParserDef.h
+++ b/include/muParserDef.h
@@ -93,336 +93,336 @@
 namespace mu
 {
 #if defined(_UNICODE)
 
 	/** \brief Encapsulate wcout. */
 	inline std::wostream& console()
 	{
 		return std::wcout;
 	}
 
 	/** \brief Encapsulate cin. */
 	inline std::wistream& console_in()
 	{
 		return std::wcin;
 	}
 
 #else
 
 	/** \brief Encapsulate cout.
 
 	  Used for supporting UNICODE more easily.
 	*/
 	inline std::ostream& console()
 	{
 		return std::cout;
 	}
 
 	/** \brief Encapsulate cin.
 
 	  Used for supporting UNICODE more easily.
 	*/
 	inline std::istream& console_in()
 	{
 		return std::cin;
 	}
 
 #endif
 
 	/** \brief Bytecode values.
 
 		\attention The order of the operator entries must match the order in ParserBase::c_DefaultOprt!
 	*/
 	enum ECmdCode
 	{
 		// The following are codes for built in binary operators
 		// apart from built in operators the user has the opportunity to
 		// add user defined operators.
 		cmLE = 0,			///< Operator item:  less or equal
 		cmGE = 1,			///< Operator item:  greater or equal
 		cmNEQ = 2,			///< Operator item:  not equal
 		cmEQ = 3,			///< Operator item:  equals
 		cmLT = 4,			///< Operator item:  less than
 		cmGT = 5,			///< Operator item:  greater than
 		cmADD = 6,			///< Operator item:  add
 		cmSUB = 7,			///< Operator item:  subtract
 		cmMUL = 8,			///< Operator item:  multiply
 		cmDIV = 9,			///< Operator item:  division
 		cmPOW = 10,			///< Operator item:  y to the power of ...
 		cmLAND = 11,
 		cmLOR = 12,
 		cmASSIGN = 13,		///< Operator item:  Assignment operator
 		cmBO = 14,			///< Operator item:  opening bracket
 		cmBC = 15,			///< Operator item:  closing bracket
 		cmIF = 16,			///< For use in the ternary if-then-else operator
 		cmELSE = 17,		///< For use in the ternary if-then-else operator
 		cmENDIF = 18,		///< For use in the ternary if-then-else operator
 		cmARG_SEP = 19,		///< function argument separator
 		cmVAR = 20,			///< variable item
 		cmVAL = 21,			///< value item
 
 		// For optimization purposes
 		cmVARPOW2 = 22,
 		cmVARPOW3 = 23,
 		cmVARPOW4 = 24,
 		cmVARMUL = 25,
 
 		// operators and functions
 		cmFUNC = 26,		///< Code for a generic function item
 		cmFUNC_STR,			///< Code for a function with a string parameter
 		cmFUNC_BULK,		///< Special callbacks for Bulk mode with an additional parameter for the bulk index 
 		cmSTRING,			///< Code for a string token
 		cmOPRT_BIN,			///< user defined binary operator
 		cmOPRT_POSTFIX,		///< code for postfix operators
 		cmOPRT_INFIX,		///< code for infix operators
 		cmEND,				///< end of formula
 		cmUNKNOWN			///< uninitialized item
 	};
 
 	/** \brief Types internally used by the parser.
 	*/
 	enum ETypeCode
 	{
 		tpSTR = 0,     ///< String type (Function arguments and constants only, no string variables)
 		tpDBL = 1,     ///< Floating point variables
 		tpVOID = 2      ///< Undefined type.
 	};
 
 
 	enum EParserVersionInfo
 	{
 		pviBRIEF,
 		pviFULL
 	};
 
 
 	/** \brief Parser operator precedence values. */
 	enum EOprtAssociativity
 	{
 		oaLEFT = 0,
 		oaRIGHT = 1,
 		oaNONE = 2
 	};
 
 
 	/** \brief Parser operator precedence values. */
 	enum EOprtPrecedence
 	{
 		// binary operators
 		prLOR = 1,
 		prLAND = 2,
 		prLOGIC = 3,	///< logic operators
 		prCMP = 4,		///< comparsion operators
 		prADD_SUB = 5,	///< addition
 		prMUL_DIV = 6,	///< multiplication/division
 		prPOW = 7,		///< power operator priority (highest)
 
 		// infix operators
 		prINFIX = 6,	///< Signs have a higher priority than ADD_SUB, but lower than power operator
 		prPOSTFIX = 6	///< Postfix operator priority (currently unused)
 	};
 
 
 	/** \brief Error codes. */
 	enum EErrorCodes
 	{
 		// Formula syntax errors
 		ecUNEXPECTED_OPERATOR = 0,	///< Unexpected binary operator found
 		ecUNASSIGNABLE_TOKEN = 1,	///< Token can't be identified.
 		ecUNEXPECTED_EOF = 2,		///< Unexpected end of formula. (Example: "2+sin(")
 		ecUNEXPECTED_ARG_SEP = 3,	///< An unexpected comma has been found. (Example: "1,23")
 		ecUNEXPECTED_ARG = 4,		///< An unexpected argument has been found
 		ecUNEXPECTED_VAL = 5,		///< An unexpected value token has been found
 		ecUNEXPECTED_VAR = 6,		///< An unexpected variable token has been found
 		ecUNEXPECTED_PARENS = 7,	///< Unexpected Parenthesis, opening or closing
 		ecUNEXPECTED_STR = 8,		///< A string has been found at an inapropriate position
 		ecSTRING_EXPECTED = 9,		///< A string function has been called with a different type of argument
 		ecVAL_EXPECTED = 10,		///< A numerical function has been called with a non value type of argument
 		ecMISSING_PARENS = 11,		///< Missing parens. (Example: "3*sin(3")
 		ecUNEXPECTED_FUN = 12,		///< Unexpected function found. (Example: "sin(8)cos(9)")
 		ecUNTERMINATED_STRING = 13,	///< unterminated string constant. (Example: "3*valueof("hello)")
 		ecTOO_MANY_PARAMS = 14,		///< Too many function parameters
 		ecTOO_FEW_PARAMS = 15,		///< Too few function parameters. (Example: "ite(1<2,2)")
 		ecOPRT_TYPE_CONFLICT = 16,	///< binary operators may only be applied to value items of the same type
 		ecSTR_RESULT = 17,			///< result is a string
 
 		// Invalid Parser input Parameters
 		ecINVALID_NAME = 18,			///< Invalid function, variable or constant name.
 		ecINVALID_BINOP_IDENT = 19,		///< Invalid binary operator identifier
 		ecINVALID_INFIX_IDENT = 20,		///< Invalid function, variable or constant name.
 		ecINVALID_POSTFIX_IDENT = 21,	///< Invalid function, variable or constant name.
 
 		ecBUILTIN_OVERLOAD = 22, ///< Trying to overload builtin operator
 		ecINVALID_FUN_PTR = 23, ///< Invalid callback function pointer 
 		ecINVALID_VAR_PTR = 24, ///< Invalid variable pointer 
 		ecEMPTY_EXPRESSION = 25, ///< The Expression is empty
 		ecNAME_CONFLICT = 26, ///< Name conflict
 		ecOPT_PRI = 27, ///< Invalid operator priority
 		// 
 		ecDOMAIN_ERROR = 28, ///< catch division by zero, sqrt(-1), log(0) (currently unused)
 		ecDIV_BY_ZERO = 29, ///< Division by zero (currently unused)
 		ecGENERIC = 30, ///< Generic error
 		ecLOCALE = 31, ///< Conflict with current locale
 
 		ecUNEXPECTED_CONDITIONAL = 32,
 		ecMISSING_ELSE_CLAUSE = 33,
 		ecMISPLACED_COLON = 34,
 
 		ecUNREASONABLE_NUMBER_OF_COMPUTATIONS = 35,
 
 		ecIDENTIFIER_TOO_LONG = 36, ///< Thrown when an identifier with more then 255 characters is used.
 
 		ecEXPRESSION_TOO_LONG = 37, ///< Throw an exception if the expression has more than 10000 characters. (an arbitrary limit)
 
 		ecINVALID_CHARACTERS_FOUND = 38,///< The expression or identifier contains invalid non printable characters
 
 		// internal errors
 		ecINTERNAL_ERROR = 39,    ///< Internal error of any kind.
 
 		// The last two are special entries 
 		ecCOUNT,                      ///< This is no error code, It just stores just the total number of error codes
 		ecUNDEFINED = -1  ///< Undefined message, placeholder to detect unassigned error messages
 	};
 
 	//------------------------------------------------------------------------------
 	// Basic Types
 	//------------------------------------------------------------------------------
 
 	/** \brief The numeric datatype used by the parser.
 
 	  Normally this is a floating point type either single or double precision.
 	*/
 	typedef MUP_BASETYPE value_type;
 
 	/** \brief The stringtype used by the parser.
 
 	  Depends on whether UNICODE is used or not.
 	*/
 	typedef MUP_STRING_TYPE string_type;
 
 	/** \brief The character type used by the parser.
 
 	  Depends on whether UNICODE is used or not.
 	*/
 	typedef string_type::value_type char_type;
 
 	/** \brief Typedef for easily using stringstream that respect the parser stringtype. */
 	typedef std::basic_stringstream<char_type, std::char_traits<char_type>, std::allocator<char_type> > stringstream_type;
 
 	// Data container types
 
 	/** \brief Type used for storing variables. */
 	typedef std::map<string_type, value_type*> varmap_type;
 
 	/** \brief Type used for storing constants. */
 	typedef std::map<string_type, value_type> valmap_type;
 
 	/** \brief Type for assigning a string name to an index in the internal string table. */
 	typedef std::map<string_type, std::size_t> strmap_type;
 
 	// Parser callbacks
 
 	/** \brief Callback type used for functions without arguments. */
 	typedef value_type(*generic_fun_type)();
 
 	/** \brief Callback type used for functions without arguments. */
 	typedef value_type(*fun_type0)();
 
 	/** \brief Callback type used for functions with a single arguments. */
 	typedef value_type(*fun_type1)(value_type);
 
 	/** \brief Callback type used for functions with two arguments. */
 	typedef value_type(*fun_type2)(value_type, value_type);
 
 	/** \brief Callback type used for functions with three arguments. */
 	typedef value_type(*fun_type3)(value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with four arguments. */
 	typedef value_type(*fun_type4)(value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with five arguments. */
 	typedef value_type(*fun_type5)(value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with six arguments. */
 	typedef value_type(*fun_type6)(value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with seven arguments. */
 	typedef value_type(*fun_type7)(value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with eight arguments. */
 	typedef value_type(*fun_type8)(value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with nine arguments. */
 	typedef value_type(*fun_type9)(value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with ten arguments. */
 	typedef value_type(*fun_type10)(value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions without arguments. */
 	typedef value_type(*bulkfun_type0)(int, int);
 
 	/** \brief Callback type used for functions with a single arguments. */
 	typedef value_type(*bulkfun_type1)(int, int, value_type);
 
 	/** \brief Callback type used for functions with two arguments. */
 	typedef value_type(*bulkfun_type2)(int, int, value_type, value_type);
 
 	/** \brief Callback type used for functions with three arguments. */
 	typedef value_type(*bulkfun_type3)(int, int, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with four arguments. */
 	typedef value_type(*bulkfun_type4)(int, int, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with five arguments. */
 	typedef value_type(*bulkfun_type5)(int, int, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with six arguments. */
 	typedef value_type(*bulkfun_type6)(int, int, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with seven arguments. */
 	typedef value_type(*bulkfun_type7)(int, int, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with eight arguments. */
 	typedef value_type(*bulkfun_type8)(int, int, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with nine arguments. */
 	typedef value_type(*bulkfun_type9)(int, int, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with ten arguments. */
 	typedef value_type(*bulkfun_type10)(int, int, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions with a variable argument list. */
 	typedef value_type(*multfun_type)(const value_type*, int);
 
 	/** \brief Callback type used for functions taking a string as an argument. */
 	typedef value_type(*strfun_type1)(const char_type*);
 
 	/** \brief Callback type used for functions taking a string and a value as arguments. */
 	typedef value_type(*strfun_type2)(const char_type*, value_type);
 
 	/** \brief Callback type used for functions taking a string and two values as arguments. */
 	typedef value_type(*strfun_type3)(const char_type*, value_type, value_type);
 
 	/** \brief Callback type used for functions taking a string and a value as arguments. */
 	typedef value_type(*strfun_type4)(const char_type*, value_type, value_type, value_type);
 
 	/** \brief Callback type used for functions taking a string and two values as arguments. */
 	typedef value_type(*strfun_type5)(const char_type*, value_type, value_type, value_type, value_type);
 
 	/** \brief Callback used for functions that identify values in a string. */
 	typedef int (*identfun_type)(const char_type* sExpr, int* nPos, value_type* fVal);
 
 	/** \brief Callback used for variable creation factory functions. */
 	typedef value_type* (*facfun_type)(const char_type*, void*);
 
 	static const int MaxLenExpression = 5000;
 	static const int MaxLenIdentifier = 100;
-	static const string_type ParserVersion = string_type(_T("2.3.3 (Development Snapshot)"));
-	static const string_type ParserVersionDate = string_type(_T("20200809"));
+	static const string_type ParserVersion = string_type(_T("2.3.3 (Unstable Development Build!)"));
+	static const string_type ParserVersionDate = string_type(_T("20200917"));
 } // end of namespace
 
 #if defined(_MSC_VER)
 	#pragma warning(pop)
 #endif
 
 #endif
 
diff --git a/samples/example1/example1.cpp b/samples/example1/example1.cpp
index e07b261..30b4dd7 100644
--- a/samples/example1/example1.cpp
+++ b/samples/example1/example1.cpp
@@ -316,79 +316,79 @@ static void ListExprVar(const mu::ParserBase& parser)
 /** \brief Check for external keywords.
 */
 static int CheckKeywords(const mu::char_type* a_szLine, mu::Parser& a_Parser)
 {
 	string_type sLine(a_szLine);
 
 	if (sLine == _T("quit"))
 	{
 		return -1;
 	}
 	else if (sLine == _T("list var"))
 	{
 		ListVar(a_Parser);
 		return 1;
 	}
 	else if (sLine == _T("opt on"))
 	{
 		a_Parser.EnableOptimizer(true);
 		mu::console() << _T("Optimizer enabled\n");
 		return 1;
 	}
 	else if (sLine == _T("opt off"))
 	{
 		a_Parser.EnableOptimizer(false);
 		mu::console() << _T("Optimizer disabled\n");
 		return 1;
 	}
 	else if (sLine == _T("list const"))
 	{
 		ListConst(a_Parser);
 		return 1;
 	}
 	else if (sLine == _T("list exprvar"))
 	{
 		ListExprVar(a_Parser);
 		return 1;
 	}
 	else if (sLine == _T("locale de"))
 	{
 		mu::console() << _T("Setting german locale: ArgSep=';' DecSep=',' ThousandsSep='.'\n");
 		a_Parser.SetArgSep(';');
 		a_Parser.SetDecSep(',');
 		a_Parser.SetThousandsSep('.');
 		return 1;
 	}
 	else if (sLine == _T("locale en"))
 	{
 		mu::console() << _T("Setting english locale: ArgSep=',' DecSep='.' ThousandsSep=''\n");
 		a_Parser.SetArgSep(',');
 		a_Parser.SetDecSep('.');
 		a_Parser.SetThousandsSep();
 		return 1;
 	}
 	else if (sLine == _T("locale reset"))
 	{
 		mu::console() << _T("Resetting locale\n");
 		a_Parser.ResetLocale();
 		return 1;
 	}
 	else if (sLine == _T("test bulk"))
 	{
 		mu::console() << _T("Testing bulk mode\n");
 		CalcBulk();
 		return 1;
 	}
 	else if (sLine == _T("dbg"))
 	{
-		string_type dbg = _T(R"(avg(0>3?4:(""),0^3?4:("")))");
+		string_type dbg = _T("((\"\")), 7");
 		a_Parser.SetExpr(dbg);
 		mu::console() << dbg;
 
 		int stackSize;
 		double* v = a_Parser.Eval(stackSize);
-		mu::console() << *v << std::endl;
+		mu::console() << "=" <<  *v << std::endl;
 		return 1;
 	}
 
 	return 0;
 }
diff --git a/src/muParserBase.cpp b/src/muParserBase.cpp
index a54ba19..795e1c7 100644
--- a/src/muParserBase.cpp
+++ b/src/muParserBase.cpp
@@ -60,1840 +60,1848 @@ using namespace std;
 namespace mu
 {
 	std::locale ParserBase::s_locale = std::locale(std::locale::classic(), new change_dec_sep<char_type>('.'));
 
 	bool ParserBase::g_DbgDumpCmdCode = false;
 	bool ParserBase::g_DbgDumpStack = false;
 
 	//------------------------------------------------------------------------------
 	/** \brief Identifiers for built in binary operators.
 
 		When defining custom binary operators with #AddOprt(...) make sure not to choose
 		names conflicting with these definitions.
 	*/
 	const char_type* ParserBase::c_DefaultOprt[] =
 	{
 	  _T("<="), _T(">="),  _T("!="),
 	  _T("=="), _T("<"),   _T(">"),
 	  _T("+"),  _T("-"),   _T("*"),
 	  _T("/"),  _T("^"),   _T("&&"),
 	  _T("||"), _T("="),   _T("("),
 	  _T(")"),   _T("?"),  _T(":"), 0
 	};
 
 	const int ParserBase::s_MaxNumOpenMPThreads = 16;
 
 	//------------------------------------------------------------------------------
 	/** \brief Constructor.
 		\param a_szFormula the formula to interpret.
 		\throw ParserException if a_szFormula is nullptr.
 	*/
 	ParserBase::ParserBase()
 		: m_pParseFormula(&ParserBase::ParseString)
 		, m_vRPN()
 		, m_vStringBuf()
 		, m_pTokenReader()
 		, m_FunDef()
 		, m_PostOprtDef()
 		, m_InfixOprtDef()
 		, m_OprtDef()
 		, m_ConstDef()
 		, m_StrVarDef()
 		, m_VarDef()
 		, m_bBuiltInOp(true)
 		, m_sNameChars()
 		, m_sOprtChars()
 		, m_sInfixOprtChars()
 		, m_vStackBuffer()
 		, m_nFinalResultIdx(0)
 	{
 		InitTokenReader();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Copy constructor.
 
 	  The parser can be safely copy constructed but the bytecode is reset during
 	  copy construction.
 	*/
 	ParserBase::ParserBase(const ParserBase& a_Parser)
 		: m_pParseFormula(&ParserBase::ParseString)
 		, m_vRPN()
 		, m_vStringBuf()
 		, m_pTokenReader()
 		, m_FunDef()
 		, m_PostOprtDef()
 		, m_InfixOprtDef()
 		, m_OprtDef()
 		, m_ConstDef()
 		, m_StrVarDef()
 		, m_VarDef()
 		, m_bBuiltInOp(true)
 		, m_sNameChars()
 		, m_sOprtChars()
 		, m_sInfixOprtChars()
 	{
 		m_pTokenReader.reset(new token_reader_type(this));
 		Assign(a_Parser);
 	}
 
 	//---------------------------------------------------------------------------
 	ParserBase::~ParserBase()
 	{}
 
 	//---------------------------------------------------------------------------
 	/** \brief Assignment operator.
 
 	  Implemented by calling Assign(a_Parser). Self assignment is suppressed.
 	  \param a_Parser Object to copy to this.
 	  \return *this
 	  \throw nothrow
 	*/
 	ParserBase& ParserBase::operator=(const ParserBase& a_Parser)
 	{
 		Assign(a_Parser);
 		return *this;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Copy state of a parser object to this.
 
 	  Clears Variables and Functions of this parser.
 	  Copies the states of all internal variables.
 	  Resets parse function to string parse mode.
 
 	  \param a_Parser the source object.
 	*/
 	void ParserBase::Assign(const ParserBase& a_Parser)
 	{
 		if (&a_Parser == this)
 			return;
 
 		// Don't copy bytecode instead cause the parser to create new bytecode
 		// by resetting the parse function.
 		ReInit();
 
 		m_ConstDef = a_Parser.m_ConstDef;         // Copy user define constants
 		m_VarDef = a_Parser.m_VarDef;           // Copy user defined variables
 		m_bBuiltInOp = a_Parser.m_bBuiltInOp;
 		m_vStringBuf = a_Parser.m_vStringBuf;
 		m_vStackBuffer = a_Parser.m_vStackBuffer;
 		m_nFinalResultIdx = a_Parser.m_nFinalResultIdx;
 		m_StrVarDef = a_Parser.m_StrVarDef;
 		m_vStringVarBuf = a_Parser.m_vStringVarBuf;
 		m_pTokenReader.reset(a_Parser.m_pTokenReader->Clone(this));
 
 		// Copy function and operator callbacks
 		m_FunDef = a_Parser.m_FunDef;             // Copy function definitions
 		m_PostOprtDef = a_Parser.m_PostOprtDef;   // post value unary operators
 		m_InfixOprtDef = a_Parser.m_InfixOprtDef; // unary operators for infix notation
 		m_OprtDef = a_Parser.m_OprtDef;           // binary operators
 
 		m_sNameChars = a_Parser.m_sNameChars;
 		m_sOprtChars = a_Parser.m_sOprtChars;
 		m_sInfixOprtChars = a_Parser.m_sInfixOprtChars;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Set the decimal separator.
 		\param cDecSep Decimal separator as a character value.
 		\sa SetThousandsSep
 
 		By default muparser uses the "C" locale. The decimal separator of this
 		locale is overwritten by the one provided here.
 	*/
 	void ParserBase::SetDecSep(char_type cDecSep)
 	{
 		char_type cThousandsSep = std::use_facet< change_dec_sep<char_type> >(s_locale).thousands_sep();
 		s_locale = std::locale(std::locale("C"), new change_dec_sep<char_type>(cDecSep, cThousandsSep));
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Sets the thousands operator.
 		\param cThousandsSep The thousands separator as a character
 		\sa SetDecSep
 
 		By default muparser uses the "C" locale. The thousands separator of this
 		locale is overwritten by the one provided here.
 	*/
 	void ParserBase::SetThousandsSep(char_type cThousandsSep)
 	{
 		char_type cDecSep = std::use_facet< change_dec_sep<char_type> >(s_locale).decimal_point();
 		s_locale = std::locale(std::locale("C"), new change_dec_sep<char_type>(cDecSep, cThousandsSep));
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Resets the locale.
 
 	  The default locale used "." as decimal separator, no thousands separator and
 	  "," as function argument separator.
 	*/
 	void ParserBase::ResetLocale()
 	{
 		s_locale = std::locale(std::locale("C"), new change_dec_sep<char_type>('.'));
 		SetArgSep(',');
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Initialize the token reader.
 
 	  Create new token reader object and submit pointers to function, operator,
 	  constant and variable definitions.
 
 	  \post m_pTokenReader.get()!=0
 	  \throw nothrow
 	*/
 	void ParserBase::InitTokenReader()
 	{
 		m_pTokenReader.reset(new token_reader_type(this));
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Reset parser to string parsing mode and clear internal buffers.
 
 		Clear bytecode, reset the token reader.
 		\throw nothrow
 	*/
 	void ParserBase::ReInit() const
 	{
 		m_pParseFormula = &ParserBase::ParseString;
 		m_vStringBuf.clear();
 		m_vRPN.clear();
 		m_pTokenReader->ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	void ParserBase::OnDetectVar(string_type* /*pExpr*/, int& /*nStart*/, int& /*nEnd*/)
 	{}
 
 	//---------------------------------------------------------------------------
 	/** \brief Returns the version of muparser.
 		\param eInfo A flag indicating whether the full version info should be
 					 returned or not.
 
 	  Format is as follows: "MAJOR.MINOR (COMPILER_FLAGS)" The COMPILER_FLAGS
 	  are returned only if eInfo==pviFULL.
 	*/
 	string_type ParserBase::GetVersion(EParserVersionInfo eInfo) const
 	{
 		stringstream_type ss;
 
 		ss << ParserVersion;
 
 		if (eInfo == pviFULL)
 		{
 			ss << _T(" (") << ParserVersionDate;
 			ss << std::dec << _T("; ") << sizeof(void*) * 8 << _T("BIT");
 
 #ifdef _DEBUG
 			ss << _T("; DEBUG");
 #else 
 			ss << _T("; RELEASE");
 #endif
 
 #ifdef _UNICODE
 			ss << _T("; UNICODE");
 #else
 #ifdef _MBCS
 			ss << _T("; MBCS");
 #else
 			ss << _T("; ASCII");
 #endif
 #endif
 
 #ifdef MUP_USE_OPENMP
 			ss << _T("; OPENMP");
 #endif
 
 			ss << _T(")");
 		}
 
 		return ss.str();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a value parsing function.
 
 		When parsing an expression muParser tries to detect values in the expression
 		string using different valident callbacks. Thus it's possible to parse
 		for hex values, binary values and floating point values.
 	*/
 	void ParserBase::AddValIdent(identfun_type a_pCallback)
 	{
 		m_pTokenReader->AddValIdent(a_pCallback);
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Set a function that can create variable pointer for unknown expression variables.
 		\param a_pFactory A pointer to the variable factory.
 		\param pUserData A user defined context pointer.
 	*/
 	void ParserBase::SetVarFactory(facfun_type a_pFactory, void* pUserData)
 	{
 		m_pTokenReader->SetVarCreator(a_pFactory, pUserData);
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a function or operator callback to the parser. */
 	void ParserBase::AddCallback(const string_type& a_strName,
 		const ParserCallback& a_Callback,
 		funmap_type& a_Storage,
 		const char_type* a_szCharSet)
 	{
 		if (a_Callback.GetAddr() == 0)
 			Error(ecINVALID_FUN_PTR);
 
 		const funmap_type* pFunMap = &a_Storage;
 
 		// Check for conflicting operator or function names
 		if (pFunMap != &m_FunDef && m_FunDef.find(a_strName) != m_FunDef.end())
 			Error(ecNAME_CONFLICT, -1, a_strName);
 
 		if (pFunMap != &m_PostOprtDef && m_PostOprtDef.find(a_strName) != m_PostOprtDef.end())
 			Error(ecNAME_CONFLICT, -1, a_strName);
 
 		if (pFunMap != &m_InfixOprtDef && pFunMap != &m_OprtDef && m_InfixOprtDef.find(a_strName) != m_InfixOprtDef.end())
 			Error(ecNAME_CONFLICT, -1, a_strName);
 
 		if (pFunMap != &m_InfixOprtDef && pFunMap != &m_OprtDef && m_OprtDef.find(a_strName) != m_OprtDef.end())
 			Error(ecNAME_CONFLICT, -1, a_strName);
 
 		CheckOprt(a_strName, a_Callback, a_szCharSet);
 		a_Storage[a_strName] = a_Callback;
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Check if a name contains invalid characters.
 
 		\throw ParserException if the name contains invalid characters.
 	*/
 	void ParserBase::CheckOprt(const string_type& a_sName,
 		const ParserCallback& a_Callback,
 		const string_type& a_szCharSet) const
 	{
 		if (!a_sName.length() ||
 			(a_sName.find_first_not_of(a_szCharSet) != string_type::npos) ||
 			(a_sName[0] >= '0' && a_sName[0] <= '9'))
 		{
 			switch (a_Callback.GetCode())
 			{
 			case cmOPRT_POSTFIX: Error(ecINVALID_POSTFIX_IDENT, -1, a_sName); break;
 			case cmOPRT_INFIX:   Error(ecINVALID_INFIX_IDENT, -1, a_sName); break;
 			default:             Error(ecINVALID_NAME, -1, a_sName);
 			}
 		}
 	}
 
 
 	/** \brief Check if a name contains invalid characters.
 		\throw ParserException if the name contains invalid characters.
 	*/
 	void ParserBase::CheckName(const string_type& a_sName, const string_type& a_szCharSet) const
 	{
 		if (!a_sName.length() ||
 			(a_sName.find_first_not_of(a_szCharSet) != string_type::npos) ||
 			(a_sName[0] >= '0' && a_sName[0] <= '9'))
 		{
 			Error(ecINVALID_NAME);
 		}
 	}
 
 	/** \brief Set the formula.
 		\param a_strFormula Formula as string_type
 		\throw ParserException in case of syntax errors.
 
 		Triggers first time calculation thus the creation of the bytecode and
 		scanning of used variables.
 	*/
 	void ParserBase::SetExpr(const string_type& a_sExpr)
 	{
 		// Check locale compatibility
 		if (m_pTokenReader->GetArgSep() == std::use_facet<numpunct<char_type> >(s_locale).decimal_point())
 			Error(ecLOCALE);
 
 		// Check maximum allowed expression length. An arbitrary value small enough so i can debug expressions sent to me
 		if (a_sExpr.length() >= MaxLenExpression)
 			Error(ecEXPRESSION_TOO_LONG, 0, a_sExpr);
 
 		m_pTokenReader->SetFormula(a_sExpr + _T(" "));
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Get the default symbols used for the built in operators.
 		\sa c_DefaultOprt
 	*/
 	const char_type** ParserBase::GetOprtDef() const
 	{
 		return (const char_type**)(&c_DefaultOprt[0]);
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Define the set of valid characters to be used in names of
 			   functions, variables, constants.
 	*/
 	void ParserBase::DefineNameChars(const char_type* a_szCharset)
 	{
 		m_sNameChars = a_szCharset;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Define the set of valid characters to be used in names of
 			   binary operators and postfix operators.
 	*/
 	void ParserBase::DefineOprtChars(const char_type* a_szCharset)
 	{
 		m_sOprtChars = a_szCharset;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Define the set of valid characters to be used in names of
 			   infix operators.
 	*/
 	void ParserBase::DefineInfixOprtChars(const char_type* a_szCharset)
 	{
 		m_sInfixOprtChars = a_szCharset;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Virtual function that defines the characters allowed in name identifiers.
 		\sa #ValidOprtChars, #ValidPrefixOprtChars
 	*/
 	const char_type* ParserBase::ValidNameChars() const
 	{
 		MUP_ASSERT(m_sNameChars.size());
 		return m_sNameChars.c_str();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Virtual function that defines the characters allowed in operator definitions.
 		\sa #ValidNameChars, #ValidPrefixOprtChars
 	*/
 	const char_type* ParserBase::ValidOprtChars() const
 	{
 		MUP_ASSERT(m_sOprtChars.size());
 		return m_sOprtChars.c_str();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Virtual function that defines the characters allowed in infix operator definitions.
 		\sa #ValidNameChars, #ValidOprtChars
 	*/
 	const char_type* ParserBase::ValidInfixOprtChars() const
 	{
 		MUP_ASSERT(m_sInfixOprtChars.size());
 		return m_sInfixOprtChars.c_str();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a user defined operator.
 		\post Will reset the Parser to string parsing mode.
 	*/
 	void ParserBase::DefinePostfixOprt(const string_type& a_sName, fun_type1 a_pFun, bool a_bAllowOpt)
 	{
 		if (a_sName.length() > MaxLenIdentifier)
 			Error(ecIDENTIFIER_TOO_LONG);
 
 		AddCallback(a_sName, ParserCallback(a_pFun, a_bAllowOpt, prPOSTFIX, cmOPRT_POSTFIX), m_PostOprtDef, ValidOprtChars());
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Initialize user defined functions.
 
 	  Calls the virtual functions InitFun(), InitConst() and InitOprt().
 	*/
 	void ParserBase::Init()
 	{
 		InitCharSets();
 		InitFun();
 		InitConst();
 		InitOprt();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a user defined operator.
 		\post Will reset the Parser to string parsing mode.
 		\param [in] a_sName  operator Identifier
 		\param [in] a_pFun  Operator callback function
 		\param [in] a_iPrec  Operator Precedence (default=prSIGN)
 		\param [in] a_bAllowOpt  True if operator is volatile (default=false)
 		\sa EPrec
 	*/
 	void ParserBase::DefineInfixOprt(const string_type& a_sName, fun_type1 a_pFun, int a_iPrec, bool a_bAllowOpt)
 	{
 		if (a_sName.length() > MaxLenIdentifier)
 			Error(ecIDENTIFIER_TOO_LONG);
 
 		AddCallback(a_sName, ParserCallback(a_pFun, a_bAllowOpt, a_iPrec, cmOPRT_INFIX), m_InfixOprtDef, ValidInfixOprtChars());
 	}
 
 
 	//---------------------------------------------------------------------------
 	/** \brief Define a binary operator.
 		\param [in] a_sName The identifier of the operator.
 		\param [in] a_pFun Pointer to the callback function.
 		\param [in] a_iPrec Precedence of the operator.
 		\param [in] a_eAssociativity The associativity of the operator.
 		\param [in] a_bAllowOpt If this is true the operator may be optimized away.
 
 		Adds a new Binary operator the the parser instance.
 	*/
 	void ParserBase::DefineOprt(const string_type& a_sName, fun_type2 a_pFun, unsigned a_iPrec, EOprtAssociativity a_eAssociativity, bool a_bAllowOpt)
 	{
 		if (a_sName.length() > MaxLenIdentifier)
 			Error(ecIDENTIFIER_TOO_LONG);
 
 		// Check for conflicts with built in operator names
 		for (int i = 0; m_bBuiltInOp && i < cmENDIF; ++i)
 		{
 			if (a_sName == string_type(c_DefaultOprt[i]))
 			{
 				Error(ecBUILTIN_OVERLOAD, -1, a_sName);
 			}
 		}
 
 		AddCallback(a_sName, ParserCallback(a_pFun, a_bAllowOpt, a_iPrec, a_eAssociativity), m_OprtDef, ValidOprtChars());
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Define a new string constant.
 		\param [in] a_strName The name of the constant.
 		\param [in] a_strVal the value of the constant.
 	*/
 	void ParserBase::DefineStrConst(const string_type& a_strName, const string_type& a_strVal)
 	{
 		// Test if a constant with that names already exists
 		if (m_StrVarDef.find(a_strName) != m_StrVarDef.end())
 			Error(ecNAME_CONFLICT);
 
 		CheckName(a_strName, ValidNameChars());
 
 		m_vStringVarBuf.push_back(a_strVal);                // Store variable string in internal buffer
 		m_StrVarDef[a_strName] = m_vStringVarBuf.size() - 1;  // bind buffer index to variable name
 
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a user defined variable.
 		\param [in] a_sName the variable name
 		\param [in] a_pVar A pointer to the variable value.
 		\post Will reset the Parser to string parsing mode.
 		\throw ParserException in case the name contains invalid signs or a_pVar is nullptr.
 	*/
 	void ParserBase::DefineVar(const string_type& a_sName, value_type* a_pVar)
 	{
 		if (a_pVar == 0)
 			Error(ecINVALID_VAR_PTR);
 
 		if (a_sName.length() > MaxLenIdentifier)
 			Error(ecIDENTIFIER_TOO_LONG);
 
 		// Test if a constant with that names already exists
 		if (m_ConstDef.find(a_sName) != m_ConstDef.end())
 			Error(ecNAME_CONFLICT);
 
 		CheckName(a_sName, ValidNameChars());
 		m_VarDef[a_sName] = a_pVar;
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Add a user defined constant.
 		\param [in] a_sName The name of the constant.
 		\param [in] a_fVal the value of the constant.
 		\post Will reset the Parser to string parsing mode.
 		\throw ParserException in case the name contains invalid signs.
 	*/
 	void ParserBase::DefineConst(const string_type& a_sName, value_type a_fVal)
 	{
 		if (a_sName.length() > MaxLenIdentifier)
 			Error(ecIDENTIFIER_TOO_LONG);
 
 		CheckName(a_sName, ValidNameChars());
 		m_ConstDef[a_sName] = a_fVal;
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Get operator priority.
 		\throw ParserException if a_Oprt is no operator code
 	*/
 	int ParserBase::GetOprtPrecedence(const token_type& a_Tok) const
 	{
 		switch (a_Tok.GetCode())
 		{
 			// built in operators
 		case cmEND:      return -5;
 		case cmARG_SEP:  return -4;
 		case cmASSIGN:   return -1;
 		case cmELSE:
 		case cmIF:       return  0;
 		case cmLAND:     return  prLAND;
 		case cmLOR:      return  prLOR;
 		case cmLT:
 		case cmGT:
 		case cmLE:
 		case cmGE:
 		case cmNEQ:
 		case cmEQ:       return  prCMP;
 		case cmADD:
 		case cmSUB:      return  prADD_SUB;
 		case cmMUL:
 		case cmDIV:      return  prMUL_DIV;
 		case cmPOW:      return  prPOW;
 
 		// user defined binary operators
 		case cmOPRT_INFIX:
 		case cmOPRT_BIN: return a_Tok.GetPri();
 		default:  
 			throw exception_type(ecINTERNAL_ERROR, 5, _T(""));
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Get operator priority.
 		\throw ParserException if a_Oprt is no operator code
 	*/
 	EOprtAssociativity ParserBase::GetOprtAssociativity(const token_type& a_Tok) const
 	{
 		switch (a_Tok.GetCode())
 		{
 		case cmASSIGN:
 		case cmLAND:
 		case cmLOR:
 		case cmLT:
 		case cmGT:
 		case cmLE:
 		case cmGE:
 		case cmNEQ:
 		case cmEQ:
 		case cmADD:
 		case cmSUB:
 		case cmMUL:
 		case cmDIV:      return oaLEFT;
 		case cmPOW:      return oaRIGHT;
 		case cmOPRT_BIN: return a_Tok.GetAssociativity();
 		default:         return oaNONE;
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Return a map containing the used variables only. */
 	const varmap_type& ParserBase::GetUsedVar() const
 	{
 		try
 		{
 			m_pTokenReader->IgnoreUndefVar(true);
 			CreateRPN(); // try to create bytecode, but don't use it for any further calculations since it
 						 // may contain references to nonexisting variables.
 			m_pParseFormula = &ParserBase::ParseString;
 			m_pTokenReader->IgnoreUndefVar(false);
 		}
 		catch (exception_type& /*e*/)
 		{
 			// Make sure to stay in string parse mode, don't call ReInit()
 			// because it deletes the array with the used variables
 			m_pParseFormula = &ParserBase::ParseString;
 			m_pTokenReader->IgnoreUndefVar(false);
 			throw;
 		}
 
 		return m_pTokenReader->GetUsedVar();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Return a map containing the used variables only. */
 	const varmap_type& ParserBase::GetVar() const
 	{
 		return m_VarDef;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Return a map containing all parser constants. */
 	const valmap_type& ParserBase::GetConst() const
 	{
 		return m_ConstDef;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Return prototypes of all parser functions.
 		\return #m_FunDef
 		\sa FunProt
 		\throw nothrow
 
 		The return type is a map of the public type #funmap_type containing the prototype
 		definitions for all numerical parser functions. String functions are not part of
 		this map. The Prototype definition is encapsulated in objects of the class FunProt
 		one per parser function each associated with function names via a map construct.
 	*/
 	const funmap_type& ParserBase::GetFunDef() const
 	{
 		return m_FunDef;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Retrieve the formula. */
 	const string_type& ParserBase::GetExpr() const
 	{
 		return m_pTokenReader->GetExpr();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Execute a function that takes a single string argument.
 		\param a_FunTok Function token.
 		\throw exception_type If the function token is not a string function
 	*/
 	ParserBase::token_type ParserBase::ApplyStrFunc(const token_type& a_FunTok,
 		const std::vector<token_type>& a_vArg) const
 	{
 		if (a_vArg.back().GetCode() != cmSTRING)
 			Error(ecSTRING_EXPECTED, m_pTokenReader->GetPos(), a_FunTok.GetAsString());
 
 		token_type  valTok;
 		generic_fun_type pFunc = a_FunTok.GetFuncAddr();
 		MUP_ASSERT(pFunc);
 
 		try
 		{
 			// Check function arguments; write dummy value into valtok to represent the result
 			switch (a_FunTok.GetArgCount())
 			{
 			case 0: valTok.SetVal(1); a_vArg[0].GetAsString();  break;
 			case 1: valTok.SetVal(1); a_vArg[1].GetAsString();  a_vArg[0].GetVal();  break;
 			case 2: valTok.SetVal(1); a_vArg[2].GetAsString();  a_vArg[1].GetVal();  a_vArg[0].GetVal();  break;
 			case 3: valTok.SetVal(1); a_vArg[3].GetAsString();  a_vArg[2].GetVal();  a_vArg[1].GetVal();  a_vArg[0].GetVal();  break;
 			case 4: valTok.SetVal(1); a_vArg[4].GetAsString();  a_vArg[3].GetVal();  a_vArg[2].GetVal();  a_vArg[1].GetVal();  a_vArg[0].GetVal();  break;
 			default: Error(ecINTERNAL_ERROR);
 			}
 		}
 		catch (ParserError&)
 		{
 			Error(ecVAL_EXPECTED, m_pTokenReader->GetPos(), a_FunTok.GetAsString());
 		}
 
 		// string functions won't be optimized
 		m_vRPN.AddStrFun(pFunc, a_FunTok.GetArgCount(), a_vArg.back().GetIdx());
 
 		// Push dummy value representing the function result to the stack
 		return valTok;
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Apply a function token.
 		\param iArgCount Number of Arguments actually gathered used only for multiarg functions.
 		\post The result is pushed to the value stack
 		\post The function token is removed from the stack
 		\throw exception_type if Argument count does not match function requirements.
 	*/
 	void ParserBase::ApplyFunc(std::stack<token_type>& a_stOpt, std::stack<token_type>& a_stVal, int a_iArgCount) const
 	{
 		MUP_ASSERT(m_pTokenReader.get());
 
 		// Operator stack empty or does not contain tokens with callback functions
 		if (a_stOpt.empty() || a_stOpt.top().GetFuncAddr() == 0)
 			return;
 
 		token_type funTok = a_stOpt.top();
 		a_stOpt.pop();
 		MUP_ASSERT(funTok.GetFuncAddr() != nullptr);
 
 		// Binary operators must rely on their internal operator number
 		// since counting of operators relies on commas for function arguments
 		// binary operators do not have commas in their expression
 		int iArgCount = (funTok.GetCode() == cmOPRT_BIN) ? funTok.GetArgCount() : a_iArgCount;
 
 		// determine how many parameters the function needs. To remember iArgCount includes the 
 		// string parameter whilst GetArgCount() counts only numeric parameters.
 		int iArgRequired = funTok.GetArgCount() + ((funTok.GetType() == tpSTR) ? 1 : 0);
 
 		// That's the number of numerical parameters
 		int iArgNumerical = iArgCount - ((funTok.GetType() == tpSTR) ? 1 : 0);
 
 		if (funTok.GetCode() == cmFUNC_STR && iArgCount - iArgNumerical > 1)
 			Error(ecINTERNAL_ERROR);
 
 		if (funTok.GetArgCount() >= 0 && iArgCount > iArgRequired)
 			Error(ecTOO_MANY_PARAMS, m_pTokenReader->GetPos() - 1, funTok.GetAsString());
 
 		if (funTok.GetCode() != cmOPRT_BIN && iArgCount < iArgRequired)
 			Error(ecTOO_FEW_PARAMS, m_pTokenReader->GetPos() - 1, funTok.GetAsString());
 
 		if (funTok.GetCode() == cmFUNC_STR && iArgCount > iArgRequired)
 			Error(ecTOO_MANY_PARAMS, m_pTokenReader->GetPos() - 1, funTok.GetAsString());
 
 		// Collect the numeric function arguments from the value stack and store them
 		// in a vector
 		std::vector<token_type> stArg;
 		for (int i = 0; i < iArgNumerical; ++i)
 		{
 			if (a_stVal.empty())
 				Error(ecINTERNAL_ERROR, m_pTokenReader->GetPos(), funTok.GetAsString());
 
 			stArg.push_back(a_stVal.top());
 			a_stVal.pop();
 
 			if (stArg.back().GetType() == tpSTR && funTok.GetType() != tpSTR)
 				Error(ecVAL_EXPECTED, m_pTokenReader->GetPos(), funTok.GetAsString());
 		}
 
 		switch (funTok.GetCode())
 		{
 		case  cmFUNC_STR:
 			if (a_stVal.empty())
 				Error(ecINTERNAL_ERROR, m_pTokenReader->GetPos(), funTok.GetAsString());
 
 			stArg.push_back(a_stVal.top());
 			a_stVal.pop();
 
 			if (stArg.back().GetType() == tpSTR && funTok.GetType() != tpSTR)
 				Error(ecVAL_EXPECTED, m_pTokenReader->GetPos(), funTok.GetAsString());
 
 			ApplyStrFunc(funTok, stArg);
 			break;
 
 		case  cmFUNC_BULK:
 			m_vRPN.AddBulkFun(funTok.GetFuncAddr(), (int)stArg.size());
 			break;
 
 		case  cmOPRT_BIN:
 		case  cmOPRT_POSTFIX:
 		case  cmOPRT_INFIX:
 		case  cmFUNC:
 			if (funTok.GetArgCount() == -1 && iArgCount == 0)
 				Error(ecTOO_FEW_PARAMS, m_pTokenReader->GetPos(), funTok.GetAsString());
 
 			m_vRPN.AddFun(funTok.GetFuncAddr(), (funTok.GetArgCount() == -1) ? -iArgNumerical : iArgNumerical);
 			break;
 		default:
 			break;
 		}
 
 		// Push dummy value representing the function result to the stack
 		token_type token;
 		token.SetVal(1);
 		a_stVal.push(token);
 	}
 
 	//---------------------------------------------------------------------------
 	void ParserBase::ApplyIfElse(std::stack<token_type>& a_stOpt, std::stack<token_type>& a_stVal) const
 	{
 		// Check if there is an if Else clause to be calculated
 		while (a_stOpt.size() && a_stOpt.top().GetCode() == cmELSE)
 		{
 			MUP_ASSERT(!a_stOpt.empty())
 			token_type opElse = a_stOpt.top();
 			a_stOpt.pop();
 
 			// Take the value associated with the else branch from the value stack
 			MUP_ASSERT(!a_stVal.empty());
 			token_type vVal2 = a_stVal.top();
 			if (vVal2.GetType() != tpDBL)
 				Error(ecUNEXPECTED_STR, m_pTokenReader->GetPos());
 			
 			a_stVal.pop();
 
 			// it then else is a ternary operator Pop all three values from the value s
 			// tack and just return the right value
 			MUP_ASSERT(!a_stVal.empty());
 			token_type vVal1 = a_stVal.top();
 			if (vVal1.GetType() != tpDBL)
 				Error(ecUNEXPECTED_STR, m_pTokenReader->GetPos());
 
 			a_stVal.pop();
 
 			MUP_ASSERT(!a_stVal.empty());
 			token_type vExpr = a_stVal.top();
 			a_stVal.pop();
 
 			a_stVal.push((vExpr.GetVal() != 0) ? vVal1 : vVal2);
 
 			token_type opIf = a_stOpt.top();
 			a_stOpt.pop();
 
 			MUP_ASSERT(opElse.GetCode() == cmELSE);
 
 			if (opIf.GetCode() != cmIF)
 				Error(ecMISPLACED_COLON, m_pTokenReader->GetPos());
 
 			m_vRPN.AddIfElse(cmENDIF);
 		} // while pending if-else-clause found
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Performs the necessary steps to write code for
 			   the execution of binary operators into the bytecode.
 	*/
 	void ParserBase::ApplyBinOprt(std::stack<token_type>& a_stOpt, std::stack<token_type>& a_stVal) const
 	{
 		// is it a user defined binary operator?
 		if (a_stOpt.top().GetCode() == cmOPRT_BIN)
 		{
 			ApplyFunc(a_stOpt, a_stVal, 2);
 		}
 		else
 		{
 			if (a_stVal.size() < 2)
 				Error(ecINTERNAL_ERROR, m_pTokenReader->GetPos(), _T("ApplyBinOprt: not enough values in value stack!"));
 
 			token_type valTok1 = a_stVal.top();
 			a_stVal.pop();
 
 			token_type valTok2 = a_stVal.top();
 			a_stVal.pop();
 
 			token_type optTok = a_stOpt.top();
 			a_stOpt.pop();
 
 			token_type resTok;
 
 			if (valTok1.GetType() != valTok2.GetType() ||
 				(valTok1.GetType() == tpSTR && valTok2.GetType() == tpSTR))
 				Error(ecOPRT_TYPE_CONFLICT, m_pTokenReader->GetPos(), optTok.GetAsString());
 
 			if (optTok.GetCode() == cmASSIGN)
 			{
 				if (valTok2.GetCode() != cmVAR)
 					Error(ecUNEXPECTED_OPERATOR, -1, _T("="));
 
 				m_vRPN.AddAssignOp(valTok2.GetVar());
 			}
 			else
 				m_vRPN.AddOp(optTok.GetCode());
 
 			resTok.SetVal(1);
 			a_stVal.push(resTok);
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Apply a binary operator.
 		\param a_stOpt The operator stack
 		\param a_stVal The value stack
 	*/
 	void ParserBase::ApplyRemainingOprt(std::stack<token_type>& stOpt, std::stack<token_type>& stVal) const
 	{
 		while (stOpt.size() &&
 			stOpt.top().GetCode() != cmBO &&
 			stOpt.top().GetCode() != cmIF)
 		{
 			token_type tok = stOpt.top();
 			switch (tok.GetCode())
 			{
 			case cmOPRT_INFIX:
 			case cmOPRT_BIN:
 			case cmLE:
 			case cmGE:
 			case cmNEQ:
 			case cmEQ:
 			case cmLT:
 			case cmGT:
 			case cmADD:
 			case cmSUB:
 			case cmMUL:
 			case cmDIV:
 			case cmPOW:
 			case cmLAND:
 			case cmLOR:
 			case cmASSIGN:
 				if (stOpt.top().GetCode() == cmOPRT_INFIX)
 					ApplyFunc(stOpt, stVal, 1);
 				else
 					ApplyBinOprt(stOpt, stVal);
 				break;
 
 			case cmELSE:
 				ApplyIfElse(stOpt, stVal);
 				break;
 
 			default:
 				Error(ecINTERNAL_ERROR);
 			}
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Parse the command code.
 		\sa ParseString(...)
 
 		Command code contains precalculated stack positions of the values and the
 		associated operators. The Stack is filled beginning from index one the
 		value at index zero is not used at all.
 	*/
 	value_type ParserBase::ParseCmdCode() const
 	{
 		return ParseCmdCodeBulk(0, 0);
 	}
 
 	value_type ParserBase::ParseCmdCodeShort() const
 	{
 		const SToken *const tok = m_vRPN.GetBase();
 		value_type buf;
 
 		switch (tok->Cmd)
 		{
 		case cmVAL:		
 			return tok->Val.data2;
 
 		case cmVAR:		
 			return *tok->Val.ptr;
 
 		case cmVARMUL:	
 			return *tok->Val.ptr * tok->Val.data + tok->Val.data2;
 
 		case cmVARPOW2: 
 			buf = *(tok->Val.ptr);
 			return buf * buf;
 
 		case  cmVARPOW3: 				
 			buf = *(tok->Val.ptr);
 			return buf * buf * buf;
 
 		case  cmVARPOW4: 				
 			buf = *(tok->Val.ptr);
 			return buf * buf * buf * buf;
 
 		// numerical function without any argument
 		case cmFUNC:
 			return (*(fun_type0)tok->Fun.ptr)();
 
 		// String function without a numerical argument
 		case cmFUNC_STR:
 			return (*(strfun_type1)tok->Fun.ptr)(m_vStringBuf[0].c_str());
 
 		default:
 			throw ParserError(ecINTERNAL_ERROR);
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Evaluate the RPN.
 		\param nOffset The offset added to variable addresses (for bulk mode)
 		\param nThreadID OpenMP Thread id of the calling thread
 	*/
 	value_type ParserBase::ParseCmdCodeBulk(int nOffset, int nThreadID) const
 	{
 		assert(nThreadID <= s_MaxNumOpenMPThreads);
 
 		// Note: The check for nOffset==0 and nThreadID here is not necessary but 
 		//       brings a minor performance gain when not in bulk mode.
 		value_type* Stack = ((nOffset == 0) && (nThreadID == 0)) ? &m_vStackBuffer[0] : &m_vStackBuffer[nThreadID * (m_vStackBuffer.size() / s_MaxNumOpenMPThreads)];
 		value_type buf;
 		int sidx(0);
 		for (const SToken* pTok = m_vRPN.GetBase(); pTok->Cmd != cmEND; ++pTok)
 		{
 			switch (pTok->Cmd)
 			{
 			// built in binary operators
 			case  cmLE:   --sidx; Stack[sidx] = Stack[sidx] <= Stack[sidx + 1]; continue;
 			case  cmGE:   --sidx; Stack[sidx] = Stack[sidx] >= Stack[sidx + 1]; continue;
 			case  cmNEQ:  --sidx; Stack[sidx] = Stack[sidx] != Stack[sidx + 1]; continue;
 			case  cmEQ:   --sidx; Stack[sidx] = Stack[sidx] == Stack[sidx + 1]; continue;
 			case  cmLT:   --sidx; Stack[sidx] = Stack[sidx] < Stack[sidx + 1];  continue;
 			case  cmGT:   --sidx; Stack[sidx] = Stack[sidx] > Stack[sidx + 1];  continue;
 			case  cmADD:  --sidx; Stack[sidx] += Stack[1 + sidx]; continue;
 			case  cmSUB:  --sidx; Stack[sidx] -= Stack[1 + sidx]; continue;
 			case  cmMUL:  --sidx; Stack[sidx] *= Stack[1 + sidx]; continue;
 			case  cmDIV:  --sidx;
 				Stack[sidx] /= Stack[1 + sidx];
 				continue;
 
 			case  cmPOW:
 				--sidx; Stack[sidx] = MathImpl<value_type>::Pow(Stack[sidx], Stack[1 + sidx]);
 				continue;
 
 			case  cmLAND: --sidx; Stack[sidx] = Stack[sidx] && Stack[sidx + 1]; continue;
 			case  cmLOR:  --sidx; Stack[sidx] = Stack[sidx] || Stack[sidx + 1]; continue;
 
 			case  cmASSIGN:
 				// Bugfix for Bulkmode:
 				// for details see:
 				//    https://groups.google.com/forum/embed/?place=forum/muparser-dev&showsearch=true&showpopout=true&showtabs=false&parenturl=http://muparser.beltoforion.de/mup_forum.html&afterlogin&pli=1#!topic/muparser-dev/szgatgoHTws
 				--sidx; Stack[sidx] = *(pTok->Oprt.ptr + nOffset) = Stack[sidx + 1]; continue;
 				// original code:
 				//--sidx; Stack[sidx] = *pTok->Oprt.ptr = Stack[sidx+1]; continue;
 
 			case  cmIF:
 				if (Stack[sidx--] == 0)
 				{
 					MUP_ASSERT(sidx >= 0);
 					pTok += pTok->Oprt.offset;
 				}
 				continue;
 
 			case  cmELSE:
 				pTok += pTok->Oprt.offset;
 				continue;
 
 			case  cmENDIF:
 				continue;
 
 				// value and variable tokens
 			case  cmVAR:    Stack[++sidx] = *(pTok->Val.ptr + nOffset);  continue;
 			case  cmVAL:    Stack[++sidx] = pTok->Val.data2;  continue;
 
 			case  cmVARPOW2: buf = *(pTok->Val.ptr + nOffset);
 				Stack[++sidx] = buf * buf;
 				continue;
 
 			case  cmVARPOW3: buf = *(pTok->Val.ptr + nOffset);
 				Stack[++sidx] = buf * buf * buf;
 				continue;
 
 			case  cmVARPOW4: buf = *(pTok->Val.ptr + nOffset);
 				Stack[++sidx] = buf * buf * buf * buf;
 				continue;
 
 			case  cmVARMUL:  
 				Stack[++sidx] = *(pTok->Val.ptr + nOffset) * pTok->Val.data + pTok->Val.data2;
 				continue;
 
 				// Next is treatment of numeric functions
 			case  cmFUNC:
 			{
 				int iArgCount = pTok->Fun.argc;
 
 				// switch according to argument count
 				switch (iArgCount)
 				{
 				case 0: sidx += 1; Stack[sidx] = (*(fun_type0)pTok->Fun.ptr)(); continue;
 				case 1:            Stack[sidx] = (*(fun_type1)pTok->Fun.ptr)(Stack[sidx]);   continue;
 				case 2: sidx -= 1; Stack[sidx] = (*(fun_type2)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1]); continue;
 				case 3: sidx -= 2; Stack[sidx] = (*(fun_type3)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2]); continue;
 				case 4: sidx -= 3; Stack[sidx] = (*(fun_type4)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3]); continue;
 				case 5: sidx -= 4; Stack[sidx] = (*(fun_type5)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4]); continue;
 				case 6: sidx -= 5; Stack[sidx] = (*(fun_type6)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5]); continue;
 				case 7: sidx -= 6; Stack[sidx] = (*(fun_type7)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6]); continue;
 				case 8: sidx -= 7; Stack[sidx] = (*(fun_type8)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7]); continue;
 				case 9: sidx -= 8; Stack[sidx] = (*(fun_type9)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7], Stack[sidx + 8]); continue;
 				case 10:sidx -= 9; Stack[sidx] = (*(fun_type10)pTok->Fun.ptr)(Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7], Stack[sidx + 8], Stack[sidx + 9]); continue;
 				default:
 					// function with variable arguments store the number as a negative value
 					if (iArgCount > 0)
 						Error(ecINTERNAL_ERROR, -1);
 
 					sidx -= -iArgCount - 1;
 
 					// <ibg 2020-06-08> From oss-fuzz. Happend when Multiarg functions and if-then-else are used incorrectly.
 					// Expressions where this was observed:
 					//		sum(0?1,2,3,4,5:6)			-> fixed
 					//		avg(0>3?4:(""),0^3?4:(""))
 					//
 					// The final result normally lieas at position 1. If sixd is smaller there is something wrong.
 					if (sidx <= 0)
 						Error(ecINTERNAL_ERROR, -1);
 					// </ibg>
 
 					Stack[sidx] = (*(multfun_type)pTok->Fun.ptr)(&Stack[sidx], -iArgCount);
 					continue;
 				}
 			}
 
 			// Next is treatment of string functions
 			case  cmFUNC_STR:
 			{
 				sidx -= pTok->Fun.argc - 1;
 
 				// The index of the string argument in the string table
 				int iIdxStack = pTok->Fun.idx;
 				if (iIdxStack < 0 || iIdxStack >= (int)m_vStringBuf.size())
 					Error(ecINTERNAL_ERROR, m_pTokenReader->GetPos());
 
 				switch (pTok->Fun.argc)  // switch according to argument count
 				{
 				case 0: Stack[sidx] = (*(strfun_type1)pTok->Fun.ptr)(m_vStringBuf[iIdxStack].c_str()); continue;
 				case 1: Stack[sidx] = (*(strfun_type2)pTok->Fun.ptr)(m_vStringBuf[iIdxStack].c_str(), Stack[sidx]); continue;
 				case 2: Stack[sidx] = (*(strfun_type3)pTok->Fun.ptr)(m_vStringBuf[iIdxStack].c_str(), Stack[sidx], Stack[sidx + 1]); continue;
 				case 3: Stack[sidx] = (*(strfun_type4)pTok->Fun.ptr)(m_vStringBuf[iIdxStack].c_str(), Stack[sidx], Stack[sidx + 1], Stack[sidx + 2]); continue;
 				case 4: Stack[sidx] = (*(strfun_type5)pTok->Fun.ptr)(m_vStringBuf[iIdxStack].c_str(), Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3]); continue;
 				}
 
 				continue;
 			}
 
 			case  cmFUNC_BULK:
 			{
 				int iArgCount = pTok->Fun.argc;
 
 				// switch according to argument count
 				switch (iArgCount)
 				{
 				case 0: sidx += 1; Stack[sidx] = (*(bulkfun_type0)pTok->Fun.ptr)(nOffset, nThreadID); continue;
 				case 1:            Stack[sidx] = (*(bulkfun_type1)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx]); continue;
 				case 2: sidx -= 1; Stack[sidx] = (*(bulkfun_type2)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1]); continue;
 				case 3: sidx -= 2; Stack[sidx] = (*(bulkfun_type3)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2]); continue;
 				case 4: sidx -= 3; Stack[sidx] = (*(bulkfun_type4)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3]); continue;
 				case 5: sidx -= 4; Stack[sidx] = (*(bulkfun_type5)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4]); continue;
 				case 6: sidx -= 5; Stack[sidx] = (*(bulkfun_type6)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5]); continue;
 				case 7: sidx -= 6; Stack[sidx] = (*(bulkfun_type7)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6]); continue;
 				case 8: sidx -= 7; Stack[sidx] = (*(bulkfun_type8)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7]); continue;
 				case 9: sidx -= 8; Stack[sidx] = (*(bulkfun_type9)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7], Stack[sidx + 8]); continue;
 				case 10:sidx -= 9; Stack[sidx] = (*(bulkfun_type10)pTok->Fun.ptr)(nOffset, nThreadID, Stack[sidx], Stack[sidx + 1], Stack[sidx + 2], Stack[sidx + 3], Stack[sidx + 4], Stack[sidx + 5], Stack[sidx + 6], Stack[sidx + 7], Stack[sidx + 8], Stack[sidx + 9]); continue;
 				default:
 					throw exception_type(ecINTERNAL_ERROR, 2, _T(""));
 				}
 			}
 
 			default:
 				throw exception_type(ecINTERNAL_ERROR, 3, _T(""));
 			} // switch CmdCode
 		} // for all bytecode tokens
 
 		return Stack[m_nFinalResultIdx];
 	}
 
 	//---------------------------------------------------------------------------
 	void ParserBase::CreateRPN() const
 	{
 		if (!m_pTokenReader->GetExpr().length())
 			Error(ecUNEXPECTED_EOF, 0);
 
 		std::stack<token_type> stOpt, stVal;
 		std::stack<int> stArgCount;
 		token_type opta, opt;  // for storing operators
 		token_type val, tval;  // for storing value
 		int ifElseCounter = 0;
 
 		ReInit();
 
 		// The outermost counter counts the number of separated items
 		// such as in "a=10,b=20,c=c+a"
 		stArgCount.push(1);
 
 		for (;;)
 		{
 			opt = m_pTokenReader->ReadNextToken();
 
 			switch (opt.GetCode())
 			{
 			//
 			// Next three are different kind of value entries
 			//
 			case cmSTRING:
 				if (stOpt.empty())
 					Error(ecSTR_RESULT, m_pTokenReader->GetPos(), opt.GetAsString());
 
 				opt.SetIdx((int)m_vStringBuf.size());      // Assign buffer index to token 
 				stVal.push(opt);
 				m_vStringBuf.push_back(opt.GetAsString()); // Store string in internal buffer
 				break;
 
 			case cmVAR:
 				stVal.push(opt);
 				m_vRPN.AddVar(static_cast<value_type*>(opt.GetVar()));
 				break;
 
 			case cmVAL:
 				stVal.push(opt);
 				m_vRPN.AddVal(opt.GetVal());
 				break;
 
 			case cmELSE:
 				if (stArgCount.empty())
 					Error(ecMISPLACED_COLON, m_pTokenReader->GetPos());
 
 				if (stArgCount.top() > 1)
 					Error(ecUNEXPECTED_ARG_SEP, m_pTokenReader->GetPos());
 
 				stArgCount.pop();
 
 				ifElseCounter--;
 				if (ifElseCounter < 0)
 					Error(ecMISPLACED_COLON, m_pTokenReader->GetPos());
 
 				ApplyRemainingOprt(stOpt, stVal);
 				m_vRPN.AddIfElse(cmELSE);
 				stOpt.push(opt);
 				break;
 
 			case cmARG_SEP:
 				if (!stOpt.empty() && stOpt.top().GetCode() == cmIF)
 					Error(ecUNEXPECTED_ARG_SEP, m_pTokenReader->GetPos());
 
 				if (stArgCount.empty())
 					Error(ecUNEXPECTED_ARG_SEP, m_pTokenReader->GetPos());
 
 				++stArgCount.top();
 				// Falls through.
 				// intentional (no break!)
 
 			case cmEND:
 				ApplyRemainingOprt(stOpt, stVal);
 				break;
 
 			case cmBC:
 			{
 				// The argument count for parameterless functions is zero
 				// by default an opening bracket sets parameter count to 1
 				// in preparation of arguments to come. If the last token
 				// was an opening bracket we know better...
 				if (opta.GetCode() == cmBO)
 					--stArgCount.top();
 
 				ApplyRemainingOprt(stOpt, stVal);
 
 				// Check if the bracket content has been evaluated completely
 				if (stOpt.size() && stOpt.top().GetCode() == cmBO)
 				{
 					// if opt is ")" and opta is "(" the bracket has been evaluated, now its time to check
 					// if there is either a function or a sign pending
 					// neither the opening nor the closing bracket will be pushed back to
 					// the operator stack
 					// Check if a function is standing in front of the opening bracket, 
 					// if yes evaluate it afterwards check for infix operators
 					MUP_ASSERT(stArgCount.size());
 					int iArgCount = stArgCount.top();
 					stArgCount.pop();
 
 					stOpt.pop(); // Take opening bracket from stack
 
 					if (iArgCount > 1 && (stOpt.size() == 0 ||
 						(stOpt.top().GetCode() != cmFUNC &&
 							stOpt.top().GetCode() != cmFUNC_BULK &&
 							stOpt.top().GetCode() != cmFUNC_STR)))
 						Error(ecUNEXPECTED_ARG, m_pTokenReader->GetPos());
 
 					// The opening bracket was popped from the stack now check if there
 					// was a function before this bracket
 					if (stOpt.size() &&
 						stOpt.top().GetCode() != cmOPRT_INFIX &&
 						stOpt.top().GetCode() != cmOPRT_BIN &&
 						stOpt.top().GetFuncAddr() != 0)
 					{
 						ApplyFunc(stOpt, stVal, iArgCount);
 					}
 				}
 			} // if bracket content is evaluated
 			break;
 
 			//
 			// Next are the binary operator entries
 			//
 			case cmIF:
 				ifElseCounter++;
 				stArgCount.push(1);
 				// Falls through.
 				// intentional (no break!)
 
 			case cmLAND:
 			case cmLOR:
 			case cmLT:
 			case cmGT:
 			case cmLE:
 			case cmGE:
 			case cmNEQ:
 			case cmEQ:
 			case cmADD:
 			case cmSUB:
 			case cmMUL:
 			case cmDIV:
 			case cmPOW:
 			case cmASSIGN:
 			case cmOPRT_BIN:
 
 				// A binary operator (user defined or built in) has been found. 
 				while (
 					stOpt.size() &&
 					stOpt.top().GetCode() != cmBO &&
 					stOpt.top().GetCode() != cmELSE &&
 					stOpt.top().GetCode() != cmIF)
 				{
 					int nPrec1 = GetOprtPrecedence(stOpt.top()),
 						nPrec2 = GetOprtPrecedence(opt);
 
 					if (stOpt.top().GetCode() == opt.GetCode())
 					{
 
 						// Deal with operator associativity
 						EOprtAssociativity eOprtAsct = GetOprtAssociativity(opt);
 						if ((eOprtAsct == oaRIGHT && (nPrec1 <= nPrec2)) ||
 							(eOprtAsct == oaLEFT && (nPrec1 < nPrec2)))
 						{
 							break;
 						}
 					}
 					else if (nPrec1 < nPrec2)
 					{
 						// In case the operators are not equal the precedence decides alone...
 						break;
 					}
 
 					if (stOpt.top().GetCode() == cmOPRT_INFIX)
 						ApplyFunc(stOpt, stVal, 1);
 					else
 						ApplyBinOprt(stOpt, stVal);
 				} // while ( ... )
 
 				if (opt.GetCode() == cmIF)
 					m_vRPN.AddIfElse(opt.GetCode());
 
 				// The operator can't be evaluated right now, push back to the operator stack
 				stOpt.push(opt);
 				break;
 
 				//
 				// Last section contains functions and operators implicitly mapped to functions
 				//
 			case cmBO:
 				stArgCount.push(1);
 				stOpt.push(opt);
 				break;
 
 			case cmOPRT_INFIX:
 			case cmFUNC:
 			case cmFUNC_BULK:
 			case cmFUNC_STR:
 				stOpt.push(opt);
 				break;
 
 			case cmOPRT_POSTFIX:
 				stOpt.push(opt);
 				ApplyFunc(stOpt, stVal, 1);  // this is the postfix operator
 				break;
 
 			default:  Error(ecINTERNAL_ERROR, 3);
 			} // end of switch operator-token
 
 			opta = opt;
 
 			if (opt.GetCode() == cmEND)
 			{
 				m_vRPN.Finalize();
 				break;
 			}
 
 			if (ParserBase::g_DbgDumpStack)
 			{
 				StackDump(stVal, stOpt);
 				m_vRPN.AsciiDump();
 			}
 
 //			if (ParserBase::g_DbgDumpCmdCode)
 				//m_vRPN.AsciiDump();
 		} // while (true)
 
 		if (ParserBase::g_DbgDumpCmdCode)
 			m_vRPN.AsciiDump();
 
 		if (ifElseCounter > 0)
 			Error(ecMISSING_ELSE_CLAUSE);
 
 		// get the last value (= final result) from the stack
 		MUP_ASSERT(stArgCount.size() == 1);
 		m_nFinalResultIdx = stArgCount.top();
 		if (m_nFinalResultIdx == 0)
 			Error(ecINTERNAL_ERROR, 9);
 
 		if (stVal.size() == 0)
 			Error(ecEMPTY_EXPRESSION);
 
-		if (stVal.top().GetType() != tpDBL)
-			Error(ecSTR_RESULT);
+		// 2020-09-17; fix for https://oss-fuzz.com/testcase-detail/5758791700971520
+		// I don't need the value stack any more. Destructively check if all values in the value 
+		// stack represent floating point values
+		while (stVal.size())
+		{
+			if (stVal.top().GetType() != tpDBL)
+				Error(ecSTR_RESULT);
+
+			stVal.pop();
+		}
 
 		m_vStackBuffer.resize(m_vRPN.GetMaxStackSize() * s_MaxNumOpenMPThreads);
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief One of the two main parse functions.
 		\sa ParseCmdCode(...)
 
 	  Parse expression from input string. Perform syntax checking and create
 	  bytecode. After parsing the string and creating the bytecode the function
 	  pointer #m_pParseFormula will be changed to the second parse routine the
 	  uses bytecode instead of string parsing.
 	*/
 	value_type ParserBase::ParseString() const
 	{
 		try
 		{
 			CreateRPN();
 
 			if (m_vRPN.GetSize() == 2)
 			{
 				m_pParseFormula = &ParserBase::ParseCmdCodeShort;
 			}
 			else
 			{
 				m_pParseFormula = &ParserBase::ParseCmdCode;
 			}
 			
 			return (this->*m_pParseFormula)();
 		}
 		catch (ParserError& exc)
 		{
 			exc.SetFormula(m_pTokenReader->GetExpr());
 			throw;
 		}
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Create an error containing the parse error position.
 
 	  This function will create an Parser Exception object containing the error text and
 	  its position.
 
 	  \param a_iErrc [in] The error code of type #EErrorCodes.
 	  \param a_iPos [in] The position where the error was detected.
 	  \param a_strTok [in] The token string representation associated with the error.
 	  \throw ParserException always throws that's the only purpose of this function.
 	*/
 	void  ParserBase::Error(EErrorCodes a_iErrc, int a_iPos, const string_type& a_sTok) const
 	{
 		throw exception_type(a_iErrc, a_sTok, m_pTokenReader->GetExpr(), a_iPos);
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear all user defined variables.
 		\throw nothrow
 
 		Resets the parser to string parsing mode by calling #ReInit.
 	*/
 	void ParserBase::ClearVar()
 	{
 		m_VarDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Remove a variable from internal storage.
 		\throw nothrow
 
 		Removes a variable if it exists. If the Variable does not exist nothing will be done.
 	*/
 	void ParserBase::RemoveVar(const string_type& a_strVarName)
 	{
 		varmap_type::iterator item = m_VarDef.find(a_strVarName);
 		if (item != m_VarDef.end())
 		{
 			m_VarDef.erase(item);
 			ReInit();
 		}
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear all functions.
 		\post Resets the parser to string parsing mode.
 		\throw nothrow
 	*/
 	void ParserBase::ClearFun()
 	{
 		m_FunDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear all user defined constants.
 
 		Both numeric and string constants will be removed from the internal storage.
 		\post Resets the parser to string parsing mode.
 		\throw nothrow
 	*/
 	void ParserBase::ClearConst()
 	{
 		m_ConstDef.clear();
 		m_StrVarDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear all user defined postfix operators.
 		\post Resets the parser to string parsing mode.
 		\throw nothrow
 	*/
 	void ParserBase::ClearPostfixOprt()
 	{
 		m_PostOprtDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear all user defined binary operators.
 		\post Resets the parser to string parsing mode.
 		\throw nothrow
 	*/
 	void ParserBase::ClearOprt()
 	{
 		m_OprtDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Clear the user defined Prefix operators.
 		\post Resets the parser to string parser mode.
 		\throw nothrow
 	*/
 	void ParserBase::ClearInfixOprt()
 	{
 		m_InfixOprtDef.clear();
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Enable or disable the formula optimization feature.
 		\post Resets the parser to string parser mode.
 		\throw nothrow
 	*/
 	void ParserBase::EnableOptimizer(bool a_bIsOn)
 	{
 		m_vRPN.EnableOptimizer(a_bIsOn);
 		ReInit();
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Enable the dumping of bytecode and stack content on the console.
 		\param bDumpCmd Flag to enable dumping of the current bytecode to the console.
 		\param bDumpStack Flag to enable dumping of the stack content is written to the console.
 
 	   This function is for debug purposes only!
 	*/
 	void ParserBase::EnableDebugDump(bool bDumpCmd, bool bDumpStack)
 	{
 		ParserBase::g_DbgDumpCmdCode = bDumpCmd;
 		ParserBase::g_DbgDumpStack = bDumpStack;
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Enable or disable the built in binary operators.
 		\throw nothrow
 		\sa m_bBuiltInOp, ReInit()
 
 	  If you disable the built in binary operators there will be no binary operators
 	  defined. Thus you must add them manually one by one. It is not possible to
 	  disable built in operators selectively. This function will Reinitialize the
 	  parser by calling ReInit().
 	*/
 	void ParserBase::EnableBuiltInOprt(bool a_bIsOn)
 	{
 		m_bBuiltInOp = a_bIsOn;
 		ReInit();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Query status of built in variables.
 		\return #m_bBuiltInOp; true if built in operators are enabled.
 		\throw nothrow
 	*/
 	bool ParserBase::HasBuiltInOprt() const
 	{
 		return m_bBuiltInOp;
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Get the argument separator character.
 	*/
 	char_type ParserBase::GetArgSep() const
 	{
 		return m_pTokenReader->GetArgSep();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Set argument separator.
 		\param cArgSep the argument separator character.
 	*/
 	void ParserBase::SetArgSep(char_type cArgSep)
 	{
 		m_pTokenReader->SetArgSep(cArgSep);
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Dump stack content.
 
 		This function is used for debugging only.
 	*/
 	void ParserBase::StackDump(const std::stack<token_type>& a_stVal, const std::stack<token_type>& a_stOprt) const
 	{
 		std::stack<token_type> stOprt(a_stOprt);
 		std::stack<token_type> stVal(a_stVal);
 
 		mu::console() << _T("\nValue stack:\n");
 		while (!stVal.empty())
 		{
 			token_type val = stVal.top();
 			stVal.pop();
 
 			if (val.GetType() == tpSTR)
 				mu::console() << _T(" \"") << val.GetAsString() << _T("\" ");
 			else
 				mu::console() << _T(" ") << val.GetVal() << _T(" ");
 		}
 		mu::console() << "\nOperator stack:\n";
 
 		while (!stOprt.empty())
 		{
 			if (stOprt.top().GetCode() <= cmASSIGN)
 			{
 				mu::console() << _T("OPRT_INTRNL \"")
 					<< ParserBase::c_DefaultOprt[stOprt.top().GetCode()]
 					<< _T("\" \n");
 			}
 			else
 			{
 				switch (stOprt.top().GetCode())
 				{
 				case cmVAR:   mu::console() << _T("VAR\n");  break;
 				case cmVAL:   mu::console() << _T("VAL\n");  break;
 				case cmFUNC:
 					mu::console()
 						<< _T("FUNC \"")
 						<< stOprt.top().GetAsString()
 						<< _T("\"\n");
 					break;
 
 				case cmFUNC_BULK:
 					mu::console()
 						<< _T("FUNC_BULK \"")
 						<< stOprt.top().GetAsString()
 						<< _T("\"\n");
 					break;
 
 				case cmOPRT_INFIX:
 					mu::console() << _T("OPRT_INFIX \"")
 						<< stOprt.top().GetAsString()
 						<< _T("\"\n");
 					break;
 
 				case cmOPRT_BIN:
 					mu::console() << _T("OPRT_BIN \"")
 						<< stOprt.top().GetAsString()
 						<< _T("\"\n");
 					break;
 
 				case cmFUNC_STR: mu::console() << _T("FUNC_STR\n");       break;
 				case cmEND:      mu::console() << _T("END\n");            break;
 				case cmUNKNOWN:  mu::console() << _T("UNKNOWN\n");        break;
 				case cmBO:       mu::console() << _T("BRACKET \"(\"\n");  break;
 				case cmBC:       mu::console() << _T("BRACKET \")\"\n");  break;
 				case cmIF:       mu::console() << _T("IF\n");  break;
 				case cmELSE:     mu::console() << _T("ELSE\n");  break;
 				case cmENDIF:    mu::console() << _T("ENDIF\n");  break;
 				default:         mu::console() << stOprt.top().GetCode() << _T(" ");  break;
 				}
 			}
 			stOprt.pop();
 		}
 
 		mu::console() << dec << endl;
 	}
 
 	/** \brief Calculate the result.
 
 	  A note on const correctness:
 	  I consider it important that Calc is a const function.
 	  Due to caching operations Calc changes only the state of internal variables with one exception
 	  m_UsedVar this is reset during string parsing and accessible from the outside. Instead of making
 	  Calc non const GetUsedVar is non const because it explicitly calls Eval() forcing this update.
 
 	  \pre A formula must be set.
 	  \pre Variables must have been set (if needed)
 
 	  \sa #m_pParseFormula
 	  \return The evaluation result
 	  \throw ParseException if no Formula is set or in case of any other error related to the formula.
 	*/
 	value_type ParserBase::Eval() const
 	{
 		return (this->*m_pParseFormula)();
 	}
 
 	//------------------------------------------------------------------------------
 	/** \brief Evaluate an expression containing comma separated subexpressions
 		\param [out] nStackSize The total number of results available
 		\return Pointer to the array containing all expression results
 
 		This member function can be used to retrieve all results of an expression
 		made up of multiple comma separated subexpressions (i.e. "x+y,sin(x),cos(y)")
 	*/
 	value_type* ParserBase::Eval(int& nStackSize) const
 	{
 		if (m_vRPN.GetSize() > 0)
 		{
 			ParseCmdCode();
 		}
 		else
 		{
 			ParseString();
 		}
 
 		nStackSize = m_nFinalResultIdx;
 
 		// (for historic reasons the stack starts at position 1)
 		return &m_vStackBuffer[1];
 	}
 
 	//---------------------------------------------------------------------------
 	/** \brief Return the number of results on the calculation stack.
 
 	  If the expression contains comma separated subexpressions (i.e. "sin(y), x+y").
 	  There may be more than one return value. This function returns the number of
 	  available results.
 	*/
 	int ParserBase::GetNumResults() const
 	{
 		return m_nFinalResultIdx;
 	}
 
 	//---------------------------------------------------------------------------
 	void ParserBase::Eval(value_type* results, int nBulkSize)
 	{
 		CreateRPN();
 
 		int i = 0;
 
 #ifdef MUP_USE_OPENMP
 		//#define DEBUG_OMP_STUFF
 #ifdef DEBUG_OMP_STUFF
 		int* pThread = new int[nBulkSize];
 		int* pIdx = new int[nBulkSize];
 #endif
 
 		int nMaxThreads = std::min(omp_get_max_threads(), s_MaxNumOpenMPThreads);
 		int nThreadID = 0;
 
 #ifdef DEBUG_OMP_STUFF
 		int ct = 0;
 #endif
 		omp_set_num_threads(nMaxThreads);
 
 #pragma omp parallel for schedule(static, std::max(nBulkSize/nMaxThreads, 1)) private(nThreadID)
 		for (i = 0; i < nBulkSize; ++i)
 		{
 			nThreadID = omp_get_thread_num();
 			results[i] = ParseCmdCodeBulk(i, nThreadID);
 
 #ifdef DEBUG_OMP_STUFF
 #pragma omp critical
 			{
 				pThread[ct] = nThreadID;
 				pIdx[ct] = i;
 				ct++;
 			}
 #endif
 		}
 
 #ifdef DEBUG_OMP_STUFF
 		FILE* pFile = fopen("bulk_dbg.txt", "w");
 		for (i = 0; i < nBulkSize; ++i)
 		{
 			fprintf(pFile, "idx: %d  thread: %d \n", pIdx[i], pThread[i]);
 		}
 
 		delete[] pIdx;
 		delete[] pThread;
 
 		fclose(pFile);
 #endif
 
 #else
 		for (i = 0; i < nBulkSize; ++i)
 		{
 			results[i] = ParseCmdCodeBulk(i, 0);
 		}
 #endif
 
 	}
 } // namespace mu
 
 #if defined(_MSC_VER)
 	#pragma warning(pop)
 #endif
 
diff --git a/src/muParserTest.cpp b/src/muParserTest.cpp
index 9d39436..e67af60 100644
--- a/src/muParserTest.cpp
+++ b/src/muParserTest.cpp
@@ -42,1574 +42,1584 @@ using namespace std;
 namespace mu
 {
 	namespace Test
 	{
 		int ParserTester::c_iCount = 0;
 
 		//---------------------------------------------------------------------------------------------
 		ParserTester::ParserTester()
 			:m_vTestFun()
 		{
 			AddTest(&ParserTester::TestNames);
 			AddTest(&ParserTester::TestSyntax);
 			AddTest(&ParserTester::TestPostFix);
 			AddTest(&ParserTester::TestInfixOprt);
 			AddTest(&ParserTester::TestVarConst);
 			AddTest(&ParserTester::TestMultiArg);
 			AddTest(&ParserTester::TestExpression);
 			AddTest(&ParserTester::TestIfThenElse);
 			AddTest(&ParserTester::TestInterface);
 			AddTest(&ParserTester::TestBinOprt);
 			AddTest(&ParserTester::TestException);
 			AddTest(&ParserTester::TestStrArg);
 			AddTest(&ParserTester::TestBulkMode);
 
 			ParserTester::c_iCount = 0;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		int ParserTester::IsHexVal(const char_type* a_szExpr, int* a_iPos, value_type* a_fVal)
 		{
 			if (a_szExpr[1] == 0 || (a_szExpr[0] != '0' || a_szExpr[1] != 'x'))
 				return 0;
 
 			unsigned iVal(0);
 
 			// New code based on streams for UNICODE compliance:
 			stringstream_type::pos_type nPos(0);
 			stringstream_type ss(a_szExpr + 2);
 			ss >> std::hex >> iVal;
 			nPos = ss.tellg();
 
 			if (nPos == (stringstream_type::pos_type)0)
 				return 1;
 
 			*a_iPos += (int)(2 + nPos);
 			*a_fVal = (value_type)iVal;
 			return 1;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		int ParserTester::TestInterface()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing member functions...");
 
 			// Test RemoveVar
 			value_type afVal[3] = { 1,2,3 };
 			Parser p;
 
 			try
 			{
 				p.DefineVar(_T("a"), &afVal[0]);
 				p.DefineVar(_T("b"), &afVal[1]);
 				p.DefineVar(_T("c"), &afVal[2]);
 				p.SetExpr(_T("a+b+c"));
 				p.Eval();
 			}
 			catch (...)
 			{
 				iStat += 1;  // this is not supposed to happen 
 			}
 
 			try
 			{
 				p.RemoveVar(_T("c"));
 				p.Eval();
 				iStat += 1;  // not supposed to reach this, nonexisting variable "c" deleted...
 			}
 			catch (...)
 			{
 				// failure is expected...
 			}
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		int ParserTester::TestStrArg()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing string arguments...");
 
 			// from oss-fuzz: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=23410
 			iStat += ThrowTest(_T(R"(6 - 6 ? 4 : "", ? 4 : "", ? 4 : "")"), ecUNEXPECTED_STR,  true);
 			// variations:
 			iStat += ThrowTest(_T(R"(avg(0?4:(""),1))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(1 ? 4 : "")"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(1 ? "" : 4)"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(1 ? "" : "")"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(0 ? 4 : "")"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(0 ? 4 : (""))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(1 ? 4 : "")"), ecUNEXPECTED_STR);
 
 			// from oss-fuzz: https://oss-fuzz.com/testcase-detail/5106868061208576
 			iStat += ThrowTest(_T(R"("","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",8)"), ecSTR_RESULT);
+			
+			// derived from oss-fuzz: https://oss-fuzz.com/testcase-detail/5758791700971520
+			iStat += ThrowTest(_T("(\"\"), 7"), ecSTR_RESULT);
+			iStat += ThrowTest(_T("((\"\")), 7"), ecSTR_RESULT);
+			//iStat += ThrowTest(_T("(\"\"),(\" \"), 7, (3)"), ecSTR_RESULT);
+			//iStat += ThrowTest(_T("(\"\"),(\"\"), 7, (3)"), ecSTR_RESULT);
+			//iStat += ThrowTest(_T("(\"\"),(\"\"), (3)"), ecSTR_RESULT);
+			//iStat += ThrowTest(_T("(\"\"),(\"\"), 7"), ecSTR_RESULT);
+
+			
 			// variations:
 			iStat += ThrowTest(_T(R"("","",9)"), ecSTR_RESULT);
 
 			iStat += EqnTest(_T("valueof(\"\")"), 123, true);   // empty string arguments caused a crash
 			iStat += EqnTest(_T("valueof(\"aaa\")+valueof(\"bbb\")  "), 246, true);
 			iStat += EqnTest(_T("2*(valueof(\"aaa\")-23)+valueof(\"bbb\")"), 323, true);
 
 			// use in expressions with variables
 			iStat += EqnTest(_T("a*(atof(\"10\")-b)"), 8, true);
 			iStat += EqnTest(_T("a-(atof(\"10\")*b)"), -19, true);
 
 			// string + numeric arguments
 			iStat += EqnTest(_T("strfun1(\"100\")"), 100, true);
 			iStat += EqnTest(_T("strfun2(\"100\",1)"), 101, true);
 			iStat += EqnTest(_T("strfun3(\"99\",1,2)"), 102, true);
 			iStat += EqnTest(_T("strfun4(\"99\",1,2,3)"), 105, true);
 			iStat += EqnTest(_T("strfun5(\"99\",1,2,3,4)"), 109, true);
 
 			// string constants
 			iStat += EqnTest(_T("atof(str1)+atof(str2)"), 3.33, true);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		int ParserTester::TestBulkMode()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing bulkmode...");
 
 #define EQN_TEST_BULK(EXPR, R1, R2, R3, R4, PASS) \
 			{ \
 			  double res[] = { R1, R2, R3, R4 }; \
 			  iStat += EqnTestBulk(_T(EXPR), res, (PASS)); \
 			}
 
 			// Bulk Variables for the test:
 			// a: 1,2,3,4
 			// b: 2,2,2,2
 			// c: 3,3,3,3
 			// d: 5,4,3,2
 			EQN_TEST_BULK("a", 1, 1, 1, 1, false)
 			EQN_TEST_BULK("a", 1, 2, 3, 4, true)
 			EQN_TEST_BULK("b=a", 1, 2, 3, 4, true)
 			EQN_TEST_BULK("b=a, b*10", 10, 20, 30, 40, true)
 			EQN_TEST_BULK("b=a, b*10, a", 1, 2, 3, 4, true)
 			EQN_TEST_BULK("a+b", 3, 4, 5, 6, true)
 			EQN_TEST_BULK("c*(a+b)", 9, 12, 15, 18, true)
 #undef EQN_TEST_BULK
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		int ParserTester::TestBinOprt()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing binary operators...");
 
 			// built in operators
 			// xor operator
 
 			iStat += EqnTest(_T("a++b"), 3, true);
 			iStat += EqnTest(_T("a ++ b"), 3, true);
 			iStat += EqnTest(_T("1++2"), 3, true);
 			iStat += EqnTest(_T("1 ++ 2"), 3, true);
 			iStat += EqnTest(_T("a add b"), 3, true);
 			iStat += EqnTest(_T("1 add 2"), 3, true);
 			iStat += EqnTest(_T("a<b"), 1, true);
 			iStat += EqnTest(_T("b>a"), 1, true);
 			iStat += EqnTest(_T("a>a"), 0, true);
 			iStat += EqnTest(_T("a<a"), 0, true);
 			iStat += EqnTest(_T("a>a"), 0, true);
 			iStat += EqnTest(_T("a<=a"), 1, true);
 			iStat += EqnTest(_T("a<=b"), 1, true);
 			iStat += EqnTest(_T("b<=a"), 0, true);
 			iStat += EqnTest(_T("a>=a"), 1, true);
 			iStat += EqnTest(_T("b>=a"), 1, true);
 			iStat += EqnTest(_T("a>=b"), 0, true);
 
 			// Test logical operators, especially if user defined "&" and the internal "&&" collide
 			iStat += EqnTest(_T("1 && 1"), 1, true);
 			iStat += EqnTest(_T("1 && 0"), 0, true);
 			iStat += EqnTest(_T("(a<b) && (b>a)"), 1, true);
 			iStat += EqnTest(_T("(a<b) && (a>b)"), 0, true);
 			//iStat += EqnTest(_T("12 and 255"), 12, true); 
 			//iStat += EqnTest(_T("12 and 0"), 0, true); 
 			iStat += EqnTest(_T("12 & 255"), 12, true);
 			iStat += EqnTest(_T("12 & 0"), 0, true);
 			iStat += EqnTest(_T("12&255"), 12, true);
 			iStat += EqnTest(_T("12&0"), 0, true);
 
 			// Assignment operator
 			iStat += EqnTest(_T("a = b"), 2, true);
 			iStat += EqnTest(_T("a = sin(b)"), 0.909297, true);
 			iStat += EqnTest(_T("a = 1+sin(b)"), 1.909297, true);
 			iStat += EqnTest(_T("(a=b)*2"), 4, true);
 			iStat += EqnTest(_T("2*(a=b)"), 4, true);
 			iStat += EqnTest(_T("2*(a=b+1)"), 6, true);
 			iStat += EqnTest(_T("(a=b+1)*2"), 6, true);
 			iStat += EqnTest(_T("a=c, a*10"), 30, true);
 
 			iStat += EqnTest(_T("2^2^3"), 256, true);
 			iStat += EqnTest(_T("1/2/3"), 1.0 / 6.0, true);
 
 			// reference: http://www.wolframalpha.com/input/?i=3%2B4*2%2F%281-5%29^2^3
 			iStat += EqnTest(_T("3+4*2/(1-5)^2^3"), 3.0001220703125, true);
 
 			// Test user defined binary operators
 			iStat += EqnTestInt(_T("1 | 2"), 3, true);
 			iStat += EqnTestInt(_T("1 || 2"), 1, true);
 			iStat += EqnTestInt(_T("123 & 456"), 72, true);
 			iStat += EqnTestInt(_T("(123 & 456) % 10"), 2, true);
 			iStat += EqnTestInt(_T("1 && 0"), 0, true);
 			iStat += EqnTestInt(_T("123 && 456"), 1, true);
 			iStat += EqnTestInt(_T("1 << 3"), 8, true);
 			iStat += EqnTestInt(_T("8 >> 3"), 1, true);
 			iStat += EqnTestInt(_T("9 / 4"), 2, true);
 			iStat += EqnTestInt(_T("9 % 4"), 1, true);
 			iStat += EqnTestInt(_T("if(5%2,1,0)"), 1, true);
 			iStat += EqnTestInt(_T("if(4%2,1,0)"), 0, true);
 			iStat += EqnTestInt(_T("-10+1"), -9, true);
 			iStat += EqnTestInt(_T("1+2*3"), 7, true);
 			iStat += EqnTestInt(_T("const1 != const2"), 1, true);
 			iStat += EqnTestInt(_T("const1 != const2"), 0, false);
 			iStat += EqnTestInt(_T("const1 == const2"), 0, true);
 			iStat += EqnTestInt(_T("const1 == 1"), 1, true);
 			iStat += EqnTestInt(_T("10*(const1 == 1)"), 10, true);
 			iStat += EqnTestInt(_T("2*(const1 | const2)"), 6, true);
 			iStat += EqnTestInt(_T("2*(const1 | const2)"), 7, false);
 			iStat += EqnTestInt(_T("const1 < const2"), 1, true);
 			iStat += EqnTestInt(_T("const2 > const1"), 1, true);
 			iStat += EqnTestInt(_T("const1 <= 1"), 1, true);
 			iStat += EqnTestInt(_T("const2 >= 2"), 1, true);
 			iStat += EqnTestInt(_T("2*(const1 + const2)"), 6, true);
 			iStat += EqnTestInt(_T("2*(const1 - const2)"), -2, true);
 			iStat += EqnTestInt(_T("a != b"), 1, true);
 			iStat += EqnTestInt(_T("a != b"), 0, false);
 			iStat += EqnTestInt(_T("a == b"), 0, true);
 			iStat += EqnTestInt(_T("a == 1"), 1, true);
 			iStat += EqnTestInt(_T("10*(a == 1)"), 10, true);
 			iStat += EqnTestInt(_T("2*(a | b)"), 6, true);
 			iStat += EqnTestInt(_T("2*(a | b)"), 7, false);
 			iStat += EqnTestInt(_T("a < b"), 1, true);
 			iStat += EqnTestInt(_T("b > a"), 1, true);
 			iStat += EqnTestInt(_T("a <= 1"), 1, true);
 			iStat += EqnTestInt(_T("b >= 2"), 1, true);
 			iStat += EqnTestInt(_T("2*(a + b)"), 6, true);
 			iStat += EqnTestInt(_T("2*(a - b)"), -2, true);
 			iStat += EqnTestInt(_T("a + (a << b)"), 5, true);
 			iStat += EqnTestInt(_T("-2^2"), -4, true);
 			iStat += EqnTestInt(_T("3--a"), 4, true);
 			iStat += EqnTestInt(_T("3+-3^2"), -6, true);
 
 			// Test reading of hex values:
 			iStat += EqnTestInt(_T("0xff"), 255, true);
 			iStat += EqnTestInt(_T("10+0xff"), 265, true);
 			iStat += EqnTestInt(_T("0xff+10"), 265, true);
 			iStat += EqnTestInt(_T("10*0xff"), 2550, true);
 			iStat += EqnTestInt(_T("0xff*10"), 2550, true);
 			iStat += EqnTestInt(_T("10+0xff+1"), 266, true);
 			iStat += EqnTestInt(_T("1+0xff+10"), 266, true);
 
 			// incorrect: '^' is yor here, not power
 			//    iStat += EqnTestInt("-(1+2)^2", -9, true);
 			//    iStat += EqnTestInt("-1^3", -1, true);          
 
 				  // Test precedence
 				  // a=1, b=2, c=3
 			iStat += EqnTestInt(_T("a + b * c"), 7, true);
 			iStat += EqnTestInt(_T("a * b + c"), 5, true);
 			iStat += EqnTestInt(_T("a<b && b>10"), 0, true);
 			iStat += EqnTestInt(_T("a<b && b<10"), 1, true);
 
 			iStat += EqnTestInt(_T("a + b << c"), 17, true);
 			iStat += EqnTestInt(_T("a << b + c"), 7, true);
 			iStat += EqnTestInt(_T("c * b < a"), 0, true);
 			iStat += EqnTestInt(_T("c * b == 6 * a"), 1, true);
 			iStat += EqnTestInt(_T("2^2^3"), 256, true);
 
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------------------------
 		/** \brief Check muParser name restriction enforcement. */
 		int ParserTester::TestNames()
 		{
 			int  iStat = 0,
 				iErr = 0;
 
 			mu::console() << "testing name restriction enforcement...";
 
 			Parser p;
 
 #define PARSER_THROWCHECK(DOMAIN, FAIL, EXPR, ARG)	\
 			iErr = 0;										\
 			ParserTester::c_iCount++;						\
 			try												\
 			{												\
 				p.Define##DOMAIN(EXPR, ARG);                \
 				iErr = (FAIL) ? 0 : 1;						\
 			}												\
 			catch(...)										\
 			{												\
 				iErr = (!FAIL) ? 0 : 1;						\
 			}												\
 			iStat += iErr;      
 
 			// constant names
 			PARSER_THROWCHECK(Const, false, _T("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"), 1)
 			PARSER_THROWCHECK(Const, false, _T("0a"), 1)
 			PARSER_THROWCHECK(Const, false, _T("9a"), 1)
 			PARSER_THROWCHECK(Const, false, _T("+a"), 1)
 			PARSER_THROWCHECK(Const, false, _T("-a"), 1)
 			PARSER_THROWCHECK(Const, false, _T("a-"), 1)
 			PARSER_THROWCHECK(Const, false, _T("a*"), 1)
 			PARSER_THROWCHECK(Const, false, _T("a?"), 1)
 			PARSER_THROWCHECK(Const, true, _T("a"), 1)
 			PARSER_THROWCHECK(Const, true, _T("a_min"), 1)
 			PARSER_THROWCHECK(Const, true, _T("a_min0"), 1)
 			PARSER_THROWCHECK(Const, true, _T("a_min9"), 1)
 
 			// variable names
 			value_type a;
 			p.ClearConst();
 			PARSER_THROWCHECK(Var, false, _T("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"), &a);
 			PARSER_THROWCHECK(Var, false, _T("123abc"), &a)
 			PARSER_THROWCHECK(Var, false, _T("9a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("0a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("+a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("-a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("?a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("!a"), &a)
 			PARSER_THROWCHECK(Var, false, _T("a+"), &a)
 			PARSER_THROWCHECK(Var, false, _T("a-"), &a)
 			PARSER_THROWCHECK(Var, false, _T("a*"), &a)
 			PARSER_THROWCHECK(Var, false, _T("a?"), &a)
 			PARSER_THROWCHECK(Var, true, _T("a"), &a)
 			PARSER_THROWCHECK(Var, true, _T("a_min"), &a)
 			PARSER_THROWCHECK(Var, true, _T("a_min0"), &a)
 			PARSER_THROWCHECK(Var, true, _T("a_min9"), &a)
 			PARSER_THROWCHECK(Var, false, _T("a_min9"), 0)
 
 			// Postfix operators
 			// fail
 			PARSER_THROWCHECK(PostfixOprt, false, _T("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"), f1of1);
 			PARSER_THROWCHECK(PostfixOprt, false, _T("(k"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, false, _T("9+"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, false, _T("+"), 0)
 			// pass
 			PARSER_THROWCHECK(PostfixOprt, true, _T("-a"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("?a"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("_"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("#"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("&&"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("||"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("&"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("|"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("++"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("--"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("?>"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("?<"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("**"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("xor"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("and"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("or"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("not"), f1of1)
 			PARSER_THROWCHECK(PostfixOprt, true, _T("!"), f1of1)
 
 			// Binary operator
 			// The following must fail with builtin operators activated
 			// p.EnableBuiltInOp(true); -> this is the default
 			p.ClearPostfixOprt();
 			PARSER_THROWCHECK(Oprt, false, _T("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"), f1of2);
 			PARSER_THROWCHECK(Oprt, false, _T("+"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("-"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("*"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("/"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("^"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("&&"), f1of2)
 			PARSER_THROWCHECK(Oprt, false, _T("||"), f1of2)
 
 			// without activated built in operators it should work
 			p.EnableBuiltInOprt(false);
 			PARSER_THROWCHECK(Oprt, true, _T("+"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("-"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("*"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("/"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("^"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("&&"), f1of2)
 			PARSER_THROWCHECK(Oprt, true, _T("||"), f1of2)
 #undef PARSER_THROWCHECK
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestSyntax()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing syntax engine...");
 
 			iStat += ThrowTest(_T("1,"), ecUNEXPECTED_EOF);  // incomplete hex definition
 			iStat += ThrowTest(_T("a,"), ecUNEXPECTED_EOF);  // incomplete hex definition
 			iStat += ThrowTest(_T("sin(8),"), ecUNEXPECTED_EOF);  // incomplete hex definition
 			iStat += ThrowTest(_T("(sin(8)),"), ecUNEXPECTED_EOF);  // incomplete hex definition
 			iStat += ThrowTest(_T("a{m},"), ecUNEXPECTED_EOF);  // incomplete hex definition
 
 			iStat += EqnTest(_T("(1+ 2*a)"), 3, true);   // Spaces within formula
 			iStat += EqnTest(_T("sqrt((4))"), 2, true);  // Multiple brackets
 			iStat += EqnTest(_T("sqrt((2)+2)"), 2, true);// Multiple brackets
 			iStat += EqnTest(_T("sqrt(2+(2))"), 2, true);// Multiple brackets
 			iStat += EqnTest(_T("sqrt(a+(3))"), 2, true);// Multiple brackets
 			iStat += EqnTest(_T("sqrt((3)+a)"), 2, true);// Multiple brackets
 			iStat += EqnTest(_T("order(1,2)"), 1, true); // May not cause name collision with operator "or"
 			iStat += EqnTest(_T("(2+"), 0, false);       // missing closing bracket 
 			iStat += EqnTest(_T("2++4"), 0, false);      // unexpected operator
 			iStat += EqnTest(_T("2+-4"), 0, false);      // unexpected operator
 			iStat += EqnTest(_T("(2+)"), 0, false);      // unexpected closing bracket
 			iStat += EqnTest(_T("--2"), 0, false);       // double sign
 			iStat += EqnTest(_T("ksdfj"), 0, false);     // unknown token
 			iStat += EqnTest(_T("()"), 0, false);        // empty bracket without a function
 			iStat += EqnTest(_T("5+()"), 0, false);      // empty bracket without a function
 			iStat += EqnTest(_T("sin(cos)"), 0, false);  // unexpected function
 			iStat += EqnTest(_T("5t6"), 0, false);       // unknown token
 			iStat += EqnTest(_T("5 t 6"), 0, false);     // unknown token
 			iStat += EqnTest(_T("8*"), 0, false);        // unexpected end of formula
 			iStat += EqnTest(_T(",3"), 0, false);        // unexpected comma
 			iStat += EqnTest(_T("3,5"), 0, false);       // unexpected comma
 			iStat += EqnTest(_T("sin(8,8)"), 0, false);  // too many function args
 			iStat += EqnTest(_T("(7,8)"), 0, false);     // too many function args
 			iStat += EqnTest(_T("sin)"), 0, false);      // unexpected closing bracket
 			iStat += EqnTest(_T("a)"), 0, false);        // unexpected closing bracket
 			iStat += EqnTest(_T("pi)"), 0, false);       // unexpected closing bracket
 			iStat += EqnTest(_T("sin(())"), 0, false);   // unexpected closing bracket
 			iStat += EqnTest(_T("sin()"), 0, false);     // unexpected closing bracket
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestVarConst()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing variable/constant detection...");
 
 			// Test if the result changes when a variable changes
 			iStat += EqnTestWithVarChange(_T("a"), 1, 1, 2, 2);
 			iStat += EqnTestWithVarChange(_T("2*a"), 2, 4, 3, 6);
 
 			// distinguish constants with same basename
 			iStat += EqnTest(_T("const"), 1, true);
 			iStat += EqnTest(_T("const1"), 2, true);
 			iStat += EqnTest(_T("const2"), 3, true);
 			iStat += EqnTest(_T("2*const"), 2, true);
 			iStat += EqnTest(_T("2*const1"), 4, true);
 			iStat += EqnTest(_T("2*const2"), 6, true);
 			iStat += EqnTest(_T("2*const+1"), 3, true);
 			iStat += EqnTest(_T("2*const1+1"), 5, true);
 			iStat += EqnTest(_T("2*const2+1"), 7, true);
 			iStat += EqnTest(_T("const"), 0, false);
 			iStat += EqnTest(_T("const1"), 0, false);
 			iStat += EqnTest(_T("const2"), 0, false);
 
 			// distinguish variables with same basename
 			iStat += EqnTest(_T("a"), 1, true);
 			iStat += EqnTest(_T("aa"), 2, true);
 			iStat += EqnTest(_T("2*a"), 2, true);
 			iStat += EqnTest(_T("2*aa"), 4, true);
 			iStat += EqnTest(_T("2*a-1"), 1, true);
 			iStat += EqnTest(_T("2*aa-1"), 3, true);
 
 			// custom value recognition
 			iStat += EqnTest(_T("0xff"), 255, true);
 			iStat += EqnTest(_T("0x97 + 0xff"), 406, true);
 
 			// Finally test querying of used variables
 			try
 			{
 				int idx;
 				mu::Parser p;
 				mu::value_type vVarVal[] = { 1, 2, 3, 4, 5 };
 				p.DefineVar(_T("a"), &vVarVal[0]);
 				p.DefineVar(_T("b"), &vVarVal[1]);
 				p.DefineVar(_T("c"), &vVarVal[2]);
 				p.DefineVar(_T("d"), &vVarVal[3]);
 				p.DefineVar(_T("e"), &vVarVal[4]);
 
 				// Test lookup of defined variables
 				// 4 used variables
 				p.SetExpr(_T("a+b+c+d"));
 				mu::varmap_type UsedVar = p.GetUsedVar();
 				int iCount = (int)UsedVar.size();
 				if (iCount != 4)
 					throw false;
 
 				// the next check will fail if the parser 
 				// erroneously creates new variables internally
 				if (p.GetVar().size() != 5)
 					throw false;
 
 				mu::varmap_type::const_iterator item = UsedVar.begin();
 				for (idx = 0; item != UsedVar.end(); ++item)
 				{
 					if (&vVarVal[idx++] != item->second)
 						throw false;
 				}
 
 				// Test lookup of undefined variables
 				p.SetExpr(_T("undef1+undef2+undef3"));
 				UsedVar = p.GetUsedVar();
 				iCount = (int)UsedVar.size();
 				if (iCount != 3)
 					throw false;
 
 				// the next check will fail if the parser 
 				// erroneously creates new variables internally
 				if (p.GetVar().size() != 5)
 					throw false;
 
 				for (item = UsedVar.begin(); item != UsedVar.end(); ++item)
 				{
 					if (item->second != 0)
 						throw false; // all pointers to undefined variables must be null
 				}
 
 				// 1 used variables
 				p.SetExpr(_T("a+b"));
 				UsedVar = p.GetUsedVar();
 				iCount = (int)UsedVar.size();
 				if (iCount != 2) throw false;
 				item = UsedVar.begin();
 				for (idx = 0; item != UsedVar.end(); ++item)
 					if (&vVarVal[idx++] != item->second) throw false;
 
 			}
 			catch (...)
 			{
 				iStat += 1;
 			}
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestMultiArg()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing multiarg functions...");
 
 			// from oss-fzz.com: UNKNOWN READ; https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=23330#c1
 			iStat += ThrowTest(_T("6, +, +, +, +, +, +, +, +, +, +, +, +, +, +, 1, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +, +"), ecUNEXPECTED_ARG_SEP, true);
 
 			// misplaced string argument			
 			iStat += ThrowTest(_T(R"(sin(0?4:("")))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(avg(0?4:(""),1))"), ecUNEXPECTED_STR);
 
 			// Compound expressions
 			iStat += EqnTest(_T("1,2,3"), 3, true);
 			iStat += EqnTest(_T("a,b,c"), 3, true);
 			iStat += EqnTest(_T("a=10,b=20,c=a*b"), 200, true);
 			iStat += EqnTest(_T("1,\n2,\n3"), 3, true);
 			iStat += EqnTest(_T("a,\nb,\nc"), 3, true);
 			iStat += EqnTest(_T("a=10,\nb=20,\nc=a*b"), 200, true);
 			iStat += EqnTest(_T("1,\r\n2,\r\n3"), 3, true);
 			iStat += EqnTest(_T("a,\r\nb,\r\nc"), 3, true);
 			iStat += EqnTest(_T("a=10,\r\nb=20,\r\nc=a*b"), 200, true);
 
 			// picking the right argument
 			iStat += EqnTest(_T("f1of1(1)"), 1, true);
 			iStat += EqnTest(_T("f1of2(1, 2)"), 1, true);
 			iStat += EqnTest(_T("f2of2(1, 2)"), 2, true);
 			iStat += EqnTest(_T("f1of3(1, 2, 3)"), 1, true);
 			iStat += EqnTest(_T("f2of3(1, 2, 3)"), 2, true);
 			iStat += EqnTest(_T("f3of3(1, 2, 3)"), 3, true);
 			iStat += EqnTest(_T("f1of4(1, 2, 3, 4)"), 1, true);
 			iStat += EqnTest(_T("f2of4(1, 2, 3, 4)"), 2, true);
 			iStat += EqnTest(_T("f3of4(1, 2, 3, 4)"), 3, true);
 			iStat += EqnTest(_T("f4of4(1, 2, 3, 4)"), 4, true);
 			iStat += EqnTest(_T("f1of5(1, 2, 3, 4, 5)"), 1, true);
 			iStat += EqnTest(_T("f2of5(1, 2, 3, 4, 5)"), 2, true);
 			iStat += EqnTest(_T("f3of5(1, 2, 3, 4, 5)"), 3, true);
 			iStat += EqnTest(_T("f4of5(1, 2, 3, 4, 5)"), 4, true);
 			iStat += EqnTest(_T("f5of5(1, 2, 3, 4, 5)"), 5, true);
 			// Too few arguments / Too many arguments
 			iStat += EqnTest(_T("1+ping()"), 11, true);
 			iStat += EqnTest(_T("ping()+1"), 11, true);
 			iStat += EqnTest(_T("2*ping()"), 20, true);
 			iStat += EqnTest(_T("ping()*2"), 20, true);
 			iStat += EqnTest(_T("ping(1,2)"), 0, false);
 			iStat += EqnTest(_T("1+ping(1,2)"), 0, false);
 			iStat += EqnTest(_T("f1of1(1,2)"), 0, false);
 			iStat += EqnTest(_T("f1of1()"), 0, false);
 			iStat += EqnTest(_T("f1of2(1, 2, 3)"), 0, false);
 			iStat += EqnTest(_T("f1of2(1)"), 0, false);
 			iStat += EqnTest(_T("f1of3(1, 2, 3, 4)"), 0, false);
 			iStat += EqnTest(_T("f1of3(1)"), 0, false);
 			iStat += EqnTest(_T("f1of4(1, 2, 3, 4, 5)"), 0, false);
 			iStat += EqnTest(_T("f1of4(1)"), 0, false);
 			iStat += EqnTest(_T("(1,2,3)"), 0, false);
 			iStat += EqnTest(_T("1,2,3"), 0, false);
 			iStat += EqnTest(_T("(1*a,2,3)"), 0, false);
 			iStat += EqnTest(_T("1,2*a,3"), 0, false);
 
 			// correct calculation of arguments
 			iStat += EqnTest(_T("min(a, 1)"), 1, true);
 			iStat += EqnTest(_T("min(3*2, 1)"), 1, true);
 			iStat += EqnTest(_T("min(3*2, 1)"), 6, false);
 			iStat += EqnTest(_T("firstArg(2,3,4)"), 2, true);
 			iStat += EqnTest(_T("lastArg(2,3,4)"), 4, true);
 			iStat += EqnTest(_T("min(3*a+1, 1)"), 1, true);
 			iStat += EqnTest(_T("max(3*a+1, 1)"), 4, true);
 			iStat += EqnTest(_T("max(3*a+1, 1)*2"), 8, true);
 			iStat += EqnTest(_T("2*max(3*a+1, 1)+2"), 10, true);
 
 			// functions with Variable argument count
 			iStat += EqnTest(_T("sum(a)"), 1, true);
 			iStat += EqnTest(_T("sum(1,2,3)"), 6, true);
 			iStat += EqnTest(_T("sum(a,b,c)"), 6, true);
 			iStat += EqnTest(_T("sum(1,-max(1,2),3)*2"), 4, true);
 			iStat += EqnTest(_T("2*sum(1,2,3)"), 12, true);
 			iStat += EqnTest(_T("2*sum(1,2,3)+2"), 14, true);
 			iStat += EqnTest(_T("2*sum(-1,2,3)+2"), 10, true);
 			iStat += EqnTest(_T("2*sum(-1,2,-(-a))+2"), 6, true);
 			iStat += EqnTest(_T("2*sum(-1,10,-a)+2"), 18, true);
 			iStat += EqnTest(_T("2*sum(1,2,3)*2"), 24, true);
 			iStat += EqnTest(_T("sum(1,-max(1,2),3)*2"), 4, true);
 			iStat += EqnTest(_T("sum(1*3, 4, a+2)"), 10, true);
 			iStat += EqnTest(_T("sum(1*3, 2*sum(1,2,2), a+2)"), 16, true);
 			iStat += EqnTest(_T("sum(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2)"), 24, true);
 
 			// some failures
 			iStat += EqnTest(_T("sum()"), 0, false);
 			iStat += EqnTest(_T("sum(,)"), 0, false);
 			iStat += EqnTest(_T("sum(1,2,)"), 0, false);
 			iStat += EqnTest(_T("sum(,1,2)"), 0, false);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestInfixOprt()
 		{
 			int iStat(0);
 			mu::console() << "testing infix operators...";
 
 			iStat += EqnTest(_T("+1"), +1, true);
 			iStat += EqnTest(_T("-(+1)"), -1, true);
 			iStat += EqnTest(_T("-(+1)*2"), -2, true);
 			iStat += EqnTest(_T("-(+2)*sqrt(4)"), -4, true);
 			iStat += EqnTest(_T("3-+a"), 2, true);
 			iStat += EqnTest(_T("+1*3"), 3, true);
 
 			iStat += EqnTest(_T("-1"), -1, true);
 			iStat += EqnTest(_T("-(-1)"), 1, true);
 			iStat += EqnTest(_T("-(-1)*2"), 2, true);
 			iStat += EqnTest(_T("-(-2)*sqrt(4)"), 4, true);
 			iStat += EqnTest(_T("-_pi"), -MathImpl<double>::CONST_PI, true);
 			iStat += EqnTest(_T("-a"), -1, true);
 			iStat += EqnTest(_T("-(a)"), -1, true);
 			iStat += EqnTest(_T("-(-a)"), 1, true);
 			iStat += EqnTest(_T("-(-a)*2"), 2, true);
 			iStat += EqnTest(_T("-(8)"), -8, true);
 			iStat += EqnTest(_T("-8"), -8, true);
 			iStat += EqnTest(_T("-(2+1)"), -3, true);
 			iStat += EqnTest(_T("-(f1of1(1+2*3)+1*2)"), -9, true);
 			iStat += EqnTest(_T("-(-f1of1(1+2*3)+1*2)"), 5, true);
 			iStat += EqnTest(_T("-sin(8)"), -0.989358, true);
 			iStat += EqnTest(_T("3-(-a)"), 4, true);
 			iStat += EqnTest(_T("3--a"), 4, true);
 			iStat += EqnTest(_T("-1*3"), -3, true);
 
 			// Postfix / infix priorities
 			iStat += EqnTest(_T("~2#"), 8, true);
 			iStat += EqnTest(_T("~f1of1(2)#"), 8, true);
 			iStat += EqnTest(_T("~(b)#"), 8, true);
 			iStat += EqnTest(_T("(~b)#"), 12, true);
 			iStat += EqnTest(_T("~(2#)"), 8, true);
 			iStat += EqnTest(_T("~(f1of1(2)#)"), 8, true);
 			//
 			iStat += EqnTest(_T("-2^2"), -4, true);
 			iStat += EqnTest(_T("-(a+b)^2"), -9, true);
 			iStat += EqnTest(_T("(-3)^2"), 9, true);
 			iStat += EqnTest(_T("-(-2^2)"), 4, true);
 			iStat += EqnTest(_T("3+-3^2"), -6, true);
 			// The following assumes use of sqr as postfix operator together
 			// with a sign operator of low priority:
 			iStat += EqnTest(_T("-2'"), -4, true);
 			iStat += EqnTest(_T("-(1+1)'"), -4, true);
 			iStat += EqnTest(_T("2+-(1+1)'"), -2, true);
 			iStat += EqnTest(_T("2+-2'"), -2, true);
 			// This is the classic behaviour of the infix sign operator (here: "$") which is
 			// now deprecated:
 			iStat += EqnTest(_T("$2^2"), 4, true);
 			iStat += EqnTest(_T("$(a+b)^2"), 9, true);
 			iStat += EqnTest(_T("($3)^2"), 9, true);
 			iStat += EqnTest(_T("$($2^2)"), -4, true);
 			iStat += EqnTest(_T("3+$3^2"), 12, true);
 
 			// infix operators sharing the first few characters
 			iStat += EqnTest(_T("~ 123"), (value_type)123.0 + 2, true);
 			iStat += EqnTest(_T("~~ 123"), (value_type)123.0 + 2, true);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestPostFix()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing postfix operators...");
 
 			// application
 			iStat += EqnTest(_T("3{m}+5"), 5.003, true);
 			iStat += EqnTest(_T("1000{m}"), 1, true);
 			iStat += EqnTest(_T("1000 {m}"), 1, true);
 			iStat += EqnTest(_T("(a){m}"), 1e-3, true);
 			iStat += EqnTest(_T("a{m}"), 1e-3, true);
 			iStat += EqnTest(_T("a {m}"), 1e-3, true);
 			iStat += EqnTest(_T("-(a){m}"), -1e-3, true);
 			iStat += EqnTest(_T("-2{m}"), -2e-3, true);
 			iStat += EqnTest(_T("-2 {m}"), -2e-3, true);
 			iStat += EqnTest(_T("f1of1(1000){m}"), 1, true);
 			iStat += EqnTest(_T("-f1of1(1000){m}"), -1, true);
 			iStat += EqnTest(_T("-f1of1(-1000){m}"), 1, true);
 			iStat += EqnTest(_T("f4of4(0,0,0,1000){m}"), 1, true);
 			iStat += EqnTest(_T("2+(a*1000){m}"), 3, true);
 
 			// can postfix operators "m" und "meg" be told apart properly?
 			iStat += EqnTest(_T("2*3000meg+2"), 2 * 3e9 + 2, true);
 
 			// some incorrect results
 			iStat += EqnTest(_T("1000{m}"), 0.1, false);
 			iStat += EqnTest(_T("(a){m}"), 2, false);
 			// failure due to syntax checking
 			iStat += ThrowTest(_T("0x"), ecUNASSIGNABLE_TOKEN);  // incomplete hex definition
 			iStat += ThrowTest(_T("3+"), ecUNEXPECTED_EOF);
 			iStat += ThrowTest(_T("4 + {m}"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("{m}4"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("sin({m})"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("{m} {m}"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("{m}(8)"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("4,{m}"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("-{m}"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("2(-{m})"), ecUNEXPECTED_PARENS);
 			iStat += ThrowTest(_T("2({m})"), ecUNEXPECTED_PARENS);
 
 			iStat += ThrowTest(_T("multi*1.0"), ecUNASSIGNABLE_TOKEN);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestExpression()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing expression samples...");
 
 			value_type b = 2;
 
 			iStat += EqnTest(_T("f0()"), 42, true);
 			iStat += EqnTest(_T("b^2"), 4, true);
 			iStat += EqnTest(_T("b^1"), 2, true);
 			iStat += EqnTest(_T("b^0"), 1, true);
 			iStat += EqnTest(_T("b^-1"), 0.5, true);
 
 			// Optimization
 			iStat += EqnTest(_T("2*b*5"), 20, true);
 			iStat += EqnTest(_T("2*b*5 + 4*b"), 28, true);
 			iStat += EqnTest(_T("2*a/3"), 2.0 / 3.0, true);
 
 			// Addition auf cmVARMUL 
 			iStat += EqnTest(_T("3+b"), b + 3, true);
 			iStat += EqnTest(_T("b+3"), b + 3, true);
 			iStat += EqnTest(_T("b*3+2"), b * 3 + 2, true);
 			iStat += EqnTest(_T("3*b+2"), b * 3 + 2, true);
 			iStat += EqnTest(_T("2+b*3"), b * 3 + 2, true);
 			iStat += EqnTest(_T("2+3*b"), b * 3 + 2, true);
 			iStat += EqnTest(_T("b+3*b"), b + 3 * b, true);
 			iStat += EqnTest(_T("3*b+b"), b + 3 * b, true);
 
 			iStat += EqnTest(_T("2+b*3+b"), 2 + b * 3 + b, true);
 			iStat += EqnTest(_T("b+2+b*3"), b + 2 + b * 3, true);
 
 			iStat += EqnTest(_T("(2*b+1)*4"), (2 * b + 1) * 4, true);
 			iStat += EqnTest(_T("4*(2*b+1)"), (2 * b + 1) * 4, true);
 
 			// operator precedences
 			iStat += EqnTest(_T("1+2-3*4/5^6"), 2.99923, true);
 			iStat += EqnTest(_T("1^2/3*4-5+6"), 2.33333333, true);
 			iStat += EqnTest(_T("1+2*3"), 7, true);
 			iStat += EqnTest(_T("1+2*3"), 7, true);
 			iStat += EqnTest(_T("(1+2)*3"), 9, true);
 			iStat += EqnTest(_T("(1+2)*(-3)"), -9, true);
 			iStat += EqnTest(_T("2/4"), 0.5, true);
 
 			iStat += EqnTest(_T("exp(ln(7))"), 7, true);
 			iStat += EqnTest(_T("e^ln(7)"), 7, true);
 			iStat += EqnTest(_T("e^(ln(7))"), 7, true);
 			iStat += EqnTest(_T("(e^(ln(7)))"), 7, true);
 			iStat += EqnTest(_T("1-(e^(ln(7)))"), -6, true);
 			iStat += EqnTest(_T("2*(e^(ln(7)))"), 14, true);
 			iStat += EqnTest(_T("10^log(5)"), pow(10.0, log(5.0)), true);
 			iStat += EqnTest(_T("10^log10(5)"), 5, true);
 			iStat += EqnTest(_T("2^log2(4)"), 4, true);
 			iStat += EqnTest(_T("-(sin(0)+1)"), -1, true);
 			iStat += EqnTest(_T("-(2^1.1)"), -2.14354692, true);
 
 			iStat += EqnTest(_T("(cos(2.41)/b)"), -0.372056, true);
 			iStat += EqnTest(_T("(1*(2*(3*(4*(5*(6*(a+b)))))))"), 2160, true);
 			iStat += EqnTest(_T("(1*(2*(3*(4*(5*(6*(7*(a+b))))))))"), 15120, true);
 			iStat += EqnTest(_T("(a/((((b+(((e*(((((pi*((((3.45*((pi+a)+pi))+b)+b)*a))+0.68)+e)+a)/a))+a)+b))+b)*a)-pi))"), 0.00377999, true);
 
 			// long formula (Reference: Matlab)
 			iStat += EqnTest(
 				_T("(((-9))-e/(((((((pi-(((-7)+(-3)/4/e))))/(((-5))-2)-((pi+(-0))*(sqrt((e+e))*(-8))*(((-pi)+(-pi)-(-9)*(6*5))")
 				_T("/(-e)-e))/2)/((((sqrt(2/(-e)+6)-(4-2))+((5/(-2))/(1*(-pi)+3))/8)*pi*((pi/((-2)/(-6)*1*(-1))*(-6)+(-e)))))/")
 				_T("((e+(-2)+(-e)*((((-3)*9+(-e)))+(-9)))))))-((((e-7+(((5/pi-(3/1+pi)))))/e)/(-5))/(sqrt((((((1+(-7))))+((((-")
 				_T("e)*(-e)))-8))*(-5)/((-e)))*(-6)-((((((-2)-(-9)-(-e)-1)/3))))/(sqrt((8+(e-((-6))+(9*(-9))))*(((3+2-8))*(7+6")
 				_T("+(-5))+((0/(-e)*(-pi))+7)))+(((((-e)/e/e)+((-6)*5)*e+(3+(-5)/pi))))+pi))/sqrt((((9))+((((pi))-8+2))+pi))/e")
 				_T("*4)*((-5)/(((-pi))*(sqrt(e)))))-(((((((-e)*(e)-pi))/4+(pi)*(-9)))))))+(-pi)"), -12.23016549, true);
 
 			// long formula (Reference: Matlab)
 			iStat += EqnTest(
 				_T("(atan(sin((((((((((((((((pi/cos((a/((((0.53-b)-pi)*e)/b))))+2.51)+a)-0.54)/0.98)+b)*b)+e)/a)+b)+a)+b)+pi)/e")
 				_T(")+a)))*2.77)"), -2.16995656, true);
 
 			// long formula (Reference: Matlab)
 			iStat += EqnTest(_T("1+2-3*4/5^6*(2*(1-5+(3*7^9)*(4+6*7-3)))+12"), -7995810.09926, true);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestIfThenElse()
 		{
 			int iStat = 0;
 			mu::console() << _T("testing if-then-else operator...");
 
 			// from oss-fuzz.com: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24167
 			iStat += ThrowTest(_T(R"(0^3^avg(0>3?4:(""),0^3?4:("")))"), ecUNEXPECTED_STR);
 			// derivatives
 			iStat += ThrowTest(_T(R"(avg(0?(""):4,1))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(avg(0>3?4:(""),0^3?4:("")))"), ecUNEXPECTED_STR);
 
 			iStat += ThrowTest(_T(R"(0?4:(""))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"((0)?4:(""))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"((0>3)?4:(""))"), ecUNEXPECTED_STR);
 			iStat += ThrowTest(_T(R"(0>3?4:(""))"), ecUNEXPECTED_STR);
 
 			// from oss-fuzz.com: https://oss-fuzz.com/testcase-detail/4777121158529024
 			iStat += ThrowTest(_T("3!=min(0?2>2,2>5,1:6)"), ecUNEXPECTED_ARG_SEP);
 
 			// Test error detection
 			iStat += ThrowTest(_T(":3"), ecUNEXPECTED_CONDITIONAL);
 			iStat += ThrowTest(_T("? 1 : 2"), ecUNEXPECTED_CONDITIONAL);
 			iStat += ThrowTest(_T("(a<b) ? (b<c) ? 1 : 2"), ecMISSING_ELSE_CLAUSE);
 			iStat += ThrowTest(_T("(a<b) ? 1"), ecMISSING_ELSE_CLAUSE);
 			iStat += ThrowTest(_T("(a<b) ? a"), ecMISSING_ELSE_CLAUSE);
 			iStat += ThrowTest(_T("(a<b) ? a+b"), ecMISSING_ELSE_CLAUSE);
 			iStat += ThrowTest(_T("a : b"), ecMISPLACED_COLON);
 			iStat += ThrowTest(_T("1 : 2"), ecMISPLACED_COLON);
 			iStat += ThrowTest(_T("(1) ? 1 : 2 : 3"), ecMISPLACED_COLON);
 			iStat += ThrowTest(_T("(true) ? 1 : 2 : 3"), ecUNASSIGNABLE_TOKEN);
 			
 			// from oss-fzz.com: UNKNOWN READ; https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=22922#c1
 			iStat += ThrowTest(_T("1?2:0?(7:1)"), ecMISPLACED_COLON);
 
 			// from oss-fuzz.com: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=22938
 			iStat += ThrowTest(_T("sum(0?1,0,0:3)"), ecUNEXPECTED_ARG_SEP);
 			iStat += ThrowTest(_T("sum(0?(1,0,0):3)"), ecUNEXPECTED_ARG);
 			iStat += ThrowTest(_T("sum(2>3?2,4,2:4)"), ecUNEXPECTED_ARG_SEP);
 			iStat += ThrowTest(_T("sum(2>3?2,4,sin(2):4)"), ecUNEXPECTED_ARG_SEP);
 			iStat += ThrowTest(_T("sum(2>3?sin(2),4,2:4)"), ecUNEXPECTED_ARG_SEP);
 			iStat += ThrowTest(_T("sum(2>3?sin(a),4,2:4)"), ecUNEXPECTED_ARG_SEP);
 			iStat += ThrowTest(_T("sum(2>3?sin(2),4,2:4)"), ecUNEXPECTED_ARG_SEP);
 
 			iStat += EqnTest(_T("1 ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("1<2 ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("a<b ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("(a<b) ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("(1) ? 10 : 11"), 10, true);
 			iStat += EqnTest(_T("(0) ? 10 : 11"), 11, true);
 			iStat += EqnTest(_T("(1) ? a+b : c+d"), 3, true);
 			iStat += EqnTest(_T("(0) ? a+b : c+d"), 1, true);
 			iStat += EqnTest(_T("(1) ? 0 : 1"), 0, true);
 			iStat += EqnTest(_T("(0) ? 0 : 1"), 1, true);
 			iStat += EqnTest(_T("(a<b) ? 10 : 11"), 10, true);
 			iStat += EqnTest(_T("(a>b) ? 10 : 11"), 11, true);
 			iStat += EqnTest(_T("(a<b) ? c : d"), 3, true);
 			iStat += EqnTest(_T("(a>b) ? c : d"), -2, true);
 
 			iStat += EqnTest(_T("(a>b) ? 1 : 0"), 0, true);
 			iStat += EqnTest(_T("((a>b) ? 1 : 0) ? 1 : 2"), 2, true);
 			iStat += EqnTest(_T("((a>b) ? 1 : 0) ? 1 : sum((a>b) ? 1 : 2)"), 2, true);
 			iStat += EqnTest(_T("((a>b) ? 0 : 1) ? 1 : sum((a>b) ? 1 : 2)"), 1, true);
 
 			iStat += EqnTest(_T("sum((a>b) ? 1 : 2)"), 2, true);
 			iStat += EqnTest(_T("sum((1) ? 1 : 2)"), 1, true);
 			iStat += EqnTest(_T("sum((a>b) ? 1 : 2, 100)"), 102, true);
 			iStat += EqnTest(_T("sum((1) ? 1 : 2, 100)"), 101, true);
 			iStat += EqnTest(_T("sum(3, (a>b) ? 3 : 10)"), 13, true);
 			iStat += EqnTest(_T("sum(3, (a<b) ? 3 : 10)"), 6, true);
 			iStat += EqnTest(_T("10*sum(3, (a>b) ? 3 : 10)"), 130, true);
 			iStat += EqnTest(_T("10*sum(3, (a<b) ? 3 : 10)"), 60, true);
 			iStat += EqnTest(_T("sum(3, (a>b) ? 3 : 10)*10"), 130, true);
 			iStat += EqnTest(_T("sum(3, (a<b) ? 3 : 10)*10"), 60, true);
 			iStat += EqnTest(_T("(a<b) ? sum(3, (a<b) ? 3 : 10)*10 : 99"), 60, true);
 			iStat += EqnTest(_T("(a>b) ? sum(3, (a<b) ? 3 : 10)*10 : 99"), 99, true);
 			iStat += EqnTest(_T("(a<b) ? sum(3, (a<b) ? 3 : 10,10,20)*10 : 99"), 360, true);
 			iStat += EqnTest(_T("(a>b) ? sum(3, (a<b) ? 3 : 10,10,20)*10 : 99"), 99, true);
 			iStat += EqnTest(_T("(a>b) ? sum(3, (a<b) ? 3 : 10,10,20)*10 : sum(3, (a<b) ? 3 : 10)*10"), 60, true);
 
 			// todo: also add for muParserX!
 			iStat += EqnTest(_T("(a<b)&&(a<b) ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("(a>b)&&(a<b) ? 128 : 255"), 255, true);
 			iStat += EqnTest(_T("(1<2)&&(1<2) ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("(1>2)&&(1<2) ? 128 : 255"), 255, true);
 			iStat += EqnTest(_T("((1<2)&&(1<2)) ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("((1>2)&&(1<2)) ? 128 : 255"), 255, true);
 			iStat += EqnTest(_T("((a<b)&&(a<b)) ? 128 : 255"), 128, true);
 			iStat += EqnTest(_T("((a>b)&&(a<b)) ? 128 : 255"), 255, true);
 
 			iStat += EqnTest(_T("1>0 ? 1>2 ? 128 : 255 : 1>0 ? 32 : 64"), 255, true);
 			iStat += EqnTest(_T("1>0 ? 1>2 ? 128 : 255 :(1>0 ? 32 : 64)"), 255, true);
 			iStat += EqnTest(_T("1>0 ? 1>0 ? 128 : 255 : 1>2 ? 32 : 64"), 128, true);
 			iStat += EqnTest(_T("1>0 ? 1>0 ? 128 : 255 :(1>2 ? 32 : 64)"), 128, true);
 			iStat += EqnTest(_T("1>2 ? 1>2 ? 128 : 255 : 1>0 ? 32 : 64"), 32, true);
 			iStat += EqnTest(_T("1>2 ? 1>0 ? 128 : 255 : 1>2 ? 32 : 64"), 64, true);
 			iStat += EqnTest(_T("1>0 ? 50 :  1>0 ? 128 : 255"), 50, true);
 			iStat += EqnTest(_T("1>0 ? 50 : (1>0 ? 128 : 255)"), 50, true);
 			iStat += EqnTest(_T("1>0 ? 1>0 ? 128 : 255 : 50"), 128, true);
 			iStat += EqnTest(_T("1>2 ? 1>2 ? 128 : 255 : 1>0 ? 32 : 1>2 ? 64 : 16"), 32, true);
 			iStat += EqnTest(_T("1>2 ? 1>2 ? 128 : 255 : 1>0 ? 32 :(1>2 ? 64 : 16)"), 32, true);
 			iStat += EqnTest(_T("1>0 ? 1>2 ? 128 : 255 :  1>0 ? 32 :1>2 ? 64 : 16"), 255, true);
 			iStat += EqnTest(_T("1>0 ? 1>2 ? 128 : 255 : (1>0 ? 32 :1>2 ? 64 : 16)"), 255, true);
 			iStat += EqnTest(_T("1 ? 0 ? 128 : 255 : 1 ? 32 : 64"), 255, true);
 
 			// assignment operators
 			iStat += EqnTest(_T("a= 0 ? 128 : 255, a"), 255, true);
 			iStat += EqnTest(_T("a=((a>b)&&(a<b)) ? 128 : 255, a"), 255, true);
 			iStat += EqnTest(_T("c=(a<b)&&(a<b) ? 128 : 255, c"), 128, true);
 			iStat += EqnTest(_T("0 ? a=a+1 : 666, a"), 1, true);
 			iStat += EqnTest(_T("1?a=10:a=20, a"), 10, true);
 			iStat += EqnTest(_T("0?a=10:a=20, a"), 20, true);
 			iStat += EqnTest(_T("0?a=sum(3,4):10, a"), 1, true);  // a should not change its value due to lazy calculation
 
 			iStat += EqnTest(_T("a=1?b=1?3:4:5, a"), 3, true);
 			iStat += EqnTest(_T("a=1?b=1?3:4:5, b"), 3, true);
 			iStat += EqnTest(_T("a=0?b=1?3:4:5, a"), 5, true);
 			iStat += EqnTest(_T("a=0?b=1?3:4:5, b"), 2, true);
 
 			iStat += EqnTest(_T("a=1?5:b=1?3:4, a"), 5, true);
 			iStat += EqnTest(_T("a=1?5:b=1?3:4, b"), 2, true);
 			iStat += EqnTest(_T("a=0?5:b=1?3:4, a"), 3, true);
 			iStat += EqnTest(_T("a=0?5:b=1?3:4, b"), 3, true);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::TestException()
 		{
 			int  iStat = 0;
 			mu::console() << _T("testing error codes...");
 
 			iStat += ThrowTest(_T("3+"), ecUNEXPECTED_EOF);
 			iStat += ThrowTest(_T("3+)"), ecUNEXPECTED_PARENS);
 			iStat += ThrowTest(_T("()"), ecUNEXPECTED_PARENS);
 			iStat += ThrowTest(_T("3+()"), ecUNEXPECTED_PARENS);
 			iStat += ThrowTest(_T("sin(3,4)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("sin()"), ecTOO_FEW_PARAMS);
 			iStat += ThrowTest(_T("(1+2"), ecMISSING_PARENS);
 			iStat += ThrowTest(_T("sin(3)3"), ecUNEXPECTED_VAL);
 			iStat += ThrowTest(_T("sin(3)xyz"), ecUNASSIGNABLE_TOKEN);
 			iStat += ThrowTest(_T("sin(3)cos(3)"), ecUNEXPECTED_FUN);
 			iStat += ThrowTest(_T("a+b+c=10"), ecUNEXPECTED_OPERATOR);
 			iStat += ThrowTest(_T("a=b=3"), ecUNEXPECTED_OPERATOR);
 
 			// functions without parameter
 			iStat += ThrowTest(_T("3+ping(2)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("3+ping(a+2)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("3+ping(sin(a)+2)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("3+ping(1+sin(a))"), ecTOO_MANY_PARAMS);
 
 			// String function related
 			iStat += ThrowTest(_T("valueof(\"xxx\")"), 999, false);
 			iStat += ThrowTest(_T("valueof()"), ecUNEXPECTED_PARENS);
 			iStat += ThrowTest(_T("1+valueof(\"abc\""), ecMISSING_PARENS);
 			iStat += ThrowTest(_T("valueof(\"abc\""), ecMISSING_PARENS);
 			iStat += ThrowTest(_T("valueof(\"abc"), ecUNTERMINATED_STRING);
 			iStat += ThrowTest(_T("valueof(\"abc\",3)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("valueof(3)"), ecSTRING_EXPECTED);
 			iStat += ThrowTest(_T("sin(\"abc\")"), ecVAL_EXPECTED);
 			iStat += ThrowTest(_T("valueof(\"\\\"abc\\\"\")"), 999, false);
 			iStat += ThrowTest(_T("\"hello world\""), ecSTR_RESULT);
 			iStat += ThrowTest(_T("(\"hello world\")"), ecSTR_RESULT);
 			iStat += ThrowTest(_T("\"abcd\"+100"), ecSTR_RESULT);
 			iStat += ThrowTest(_T("\"a\"+\"b\""), ecSTR_RESULT);
 			iStat += ThrowTest(_T("strfun1(\"100\",3)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("strfun2(\"100\",3,5)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("strfun3(\"100\",3,5,6)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("strfun2(\"100\")"), ecTOO_FEW_PARAMS);
 			iStat += ThrowTest(_T("strfun3(\"100\",6)"), ecTOO_FEW_PARAMS);
 			iStat += ThrowTest(_T("strfun2(1,1)"), ecSTRING_EXPECTED);
 			iStat += ThrowTest(_T("strfun2(a,1)"), ecSTRING_EXPECTED);
 			iStat += ThrowTest(_T("strfun2(1,1,1)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("strfun2(a,1,1)"), ecTOO_MANY_PARAMS);
 			iStat += ThrowTest(_T("strfun3(1,2,3)"), ecSTRING_EXPECTED);
 			iStat += ThrowTest(_T("strfun3(1, \"100\",3)"), ecSTRING_EXPECTED);
 			iStat += ThrowTest(_T("strfun3(\"1\", \"100\",3)"), ecVAL_EXPECTED);
 			iStat += ThrowTest(_T("strfun3(\"1\", 3, \"100\")"), ecVAL_EXPECTED);
 			iStat += ThrowTest(_T("strfun3(\"1\", \"100\", \"100\", \"100\")"), ecTOO_MANY_PARAMS);
 
 			// assignment operator
 			iStat += ThrowTest(_T("3=4"), ecUNEXPECTED_OPERATOR);
 			iStat += ThrowTest(_T("sin(8)=4"), ecUNEXPECTED_OPERATOR);
 			iStat += ThrowTest(_T("\"test\"=a"), ecSTR_RESULT);
 
 			// <ibg 20090529>
 			// this is now legal, for reference see:
 			// https://sourceforge.net/forum/message.php?msg_id=7411373
 			//      iStat += ThrowTest( _T("sin=9"), ecUNEXPECTED_OPERATOR);    
 			// </ibg>
 
 			iStat += ThrowTest(_T("(8)=5"), ecUNEXPECTED_OPERATOR);
 			iStat += ThrowTest(_T("(a)=5"), ecUNEXPECTED_OPERATOR);
 			iStat += ThrowTest(_T("a=\"tttt\""), ecOPRT_TYPE_CONFLICT);
 
 			if (iStat == 0)
 				mu::console() << _T("passed") << endl;
 			else
 				mu::console() << _T("\n  failed with ") << iStat << _T(" errors") << endl;
 
 			return iStat;
 		}
 
 
 		//---------------------------------------------------------------------------
 		void ParserTester::AddTest(testfun_type a_pFun)
 		{
 			m_vTestFun.push_back(a_pFun);
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::Run()
 		{
 			int iStat = 0;
 			try
 			{
 				for (int i = 0; i < (int)m_vTestFun.size(); ++i)
 					iStat += (this->*m_vTestFun[i])();
 			}
 			catch (Parser::exception_type& e)
 			{
 				mu::console() << "\n" << e.GetMsg() << endl;
 				mu::console() << e.GetToken() << endl;
 				Abort();
 			}
 			catch (std::exception& e)
 			{
 				mu::console() << e.what() << endl;
 				Abort();
 			}
 			catch (...)
 			{
 				mu::console() << "Internal error";
 				Abort();
 			}
 
 			if (iStat == 0)
 			{
 				mu::console() << "Test passed (" << ParserTester::c_iCount << " expressions)" << endl;
 			}
 			else
 			{
 				mu::console() << "Test failed with " << iStat
 					<< " errors (" << ParserTester::c_iCount
 					<< " expressions)" << endl;
 			}
 			ParserTester::c_iCount = 0;
 			return iStat;
 		}
 
 
 		//---------------------------------------------------------------------------
 		int ParserTester::ThrowTest(const string_type& a_str, int a_iErrc, bool a_expectedToFail)
 		{
 			ParserTester::c_iCount++;
 
 			try
 			{
 				value_type fVal[] = { 1,1,1 };
 				Parser p;
 
 				p.DefineVar(_T("a"), &fVal[0]);
 				p.DefineVar(_T("b"), &fVal[1]);
 				p.DefineVar(_T("c"), &fVal[2]);
 				p.DefinePostfixOprt(_T("{m}"), Milli);
 				p.DefinePostfixOprt(_T("m"), Milli);
 				p.DefineFun(_T("ping"), Ping);
 				p.DefineFun(_T("valueof"), ValueOf);
 				p.DefineFun(_T("strfun1"), StrFun1);
 				p.DefineFun(_T("strfun2"), StrFun2);
 				p.DefineFun(_T("strfun3"), StrFun3);
 				p.DefineFun(_T("strfun4"), StrFun4);
 				p.DefineFun(_T("strfun5"), StrFun5);
 				p.SetExpr(a_str);
 //				p.EnableDebugDump(1, 0);
 				p.Eval();
 			}
 			catch (ParserError& e)
 			{
 				// output the formula in case of an failed test
 				if (a_expectedToFail == false || (a_expectedToFail == true && a_iErrc != e.GetCode()))
 				{
 					mu::console() << _T("\n  ")
 						<< _T("Expression: ") << a_str
 						<< _T("  Code:") << e.GetCode() << _T("(") << e.GetMsg() << _T(")")
 						<< _T("  Expected:") << a_iErrc;
 				}
 
 				return (a_iErrc == e.GetCode()) ? 0 : 1;
 			}
 
 			// if a_expectedToFail == false no exception is expected
 			bool bRet((a_expectedToFail == false) ? 0 : 1);
 			if (bRet == 1)
 			{
 				mu::console() << _T("\n  ")
 					<< _T("Expression: ") << a_str
 					<< _T("  did evaluate; Expected error:") << a_iErrc;
 			}
 
 			return bRet;
 		}
 
 		//---------------------------------------------------------------------------
 		/** \brief Evaluate a tet expression.
 
 			\return 1 in case of a failure, 0 otherwise.
 		*/
 		int ParserTester::EqnTestWithVarChange(const string_type& a_str,
 			double a_fVar1,
 			double a_fRes1,
 			double a_fVar2,
 			double a_fRes2)
 		{
 			ParserTester::c_iCount++;
 
 			try
 			{
 				value_type fVal[2] = { -999, -999 }; // should be equal
 
 				Parser  p;
 				value_type var = 0;
 
 				// variable
 				p.DefineVar(_T("a"), &var);
 				p.SetExpr(a_str);
 
 				var = a_fVar1;
 				fVal[0] = p.Eval();
 
 				var = a_fVar2;
 				fVal[1] = p.Eval();
 
 				if (fabs(a_fRes1 - fVal[0]) > 0.0000000001)
 					throw std::runtime_error("incorrect result (first pass)");
 
 				if (fabs(a_fRes2 - fVal[1]) > 0.0000000001)
 					throw std::runtime_error("incorrect result (second pass)");
 			}
 			catch (Parser::exception_type& e)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (") << e.GetMsg() << _T(")");
 				return 1;
 			}
 			catch (std::exception& e)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (") << e.what() << _T(")");
 				return 1;  // always return a failure since this exception is not expected
 			}
 			catch (...)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (unexpected exception)");
 				return 1;  // exceptions other than ParserException are not allowed
 			}
 
 			return 0;
 		}
 
 		//---------------------------------------------------------------------------
 		/** \brief Evaluate a tet expression.
 
 			\return 1 in case of a failure, 0 otherwise.
 		*/
 		int ParserTester::EqnTest(const string_type& a_str, double a_fRes, bool a_fPass)
 		{
 			ParserTester::c_iCount++;
 			int iRet(0);
 			value_type fVal[5] = { -999, -998, -997, -996, -995 }; // initially should be different
 
 			try
 			{
 				std::unique_ptr<Parser> p1;
 				Parser  p2, p3;   // three parser objects
 								  // they will be used for testing copy and assignment operators
 				// p1 is a pointer since i'm going to delete it in order to test if
 				// parsers after copy construction still refer to members of it.
 				// !! If this is the case this function will crash !!
 
 				p1.reset(new mu::Parser());
 				// Add constants
 				p1->DefineConst(_T("pi"), MathImpl<value_type>::CONST_PI);
 				p1->DefineConst(_T("e"), MathImpl<value_type>::CONST_E);
 				p1->DefineConst(_T("const"), 1);
 				p1->DefineConst(_T("const1"), 2);
 				p1->DefineConst(_T("const2"), 3);
 				// string constants
 				p1->DefineStrConst(_T("str1"), _T("1.11"));
 				p1->DefineStrConst(_T("str2"), _T("2.22"));
 				// variables
 				value_type vVarVal[] = { 1, 2, 3, -2 };
 				p1->DefineVar(_T("a"), &vVarVal[0]);
 				p1->DefineVar(_T("aa"), &vVarVal[1]);
 				p1->DefineVar(_T("b"), &vVarVal[1]);
 				p1->DefineVar(_T("c"), &vVarVal[2]);
 				p1->DefineVar(_T("d"), &vVarVal[3]);
 
 				// custom value ident functions
 				p1->AddValIdent(&ParserTester::IsHexVal);
 
 				// functions
 				p1->DefineFun(_T("ping"), Ping);
 				p1->DefineFun(_T("f0"), f0);        // no parameter
 				p1->DefineFun(_T("f1of1"), f1of1);  // one parameter
 				p1->DefineFun(_T("f1of2"), f1of2);  // two parameter
 				p1->DefineFun(_T("f2of2"), f2of2);
 				p1->DefineFun(_T("f1of3"), f1of3);  // three parameter
 				p1->DefineFun(_T("f2of3"), f2of3);
 				p1->DefineFun(_T("f3of3"), f3of3);
 				p1->DefineFun(_T("f1of4"), f1of4);  // four parameter
 				p1->DefineFun(_T("f2of4"), f2of4);
 				p1->DefineFun(_T("f3of4"), f3of4);
 				p1->DefineFun(_T("f4of4"), f4of4);
 				p1->DefineFun(_T("f1of5"), f1of5);  // five parameter
 				p1->DefineFun(_T("f2of5"), f2of5);
 				p1->DefineFun(_T("f3of5"), f3of5);
 				p1->DefineFun(_T("f4of5"), f4of5);
 				p1->DefineFun(_T("f5of5"), f5of5);
 
 				// binary operators
 				p1->DefineOprt(_T("add"), add, 0);
 				p1->DefineOprt(_T("++"), add, 0);
 				p1->DefineOprt(_T("&"), land, prLAND);
 
 				// sample functions
 				p1->DefineFun(_T("min"), Min);
 				p1->DefineFun(_T("max"), Max);
 				p1->DefineFun(_T("sum"), Sum);
 				p1->DefineFun(_T("valueof"), ValueOf);
 				p1->DefineFun(_T("atof"), StrToFloat);
 				p1->DefineFun(_T("strfun1"), StrFun1);
 				p1->DefineFun(_T("strfun2"), StrFun2);
 				p1->DefineFun(_T("strfun3"), StrFun3);
 				p1->DefineFun(_T("strfun4"), StrFun4);
 				p1->DefineFun(_T("strfun5"), StrFun5);
 				p1->DefineFun(_T("lastArg"), LastArg);
 				p1->DefineFun(_T("firstArg"), FirstArg);
 				p1->DefineFun(_T("order"), FirstArg);
 
 				// infix / postfix operator
 				// Note: Identifiers used here do not have any meaning 
 				//       they are mere placeholders to test certain features.
 				p1->DefineInfixOprt(_T("$"), sign, prPOW + 1);  // sign with high priority
 				p1->DefineInfixOprt(_T("~"), plus2);          // high priority
 				p1->DefineInfixOprt(_T("~~"), plus2);
 				p1->DefinePostfixOprt(_T("{m}"), Milli);
 				p1->DefinePostfixOprt(_T("{M}"), Mega);
 				p1->DefinePostfixOprt(_T("m"), Milli);
 				p1->DefinePostfixOprt(_T("meg"), Mega);
 				p1->DefinePostfixOprt(_T("#"), times3);
 				p1->DefinePostfixOprt(_T("'"), sqr);
 				p1->SetExpr(a_str);
 
 				// Test bytecode integrity
 				// String parsing and bytecode parsing must yield the same result
 				fVal[0] = p1->Eval(); // result from stringparsing
 				fVal[1] = p1->Eval(); // result from bytecode
 				if (fVal[0] != fVal[1])
 					throw Parser::exception_type(_T("Bytecode / string parsing mismatch."));
 
 				// Test copy and assignment operators
 				try
 				{
 					// Test copy constructor
 					std::vector<mu::Parser> vParser;
 					vParser.push_back(*(p1.get()));
 					mu::Parser p4 = vParser[0];   // take parser from vector
 
 					// destroy the originals from p2
 					vParser.clear();              // delete the vector
 					p1.reset(0);
 
 					fVal[2] = p4.Eval();
 
 					// Test assignment operator
 					// additionally  disable Optimizer this time
 					mu::Parser p5;
 					p5 = p4;
 					p5.EnableOptimizer(false);
 					fVal[3] = p5.Eval();
 
 					// Test Eval function for multiple return values
 					// use p2 since it has the optimizer enabled!
 					int nNum;
 					value_type* v = p4.Eval(nNum);
 					fVal[4] = v[nNum - 1];
 				}
 				catch (std::exception& e)
 				{
 					mu::console() << _T("\n  ") << e.what() << _T("\n");
 				}
 
 				// limited floating point accuracy requires the following test
 				bool bCloseEnough(true);
 				for (unsigned i = 0; i < sizeof(fVal) / sizeof(value_type); ++i)
 				{
 					bCloseEnough &= (fabs(a_fRes - fVal[i]) <= fabs(fVal[i] * 0.00001));
 
 					// The tests equations never result in infinity, if they do thats a bug.
 					// reference:
 					// http://sourceforge.net/projects/muparser/forums/forum/462843/topic/5037825
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable:4127)
 #endif
 					if (std::numeric_limits<value_type>::has_infinity)
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 					{
 						bCloseEnough &= (fabs(fVal[i]) != numeric_limits<value_type>::infinity());
 					}
 				}
 
 				iRet = ((bCloseEnough && a_fPass) || (!bCloseEnough && !a_fPass)) ? 0 : 1;
 
 
 				if (iRet == 1)
 				{
 					mu::console() << _T("\n  fail: ") << a_str.c_str()
 						<< _T(" (incorrect result; expected: ") << a_fRes
 						<< _T(" ;calculated: ") << fVal[0] << _T(",")
 						<< fVal[1] << _T(",")
 						<< fVal[2] << _T(",")
 						<< fVal[3] << _T(",")
 						<< fVal[4] << _T(").");
 				}
 			}
 			catch (Parser::exception_type& e)
 			{
 				if (a_fPass)
 				{
 					if (fVal[0] != fVal[2] && fVal[0] != -999 && fVal[1] != -998)
 						mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (copy construction)");
 					else
 						mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (") << e.GetMsg() << _T(")");
 					return 1;
 				}
 			}
 			catch (std::exception& e)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (") << e.what() << _T(")");
 				return 1;  // always return a failure since this exception is not expected
 			}
 			catch (...)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (unexpected exception)");
 				return 1;  // exceptions other than ParserException are not allowed
 			}
 
 			return iRet;
 		}
 
 		//---------------------------------------------------------------------------
 		int ParserTester::EqnTestInt(const string_type& a_str, double a_fRes, bool a_fPass)
 		{
 			ParserTester::c_iCount++;
 
 			value_type vVarVal[] = { 1, 2, 3 };   // variable values
 			int iRet(0);
 
 			try
 			{
 				value_type fVal[2] = { -99, -999 };   // results: initially should be different
 				ParserInt p;
 				p.DefineConst(_T("const1"), 1);
 				p.DefineConst(_T("const2"), 2);
 				p.DefineVar(_T("a"), &vVarVal[0]);
 				p.DefineVar(_T("b"), &vVarVal[1]);
 				p.DefineVar(_T("c"), &vVarVal[2]);
 
 				p.SetExpr(a_str);
 				fVal[0] = p.Eval(); // result from stringparsing
 				fVal[1] = p.Eval(); // result from bytecode
 
 				if (fVal[0] != fVal[1])
 					throw Parser::exception_type(_T("Bytecode corrupt."));
 
 				iRet = ((a_fRes == fVal[0] && a_fPass) ||
 					(a_fRes != fVal[0] && !a_fPass)) ? 0 : 1;
 				if (iRet == 1)
 				{
 					mu::console() << _T("\n  fail: ") << a_str.c_str()
 						<< _T(" (incorrect result; expected: ") << a_fRes
 						<< _T(" ;calculated: ") << fVal[0] << _T(").");
 				}
 			}
 			catch (Parser::exception_type& e)
 			{
 				if (a_fPass)
 				{
 					mu::console() << _T("\n  fail: ") << e.GetExpr() << _T(" : ") << e.GetMsg();
 					iRet = 1;
 				}
 			}
 			catch (...)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (unexpected exception)");
 				iRet = 1;  // exceptions other than ParserException are not allowed
 			}
 
 			return iRet;
 		}
 
 		//---------------------------------------------------------------------------
 		/** \brief Test an expression in Bulk Mode. */
 		int ParserTester::EqnTestBulk(const string_type& a_str, double a_fRes[4], bool a_fPass)
 		{
 			ParserTester::c_iCount++;
 
 			// Define Bulk Variables
 			int nBulkSize = 4;
 			value_type vVariableA[] = { 1, 2, 3, 4 };   // variable values
 			value_type vVariableB[] = { 2, 2, 2, 2 };   // variable values
 			value_type vVariableC[] = { 3, 3, 3, 3 };   // variable values
 			value_type vResults[] = { 0, 0, 0, 0 };   // variable values
 			int iRet(0);
 
 			try
 			{
 				Parser p;
 				p.DefineConst(_T("const1"), 1);
 				p.DefineConst(_T("const2"), 2);
 				p.DefineVar(_T("a"), vVariableA);
 				p.DefineVar(_T("b"), vVariableB);
 				p.DefineVar(_T("c"), vVariableC);
 
 				p.SetExpr(a_str);
 				p.Eval(vResults, nBulkSize);
 
 				bool bCloseEnough(true);
 				for (int i = 0; i < nBulkSize; ++i)
 				{
 					bCloseEnough &= (fabs(a_fRes[i] - vResults[i]) <= fabs(a_fRes[i] * 0.00001));
 				}
 
 				iRet = ((bCloseEnough && a_fPass) || (!bCloseEnough && !a_fPass)) ? 0 : 1;
 				if (iRet == 1)
 				{
 					mu::console() << _T("\n  fail: ") << a_str.c_str()
 						<< _T(" (incorrect result; expected: {") << a_fRes[0] << _T(",") << a_fRes[1] << _T(",") << a_fRes[2] << _T(",") << a_fRes[3] << _T("}")
 						<< _T(" ;calculated: ") << vResults[0] << _T(",") << vResults[1] << _T(",") << vResults[2] << _T(",") << vResults[3] << _T("}");
 				}
 			}
 			catch (Parser::exception_type& e)
 			{
 				if (a_fPass)
 				{
 					mu::console() << _T("\n  fail: ") << e.GetExpr() << _T(" : ") << e.GetMsg();
 					iRet = 1;
 				}
 			}
 			catch (...)
 			{
 				mu::console() << _T("\n  fail: ") << a_str.c_str() << _T(" (unexpected exception)");
 				iRet = 1;  // exceptions other than ParserException are not allowed
 			}
 
 			return iRet;
 		}
 
 		//---------------------------------------------------------------------------
 		/** \brief Internal error in test class Test is going to be aborted. */
 		void ParserTester::Abort() const
 		{
 			mu::console() << _T("Test failed (internal error in test class)") << endl;
 			while (!getchar());
 			exit(-1);
 		}
 	} // namespace test
 } // namespace mu
diff --git a/src/muParserTokenReader.cpp b/src/muParserTokenReader.cpp
index 9bb4295..f67d852 100644
--- a/src/muParserTokenReader.cpp
+++ b/src/muParserTokenReader.cpp
@@ -48,953 +48,950 @@
 namespace mu
 {
 
 	// Forward declaration
 	class ParserBase;
 
 	/** \brief Copy constructor.
 
 		\sa Assign
 		\throw nothrow
 	*/
 	ParserTokenReader::ParserTokenReader(const ParserTokenReader& a_Reader)
 	{
 		Assign(a_Reader);
 	}
 
 
 	/** \brief Assignment operator.
 
 		Self assignment will be suppressed otherwise #Assign is called.
 
 		\param a_Reader Object to copy to this token reader.
 		\throw nothrow
 	*/
 	ParserTokenReader& ParserTokenReader::operator=(const ParserTokenReader& a_Reader)
 	{
 		if (&a_Reader != this)
 			Assign(a_Reader);
 
 		return *this;
 	}
 
 
 	/** \brief Assign state of a token reader to this token reader.
 
 		\param a_Reader Object from which the state should be copied.
 		\throw nothrow
 	*/
 	void ParserTokenReader::Assign(const ParserTokenReader& a_Reader)
 	{
 		m_pParser = a_Reader.m_pParser;
 		m_strFormula = a_Reader.m_strFormula;
 		m_iPos = a_Reader.m_iPos;
 		m_iSynFlags = a_Reader.m_iSynFlags;
 
 		m_UsedVar = a_Reader.m_UsedVar;
 		m_pFunDef = a_Reader.m_pFunDef;
 		m_pConstDef = a_Reader.m_pConstDef;
 		m_pVarDef = a_Reader.m_pVarDef;
 		m_pStrVarDef = a_Reader.m_pStrVarDef;
 		m_pPostOprtDef = a_Reader.m_pPostOprtDef;
 		m_pInfixOprtDef = a_Reader.m_pInfixOprtDef;
 		m_pOprtDef = a_Reader.m_pOprtDef;
 		m_bIgnoreUndefVar = a_Reader.m_bIgnoreUndefVar;
 		m_vIdentFun = a_Reader.m_vIdentFun;
 		m_pFactory = a_Reader.m_pFactory;
 		m_pFactoryData = a_Reader.m_pFactoryData;
 		m_bracketStack = a_Reader.m_bracketStack;
 		m_cArgSep = a_Reader.m_cArgSep;
 		m_fZero = a_Reader.m_fZero;
 		m_lastTok = a_Reader.m_lastTok;
 	}
 
 
 	/** \brief Constructor.
 
 		Create a Token reader and bind it to a parser object.
 
 		\pre [assert] a_pParser may not be NULL
 		\post #m_pParser==a_pParser
 		\param a_pParent Parent parser object of the token reader.
 	*/
 	ParserTokenReader::ParserTokenReader(ParserBase* a_pParent)
 		:m_pParser(a_pParent)
 		, m_strFormula()
 		, m_iPos(0)
 		, m_iSynFlags(0)
 		, m_bIgnoreUndefVar(false)
 		, m_pFunDef(nullptr)
 		, m_pPostOprtDef(nullptr)
 		, m_pInfixOprtDef(nullptr)
 		, m_pOprtDef(nullptr)
 		, m_pConstDef(nullptr)
 		, m_pStrVarDef(nullptr)
 		, m_pVarDef(nullptr)
 		, m_pFactory(nullptr)
 		, m_pFactoryData(nullptr)
 		, m_vIdentFun()
 		, m_UsedVar()
 		, m_fZero(0)
 		, m_bracketStack()
 		, m_lastTok()
 		, m_cArgSep(',')
 	{
 		MUP_ASSERT(m_pParser != nullptr);
 		SetParent(m_pParser);
 	}
 
 
 	/** \brief Create instance of a ParserTokenReader identical with this
 				and return its pointer.
 
 		This is a factory method the calling function must take care of the object destruction.
 
 		\return A new ParserTokenReader object.
 		\throw nothrow
 	*/
 	ParserTokenReader* ParserTokenReader::Clone(ParserBase* a_pParent) const
 	{
 		std::unique_ptr<ParserTokenReader> ptr(new ParserTokenReader(*this));
 		ptr->SetParent(a_pParent);
 		return ptr.release();
 	}
 
 
 	ParserTokenReader::token_type& ParserTokenReader::SaveBeforeReturn(const token_type& tok)
 	{
 		m_lastTok = tok;
 		return m_lastTok;
 	}
 
 
 	void ParserTokenReader::AddValIdent(identfun_type a_pCallback)
 	{
 		// Use push_front is used to give user defined callbacks a higher priority than
 		// the built in ones. Otherwise reading hex numbers would not work
 		// since the "0" in "0xff" would always be read first making parsing of 
 		// the rest impossible.
 		// reference:
 		// http://sourceforge.net/projects/muparser/forums/forum/462843/topic/4824956
 		m_vIdentFun.push_front(a_pCallback);
 	}
 
 
 	void ParserTokenReader::SetVarCreator(facfun_type a_pFactory, void* pUserData)
 	{
 		m_pFactory = a_pFactory;
 		m_pFactoryData = pUserData;
 	}
 
 
 	/** \brief Return the current position of the token reader in the formula string.
 
 		\return #m_iPos
 		\throw nothrow
 	*/
 	int ParserTokenReader::GetPos() const
 	{
 		return m_iPos;
 	}
 
 
 	/** \brief Return a reference to the formula.
 
 		\return #m_strFormula
 		\throw nothrow
 	*/
 	const string_type& ParserTokenReader::GetExpr() const
 	{
 		return m_strFormula;
 	}
 
 
 	/** \brief Return a map containing the used variables only. */
 	varmap_type& ParserTokenReader::GetUsedVar()
 	{
 		return m_UsedVar;
 	}
 
 
 	/** \brief Initialize the token Reader.
 
 		Sets the formula position index to zero and set Syntax flags to default for initial formula parsing.
 		\pre [assert] triggered if a_szFormula==0
 	*/
 	void ParserTokenReader::SetFormula(const string_type& a_strFormula)
 	{
 		m_strFormula = a_strFormula;
 		ReInit();
 	}
 
 
 	/** \brief Set Flag that controls behaviour in case of undefined variables being found.
 
 	  If true, the parser does not throw an exception if an undefined variable is found.
 	  otherwise it does. This variable is used internally only!
 	  It suppresses a "undefined variable" exception in GetUsedVar().
 	  Those function should return a complete list of variables including
 	  those the are not defined by the time of it's call.
 	*/
 	void ParserTokenReader::IgnoreUndefVar(bool bIgnore)
 	{
 		m_bIgnoreUndefVar = bIgnore;
 	}
 
 
 	/** \brief Reset the token reader to the start of the formula.
 
 		The syntax flags will be reset to a value appropriate for the
 		start of a formula.
 		\post #m_iPos==0, #m_iSynFlags = noOPT | noBC | noPOSTOP | noSTR
 		\throw nothrow
 		\sa ESynCodes
 	*/
 	void ParserTokenReader::ReInit()
 	{
 		m_iPos = 0;
 		m_iSynFlags = sfSTART_OF_LINE;
 		m_bracketStack = std::stack<int>();
 		m_UsedVar.clear();
 		m_lastTok = token_type();
 	}
 
 
 	/** \brief Read the next token from the string. */
 	ParserTokenReader::token_type ParserTokenReader::ReadNextToken()
 	{
 		MUP_ASSERT(m_pParser != nullptr);
 
 		const char_type* szExpr = m_strFormula.c_str();
 		token_type tok;
 
 		// Ignore all non printable characters when reading the expression
 		while (szExpr[m_iPos] > 0 && szExpr[m_iPos] <= 0x20)
 		{
 			// 14-31 are control characters. I dont want to have to deal with such strings at all!
 			// (see https://en.cppreference.com/w/cpp/string/byte/isprint)
 			if (szExpr[m_iPos] >= 14 && szExpr[m_iPos] <= 31)
 				Error(ecINVALID_CHARACTERS_FOUND, m_iPos);
 
 			++m_iPos;
 		}
 
 		// Check for end of formula
 		if (IsEOF(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for user defined binary operator
 		if (IsOprt(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for function token
 		if (IsFunTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check built in operators / tokens
 		if (IsBuiltIn(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for function argument separators
 		if (IsArgSep(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for values / constant tokens
 		if (IsValTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for variable tokens
 		if (IsVarTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for string variables
 		if (IsStrVarTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for String tokens
 		if (IsString(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for unary operators
 		if (IsInfixOpTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for unary operators
 		if (IsPostOpTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check String for undefined variable token. Done only if a 
 		// flag is set indicating to ignore undefined variables.
 		// This is a way to conditionally avoid an error if 
 		// undefined variables occur. 
 		// (The GetUsedVar function must suppress the error for
 		// undefined variables in order to collect all variable 
 		// names including the undefined ones.)
 		if ((m_bIgnoreUndefVar || m_pFactory) && IsUndefVarTok(tok))
 			return SaveBeforeReturn(tok);
 
 		// Check for unknown token
 		// 
 		// !!! From this point on there is no exit without an exception possible...
 		// 
 		string_type strTok;
 		auto iEnd = ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos);
 		if (iEnd != m_iPos)
 			Error(ecUNASSIGNABLE_TOKEN, m_iPos, strTok);
 
 		Error(ecUNASSIGNABLE_TOKEN, m_iPos, m_strFormula.substr(m_iPos));
 		return token_type(); // never reached
 	}
 
 
 	void ParserTokenReader::SetParent(ParserBase* a_pParent)
 	{
 		m_pParser = a_pParent;
 		m_pFunDef = &a_pParent->m_FunDef;
 		m_pOprtDef = &a_pParent->m_OprtDef;
 		m_pInfixOprtDef = &a_pParent->m_InfixOprtDef;
 		m_pPostOprtDef = &a_pParent->m_PostOprtDef;
 		m_pVarDef = &a_pParent->m_VarDef;
 		m_pStrVarDef = &a_pParent->m_StrVarDef;
 		m_pConstDef = &a_pParent->m_ConstDef;
 	}
 
 
 	/** \brief Extract all characters that belong to a certain charset.
 
 		\param a_szCharSet [in] Const char array of the characters allowed in the token.
 		\param a_strTok [out]  The string that consists entirely of characters listed in a_szCharSet.
 		\param a_iPos [in] Position in the string from where to start reading.
 		\return The Position of the first character not listed in a_szCharSet.
 		\throw nothrow
 	*/
 	int ParserTokenReader::ExtractToken(const char_type* a_szCharSet, string_type& a_sTok, std::size_t a_iPos) const
 	{
 		auto iEnd = m_strFormula.find_first_not_of(a_szCharSet, a_iPos);
 
 		if (iEnd == string_type::npos)
 			iEnd = m_strFormula.length();
 
 		// Assign token string if there was something found
 		if (a_iPos != iEnd)
 			a_sTok = string_type(m_strFormula.begin() + a_iPos, m_strFormula.begin() + iEnd);
 
 		return iEnd;
 	}
 
 
 	/** \brief Check Expression for the presence of a binary operator token.
 
 	  Userdefined binary operator "++" gives inconsistent parsing result for
 	  the equations "a++b" and "a ++ b" if alphabetic characters are allowed
 	  in operator tokens. To avoid this this function checks specifically
 	  for operator tokens.
 	*/
 	int ParserTokenReader::ExtractOperatorToken(string_type& a_sTok, std::size_t a_iPos) const
 	{
 		// Changed as per Issue 6: https://code.google.com/p/muparser/issues/detail?id=6
 		auto iEnd = m_strFormula.find_first_not_of(m_pParser->ValidOprtChars(), a_iPos);
 		if (iEnd == string_type::npos)
 			iEnd = m_strFormula.length();
 
 		// Assign token string if there was something found
 		if (a_iPos != iEnd)
 		{
 			a_sTok = string_type(m_strFormula.begin() + a_iPos, m_strFormula.begin() + iEnd);
 			return iEnd;
 		}
 		else
 		{
 			// There is still the chance of having to deal with an operator consisting exclusively
 			// of alphabetic characters.
 			return ExtractToken(_T("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"), a_sTok, (std::size_t)a_iPos);
 		}
 	}
 
 
 	/** \brief Check if a built in operator or other token can be found
 		\param a_Tok  [out] Operator token if one is found. This can either be a binary operator or an infix operator token.
 		\return true if an operator token has been found.
 	*/
 	bool ParserTokenReader::IsBuiltIn(token_type& a_Tok)
 	{
 		const char_type** const pOprtDef = m_pParser->GetOprtDef(),
 			* const szFormula = m_strFormula.c_str();
 
 		// Compare token with function and operator strings
 		// check string for operator/function
 		for (int i = 0; pOprtDef[i]; i++)
 		{
 			std::size_t len(std::char_traits<char_type>::length(pOprtDef[i]));
 			if (string_type(pOprtDef[i]) == string_type(szFormula + m_iPos, szFormula + m_iPos + len))
 			{
 				switch (i)
 				{
 				case cmLAND:
 				case cmLOR:
 				case cmLT:
 				case cmGT:
 				case cmLE:
 				case cmGE:
 				case cmNEQ:
 				case cmEQ:
 				case cmADD:
 				case cmSUB:
 				case cmMUL:
 				case cmDIV:
 				case cmPOW:
 				case cmASSIGN:
-					//if (len!=sTok.length())
-					//  continue;
-
 					// The assignment operator need special treatment
 					if (i == cmASSIGN && m_iSynFlags & noASSIGN)
 						Error(ecUNEXPECTED_OPERATOR, m_iPos, pOprtDef[i]);
 
 					if (!m_pParser->HasBuiltInOprt()) continue;
 					if (m_iSynFlags & noOPT)
 					{
 						// Maybe its an infix operator not an operator
 						// Both operator types can share characters in 
 						// their identifiers
 						if (IsInfixOpTok(a_Tok))
 							return true;
 
 						Error(ecUNEXPECTED_OPERATOR, m_iPos, pOprtDef[i]);
 					}
 
 					m_iSynFlags = noBC | noOPT | noARG_SEP | noPOSTOP | noASSIGN | noIF | noELSE | noEND;
 					break;
 
 				case cmBO:
 					if (m_iSynFlags & noBO)
 						Error(ecUNEXPECTED_PARENS, m_iPos, pOprtDef[i]);
 
 					if (m_lastTok.GetCode() == cmFUNC)
 						m_iSynFlags = noOPT | noEND | noARG_SEP | noPOSTOP | noASSIGN | noIF | noELSE;
 					else
 						m_iSynFlags = noBC | noOPT | noEND | noARG_SEP | noPOSTOP | noASSIGN | noIF | noELSE;
 
 					m_bracketStack.push(cmBO);
 					break;
 
 				case cmBC:
 					if (m_iSynFlags & noBC)
 						Error(ecUNEXPECTED_PARENS, m_iPos, pOprtDef[i]);
 
 					m_iSynFlags = noBO | noVAR | noVAL | noFUN | noINFIXOP | noSTR | noASSIGN;
 
 					if (!m_bracketStack.empty())
 						m_bracketStack.pop();
 					else
 						Error(ecUNEXPECTED_PARENS, m_iPos, pOprtDef[i]);
 					break;
 
 				case cmELSE:
 					if (m_iSynFlags & noELSE)
 						Error(ecUNEXPECTED_CONDITIONAL, m_iPos, pOprtDef[i]);
 
 					m_iSynFlags = noBC | noPOSTOP | noEND | noOPT | noIF | noELSE | noSTR;
 					break;
 
 				case cmIF:
 					if (m_iSynFlags & noIF)
 						Error(ecUNEXPECTED_CONDITIONAL, m_iPos, pOprtDef[i]);
 
 					m_iSynFlags = noBC | noPOSTOP | noEND | noOPT | noIF | noELSE | noSTR;
 					break;
 
 				default:      // The operator is listed in c_DefaultOprt, but not here. This is a bad thing...
 					Error(ecINTERNAL_ERROR);
 				} // switch operator id
 
 				m_iPos += (int)len;
 				a_Tok.Set((ECmdCode)i, pOprtDef[i]);
 				return true;
 			} // if operator string found
 		} // end of for all operator strings
 
 		return false;
 	}
 
 
 	bool ParserTokenReader::IsArgSep(token_type& a_Tok)
 	{
 		const char_type* szFormula = m_strFormula.c_str();
 
 		if (szFormula[m_iPos] == m_cArgSep)
 		{
 			// copy the separator into null terminated string
 			char_type szSep[2];
 			szSep[0] = m_cArgSep;
 			szSep[1] = 0;
 
 			if (m_iSynFlags & noARG_SEP)
 				Error(ecUNEXPECTED_ARG_SEP, m_iPos, szSep);
 
 			m_iSynFlags = noBC | noOPT | noEND | noARG_SEP | noPOSTOP | noASSIGN;
 			m_iPos++;
 			a_Tok.Set(cmARG_SEP, szSep);
 			return true;
 		}
 
 		return false;
 	}
 
 
 	/** \brief Check for End of Formula.
 
 		\return true if an end of formula is found false otherwise.
 		\param a_Tok [out] If an eof is found the corresponding token will be stored there.
 		\throw nothrow
 		\sa IsOprt, IsFunTok, IsStrFunTok, IsValTok, IsVarTok, IsString, IsInfixOpTok, IsPostOpTok
 	*/
 	bool ParserTokenReader::IsEOF(token_type& a_Tok)
 	{
 		const char_type* szFormula = m_strFormula.c_str();
 
 		// check for EOF
 		if (!szFormula[m_iPos] /*|| szFormula[m_iPos] == '\n'*/)
 		{
 			if (m_iSynFlags & noEND)
 				Error(ecUNEXPECTED_EOF, m_iPos);
 
 			if (!m_bracketStack.empty())
 				Error(ecMISSING_PARENS, m_iPos, _T(")"));
 
 			m_iSynFlags = 0;
 			a_Tok.Set(cmEND);
 			return true;
 		}
 
 		return false;
 	}
 
 
 	/** \brief Check if a string position contains a unary infix operator.
 		\return true if a function token has been found false otherwise.
 	*/
 	bool ParserTokenReader::IsInfixOpTok(token_type& a_Tok)
 	{
 		string_type sTok;
 		auto iEnd = ExtractToken(m_pParser->ValidInfixOprtChars(), sTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		// iterate over all postfix operator strings
 		funmap_type::const_reverse_iterator it = m_pInfixOprtDef->rbegin();
 		for (; it != m_pInfixOprtDef->rend(); ++it)
 		{
 			if (sTok.find(it->first) != 0)
 				continue;
 
 			a_Tok.Set(it->second, it->first);
 			m_iPos += (int)it->first.length();
 
 			if (m_iSynFlags & noINFIXOP)
 				Error(ecUNEXPECTED_OPERATOR, m_iPos, a_Tok.GetAsString());
 
 			m_iSynFlags = noPOSTOP | noINFIXOP | noOPT | noBC | noSTR | noASSIGN | noARG_SEP;
 			return true;
 		}
 
 		return false;
 
 		/*
 			a_Tok.Set(item->second, sTok);
 			m_iPos = (int)iEnd;
 
 			if (m_iSynFlags & noINFIXOP)
 			  Error(ecUNEXPECTED_OPERATOR, m_iPos, a_Tok.GetAsString());
 
 			m_iSynFlags = noPOSTOP | noINFIXOP | noOPT | noBC | noSTR | noASSIGN;
 			return true;
 		*/
 	}
 
 
 	/** \brief Check whether the token at a given position is a function token.
 		\param a_Tok [out] If a value token is found it will be placed here.
 		\throw ParserException if Syntaxflags do not allow a function at a_iPos
 		\return true if a function token has been found false otherwise.
 		\pre [assert] m_pParser!=0
 	*/
 	bool ParserTokenReader::IsFunTok(token_type& a_Tok)
 	{
 		string_type strTok;
 		auto iEnd = ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		funmap_type::const_iterator item = m_pFunDef->find(strTok);
 		if (item == m_pFunDef->end())
 			return false;
 
 		// Check if the next sign is an opening bracket
 		const char_type* szFormula = m_strFormula.c_str();
 		if (szFormula[iEnd] != '(')
 			return false;
 
 		a_Tok.Set(item->second, strTok);
 
 		m_iPos = (int)iEnd;
 		if (m_iSynFlags & noFUN)
 			Error(ecUNEXPECTED_FUN, m_iPos - (int)a_Tok.GetAsString().length(), a_Tok.GetAsString());
 
 		m_iSynFlags = noANY ^ noBO;
 		return true;
 	}
 
 
 	/** \brief Check if a string position contains a binary operator.
 		\param a_Tok  [out] Operator token if one is found. This can either be a binary operator or an infix operator token.
 		\return true if an operator token has been found.
 	*/
 	bool ParserTokenReader::IsOprt(token_type& a_Tok)
 	{
 		const char_type* const szExpr = m_strFormula.c_str();
 		string_type strTok;
 
 		auto iEnd = ExtractOperatorToken(strTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		// Check if the operator is a built in operator, if so ignore it here
 		const char_type** const pOprtDef = m_pParser->GetOprtDef();
 		for (int i = 0; m_pParser->HasBuiltInOprt() && pOprtDef[i]; ++i)
 		{
 			if (string_type(pOprtDef[i]) == strTok)
 				return false;
 		}
 
 		// Note:
 		// All tokens in oprt_bin_maptype are have been sorted by their length
 		// Long operators must come first! Otherwise short names (like: "add") that
 		// are part of long token names (like: "add123") will be found instead 
 		// of the long ones.
 		// Length sorting is done with ascending length so we use a reverse iterator here.
 		funmap_type::const_reverse_iterator it = m_pOprtDef->rbegin();
 		for (; it != m_pOprtDef->rend(); ++it)
 		{
 			const string_type& sID = it->first;
 			if (sID == string_type(szExpr + m_iPos, szExpr + m_iPos + sID.length()))
 			{
 				a_Tok.Set(it->second, strTok);
 
 				// operator was found
 				if (m_iSynFlags & noOPT)
 				{
 					// An operator was found but is not expected to occur at
 					// this position of the formula, maybe it is an infix 
 					// operator, not a binary operator. Both operator types
 					// can share characters in their identifiers.
 					if (IsInfixOpTok(a_Tok))
 						return true;
 					else
 					{
 						// nope, no infix operator
 						return false;
 						//Error(ecUNEXPECTED_OPERATOR, m_iPos, a_Tok.GetAsString()); 
 					}
 
 				}
 
 				m_iPos += (int)sID.length();
 				m_iSynFlags = noBC | noOPT | noARG_SEP | noPOSTOP | noEND | noASSIGN;
 				return true;
 			}
 		}
 
 		return false;
 	}
 
 
 	/** \brief Check if a string position contains a unary post value operator. */
 	bool ParserTokenReader::IsPostOpTok(token_type& a_Tok)
 	{
 		// <ibg 20110629> Do not check for postfix operators if they are not allowed at
 		//                the current expression index.
 		//
 		//  This will fix the bug reported here:  
 		//
 		//  http://sourceforge.net/tracker/index.php?func=detail&aid=3343891&group_id=137191&atid=737979
 		//
 		if (m_iSynFlags & noPOSTOP)
 			return false;
 		// </ibg>
 
 		// Tricky problem with equations like "3m+5":
 		//     m is a postfix operator, + is a valid sign for postfix operators and 
 		//     for binary operators parser detects "m+" as operator string and 
 		//     finds no matching postfix operator.
 		// 
 		// This is a special case so this routine slightly differs from the other
 		// token readers.
 
 		// Test if there could be a postfix operator
 		string_type sTok;
 		auto iEnd = ExtractToken(m_pParser->ValidOprtChars(), sTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		// iterate over all postfix operator strings
 		funmap_type::const_reverse_iterator it = m_pPostOprtDef->rbegin();
 		for (; it != m_pPostOprtDef->rend(); ++it)
 		{
 			if (sTok.find(it->first) != 0)
 				continue;
 
 			a_Tok.Set(it->second, sTok);
 			m_iPos += (int)it->first.length();
 
 			m_iSynFlags = noVAL | noVAR | noFUN | noBO | noPOSTOP | noSTR | noASSIGN;
 			return true;
 		}
 
 		return false;
 	}
 
 
 	/** \brief Check whether the token at a given position is a value token.
 
 		Value tokens are either values or constants.
 
 		\param a_Tok [out] If a value token is found it will be placed here.
 		\return true if a value token has been found.
 	*/
 	bool ParserTokenReader::IsValTok(token_type& a_Tok)
 	{
 		MUP_ASSERT(m_pConstDef != nullptr);
 		MUP_ASSERT(m_pParser != nullptr);
 
 		string_type strTok;
 		value_type fVal(0);
 
 		// 2.) Check for user defined constant
 		// Read everything that could be a constant name
 		auto iEnd = ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos);
 		if (iEnd != m_iPos)
 		{
 			valmap_type::const_iterator item = m_pConstDef->find(strTok);
 			if (item != m_pConstDef->end())
 			{
 				m_iPos = iEnd;
 				a_Tok.SetVal(item->second, strTok);
 
 				if (m_iSynFlags & noVAL)
 					Error(ecUNEXPECTED_VAL, m_iPos - (int)strTok.length(), strTok);
 
 				m_iSynFlags = noVAL | noVAR | noFUN | noBO | noINFIXOP | noSTR | noASSIGN;
 				return true;
 			}
 		}
 
 		// 3.call the value recognition functions provided by the user
 		// Call user defined value recognition functions
 		std::list<identfun_type>::const_iterator item = m_vIdentFun.begin();
 		for (item = m_vIdentFun.begin(); item != m_vIdentFun.end(); ++item)
 		{
 			int iStart = m_iPos;
 			if ((*item)(m_strFormula.c_str() + m_iPos, &m_iPos, &fVal) == 1)
 			{
 				// 2013-11-27 Issue 2:  https://code.google.com/p/muparser/issues/detail?id=2
 				strTok.assign(m_strFormula.c_str(), iStart, (std::size_t)m_iPos - iStart);
 
 				if (m_iSynFlags & noVAL)
 					Error(ecUNEXPECTED_VAL, m_iPos - (int)strTok.length(), strTok);
 
 				a_Tok.SetVal(fVal, strTok);
 				m_iSynFlags = noVAL | noVAR | noFUN | noBO | noINFIXOP | noSTR | noASSIGN;
 				return true;
 			}
 		}
 
 		return false;
 	}
 
 
 	/** \brief Check wheter a token at a given position is a variable token.
 		\param a_Tok [out] If a variable token has been found it will be placed here.
 		  \return true if a variable token has been found.
 	*/
 	bool ParserTokenReader::IsVarTok(token_type& a_Tok)
 	{
 		if (m_pVarDef->empty())
 			return false;
 
 		string_type strTok;
 		auto iEnd = ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		varmap_type::const_iterator item = m_pVarDef->find(strTok);
 		if (item == m_pVarDef->end())
 			return false;
 
 		if (m_iSynFlags & noVAR)
 			Error(ecUNEXPECTED_VAR, m_iPos, strTok);
 
 		m_pParser->OnDetectVar(&m_strFormula, m_iPos, iEnd);
 
 		m_iPos = iEnd;
 		a_Tok.SetVar(item->second, strTok);
 		m_UsedVar[item->first] = item->second;  // Add variable to used-var-list
 
 		m_iSynFlags = noVAL | noVAR | noFUN | noBO | noINFIXOP | noSTR;
 
 		//  Zur Info hier die SynFlags von IsVal():
 		//    m_iSynFlags = noVAL | noVAR | noFUN | noBO | noINFIXOP | noSTR | noASSIGN; 
 		return true;
 	}
 
 
 	bool ParserTokenReader::IsStrVarTok(token_type& a_Tok)
 	{
 		if (!m_pStrVarDef || m_pStrVarDef->empty())
 			return false;
 
 		string_type strTok;
 		auto iEnd = ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos);
 		if (iEnd == m_iPos)
 			return false;
 
 		strmap_type::const_iterator item = m_pStrVarDef->find(strTok);
 		if (item == m_pStrVarDef->end())
 			return false;
 
 		if (m_iSynFlags & noSTR)
 			Error(ecUNEXPECTED_VAR, m_iPos, strTok);
 
 		m_iPos = iEnd;
 		if (!m_pParser->m_vStringVarBuf.size())
 			Error(ecINTERNAL_ERROR);
 
 		a_Tok.SetString(m_pParser->m_vStringVarBuf[item->second], m_pParser->m_vStringVarBuf.size());
 
 		m_iSynFlags = noANY ^ (noBC | noOPT | noEND | noARG_SEP);
 		return true;
 	}
 
 
 
 	/** \brief Check wheter a token at a given position is an undefined variable.
 
 		\param a_Tok [out] If a variable tom_pParser->m_vStringBufken has been found it will be placed here.
 		  \return true if a variable token has been found.
 		\throw nothrow
 	*/
 	bool ParserTokenReader::IsUndefVarTok(token_type& a_Tok)
 	{
 		string_type strTok;
 		auto iEnd(ExtractToken(m_pParser->ValidNameChars(), strTok, (std::size_t)m_iPos));
 		if (iEnd == m_iPos)
 			return false;
 
 		if (m_iSynFlags & noVAR)
 		{
 			// <ibg/> 20061021 added token string strTok instead of a_Tok.GetAsString() as the 
 			//                 token identifier. 
 			// related bug report:
 			// http://sourceforge.net/tracker/index.php?func=detail&aid=1578779&group_id=137191&atid=737979
 			Error(ecUNEXPECTED_VAR, m_iPos - (int)a_Tok.GetAsString().length(), strTok);
 		}
 
 		// If a factory is available implicitely create new variables
 		if (m_pFactory)
 		{
 			value_type* fVar = m_pFactory(strTok.c_str(), m_pFactoryData);
 			a_Tok.SetVar(fVar, strTok);
 
 			// Do not use m_pParser->DefineVar( strTok, fVar );
 			// in order to define the new variable, it will clear the
 			// m_UsedVar array which will kill previously defined variables
 			// from the list
 			// This is safe because the new variable can never override an existing one
 			// because they are checked first!
 			(*m_pVarDef)[strTok] = fVar;
 			m_UsedVar[strTok] = fVar;  // Add variable to used-var-list
 		}
 		else
 		{
 			a_Tok.SetVar((value_type*)&m_fZero, strTok);
 			m_UsedVar[strTok] = 0;  // Add variable to used-var-list
 		}
 
 		m_iPos = iEnd;
 
 		// Call the variable factory in order to let it define a new parser variable
 		m_iSynFlags = noVAL | noVAR | noFUN | noBO | noPOSTOP | noINFIXOP | noSTR;
 		return true;
 	}
 
 
 
 	/** \brief Check wheter a token at a given position is a string.
 		\param a_Tok [out] If a variable token has been found it will be placed here.
 		\return true if a string token has been found.
 		\sa IsOprt, IsFunTok, IsStrFunTok, IsValTok, IsVarTok, IsEOF, IsInfixOpTok, IsPostOpTok
 		\throw nothrow
 	*/
 	bool ParserTokenReader::IsString(token_type& a_Tok)
 	{
 		if (m_strFormula[m_iPos] != '"')
 			return false;
 
 		string_type strBuf(&m_strFormula[(std::size_t)m_iPos + 1]);
 		std::size_t iEnd(0), iSkip(0);
 
 		// parser over escaped '\"' end replace them with '"'
 		for (iEnd = (int)strBuf.find(_T('\"')); iEnd != 0 && iEnd != string_type::npos; iEnd = (int)strBuf.find(_T('\"'), iEnd))
 		{
 			if (strBuf[iEnd - 1] != '\\') break;
 			strBuf.replace(iEnd - 1, 2, _T("\""));
 			iSkip++;
 		}
 
 		if (iEnd == string_type::npos)
 			Error(ecUNTERMINATED_STRING, m_iPos, _T("\""));
 
 		string_type strTok(strBuf.begin(), strBuf.begin() + iEnd);
 
 		if (m_iSynFlags & noSTR)
 			Error(ecUNEXPECTED_STR, m_iPos, strTok);
 
 		m_pParser->m_vStringBuf.push_back(strTok); // Store string in internal buffer
 		a_Tok.SetString(strTok, m_pParser->m_vStringBuf.size());
 
 		m_iPos += (int)strTok.length() + 2 + (int)iSkip;  // +2 for quotes; +iSkip for escape characters 
 		m_iSynFlags = noANY ^ (noARG_SEP | noBC | noOPT | noEND);
 
 		return true;
 	}
 
 
 	/** \brief Create an error containing the parse error position.
 
 	  This function will create an Parser Exception object containing the error text and its position.
 
 	  \param a_iErrc [in] The error code of type #EErrorCodes.
 	  \param a_iPos [in] The position where the error was detected.
 	  \param a_strTok [in] The token string representation associated with the error.
 	  \throw ParserException always throws thats the only purpose of this function.
 	*/
 	void  ParserTokenReader::Error(EErrorCodes a_iErrc,	int a_iPos,	const string_type& a_sTok) const
 	{
 		m_pParser->Error(a_iErrc, a_iPos, a_sTok);
 	}
 
 
 	void ParserTokenReader::SetArgSep(char_type cArgSep)
 	{
 		m_cArgSep = cArgSep;
 	}
 
 
 	char_type ParserTokenReader::GetArgSep() const
 	{
 		return m_cArgSep;
 	}
 } // namespace mu
 
 #if defined(_MSC_VER)
 	#pragma warning(pop)
 #endif
