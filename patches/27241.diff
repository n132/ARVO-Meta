commit 163af0b9c0513f31cc4cbfe8aeee26d22513163c
Author: davkor <david@adalogics.com>
Date:   Sat Nov 7 14:05:30 2020 +0000

    strptime: fix bounds check (oss-fuzz 27241)
    
    Signed-off-by: davkor <david@adalogics.com>

diff --git a/src/flb_strptime.c b/src/flb_strptime.c
index c96feb03c..994aad870 100644
--- a/src/flb_strptime.c
+++ b/src/flb_strptime.c
@@ -142,32 +142,39 @@ static char *
 _flb_strptime(const char *buf, const char *fmt, struct tm *tm, int initialize)
 {
 	unsigned char c;
 	const unsigned char *bp, *ep;
 	size_t len = 0;
 	int alt_format, i, offs;
 	int neg = 0;
 	static int century, relyear, fields;
 
 	if (initialize) {
 		century = TM_YEAR_BASE;
 		relyear = -1;
 		fields = 0;
 	}
 
 	bp = (const unsigned char *)buf;
 	while ((c = *fmt) != '\0') {
 		/* Clear `alternate' modifier prior to new conversion. */
 		alt_format = 0;
 
 		/* Eat up white-space. */
 		if (isspace(c)) {
 			while (isspace(*bp))
 				bp++;
 
 			fmt++;
 			continue;
 		}
 
+        /*
+         * Having increased bp we need to ensure we are not
+         * moving beyond bounds.
+         */
+        if (*bp == '\0')
+           return (NULL);
+
 		if ((c = *fmt++) != '%')
 			goto literal;
 
@@ -176,490 +183,497 @@ again:		switch (c = *fmt++) {
 		case '%':	/* "%%" is converted to "%". */
 literal:
 		if (c != *bp++)
 			return (NULL);
 
+        /*
+         * Having increased bp we need to ensure we are not
+         * moving beyond bounds.
+         */
+        if (*bp == '\0')
+           return (NULL);
+
 		break;
 
 		/*
 		 * "Alternative" modifiers. Just set the appropriate flag
 		 * and start over again.
 		 */
 		case 'E':	/* "%E?" alternative conversion modifier. */
 			_LEGAL_ALT(0);
 			alt_format |= _ALT_E;
 			goto again;
 
 		case 'O':	/* "%O?" alternative conversion modifier. */
 			_LEGAL_ALT(0);
 			alt_format |= _ALT_O;
 			goto again;
 
 		/*
 		 * "Complex" conversion rules, implemented through recursion.
 		 */
 		case 'c':	/* Date and time, using the locale's format. */
 			_LEGAL_ALT(_ALT_E);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, _ctloc(D_T_FMT), tm, 0)))
 				return (NULL);
 			break;
 
 		case 'D':	/* The date as "%m/%d/%y". */
 			_LEGAL_ALT(0);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, "%m/%d/%y", tm, 0)))
 				return (NULL);
 			break;
 
 		case 'F':	/* The date as "%Y-%m-%d". */
 			_LEGAL_ALT(0);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, "%Y-%m-%d", tm, 0)))
 				return (NULL);
 			continue;
 
 		case 'R':	/* The time as "%H:%M". */
 			_LEGAL_ALT(0);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, "%H:%M", tm, 0)))
 				return (NULL);
 			break;
 
 		case 'r':	/* The time as "%I:%M:%S %p". */
 			_LEGAL_ALT(0);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, "%I:%M:%S %p", tm, 0)))
 				return (NULL);
 			break;
 
 		case 'T':	/* The time as "%H:%M:%S". */
 			_LEGAL_ALT(0);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, "%H:%M:%S", tm, 0)))
 				return (NULL);
 			break;
 
 		case 'X':	/* The time, using the locale's format. */
 			_LEGAL_ALT(_ALT_E);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, _ctloc(T_FMT), tm, 0)))
 				return (NULL);
 			break;
 
 		case 'x':	/* The date, using the locale's format. */
 			_LEGAL_ALT(_ALT_E);
 			if (!(bp = (const unsigned char *)_flb_strptime((const char *)bp, _ctloc(D_FMT), tm, 0)))
 				return (NULL);
 			break;
 
 		/*
 		 * "Elementary" conversion rules.
 		 */
 		case 'A':	/* The day of week, using the locale's form. */
 		case 'a':
 			_LEGAL_ALT(0);
 			for (i = 0; i < 7; i++) {
 				/* Full name. */
 				len = strlen(_ctloc(day[i]));
 				if (strncasecmp(_ctloc(day[i]), (const char *)bp, len) == 0)
 					break;
 
 				/* Abbreviated name. */
 				len = strlen(_ctloc(abday[i]));
 				if (strncasecmp(_ctloc(abday[i]), (const char *)bp, len) == 0)
 					break;
 			}
 
 			/* Nothing matched. */
 			if (i == 7)
 				return (NULL);
 
 			tm->tm_wday = i;
 			bp += len;
 			fields |= FIELD_TM_WDAY;
 			break;
 
 		case 'B':	/* The month, using the locale's form. */
 		case 'b':
 		case 'h':
 			_LEGAL_ALT(0);
 			for (i = 0; i < 12; i++) {
 				/* Full name. */
 				len = strlen(_ctloc(mon[i]));
 				if (strncasecmp(_ctloc(mon[i]), (const char *)bp, len) == 0)
 					break;
 
 				/* Abbreviated name. */
 				len = strlen(_ctloc(abmon[i]));
 				if (strncasecmp(_ctloc(abmon[i]), (const char *)bp, len) == 0)
 					break;
 			}
 
 			/* Nothing matched. */
 			if (i == 12)
 				return (NULL);
 
 			tm->tm_mon = i;
 			bp += len;
 			fields |= FIELD_TM_MON;
 			break;
 
 		case 'C':	/* The century number. */
 			_LEGAL_ALT(_ALT_E);
 			if (!(_conv_num(&bp, &i, 0, 99)))
 				return (NULL);
 
 			century = i * 100;
 			break;
 
 		case 'e':	/* The day of month. */
 			if (isspace(*bp))
 				bp++;
 			/* FALLTHROUGH */
 		case 'd':
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_mday, 1, 31)))
 				return (NULL);
 			fields |= FIELD_TM_MDAY;
 			break;
 
 		case 'k':	/* The hour (24-hour clock representation). */
 			_LEGAL_ALT(0);
 			/* FALLTHROUGH */
 		case 'H':
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_hour, 0, 23)))
 				return (NULL);
 			break;
 
 		case 'l':	/* The hour (12-hour clock representation). */
 			_LEGAL_ALT(0);
 			/* FALLTHROUGH */
 		case 'I':
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_hour, 1, 12)))
 				return (NULL);
 			break;
 
 		case 'j':	/* The day of year. */
 			_LEGAL_ALT(0);
 			if (!(_conv_num(&bp, &tm->tm_yday, 1, 366)))
 				return (NULL);
 			tm->tm_yday--;
 			fields |= FIELD_TM_YDAY;
 			break;
 
 		case 'M':	/* The minute. */
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_min, 0, 59)))
 				return (NULL);
 			break;
 
 		case 'm':	/* The month. */
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_mon, 1, 12)))
 				return (NULL);
 			tm->tm_mon--;
 			fields |= FIELD_TM_MON;
 			break;
 
 		case 'p':	/* The locale's equivalent of AM/PM. */
 			_LEGAL_ALT(0);
 			/* AM? */
 			len = strlen(_ctloc(AM_STR));
 			if (strncasecmp(_ctloc(AM_STR), (const char *)bp, len) == 0) {
 				if (tm->tm_hour > 12)	/* i.e., 13:00 AM ?! */
 					return (NULL);
 				else if (tm->tm_hour == 12)
 					tm->tm_hour = 0;
 
 				bp += len;
 				break;
 			}
 			/* PM? */
 			len = strlen(_ctloc(PM_STR));
 			if (strncasecmp(_ctloc(PM_STR), (const char *)bp, len) == 0) {
 				if (tm->tm_hour > 12)	/* i.e., 13:00 PM ?! */
 					return (NULL);
 				else if (tm->tm_hour < 12)
 					tm->tm_hour += 12;
 
 				bp += len;
 				break;
 			}
 
 			/* Nothing matched. */
 			return (NULL);
 
 		case 'S':	/* The seconds. */
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_sec, 0, 60)))
 				return (NULL);
 			break;
 		case 's':	/* Seconds since epoch */
 			{
 				int64_t i64;
 				if (!(_conv_num64(&bp, &i64, 0, INT64_MAX)))
 					return (NULL);
 				if (!gmtime_r(&i64, tm))
 					return (NULL);
 				fields = 0xffff;	 /* everything */
 			}
 			break;
 		case 'U':	/* The week of year, beginning on sunday. */
 		case 'W':	/* The week of year, beginning on monday. */
 			_LEGAL_ALT(_ALT_O);
 			/*
 			 * XXX This is bogus, as we can not assume any valid
 			 * information present in the tm structure at this
 			 * point to calculate a real value, so just check the
 			 * range for now.
 			 */
 			 if (!(_conv_num(&bp, &i, 0, 53)))
 				return (NULL);
 			 break;
 
 		case 'w':	/* The day of week, beginning on sunday. */
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &tm->tm_wday, 0, 6)))
 				return (NULL);
 			fields |= FIELD_TM_WDAY;
 			break;
 
 		case 'u':	/* The day of week, monday = 1. */
 			_LEGAL_ALT(_ALT_O);
 			if (!(_conv_num(&bp, &i, 1, 7)))
 				return (NULL);
 			tm->tm_wday = i % 7;
 			fields |= FIELD_TM_WDAY;
 			continue;
 
 		case 'g':	/* The year corresponding to the ISO week
 				 * number but without the century.
 				 */
 			if (!(_conv_num(&bp, &i, 0, 99)))
 				return (NULL);
 			continue;
 
 		case 'G':	/* The year corresponding to the ISO week
 				 * number with century.
 				 */
 			do
 				bp++;
 			while (isdigit(*bp));
 			continue;
 
 		case 'V':	/* The ISO 8601:1988 week number as decimal */
 			if (!(_conv_num(&bp, &i, 0, 53)))
 				return (NULL);
 			continue;
 
 		case 'Y':	/* The year. */
 			_LEGAL_ALT(_ALT_E);
 			if (!(_conv_num(&bp, &i, 0, 9999)))
 				return (NULL);
 
 			relyear = -1;
 			tm->tm_year = i - TM_YEAR_BASE;
 			fields |= FIELD_TM_YEAR;
 			break;
 
 		case 'y':	/* The year within the century (2 digits). */
 			_LEGAL_ALT(_ALT_E | _ALT_O);
 			if (!(_conv_num(&bp, &relyear, 0, 99)))
 				return (NULL);
 			break;
 
 		case 'Z':
 			tzset();
 			if (strncmp((const char *)bp, gmt, 3) == 0) {
 				tm->tm_isdst = 0;
 #ifdef FLB_HAVE_GMTOFF
 				tm->tm_gmtoff = 0;
 #endif
 #ifdef FLB_HAVE_ZONE
 				tm->tm_zone = gmt;
 #endif
 				bp += 3;
 			} else if (strncmp((const char *)bp, utc, 3) == 0) {
 				tm->tm_isdst = 0;
 #ifdef FLB_HAVE_GMTOFF
 				tm->tm_gmtoff = 0;
 #endif
 #ifdef FLB_HAVE_ZONE
 				tm->tm_zone = utc;
 #endif
 				bp += 3;
 			} else {
 				ep = _find_string(bp, &i,
 						 (const char * const *)tzname,
 						  NULL, 2);
 				if (ep == NULL)
 					return (NULL);
 
 				tm->tm_isdst = i;
 #ifdef FLB_HAVE_GMTOFF
 				tm->tm_gmtoff = -(timezone);
 #endif
 #ifdef FLB_HAVE_ZONE
 				tm->tm_zone = tzname[i];
 #endif
 				bp = ep;
 			}
 			continue;
 
 		case 'z':
 			/*
 			 * We recognize all ISO 8601 formats:
 			 * Z	= Zulu time/UTC
 			 * [+-]hhmm
 			 * [+-]hh:mm
 			 * [+-]hh
 			 * We recognize all RFC-822/RFC-2822 formats:
 			 * UT|GMT
 			 *          North American : UTC offsets
 			 * E[DS]T = Eastern : -4 | -5
 			 * C[DS]T = Central : -5 | -6
 			 * M[DS]T = Mountain: -6 | -7
 			 * P[DS]T = Pacific : -7 | -8
 			 */
 			while (isspace(*bp))
 				bp++;
 
 			switch (*bp++) {
 			case 'G':
 				if (*bp++ != 'M')
 					return NULL;
 				/*FALLTHROUGH*/
 			case 'U':
 				if (*bp++ != 'T')
 					return NULL;
 				/*FALLTHROUGH*/
 			case 'Z':
 				tm->tm_isdst = 0;
 #ifdef FLB_HAVE_GMTOFF
 				tm->tm_gmtoff = 0;
 #endif
 #ifdef FLB_HAVE_ZONE
 				tm->tm_zone = utc;
 #endif
 				continue;
 			case '+':
 				neg = 0;
 				break;
 			case '-':
 				neg = 1;
 				break;
 			default:
 				--bp;
 				ep = _find_string(bp, &i, nast, NULL, 4);
 				if (ep != NULL) {
 #ifdef FLB_HAVE_GMTOFF
 					tm->tm_gmtoff = (-5 - i) * SECSPERHOUR;
 #endif
 #ifdef FLB_HAVE_ZONE
 					tm->tm_zone = (char *)nast[i];
 #endif
 					bp = ep;
 					continue;
 				}
 				ep = _find_string(bp, &i, nadt, NULL, 4);
 				if (ep != NULL) {
 					tm->tm_isdst = 1;
 #ifdef FLB_HAVE_GMTOFF
 					tm->tm_gmtoff = (-4 - i) * SECSPERHOUR;
 #endif
 #ifdef FLB_HAVE_ZONE
 					tm->tm_zone = (char *)nadt[i];
 #endif
 					bp = ep;
 					continue;
 				}
 				return NULL;
 			}
 			if (!isdigit(bp[0]) || !isdigit(bp[1]))
 				return NULL;
 			offs = ((bp[0]-'0') * 10 + (bp[1]-'0')) * SECSPERHOUR;
 			bp += 2;
 			if (*bp == ':')
 				bp++;
 			if (isdigit(*bp)) {
 				offs += (*bp++ - '0') * 10 * SECSPERMIN;
 				if (!isdigit(*bp))
 					return NULL;
 				offs += (*bp++ - '0') * SECSPERMIN;
 			}
 			if (neg)
 				offs = -offs;
 			tm->tm_isdst = 0;	/* XXX */
 #ifdef FLB_HAVE_GMTOFF
 			tm->tm_gmtoff = offs;
 #endif
 #ifdef FLB_HAVE_ZONE
 			tm->tm_zone = NULL;	/* XXX */
 #endif
 			continue;
 
 		/*
 		 * Miscellaneous conversions.
 		 */
 		case 'n':	/* Any kind of white-space. */
 		case 't':
 			_LEGAL_ALT(0);
 			while (isspace(*bp))
 				bp++;
 			break;
 
 
 		default:	/* Unknown/unsupported conversion. */
 			return (NULL);
 		}
 
 
 	}
 
 	/*
 	 * We need to evaluate the two digit year spec (%y)
 	 * last as we can get a century spec (%C) at any time.
 	 */
 	if (relyear != -1) {
 		if (century == TM_YEAR_BASE) {
 			if (relyear <= 68)
 				tm->tm_year = relyear + 2000 - TM_YEAR_BASE;
 			else
 				tm->tm_year = relyear + 1900 - TM_YEAR_BASE;
 		} else {
 			tm->tm_year = relyear + century - TM_YEAR_BASE;
 		}
 		fields |= FIELD_TM_YEAR;
 	}
 
 	/* Compute some missing values when possible. */
 	if (fields & FIELD_TM_YEAR) {
 		const int year = tm->tm_year + TM_YEAR_BASE;
 		const int *mon_lens = mon_lengths[isleap(year)];
 		if (!(fields & FIELD_TM_YDAY) &&
 		    (fields & FIELD_TM_MON) && (fields & FIELD_TM_MDAY)) {
 			tm->tm_yday = tm->tm_mday - 1;
 			for (i = 0; i < tm->tm_mon; i++)
 				tm->tm_yday += mon_lens[i];
 			fields |= FIELD_TM_YDAY;
 		}
 		if (fields & FIELD_TM_YDAY) {
 			int days = tm->tm_yday;
 			if (!(fields & FIELD_TM_WDAY)) {
 				tm->tm_wday = EPOCH_WDAY +
 				    ((year - EPOCH_YEAR) % DAYSPERWEEK) *
 				    (DAYSPERNYEAR % DAYSPERWEEK) +
 				    leaps_thru_end_of(year - 1) -
 				    leaps_thru_end_of(EPOCH_YEAR - 1) +
 				    tm->tm_yday;
 				tm->tm_wday %= DAYSPERWEEK;
 				if (tm->tm_wday < 0)
 					tm->tm_wday += DAYSPERWEEK;
 			}
 			if (!(fields & FIELD_TM_MON)) {
 				tm->tm_mon = 0;
 				while (tm->tm_mon < MONSPERYEAR && days >= mon_lens[tm->tm_mon])
 					days -= mon_lens[tm->tm_mon++];
 			}
 			if (!(fields & FIELD_TM_MDAY))
 				tm->tm_mday = days + 1;
 		}
 	}
 
 	return ((char *)bp);
 }
