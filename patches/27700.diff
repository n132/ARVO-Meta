commit 633fdfb78b85d795f4b437cdb5fbdc041ae2b622
Author: seladb <pcapplusplus@gmail.com>
Date:   Sun Nov 22 00:49:24 2020 -0800

    Add parsing of two TLS extensions: supported groups and EC point format

diff --git a/Packet++/header/SSLCommon.h b/Packet++/header/SSLCommon.h
index b5258c1e..8d7bb5bf 100644
--- a/Packet++/header/SSLCommon.h
+++ b/Packet++/header/SSLCommon.h
@@ -12,601 +12,601 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct ssl_tls_record_layer
 	 * The common part of all SSL/TLS messages
 	 */
 #pragma pack(push, 1)
 	struct ssl_tls_record_layer
 	{
 		/** Message (record) type (one of ::SSLRecordType) */
 		uint8_t recordType;
 		/** Message (record) version (one of SSLVersion::SSLVersionEnum) */
 		uint16_t recordVersion;
 		/** Message (record) length in bytes */
 		uint16_t length;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * @struct ssl_tls_handshake_layer
 	 * The common part of all SSL/TLS handshake message types
 	 */
 #pragma pack(push, 1)
 	struct ssl_tls_handshake_layer
 	{
 		/** Type of the handshake message (one of ::SSLHandshakeType) */
 		uint8_t handshakeType;
 		/** Length of the message. Length is 3-Byte long, This is the MSB byte */
 		uint8_t length1;
 		/** Length of the message. Length is 3-Byte long, This is the 2 LSB bytes */
 		uint16_t length2;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * @struct ssl_tls_client_server_hello
 	 * The common header part of client-hello and server-hello handshake messages
 	 */
 #pragma pack(push, 1)
 	struct ssl_tls_client_server_hello : ssl_tls_handshake_layer
 	{
 		/** SSL/TLS handshake version (one of SSLVersion::SSLVersionEnum) */
 		uint16_t handshakeVersion;
 		/** 32-bytes random number */
 		uint8_t random[32];
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * @struct ssl_tls_change_cipher_spec
 	 * SSL/TLS change-cipher-spec message structure
 	 */
 #pragma pack(push, 1)
 	struct ssl_tls_change_cipher_spec
 	{
 		/** Unused byte */
 		uint8_t changeCipherSpec;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * @struct ssl_tls_alert
 	 * SSL/TLS alert message structure
 	 */
 #pragma pack(push, 1)
 	struct ssl_tls_alert
 	{
 		/** Alert level (one of ::SSLAlertLevel) */
 		uint8_t alertLevel;
 		/** Alert description (one of ::SSLAlertDescription) */
 		uint8_t alertDescription;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * SSL/TLS message types
 	 */
 	enum SSLRecordType
 	{
 		/** Change-cipher-spec message */
 		SSL_CHANGE_CIPHER_SPEC = 20,
 		/** SSL alert message */
 		SSL_ALERT              = 21,
 		/** SSL handshake message */
 		SSL_HANDSHAKE          = 22,
 		/** SSL data message */
 		SSL_APPLICATION_DATA   = 23
 	};
 
 
 	/**
 	 * @class SSLVersion
 	 * A wrapper class for SSL/TLS versions. The SSL/TLS version is typically represented by a 2-byte number,
 	 * for example TLS 1.2 is represented by 0x0303.
 	 * This class wraps the numeric value and provides methods to convert it into an enum, string, etc.
 	 */
 	class SSLVersion
 	{
 	public:
 		/**
 		 * SSL/TLS versions enum
 		 */
 		enum SSLVersionEnum
 		{
 			/** SSL 2.0 */
 			SSL2   = 0x0200,
 			/** SSL 3.0 */
 			SSL3   = 0x0300,
 			/** TLS 1.0 */
 			TLS1_0 = 0x0301,
 			/** TLS 1.1 */
 			TLS1_1 = 0x0302,
 			/** TLS 1.2 */
 			TLS1_2 = 0x0303,
 			/** TLS 1.3 */
 			TLS1_3 = 0x0304,
 			/** TLS 1.3 (draft 14) */
 			TLS1_3_D14 = 0x7f0e,
 			/** TLS 1.3 (draft 15) */
 			TLS1_3_D15 = 0x7f0f,
 			/** TLS 1.3 (draft 16) */
 			TLS1_3_D16 = 0x7f10,
 			/** TLS 1.3 (draft 17) */
 			TLS1_3_D17 = 0x7f11,
 			/** TLS 1.3 (draft 18) */
 			TLS1_3_D18 = 0x7f12,
 			/** TLS 1.3 (draft 19) */
 			TLS1_3_D19 = 0x7f13,
 			/** TLS 1.3 (draft 20) */
 			TLS1_3_D20 = 0x7f14,
 			/** TLS 1.3 (draft 21) */
 			TLS1_3_D21 = 0x7f15,
 			/** TLS 1.3 (draft 22) */
 			TLS1_3_D22 = 0x7f16,
 			/** TLS 1.3 (draft 23) */
 			TLS1_3_D23 = 0x7f17,
 			/** TLS 1.3 (draft 24) */
 			TLS1_3_D24 = 0x7f18,
 			/** TLS 1.3 (draft 25) */
 			TLS1_3_D25 = 0x7f19,
 			/** TLS 1.3 (draft 26) */
 			TLS1_3_D26 = 0x7f1a,
 			/** TLS 1.3 (draft 27) */
 			TLS1_3_D27 = 0x7f1b,
 			/** TLS 1.3 (draft 28) */
 			TLS1_3_D28 = 0x7f1c,
 			/** TLS 1.3 (Facebook draft 23) */
 			TLS1_3_FBD23 = 0xfb17,
 			/** TLS 1.3 (Facebook draft 26) */
 			TLS1_3_FBD26 = 0xfb1a,
 			/** Unknown value */
 			Unknown = 0
 		};
 
 		/**
 		 * A c'tor for this class.
 		 * @param[in] sslVersionValue The numeric value representing this SSL/TLS version. For example:
 		 * for TLS 1.2 this would be 0x0303.
 		 */
 		SSLVersion(uint16_t sslVersionValue) { m_SSLVersionValue = sslVersionValue; }
 
 		/**
 		 * @return An enum value of type SSLVersion::SSLVersionEnum representing the SSL/TLS version.
 		 * If the numeric value is an invalid SSL/TLS version SSLVersion::Unknown will be returned.
 		 * @param[in] countTlsDraftsAs1_3 A flag indicating whether to return the enum value SSLVersion::TLS1_3 for all TLS 1.3 drafts. If set to "true"
 		 * all TLS 1.3 draft values (i.e 0x7f0e - 0x7f1c, 0xfb17, 0xfb1a) will return SSLVersion::TLS1_3, otherwise the corresponding enum values will be
 		 * returned. The default value is "false".
 		 */
 		SSLVersionEnum asEnum(bool countTlsDraftsAs1_3 = false);
 
 		/**
 		 * @return The numeric value of the SSL/TLs version
 		 */
 		uint16_t asUInt() { return m_SSLVersionValue; }
 
 		/**
 		 * @return A string representation of the SSL/TLS version. For example: for TLS 1.2 the string "TLS 1.2" is returned.
 		 * If the numeric value is an invalid SSL/TLS version the string "Unknown" will be returned.
 		 * @param[in] countTlsDraftsAs1_3 A flag indicating whether to return the string value "TLS 1.3" for all TLS 1.3 drafts. If set to "true"
 		 * all TLS 1.3 draft values (i.e 0x7f0e - 0x7f1c, 0xfb17, 0xfb1a) will return "TLS 1.3", otherwise the corresponding string values will be
 		 * returned. The default value is "false".
 		 */
 		std::string toString(bool countTlsDraftsAs1_3 = false);
 
 	private:
 		uint16_t m_SSLVersionValue;
 
 		// unimplemented empty c'tor
 		SSLVersion();
 	};
 
 	/**
 	 * SSL/TLS handshake message types
 	 */
 	enum SSLHandshakeType
 	{
 		/** Hello-request message type */
 		SSL_HELLO_REQUEST        = 0,
 		/** Client-hello message type */
 		SSL_CLIENT_HELLO         = 1,
 		/** Server-hello message type */
 		SSL_SERVER_HELLO         = 2,
 		/** New-session-ticket message type */
 		SSL_NEW_SESSION_TICKET   = 4,
 		/** End-of-early-data message type (TLS 1.3) */
 		SSL_END_OF_EARLY_DATE    = 5,
 		/** Encrypted-extensions message type (TLS 1.3) */
 		SSL_ENCRYPTED_EXTENSIONS = 8,
 		/** Certificate message type */
 		SSL_CERTIFICATE          = 11,
 		/** Server-key-exchange message type */
 		SSL_SERVER_KEY_EXCHANGE  = 12,
 		/** Certificate-request message type */
 		SSL_CERTIFICATE_REQUEST  = 13,
 		/** Server-hello-done message type */
 		SSL_SERVER_DONE          = 14,
 		/** Certificate-verify message type */
 		SSL_CERTIFICATE_VERIFY   = 15,
 		/** Client-key-exchange message type */
 		SSL_CLIENT_KEY_EXCHANGE  = 16,
 		/** Finish message type */
 		SSL_FINISHED             = 20,
 		/** Key-update message type (TLS 1.3) */
 		SSL_KEY_UPDATE           = 24,
 		/** Unknown SSL handshake message */
 		SSL_HANDSHAKE_UNKNOWN    = 255
 	};
 
 	/**
 	 * SSL/TLS alert levels
 	 */
 	enum SSLAlertLevel
 	{
 		/** Warning level alert */
 		SSL_ALERT_LEVEL_WARNING       = 1,
 		/** Fatal level alert */
 		SSL_ALERT_LEVEL_FATAL         = 2,
 		/** For encrypted alerts the level is unknown so this type will be returned */
 		SSL_ALERT_LEVEL_ENCRYPTED     = 255
 	};
 
 	/**
 	 * SSL/TLS alert description types
 	 */
 	enum SSLAlertDescription
 	{
 		/** Close notify alert */
 		SSL_ALERT_CLOSE_NOTIFY            =  0,
 		/** Unexpected message alert */
 		SSL_ALERT_UNEXPECTED_MESSAGE      = 10,
 		/** Bad record MAC alert */
 		SSL_ALERT_BAD_RECORD_MAC          = 20,
 		/** Decryption failed alert */
 		SSL_ALERT_DECRYPTION_FAILED       = 21,
 		/**  */
 		SSL_ALERT_RECORD_OVERFLOW         = 22,
 		/** Decompression failure alert */
 		SSL_ALERT_DECOMPRESSION_FAILURE   = 30,
 		/** Handshake failure alert */
 		SSL_ALERT_HANDSHAKE_FAILURE       = 40,
 		/** No certificate alert */
 		SSL_ALERT_NO_CERTIFICATE          = 41,
 		/** Bad certificate alert */
 		SSL_ALERT_BAD_CERTIFICATE         = 42,
 		/** Unsupported certificate */
 		SSL_ALERT_UNSUPPORTED_CERTIFICATE = 43,
 		/** Certificate revoked alert */
 		SSL_ALERT_CERTIFICATE_REVOKED     = 44,
 		/** Certificate expired alert */
 		SSL_ALERT_CERTIFICATE_EXPIRED     = 45,
 		/** Certificate unknown alert */
 		SSL_ALERT_CERTIFICATE_UNKNOWN     = 46,
 		/** Illegal parameter alert */
 		SSL_ALERT_ILLEGAL_PARAMETER       = 47,
 		/** Unknown CA alert */
 		SSL_ALERT_UNKNOWN_CA              = 48,
 		/** Access denied alert */
 		SSL_ALERT_ACCESS_DENIED           = 49,
 		/** Decode error alert */
 		SSL_ALERT_DECODE_ERROR            = 50,
 		/** Decrypt error alert */
 		SSL_ALERT_DECRYPT_ERROR           = 51,
 		/** Export restriction alert */
 		SSL_ALERT_EXPORT_RESTRICTION      = 60,
 		/** Protocol version alert */
 		SSL_ALERT_PROTOCOL_VERSION        = 70,
 		/** Insufficient security alert */
 		SSL_ALERT_INSUFFICIENT_SECURITY   = 71,
 		/** Internal error alert */
 		SSL_ALERT_INTERNAL_ERROR          = 80,
 		/** User cancelled alert */
 		SSL_ALERT_USER_CANCELLED          = 90,
 		/** No negotiation alert */
 		SSL_ALERT_NO_RENEGOTIATION        = 100,
 		/** Unsupported extension alert */
 		SSL_ALERT_UNSUPPORTED_EXTENSION   = 110,
 		/** Encrtpyed alert (cannot determine its type) */
 		SSL_ALERT_ENCRYPTED               = 255
 	};
 
 	/**
 	 * SSL/TLS key exchange algorithms
 	 */
 	enum SSLKeyExchangeAlgorithm
 	{
 		/** NULL value */
 		SSL_KEYX_NULL,
 		/** RSA (Rivest-Shamir-Adleman) */
 		SSL_KEYX_RSA,
 		/** Diffie-Hellman */
 		SSL_KEYX_DH,
 		/** Diffie-Hellman ephemeral */
 		SSL_KEYX_DHE,
 		/** Elliptic curve Diffie�Hellman */
 		SSL_KEYX_ECDH,
 		/** Elliptic curve Diffie�Hellman ephemeral */
 		SSL_KEYX_ECDHE,
 		/** Fortezza Crypto Card */
 		SSL_KEYX_FORTEZZA,
 		/** Kerberos 5 */
 		SSL_KEYX_KRB5,
 		/**  Pre-Shared Key */
 		SSL_KEYX_PSK,
 		/** GOST */
 		SSL_KEYX_GOST,
 		/** Secure Remote Password */
 		SSL_KEYX_SRP,
 		/** PCT */
 		SSL_KEYX_PCT,
 		/** Unknown algorithm */
 		SSL_KEYX_Unknown
 	};
 
 	/**
 	 * SSL/TLS authentication algorithms
 	 */
 	enum SSLAuthenticationAlgorithm
 	{
 		/** NULL value */
 		SSL_AUTH_NULL,
 		/** RSA (Rivest-Shamir-Adleman) */
 		SSL_AUTH_RSA,
 		/** Digital Signature Standard */
 		SSL_AUTH_DSS,
 		/** Anonymous */
 		SSL_AUTH_anon,
 		/** Diffie-Hellman based key-exchange protocol */
 		SSL_AUTH_KEA,
 		/** Kerberos 5 */
 		SSL_AUTH_KRB5,
 		/** Pre-Shared Key */
 		SSL_AUTH_PSK,
 		/** Elliptic Curve Digital Signature Algorithm */
 		SSL_AUTH_ECDSA,
 		/** GOST */
 		SSL_AUTH_GOST,
 		/** SHA-1 (Secure Hash Algorithm) */
 		SSL_AUTH_SHA,
 		/** PCT */
 		SSL_AUTH_PCT,
 		/** Diffie-Hellman ephemeral */
 		SSL_AUTH_DHE,
 		/** Unknown algorithm */
 		SSL_AUTH_Unknown
 	};
 
 	/**
 	 * SSL/TLS symmetric encryption algorithms
 	 */
 	enum SSLSymetricEncryptionAlgorithm
 	{
 		/** NULL value */
 		SSL_SYM_NULL,
 		/** RC4_40 */
 		SSL_SYM_RC4_40,
 		/** RC4_128 */
 		SSL_SYM_RC4_128,
 		/** RC2_CBC_40 */
 		SSL_SYM_RC2_CBC_40,
 		/** IDEA_CBC */
 		SSL_SYM_IDEA_CBC,
 		/** DES40_CBC */
 		SSL_SYM_DES40_CBC,
 		/** DES_CBC */
 		SSL_SYM_DES_CBC,
 		/** 3DES_EDE_CBC */
 		SSL_SYM_3DES_EDE_CBC,
 		/** FORTEZZA_CBC */
 		SSL_SYM_FORTEZZA_CBC,
 		/** DES_CBC_40 */
 		SSL_SYM_DES_CBC_40,
 		/** AES_128_CBC */
 		SSL_SYM_AES_128_CBC,
 		/** AES_256_CBC */
 		SSL_SYM_AES_256_CBC,
 		/** CAMELLIA_128_CBC */
 		SSL_SYM_CAMELLIA_128_CBC,
 		/** CAMELLIA_128_GCM */
 		SSL_SYM_CAMELLIA_128_GCM,
 		/** CAMELLIA_256_GCM */
 		SSL_SYM_CAMELLIA_256_GCM,
 		/** RC4_56 */
 		SSL_SYM_RC4_56,
 		/** RC2_CBC_56 */
 		SSL_SYM_RC2_CBC_56,
 		/** GOST28147 */
 		SSL_SYM_GOST28147,
 		/** CAMELLIA_256_CBC */
 		SSL_SYM_CAMELLIA_256_CBC,
 		/** SEED_CBC */
 		SSL_SYM_SEED_CBC,
 		/** AES_128 */
 		SSL_SYM_AES_128,
 		/** AES_256 */
 		SSL_SYM_AES_256,
 		/** SSL_SYM_AES_128_GCM */
 		SSL_SYM_AES_128_GCM,
 		/** AES_256_GCM */
 		SSL_SYM_AES_256_GCM,
 		/** RC4_128_EXPORT40 */
 		SSL_SYM_RC4_128_EXPORT40,
 		/** RC2_CBC_128_CBC */
 		SSL_SYM_RC2_CBC_128_CBC,
 		/** IDEA_128_CBC */
 		SSL_SYM_IDEA_128_CBC,
 		/** DES_64_CBC */
 		SSL_SYM_DES_64_CBC,
 		/** DES_192_EDE3_CBC */
 		SSL_SYM_DES_192_EDE3_CBC,
 		/** RC4_64 */
 		SSL_SYM_RC4_64,
 		/** ARIA_128_CBC*/
 		SSL_SYM_ARIA_128_CBC,
 		/** ARIA_256_CBC */
 		SSL_SYM_ARIA_256_CBC,
 		/** ARIA_128_GCM */
 		SSL_SYM_ARIA_128_GCM,
 		/** ARIA_256_GCM */
 		SSL_SYM_ARIA_256_GCM,
 		/** CHACHA20_POLY1305 */
 		SSL_SYM_CHACHA20_POLY1305,
 		/** AES_128_CCM */
 		SSL_SYM_AES_128_CCM,
 		/** AES_128_CCM_8 */
 		SSL_SYM_AES_128_CCM_8,
 		/** Unknown algorithm */
 		SSL_SYM_Unknown
 	};
 
 	/**
 	 * SSL/TLS hashing algortihms
 	 */
 	enum SSLHashingAlgorithm
 	{
 		/** NULL value */
 		SSL_HASH_NULL,
 		/** Message-Digest Algorithm */
 		SSL_HASH_MD5,
 		/** SHA-1 (Secure Hash Algorithm) */
 		SSL_HASH_SHA,
 		/** SHA-256 (Secure Hash Algorithm) */
 		SSL_HASH_SHA256,
 		/** GOST 28147 */
 		SSL_HASH_GOST28147,
 		/**  GOST R 34.11 */
 		SSL_HASH_GOSTR3411,
 		/** SHA-384 (Secure Hash Algorithm) */
 		SSL_HASH_SHA384,
 		/** CCM mode (Counter with CBC-MAC) */
 		SSL_HASH_CCM,
 		/** CCM mode (Counter with CBC-MAC) */
 		SSL_HASH_CCM_8,
 		/** Unknown algorithm */
 		SSL_HASH_Unknown
 	};
 
 	/**
 	 * SSL/TLS extension types
 	 */
 	enum SSLExtensionType
 	{
 		/** Server Name Indication extension */
 		SSL_EXT_SERVER_NAME = 0,
 		/** Maximum Fragment Length Negotiation extension */
 		SSL_EXT_MAX_FRAGMENT_LENGTH = 1,
 		/** Client Certificate URLs extension */
 		SSL_EXT_CLIENT_CERTIFICATE_URL = 2,
 		/** Trusted CA Indication extension */
 		SSL_EXT_TRUSTED_CA_KEYS = 3,
 		/** Truncated HMAC extension */
 		SSL_EXT_TRUNCATED_HMAC = 4,
 		/** Certificate Status Request extension */
 		SSL_EXT_STATUS_REQUEST = 5,
 		/** TLS User Mapping extension */
 		SSL_EXT_USER_MAPPING = 6,
 		/** Client Authorization  extension */
 		SSL_EXT_CLIENT_AUTHZ = 7,
 		/** Server Authorization extension */
 		SSL_EXT_SERVER_AUTHZ = 8,
 		/** Certificate Type extension */
 		SSL_EXT_CERT_TYPE = 9,
-		/** Supported Elliptic Curves extension */
-		SSL_EXT_ELLIPTIC_CURVES = 10,
+		/** Supported Groups extension (renamed from "elliptic curves") */
+		SSL_EXT_SUPPORTED_GROUPS = 10,
 		/** Elliptic Curves Point Format extension */
 		SSL_EXT_EC_POINT_FORMATS = 11,
 		/** Secure Remote Password extension */
 		SSL_EXT_SRP = 12,
 		/** Signature Algorithms extension */
 		SSL_EXT_SIGNATURE_ALGORITHMS = 13,
 		/** Use Secure Real-time Transport Protocol extension */
 		SSL_EXT_USE_SRTP = 14,
 		/** TLS Heartbit extension */
 		SSL_EXT_HEARTBEAT = 15,
 		/** Application Layer Protocol Negotiation (ALPN) extension */
 		SSL_EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION = 16,
 		/** Status Request extension */
 		SSL_EXT_STATUS_REQUEST_V2 = 17,
 		/** Signed Certificate Timestamp extension */
 		SSL_EXT_SIGNED_CERTIFICATE_TIMESTAMP = 18,
 		/** Client Certificate Type extension */
 		SSL_EXT_CLIENT_CERTIFICATE_TYPE = 19,
 		/** Server Certificate Type extension */
 		SSL_EXT_SERVER_CERTIFICATE_TYPE = 20,
 		/** ClientHello Padding extension */
 		SSL_EXT_PADDING = 21,
 		/** Encrypt-then-MAC extension */
 		SSL_EXT_ENCRYPT_THEN_MAC = 22,
 		/** Extended Master Secret extension */
 		SSL_EXT_EXTENDED_MASTER_SECRET = 23,
 		/** Token Binding extension */
 		SSL_EXT_TOKEN_BINDING = 24,
 		/** SessionTicket TLS extension */
 		SSL_EXT_SESSIONTICKET_TLS = 35,
 		/** Pre-shared key (PSK) extension (TLS 1.3) */
 		SSL_EXT_PRE_SHARED_KEY = 41,
 		/** Early data extension (TLS 1.3) */
 		SSL_EXT_EARLY_DATA = 42,
 		/** Supported versions extension (TLS 1.3) */
 		SSL_EXT_SUPPORTED_VERSIONS = 43,
 		/** Cookie extension (TLS 1.3) */
 		SSL_EXT_COOKIE = 44,
 		/** Pre-Shared Key Exchange Modes extension (TLS 1.3) */
 		SSL_EXT_PSK_KEY_EXCHANGE_MODES = 45,
 		/** Certificate authorities extension (TLS 1.3) */
 		SSL_EXT_CERTIFICATE_AUTHORITIES = 47,
 		/** Old filters extension (TLS 1.3) */
 		SSL_EXT_OLD_FILTERS = 48,
 		/** Post hanshake auth extension (TLS 1.3) */
 		SSL_EXT_POST_HANDSHAKE_AUTH = 49,
 		/** Signature algorithm cert extension (TLS 1.3) */
 		SSL_EXT_SIGNATURE_ALGORITHM_CERT = 50,
 		/** Key share extension (TLS 1.3) */
 		SSL_EXT_KEY_SHARE = 51,
 		/** Renegotiation Indication extension */
 		SSL_EXT_RENEGOTIATION_INFO = 65281,
 		/** Unknown extension */
 		SSL_EXT_Unknown
 	};
 
 	/**
 	 * SSL/TLS client certificate types
 	 */
 	enum SSLClientCertificateType
 	{
 		/** RSA_SIGN */
 		SSL_CCT_RSA_SIGN = 1,
 		/** DSS_SIGN */
 		SSL_CCT_DSS_SIGN = 2,
 		/** RSA_FIXED_DH */
 		SSL_CCT_RSA_FIXED_DH = 3,
 		/** DSS_FIXED_DH */
 		SSL_CCT_DSS_FIXED_DH = 4,
 		/** RSA_EPHEMERAL_DH_RESERVED */
 		SSL_CCT_RSA_EPHEMERAL_DH_RESERVED = 5,
 		/** DSS_EPHEMERAL_DH_RESERVED */
 		SSL_CCT_DSS_EPHEMERAL_DH_RESERVED = 6,
 		/** FORTEZZA_DMS_RESERVED */
 		SSL_CCT_FORTEZZA_DMS_RESERVED = 20,
 		/** ECDSA_SIGN */
 		SSL_CCT_ECDSA_SIGN = 64,
 		/** FIXED_ECDH */
 		SSL_CCT_RSA_FIXED_ECDH = 65,
 		/** ECDSA_FIXED_ECDH */
 		SSL_CCT_ECDSA_FIXED_ECDH = 66,
 		/** Unknown client certificate type */
 		SSL_CCT_UNKNOWN
 	};
 
 } //namespace pcpp
 
 #endif // PACKETPP_SSL_LAYER_COMMON
diff --git a/Packet++/header/SSLHandshake.h b/Packet++/header/SSLHandshake.h
index e7ec82c5..ea0315b2 100644
--- a/Packet++/header/SSLHandshake.h
+++ b/Packet++/header/SSLHandshake.h
@@ -193,21 +193,63 @@ class SSLSupportedVersionsExtension : public SSLExtension
 {
 public:
 	/**
 	 * C'tor for this class
 	 * @param[in] data The raw data for the extension
 	 */
 	SSLSupportedVersionsExtension(uint8_t* data) : SSLExtension(data) {}
 
 	/**
 	 * @return The list of supported versions mentioned in the extension data
 	 */
 	std::vector<SSLVersion> getSupportedVersions() const;
 };
 
 
+/**
+ * @class TLSSupportedGroupsExtension
+ * Represents TLS Supported Groups extension. Inherits from SSLExtension and adds parsing of the
+ * supported groups (Elliptic Curves) mentioned in the extension data
+ */
+class TLSSupportedGroupsExtension : public SSLExtension
+{
+	public:
+	/**
+	 * C'tor for this class
+	 * @param[in] data The raw data for the extension
+	 */
+	TLSSupportedGroupsExtension(uint8_t* data) : SSLExtension(data) {}
+
+	/**
+	 * @return A vector of the supported groups (also known as "Elliptic Curves")
+	 */
+	std::vector<uint16_t> getSupportedGroups() const;
+};
+
+
+/**
+ * @class TLSECPointFormatExtension
+ * Represents TLS EC (Elliptic Curves) Point Format extension. Inherits from SSLExtension and adds parsing of the
+ * EC point formats mentioned in the extension data
+ */
+class TLSECPointFormatExtension : public SSLExtension
+{
+	public:
+	/**
+	 * C'tor for this class
+	 * @param[in] data The raw data for the extension
+	 */
+	TLSECPointFormatExtension(uint8_t* data) : SSLExtension(data) {}
+
+	/**
+	 * @return A vector of the elliptic curves point formats
+	 */
+	std::vector<uint8_t> getECPointFormatList() const;
+};
+
+
 /**
  * @class SSLx509Certificate
  * Represents a x509v3 certificate. the SSLCertificateMessage class returns an instance of this class as the certificate.
  * Currently this class doesn't do much as it doesn't parse the certificate. It only acts as container to the raw data
  * and returns general info as data as raw, length, etc. In the future I may add full parsing of the certificate
  */
diff --git a/Packet++/src/SSLHandshake.cpp b/Packet++/src/SSLHandshake.cpp
index 23b2c370..934ad15b 100644
--- a/Packet++/src/SSLHandshake.cpp
+++ b/Packet++/src/SSLHandshake.cpp
@@ -1121,29 +1121,80 @@ std::string SSLServerNameIndicationExtension::getHostName() const
 std::vector<SSLVersion> SSLSupportedVersionsExtension::getSupportedVersions() const
 {
 	std::vector<SSLVersion> result;
 	uint16_t extensionLength = getLength();
 	if (extensionLength == 2) // server hello message
 	{
 		result.push_back(SSLVersion(be16toh(*(uint16_t*)getData())));
 	}
 	else // client-hello message
 	{
 		uint8_t listLength = *getData();
 		if (listLength != static_cast<uint8_t>(extensionLength - 1) || listLength % 2 != 0)
 			return result; // bad extension data
 
 		uint8_t* dataPtr = getData() + sizeof(uint8_t);
 		for (int i = 0; i < listLength / 2; i++)
 		{
 			result.push_back(SSLVersion(be16toh(*(uint16_t*)dataPtr)));
 			dataPtr += sizeof(uint16_t);
 		}
 	}
 
 	return result;
 }
 
 
+// -----------------------------------
+// TLSSupportedGroupsExtension methods
+// -----------------------------------
+
+std::vector<uint16_t> TLSSupportedGroupsExtension::getSupportedGroups() const
+{
+	std::vector<uint16_t> result;
+
+	uint16_t extensionLength = getLength();
+	if (extensionLength < sizeof(uint16_t))
+		return result; //bad extension data
+
+	uint16_t listLength = be16toh(*(uint16_t*)getData());
+	if (listLength != (extensionLength - sizeof(uint16_t)) || listLength % 2 != 0)
+		return result; // bad extension data
+
+	uint8_t* dataPtr = getData() + sizeof(uint16_t);
+	for (int i = 0; i < listLength / 2; i++)
+	{
+		result.push_back(be16toh(*(uint16_t*)dataPtr));
+		dataPtr += sizeof(uint16_t);
+	}
+
+	return result;
+}
+
+
+// ---------------------------------
+// TLSECPointFormatExtension methods
+// ---------------------------------
+
+std::vector<uint8_t> TLSECPointFormatExtension::getECPointFormatList() const
+{
+	std::vector<uint8_t> result;
+
+	uint16_t extensionLength = getLength();
+	uint8_t listLength = *getData();
+	if (listLength != static_cast<uint8_t>(extensionLength - 1))
+		return result; // bad extension data
+
+	uint8_t* dataPtr = getData() + sizeof(uint8_t);
+	for (int i = 0; i < listLength; i++)
+	{
+		result.push_back(*dataPtr);
+		dataPtr += sizeof(uint8_t);
+	}
+
+	return result;
+}
+
+
 // ---------------------------
 // SSLHandshakeMessage methods
 // ---------------------------
@@ -1225,44 +1276,50 @@ bool SSLHandshakeMessage::isMessageComplete() const
 SSLClientHelloMessage::SSLClientHelloMessage(uint8_t* data, size_t dataLen, SSLHandshakeLayer* container)
 	: SSLHandshakeMessage(data, dataLen, container)
 {
 	size_t extensionLengthOffset = sizeof(ssl_tls_client_server_hello) + sizeof(uint8_t) + getSessionIDLength() + sizeof(uint16_t) + sizeof(uint16_t)*getCipherSuiteCount() + 2*sizeof(uint8_t);
 	if (extensionLengthOffset + sizeof(uint16_t) > m_DataLen)
 		return;
 
 	uint8_t* extensionLengthPos = m_Data + extensionLengthOffset;
 	uint16_t extensionLength = getExtensionsLenth();
 	uint8_t* extensionPos = extensionLengthPos + sizeof(uint16_t);
 	uint8_t* curPos = extensionPos;
 	size_t messageLen = getMessageLength();
 	size_t minSSLExtentionLen = 2*sizeof(uint16_t) + sizeof(uint8_t);
 	while ((curPos - extensionPos) < (int)extensionLength 
 		&& (curPos - m_Data) < (int)messageLen 
 		&& (int)messageLen - (curPos - m_Data) >= (int)minSSLExtentionLen)
 	{
 		SSLExtension* newExt = NULL;
 		uint16_t sslExtType = be16toh(*(uint16_t*)curPos);
 		switch (sslExtType)
 		{
 		case SSL_EXT_SERVER_NAME:
 			newExt = new SSLServerNameIndicationExtension(curPos);
 			break;
 		case SSL_EXT_SUPPORTED_VERSIONS:
 			newExt = new SSLSupportedVersionsExtension(curPos);
 			break;
+		case SSL_EXT_SUPPORTED_GROUPS:
+			newExt = new TLSSupportedGroupsExtension(curPos);
+			break;
+		case SSL_EXT_EC_POINT_FORMATS:
+			newExt = new TLSECPointFormatExtension(curPos);
+			break;
 		default:
 			newExt = new SSLExtension(curPos);
 		}
 
 		// Total length can be zero only if getLength() == 0xfffc which is way too large
 		// and means that this extension (and packet) are malformed
 		if (newExt->getTotalLength() == 0)
 		{
 			delete newExt;
 			break;
 		}
 			
 
 		m_ExtensionList.pushBack(newExt);
 		curPos += newExt->getTotalLength();
 	}
 }
@@ -1385,41 +1442,47 @@ std::string SSLClientHelloMessage::toString() const
 SSLServerHelloMessage::SSLServerHelloMessage(uint8_t* data, size_t dataLen, SSLHandshakeLayer* container)
 	: SSLHandshakeMessage(data, dataLen, container)
 {
 	size_t extensionLengthOffset = sizeof(ssl_tls_client_server_hello) + sizeof(uint8_t) + getSessionIDLength() + sizeof(uint16_t) + sizeof(uint8_t);
 	if (extensionLengthOffset + sizeof(uint16_t) > m_DataLen)
 		return;
 
 	uint8_t* extensionLengthPos = m_Data + extensionLengthOffset;
 	uint16_t extensionLength = getExtensionsLenth();
 	uint8_t* extensionPos = extensionLengthPos + sizeof(uint16_t);
 	uint8_t* curPos = extensionPos;
 	size_t messageLen = getMessageLength();
 	size_t minSSLExtentionLen = 2*sizeof(uint16_t) + sizeof(uint8_t);
 	while ((curPos - extensionPos) < (int)extensionLength 
 		&& (curPos - m_Data) < (int)messageLen 
 		&& (int)messageLen - (curPos - m_Data) >= (int)minSSLExtentionLen)
 	{
 		SSLExtension* newExt = NULL;
 		uint16_t sslExtType = be16toh(*(uint16_t*)curPos);
 		switch (sslExtType)
 		{
 		case SSL_EXT_SERVER_NAME:
 			newExt = new SSLServerNameIndicationExtension(curPos);
 			break;
 		case SSL_EXT_SUPPORTED_VERSIONS:
 			newExt = new SSLSupportedVersionsExtension(curPos);
 			break;
+		case SSL_EXT_SUPPORTED_GROUPS:
+			newExt = new TLSSupportedGroupsExtension(curPos);
+			break;
+		case SSL_EXT_EC_POINT_FORMATS:
+			newExt = new TLSECPointFormatExtension(curPos);
+			break;
 		default:
 			newExt = new SSLExtension(curPos);
 		}
 
 		if (newExt->getTotalLength() == 0)
 		{
 			delete newExt;
 			break;
 		}
 			
 		m_ExtensionList.pushBack(newExt);
 		curPos += newExt->getTotalLength();
 	}
 }
diff --git a/Tests/Packet++Test/Tests/SSLTests.cpp b/Tests/Packet++Test/Tests/SSLTests.cpp
index dc075055..31d3a2a5 100644
--- a/Tests/Packet++Test/Tests/SSLTests.cpp
+++ b/Tests/Packet++Test/Tests/SSLTests.cpp
@@ -11,140 +11,154 @@
 PTF_TEST_CASE(SSLClientHelloParsingTest)
 {
 	timeval time;
 	gettimeofday(&time, NULL);
 	READ_FILE_AND_CREATE_PACKET(1, "PacketExamples/SSL-ClientHello1.dat");
 
 	pcpp::Packet clientHelloPacket(&rawPacket1);
 
 	PTF_ASSERT_TRUE(clientHelloPacket.isPacketOfType(pcpp::SSL));
 	pcpp::SSLHandshakeLayer* handshakeLayer = clientHelloPacket.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	PTF_ASSERT_EQUAL(handshakeLayer->getHandshakeMessagesCount(), 1, size);
 	pcpp::SSLClientHelloMessage* clientHelloMessage = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLClientHelloMessage>();
 	PTF_ASSERT_TRUE(handshakeLayer->getHandshakeMessageAt(0) == clientHelloMessage);
 	PTF_ASSERT_NOT_NULL(clientHelloMessage);
 	PTF_ASSERT_EQUAL(handshakeLayer->getRecordType(), pcpp::SSL_HANDSHAKE, enum);
 	PTF_ASSERT_EQUAL(handshakeLayer->getRecordVersion().asEnum(), pcpp::SSLVersion::TLS1_0, enum);
 	PTF_ASSERT_EQUAL(clientHelloMessage->getHandshakeType(), pcpp::SSL_CLIENT_HELLO, enum);
 	PTF_ASSERT_EQUAL(clientHelloMessage->getHandshakeVersion().asEnum(), pcpp::SSLVersion::TLS1_2, enum);
 	uint8_t* random = clientHelloMessage->getClientHelloHeader()->random;
 	PTF_ASSERT_EQUAL(random[0], 0x3e, hex);
 	PTF_ASSERT_EQUAL(random[8], 0x78, hex);
 	PTF_ASSERT_EQUAL(random[27], 0xe5, hex);
 	PTF_ASSERT_EQUAL(clientHelloMessage->getSessionIDLength(), 0, u8);
 	PTF_ASSERT_NULL(clientHelloMessage->getSessionID());
 	PTF_ASSERT_EQUAL(clientHelloMessage->getCipherSuiteCount(), 11, int);
 
 	uint16_t cipherSuiteIDs[11] = { 0xc02b, 0xc02f, 0xc00a, 0xc009, 0xc013, 0xc014, 0x0033, 0x0039, 0x002f, 0x0035, 0x000a };
 	std::string cipherSuiteNames[11] = {
 			"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
 			"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
 			"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
 			"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
 			"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
 			"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
 			"TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
 			"TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
 			"TLS_RSA_WITH_AES_128_CBC_SHA",
 			"TLS_RSA_WITH_AES_256_CBC_SHA",
 			"TLS_RSA_WITH_3DES_EDE_CBC_SHA"
 			};
 	pcpp::SSLKeyExchangeAlgorithm cipherSuiteKey[11] = {
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_ECDHE,
 			pcpp::SSL_KEYX_DHE,
 			pcpp::SSL_KEYX_DHE,
 			pcpp::SSL_KEYX_RSA,
 			pcpp::SSL_KEYX_RSA,
 			pcpp::SSL_KEYX_RSA
 	};
 
 	pcpp::SSLAuthenticationAlgorithm cipherSuiteAuth[11] = {
 			pcpp::SSL_AUTH_ECDSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_ECDSA,
 			pcpp::SSL_AUTH_ECDSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA,
 			pcpp::SSL_AUTH_RSA
 	};
 
 	pcpp::SSLSymetricEncryptionAlgorithm cipherSuiteSym[11] = {
 			pcpp::SSL_SYM_AES_128_GCM,
 			pcpp::SSL_SYM_AES_128_GCM,
 			pcpp::SSL_SYM_AES_256_CBC,
 			pcpp::SSL_SYM_AES_128_CBC,
 			pcpp::SSL_SYM_AES_128_CBC,
 			pcpp::SSL_SYM_AES_256_CBC,
 			pcpp::SSL_SYM_AES_128_CBC,
 			pcpp::SSL_SYM_AES_256_CBC,
 			pcpp::SSL_SYM_AES_128_CBC,
 			pcpp::SSL_SYM_AES_256_CBC,
 			pcpp::SSL_SYM_3DES_EDE_CBC
 	};
 
 	pcpp::SSLHashingAlgorithm cipherSuiteHash[11] = {
 			pcpp::SSL_HASH_SHA256,
 			pcpp::SSL_HASH_SHA256,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA,
 			pcpp::SSL_HASH_SHA
 	};
 
 	PTF_PRINT_VERBOSE("Iterating over cipher suites");
 	for (int i = 0; i < clientHelloMessage->getCipherSuiteCount(); i++)
 	{
 		PTF_PRINT_VERBOSE("Iteration %d", i);
 		pcpp::SSLCipherSuite* curCipherSuite = clientHelloMessage->getCipherSuite(i);
 		PTF_ASSERT_NOT_NULL(curCipherSuite);
 		PTF_ASSERT_EQUAL(curCipherSuite->asString(), cipherSuiteNames[i], string);
 		PTF_ASSERT_EQUAL(curCipherSuite->getID(), cipherSuiteIDs[i], u16);
 		PTF_ASSERT_EQUAL(curCipherSuite->getKeyExchangeAlg(), cipherSuiteKey[i], enum);
 		PTF_ASSERT_EQUAL(curCipherSuite->getAuthAlg(), cipherSuiteAuth[i], enum);
 		PTF_ASSERT_EQUAL(curCipherSuite->getSymKeyAlg(), cipherSuiteSym[i], enum);
 		PTF_ASSERT_EQUAL(curCipherSuite->getMACAlg(), cipherSuiteHash[i], enum);
 	}
 
 	PTF_ASSERT_EQUAL(clientHelloMessage->getCompressionMethodsValue(), 0, u8);
 	PTF_ASSERT_EQUAL(handshakeLayer->getHeaderLen(), 188, size);
 
 	int extCount = clientHelloMessage->getExtensionCount();
 	PTF_ASSERT_EQUAL(extCount, 9, int);
 	PTF_ASSERT_EQUAL(clientHelloMessage->getExtensionsLenth(), 116, u16);
 
 	pcpp::SSLExtension* ext = clientHelloMessage->getExtension(0);
 	PTF_ASSERT_EQUAL(ext->getType(), pcpp::SSL_EXT_SERVER_NAME, enum);
 	pcpp::SSLServerNameIndicationExtension* serverNameExt = clientHelloMessage->getExtensionOfType<pcpp::SSLServerNameIndicationExtension>();
 	PTF_ASSERT_NOT_NULL(serverNameExt);
 	PTF_ASSERT_EQUAL(serverNameExt->getHostName(), "www.google.com", string);
 
-	pcpp::SSLExtensionType extTypes[9] = { pcpp::SSL_EXT_SERVER_NAME, pcpp::SSL_EXT_RENEGOTIATION_INFO, pcpp::SSL_EXT_ELLIPTIC_CURVES, pcpp::SSL_EXT_EC_POINT_FORMATS,
+	pcpp::TLSECPointFormatExtension* ecPointFormatExt = clientHelloMessage->getExtensionOfType<pcpp::TLSECPointFormatExtension>();
+	PTF_ASSERT_NOT_NULL(ecPointFormatExt);
+	std::vector<uint8_t> ecPointFormatList = ecPointFormatExt->getECPointFormatList();
+	PTF_ASSERT_EQUAL(ecPointFormatList.size(), 1, size);
+	PTF_ASSERT_EQUAL(ecPointFormatList.at(0), 0, u8);
+
+	pcpp::TLSSupportedGroupsExtension* supportedGroupsExt = clientHelloMessage->getExtensionOfType<pcpp::TLSSupportedGroupsExtension>();
+	PTF_ASSERT_NOT_NULL(supportedGroupsExt);
+	std::vector<uint16_t> supportedGroups = supportedGroupsExt->getSupportedGroups();
+	PTF_ASSERT_EQUAL(supportedGroups.size(), 3, size);
+	PTF_ASSERT_EQUAL(supportedGroups.at(0), 23, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(1), 24, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(2), 25, u16);
+
+	pcpp::SSLExtensionType extTypes[9] = { pcpp::SSL_EXT_SERVER_NAME, pcpp::SSL_EXT_RENEGOTIATION_INFO, pcpp::SSL_EXT_SUPPORTED_GROUPS, pcpp::SSL_EXT_EC_POINT_FORMATS,
 			pcpp::SSL_EXT_SESSIONTICKET_TLS, pcpp::SSL_EXT_Unknown, pcpp::SSL_EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION, pcpp::SSL_EXT_STATUS_REQUEST,
 			pcpp::SSL_EXT_SIGNATURE_ALGORITHMS };
 
 	uint16_t extLength[9] = { 19, 1, 8, 2, 0, 0, 23, 5, 22 };
 
 	PTF_PRINT_VERBOSE("Iterating over extensions");
 	for (int i = 0; i < extCount; i++)
 	{
 		PTF_PRINT_VERBOSE("Iteration %d", i);
 		pcpp::SSLExtension* curExt = clientHelloMessage->getExtension(i);
 		PTF_ASSERT_EQUAL(curExt->getType(), extTypes[i], enum);
 		PTF_ASSERT_EQUAL(curExt->getLength(), extLength[i], u16);
 		PTF_ASSERT_TRUE(clientHelloMessage->getExtensionOfType(extTypes[i]) == curExt);
 	}
 } // SSLClientHelloParsingTest
@@ -224,69 +238,74 @@ PTF_TEST_CASE(SSLAlertParsingTest)
 /**
  * Testing: server-hello, change-cipher-spec, hello-request
  */
 PTF_TEST_CASE(SSLMultipleRecordParsingTest)
 {
 	timeval time;
 	gettimeofday(&time, NULL);
 	READ_FILE_AND_CREATE_PACKET(1, "PacketExamples/SSL-MultipleRecords1.dat");
 
 	pcpp::Packet multipleRecordsPacket(&rawPacket1);
 
 	PTF_ASSERT_TRUE(multipleRecordsPacket.isPacketOfType(pcpp::SSL));
 	pcpp::SSLHandshakeLayer* handshakeLayer = multipleRecordsPacket.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	PTF_ASSERT_EQUAL(handshakeLayer->getHandshakeMessagesCount(), 1, size);
 	pcpp::SSLServerHelloMessage* serverHelloMessage = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLServerHelloMessage>();
 	PTF_ASSERT_NOT_NULL(serverHelloMessage);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getSessionIDLength(), 32, u8);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getSessionID()[0], 0xbf, hex);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getSessionID()[31], 0x44, hex);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getCipherSuite()->asString(), "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", string);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getCipherSuite()->getSymKeyAlg(), pcpp::SSL_SYM_AES_128_GCM, enum);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getExtensionsLenth(), 20, u16);
 	PTF_ASSERT_EQUAL(serverHelloMessage->getExtensionCount(), 3, int);
 	uint16_t extensionsLength[3] = { 1, 5, 2 };
 	uint16_t totalExtensionsLength[3] = { 5, 9, 6 };
 	pcpp::SSLExtensionType extensionTypes[3] = { pcpp::SSL_EXT_RENEGOTIATION_INFO, pcpp::SSL_EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION, pcpp::SSL_EXT_EC_POINT_FORMATS };
 	uint8_t extensionDataFirstByte[3] = { 0, 0, 1 };
 	PTF_PRINT_VERBOSE("iterating over SSL extensions");
 	for (int i = 0; i < 3; i++)
 	{
 		PTF_PRINT_VERBOSE("Iteration #%d", i);
 		pcpp::SSLExtension* curExt = serverHelloMessage->getExtension(i);
 		PTF_ASSERT_EQUAL(curExt->getLength(), extensionsLength[i], u16);
 		PTF_ASSERT_EQUAL(curExt->getTotalLength(), totalExtensionsLength[i], u16);
 		PTF_ASSERT_EQUAL(curExt->getType(), extensionTypes[i], enum);
 		PTF_ASSERT_EQUAL(curExt->getData()[0], extensionDataFirstByte[i], u8);
 	}
+	pcpp::TLSECPointFormatExtension* ecPointFormatExt = serverHelloMessage->getExtensionOfType<pcpp::TLSECPointFormatExtension>();
+	PTF_ASSERT_NOT_NULL(ecPointFormatExt);
+	std::vector<uint8_t> ecPointFormatList = ecPointFormatExt->getECPointFormatList();
+	PTF_ASSERT_EQUAL(ecPointFormatList.size(), 1, size);
+	PTF_ASSERT_EQUAL(ecPointFormatList.at(0), 0, u8);
 
 	pcpp::SSLChangeCipherSpecLayer* ccsLayer = multipleRecordsPacket.getLayerOfType<pcpp::SSLChangeCipherSpecLayer>();
 	PTF_ASSERT_NOT_NULL(ccsLayer);
 	PTF_ASSERT_EQUAL(ccsLayer->getRecordVersion().asEnum(), pcpp::SSLVersion::TLS1_2, enum);
 	PTF_ASSERT_EQUAL(ccsLayer->getRecordType(), pcpp::SSL_CHANGE_CIPHER_SPEC, enum);
 	PTF_ASSERT_EQUAL(ccsLayer->getHeaderLen(), 6, size);
 
 	handshakeLayer = multipleRecordsPacket.getNextLayerOfType<pcpp::SSLHandshakeLayer>(handshakeLayer);
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	PTF_ASSERT_EQUAL(handshakeLayer->getHandshakeMessagesCount(), 3, size);
 	pcpp::SSLHelloRequestMessage* helloRequest = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLHelloRequestMessage>();
 	PTF_ASSERT_NOT_NULL(helloRequest);
 	PTF_ASSERT_EQUAL(helloRequest->getHandshakeType(), pcpp::SSL_HELLO_REQUEST, enum);
 	PTF_ASSERT_EQUAL(helloRequest->getMessageLength(), 4, size);
 	pcpp::SSLHelloRequestMessage* helloRequest2 = handshakeLayer->getNextHandshakeMessageOfType<pcpp::SSLHelloRequestMessage>(helloRequest);
 	PTF_ASSERT_NOT_NULL(helloRequest2);
 	PTF_ASSERT_TRUE(helloRequest2 != helloRequest);
 	PTF_ASSERT_EQUAL(helloRequest2->getHandshakeType(), pcpp::SSL_HELLO_REQUEST, enum);
 	PTF_ASSERT_EQUAL(helloRequest2->getMessageLength(), 4, size);
 	helloRequest2 = handshakeLayer->getNextHandshakeMessageOfType<pcpp::SSLHelloRequestMessage>(helloRequest2);
 	PTF_ASSERT_NULL(helloRequest2);
 	PTF_ASSERT_NOT_NULL(handshakeLayer->getHandshakeMessageAt(2));
 	PTF_ASSERT_EQUAL(handshakeLayer->getHandshakeMessageAt(2)->getHandshakeType(), pcpp::SSL_HANDSHAKE_UNKNOWN, enum);
 	PTF_ASSERT_EQUAL(handshakeLayer->getHandshakeMessageAt(2)->getMessageLength(), 32, size);
 } // SSLMultipleRecordParsingTest
 
 
 
 /**
  * Testing: client-key-exchange
  */
@@ -505,110 +524,128 @@ PTF_TEST_CASE(SSLMalformedPacketParsing)
 PTF_TEST_CASE(TLS1_3ParsingTest)
 {
 	timeval time;
 	gettimeofday(&time, NULL);
 
 	READ_FILE_AND_CREATE_PACKET(1, "PacketExamples/tls1_3_client_hello1.dat");
 	READ_FILE_AND_CREATE_PACKET(2, "PacketExamples/tls1_3_client_hello2.dat");
 
 	pcpp::Packet tls13ClientHello1(&rawPacket1);
 	pcpp::Packet tls13ClientHello2(&rawPacket2);
 
 	uint16_t cipherSuiteIDs[3] = { 0x1302, 0x1303, 0x1301 };
 	std::string cipherSuiteNames[3] = 
 	{
 		"TLS_AES_256_GCM_SHA384",
 		"TLS_CHACHA20_POLY1305_SHA256",
 		"TLS_AES_128_GCM_SHA256"
 	};
 	pcpp::SSLSymetricEncryptionAlgorithm cipherSuiteSym[3] = 
 	{
 		pcpp::SSL_SYM_AES_256_GCM,
 		pcpp::SSL_SYM_CHACHA20_POLY1305,
 		pcpp::SSL_SYM_AES_128_GCM
 	};
 
 	pcpp::SSLHashingAlgorithm cipherSuiteHash[3] = 
 	{
 		pcpp::SSL_HASH_SHA384,
 		pcpp::SSL_HASH_SHA256,
 		pcpp::SSL_HASH_SHA256
 	};
 
 	pcpp::SSLHandshakeLayer* handshakeLayer = tls13ClientHello1.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	pcpp::SSLClientHelloMessage* clientHelloMsg = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLClientHelloMessage>();
 	PTF_ASSERT_NOT_NULL(clientHelloMsg);
 	PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuiteCount(), 4, int);
 	for (int i = 0; i < 3; i++)
 	{
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->asString(), cipherSuiteNames[i], string);
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->getID(), cipherSuiteIDs[i], u16);
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->getSymKeyAlg(), cipherSuiteSym[i], enum);
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->getMACAlg(), cipherSuiteHash[i], enum);
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->getKeyExchangeAlg(), pcpp::SSL_KEYX_NULL, enum);
 		PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(i)->getAuthAlg(), pcpp::SSL_AUTH_NULL, enum);
 	}
 
 	pcpp::SSLSupportedVersionsExtension* supportedVersionsExt = clientHelloMsg->getExtensionOfType<pcpp::SSLSupportedVersionsExtension>();
 	PTF_ASSERT_NOT_NULL(supportedVersionsExt);
 	std::vector<pcpp::SSLVersion> versionVec = supportedVersionsExt->getSupportedVersions();
 	PTF_ASSERT_EQUAL(versionVec.size(), 3, size);
 	PTF_ASSERT_EQUAL(versionVec[0].asEnum(), pcpp::SSLVersion::TLS1_3_D28, enum);
 	PTF_ASSERT_EQUAL(versionVec[1].asEnum(), pcpp::SSLVersion::TLS1_3_D27, enum);
 	PTF_ASSERT_EQUAL(versionVec[2].asEnum(), pcpp::SSLVersion::TLS1_3_D26, enum);
 	PTF_ASSERT_EQUAL(versionVec[0].asEnum(true), pcpp::SSLVersion::TLS1_3, enum);
 
+	pcpp::TLSECPointFormatExtension* ecPointFormatExt = clientHelloMsg->getExtensionOfType<pcpp::TLSECPointFormatExtension>();
+	PTF_ASSERT_NOT_NULL(ecPointFormatExt);
+	std::vector<uint8_t> ecPointFormatList = ecPointFormatExt->getECPointFormatList();
+	PTF_ASSERT_EQUAL(ecPointFormatList.size(), 3, size);
+	PTF_ASSERT_EQUAL(ecPointFormatList.at(0), 0, u8);
+	PTF_ASSERT_EQUAL(ecPointFormatList.at(1), 1, u8);
+	PTF_ASSERT_EQUAL(ecPointFormatList.at(2), 2, u8);
+
+	pcpp::TLSSupportedGroupsExtension* supportedGroupsExt = clientHelloMsg->getExtensionOfType<pcpp::TLSSupportedGroupsExtension>();
+	PTF_ASSERT_NOT_NULL(supportedGroupsExt);
+	std::vector<uint16_t> supportedGroups = supportedGroupsExt->getSupportedGroups();
+	PTF_ASSERT_EQUAL(supportedGroups.size(), 5, size);
+	PTF_ASSERT_EQUAL(supportedGroups.at(0), 29, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(1), 23, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(2), 30, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(3), 25, u16);
+	PTF_ASSERT_EQUAL(supportedGroups.at(4), 24, u16);
+
 
 	handshakeLayer = tls13ClientHello2.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	clientHelloMsg = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLClientHelloMessage>();
 	PTF_ASSERT_NOT_NULL(clientHelloMsg);
 	PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuiteCount(), 18, int);
 	PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(0)->asString(), cipherSuiteNames[2], string);
 	PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(1)->asString(), cipherSuiteNames[1], string);
 	PTF_ASSERT_EQUAL(clientHelloMsg->getCipherSuite(2)->asString(), cipherSuiteNames[0], string);
 
 	supportedVersionsExt = clientHelloMsg->getExtensionOfType<pcpp::SSLSupportedVersionsExtension>();
 	PTF_ASSERT_NOT_NULL(supportedVersionsExt);
 	versionVec.clear();
 	versionVec = supportedVersionsExt->getSupportedVersions();
 	PTF_ASSERT_EQUAL(versionVec.size(), 2, size);
 	PTF_ASSERT_EQUAL(versionVec[0].asEnum(), pcpp::SSLVersion::TLS1_3, enum);
 	PTF_ASSERT_EQUAL(versionVec[1].asEnum(), pcpp::SSLVersion::TLS1_2, enum);
 
 
 	READ_FILE_AND_CREATE_PACKET(3, "PacketExamples/tls1_3_server_hello1.dat");
 	READ_FILE_AND_CREATE_PACKET(4, "PacketExamples/tls1_3_server_hello2.dat");
 
 	pcpp::Packet tls13ServerHello1(&rawPacket3);
 	pcpp::Packet tls13ServerHello2(&rawPacket4);
 
 	handshakeLayer = tls13ServerHello1.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	pcpp::SSLServerHelloMessage* serverHelloMsg = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLServerHelloMessage>();
 	PTF_ASSERT_NOT_NULL(serverHelloMsg);
 	PTF_ASSERT_EQUAL(serverHelloMsg->getCipherSuite()->asString(), cipherSuiteNames[0], string);
 
 	supportedVersionsExt = serverHelloMsg->getExtensionOfType<pcpp::SSLSupportedVersionsExtension>();
 	PTF_ASSERT_NOT_NULL(supportedVersionsExt);
 	versionVec.clear();
 	versionVec = supportedVersionsExt->getSupportedVersions();
 	PTF_ASSERT_EQUAL(versionVec.size(), 1, size);
 	PTF_ASSERT_EQUAL(versionVec[0].asEnum(), pcpp::SSLVersion::TLS1_3_D28, enum);
 	PTF_ASSERT_EQUAL(serverHelloMsg->getHandshakeVersion().asEnum(true), pcpp::SSLVersion::TLS1_3, enum);
 
 
 	handshakeLayer = tls13ServerHello2.getLayerOfType<pcpp::SSLHandshakeLayer>();
 	PTF_ASSERT_NOT_NULL(handshakeLayer);
 	serverHelloMsg = handshakeLayer->getHandshakeMessageOfType<pcpp::SSLServerHelloMessage>();
 	PTF_ASSERT_NOT_NULL(serverHelloMsg);
 	PTF_ASSERT_EQUAL(serverHelloMsg->getCipherSuite()->asString(), cipherSuiteNames[2], string);
 
 	supportedVersionsExt = serverHelloMsg->getExtensionOfType<pcpp::SSLSupportedVersionsExtension>();
 	PTF_ASSERT_NOT_NULL(supportedVersionsExt);
 	versionVec.clear();
 	versionVec = supportedVersionsExt->getSupportedVersions();
 	PTF_ASSERT_EQUAL(versionVec.size(), 1, size);
 	PTF_ASSERT_EQUAL(versionVec[0].asEnum(), pcpp::SSLVersion::TLS1_3, enum);
 	PTF_ASSERT_EQUAL(serverHelloMsg->getHandshakeVersion().asEnum(true), pcpp::SSLVersion::TLS1_3, enum);
 } // TLS1_3ParsingTest
