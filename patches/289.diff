commit edf40148545038d07a394082caa1b9155941f88f
Author: Dave Arnold <darnold@adobe.com>
Date:   Thu Dec 15 21:56:44 2016 +0100

    [cff] Implement CFF2 support (2/2).
    
    The font variation code.  All parts dependent on the GX code in the
    `truetype' module are guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
    In other words, you can still compile the `cff' module without
    defining TT_CONFIG_OPTION_GX_VAR_SUPPORT (which brings you CFF2
    support without font variation).
    
    * src/cff/cf2font.c (cf2_font_setup): Add support for font
    variation.
    * src/cff/cf2font.h (CF2_Font): Add fields for variation data.
    
    * src/cff/cf2ft.c (cf2_free_instance): Free blend data.
    (cf2_getVStore, cf2_getNormalizedVector): New functions.
    * src/cff/cf2ft.h: Updated.
    
    * src/cff/cf2intrp.c: Include `cffload.h'.
    (cf2_cmdRESERVED_15, cf2_cmdRESERVED_16): Replace with...
    (cf2_cmdVSINDEX, cf2_cmdBLEND): ... this new enum values.
    (cf2_doBlend): New function.
    (cf2_interpT2CharString): Handle `vsindex' and `blend' opcodes.
    
    * src/cff/cffload.c (FT_fdot14ToFixed): New macro.
    (cff_vstore_done, cff_vstore_load): New functions.
    (cff_blend_clear, cff_blend_doBlend, cff_blend_build_vector,
    cff_blend_check_vector): New functions.
    (cff_load_private_dict): Add arguments for blend vector.
    Handle blend data.
    (cff_subfont_load, cff_subfont_done): Updated.
    (cff_font_load): Handle CFF2 variation store data.
    (cff_font_done): Updated.
    * src/cff/cffload.h: Include `cffparse.h'.
    Updated.
    
    * src/cff/cffobjs.c (cff_face_done): Updated.
    
    * src/cff/cffparse.c: Include `cffload.h'.
    (cff_parse_num): Handle internal value 255.
    (cff_parse_vsindex, cff_parse_blend): New functions.
    (CFF_FIELD_BLEND): New macro.
    (cff_parser_run): Updated.
    * src/cff/cffparse.h (cff_kind_blend): New enum value.
    
    * src/cff/cfftoken.h: Handle `vstore', `vsindex', and `blend'
    dictionary values.
    
    * src/cff/cfftypes.h (CFF_VarData, CFF_AxisCoords, CFF_VarRegion,
    CFF_VStore, CFF_Blend): New structures.
    (CFF_FontRecDict): Add `vstore_offset' field.
    (CFF_Private): Add `vsindex' field.
    (CFF_SubFont): Add fields for blend data.
    (CFF_Font): Add `vstore' field.
    
    * src/truetype/ttgxvar.c (TT_Get_MM_Var): `CFF2' is equal to `gvar',
    since glyph variation data is directly embedded.
    (TT_Set_MM_Blend): Don't load `gvar' table for CFF2 fonts.

diff --git a/ChangeLog b/ChangeLog
index c37cde2db..976595f4f 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,1530 +1,1590 @@
+2016-12-15  Dave Arnold  <darnold@adobe.com>
+	    Werner Lemberg  <wl@gnu.org>
+
+	[cff] Implement CFF2 support (2/2).
+
+	The font variation code.  All parts dependent on the GX code in the
+	`truetype' module are guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT. 
+	In other words, you can still compile the `cff' module without
+	defining TT_CONFIG_OPTION_GX_VAR_SUPPORT (which brings you CFF2
+	support without font variation).
+
+	* src/cff/cf2font.c (cf2_font_setup): Add support for font
+	variation.
+	* src/cff/cf2font.h (CF2_Font): Add fields for variation data.
+
+	* src/cff/cf2ft.c (cf2_free_instance): Free blend data.
+	(cf2_getVStore, cf2_getNormalizedVector): New functions.
+	* src/cff/cf2ft.h: Updated.
+
+	* src/cff/cf2intrp.c: Include `cffload.h'.
+	(cf2_cmdRESERVED_15, cf2_cmdRESERVED_16): Replace with...
+	(cf2_cmdVSINDEX, cf2_cmdBLEND): ... this new enum values.
+	(cf2_doBlend): New function.
+	(cf2_interpT2CharString): Handle `vsindex' and `blend' opcodes.
+
+	* src/cff/cffload.c (FT_fdot14ToFixed): New macro.
+	(cff_vstore_done, cff_vstore_load): New functions.
+	(cff_blend_clear, cff_blend_doBlend, cff_blend_build_vector,
+	cff_blend_check_vector): New functions.
+	(cff_load_private_dict): Add arguments for blend vector.
+	Handle blend data.
+	(cff_subfont_load, cff_subfont_done): Updated.
+	(cff_font_load): Handle CFF2 variation store data.
+	(cff_font_done): Updated.
+	* src/cff/cffload.h: Include `cffparse.h'.
+	Updated.
+
+	* src/cff/cffobjs.c (cff_face_done): Updated.
+
+	* src/cff/cffparse.c: Include `cffload.h'.
+	(cff_parse_num): Handle internal value 255.
+	(cff_parse_vsindex, cff_parse_blend): New functions.
+	(CFF_FIELD_BLEND): New macro.
+	(cff_parser_run): Updated.
+	* src/cff/cffparse.h (cff_kind_blend): New enum value.
+
+	* src/cff/cfftoken.h: Handle `vstore', `vsindex', and `blend'
+	dictionary values.
+
+	* src/cff/cfftypes.h (CFF_VarData, CFF_AxisCoords, CFF_VarRegion,
+	CFF_VStore, CFF_Blend): New structures.
+	(CFF_FontRecDict): Add `vstore_offset' field.
+	(CFF_Private): Add `vsindex' field.
+	(CFF_SubFont): Add fields for blend data.
+	(CFF_Font): Add `vstore' field.
+
+	* src/truetype/ttgxvar.c (TT_Get_MM_Var): `CFF2' is equal to `gvar',
+	since glyph variation data is directly embedded.
+	(TT_Set_MM_Blend): Don't load `gvar' table for CFF2 fonts.
+
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[cff] Implement CFF2 support (1/2).
 
 	This commit does not contain the blend code for font variation
 	support, which follows in another commit.
 
 	You should ignore whitespace while inspecting this commit.
 
 	* include/freetype/internal/tttypes.h (TT_Face): Add `isCFF2'
 	member.
 
 	* src/cff/cf2font.h (CF2_Font): Add `isCFF2' member.
 
 	* src/cff/cf2ft.c (cf2_decoder_parse_charstrings): Handle `isCFF2'
 	flag.
 	(cf2_getMaxstack): New function.
 	* src/cff/cf2ft.h: Updated.
 
 	* src/cff/cf2intrp.c (cf2_escRESERVED_38): New enum.
 	(cf2_interpT2CharString): Handle CFF2 differences.
 	Add tracing message for errors.
 
 	* src/cff/cffdrivr.c (cff_get_glyph_name, cff_get_name_index):
 	Update for CFF2.
 
 	* src/cff/cffload.c (FT_FIXED_ONE): New macro.
 	(cff_index_init, cff_index_load_offsets, cff_index_access_element,
 	cff_index_get_name, cff_ft_select_get, cff_load_private_dict,
 	cff_subfont_load, cff_font_load): Handle CFF2.
 	* src/cff/cffload.h: Updated.
 
 	* src/cff/cffobjs.c (cff_face_init): Handle CFF2.
 
 	* src/cff/cffparse.c (cff_parse_maxstack): New function.
 	(CFFCODE_TOPDICT, CFFCODE_PRIVATE): Removed
 	* src/cff/cffparse.h (CFF2_MAX_STACK, CFF2_DEFAULT_STACK): New
 	macros.
 	(CFF2_CODE_TOPDICT, CFF2_CODE_FONTDICT, CFF2_CODE_PRIVATE): New
 	macros.
 
 	* src/cff/cfftoken.h: Add fields for CFF2 dictionaries (but no blend
 	stuff).
 
 	* src/cff/cfftypes.h (CFF_Index): Add `hdr_size' field.
 	(CFF_FontRecDict): Add `maxstack' field.
 	(CFF_Private): Add `subfont' field.
 	(CFF_Font): Add `top_dict_length' and `cff2' fields.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Handle `CFF2' table.
 
 2016-12-15  Werner Lemberg  <wl@gnu.org>
 	    Dave Arnold  <darnold@adobe.com>
 
 	[truetype] Provide HVAR advance width variation as a service.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* src/truetype/ttdriver.c (tt_service_metrics_variations): Updated.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Prevent
 	double adjustment of advance width.
 
 	* src/sfnt/ttmtx.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(tt_face_get_metrics): Apply metrics variations.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Provide function to apply `HVAR' advance width variation.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* src/truetype/ttgxvar.c (tt_hadvance_adjust): New function.
 	* src/truetype/ttgxvar.h: Updated.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add `HVAR' table parsing.
 
 	Note that this is not complete yet; it only handles advance width
 	variation.
 
 	Activation of the code follows in another commit.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/ftmm.h (FT_Var_Named_Style): Add `psid' member.
 
 	* src/truetype/ttgxvar.h (GX_HVarData, GX_AxisCoords, GX_HVarRegion,
 	GX_HVStore, GX_WidthMap): New auxiliary structures for...
 	(GX_HVarTable): ... HVAR main structure.
 	(GX_BlendRec): Add data for HVAR loading.
 
 	* src/truetype/ttgxvar.c (FT_FIXED_ONE, FT_fdot14ToFixed,
 	FT_intToFixed, FT_fixedToInt): New macros.
 	(ft_var_load_hvar): New function.
 	(TT_Get_MM_Var): Updated.
 	(tt_done_blend): Deallocate HVAR data.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 
 	[cff] Extend number parsing.
 
 	The forthcoming CFF2 support needs a dynamic parsing limit.
 
 	* src/cff/cffparse.c (cff_parse_num, do_fixed, cff_parse_fixed,
 	cff_parse_fixed_scaled, cff_parse_fixed_dynamic): Add argument for
 	parser.
 	(cff_parse_font_matrix, cff_parse_font_bbox, cff_parse_private_dict,
 	cff_parse_multiple_master, cff_parse_cid_ros, cff_parser_run): Updated.
 
 	* src/cff/cffparse.h (cff_parse_num): Export locally.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 
 	[cff] Implement dynamic stack size for Adobe engine.
 
 	This also adds `cf2_stack_setReal' and `cf2_stack_pop', needed for
 	the forthcoming CFF2 support.
 
 	* src/cff/cf2stack.c (cf2_stack_init): Add argument for stack size.
 	(cf2_stack_free): Deallocate stack.
 	(cf2_stack_count, cf2_stack_pushInt, cf2_stack_pushFixed,
 	cf2_stack_popInt, cf2_stack_popFixed, cf2_stack_getReal,
 	cf2_stack_clear): Updated.
 	(cf2_stack_setReal, cf2_stack_pop): New functions.
 
 	* src/cff/cf2stack.h (CF2_Stack): Add `stackSize' member.
 	Update function declarations.
 
 	* src/cff/cf2intrp.c (cf2_interpT2CharString): Updated.
 
 	* src/cff/cffparse.c (cff_parser_init): Add parameter for stack
 	size; return error code.
 	(cff_parser_done): New function.
 	(cff_parser_run): Updated.
 
 	* src/cff/cffparse.h (CFF_Parser): Add `stackSize' member and make
 	`stack' a pointer.
 	Update function declarations.
 
 	* src/cff/cffload.c (cff_load_private_dict, cff_subfont_load):
 	Updated.
 
 2016-12-15  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[cff] Code shuffling.
 
 	* src/cff/cfftypes.h (CFF_Font): Add `library' and `base_offset'
 	fields.
 
 	* src/cff/cffload.c (cff_subfont_load): Change last argument to
 	`CFF_Font'
 	Split off parsing of private dictionary into...
 	(cff_load_private_dict): ...this new function.
 	(cff_font_load): Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, truetype] Add framework for Metrics Variations service.
 
 	No effect yet; service functions will be implemented later on.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/internal/services/svmetric.h: New file.
 
 	* include/freetype/internal/ftserv.h
 	(FT_SERVICE_METRICS_VARIATIONS_H): New macro.
 
 	* include/freetype/internal/tttypes.h (TT_Face): New field `var'.
 
 	* src/sfnt/sfobjs.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(sfnt_init_face): Initialize `face->var'.
 
 	* src/truetype/ttdriver.c: Include FT_SERVICE_METRICS_VARIATIONS_H.
 	(tt_service_metrics_variations): New service.
 	(tt_services): Updated.
 
 	* src/truetype/ttpic.h: Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Add Multiple Masters service.
 
 	The code simply uses the MM functions from the `truetype' module.
 
 	Everything is guarded with TT_CONFIG_OPTION_GX_VAR_SUPPORT.
 
 	* include/freetype/internal/tttypes.h (TT_Face): New field `mm'.
 
 	* src/cff/cffdrivr.c: Include FT_SERVICE_MULTIPLE_MASTERS_H.
 	(cff_set_mm_blend, cff_get_mm_blend, cff_get_mm_var,
 	cff_set_var_design, cff_get_var_design): New functions.
 	(cff_service_multi_masters): New service.
 	(cff_services): Updated.
 
 	* src/cff/cffload.c (cff_get_var_blend, cff_done_blend): New
 	functions.
 	* src/cff/cffload.h: Updated.
 
 	* src/cff/cffpic.h (CFF_SERVICE_MULTI_MASTERS_GET): New macro.
 
 	* src/sfnt/sfobjs.c: Include FT_SERVICE_MULTIPLE_MASTERS_H.
 	(sfnt_init_face): Initialize `face->mm'.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	Extend functionality of `ft_module_get_service'.
 
 	It can now differentiate between local and global searches.
 
 	* src/base/ftobjs.c (ft_module_get_service): Add `global' argument.
 	(FT_Get_TrueType_Engine_Type): Updated.
 
 	* src/cff/cffdrivr.c (cff_get_ps_name, cff_get_cmap_info): Updated.
 
 	* include/freetype/internal/ftobjs.h: Updated.
 	* include/freetype/internal/ftserv.h (FT_FACE_FIND_GLOBAL_SERVICE):
 	Updated.
 
 2016-12-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_get_var_blend): Fix compiler warning.
 
 2016-12-14  Dave Arnold  <darnold@adobe.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, cff] Minor preparations.
 
 	* include/freetype/tttags.h (TTAG_CFF2, TTAG_HVAR, TTAG_MVAR,
 	TTAG_VVAR): New SFNT table tags.
 
 	* src/cff/cf2fixed.h (CF2_FIXED_ONE, CF2_FIXED_EPSILON): Add cast.
 
 2016-12-10  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, type1] Add `get_var_blend' to MM service.
 
 	For internal use; we want to share code between the forthcoming CFF2
 	support and TrueType.
 
 	* include/freetype/internal/services/svmm.h (FT_Get_Var_Blend_Func):
 	New typedef.
 	(MultiMasters): Add `get_var_blend'.
 	(FT_Service_MultiMasters): Updated.
 
 	* src/truetype/ttgxvar.c (tt_get_var_blend): New function.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Updated.
 	* src/type1/t1driver.c (t1_service_multi_masters): Updated.
 
 2016-12-10  Werner Lemberg  <wl@gnu.org>
 
 	[truetype, type1] Add `done_blend' to MM service.
 
 	For internal use; we want to share code between the forthcoming CFF2
 	support and TrueType.
 
 	* include/freetype/internal/services/svmm.h (FT_Done_Blend_Func):
 	New typedef.
 	(MultiMasters): Add `done_blend'.
 	(FT_Service_MultiMasters): Updated.
 
 	* src/truetype/ttgxvar.c (tt_done_blend): Use `TT_Face' as argument.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/truetype/ttobjs.c (TT_Face_Done): Updated.
 
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Updated.
 	* src/type1/t1driver.c (t1_service_multi_masters): Updated.
 
 2016-12-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Revert change from 2016-12-08.
 
 	I missed the functionality of `ft_module_get_service', which makes
 	the change unnecessary.
 
 2016-12-08  Werner Lemberg  <wl@gnu.org>
 
 	Add framework to support services with 8 functions.
 
 	We will need this for CFF variation font support.
 
 	* include/freetype/internal/ftserv.h (FT_DEFINE_SERVICEDESCREC8):
 	New macro.
 
 2016-12-08  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Add `get_glyph_name' and `get_name_index' to SFNT interface.
 
 	CFF2 fonts will need access to those two functions.
 
 	* include/freetype/internal/sfnt.h: Include FT_SERVICE_GLYPH_DICT_H.
 	(SFNT_Interface): Add `get_glyph_name' and `get_name_index' members.
 	(FT_DEFINE_SFNT_INTERFACE): Updated.
 
 	* src/sfnt/sfdriver.c (sfnt_get_glyph_name, sfnt_get_name_index):
 	Fix signatures to exactly correspond to the glyph dict service
 	function typedefs.
 	(sfnt_interface): Updated.
 
 2016-12-06  Dave Arnold  <darnold@adobe.com>
 
 	Add `FT_Get_Var_Design_Coordinates' function.
 
 	Note that the low-level functions aren't implemented yet.
 
 	* include/freetype/ftmm.h: Declare.
 
 	* include/freetype/internal/services/svmm.h
 	(FT_Get_Var_Design_Func): New typedef.
 	(MultiMasters): New MM service function `get_var_design'.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 	Update all callers.
 
 	* src/base/ftmm.c (FT_Get_Var_Design_Coordinates): Implement.
 
 	* src/truetype/ttdriver.c: Updated.
 
 	* src/truetype/ttgxvar.c (TT_Get_Var_Design): New dummy function to
 	handle `get_var_design' service.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/type1/t1driver.c: Updated.
 
 	* src/type1/t1load.c (T1_Get_Var_Design): New dummp function to
 	handle `get_var_design' service.
 	* src/type1/t1load.h: Updated.
 
 2016-12-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Fix memory leak.
 
 	The `subrs' keyword might erroneously occur multiple times.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=231
 
 2016-12-01  Werner Lemberg  <wl@gnu.org>
 
 	[gzip] Improve building with external zlib (#49673).
 
 	Building FreeType with external zlib 1.2.8 makes msvc 14 stop with
 	the following error.
 
 	  ftgzip.c
 	  zlib-1.2.8\zlib.h(86): error C2061:
 	                         syntax error: identifier 'z_const'
 	  zlib-1.2.8\zlib.h(94): error C2054:
 	                         expected '(' to follow 'z_const'
 	  zlib-1.2.8\zlib.h(94): error C2085:
 	                         'msg': not in formal parameter list
 	  ...
 	  zlib-1.2.8\zlib.h(877): fatal error C1003:
 	                          error count exceeds 100; stopping compilation
 
 	The error happens because FreeType keeps an own copy of zlib-1.1.4
 	under `src/gzip'.  When building `src/gzip/ftgzip.c' with
 	FT_CONFIG_OPTION_SYSTEM_ZLIB defined, it uses
 
 	  #include <zlib.h>
 
 	which correctly finds an external `zlib.h', but `zlib.h' itself has
 	a line
 
 	  #include "zconf.h"
 
 	which makes Visual Studio 2015 find `src/gzip/zconf.h' while
 	compiling the files in `src/gzip'.
 
 	* src/gzip/zconf.h: Rename to...
 	* src/gzip/ftzconf.h: ... this.
 	* src/gzip/zlib.h, src/gzip/rules.mk (GZIP_DRV_SRCS): Updated.
 
 2016-12-01  Oleksandr Chekhovskyi  <oleksandr.chekhovskyi@gmail.com>
 
 	[autofit] Fix Emscripten crash (patch #9180).
 
 	Function calls through pointers must use a matching signature to
 	work on Emscripten, since such calls are dispatched through lookup
 	tables grouped by signature.
 
 	* src/autofit/aftypes.h (AF_WritingSystem_ApplyHintsFunc): Fix
 	typedef.
 
 2016-11-29  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Revert previous commit.  Already fixed with 6ca54c64.
 
 2016-11-29  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Avoid conditional jump on uninitialized value (#49711).
 
 	* src/smooth/ftgrays.c (gray_raster_render): Initialize `worker'.
 
 2016-11-27  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[autofit] Code shuffling.
 
 	Also improve some comments and remove unused code.
 
 	No functional change.
 
 	* src/autofit/afloader.c (af_loader_load_g): Merged with...
 	(af_loader_load_glyph): ...this function.
 	Split off emboldening code into...
 	(af_loader_embolden_glyph_in_slot): ... this function.
 
 2016-11-17  Werner Lemberg  <wl@gnu.org>
 
 	Better support of LLP64 systems with gcc (and clang).
 
 	* builds/unix/configure.raw: Call `AC_TYPE_LONG_LONG_INT'.
 
 	* builds/unix/ftconfig.in (FT_LONG64): Enable for LLP64 systems (and
 	suppress warnings) even without `FT_CONFIG_OPTION_FORCE_INT64'.
 
 2016-11-10  Werner Lemberg  <wl@gnu.org>
 
 	Fix `lcd_weights' array size.
 
 	* include/freetype/internal/ftobjs.h (FT_LibraryRec): Do it.
 
 	Reported by Nikolaus.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Fix tracing.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Improve FT_LOAD_BITMAP_METRICS_ONLY for `sbix' format.
 
 	It's unavoidable to call the PNG engine, but to get the metrics it
 	is sufficient to read the PNG image's header only.
 
 	* src/sfnt/pngshim.c (Load_SBit_Png): Add argument to control the
 	allocation of the glyph slot.
 	* src/sfnt/pngshim.h: Updated.
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_load_png,
 	tt_face_load_sbix_image, tt_face_load_sbit_image): Updated.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Speed up `sbix' lookup.
 
 	This also fixes a bug introduced in 2016-10-01 which prevents
 	display of embedded bitmap fonts that use the `sbix' format.
 
 	* src/sfnt/ttsbit.c (tt_face_load_sbit): Store `sbix' size and
 	offset also in `ebdt_size' and `ebdt_start', respectively.  This
 	makes the test for an embedded bitmap data table succeed for this
 	format.
 
 	(tt_face_load_strike_metrics) <TT_SBIT_TABLE_TYPE_SBIX>: Use
 	`ebdt_size' and `ebdt_start'
 	(tt_face_load_sbix_image): Ditto.
 
 2016-11-06  Seigo Nonaka  <nona@google.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	Introduce a way of quickly retrieving (embedded) bitmap metrics.
 
 	`FT_Load_Glyph' doesn't generate a bitmap for a non-bitmap glyph
 	until the user calls `FT_Render_Glyph'.  However, it always
 	allocates memory for bitmaps and copies or decodes the contents of a
 	bitmap glyph, which can be quite slow for PNG data.
 
 	* include/freetype/freetype.h (FT_LOAD_BITMAP_METRICS_ONLY): New
 	macro.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Unset FT_LOAD_RENDER if
 	FT_LOAD_BITMAP_METRICS_ONLY is used.
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_alloc_bitmap,
 	tt_sbit_decoder_load_bitmap): Add argument to control allocation of
 	the glyph slot.
 	(tt_sbit_decoder_load_image, tt_sbit_decoder_load_compound,
 	tt_face_load_sbit_image): Updated.
 
 	* src/pcf/pcfdrivr.c (PCF_Glyph_Load): Quickly exit if
 	`FT_LOAD_BITMAP_METRICS_ONLY' is set.
 
 	* src/pfr/pfrsbit.c, src/pfr/pfrsbit.h (pfr_slot_load_bitmap): Add
 	argument to control allocation of the glyph slot.
 	* src/pfr/pfrobjs (pfr_slot_load): Updated.
 
 	* src/winfonts/winfnt.c (FNT_Load_Glyph): Ditto.
 
 	* docs/CHANGES: Updated.
 
 2016-11-06  Werner Lemberg  <wl@gnu.org>
 
 	Synchronize with gnulib (#49448).
 
 	* include/freetype/config/ftconfig.h, builds/unix/ftconfig.in,
 	builds/vms/ftconfig.h (FT_TYPEOF): Update code to use definition in
 	current version of `intprops.h'.
 	Other minor synchronization to reduce code differences between the
 	three files.
 
 2016-11-03  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Clamp variation requests to valid range.
 
 	This is required by OpenType 1.8; it also avoids rounding surprises.
 
 	* src/truetype/ttgxvar.c (TT_Set_Var_Design): Clamp design coordinates
 	outside of the allowed range to always stay within the range instead
 	of producing an error.
 
 2016-10-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Remove clang warnings.
 
 	* src/truetype/ttinterp.h (TT_ExecContextRec): Using `FT_ULong' for
 	loop counter handling.
 
 	* src/truetype/ttinterp.c: Updated.
 	(Ins_SCANTYPE): Use signed constant.
 	(TT_RunIns): Ensure `num_twilight_points' is 16bit.
 
 2016-10-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix commit from 2014-11-24.
 
 	Problem reported by Hin-Tak Leung  <htl10@users.sourceforge.net>.
 
 	* src/truetype/ttpload.c (tt_face_load_hdmx): Fix file checking
 	logic.
 
 2016-10-26  Werner Lemberg  <wl@gnu.org>
 
 	Add `FT_Get_{MM,Var}_Blend_Coordinates' functions.
 
 	* include/freetype/ftmm.h: Declare.
 
 	* include/freetype/internal/services/svmm.h (FT_Get_MM_Blend_Func):
 	New typedef.
 	(MultiMasters): New MM service function `get_mm_blend'.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 	Update all callers.
 
 	* src/base/ftmm.c (FT_Get_MM_Blend_Coordinates,
 	FT_Get_Var_Blend_Coordinates): Implement.
 
 	* src/truetype/ttdriver.c: Updated.
 
 	* src/truetype/ttgxvar.c (TT_Get_MM_Blend): New function to handle
 	`get_mm_blend' service.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/type1/t1driver.c: Updated.
 
 	* src/type1/t1load.c (T1_Get_MM_Blend): New function to handle
 	`get_mm_blend' service.
 	* src/type1/t1load.h: Updated.
 
 	* docs/CHANGES: Document.
 
 2016-10-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/type1/t1load.c (parse_subrs): Fix limit check.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=81
 
 2016-10-25  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[cff] Correct cmap format reporting (#24819).
 
 	* src/cff/cffdrivr.c (cff_get_cmap_info): Throw an error on synthetic
 	charmap instead of guessing its format and language.
 
 2016-10-22  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix SCANTYPE instruction (#49394).
 
 	* src/truetype/ttinterp.c (Ins_SCANTYPE): Only use lower 16bits.
 
 2016-10-22  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Improve handling of invalid post 2.5 tables [#49393].
 
 	* src/sfnt/ttpost.c (load_format_25): We need at least a single
 	table entry.
 
 2016-10-14  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix handling of `cvar' table data.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=53
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Ignore invalid CVT
 	indices.
 
 2016-10-11  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix handling of invalid flex subrs.
 
 	Problem reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=52
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings)
 	<op_callothersubr>: Set `flex_state' after error checking.
 
 2016-10-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_done_blend): Fix deallocation.
 
 2016-10-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidload.c (cid_face_open): Properly propagate `error'.
 
 2016-10-08  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Fix parsing of subr offsets.
 
 	Bug introduced 2016-05-16.
 
 	* src/cid/cidparse.c (cid_parser_new): Fix off-by-one error.
 
 2016-10-01  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Disable bitmap strikes if we don't have a bitmap data table.
 
 	* src/sfnt/ttsbit.c (tt_face_load_sbit): Check whether we have
 	a bitmap data table.
 
 2016-10-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Remove impossibility.
 
 	* src/smooth/ftgrays.c (TWorker): Rearrange fields.
 	(gray_convert_glyph): Remove impossible condition and clean up.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[pcf] Enrich family name with foundry name and glyph width info.
 
 	This is a very old patch from openSuSE (from 2006, submitted to
 	FreeType in 2011) that I forgot to apply.
 
 	  https://build.opensuse.org/package/view_file/openSUSE:Factory/freetype2/freetype2-bitmap-foundry.patch
 
 	Prepend the foundry name plus a space to the family name.  There are
 	many fonts just called `Fixed' which look completely different, and
 	which have nothing to do with each other.  When selecting `Fixed' in
 	KDE or Gnome one gets results that appear rather random, the style
 	changes often if one changes the size and one cannot select some
 	fonts at all.
 
 	We also check whether we have `wide' characters; all put together,
 	we get family names like `Sony Fixed' or `Misc Fixed Wide'.
 
 	* src/pcf/pcfread.c (pcf_load_font): Implement it.
 
 	* docs/CHANGES: Document it.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Speed up.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Don't
 	check for embedded bitmaps if we have a non-default instance.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Disallow bitmap strokes for non-default instances.
 
 	Also speed up access of default instances if GX variations are
 	active.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add
 	`is_default_instance' member.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Initialize
 	`is_default_instance'.
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph,
 	load_truetype_glyph): Add test for default instance.
 	(TT_Load_Glyph): Load embedded bitmaps for default instance only.
 
 	* src/truetype/ttgxvar.c (TT_Set_MM_Blend): Compute
 	`is_default_instance'.
 
 2016-09-29  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Clean up `TT_Face' structure.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Remove unused
 	fields `horz_metrics' and `vert_metrics'.
 	Update documentation.
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Updated.
 
 2016-09-28  Werner Lemberg  <wl@gnu.org>
 
 	More FT_ZERO usage.
 
 	* src/gxvalid/gxvcommn.c (gxv_ClassTable_validate):
 	s/ft_memset/FT_MEM_ZERO/.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings):
 	s/ft_memset/FT_ARRAY_ZERO/.
 
 	* src/raster/ftraster.c (FT_ZERO): Define.
 	(ft_black_new): Use it.
 	* src/raster/ftrend1.c (ft_raster1_get_cbox):
 	s/FT_MEM_ZERO/FT_ZERO/.
 
 	* src/smooth/ftgrays.c (FT_ZERO): Define.
 	(gray_raster_new): Use it.
 	* src/smooth/ftsmooth.c (ft_smooth_get_cbox):
 	s/FT_MEM_ZERO/FT_ZERO/.
 
 2016-09-28  Werner Lemberg  <wl@gnu.org>
 
 	*/*: s/FT_MEM_ZERO/FT_ZERO/ where appropriate.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Trace number of executed opcodes.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Implement it.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Speed up `TT_Load_Glyph'.
 
 	This avoids additional calls to `tt_face_lookup_table' for the
 	`glyf' table, which can be expensive.
 
 	* include/freetype/internal/tttypes.h (TT_LoaderRec): Move
 	`glyf_offset' field to ...
 	(TT_FaceRec): ... this structure.
 	* src/truetype/ttgload.c (load_truetype_glyph): Updated.
 	(tt_loader_init): Move initialization of `glyf_offset' to ...
 	* src/truetype/ttpload.c (tt_face_load_loca): ... this function.
 
 2016-09-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Introduce dynamic limits for some bytecode opcodes.
 
 	This speeds up FreeType's handling of malformed fonts.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Set up limits for the number
 	of twilight points, the total number of negative jumps, and the
 	total number of loops in LOOPCALL opcodes.  The values are based on
 	the number of points and entries in the CVT table.
 	(Ins_JMPR): Test negative jump counter.
 	(Ins_LOOPCALL): Test loopcall counter.
 
 	* src/truetype/ttinterp.h (TT_ExecContext): Updated.
 
 	* docs/CHANGES: Updated.
 
 2016-09-25  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitize only last entry of `loca' table.
 
 	Without this patch, a loca sequence like `0 100000 0 100000 ...',
 	where value 100000 is larger than the `glyf' table size, makes
 	FreeType handle the whole `glyf' table as a single glyph again and
 	again, which is certainly invalid (and can be very slow, too).
 
 	* src/truetype/ttpload.c (tt_face_get_location): Implement.
 	Improve tracing messages.
 
 2016-09-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Fix typo.
 
 2016-09-24  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Tracing fixes.
 
 	* src/autofit/afmodule.c (af_autofitter_load_glyph): Call dumping
 	functions only if we actually do tracing.
 
 2016-09-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Reduce divisions in the line renderer.
 
 	We don't need some divisions if a line segments stays within a single
 	row or a single column of pixels.
 
 	* src/smooth/ftgrays.c (gray_render_line) [FT_LONG64]: Make divisions
 	conditional.
 
 2016-09-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_sweep): Remove check for empty table.
 
 2016-09-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Another tiny speed-up.
 
 	* src/smooth/ftgrays.c (gray_find_cell): Merge into...
 	(gray_record_cell): ... this function.
 
 2016-09-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_{find,set}_cell): Remove dubious code.
 
 2016-09-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Fix valgrind warning and reoptimize.
 
 	The algorithm calls `gray_set_cell' at the start of each new contour
 	or when the contours cross the cell boundaries. Double-checking for
 	that is wasteful.
 
 	* src/smooth/ftgrays.c (gray_set_cell): Remove check for a new cell.
 	(gray_convert_glyph): Remove initialization introduced by 44b172e88.
 
 2016-09-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix previous commit.
 
 	Problems reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40
 
 	We now map the strike index right before accessing the physical
 	data, not earlier.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Set `face->sbit_strike_map'
 	after creating the map so that...
 
 	* src/sfnt/ttsbit.c (tt_face_load_strike_metrics): ... this function
 	can be used before and after setting up `sbit_strike_map'.
 	(tt_face_set_sbit_strike): Revert change.
 	(tt_sbit_decoder_init, tt_face_load_sbix_image): Map strike index.
 
 	* src/truetype/ttdriver.c (tt_size_select): Revert change.
 
 2016-09-09  Werner Lemberg  <wl@gnu.org>
 
 	[ftfuzzer] Minor improvements.
 
 	* src/tools/ftfuzzer/ftfuzzer.cc (LLVMFuzzerTestOneInput): Ignore
 	invalid strikes.
 	Use better values for call to `FT_Set_Char_Size'.
 
 2016-09-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Don't provide (completely) broken strike data.
 
 	FreeType tries to sanitize strike header data; we now reject
 	completely broken ones.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): New
 	`sbit_strike_map' array pointer.
 
 	* src/base/ftobjs.c (FT_Match_Size): Reject matches where either
 	width or height would be zero.
 	Add tracing message in case of error.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Populate `sbit_strike_map',
 	only using (more or less) valid strike header data for
 	FT_Face's `available_sizes' array.
 	(sfnt_done_face): Updated.
 
 	* src/sfnt/ttsbit.c (tt_face_set_sbit_strike): Use
 	`sbit_strike_map'.
 	(tt_face_load_strike_metrics): Improve tracing.
 
 	* src/truetype/ttdriver.c (tt_size_select): Use `sbit_strike_map'.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.7 released.
 	=======================
 
 
 	Tag sources with `VER-2-7'.
 
 	* docs/VERSION.TXT: Add entry for version 2.7.
 
 	* README, Jamfile (RefDoc), builds/windows/vc2005/freetype.vcproj,
 	builds/windows/vc2005/index.html,
 	builds/windows/vc2008/freetype.vcproj,
 	builds/windows/vc2008/index.html,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.6.5/2.7/, s/265/27/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 7.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 18:6:12.
 	* CMakeLists.txt (VERSION_MINOR): Set to 7.
 	(VERSION_PATCH): Set to 0.
 
 	* docs/CHANGES: Updated.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c: Include `ttgxvar.h'.
 
 	This fixes the `multi' build.
 
 2016-09-08  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Another improvement to Armenian support.
 
 	Suggested by Hrant H Papazian <hpapazian@gmail.com>.
 
 	* src/autofit/afscript.h: Use better suited characters to derive
 	default stem widths.
 
 2016-09-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_hline): Microptimize.
 
 2016-09-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Operate in absolute bitmap coordinates.
 
 	Simpler bitmap addressing improves performance by 1.5%.
 
 	* src/smooth/ftgrays.c (gray_TWorker): Remove count fields.
 	(gray_dump_cells, gray_find_cell, gray_set_cell, gray_hline,
 	gray_sweep, gray_convert_glyph, gray_raster_render): Updated.
 
 2016-09-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Improve contour start (take 2).
 
 	* src/smooth/ftgrays.c (gray_move_to): Call `gray_set_cell' directly
 	instead of...
 	(gray_start_cell): ... this function, which is removed.
 	(gray_convert_glyph): Make initial y-coordinate invalid.
 
 2016-09-06  Werner Lemberg  <wl@gnu.org>
 
 	[type1] MM fonts support exactly zero named instances (#48748).
 
 	* src/type1/t1load.c (T1_Get_MM_Var): Set `num_namedstyles' to zero.
 
 2016-09-06  Jonathan Kew  <jfkthame@gmail.com>
 
 	[cff] Fix uninitialized memory.
 
 	Problem reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1270288
 
 	* src/cff/cf2interp.c (cf2_interpT2CharString): Initialize `storage'
 	array to handle a `get' opcode without a previous `put'.
 
 2016-09-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_move_to, gray_start_cell): Revert.
 
 2016-09-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Improve contour start.
 
 	* src/smooth/ftgrays.c (gray_move_to): Call `gray_set_cell' directly
 	instead of...
 	(gray_start_cell): ... this function, which is removed.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix memory initialization.
 
 	* src/cff/cf2stack.c (cf2_stack_init): Use `FT_NEW'.  The `Q'
 	variants of FreeType's memory allocation macros don't do zeroing.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Minor improvements.
 
 	* src/tools/ftrandom/ftrandom.c (_XOPEN_SOURCE): New macro, set to
 	500.
 
 	* src/tools/ftrandom/Makefile (CFLAGS): Split off include
 	directories to ...
 	(INCLUDES): ... this new variable.
 	(LDFLAGS): New variable.
 	(ftrandom.o, ftrandom): Updated.
 
 2016-09-05  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Improve Armenian support.
 
 	Thanks to Hrant H Papazian <hpapazian@gmail.com> for help.
 
 	* src/autofit/afblue.dat (AF_BLUE_STRING_ARMENIAN_*): Improve
 	selection of characters.
 
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 2016-09-04  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Improve Makefile.
 
 	It now supports both a normal build (`./configure && make') and a
 	development build (`make devel').
 
 	* src/tools/ftrandom/Makefile (VPATH): Set it so that
 	`libfreetype.a' gets searched in both `objs' (for the development
 	build) and `objs/.libs' (for a normal build which uses libtool).
 	(LIBS): Add missing libraries.
 	(ftrandom.o): New rule.
 	(ftrandom): Use automatic variables.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] More fixes for handling of GX deltas.
 
 	Problems reported by Bob Taylor <Bob.Taylor@monotype.com>.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Fix rough
 	sanity test for glyph variation array header size.
 	Always set stream position before reading packed x and y deltas.
 	Fix thinko w.r.t. `localpoints' array.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[ftrandom] Various fixes.
 
 	* src/tools/ftrandom/ftrandom.c (GOOD_FONTS_DIR): Provide better
 	default.
 	(error_fraction): Make it of type `double' to work as advertized â€“
 	this was completely broken.
 	Update all related code.
 	(error_count, fcnt): Make it unsigned to fix compiler warnings.
 	Update all related code.
 	(fontlist): Change `len' member to `long' to fix compiler warnings.
 	(FT_MoveTo, FT_LineTo, FT_ConicTo, FT_CubicTo, abort_test): Tag
 	unused variables.
 	(TestFace, FindFonts, copyfont, do_test): Fix compiler warnings.
 	(ExecuteTest): Ditto.
 	Call `FT_Done_FreeType'.
 	(getErrorCnt): Replace `ceil' with an ordinary cast to `unsigned
 	int'.
 	(usage): Improve output.
 	(main): Fix compiler warnings.
 
 	* src/tools/ftrandom/README: Updated.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[base] Avoid negative bitmap stroke dimensions (#48985).
 
 	* src/base/ftobjs.c (FT_Open_Face): Check whether negation was
 	actually successful.  For example, this can fail for value
 	-32768 if the type is `signed short'.  If there are problems,
 	disable the stroke.
 
 2016-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Avoid null pointer passed to FT_MEM_COPY (#48984).
 
 	* src/cff/cffload.c (cff_index_get_name): Check `byte_len'.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	[unix] Enable 64bit support in file system access (#48962).
 
 	* builds/unix/configure.raw: Call `AC_SYS_LARGEFILE'.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Avoid left shift of negative value (#48980).
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_load_bit_aligned): Use unsigned
 	constant.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/smooth/ftgrays.c (gray_hline): Fix clang compiler warnings.
 
 2016-09-02  Werner Lemberg  <wl@gnu.org>
 
 	Some preparations for the next release.
 
 	* include/freetype/config/ftoption.h
 	(TT_CONFIG_OPTION_SUBPIXEL_HINTING): Enable.
 
 	* docs/CHANGES: Updated.
 
 2016-09-01  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Simplify span rendering more.
 
 	It turns out that there is significant cost associated with `FT_Span'
 	creation and calls to `gray_render_span' because it happerns so
 	frequently. This removes these steps from our internal use but leaves
 	it alone for `FT_RASTER_FLAG_DIRECT" to preserve API. The speed gain
 	is about 5%.
 
 	* src/smooth/ftgrays.c (gray_render_span): Removed. The code is
 	migrated to...
 	(gray_hline): ... here.
 
 2016-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Streamline pixmap drawing a bit more.
 
 	Zero coverage is unlikely (1 out of 256) to warrant checking. This
 	gives 0.5% speed improvement in rendering simple glyphs.
 
 	* src/smooth/ftgrays.c (gray_hline, gray_render_span): Remove checks.
 
 2016-08-29  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Streamline pixmap drawing.
 
 	This gives 2% speed improvement in rendering simple glyphs.
 
 	* src/smooth/ftgrays.c (TPixmap): Reduced pixmap descriptor with a
 	pointer to its bottom-left and pitch to be used in...
 	(gray_TWorker): ... here.
 	(gray_render_span): Move pixmap flow check from here...
 	(gray_raster_render): .. to here.
 
 2016-08-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Reduce stack of band boundaries.
 
 	* src/smooth/ftgrays.c (gray_TBand): Removed.
 	(gray_convert_glyph): Updated to stack band boundaries concisely.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidload.c (cid_face_open): Improve handling of `SDBytes'.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Fix commit from 2016-05-16.
 
 	* src/cid/cidparse.c (cid_parser_new): Fix off-by-one errors.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Cache offset and size to bitmap data table.
 
 	This commit avoids `EBDT' and friends being looked up again and
 	again while loading a single embedded bitmap.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec)
 	[TT_CONFIG_OPTION_EMBEDDED_BITMAPS]: New fields `ebdt_start' and
 	`ebdt_size'.
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_init): Move table lookup to ...
 	(tt_face_load_sbit): ... this function; also store the table size
 	and offset.
 
 2016-08-26  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_raster_render): Minor tweaks.
 
 2016-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Fix heap buffer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=36
 
 	* src/type1/t1load.c (parse_charstrings): Reject fonts that don't
 	contain glyph names.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix previous commit (#48901).
 
 	* src/sfnt/ttcmap.c (tt_cmap4_char_map_binary): Thinkos.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Speed up handling of invalid format 4 cmaps.
 
 	* src/sfnt/ttcmap.c (tt_cmap4_next, tt_cmap4_char_map_binary): Add
 	tests for `num_glyph' from `tt_cmap4_char_map_linear'.
 
 2016-08-25  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/internal/ftdriver.h: Remove unused typedefs.
 
 2016-08-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Simplify span rendering.
 
 	This removes unnecessary complexity of span merging and buffering.
 	Instead, the spans are rendered as they come, speeding up the
 	rendering by about 5% as a result.
 
 	* src/smooth/ftgrays.c [FT_MAX_GRAY_SPANS]: Macro removed.
 	(gray_TWorker): Remove span buffer and related fields.
 	(gray_sweep, gray_hline): Updated.
 
 	* include/freetype/ftimage.h: Remove documentation note about
 	`FT_MAX_GRAY_SPANS', which was never in `ftoption.h' and is now gone.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix `MPS' instruction.
 
 	According to Greg Hitchcock, MPS in DWrite really returns the point
 	size.
 
 	* src/truetype/ttobjs.h (TT_SizeRec): Add `point_size' member.
 
 	* src/truetype/ttdriver.c (tt_size_request): Set `point_size'.
 
 	* src/truetype/ttinterp.h (TT_ExecContextRec): Add `pointSize'
 	member.
 
 	* src/truetype/ttinterp.c (TT_Load_Context): Updated.
 	(Ins_MPS): Fix instruction.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Optimize last commit.
 
 	* src/lzw/ftzopen.c (ft_lzwstate_get_code): Move check into
 	conditional clause.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Avoid invalid left shift.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1295366
 
 	* src/lzw/ftzopen.c (ft_lzwstate_get_code): Limit `num_bits'.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[lzw] Avoid buffer overrun.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1273283
 
 	* src/lzw/ftzopen.c (ft_lzwstate_refill): Ensure `buf_size' doesn't
 	underflow.
 
 2016-08-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix compiler warning.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Add cast.
 
 2016-08-13  Werner Lemberg  <wl@gnu.org>
 
 	[winfonts] Avoid zero bitmap width and height.
 
 	Reported as
 
 	  https://bugzilla.mozilla.org/show_bug.cgi?id=1272173
 
 	* src/winfonts/winfnt.c (FNT_Face_Init): Check zero pixel height.
 	(FNT_Load_Glyph): Check for zero pitch.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (Pop_Push_Count): Revert changes.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (TT_RunIns): Minor and formatting.
 
 2016-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttinterp.c (Pop_Push_Count): Fix some entries.
 
 2016-08-10  Peter Klotz  <Peter.Klotz@ith-icoserve.com>
 
 	* src/smooth/ftgrays.c (gray_hline): Fix uninitialized access.
 
 2016-08-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Use correct type for `italicAngle' field (#48732).
 
 	* src/sfnt/ttload.c (tt_face_load_post): Fix types.
 
 2016-08-06  Jon Spencer  <jon@jonspencer.ca>
 
 	[sfnt] Fix `FT_Get_Advance' for bitmap strikes.
 
 	`FT_Get_Advance' returns 0 for bitmap fonts.  It first gets the
 	advance value from the font table and then scales it by the
 	`font->size->metrics->x_scale' field.  But `FT_Select_Size' doesn't
 	set that value for bitmap fonts and the advance gets scaled to zero.
 
 	Taken from
 
 	  https://github.com/behdad/harfbuzz/issues/252
 
 	* src/sfnt/ttsbit.c (tt_face_load_strike_metrics)
 	<TT_SBIT_TABLE_TYPE_EBLC>: Set scale values.
 
 2016-08-06  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Fix GX variation handling of composites.
 
 	* src/truetype/ttgload.c (load_truetype_glyph)
 	[TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Check `ARGS_ARE_XY_VALUES' flag.
 
 2016-08-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Minor refactoring.
 
 	* src/smooth/ftgrays.c (gray_render_scanline, gray_render_line):
 	Updated.
 
 2016-07-29  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt, truetype] Don't abort on invalid `maxComponentDepth'.
 
 	Since 2016-05-16 we detect infinite recursion directly.
 
 	* src/sfnt/ttload.c (tt_face_load_maxp): Don't adjust
 	`maxComponentDepth'.
 	* src/truetype/ttgload.c (load_truetype_glyph): Don't abort if
 	`maxComponentDepth' is not valid.  Instead, simply adjust its value
 	and emit a tracing message.
 
 2016-07-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_metrics_scale_dim): Minor.
 
 	No functional change.
 
 2016-07-22  Hin-Tak Leung  <htl10@users.sourceforge.net>
 
 	[truetype] Record the end of IDEFs.
 
 	To match the logic in FDEF.  The value of the end is only used for
 	bound-checking in `Ins_JMPR', so it may not have been obvious that
 	it was not recorded.  Tested (as part of Font Validator 2.0) all the
 	fonts on Fedora and did not see any change.
 
 	* src/truetype/ttinterp.c (Ins_IDEF): Updated.
 
 2016-07-19  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitizer fix, second try.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Fix boundary
 	tests and use only one slot more.
 
 2016-07-19  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Sanitizer fix.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Increase array
 	to fix nested loops.
 
 2016-07-18  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Make GETDATA work only for GX fonts.
 
 	* src/truetype/ttinterp.c (opcode_name): Updated.
 	(Ins_GETDATA): Only define for `TT_CONFIG_OPTION_GX_VAR_SUPPORT'.
 	(TT_RunIns): Updated.
 
 2016-07-17  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add support for Apple's
 
 	  GETDATA[], opcode 0x92
 
 	bytecode instruction.  It always returns 17, and we have absolutely
 	no idea what it is good for...
 
 	* src/truetype/ttinterp.c (Pop_Push_Count, opcode_name): Updated.
 	(Ins_GETDATA): New function.
 	(TT_RunIns): Add it.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Add bytecode support for GX variation fonts.
 
 	This commit implements undocumented (but confirmed) stuff from
 	Apple's old bytecode engine.
 
 	  GETVARIATION[], opcode 0x91
 	    This opcode pushes normalized variation coordinates for all axes
 	    onto the stack (in 2.14 format).  Coordinate of first axis gets
 	    pushed first.
 
 	  GETINFO[], selector bit 3
 	    If GX variation support is enabled, bit 10 of the result is set
 	    to 1.
 
 	* src/truetype/ttinterp.c: Include FT_MULTIPLE_MASTERS_H.
 	(opcode_name) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Updated.
 	(Ins_GETINFO) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Handle selector
 	bit 3, checking support for variation glyph hinting.
 	(Ins_GETVARIATION) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: New function
 	to implement opcode 0x91.
 	(TT_RunIns) [TT_CONFIG_OPTION_GX_VAR_SUPPORT]: Handle opcode 0x91.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix GETINFO bytecode instruction.
 
 	* src/truetype/ttinterp.c (Ins_GETINFO): Fix return value for
 	stretching information.
 
 2016-07-16  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Make all glyphs in `Zycon' GX font work.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): Fix boundary
 	tests.
 
 2016-07-16  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix GX delta tracing.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Trace
 	relative point movements.
 
 2016-07-16  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] More fixes for GX.
 
 	This finally fixes the rendering of the cyclist and the lizard in
 	the `Zycon' font.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackedpoints): `first' point
 	index is always cumulative.
 
 	(tt_handle_deltas): Rename to...
 	(tt_interpolate_deltas): ... This.
 	Add new parameter for output point array.
 	Update caller.
 
 	(TT_Vary_Apply_Glyph_Deltas): Add `points_out' array; it now holds
 	the intermediate results of `tt_interpolate_deltas' that are to be
 	added to `outline->points'.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Thinko.
 
 	`max_pos' is always larger than `min_pos' so `FT_ABS' is not needed.
 
 	Reported by Alexei.
 
 2016-07-16  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	* src/truetype/ttinterp.c (Ins_MIRP): Fix copy-and-paste error.
 
 	Problem reported by Hin-Tak Leung.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Update and improve segment and edge tracing.
 
 	* src/autofit/afhints.c (af_glyph_hints_dump_segments): Trace
 	`delta' also.
 	Don't show first point of segment as a replacement for `pos'; this
 	is (a) misleading, since the difference to `pos' can be almost
 	arbitrarily large in corner cases, and (b) it is better to have all
 	segment data in font units instead of a single value given in output
 	space coordinates.
 	Improve layout.
 	(af_glyph_hints_dump_edges): Show px->units and units->px conversion
 	values for convenience.
 	Improve layout.
 
 2016-07-15  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] For edges, reject segments wider than 1px (#41334).
 
 	* src/autofit/afhints.h (AF_SegmentRec): New member `delta'.
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Compute
 	`delta'.
 	(af_latin_hints_compute_edges): Reject segments with a delta larger
 	than 0.5px.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/freetype.h (FT_IS_NAMED_INSTANCE): New macro.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix `face_index' value in `FT_Face' for named instances.
 
 	* src/sfnt/sfobjc.s (sfnt_init_face): Don't strip off higher 16bits.
 
 2016-07-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Fix tracing.
 
 2016-07-14  Behdad Esfahbod  <behdad@behdad.org>
 
 	[truetype] Fix gxvar delta interpolation.
 
 	The coordinates of the base font should be used for interpolation
 	purposes, NOT the current points (i.e., the result of accumulation
 	of previous deltas).
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Initialize
 	`points_org' before looping over all tuples.
 
 
 ----------------------------------------------------------------------------
diff --git a/src/cff/cf2font.c b/src/cff/cf2font.c
index 508b273c2..a86e3619b 100644
--- a/src/cff/cf2font.c
+++ b/src/cff/cf2font.c
@@ -1,514 +1,562 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cf2font.c                                                              */
 /*                                                                         */
 /*    Adobe's code for font instances (body).                              */
 /*                                                                         */
 /*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
 /*                                                                         */
 /*  This software, and all works of authorship, whether in source or       */
 /*  object code form as indicated by the copyright notice(s) included      */
 /*  herein (collectively, the "Work") is made available, and may only be   */
 /*  used, modified, and distributed under the FreeType Project License,    */
 /*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
 /*  FreeType Project License, each contributor to the Work hereby grants   */
 /*  to any individual or legal entity exercising permissions granted by    */
 /*  the FreeType Project License and this section (hereafter, "You" or     */
 /*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
 /*  royalty-free, irrevocable (except as stated in this section) patent    */
 /*  license to make, have made, use, offer to sell, sell, import, and      */
 /*  otherwise transfer the Work, where such license applies only to those  */
 /*  patent claims licensable by such contributor that are necessarily      */
 /*  infringed by their contribution(s) alone or by combination of their    */
 /*  contribution(s) with the Work to which such contribution(s) was        */
 /*  submitted.  If You institute patent litigation against any entity      */
 /*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
 /*  the Work or a contribution incorporated within the Work constitutes    */
 /*  direct or contributory patent infringement, then any patent licenses   */
 /*  granted to You under this License for that Work shall terminate as of  */
 /*  the date such litigation is filed.                                     */
 /*                                                                         */
 /*  By using, modifying, or distributing the Work you indicate that you    */
 /*  have read and understood the terms and conditions of the               */
 /*  FreeType Project License as well as those provided in this section,    */
 /*  and you accept them fully.                                             */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_CALC_H
 
 #include "cf2ft.h"
 
 #include "cf2glue.h"
 #include "cf2font.h"
 #include "cf2error.h"
 #include "cf2intrp.h"
 
 
   /* Compute a stem darkening amount in character space. */
   static void
   cf2_computeDarkening( CF2_Fixed   emRatio,
                         CF2_Fixed   ppem,
                         CF2_Fixed   stemWidth,
                         CF2_Fixed*  darkenAmount,
                         CF2_Fixed   boldenAmount,
                         FT_Bool     stemDarkened,
                         FT_Int*     darkenParams )
   {
     /*
      * Total darkening amount is computed in 1000 unit character space
      * using the modified 5 part curve as Adobe's Avalon rasterizer.
      * The darkening amount is smaller for thicker stems.
      * It becomes zero when the stem is thicker than 2.333 pixels.
      *
      * By default, we use
      *
      *   darkenAmount = 0.4 pixels   if scaledStem <= 0.5 pixels,
      *   darkenAmount = 0.275 pixels if 1 <= scaledStem <= 1.667 pixels,
      *   darkenAmount = 0 pixel      if scaledStem >= 2.333 pixels,
      *
      * and piecewise linear in-between:
      *
      *
      *   darkening
      *       ^
      *       |
      *       |      (x1,y1)
      *       |--------+
      *       |         \
      *       |          \
      *       |           \          (x3,y3)
      *       |            +----------+
      *       |        (x2,y2)         \
      *       |                         \
      *       |                          \
      *       |                           +-----------------
      *       |                         (x4,y4)
      *       +--------------------------------------------->   stem
      *                                                       thickness
      *
      *
      * This corresponds to the following values for the
      * `darkening-parameters' property:
      *
      *   (x1, y1) = (500, 400)
      *   (x2, y2) = (1000, 275)
      *   (x3, y3) = (1667, 275)
      *   (x4, y4) = (2333, 0)
      *
      */
 
     /* Internal calculations are done in units per thousand for */
     /* convenience. The x axis is scaled stem width in          */
     /* thousandths of a pixel. That is, 1000 is 1 pixel.        */
     /* The y axis is darkening amount in thousandths of a pixel.*/
     /* In the code, below, dividing by ppem and                 */
     /* adjusting for emRatio converts darkenAmount to character */
     /* space (font units).                                      */
     CF2_Fixed  stemWidthPer1000, scaledStem;
     FT_Int     logBase2;
 
 
     *darkenAmount = 0;
 
     if ( boldenAmount == 0 && !stemDarkened )
       return;
 
     /* protect against range problems and divide by zero */
     if ( emRatio < cf2_floatToFixed( .01 ) )
       return;
 
     if ( stemDarkened )
     {
       FT_Int  x1 = darkenParams[0];
       FT_Int  y1 = darkenParams[1];
       FT_Int  x2 = darkenParams[2];
       FT_Int  y2 = darkenParams[3];
       FT_Int  x3 = darkenParams[4];
       FT_Int  y3 = darkenParams[5];
       FT_Int  x4 = darkenParams[6];
       FT_Int  y4 = darkenParams[7];
 
 
       /* convert from true character space to 1000 unit character space; */
       /* add synthetic emboldening effect                                */
 
       /* `stemWidthPer1000' will not overflow for a legitimate font      */
 
       stemWidthPer1000 = FT_MulFix( stemWidth + boldenAmount, emRatio );
 
       /* `scaledStem' can easily overflow, so we must clamp its maximum  */
       /* value; the test doesn't need to be precise, but must be         */
       /* conservative.  The clamp value (default 2333) where             */
       /* `darkenAmount' is zero is well below the overflow value of      */
       /* 32767.                                                          */
       /*                                                                 */
       /* FT_MSB computes the integer part of the base 2 logarithm.  The  */
       /* number of bits for the product is 1 or 2 more than the sum of   */
       /* logarithms; remembering that the 16 lowest bits of the fraction */
       /* are dropped this is correct to within a factor of almost 4.     */
       /* For example, 0x80.0000 * 0x80.0000 = 0x4000.0000 is 23+23 and   */
       /* is flagged as possible overflow because 0xFF.FFFF * 0xFF.FFFF = */
       /* 0xFFFF.FE00 is also 23+23.                                      */
 
       logBase2 = FT_MSB( (FT_UInt32)stemWidthPer1000 ) +
                    FT_MSB( (FT_UInt32)ppem );
 
       if ( logBase2 >= 46 )
         /* possible overflow */
         scaledStem = cf2_intToFixed( x4 );
       else
         scaledStem = FT_MulFix( stemWidthPer1000, ppem );
 
       /* now apply the darkening parameters */
 
       if ( scaledStem < cf2_intToFixed( x1 ) )
         *darkenAmount = FT_DivFix( cf2_intToFixed( y1 ), ppem );
 
       else if ( scaledStem < cf2_intToFixed( x2 ) )
       {
         FT_Int  xdelta = x2 - x1;
         FT_Int  ydelta = y2 - y1;
         FT_Int  x      = stemWidthPer1000 -
                            FT_DivFix( cf2_intToFixed( x1 ), ppem );
 
 
         if ( !xdelta )
           goto Try_x3;
 
         *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                           FT_DivFix( cf2_intToFixed( y1 ), ppem );
       }
 
       else if ( scaledStem < cf2_intToFixed( x3 ) )
       {
       Try_x3:
         {
           FT_Int  xdelta = x3 - x2;
           FT_Int  ydelta = y3 - y2;
           FT_Int  x      = stemWidthPer1000 -
                              FT_DivFix( cf2_intToFixed( x2 ), ppem );
 
 
           if ( !xdelta )
             goto Try_x4;
 
           *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                             FT_DivFix( cf2_intToFixed( y2 ), ppem );
         }
       }
 
       else if ( scaledStem < cf2_intToFixed( x4 ) )
       {
       Try_x4:
         {
           FT_Int  xdelta = x4 - x3;
           FT_Int  ydelta = y4 - y3;
           FT_Int  x      = stemWidthPer1000 -
                              FT_DivFix( cf2_intToFixed( x3 ), ppem );
 
 
           if ( !xdelta )
             goto Use_y4;
 
           *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                             FT_DivFix( cf2_intToFixed( y3 ), ppem );
         }
       }
 
       else
       {
       Use_y4:
         *darkenAmount = FT_DivFix( cf2_intToFixed( y4 ), ppem );
       }
 
       /* use half the amount on each side and convert back to true */
       /* character space                                           */
       *darkenAmount = FT_DivFix( *darkenAmount, 2 * emRatio );
     }
 
     /* add synthetic emboldening effect in character space */
     *darkenAmount += boldenAmount / 2;
   }
 
 
   /* set up values for the current FontDict and matrix; */
   /* called for each glyph to be rendered               */
 
   /* caller's transform is adjusted for subpixel positioning */
   static void
   cf2_font_setup( CF2_Font           font,
                   const CF2_Matrix*  transform )
   {
     /* pointer to parsed font object */
     CFF_Decoder*  decoder = font->decoder;
 
     FT_Bool  needExtraSetup = FALSE;
 
+    CFF_VStoreRec*  vstore;
+    FT_Bool         hasVariations = FALSE;
+
     /* character space units */
     CF2_Fixed  boldenX = font->syntheticEmboldeningAmountX;
     CF2_Fixed  boldenY = font->syntheticEmboldeningAmountY;
 
     CFF_SubFont  subFont;
     CF2_Fixed    ppem;
 
+    CF2_UInt   lenNormalizedV = 0;
+    FT_Fixed*  normalizedV    = NULL;
+
 
     /* clear previous error */
     font->error = FT_Err_Ok;
 
     /* if a CID fontDict has changed, we need to recompute some cached */
     /* data                                                            */
     subFont = cf2_getSubfont( decoder );
     if ( font->lastSubfont != subFont )
     {
       font->lastSubfont = subFont;
       needExtraSetup    = TRUE;
     }
 
+    /* check for variation vectors */
+    vstore        = cf2_getVStore( decoder );
+    hasVariations = ( vstore->dataCount != 0 );
+
+    if ( hasVariations )
+    {
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+      /* check whether Private DICT in this subfont needs to be reparsed */
+      font->error = cf2_getNormalizedVector( decoder,
+                                             &lenNormalizedV,
+                                             &normalizedV );
+      if ( font->error )
+        return;
+
+      if ( cff_blend_check_vector( &subFont->blend,
+                                   subFont->private_dict.vsindex,
+                                   lenNormalizedV,
+                                   normalizedV ) )
+      {
+        /* blend has changed, reparse */
+        cff_load_private_dict( decoder->cff,
+                               subFont,
+                               lenNormalizedV,
+                               normalizedV );
+        needExtraSetup = TRUE;
+      }
+#endif
+
+      /* copy from subfont */
+      font->blend.font = subFont->blend.font;
+
+      /* clear state of charstring blend */
+      font->blend.usedBV = FALSE;
+
+      /* initialize value for charstring */
+      font->vsindex = subFont->private_dict.vsindex;
+
+      /* store vector inputs for blends in charstring */
+      font->lenNDV = lenNormalizedV;
+      font->NDV    = normalizedV;
+    }
+
     /* if ppem has changed, we need to recompute some cached data         */
     /* note: because of CID font matrix concatenation, ppem and transform */
     /*       do not necessarily track.                                    */
     ppem = cf2_getPpemY( decoder );
     if ( font->ppem != ppem )
     {
       font->ppem     = ppem;
       needExtraSetup = TRUE;
     }
 
     /* copy hinted flag on each call */
     font->hinted = (FT_Bool)( font->renderingFlags & CF2_FlagsHinted );
 
     /* determine if transform has changed;       */
     /* include Fontmatrix but ignore translation */
     if ( ft_memcmp( transform,
                     &font->currentTransform,
                     4 * sizeof ( CF2_Fixed ) ) != 0 )
     {
       /* save `key' information for `cache of one' matrix data; */
       /* save client transform, without the translation         */
       font->currentTransform    = *transform;
       font->currentTransform.tx =
       font->currentTransform.ty = cf2_intToFixed( 0 );
 
       /* TODO: FreeType transform is simple scalar; for now, use identity */
       /*       for outer                                                  */
       font->innerTransform   = *transform;
       font->outerTransform.a =
       font->outerTransform.d = cf2_intToFixed( 1 );
       font->outerTransform.b =
       font->outerTransform.c = cf2_intToFixed( 0 );
 
       needExtraSetup = TRUE;
     }
 
     /*
      * font->darkened is set to true if there is a stem darkening request or
      * the font is synthetic emboldened.
      * font->darkened controls whether to adjust blue zones, winding order,
      * and hinting.
      *
      */
     if ( font->stemDarkened != ( font->renderingFlags & CF2_FlagsDarkened ) )
     {
       font->stemDarkened =
         (FT_Bool)( font->renderingFlags & CF2_FlagsDarkened );
 
       /* blue zones depend on darkened flag */
       needExtraSetup = TRUE;
     }
 
     /* recompute variables that are dependent on transform or FontDict or */
     /* darken flag                                                        */
     if ( needExtraSetup )
     {
       /* StdVW is found in the private dictionary;                       */
       /* recompute darkening amounts whenever private dictionary or      */
       /* transform change                                                */
       /* Note: a rendering flag turns darkening on or off, so we want to */
       /*       store the `on' amounts;                                   */
       /*       darkening amount is computed in character space           */
       /* TODO: testing size-dependent darkening here;                    */
       /*       what to do for rotations?                                 */
 
       CF2_Fixed  emRatio;
       CF2_Fixed  stdHW;
       CF2_Int    unitsPerEm = font->unitsPerEm;
 
 
       if ( unitsPerEm == 0 )
         unitsPerEm = 1000;
 
       ppem = FT_MAX( cf2_intToFixed( 4 ),
                      font->ppem ); /* use minimum ppem of 4 */
 
 #if 0
       /* since vstem is measured in the x-direction, we use the `a' member */
       /* of the fontMatrix                                                 */
       emRatio = cf2_fixedFracMul( cf2_intToFixed( 1000 ), fontMatrix->a );
 #endif
 
       /* Freetype does not preserve the fontMatrix when parsing; use */
       /* unitsPerEm instead.                                         */
       /* TODO: check precision of this                               */
       emRatio     = cf2_intToFixed( 1000 ) / unitsPerEm;
       font->stdVW = cf2_getStdVW( decoder );
 
       if ( font->stdVW <= 0 )
         font->stdVW = FT_DivFix( cf2_intToFixed( 75 ), emRatio );
 
       if ( boldenX > 0 )
       {
         /* Ensure that boldenX is at least 1 pixel for synthetic bold font */
         /* (similar to what Avalon does)                                   */
         boldenX = FT_MAX( boldenX,
                           FT_DivFix( cf2_intToFixed( unitsPerEm ), ppem ) );
 
         /* Synthetic emboldening adds at least 1 pixel to darkenX, while */
         /* stem darkening adds at most half pixel.  Since the purpose of */
         /* stem darkening (readability at small sizes) is met with       */
         /* synthetic emboldening, no need to add stem darkening for a    */
         /* synthetic bold font.                                          */
         cf2_computeDarkening( emRatio,
                               ppem,
                               font->stdVW,
                               &font->darkenX,
                               boldenX,
                               FALSE,
                               font->darkenParams );
       }
       else
         cf2_computeDarkening( emRatio,
                               ppem,
                               font->stdVW,
                               &font->darkenX,
                               0,
                               font->stemDarkened,
                               font->darkenParams );
 
 #if 0
       /* since hstem is measured in the y-direction, we use the `d' member */
       /* of the fontMatrix                                                 */
       /* TODO: use the same units per em as above; check this              */
       emRatio = cf2_fixedFracMul( cf2_intToFixed( 1000 ), fontMatrix->d );
 #endif
 
       /* set the default stem width, because it must be the same for all */
       /* family members;                                                 */
       /* choose a constant for StdHW that depends on font contrast       */
       stdHW = cf2_getStdHW( decoder );
 
       if ( stdHW > 0 && font->stdVW > 2 * stdHW )
         font->stdHW = FT_DivFix( cf2_intToFixed( 75 ), emRatio );
       else
       {
         /* low contrast font gets less hstem darkening */
         font->stdHW = FT_DivFix( cf2_intToFixed( 110 ), emRatio );
       }
 
       cf2_computeDarkening( emRatio,
                             ppem,
                             font->stdHW,
                             &font->darkenY,
                             boldenY,
                             font->stemDarkened,
                             font->darkenParams );
 
       if ( font->darkenX != 0 || font->darkenY != 0 )
         font->darkened = TRUE;
       else
         font->darkened = FALSE;
 
       font->reverseWinding = FALSE; /* initial expectation is CCW */
 
       /* compute blue zones for this instance */
       cf2_blues_init( &font->blues, font );
 
     } /* needExtraSetup */
   }
 
 
   /* equivalent to AdobeGetOutline */
   FT_LOCAL_DEF( FT_Error )
   cf2_getGlyphOutline( CF2_Font           font,
                        CF2_Buffer         charstring,
                        const CF2_Matrix*  transform,
                        CF2_F16Dot16*      glyphWidth )
   {
     FT_Error  lastError = FT_Err_Ok;
 
     FT_Vector  translation;
 
 #if 0
     FT_Vector  advancePoint;
 #endif
 
     CF2_Fixed  advWidth = 0;
     FT_Bool    needWinding;
 
 
     /* Note: use both integer and fraction for outlines.  This allows bbox */
     /*       to come out directly.                                         */
 
     translation.x = transform->tx;
     translation.y = transform->ty;
 
     /* set up values based on transform */
     cf2_font_setup( font, transform );
     if ( font->error )
       goto exit;                      /* setup encountered an error */
 
     /* reset darken direction */
     font->reverseWinding = FALSE;
 
     /* winding order only affects darkening */
     needWinding = font->darkened;
 
     while ( 1 )
     {
       /* reset output buffer */
       cf2_outline_reset( &font->outline );
 
       /* build the outline, passing the full translation */
       cf2_interpT2CharString( font,
                               charstring,
                               (CF2_OutlineCallbacks)&font->outline,
                               &translation,
                               FALSE,
                               0,
                               0,
                               &advWidth );
 
       if ( font->error )
         goto exit;
 
       if ( !needWinding )
         break;
 
       /* check winding order */
       if ( font->outline.root.windingMomentum >= 0 ) /* CFF is CCW */
         break;
 
       /* invert darkening and render again                            */
       /* TODO: this should be a parameter to getOutline-computeOffset */
       font->reverseWinding = TRUE;
 
       needWinding = FALSE;    /* exit after next iteration */
     }
 
     /* finish storing client outline */
     cf2_outline_close( &font->outline );
 
   exit:
     /* FreeType just wants the advance width; there is no translation */
     *glyphWidth = advWidth;
 
     /* free resources and collect errors from objects we've used */
     cf2_setError( &font->error, lastError );
 
     return font->error;
   }
 
 
 /* END */
diff --git a/src/cff/cf2font.h b/src/cff/cf2font.h
index b1ffb79d2..1b6241774 100644
--- a/src/cff/cf2font.h
+++ b/src/cff/cf2font.h
@@ -47,68 +47,74 @@
 FT_BEGIN_HEADER
 
 
 #define CF2_OPERAND_STACK_SIZE  48
 #define CF2_MAX_SUBR            16 /* maximum subroutine nesting;         */
                                    /* only 10 are allowed but there exist */
                                    /* fonts like `HiraKakuProN-W3.ttf'    */
                                    /* (Hiragino Kaku Gothic ProN W3;      */
                                    /* 8.2d6e1; 2014-12-19) that exceed    */
                                    /* this limit                          */
 #define CF2_STORAGE_SIZE        32
 
 
   /* typedef is in `cf2glue.h' */
   struct  CF2_FontRec_
   {
     FT_Memory  memory;
     FT_Error   error;     /* shared error for this instance */
 
     FT_Bool             isCFF2;
     CF2_RenderingFlags  renderingFlags;
 
     /* variables that depend on Transform:  */
     /* the following have zero translation; */
     /* inner * outer = font * original      */
 
     CF2_Matrix  currentTransform;  /* original client matrix           */
     CF2_Matrix  innerTransform;    /* for hinting; erect, scaled       */
     CF2_Matrix  outerTransform;    /* post hinting; includes rotations */
     CF2_Fixed   ppem;              /* transform-dependent              */
 
+    /* variation data */
+    CFF_BlendRec  blend;            /* cached charstring blend vector  */
+    CF2_UInt      vsindex;          /* current vsindex                 */
+    CF2_UInt      lenNDV;           /* current length NDV or zero      */
+    FT_Fixed*     NDV;              /* ptr to current NDV or NULL      */
+
     CF2_Int  unitsPerEm;
 
     CF2_Fixed  syntheticEmboldeningAmountX;   /* character space units */
     CF2_Fixed  syntheticEmboldeningAmountY;   /* character space units */
 
     /* FreeType related members */
     CF2_OutlineRec  outline;       /* freetype glyph outline functions */
     CFF_Decoder*    decoder;
     CFF_SubFont     lastSubfont;              /* FreeType parsed data; */
                                               /* top font or subfont   */
 
     /* these flags can vary from one call to the next */
     FT_Bool  hinted;
     FT_Bool  darkened;       /* true if stemDarkened or synthetic bold */
                              /* i.e. darkenX != 0 || darkenY != 0      */
     FT_Bool  stemDarkened;
 
     FT_Int  darkenParams[8];              /* 1000 unit character space */
 
     /* variables that depend on both FontDict and Transform */
     CF2_Fixed  stdVW;     /* in character space; depends on dict entry */
     CF2_Fixed  stdHW;     /* in character space; depends on dict entry */
     CF2_Fixed  darkenX;                    /* character space units    */
     CF2_Fixed  darkenY;                    /* depends on transform     */
                                            /* and private dict (StdVW) */
     FT_Bool  reverseWinding;               /* darken assuming          */
                                            /* counterclockwise winding */
 
     CF2_BluesRec  blues;                         /* computed zone data */
   };
 
 
   FT_LOCAL( FT_Error )
   cf2_getGlyphOutline( CF2_Font           font,
                        CF2_Buffer         charstring,
                        const CF2_Matrix*  transform,
                        CF2_F16Dot16*      glyphWidth );
diff --git a/src/cff/cf2ft.c b/src/cff/cf2ft.c
index e35dcf63e..02f16ab07 100644
--- a/src/cff/cf2ft.c
+++ b/src/cff/cf2ft.c
@@ -1,719 +1,748 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cf2ft.c                                                                */
 /*                                                                         */
 /*    FreeType Glue Component to Adobe's Interpreter (body).               */
 /*                                                                         */
 /*  Copyright 2013-2014 Adobe Systems Incorporated.                        */
 /*                                                                         */
 /*  This software, and all works of authorship, whether in source or       */
 /*  object code form as indicated by the copyright notice(s) included      */
 /*  herein (collectively, the "Work") is made available, and may only be   */
 /*  used, modified, and distributed under the FreeType Project License,    */
 /*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
 /*  FreeType Project License, each contributor to the Work hereby grants   */
 /*  to any individual or legal entity exercising permissions granted by    */
 /*  the FreeType Project License and this section (hereafter, "You" or     */
 /*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
 /*  royalty-free, irrevocable (except as stated in this section) patent    */
 /*  license to make, have made, use, offer to sell, sell, import, and      */
 /*  otherwise transfer the Work, where such license applies only to those  */
 /*  patent claims licensable by such contributor that are necessarily      */
 /*  infringed by their contribution(s) alone or by combination of their    */
 /*  contribution(s) with the Work to which such contribution(s) was        */
 /*  submitted.  If You institute patent litigation against any entity      */
 /*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
 /*  the Work or a contribution incorporated within the Work constitutes    */
 /*  direct or contributory patent infringement, then any patent licenses   */
 /*  granted to You under this License for that Work shall terminate as of  */
 /*  the date such litigation is filed.                                     */
 /*                                                                         */
 /*  By using, modifying, or distributing the Work you indicate that you    */
 /*  have read and understood the terms and conditions of the               */
 /*  FreeType Project License as well as those provided in this section,    */
 /*  and you accept them fully.                                             */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include "cf2ft.h"
 #include FT_INTERNAL_DEBUG_H
 
 #include "cf2font.h"
 #include "cf2error.h"
 
 
 #define CF2_MAX_SIZE  cf2_intToFixed( 2000 )    /* max ppem */
 
 
   /*
    * This check should avoid most internal overflow cases.  Clients should
    * generally respond to `Glyph_Too_Big' by getting a glyph outline
    * at EM size, scaling it and filling it as a graphics operation.
    *
    */
   static FT_Error
   cf2_checkTransform( const CF2_Matrix*  transform,
                       CF2_Int            unitsPerEm )
   {
     CF2_Fixed  maxScale;
 
 
     FT_ASSERT( unitsPerEm > 0 );
 
     if ( transform->a <= 0 || transform->d <= 0 )
       return FT_THROW( Invalid_Size_Handle );
 
     FT_ASSERT( transform->b == 0 && transform->c == 0 );
     FT_ASSERT( transform->tx == 0 && transform->ty == 0 );
 
     if ( unitsPerEm > 0x7FFF )
       return FT_THROW( Glyph_Too_Big );
 
     maxScale = FT_DivFix( CF2_MAX_SIZE, cf2_intToFixed( unitsPerEm ) );
 
     if ( transform->a > maxScale || transform->d > maxScale )
       return FT_THROW( Glyph_Too_Big );
 
     return FT_Err_Ok;
   }
 
 
   static void
   cf2_setGlyphWidth( CF2_Outline  outline,
                      CF2_Fixed    width )
   {
     CFF_Decoder*  decoder = outline->decoder;
 
 
     FT_ASSERT( decoder );
 
     decoder->glyph_width = cf2_fixedToInt( width );
   }
 
 
   /* Clean up font instance. */
   static void
   cf2_free_instance( void*  ptr )
   {
     CF2_Font  font = (CF2_Font)ptr;
 
 
     if ( font )
     {
       FT_Memory  memory = font->memory;
 
 
-      (void)memory;
+      FT_FREE( font->blend.lastNDV );
+      FT_FREE( font->blend.BV );
     }
   }
 
 
   /********************************************/
   /*                                          */
   /* functions for handling client outline;   */
   /* FreeType uses coordinates in 26.6 format */
   /*                                          */
   /********************************************/
 
   static void
   cf2_builder_moveTo( CF2_OutlineCallbacks      callbacks,
                       const CF2_CallbackParams  params )
   {
     /* downcast the object pointer */
     CF2_Outline   outline = (CF2_Outline)callbacks;
     CFF_Builder*  builder;
 
     (void)params;        /* only used in debug mode */
 
 
     FT_ASSERT( outline && outline->decoder );
     FT_ASSERT( params->op == CF2_PathOpMoveTo );
 
     builder = &outline->decoder->builder;
 
     /* note: two successive moves simply close the contour twice */
     cff_builder_close_contour( builder );
     builder->path_begun = 0;
   }
 
 
   static void
   cf2_builder_lineTo( CF2_OutlineCallbacks      callbacks,
                       const CF2_CallbackParams  params )
   {
     FT_Error  error;
 
     /* downcast the object pointer */
     CF2_Outline   outline = (CF2_Outline)callbacks;
     CFF_Builder*  builder;
 
 
     FT_ASSERT( outline && outline->decoder );
     FT_ASSERT( params->op == CF2_PathOpLineTo );
 
     builder = &outline->decoder->builder;
 
     if ( !builder->path_begun )
     {
       /* record the move before the line; also check points and set */
       /* `path_begun'                                               */
       error = cff_builder_start_point( builder,
                                        params->pt0.x,
                                        params->pt0.y );
       if ( error )
       {
         if ( !*callbacks->error )
           *callbacks->error =  error;
         return;
       }
     }
 
     /* `cff_builder_add_point1' includes a check_points call for one point */
     error = cff_builder_add_point1( builder,
                                     params->pt1.x,
                                     params->pt1.y );
     if ( error )
     {
       if ( !*callbacks->error )
         *callbacks->error =  error;
       return;
     }
   }
 
 
   static void
   cf2_builder_cubeTo( CF2_OutlineCallbacks      callbacks,
                       const CF2_CallbackParams  params )
   {
     FT_Error  error;
 
     /* downcast the object pointer */
     CF2_Outline   outline = (CF2_Outline)callbacks;
     CFF_Builder*  builder;
 
 
     FT_ASSERT( outline && outline->decoder );
     FT_ASSERT( params->op == CF2_PathOpCubeTo );
 
     builder = &outline->decoder->builder;
 
     if ( !builder->path_begun )
     {
       /* record the move before the line; also check points and set */
       /* `path_begun'                                               */
       error = cff_builder_start_point( builder,
                                        params->pt0.x,
                                        params->pt0.y );
       if ( error )
       {
         if ( !*callbacks->error )
           *callbacks->error =  error;
         return;
       }
     }
 
     /* prepare room for 3 points: 2 off-curve, 1 on-curve */
     error = cff_check_points( builder, 3 );
     if ( error )
     {
       if ( !*callbacks->error )
         *callbacks->error =  error;
       return;
     }
 
     cff_builder_add_point( builder,
                            params->pt1.x,
                            params->pt1.y, 0 );
     cff_builder_add_point( builder,
                            params->pt2.x,
                            params->pt2.y, 0 );
     cff_builder_add_point( builder,
                            params->pt3.x,
                            params->pt3.y, 1 );
   }
 
 
   static void
   cf2_outline_init( CF2_Outline  outline,
                     FT_Memory    memory,
                     FT_Error*    error )
   {
     FT_ZERO( outline );
 
     outline->root.memory = memory;
     outline->root.error  = error;
 
     outline->root.moveTo = cf2_builder_moveTo;
     outline->root.lineTo = cf2_builder_lineTo;
     outline->root.cubeTo = cf2_builder_cubeTo;
   }
 
 
   /* get scaling and hint flag from GlyphSlot */
   static void
   cf2_getScaleAndHintFlag( CFF_Decoder*  decoder,
                            CF2_Fixed*    x_scale,
                            CF2_Fixed*    y_scale,
                            FT_Bool*      hinted,
                            FT_Bool*      scaled )
   {
     FT_ASSERT( decoder && decoder->builder.glyph );
 
     /* note: FreeType scale includes a factor of 64 */
     *hinted = decoder->builder.glyph->hint;
     *scaled = decoder->builder.glyph->scaled;
 
     if ( *hinted )
     {
       *x_scale = ( decoder->builder.glyph->x_scale + 32 ) / 64;
       *y_scale = ( decoder->builder.glyph->y_scale + 32 ) / 64;
     }
     else
     {
       /* for unhinted outlines, `cff_slot_load' does the scaling, */
       /* thus render at `unity' scale                             */
 
       *x_scale = 0x0400;   /* 1/64 as 16.16 */
       *y_scale = 0x0400;
     }
   }
 
 
   /* get units per em from `FT_Face' */
   /* TODO: should handle font matrix concatenation? */
   static FT_UShort
   cf2_getUnitsPerEm( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->builder.face );
     FT_ASSERT( decoder->builder.face->root.units_per_EM );
 
     return decoder->builder.face->root.units_per_EM;
   }
 
 
   /* Main entry point: Render one glyph. */
   FT_LOCAL_DEF( FT_Error )
   cf2_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                  FT_Byte*      charstring_base,
                                  FT_ULong      charstring_len )
   {
     FT_Memory  memory;
     FT_Error   error = FT_Err_Ok;
     CF2_Font   font;
 
 
     FT_ASSERT( decoder && decoder->cff );
 
     memory = decoder->builder.memory;
 
     /* CF2 data is saved here across glyphs */
     font = (CF2_Font)decoder->cff->cf2_instance.data;
 
     /* on first glyph, allocate instance structure */
     if ( decoder->cff->cf2_instance.data == NULL )
     {
       decoder->cff->cf2_instance.finalizer =
         (FT_Generic_Finalizer)cf2_free_instance;
 
       if ( FT_ALLOC( decoder->cff->cf2_instance.data,
                      sizeof ( CF2_FontRec ) ) )
         return FT_THROW( Out_Of_Memory );
 
       font = (CF2_Font)decoder->cff->cf2_instance.data;
 
       font->memory = memory;
 
       /* initialize a client outline, to be shared by each glyph rendered */
       cf2_outline_init( &font->outline, font->memory, &font->error );
     }
 
     /* save decoder; it is a stack variable and will be different on each */
     /* call                                                               */
     font->decoder         = decoder;
     font->outline.decoder = decoder;
 
     {
       /* build parameters for Adobe engine */
 
       CFF_Builder*  builder = &decoder->builder;
       CFF_Driver    driver  = (CFF_Driver)FT_FACE_DRIVER( builder->face );
 
       /* local error */
       FT_Error       error2 = FT_Err_Ok;
       CF2_BufferRec  buf;
       CF2_Matrix     transform;
       CF2_F16Dot16   glyphWidth;
 
       FT_Bool  hinted;
       FT_Bool  scaled;
 
 
       /* FreeType has already looked up the GID; convert to         */
       /* `RegionBuffer', assuming that the input has been validated */
       FT_ASSERT( charstring_base + charstring_len >= charstring_base );
 
       FT_ZERO( &buf );
       buf.start =
       buf.ptr   = charstring_base;
       buf.end   = charstring_base + charstring_len;
 
       FT_ZERO( &transform );
 
       cf2_getScaleAndHintFlag( decoder,
                                &transform.a,
                                &transform.d,
                                &hinted,
                                &scaled );
 
       /* copy isCFF2 boolean from TT_Face to CF2_Font */
       font->isCFF2 = builder->face->isCFF2;
 
       font->renderingFlags = 0;
       if ( hinted )
         font->renderingFlags |= CF2_FlagsHinted;
       if ( scaled && !driver->no_stem_darkening )
         font->renderingFlags |= CF2_FlagsDarkened;
 
       font->darkenParams[0] = driver->darken_params[0];
       font->darkenParams[1] = driver->darken_params[1];
       font->darkenParams[2] = driver->darken_params[2];
       font->darkenParams[3] = driver->darken_params[3];
       font->darkenParams[4] = driver->darken_params[4];
       font->darkenParams[5] = driver->darken_params[5];
       font->darkenParams[6] = driver->darken_params[6];
       font->darkenParams[7] = driver->darken_params[7];
 
       /* now get an outline for this glyph;      */
       /* also get units per em to validate scale */
       font->unitsPerEm = (CF2_Int)cf2_getUnitsPerEm( decoder );
 
       if ( scaled )
       {
         error2 = cf2_checkTransform( &transform, font->unitsPerEm );
         if ( error2 )
           return error2;
       }
 
       error2 = cf2_getGlyphOutline( font, &buf, &transform, &glyphWidth );
       if ( error2 )
         return FT_ERR( Invalid_File_Format );
 
       cf2_setGlyphWidth( &font->outline, glyphWidth );
 
       return FT_Err_Ok;
     }
   }
 
 
   /* get pointer to current FreeType subfont (based on current glyphID) */
   FT_LOCAL_DEF( CFF_SubFont )
   cf2_getSubfont( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return decoder->current_subfont;
   }
 
 
+  /* get pointer to VStore structure */
+  FT_LOCAL_DEF( CFF_VStore )
+  cf2_getVStore( CFF_Decoder*  decoder )
+  {
+    FT_ASSERT( decoder && decoder->cff );
+
+    return &decoder->cff->vstore;
+  }
+
+
   /* get maxstack value from CFF2 Top DICT */
   FT_LOCAL_DEF( FT_UInt )
   cf2_getMaxstack( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->cff );
 
     return decoder->cff->top_font.font_dict.maxstack;
   }
 
 
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+  /* Get normalized design vector for current render request; */
+  /* return pointer and length.                               */
+  /*                                                          */
+  /* Note: Uses FT_Fixed not CF2_Fixed for the vector.        */
+  FT_LOCAL_DEF( FT_Error )
+  cf2_getNormalizedVector( CFF_Decoder*  decoder,
+                           CF2_UInt     *len,
+                           FT_Fixed*    *vec )
+  {
+    FT_ASSERT( decoder && decoder->builder.face );
+    FT_ASSERT( vec && len );
+
+    return cff_get_var_blend( decoder->builder.face, len, vec );
+  }
+#endif
+
+
   /* get `y_ppem' from `CFF_Size' */
   FT_LOCAL_DEF( CF2_Fixed )
   cf2_getPpemY( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder                          &&
                decoder->builder.face            &&
                decoder->builder.face->root.size );
 
     /*
      * Note that `y_ppem' can be zero if there wasn't a call to
      * `FT_Set_Char_Size' or something similar.  However, this isn't a
      * problem since we come to this place in the code only if
      * FT_LOAD_NO_SCALE is set (the other case gets caught by
      * `cf2_checkTransform').  The ppem value is needed to compute the stem
      * darkening, which is disabled for getting the unscaled outline.
      *
      */
     return cf2_intToFixed(
              decoder->builder.face->root.size->metrics.y_ppem );
   }
 
 
   /* get standard stem widths for the current subfont; */
   /* FreeType stores these as integer font units       */
   /* (note: variable names seem swapped)               */
   FT_LOCAL_DEF( CF2_Fixed )
   cf2_getStdVW( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return cf2_intToFixed(
              decoder->current_subfont->private_dict.standard_height );
   }
 
 
   FT_LOCAL_DEF( CF2_Fixed )
   cf2_getStdHW( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return cf2_intToFixed(
              decoder->current_subfont->private_dict.standard_width );
   }
 
 
   /* note: FreeType stores 1000 times the actual value for `BlueScale' */
   FT_LOCAL_DEF( void )
   cf2_getBlueMetrics( CFF_Decoder*  decoder,
                       CF2_Fixed*    blueScale,
                       CF2_Fixed*    blueShift,
                       CF2_Fixed*    blueFuzz )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     *blueScale = FT_DivFix(
                    decoder->current_subfont->private_dict.blue_scale,
                    cf2_intToFixed( 1000 ) );
     *blueShift = cf2_intToFixed(
                    decoder->current_subfont->private_dict.blue_shift );
     *blueFuzz  = cf2_intToFixed(
                    decoder->current_subfont->private_dict.blue_fuzz );
   }
 
 
   /* get blue values counts and arrays; the FreeType parser has validated */
   /* the counts and verified that each is an even number                  */
   FT_LOCAL_DEF( void )
   cf2_getBlueValues( CFF_Decoder*  decoder,
                      size_t*       count,
                      FT_Pos*      *data )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     *count = decoder->current_subfont->private_dict.num_blue_values;
     *data  = (FT_Pos*)
                &decoder->current_subfont->private_dict.blue_values;
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_getOtherBlues( CFF_Decoder*  decoder,
                      size_t*       count,
                      FT_Pos*      *data )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     *count = decoder->current_subfont->private_dict.num_other_blues;
     *data  = (FT_Pos*)
                &decoder->current_subfont->private_dict.other_blues;
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_getFamilyBlues( CFF_Decoder*  decoder,
                       size_t*       count,
                       FT_Pos*      *data )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     *count = decoder->current_subfont->private_dict.num_family_blues;
     *data  = (FT_Pos*)
                &decoder->current_subfont->private_dict.family_blues;
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_getFamilyOtherBlues( CFF_Decoder*  decoder,
                            size_t*       count,
                            FT_Pos*      *data )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     *count = decoder->current_subfont->private_dict.num_family_other_blues;
     *data  = (FT_Pos*)
                &decoder->current_subfont->private_dict.family_other_blues;
   }
 
 
   FT_LOCAL_DEF( CF2_Int )
   cf2_getLanguageGroup( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return decoder->current_subfont->private_dict.language_group;
   }
 
 
   /* convert unbiased subroutine index to `CF2_Buffer' and */
   /* return 0 on success                                   */
   FT_LOCAL_DEF( CF2_Int )
   cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,
                               CF2_Int       subrNum,
                               CF2_Buffer    buf )
   {
     CF2_UInt  idx;
 
 
     FT_ASSERT( decoder );
 
     FT_ZERO( buf );
 
     idx = (CF2_UInt)( subrNum + decoder->globals_bias );
     if ( idx >= decoder->num_globals )
       return TRUE;     /* error */
 
     FT_ASSERT( decoder->globals );
 
     buf->start =
     buf->ptr   = decoder->globals[idx];
     buf->end   = decoder->globals[idx + 1];
 
     return FALSE;      /* success */
   }
 
 
   /* convert AdobeStandardEncoding code to CF2_Buffer; */
   /* used for seac component                           */
   FT_LOCAL_DEF( FT_Error )
   cf2_getSeacComponent( CFF_Decoder*  decoder,
                         CF2_Int       code,
                         CF2_Buffer    buf )
   {
     CF2_Int   gid;
     FT_Byte*  charstring;
     FT_ULong  len;
     FT_Error  error;
 
 
     FT_ASSERT( decoder );
 
     FT_ZERO( buf );
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
     /* Incremental fonts don't necessarily have valid charsets.        */
     /* They use the character code, not the glyph index, in this case. */
     if ( decoder->builder.face->root.internal->incremental_interface )
       gid = code;
     else
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
     {
       gid = cff_lookup_glyph_by_stdcharcode( decoder->cff, code );
       if ( gid < 0 )
         return FT_THROW( Invalid_Glyph_Format );
     }
 
     error = cff_get_glyph_data( decoder->builder.face,
                                 (CF2_UInt)gid,
                                 &charstring,
                                 &len );
     /* TODO: for now, just pass the FreeType error through */
     if ( error )
       return error;
 
     /* assume input has been validated */
     FT_ASSERT( charstring + len >= charstring );
 
     buf->start = charstring;
     buf->end   = charstring + len;
     buf->ptr   = buf->start;
 
     return FT_Err_Ok;
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_freeSeacComponent( CFF_Decoder*  decoder,
                          CF2_Buffer    buf )
   {
     FT_ASSERT( decoder );
 
     cff_free_glyph_data( decoder->builder.face,
                          (FT_Byte**)&buf->start,
                          (FT_ULong)( buf->end - buf->start ) );
   }
 
 
   FT_LOCAL_DEF( CF2_Int )
   cf2_initLocalRegionBuffer( CFF_Decoder*  decoder,
                              CF2_Int       subrNum,
                              CF2_Buffer    buf )
   {
     CF2_UInt  idx;
 
 
     FT_ASSERT( decoder );
 
     FT_ZERO( buf );
 
     idx = (CF2_UInt)( subrNum + decoder->locals_bias );
     if ( idx >= decoder->num_locals )
       return TRUE;     /* error */
 
     FT_ASSERT( decoder->locals );
 
     buf->start =
     buf->ptr   = decoder->locals[idx];
     buf->end   = decoder->locals[idx + 1];
 
     return FALSE;      /* success */
   }
 
 
   FT_LOCAL_DEF( CF2_Fixed )
   cf2_getDefaultWidthX( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return cf2_intToFixed(
              decoder->current_subfont->private_dict.default_width );
   }
 
 
   FT_LOCAL_DEF( CF2_Fixed )
   cf2_getNominalWidthX( CFF_Decoder*  decoder )
   {
     FT_ASSERT( decoder && decoder->current_subfont );
 
     return cf2_intToFixed(
              decoder->current_subfont->private_dict.nominal_width );
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_outline_reset( CF2_Outline  outline )
   {
     CFF_Decoder*  decoder = outline->decoder;
 
 
     FT_ASSERT( decoder );
 
     outline->root.windingMomentum = 0;
 
     FT_GlyphLoader_Rewind( decoder->builder.loader );
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_outline_close( CF2_Outline  outline )
   {
     CFF_Decoder*  decoder = outline->decoder;
 
 
     FT_ASSERT( decoder );
 
     cff_builder_close_contour( &decoder->builder );
 
     FT_GlyphLoader_Add( decoder->builder.loader );
   }
 
 
 /* END */
diff --git a/src/cff/cf2ft.h b/src/cff/cf2ft.h
index 5ec78e418..b054a6e95 100644
--- a/src/cff/cf2ft.h
+++ b/src/cff/cf2ft.h
@@ -56,87 +56,95 @@
 FT_BEGIN_HEADER
 
 
   FT_LOCAL( FT_Error )
   cf2_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                  FT_Byte*      charstring_base,
                                  FT_ULong      charstring_len );
 
   FT_LOCAL( CFF_SubFont )
   cf2_getSubfont( CFF_Decoder*  decoder );
 
+  FT_LOCAL( CFF_VStore )
+  cf2_getVStore( CFF_Decoder*  decoder );
 
   FT_LOCAL( FT_UInt )
   cf2_getMaxstack( CFF_Decoder*  decoder );
 
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+  FT_LOCAL( FT_Error )
+  cf2_getNormalizedVector( CFF_Decoder*  decoder,
+                           CF2_UInt     *len,
+                           FT_Fixed*    *vec );
+#endif
 
   FT_LOCAL( CF2_Fixed )
   cf2_getPpemY( CFF_Decoder*  decoder );
   FT_LOCAL( CF2_Fixed )
   cf2_getStdVW( CFF_Decoder*  decoder );
   FT_LOCAL( CF2_Fixed )
   cf2_getStdHW( CFF_Decoder*  decoder );
 
   FT_LOCAL( void )
   cf2_getBlueMetrics( CFF_Decoder*  decoder,
                       CF2_Fixed*    blueScale,
                       CF2_Fixed*    blueShift,
                       CF2_Fixed*    blueFuzz );
   FT_LOCAL( void )
   cf2_getBlueValues( CFF_Decoder*  decoder,
                      size_t*       count,
                      FT_Pos*      *data );
   FT_LOCAL( void )
   cf2_getOtherBlues( CFF_Decoder*  decoder,
                      size_t*       count,
                      FT_Pos*      *data );
   FT_LOCAL( void )
   cf2_getFamilyBlues( CFF_Decoder*  decoder,
                       size_t*       count,
                       FT_Pos*      *data );
   FT_LOCAL( void )
   cf2_getFamilyOtherBlues( CFF_Decoder*  decoder,
                            size_t*       count,
                            FT_Pos*      *data );
 
   FT_LOCAL( CF2_Int )
   cf2_getLanguageGroup( CFF_Decoder*  decoder );
 
   FT_LOCAL( CF2_Int )
   cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,
                               CF2_Int       subrNum,
                               CF2_Buffer    buf );
   FT_LOCAL( FT_Error )
   cf2_getSeacComponent( CFF_Decoder*  decoder,
                         CF2_Int       code,
                         CF2_Buffer    buf );
   FT_LOCAL( void )
   cf2_freeSeacComponent( CFF_Decoder*  decoder,
                          CF2_Buffer    buf );
   FT_LOCAL( CF2_Int )
   cf2_initLocalRegionBuffer( CFF_Decoder*  decoder,
                              CF2_Int       subrNum,
                              CF2_Buffer    buf );
 
   FT_LOCAL( CF2_Fixed )
   cf2_getDefaultWidthX( CFF_Decoder*  decoder );
   FT_LOCAL( CF2_Fixed )
   cf2_getNominalWidthX( CFF_Decoder*  decoder );
 
 
   /*
    * FreeType client outline
    *
    * process output from the charstring interpreter
    */
   typedef struct  CF2_OutlineRec_
   {
     CF2_OutlineCallbacksRec  root;        /* base class must be first */
     CFF_Decoder*             decoder;
 
   } CF2_OutlineRec, *CF2_Outline;
 
 
   FT_LOCAL( void )
   cf2_outline_reset( CF2_Outline  outline );
   FT_LOCAL( void )
   cf2_outline_close( CF2_Outline  outline );
diff --git a/src/cff/cf2intrp.c b/src/cff/cf2intrp.c
index a6bb92972..2bbbb33be 100644
--- a/src/cff/cf2intrp.c
+++ b/src/cff/cf2intrp.c
@@ -1,1809 +1,1894 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cf2intrp.c                                                             */
 /*                                                                         */
 /*    Adobe's CFF Interpreter (body).                                      */
 /*                                                                         */
 /*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
 /*                                                                         */
 /*  This software, and all works of authorship, whether in source or       */
 /*  object code form as indicated by the copyright notice(s) included      */
 /*  herein (collectively, the "Work") is made available, and may only be   */
 /*  used, modified, and distributed under the FreeType Project License,    */
 /*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
 /*  FreeType Project License, each contributor to the Work hereby grants   */
 /*  to any individual or legal entity exercising permissions granted by    */
 /*  the FreeType Project License and this section (hereafter, "You" or     */
 /*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
 /*  royalty-free, irrevocable (except as stated in this section) patent    */
 /*  license to make, have made, use, offer to sell, sell, import, and      */
 /*  otherwise transfer the Work, where such license applies only to those  */
 /*  patent claims licensable by such contributor that are necessarily      */
 /*  infringed by their contribution(s) alone or by combination of their    */
 /*  contribution(s) with the Work to which such contribution(s) was        */
 /*  submitted.  If You institute patent litigation against any entity      */
 /*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
 /*  the Work or a contribution incorporated within the Work constitutes    */
 /*  direct or contributory patent infringement, then any patent licenses   */
 /*  granted to You under this License for that Work shall terminate as of  */
 /*  the date such litigation is filed.                                     */
 /*                                                                         */
 /*  By using, modifying, or distributing the Work you indicate that you    */
 /*  have read and understood the terms and conditions of the               */
 /*  FreeType Project License as well as those provided in this section,    */
 /*  and you accept them fully.                                             */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include "cf2ft.h"
 #include FT_INTERNAL_DEBUG_H
 
 #include "cf2glue.h"
 #include "cf2font.h"
 #include "cf2stack.h"
 #include "cf2hints.h"
 #include "cf2intrp.h"
 
 #include "cf2error.h"
 
+#include "cffload.h"
+
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_cf2interp
 
 
   /* some operators are not implemented yet */
 #define CF2_FIXME  FT_TRACE4(( "cf2_interpT2CharString:"            \
                                " operator not implemented yet\n" ))
 
 
 
   FT_LOCAL_DEF( void )
   cf2_hintmask_init( CF2_HintMask  hintmask,
                      FT_Error*     error )
   {
     FT_ZERO( hintmask );
 
     hintmask->error = error;
   }
 
 
   FT_LOCAL_DEF( FT_Bool )
   cf2_hintmask_isValid( const CF2_HintMask  hintmask )
   {
     return hintmask->isValid;
   }
 
 
   FT_LOCAL_DEF( FT_Bool )
   cf2_hintmask_isNew( const CF2_HintMask  hintmask )
   {
     return hintmask->isNew;
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_hintmask_setNew( CF2_HintMask  hintmask,
                        FT_Bool       val )
   {
     hintmask->isNew = val;
   }
 
 
   /* clients call `getMaskPtr' in order to iterate */
   /* through hint mask                             */
 
   FT_LOCAL_DEF( FT_Byte* )
   cf2_hintmask_getMaskPtr( CF2_HintMask  hintmask )
   {
     return hintmask->mask;
   }
 
 
   static size_t
   cf2_hintmask_setCounts( CF2_HintMask  hintmask,
                           size_t        bitCount )
   {
     if ( bitCount > CF2_MAX_HINTS )
     {
       /* total of h and v stems must be <= 96 */
       CF2_SET_ERROR( hintmask->error, Invalid_Glyph_Format );
       return 0;
     }
 
     hintmask->bitCount  = bitCount;
     hintmask->byteCount = ( hintmask->bitCount + 7 ) / 8;
 
     hintmask->isValid = TRUE;
     hintmask->isNew   = TRUE;
 
     return bitCount;
   }
 
 
   /* consume the hintmask bytes from the charstring, advancing the src */
   /* pointer                                                           */
   static void
   cf2_hintmask_read( CF2_HintMask  hintmask,
                      CF2_Buffer    charstring,
                      size_t        bitCount )
   {
     size_t  i;
 
 #ifndef CF2_NDEBUG
     /* these are the bits in the final mask byte that should be zero  */
     /* Note: this variable is only used in an assert expression below */
     /* and then only if CF2_NDEBUG is not defined                     */
     CF2_UInt  mask = ( 1 << ( -(CF2_Int)bitCount & 7 ) ) - 1;
 #endif
 
 
     /* initialize counts and isValid */
     if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
       return;
 
     FT_ASSERT( hintmask->byteCount > 0 );
 
     FT_TRACE4(( " (maskbytes:" ));
 
     /* set mask and advance interpreter's charstring pointer */
     for ( i = 0; i < hintmask->byteCount; i++ )
     {
       hintmask->mask[i] = (FT_Byte)cf2_buf_readByte( charstring );
       FT_TRACE4(( " 0x%02X", hintmask->mask[i] ));
     }
 
     FT_TRACE4(( ")\n" ));
 
     /* assert any unused bits in last byte are zero unless there's a prior */
     /* error                                                               */
     /* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1      */
 #ifndef CF2_NDEBUG
     FT_ASSERT( ( hintmask->mask[hintmask->byteCount - 1] & mask ) == 0 ||
                *hintmask->error                                        );
 #endif
   }
 
 
   FT_LOCAL_DEF( void )
   cf2_hintmask_setAll( CF2_HintMask  hintmask,
                        size_t        bitCount )
   {
     size_t    i;
     CF2_UInt  mask = ( 1 << ( -(CF2_Int)bitCount & 7 ) ) - 1;
 
 
     /* initialize counts and isValid */
     if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
       return;
 
     FT_ASSERT( hintmask->byteCount > 0 );
     FT_ASSERT( hintmask->byteCount <=
                  sizeof ( hintmask->mask ) / sizeof ( hintmask->mask[0] ) );
 
     /* set mask to all ones */
     for ( i = 0; i < hintmask->byteCount; i++ )
       hintmask->mask[i] = 0xFF;
 
     /* clear unused bits                                              */
     /* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1 */
     hintmask->mask[hintmask->byteCount - 1] &= ~mask;
   }
 
 
   /* Type2 charstring opcodes */
   enum
   {
     cf2_cmdRESERVED_0,   /* 0 */
     cf2_cmdHSTEM,        /* 1 */
     cf2_cmdRESERVED_2,   /* 2 */
     cf2_cmdVSTEM,        /* 3 */
     cf2_cmdVMOVETO,      /* 4 */
     cf2_cmdRLINETO,      /* 5 */
     cf2_cmdHLINETO,      /* 6 */
     cf2_cmdVLINETO,      /* 7 */
     cf2_cmdRRCURVETO,    /* 8 */
     cf2_cmdRESERVED_9,   /* 9 */
     cf2_cmdCALLSUBR,     /* 10 */
     cf2_cmdRETURN,       /* 11 */
     cf2_cmdESC,          /* 12 */
     cf2_cmdRESERVED_13,  /* 13 */
     cf2_cmdENDCHAR,      /* 14 */
-    cf2_cmdRESERVED_15,  /* 15 */
-    cf2_cmdRESERVED_16,  /* 16 */
+    cf2_cmdVSINDEX,      /* 15 */
+    cf2_cmdBLEND,        /* 16 */
     cf2_cmdRESERVED_17,  /* 17 */
     cf2_cmdHSTEMHM,      /* 18 */
     cf2_cmdHINTMASK,     /* 19 */
     cf2_cmdCNTRMASK,     /* 20 */
     cf2_cmdRMOVETO,      /* 21 */
     cf2_cmdHMOVETO,      /* 22 */
     cf2_cmdVSTEMHM,      /* 23 */
     cf2_cmdRCURVELINE,   /* 24 */
     cf2_cmdRLINECURVE,   /* 25 */
     cf2_cmdVVCURVETO,    /* 26 */
     cf2_cmdHHCURVETO,    /* 27 */
     cf2_cmdEXTENDEDNMBR, /* 28 */
     cf2_cmdCALLGSUBR,    /* 29 */
     cf2_cmdVHCURVETO,    /* 30 */
     cf2_cmdHVCURVETO     /* 31 */
   };
 
   enum
   {
     cf2_escDOTSECTION,   /* 0 */
     cf2_escRESERVED_1,   /* 1 */
     cf2_escRESERVED_2,   /* 2 */
     cf2_escAND,          /* 3 */
     cf2_escOR,           /* 4 */
     cf2_escNOT,          /* 5 */
     cf2_escRESERVED_6,   /* 6 */
     cf2_escRESERVED_7,   /* 7 */
     cf2_escRESERVED_8,   /* 8 */
     cf2_escABS,          /* 9 */
     cf2_escADD,          /* 10     like otherADD */
     cf2_escSUB,          /* 11     like otherSUB */
     cf2_escDIV,          /* 12 */
     cf2_escRESERVED_13,  /* 13 */
     cf2_escNEG,          /* 14 */
     cf2_escEQ,           /* 15 */
     cf2_escRESERVED_16,  /* 16 */
     cf2_escRESERVED_17,  /* 17 */
     cf2_escDROP,         /* 18 */
     cf2_escRESERVED_19,  /* 19 */
     cf2_escPUT,          /* 20     like otherPUT    */
     cf2_escGET,          /* 21     like otherGET    */
     cf2_escIFELSE,       /* 22     like otherIFELSE */
     cf2_escRANDOM,       /* 23     like otherRANDOM */
     cf2_escMUL,          /* 24     like otherMUL    */
     cf2_escRESERVED_25,  /* 25 */
     cf2_escSQRT,         /* 26 */
     cf2_escDUP,          /* 27     like otherDUP    */
     cf2_escEXCH,         /* 28     like otherEXCH   */
     cf2_escINDEX,        /* 29 */
     cf2_escROLL,         /* 30 */
     cf2_escRESERVED_31,  /* 31 */
     cf2_escRESERVED_32,  /* 32 */
     cf2_escRESERVED_33,  /* 33 */
     cf2_escHFLEX,        /* 34 */
     cf2_escFLEX,         /* 35 */
     cf2_escHFLEX1,       /* 36 */
     cf2_escFLEX1,        /* 37 */
     cf2_escRESERVED_38   /* 38     & all higher     */
   };
 
 
   /* `stemHintArray' does not change once we start drawing the outline. */
   static void
   cf2_doStems( const CF2_Font  font,
                CF2_Stack       opStack,
                CF2_ArrStack    stemHintArray,
                CF2_Fixed*      width,
                FT_Bool*        haveWidth,
                CF2_Fixed       hintOffset )
   {
     CF2_UInt  i;
     CF2_UInt  count       = cf2_stack_count( opStack );
     FT_Bool   hasWidthArg = (FT_Bool)( count & 1 );
 
     /* variable accumulates delta values from operand stack */
     CF2_Fixed  position = hintOffset;
 
 
     if ( hasWidthArg && !*haveWidth )
       *width = cf2_stack_getReal( opStack, 0 ) +
                  cf2_getNominalWidthX( font->decoder );
 
     if ( font->decoder->width_only )
       goto exit;
 
     for ( i = hasWidthArg ? 1 : 0; i < count; i += 2 )
     {
       /* construct a CF2_StemHint and push it onto the list */
       CF2_StemHintRec  stemhint;
 
 
       stemhint.min  =
         position   += cf2_stack_getReal( opStack, i );
       stemhint.max  =
         position   += cf2_stack_getReal( opStack, i + 1 );
 
       stemhint.used  = FALSE;
       stemhint.maxDS =
       stemhint.minDS = 0;
 
       cf2_arrstack_push( stemHintArray, &stemhint ); /* defer error check */
     }
 
     cf2_stack_clear( opStack );
 
   exit:
     /* cf2_doStems must define a width (may be default) */
     *haveWidth = TRUE;
   }
 
 
   static void
   cf2_doFlex( CF2_Stack       opStack,
               CF2_Fixed*      curX,
               CF2_Fixed*      curY,
               CF2_GlyphPath   glyphPath,
               const FT_Bool*  readFromStack,
               FT_Bool         doConditionalLastRead )
   {
     CF2_Fixed  vals[14];
     CF2_UInt   index;
     FT_Bool    isHFlex;
     CF2_Int    top, i, j;
 
 
     vals[0] = *curX;
     vals[1] = *curY;
     index   = 0;
     isHFlex = readFromStack[9] == FALSE;
     top     = isHFlex ? 9 : 10;
 
     for ( i = 0; i < top; i++ )
     {
       vals[i + 2] = vals[i];
       if ( readFromStack[i] )
         vals[i + 2] += cf2_stack_getReal( opStack, index++ );
     }
 
     if ( isHFlex )
       vals[9 + 2] = *curY;
 
     if ( doConditionalLastRead )
     {
       FT_Bool    lastIsX = (FT_Bool)( cf2_fixedAbs( vals[10] - *curX ) >
                                         cf2_fixedAbs( vals[11] - *curY ) );
       CF2_Fixed  lastVal = cf2_stack_getReal( opStack, index );
 
 
       if ( lastIsX )
       {
         vals[12] = vals[10] + lastVal;
         vals[13] = *curY;
       }
       else
       {
         vals[12] = *curX;
         vals[13] = vals[11] + lastVal;
       }
     }
     else
     {
       if ( readFromStack[10] )
         vals[12] = vals[10] + cf2_stack_getReal( opStack, index++ );
       else
         vals[12] = *curX;
 
       if ( readFromStack[11] )
         vals[13] = vals[11] + cf2_stack_getReal( opStack, index );
       else
         vals[13] = *curY;
     }
 
     for ( j = 0; j < 2; j++ )
       cf2_glyphpath_curveTo( glyphPath, vals[j * 6 + 2],
                                         vals[j * 6 + 3],
                                         vals[j * 6 + 4],
                                         vals[j * 6 + 5],
                                         vals[j * 6 + 6],
                                         vals[j * 6 + 7] );
 
     cf2_stack_clear( opStack );
 
     *curX = vals[12];
     *curY = vals[13];
   }
 
 
+  /* Blend numOperands on the stack,                */
+  /* store results into the first numBlends values, */
+  /* then pop remaining arguments.                  */
+  static void
+  cf2_doBlend( const CFF_Blend  blend,
+               CF2_Stack        opStack,
+               CF2_UInt         numBlends )
+  {
+    CF2_UInt  delta;
+    CF2_UInt  base;
+    CF2_UInt  i, j;
+    CF2_UInt  numOperands = (CF2_UInt)( numBlends * blend->lenBV );
+
+
+    base  = cf2_stack_count( opStack ) - numOperands;
+    delta = base + numBlends;
+
+    for ( i = 0; i < numBlends; i++ )
+    {
+      const CF2_Fixed*  weight = &blend->BV[1];
+
+      /* start with first term */
+      CF2_Fixed  sum = cf2_stack_getReal( opStack, i + base );
+
+
+      for ( j = 1; j < blend->lenBV; j++ )
+        sum += FT_MulFix( *weight++, cf2_stack_getReal( opStack, delta++ ) );
+
+      /* store blended result  */
+      cf2_stack_setReal( opStack, i + base, sum );
+    }
+
+    /* leave only `numBlends' results on stack */
+    cf2_stack_pop( opStack, numOperands - numBlends );
+  }
+
+
   /*
    * `error' is a shared error code used by many objects in this
    * routine.  Before the code continues from an error, it must check and
    * record the error in `*error'.  The idea is that this shared
    * error code will record the first error encountered.  If testing
    * for an error anyway, the cost of `goto exit' is small, so we do it,
    * even if continuing would be safe.  In this case, `lastError' is
    * set, so the testing and storing can be done in one place, at `exit'.
    *
    * Continuing after an error is intended for objects which do their own
    * testing of `*error', e.g., array stack functions.  This allows us to
    * avoid an extra test after the call.
    *
    * Unimplemented opcodes are ignored.
    *
    */
   FT_LOCAL_DEF( void )
   cf2_interpT2CharString( CF2_Font              font,
                           CF2_Buffer            buf,
                           CF2_OutlineCallbacks  callbacks,
                           const FT_Vector*      translation,
                           FT_Bool               doingSeac,
                           CF2_Fixed             curX,
                           CF2_Fixed             curY,
                           CF2_Fixed*            width )
   {
     /* lastError is used for errors that are immediately tested */
     FT_Error  lastError = FT_Err_Ok;
 
     /* pointer to parsed font object */
     CFF_Decoder*  decoder = font->decoder;
 
     FT_Error*  error  = &font->error;
     FT_Memory  memory = font->memory;
 
     CF2_Fixed  scaleY        = font->innerTransform.d;
     CF2_Fixed  nominalWidthX = cf2_getNominalWidthX( decoder );
 
     /* save this for hinting seac accents */
     CF2_Fixed  hintOriginY = curY;
 
     CF2_Stack  opStack = NULL;
     FT_UInt    stackSize;
     FT_Byte    op1;                       /* first opcode byte */
 
     CF2_F16Dot16  storage[CF2_STORAGE_SIZE];    /* for `put' and `get' */
 
     /* instruction limit; 20,000,000 matches Avalon */
     FT_UInt32  instructionLimit = 20000000UL;
 
     CF2_ArrStackRec  subrStack;
 
     FT_Bool     haveWidth;
     CF2_Buffer  charstring = NULL;
 
     CF2_Int  charstringIndex = -1;       /* initialize to empty */
 
     /* TODO: placeholders for hint structures */
 
     /* objects used for hinting */
     CF2_ArrStackRec  hStemHintArray;
     CF2_ArrStackRec  vStemHintArray;
 
     CF2_HintMaskRec   hintMask;
     CF2_GlyphPathRec  glyphPath;
 
 
     FT_ZERO( &storage );
 
     /* initialize the remaining objects */
     cf2_arrstack_init( &subrStack,
                        memory,
                        error,
                        sizeof ( CF2_BufferRec ) );
     cf2_arrstack_init( &hStemHintArray,
                        memory,
                        error,
                        sizeof ( CF2_StemHintRec ) );
     cf2_arrstack_init( &vStemHintArray,
                        memory,
                        error,
                        sizeof ( CF2_StemHintRec ) );
 
     /* initialize CF2_StemHint arrays */
     cf2_hintmask_init( &hintMask, error );
 
     /* initialize path map to manage drawing operations */
 
     /* Note: last 4 params are used to handle `MoveToPermissive', which */
     /*       may need to call `hintMap.Build'                           */
     /* TODO: MoveToPermissive is gone; are these still needed?          */
     cf2_glyphpath_init( &glyphPath,
                         font,
                         callbacks,
                         scaleY,
                         /* hShift, */
                         &hStemHintArray,
                         &vStemHintArray,
                         &hintMask,
                         hintOriginY,
                         &font->blues,
                         translation );
 
     /*
      * Initialize state for width parsing.  From the CFF Spec:
      *
      *   The first stack-clearing operator, which must be one of hstem,
      *   hstemhm, vstem, vstemhm, cntrmask, hintmask, hmoveto, vmoveto,
      *   rmoveto, or endchar, takes an additional argument - the width (as
      *   described earlier), which may be expressed as zero or one numeric
      *   argument.
      *
      * What we implement here uses the first validly specified width, but
      * does not detect errors for specifying more than one width.
      *
      * If one of the above operators occurs without explicitly specifying
      * a width, we assume the default width.
      *
      * CFF2 charstrings always return the default width (0).
      *
      */
     haveWidth = font->isCFF2 ? TRUE : FALSE;
     *width    = cf2_getDefaultWidthX( decoder );
 
     /*
      * Note: At this point, all pointers to resources must be NULL
      *       and all local objects must be initialized.
      *       There must be no branches to `exit:' above this point.
      *
      */
 
     /* allocate an operand stack */
     stackSize = font->isCFF2 ? cf2_getMaxstack( decoder )
                              : CF2_OPERAND_STACK_SIZE;
     opStack   = cf2_stack_init( memory, error, stackSize );
 
     if ( !opStack )
     {
       lastError = FT_THROW( Out_Of_Memory );
       goto exit;
     }
 
     /* initialize subroutine stack by placing top level charstring as */
     /* first element (max depth plus one for the charstring)          */
     /* Note: Caller owns and must finalize the first charstring.      */
     /*       Our copy of it does not change that requirement.         */
     cf2_arrstack_setCount( &subrStack, CF2_MAX_SUBR + 1 );
 
     charstring  = (CF2_Buffer)cf2_arrstack_getBuffer( &subrStack );
     *charstring = *buf;    /* structure copy */
 
     charstringIndex = 0;       /* entry is valid now */
 
     /* catch errors so far */
     if ( *error )
       goto exit;
 
     /* main interpreter loop */
     while ( 1 )
     {
       if ( cf2_buf_isEnd( charstring ) )
       {
         /* If we've reached the end of the charstring, simulate a */
         /* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
         /* We do this for both CFF and CFF2.                      */
         if ( charstringIndex )
           op1 = cf2_cmdRETURN;  /* end of buffer for subroutine */
         else
           op1 = cf2_cmdENDCHAR; /* end of buffer for top level charstring */
       }
       else
       {
         op1 = (FT_Byte)cf2_buf_readByte( charstring );
 
         /* Explicit RETURN and ENDCHAR in CFF2 should be ignored. */
         /* Note: Trace message will report 0 instead of 11 or 14. */
         if ( ( op1 == cf2_cmdRETURN || op1 == cf2_cmdENDCHAR ) &&
              font->isCFF2                                      )
           op1 = cf2_cmdRESERVED_0;
       }
 
       /* check for errors once per loop */
       if ( *error )
         goto exit;
 
       instructionLimit--;
       if ( instructionLimit == 0 )
       {
         lastError = FT_THROW( Invalid_Glyph_Format );
         goto exit;
       }
 
       switch( op1 )
       {
       case cf2_cmdRESERVED_0:
       case cf2_cmdRESERVED_2:
       case cf2_cmdRESERVED_9:
       case cf2_cmdRESERVED_13:
-      case cf2_cmdRESERVED_15:
-      case cf2_cmdRESERVED_16:
       case cf2_cmdRESERVED_17:
         /* we may get here if we have a prior error */
         FT_TRACE4(( " unknown op (%d)\n", op1 ));
         break;
 
+      case cf2_cmdVSINDEX:
+        FT_TRACE4(( " vsindex\n" ));
+
+        if ( !font->isCFF2 )
+          break;    /* clear stack & ignore */
+
+        if ( font->blend.usedBV )
+        {
+          /* vsindex not allowed after blend */
+          lastError = FT_THROW( Invalid_Glyph_Format );
+          goto exit;
+        }
+
+        font->vsindex = (FT_UInt)cf2_stack_popInt( opStack );
+        break;
+
+      case cf2_cmdBLEND:
+        {
+          FT_UInt  numBlends;
+
+
+          FT_TRACE4(( " blend\n" ));
+
+          if ( !font->isCFF2 )
+            break;    /* clear stack & ignore */
+
+          /* check cached blend vector */
+          if ( cff_blend_check_vector( &font->blend,
+                                       font->vsindex,
+                                       font->lenNDV,
+                                       font->NDV ) )
+          {
+            lastError = cff_blend_build_vector( &font->blend,
+                                                font->vsindex,
+                                                font->lenNDV,
+                                                font->NDV );
+            if ( lastError )
+              goto exit;
+          }
+
+          /* do the blend */
+          numBlends = (FT_UInt)cf2_stack_popInt( opStack );
+          cf2_doBlend( &font->blend, opStack, numBlends );
+
+          font->blend.usedBV = TRUE;
+        }
+        continue;     /* do not clear the stack */
+
       case cf2_cmdHSTEMHM:
       case cf2_cmdHSTEM:
         FT_TRACE4(( op1 == cf2_cmdHSTEMHM ? " hstemhm\n" : " hstem\n" ));
 
         /* never add hints after the mask is computed */
         if ( cf2_hintmask_isValid( &hintMask ) )
         {
           FT_TRACE4(( "cf2_interpT2CharString:"
                       " invalid horizontal hint mask\n" ));
           break;
         }
 
         cf2_doStems( font,
                      opStack,
                      &hStemHintArray,
                      width,
                      &haveWidth,
                      0 );
 
         if ( font->decoder->width_only )
           goto exit;
 
         break;
 
       case cf2_cmdVSTEMHM:
       case cf2_cmdVSTEM:
         FT_TRACE4(( op1 == cf2_cmdVSTEMHM ? " vstemhm\n" : " vstem\n" ));
 
         /* never add hints after the mask is computed */
         if ( cf2_hintmask_isValid( &hintMask ) )
         {
           FT_TRACE4(( "cf2_interpT2CharString:"
                       " invalid vertical hint mask\n" ));
           break;
         }
 
         cf2_doStems( font,
                      opStack,
                      &vStemHintArray,
                      width,
                      &haveWidth,
                      0 );
 
         if ( font->decoder->width_only )
           goto exit;
 
         break;
 
       case cf2_cmdVMOVETO:
         FT_TRACE4(( " vmoveto\n" ));
 
         if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
           *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
 
         /* width is defined or default after this */
         haveWidth = TRUE;
 
         if ( font->decoder->width_only )
           goto exit;
 
         curY += cf2_stack_popFixed( opStack );
 
         cf2_glyphpath_moveTo( &glyphPath, curX, curY );
 
         break;
 
       case cf2_cmdRLINETO:
         {
           CF2_UInt  index;
           CF2_UInt  count = cf2_stack_count( opStack );
 
 
           FT_TRACE4(( " rlineto\n" ));
 
           for ( index = 0; index < count; index += 2 )
           {
             curX += cf2_stack_getReal( opStack, index + 0 );
             curY += cf2_stack_getReal( opStack, index + 1 );
 
             cf2_glyphpath_lineTo( &glyphPath, curX, curY );
           }
 
           cf2_stack_clear( opStack );
         }
         continue; /* no need to clear stack again */
 
       case cf2_cmdHLINETO:
       case cf2_cmdVLINETO:
         {
           CF2_UInt  index;
           CF2_UInt  count = cf2_stack_count( opStack );
 
           FT_Bool  isX = op1 == cf2_cmdHLINETO;
 
 
           FT_TRACE4(( isX ? " hlineto\n" : " vlineto\n" ));
 
           for ( index = 0; index < count; index++ )
           {
             CF2_Fixed  v = cf2_stack_getReal( opStack, index );
 
 
             if ( isX )
               curX += v;
             else
               curY += v;
 
             isX = !isX;
 
             cf2_glyphpath_lineTo( &glyphPath, curX, curY );
           }
 
           cf2_stack_clear( opStack );
         }
         continue;
 
       case cf2_cmdRCURVELINE:
       case cf2_cmdRRCURVETO:
         {
           CF2_UInt  count = cf2_stack_count( opStack );
           CF2_UInt  index = 0;
 
 
           FT_TRACE4(( op1 == cf2_cmdRCURVELINE ? " rcurveline\n"
                                                : " rrcurveto\n" ));
 
           while ( index + 6 <= count )
           {
             CF2_Fixed  x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
             CF2_Fixed  y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
             CF2_Fixed  x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
             CF2_Fixed  y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
             CF2_Fixed  x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
             CF2_Fixed  y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;
 
 
             cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );
 
             curX   = x3;
             curY   = y3;
             index += 6;
           }
 
           if ( op1 == cf2_cmdRCURVELINE )
           {
             curX += cf2_stack_getReal( opStack, index + 0 );
             curY += cf2_stack_getReal( opStack, index + 1 );
 
             cf2_glyphpath_lineTo( &glyphPath, curX, curY );
           }
 
           cf2_stack_clear( opStack );
         }
         continue; /* no need to clear stack again */
 
       case cf2_cmdCALLGSUBR:
       case cf2_cmdCALLSUBR:
         {
           CF2_Int  subrNum;
 
 
           FT_TRACE4(( op1 == cf2_cmdCALLGSUBR ? " callgsubr"
                                               : " callsubr" ));
 
           if ( charstringIndex > CF2_MAX_SUBR )
           {
             /* max subr plus one for charstring */
             lastError = FT_THROW( Invalid_Glyph_Format );
             goto exit;                      /* overflow of stack */
           }
 
           /* push our current CFF charstring region on subrStack */
           charstring = (CF2_Buffer)
                          cf2_arrstack_getPointer(
                            &subrStack,
                            (size_t)charstringIndex + 1 );
 
           /* set up the new CFF region and pointer */
           subrNum = cf2_stack_popInt( opStack );
 
           switch ( op1 )
           {
           case cf2_cmdCALLGSUBR:
             FT_TRACE4(( " (idx %d, entering level %d)\n",
                         subrNum + decoder->globals_bias,
                         charstringIndex + 1 ));
 
             if ( cf2_initGlobalRegionBuffer( decoder,
                                              subrNum,
                                              charstring ) )
             {
               lastError = FT_THROW( Invalid_Glyph_Format );
               goto exit;  /* subroutine lookup or stream error */
             }
             break;
 
           default:
             /* cf2_cmdCALLSUBR */
             FT_TRACE4(( " (idx %d, entering level %d)\n",
                         subrNum + decoder->locals_bias,
                         charstringIndex + 1 ));
 
             if ( cf2_initLocalRegionBuffer( decoder,
                                             subrNum,
                                             charstring ) )
             {
               lastError = FT_THROW( Invalid_Glyph_Format );
               goto exit;  /* subroutine lookup or stream error */
             }
           }
 
           charstringIndex += 1;       /* entry is valid now */
         }
         continue; /* do not clear the stack */
 
       case cf2_cmdRETURN:
         FT_TRACE4(( " return (leaving level %d)\n", charstringIndex ));
 
         if ( charstringIndex < 1 )
         {
           /* Note: cannot return from top charstring */
           lastError = FT_THROW( Invalid_Glyph_Format );
           goto exit;                      /* underflow of stack */
         }
 
         /* restore position in previous charstring */
         charstring = (CF2_Buffer)
                        cf2_arrstack_getPointer(
                          &subrStack,
                          (CF2_UInt)--charstringIndex );
         continue;     /* do not clear the stack */
 
       case cf2_cmdESC:
         {
           FT_Byte  op2 = (FT_Byte)cf2_buf_readByte( charstring );
 
 
           /* first switch for 2-byte operators handles CFF2      */
           /* and opcodes that are reserved for both CFF and CFF2 */
           switch ( op2 )
           {
           case cf2_escHFLEX:
             {
               static const FT_Bool  readFromStack[12] =
               {
                 TRUE /* dx1 */, FALSE /* dy1 */,
                 TRUE /* dx2 */, TRUE  /* dy2 */,
                 TRUE /* dx3 */, FALSE /* dy3 */,
                 TRUE /* dx4 */, FALSE /* dy4 */,
                 TRUE /* dx5 */, FALSE /* dy5 */,
                 TRUE /* dx6 */, FALSE /* dy6 */
               };
 
 
               FT_TRACE4(( " hflex\n" ));
 
               cf2_doFlex( opStack,
                           &curX,
                           &curY,
                           &glyphPath,
                           readFromStack,
                           FALSE /* doConditionalLastRead */ );
             }
             continue;
 
           case cf2_escFLEX:
             {
               static const FT_Bool  readFromStack[12] =
               {
                 TRUE /* dx1 */, TRUE /* dy1 */,
                 TRUE /* dx2 */, TRUE /* dy2 */,
                 TRUE /* dx3 */, TRUE /* dy3 */,
                 TRUE /* dx4 */, TRUE /* dy4 */,
                 TRUE /* dx5 */, TRUE /* dy5 */,
                 TRUE /* dx6 */, TRUE /* dy6 */
               };
 
 
               FT_TRACE4(( " flex\n" ));
 
               cf2_doFlex( opStack,
                           &curX,
                           &curY,
                           &glyphPath,
                           readFromStack,
                           FALSE /* doConditionalLastRead */ );
             }
             break;      /* TODO: why is this not a continue? */
 
           case cf2_escHFLEX1:
             {
               static const FT_Bool  readFromStack[12] =
               {
                 TRUE /* dx1 */, TRUE  /* dy1 */,
                 TRUE /* dx2 */, TRUE  /* dy2 */,
                 TRUE /* dx3 */, FALSE /* dy3 */,
                 TRUE /* dx4 */, FALSE /* dy4 */,
                 TRUE /* dx5 */, TRUE  /* dy5 */,
                 TRUE /* dx6 */, FALSE /* dy6 */
               };
 
 
               FT_TRACE4(( " hflex1\n" ));
 
               cf2_doFlex( opStack,
                           &curX,
                           &curY,
                           &glyphPath,
                           readFromStack,
                           FALSE /* doConditionalLastRead */ );
             }
             continue;
 
           case cf2_escFLEX1:
             {
               static const FT_Bool  readFromStack[12] =
               {
                 TRUE  /* dx1 */, TRUE  /* dy1 */,
                 TRUE  /* dx2 */, TRUE  /* dy2 */,
                 TRUE  /* dx3 */, TRUE  /* dy3 */,
                 TRUE  /* dx4 */, TRUE  /* dy4 */,
                 TRUE  /* dx5 */, TRUE  /* dy5 */,
                 FALSE /* dx6 */, FALSE /* dy6 */
               };
 
 
               FT_TRACE4(( " flex1\n" ));
 
               cf2_doFlex( opStack,
                           &curX,
                           &curY,
                           &glyphPath,
                           readFromStack,
                           TRUE /* doConditionalLastRead */ );
             }
             continue;
 
           /* these opcodes are reserved in both CFF & CFF2 */
           case cf2_escRESERVED_1:
           case cf2_escRESERVED_2:
           case cf2_escRESERVED_6:
           case cf2_escRESERVED_7:
           case cf2_escRESERVED_8:
           case cf2_escRESERVED_13:
           case cf2_escRESERVED_16:
           case cf2_escRESERVED_17:
           case cf2_escRESERVED_19:
           case cf2_escRESERVED_25:
           case cf2_escRESERVED_31:
           case cf2_escRESERVED_32:
           case cf2_escRESERVED_33:
             FT_TRACE4(( " unknown op (12, %d)\n", op2 ));
             break;
 
           default:
             {
               if ( font->isCFF2 || op2 >= cf2_escRESERVED_38 )
                 FT_TRACE4(( " unknown op (12, %d)\n", op2 ));
               else
               {
                 /* second switch for 2-byte operators handles just CFF */
                 switch ( op2 )
                 {
 
                 case cf2_escDOTSECTION:
                   /* something about `flip type of locking' -- ignore it */
                   FT_TRACE4(( " dotsection\n" ));
 
                   break;
 
                 case cf2_escAND:
                   {
                     CF2_F16Dot16  arg1;
                     CF2_F16Dot16  arg2;
 
 
                     FT_TRACE4(( " and\n" ));
 
                     arg2 = cf2_stack_popFixed( opStack );
                     arg1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushInt( opStack, arg1 && arg2 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escOR:
                   {
                     CF2_F16Dot16  arg1;
                     CF2_F16Dot16  arg2;
 
 
                     FT_TRACE4(( " or\n" ));
 
                     arg2 = cf2_stack_popFixed( opStack );
                     arg1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushInt( opStack, arg1 || arg2 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escNOT:
                   {
                     CF2_F16Dot16  arg;
 
 
                     FT_TRACE4(( " not\n" ));
 
                     arg = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushInt( opStack, !arg );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escABS:
                   {
                     CF2_F16Dot16  arg;
 
 
                     FT_TRACE4(( " abs\n" ));
 
                     arg = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, FT_ABS( arg ) );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escADD:
                   {
                     CF2_F16Dot16  summand1;
                     CF2_F16Dot16  summand2;
 
 
                     FT_TRACE4(( " add\n" ));
 
                     summand2 = cf2_stack_popFixed( opStack );
                     summand1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, summand1 + summand2 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escSUB:
                   {
                     CF2_F16Dot16  minuend;
                     CF2_F16Dot16  subtrahend;
 
 
                     FT_TRACE4(( " sub\n" ));
 
                     subtrahend = cf2_stack_popFixed( opStack );
                     minuend    = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, minuend - subtrahend );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escDIV:
                   {
                     CF2_F16Dot16  dividend;
                     CF2_F16Dot16  divisor;
 
 
                     FT_TRACE4(( " div\n" ));
 
                     divisor  = cf2_stack_popFixed( opStack );
                     dividend = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, FT_DivFix( dividend, divisor ) );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escNEG:
                   {
                     CF2_F16Dot16  arg;
 
 
                     FT_TRACE4(( " neg\n" ));
 
                     arg = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, -arg );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escEQ:
                   {
                     CF2_F16Dot16  arg1;
                     CF2_F16Dot16  arg2;
 
 
                     FT_TRACE4(( " eq\n" ));
 
                     arg2 = cf2_stack_popFixed( opStack );
                     arg1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushInt( opStack, arg1 == arg2 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escDROP:
                   FT_TRACE4(( " drop\n" ));
 
                   (void)cf2_stack_popFixed( opStack );
                   continue; /* do not clear the stack */
 
                 case cf2_escPUT:
                   {
                     CF2_F16Dot16  val;
                     CF2_Int       idx;
 
 
                     FT_TRACE4(( " put\n" ));
 
                     idx = cf2_stack_popInt( opStack );
                     val = cf2_stack_popFixed( opStack );
 
                     if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                       storage[idx] = val;
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escGET:
                   {
                     CF2_Int  idx;
 
 
                     FT_TRACE4(( " get\n" ));
 
                     idx = cf2_stack_popInt( opStack );
 
                     if ( idx >= 0 && idx < CF2_STORAGE_SIZE )
                     cf2_stack_pushFixed( opStack, storage[idx] );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escIFELSE:
                   {
                     CF2_F16Dot16  arg1;
                     CF2_F16Dot16  arg2;
                     CF2_F16Dot16  cond1;
                     CF2_F16Dot16  cond2;
 
 
                     FT_TRACE4(( " ifelse\n" ));
 
                     cond2 = cf2_stack_popFixed( opStack );
                     cond1 = cf2_stack_popFixed( opStack );
                     arg2  = cf2_stack_popFixed( opStack );
                     arg1  = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, cond1 <= cond2 ? arg1 : arg2 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escRANDOM: /* in spec */
                   FT_TRACE4(( " random\n" ));
 
                   CF2_FIXME;
                   break;
 
                 case cf2_escMUL:
                   {
                     CF2_F16Dot16  factor1;
                     CF2_F16Dot16  factor2;
 
 
                     FT_TRACE4(( " mul\n" ));
 
                     factor2 = cf2_stack_popFixed( opStack );
                     factor1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, FT_MulFix( factor1, factor2 ) );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escSQRT:
                   {
                     CF2_F16Dot16  arg;
 
 
                     FT_TRACE4(( " sqrt\n" ));
 
                     arg = cf2_stack_popFixed( opStack );
                     if ( arg > 0 )
                     {
                       FT_Fixed  root = arg;
                       FT_Fixed  new_root;
 
 
                       /* Babylonian method */
                       for (;;)
                       {
                         new_root = ( root + FT_DivFix( arg, root ) + 1 ) >> 1;
                         if ( new_root == root )
                           break;
                         root = new_root;
                       }
                       arg = new_root;
                     }
                     else
                       arg = 0;
 
                     cf2_stack_pushFixed( opStack, arg );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escDUP:
                   {
                     CF2_F16Dot16  arg;
 
 
                     FT_TRACE4(( " dup\n" ));
 
                     arg = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, arg );
                     cf2_stack_pushFixed( opStack, arg );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escEXCH:
                   {
                     CF2_F16Dot16  arg1;
                     CF2_F16Dot16  arg2;
 
 
                     FT_TRACE4(( " exch\n" ));
 
                     arg2 = cf2_stack_popFixed( opStack );
                     arg1 = cf2_stack_popFixed( opStack );
 
                     cf2_stack_pushFixed( opStack, arg2 );
                     cf2_stack_pushFixed( opStack, arg1 );
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escINDEX:
                   {
                     CF2_Int   idx;
                     CF2_UInt  size;
 
 
                     FT_TRACE4(( " index\n" ));
 
                     idx  = cf2_stack_popInt( opStack );
                     size = cf2_stack_count( opStack );
 
                     if ( size > 0 )
                     {
                       /* for `cf2_stack_getReal', index 0 is bottom of stack */
                       CF2_UInt  gr_idx;
 
 
                       if ( idx < 0 )
                         gr_idx = size - 1;
                       else if ( (CF2_UInt)idx >= size )
                         gr_idx = 0;
                       else
                         gr_idx = size - 1 - (CF2_UInt)idx;
 
                       cf2_stack_pushFixed( opStack,
                                            cf2_stack_getReal( opStack, gr_idx ) );
                     }
                   }
                   continue; /* do not clear the stack */
 
                 case cf2_escROLL:
                   {
                     CF2_Int  idx;
                     CF2_Int  count;
 
 
                     FT_TRACE4(( " roll\n" ));
 
                     idx   = cf2_stack_popInt( opStack );
                     count = cf2_stack_popInt( opStack );
 
                     cf2_stack_roll( opStack, count, idx );
                   }
                   continue; /* do not clear the stack */
 
                 } /* end of 2nd switch checking op2 */
               }
             }
           } /* end of 1st switch checking op2 */
         } /* case cf2_cmdESC */
 
         break;
 
       case cf2_cmdENDCHAR:
         FT_TRACE4(( " endchar\n" ));
 
         if ( cf2_stack_count( opStack ) == 1 ||
              cf2_stack_count( opStack ) == 5 )
         {
           if ( !haveWidth )
             *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
         }
 
         /* width is defined or default after this */
         haveWidth = TRUE;
 
         if ( font->decoder->width_only )
           goto exit;
 
         /* close path if still open */
         cf2_glyphpath_closeOpenPath( &glyphPath );
 
         /* disable seac for CFF2 (charstring ending with args on stack) */
         if ( !font->isCFF2 && cf2_stack_count( opStack ) > 1 )
         {
           /* must be either 4 or 5 --                       */
           /* this is a (deprecated) implied `seac' operator */
 
           CF2_Int        achar;
           CF2_Int        bchar;
           CF2_BufferRec  component;
           CF2_Fixed      dummyWidth;   /* ignore component width */
           FT_Error       error2;
 
 
           if ( doingSeac )
           {
             lastError = FT_THROW( Invalid_Glyph_Format );
             goto exit;      /* nested seac */
           }
 
           achar = cf2_stack_popInt( opStack );
           bchar = cf2_stack_popInt( opStack );
 
           curY = cf2_stack_popFixed( opStack );
           curX = cf2_stack_popFixed( opStack );
 
           error2 = cf2_getSeacComponent( decoder, achar, &component );
           if ( error2 )
           {
             lastError = error2;      /* pass FreeType error through */
             goto exit;
           }
           cf2_interpT2CharString( font,
                                   &component,
                                   callbacks,
                                   translation,
                                   TRUE,
                                   curX,
                                   curY,
                                   &dummyWidth );
           cf2_freeSeacComponent( decoder, &component );
 
           error2 = cf2_getSeacComponent( decoder, bchar, &component );
           if ( error2 )
           {
             lastError = error2;      /* pass FreeType error through */
             goto exit;
           }
           cf2_interpT2CharString( font,
                                   &component,
                                   callbacks,
                                   translation,
                                   TRUE,
                                   0,
                                   0,
                                   &dummyWidth );
           cf2_freeSeacComponent( decoder, &component );
         }
         goto exit;
 
       case cf2_cmdCNTRMASK:
       case cf2_cmdHINTMASK:
         /* the final \n in the tracing message gets added in      */
         /* `cf2_hintmask_read' (which also traces the mask bytes) */
         FT_TRACE4(( op1 == cf2_cmdCNTRMASK ? " cntrmask" : " hintmask" ));
 
         /* never add hints after the mask is computed */
         if ( cf2_stack_count( opStack ) > 1    &&
              cf2_hintmask_isValid( &hintMask ) )
         {
           FT_TRACE4(( "cf2_interpT2CharString: invalid hint mask\n" ));
           break;
         }
 
         /* if there are arguments on the stack, there this is an */
         /* implied cf2_cmdVSTEMHM                                */
         cf2_doStems( font,
                      opStack,
                      &vStemHintArray,
                      width,
                      &haveWidth,
                      0 );
 
         if ( font->decoder->width_only )
           goto exit;
 
         if ( op1 == cf2_cmdHINTMASK )
         {
           /* consume the hint mask bytes which follow the operator */
           cf2_hintmask_read( &hintMask,
                              charstring,
                              cf2_arrstack_size( &hStemHintArray ) +
                                cf2_arrstack_size( &vStemHintArray ) );
         }
         else
         {
           /*
            * Consume the counter mask bytes which follow the operator:
            * Build a temporary hint map, just to place and lock those
            * stems participating in the counter mask.  These are most
            * likely the dominant hstems, and are grouped together in a
            * few counter groups, not necessarily in correspondence
            * with the hint groups.  This reduces the chances of
            * conflicts between hstems that are initially placed in
            * separate hint groups and then brought together.  The
            * positions are copied back to `hStemHintArray', so we can
            * discard `counterMask' and `counterHintMap'.
            *
            */
           CF2_HintMapRec   counterHintMap;
           CF2_HintMaskRec  counterMask;
 
 
           cf2_hintmap_init( &counterHintMap,
                             font,
                             &glyphPath.initialHintMap,
                             &glyphPath.hintMoves,
                             scaleY );
           cf2_hintmask_init( &counterMask, error );
 
           cf2_hintmask_read( &counterMask,
                              charstring,
                              cf2_arrstack_size( &hStemHintArray ) +
                                cf2_arrstack_size( &vStemHintArray ) );
           cf2_hintmap_build( &counterHintMap,
                              &hStemHintArray,
                              &vStemHintArray,
                              &counterMask,
                              0,
                              FALSE );
         }
         break;
 
       case cf2_cmdRMOVETO:
         FT_TRACE4(( " rmoveto\n" ));
 
         if ( cf2_stack_count( opStack ) > 2 && !haveWidth )
           *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
 
         /* width is defined or default after this */
         haveWidth = TRUE;
 
         if ( font->decoder->width_only )
           goto exit;
 
         curY += cf2_stack_popFixed( opStack );
         curX += cf2_stack_popFixed( opStack );
 
         cf2_glyphpath_moveTo( &glyphPath, curX, curY );
 
         break;
 
       case cf2_cmdHMOVETO:
         FT_TRACE4(( " hmoveto\n" ));
 
         if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
           *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
 
         /* width is defined or default after this */
         haveWidth = TRUE;
 
         if ( font->decoder->width_only )
           goto exit;
 
         curX += cf2_stack_popFixed( opStack );
 
         cf2_glyphpath_moveTo( &glyphPath, curX, curY );
 
         break;
 
       case cf2_cmdRLINECURVE:
         {
           CF2_UInt  count = cf2_stack_count( opStack );
           CF2_UInt  index = 0;
 
 
           FT_TRACE4(( " rlinecurve\n" ));
 
           while ( index + 6 < count )
           {
             curX += cf2_stack_getReal( opStack, index + 0 );
             curY += cf2_stack_getReal( opStack, index + 1 );
 
             cf2_glyphpath_lineTo( &glyphPath, curX, curY );
             index += 2;
           }
 
           while ( index < count )
           {
             CF2_Fixed  x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
             CF2_Fixed  y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
             CF2_Fixed  x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
             CF2_Fixed  y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
             CF2_Fixed  x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
             CF2_Fixed  y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;
 
 
             cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );
 
             curX   = x3;
             curY   = y3;
             index += 6;
           }
 
           cf2_stack_clear( opStack );
         }
         continue; /* no need to clear stack again */
 
       case cf2_cmdVVCURVETO:
         {
           CF2_UInt  count, count1 = cf2_stack_count( opStack );
           CF2_UInt  index = 0;
 
 
           /* if `cf2_stack_count' isn't of the form 4n or 4n+1, */
           /* we enforce it by clearing the second bit           */
           /* (and sorting the stack indexing to suit)           */
           count  = count1 & ~2U;
           index += count1 - count;
 
           FT_TRACE4(( " vvcurveto\n" ));
 
           while ( index < count )
           {
             CF2_Fixed  x1, y1, x2, y2, x3, y3;
 
 
             if ( ( count - index ) & 1 )
             {
               x1 = cf2_stack_getReal( opStack, index ) + curX;
 
               ++index;
             }
             else
               x1 = curX;
 
             y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
             x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
             y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
             x3 = x2;
             y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;
 
             cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );
 
             curX   = x3;
             curY   = y3;
             index += 4;
           }
 
           cf2_stack_clear( opStack );
         }
         continue; /* no need to clear stack again */
 
       case cf2_cmdHHCURVETO:
         {
           CF2_UInt  count, count1 = cf2_stack_count( opStack );
           CF2_UInt  index = 0;
 
 
           /* if `cf2_stack_count' isn't of the form 4n or 4n+1, */
           /* we enforce it by clearing the second bit           */
           /* (and sorting the stack indexing to suit)           */
           count  = count1 & ~2U;
           index += count1 - count;
 
           FT_TRACE4(( " hhcurveto\n" ));
 
           while ( index < count )
           {
             CF2_Fixed  x1, y1, x2, y2, x3, y3;
 
 
             if ( ( count - index ) & 1 )
             {
               y1 = cf2_stack_getReal( opStack, index ) + curY;
 
               ++index;
             }
             else
               y1 = curY;
 
             x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
             x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
             y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
             x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;
             y3 = y2;
 
             cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );
 
             curX   = x3;
             curY   = y3;
             index += 4;
           }
 
           cf2_stack_clear( opStack );
         }
         continue; /* no need to clear stack again */
 
       case cf2_cmdVHCURVETO:
       case cf2_cmdHVCURVETO:
         {
           CF2_UInt  count, count1 = cf2_stack_count( opStack );
           CF2_UInt  index = 0;
 
           FT_Bool  alternate = op1 == cf2_cmdHVCURVETO;
 
 
           /* if `cf2_stack_count' isn't of the form 8n, 8n+1, */
           /* 8n+4, or 8n+5, we enforce it by clearing the     */
           /* second bit                                       */
           /* (and sorting the stack indexing to suit)         */
           count  = count1 & ~2U;
           index += count1 - count;
 
           FT_TRACE4(( alternate ? " hvcurveto\n" : " vhcurveto\n" ));
 
           while ( index < count )
           {
             CF2_Fixed x1, x2, x3, y1, y2, y3;
 
 
             if ( alternate )
             {
               x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
               y1 = curY;
               x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
               y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
               y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;
 
               if ( count - index == 5 )
               {
                 x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
 
                 ++index;
               }
               else
                 x3 = x2;
 
               alternate = FALSE;
             }
             else
             {
               x1 = curX;
               y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
               x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
               y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
               x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;
 
               if ( count - index == 5 )
               {
                 y3 = cf2_stack_getReal( opStack, index + 4 ) + y2;
 
                 ++index;
               }
               else
                 y3 = y2;
 
               alternate = TRUE;
             }
 
             cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );
 
             curX   = x3;
             curY   = y3;
             index += 4;
           }
 
           cf2_stack_clear( opStack );
         }
         continue;     /* no need to clear stack again */
 
       case cf2_cmdEXTENDEDNMBR:
         {
           CF2_Int  v;
 
           CF2_Int  byte1 = cf2_buf_readByte( charstring );
           CF2_Int  byte2 = cf2_buf_readByte( charstring );
 
 
           v = (FT_Short)( ( byte1 << 8 ) |
                             byte2        );
 
           FT_TRACE4(( " %d", v ));
 
           cf2_stack_pushInt( opStack, v );
         }
         continue;
 
       default:
         /* numbers */
         {
           if ( /* op1 >= 32 && */ op1 <= 246 )
           {
             CF2_Int  v;
 
 
             v = op1 - 139;
 
             FT_TRACE4(( " %d", v ));
 
             /* -107 .. 107 */
             cf2_stack_pushInt( opStack, v );
           }
 
           else if ( /* op1 >= 247 && */ op1 <= 250 )
           {
             CF2_Int  v;
 
 
             v  = op1;
             v -= 247;
             v *= 256;
             v += cf2_buf_readByte( charstring );
             v += 108;
 
             FT_TRACE4(( " %d", v ));
 
             /* 108 .. 1131 */
             cf2_stack_pushInt( opStack, v );
           }
 
           else if ( /* op1 >= 251 && */ op1 <= 254 )
           {
             CF2_Int  v;
 
 
             v  = op1;
             v -= 251;
             v *= 256;
             v += cf2_buf_readByte( charstring );
             v  = -v - 108;
 
             FT_TRACE4(( " %d", v ));
 
             /* -1131 .. -108 */
             cf2_stack_pushInt( opStack, v );
           }
 
           else /* op1 == 255 */
           {
             CF2_Fixed  v;
 
             FT_UInt32  byte1 = (FT_UInt32)cf2_buf_readByte( charstring );
             FT_UInt32  byte2 = (FT_UInt32)cf2_buf_readByte( charstring );
             FT_UInt32  byte3 = (FT_UInt32)cf2_buf_readByte( charstring );
             FT_UInt32  byte4 = (FT_UInt32)cf2_buf_readByte( charstring );
 
 
             v = (CF2_Fixed)( ( byte1 << 24 ) |
                              ( byte2 << 16 ) |
                              ( byte3 <<  8 ) |
                                byte4         );
 
             FT_TRACE4(( " %.2f", v / 65536.0 ));
 
             cf2_stack_pushFixed( opStack, v );
           }
         }
         continue;   /* don't clear stack */
 
       } /* end of switch statement checking `op1' */
 
       cf2_stack_clear( opStack );
 
     } /* end of main interpreter loop */
 
     /* we get here if the charstring ends without cf2_cmdENDCHAR */
     FT_TRACE4(( "cf2_interpT2CharString:"
                 "  charstring ends without ENDCHAR\n" ));
 
   exit:
     /* check whether last error seen is also the first one */
     cf2_setError( error, lastError );
 
     if ( *error )
       FT_TRACE4(( "charstring error %d\n", *error ));
 
     /* free resources from objects we've used */
     cf2_glyphpath_finalize( &glyphPath );
     cf2_arrstack_finalize( &vStemHintArray );
     cf2_arrstack_finalize( &hStemHintArray );
     cf2_arrstack_finalize( &subrStack );
     cf2_stack_free( opStack );
 
     FT_TRACE4(( "\n" ));
 
     return;
   }
 
 
 /* END */
diff --git a/src/cff/cffload.c b/src/cff/cffload.c
index e61dfc2b0..0698c8f23 100644
--- a/src/cff/cffload.c
+++ b/src/cff/cffload.c
@@ -1,1905 +1,2394 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cffload.c                                                              */
 /*                                                                         */
 /*    OpenType and CFF data/program tables loader (body).                  */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_INTERNAL_OBJECTS_H
 #include FT_INTERNAL_STREAM_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_TYPE1_TABLES_H
 
 #include "cffload.h"
 #include "cffparse.h"
 
 #include "cfferrs.h"
 
 
 #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )
 
 
 #if 1
 
   static const FT_UShort  cff_isoadobe_charset[229] =
   {
       0,   1,   2,   3,   4,   5,   6,   7,
       8,   9,  10,  11,  12,  13,  14,  15,
      16,  17,  18,  19,  20,  21,  22,  23,
      24,  25,  26,  27,  28,  29,  30,  31,
      32,  33,  34,  35,  36,  37,  38,  39,
      40,  41,  42,  43,  44,  45,  46,  47,
      48,  49,  50,  51,  52,  53,  54,  55,
      56,  57,  58,  59,  60,  61,  62,  63,
      64,  65,  66,  67,  68,  69,  70,  71,
      72,  73,  74,  75,  76,  77,  78,  79,
      80,  81,  82,  83,  84,  85,  86,  87,
      88,  89,  90,  91,  92,  93,  94,  95,
      96,  97,  98,  99, 100, 101, 102, 103,
     104, 105, 106, 107, 108, 109, 110, 111,
     112, 113, 114, 115, 116, 117, 118, 119,
     120, 121, 122, 123, 124, 125, 126, 127,
     128, 129, 130, 131, 132, 133, 134, 135,
     136, 137, 138, 139, 140, 141, 142, 143,
     144, 145, 146, 147, 148, 149, 150, 151,
     152, 153, 154, 155, 156, 157, 158, 159,
     160, 161, 162, 163, 164, 165, 166, 167,
     168, 169, 170, 171, 172, 173, 174, 175,
     176, 177, 178, 179, 180, 181, 182, 183,
     184, 185, 186, 187, 188, 189, 190, 191,
     192, 193, 194, 195, 196, 197, 198, 199,
     200, 201, 202, 203, 204, 205, 206, 207,
     208, 209, 210, 211, 212, 213, 214, 215,
     216, 217, 218, 219, 220, 221, 222, 223,
     224, 225, 226, 227, 228
   };
 
   static const FT_UShort  cff_expert_charset[166] =
   {
       0,   1, 229, 230, 231, 232, 233, 234,
     235, 236, 237, 238,  13,  14,  15,  99,
     239, 240, 241, 242, 243, 244, 245, 246,
     247, 248,  27,  28, 249, 250, 251, 252,
     253, 254, 255, 256, 257, 258, 259, 260,
     261, 262, 263, 264, 265, 266, 109, 110,
     267, 268, 269, 270, 271, 272, 273, 274,
     275, 276, 277, 278, 279, 280, 281, 282,
     283, 284, 285, 286, 287, 288, 289, 290,
     291, 292, 293, 294, 295, 296, 297, 298,
     299, 300, 301, 302, 303, 304, 305, 306,
     307, 308, 309, 310, 311, 312, 313, 314,
     315, 316, 317, 318, 158, 155, 163, 319,
     320, 321, 322, 323, 324, 325, 326, 150,
     164, 169, 327, 328, 329, 330, 331, 332,
     333, 334, 335, 336, 337, 338, 339, 340,
     341, 342, 343, 344, 345, 346, 347, 348,
     349, 350, 351, 352, 353, 354, 355, 356,
     357, 358, 359, 360, 361, 362, 363, 364,
     365, 366, 367, 368, 369, 370, 371, 372,
     373, 374, 375, 376, 377, 378
   };
 
   static const FT_UShort  cff_expertsubset_charset[87] =
   {
       0,   1, 231, 232, 235, 236, 237, 238,
      13,  14,  15,  99, 239, 240, 241, 242,
     243, 244, 245, 246, 247, 248,  27,  28,
     249, 250, 251, 253, 254, 255, 256, 257,
     258, 259, 260, 261, 262, 263, 264, 265,
     266, 109, 110, 267, 268, 269, 270, 272,
     300, 301, 302, 305, 314, 315, 158, 155,
     163, 320, 321, 322, 323, 324, 325, 326,
     150, 164, 169, 327, 328, 329, 330, 331,
     332, 333, 334, 335, 336, 337, 338, 339,
     340, 341, 342, 343, 344, 345, 346
   };
 
   static const FT_UShort  cff_standard_encoding[256] =
   {
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       1,   2,   3,   4,   5,   6,   7,   8,
       9,  10,  11,  12,  13,  14,  15,  16,
      17,  18,  19,  20,  21,  22,  23,  24,
      25,  26,  27,  28,  29,  30,  31,  32,
      33,  34,  35,  36,  37,  38,  39,  40,
      41,  42,  43,  44,  45,  46,  47,  48,
      49,  50,  51,  52,  53,  54,  55,  56,
      57,  58,  59,  60,  61,  62,  63,  64,
      65,  66,  67,  68,  69,  70,  71,  72,
      73,  74,  75,  76,  77,  78,  79,  80,
      81,  82,  83,  84,  85,  86,  87,  88,
      89,  90,  91,  92,  93,  94,  95,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,  96,  97,  98,  99, 100, 101, 102,
     103, 104, 105, 106, 107, 108, 109, 110,
       0, 111, 112, 113, 114,   0, 115, 116,
     117, 118, 119, 120, 121, 122,   0, 123,
       0, 124, 125, 126, 127, 128, 129, 130,
     131,   0, 132, 133,   0, 134, 135, 136,
     137,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0, 138,   0, 139,   0,   0,   0,   0,
     140, 141, 142, 143,   0,   0,   0,   0,
       0, 144,   0,   0,   0, 145,   0,   0,
     146, 147, 148, 149,   0,   0,   0,   0
   };
 
   static const FT_UShort  cff_expert_encoding[256] =
   {
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       1, 229, 230,   0, 231, 232, 233, 234,
     235, 236, 237, 238,  13,  14,  15,  99,
     239, 240, 241, 242, 243, 244, 245, 246,
     247, 248,  27,  28, 249, 250, 251, 252,
       0, 253, 254, 255, 256, 257,   0,   0,
       0, 258,   0,   0, 259, 260, 261, 262,
       0,   0, 263, 264, 265,   0, 266, 109,
     110, 267, 268, 269,   0, 270, 271, 272,
     273, 274, 275, 276, 277, 278, 279, 280,
     281, 282, 283, 284, 285, 286, 287, 288,
     289, 290, 291, 292, 293, 294, 295, 296,
     297, 298, 299, 300, 301, 302, 303,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,
       0, 304, 305, 306,   0,   0, 307, 308,
     309, 310, 311,   0, 312,   0,   0, 312,
       0,   0, 314, 315,   0,   0, 316, 317,
     318,   0,   0,   0, 158, 155, 163, 319,
     320, 321, 322, 323, 324, 325,   0,   0,
     326, 150, 164, 169, 327, 328, 329, 330,
     331, 332, 333, 334, 335, 336, 337, 338,
     339, 340, 341, 342, 343, 344, 345, 346,
     347, 348, 349, 350, 351, 352, 353, 354,
     355, 356, 357, 358, 359, 360, 361, 362,
     363, 364, 365, 366, 367, 368, 369, 370,
     371, 372, 373, 374, 375, 376, 377, 378
   };
 
 #endif /* 1 */
 
 
   FT_LOCAL_DEF( FT_UShort )
   cff_get_standard_encoding( FT_UInt  charcode )
   {
     return (FT_UShort)( charcode < 256 ? cff_standard_encoding[charcode]
                                        : 0 );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_cffload
 
 
   /* read an offset from the index's stream current position */
   static FT_ULong
   cff_index_read_offset( CFF_Index  idx,
                          FT_Error  *errorp )
   {
     FT_Error   error;
     FT_Stream  stream = idx->stream;
     FT_Byte    tmp[4];
     FT_ULong   result = 0;
 
 
     if ( !FT_STREAM_READ( tmp, idx->off_size ) )
     {
       FT_Int  nn;
 
 
       for ( nn = 0; nn < idx->off_size; nn++ )
         result = ( result << 8 ) | tmp[nn];
     }
 
     *errorp = error;
     return result;
   }
 
 
   static FT_Error
   cff_index_init( CFF_Index  idx,
                   FT_Stream  stream,
                   FT_Bool    load,
                   FT_Bool    cff2 )
   {
     FT_Error   error;
     FT_Memory  memory = stream->memory;
     FT_UInt    count;
 
 
     FT_ZERO( idx );
 
     idx->stream = stream;
     idx->start  = FT_STREAM_POS();
 
     if ( cff2 )
     {
       if ( FT_READ_ULONG( count ) )
         goto Exit;
       idx->hdr_size = 5;
     }
     else
     {
       if ( FT_READ_USHORT( count ) )
         goto Exit;
       idx->hdr_size = 3;
     }
 
     if ( count > 0 )
     {
       FT_Byte   offsize;
       FT_ULong  size;
 
 
       /* there is at least one element; read the offset size,           */
       /* then access the offset table to compute the index's total size */
       if ( FT_READ_BYTE( offsize ) )
         goto Exit;
 
       if ( offsize < 1 || offsize > 4 )
       {
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       idx->count    = count;
       idx->off_size = offsize;
       size          = (FT_ULong)( count + 1 ) * offsize;
 
       idx->data_offset = idx->start + idx->hdr_size + size;
 
       if ( FT_STREAM_SKIP( size - offsize ) )
         goto Exit;
 
       size = cff_index_read_offset( idx, &error );
       if ( error )
         goto Exit;
 
       if ( size == 0 )
       {
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       idx->data_size = --size;
 
       if ( load )
       {
         /* load the data */
         if ( FT_FRAME_EXTRACT( size, idx->bytes ) )
           goto Exit;
       }
       else
       {
         /* skip the data */
         if ( FT_STREAM_SKIP( size ) )
           goto Exit;
       }
     }
 
   Exit:
     if ( error )
       FT_FREE( idx->offsets );
 
     return error;
   }
 
 
   static void
   cff_index_done( CFF_Index  idx )
   {
     if ( idx->stream )
     {
       FT_Stream  stream = idx->stream;
       FT_Memory  memory = stream->memory;
 
 
       if ( idx->bytes )
         FT_FRAME_RELEASE( idx->bytes );
 
       FT_FREE( idx->offsets );
       FT_ZERO( idx );
     }
   }
 
 
   static FT_Error
   cff_index_load_offsets( CFF_Index  idx )
   {
     FT_Error   error  = FT_Err_Ok;
     FT_Stream  stream = idx->stream;
     FT_Memory  memory = stream->memory;
 
 
     if ( idx->count > 0 && idx->offsets == NULL )
     {
       FT_Byte    offsize = idx->off_size;
       FT_ULong   data_size;
       FT_Byte*   p;
       FT_Byte*   p_end;
       FT_ULong*  poff;
 
 
       data_size = (FT_ULong)( idx->count + 1 ) * offsize;
 
       if ( FT_NEW_ARRAY( idx->offsets, idx->count + 1 ) ||
            FT_STREAM_SEEK( idx->start + idx->hdr_size ) ||
            FT_FRAME_ENTER( data_size )                  )
         goto Exit;
 
       poff   = idx->offsets;
       p      = (FT_Byte*)stream->cursor;
       p_end  = p + data_size;
 
       switch ( offsize )
       {
       case 1:
         for ( ; p < p_end; p++, poff++ )
           poff[0] = p[0];
         break;
 
       case 2:
         for ( ; p < p_end; p += 2, poff++ )
           poff[0] = FT_PEEK_USHORT( p );
         break;
 
       case 3:
         for ( ; p < p_end; p += 3, poff++ )
           poff[0] = FT_PEEK_UOFF3( p );
         break;
 
       default:
         for ( ; p < p_end; p += 4, poff++ )
           poff[0] = FT_PEEK_ULONG( p );
       }
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     if ( error )
       FT_FREE( idx->offsets );
 
     return error;
   }
 
 
   /* Allocate a table containing pointers to an index's elements. */
   /* The `pool' argument makes this function convert the index    */
   /* entries to C-style strings (this is, NULL-terminated).       */
   static FT_Error
   cff_index_get_pointers( CFF_Index   idx,
                           FT_Byte***  table,
                           FT_Byte**   pool,
                           FT_ULong*   pool_size )
   {
     FT_Error   error     = FT_Err_Ok;
     FT_Memory  memory    = idx->stream->memory;
 
     FT_Byte**  t         = NULL;
     FT_Byte*   new_bytes = NULL;
     FT_ULong   new_size;
 
 
     *table = NULL;
 
     if ( idx->offsets == NULL )
     {
       error = cff_index_load_offsets( idx );
       if ( error )
         goto Exit;
     }
 
     new_size = idx->data_size + idx->count;
 
     if ( idx->count > 0                                &&
          !FT_NEW_ARRAY( t, idx->count + 1 )            &&
          ( !pool || !FT_ALLOC( new_bytes, new_size ) ) )
     {
       FT_ULong  n, cur_offset;
       FT_ULong  extra = 0;
       FT_Byte*  org_bytes = idx->bytes;
 
 
       /* at this point, `idx->offsets' can't be NULL */
       cur_offset = idx->offsets[0] - 1;
 
       /* sanity check */
       if ( cur_offset != 0 )
       {
         FT_TRACE0(( "cff_index_get_pointers:"
                     " invalid first offset value %d set to zero\n",
                     cur_offset ));
         cur_offset = 0;
       }
 
       if ( !pool )
         t[0] = org_bytes + cur_offset;
       else
         t[0] = new_bytes + cur_offset;
 
       for ( n = 1; n <= idx->count; n++ )
       {
         FT_ULong  next_offset = idx->offsets[n] - 1;
 
 
         /* two sanity checks for invalid offset tables */
         if ( next_offset < cur_offset )
           next_offset = cur_offset;
         else if ( next_offset > idx->data_size )
           next_offset = idx->data_size;
 
         if ( !pool )
           t[n] = org_bytes + next_offset;
         else
         {
           t[n] = new_bytes + next_offset + extra;
 
           if ( next_offset != cur_offset )
           {
             FT_MEM_COPY( t[n - 1], org_bytes + cur_offset, t[n] - t[n - 1] );
             t[n][0] = '\0';
             t[n]   += 1;
             extra++;
           }
         }
 
         cur_offset = next_offset;
       }
       *table = t;
 
       if ( pool )
         *pool = new_bytes;
       if ( pool_size )
         *pool_size = new_size;
     }
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_index_access_element( CFF_Index  idx,
                             FT_UInt    element,
                             FT_Byte**  pbytes,
                             FT_ULong*  pbyte_len )
   {
     FT_Error  error = FT_Err_Ok;
 
 
     if ( idx && idx->count > element )
     {
       /* compute start and end offsets */
       FT_Stream  stream = idx->stream;
       FT_ULong   off1, off2 = 0;
 
 
       /* load offsets from file or the offset table */
       if ( !idx->offsets )
       {
         FT_ULong  pos = element * idx->off_size;
 
 
         if ( FT_STREAM_SEEK( idx->start + idx->hdr_size + pos ) )
           goto Exit;
 
         off1 = cff_index_read_offset( idx, &error );
         if ( error )
           goto Exit;
 
         if ( off1 != 0 )
         {
           do
           {
             element++;
             off2 = cff_index_read_offset( idx, &error );
 
           } while ( off2 == 0 && element < idx->count );
         }
       }
       else   /* use offsets table */
       {
         off1 = idx->offsets[element];
         if ( off1 )
         {
           do
           {
             element++;
             off2 = idx->offsets[element];
 
           } while ( off2 == 0 && element < idx->count );
         }
       }
 
       /* XXX: should check off2 does not exceed the end of this entry; */
       /*      at present, only truncate off2 at the end of this stream */
       if ( off2 > stream->size + 1                    ||
            idx->data_offset > stream->size - off2 + 1 )
       {
         FT_ERROR(( "cff_index_access_element:"
                    " offset to next entry (%d)"
                    " exceeds the end of stream (%d)\n",
                    off2, stream->size - idx->data_offset + 1 ));
         off2 = stream->size - idx->data_offset + 1;
       }
 
       /* access element */
       if ( off1 && off2 > off1 )
       {
         *pbyte_len = off2 - off1;
 
         if ( idx->bytes )
         {
           /* this index was completely loaded in memory, that's easy */
           *pbytes = idx->bytes + off1 - 1;
         }
         else
         {
           /* this index is still on disk/file, access it through a frame */
           if ( FT_STREAM_SEEK( idx->data_offset + off1 - 1 ) ||
                FT_FRAME_EXTRACT( off2 - off1, *pbytes )      )
             goto Exit;
         }
       }
       else
       {
         /* empty index element */
         *pbytes    = 0;
         *pbyte_len = 0;
       }
     }
     else
       error = FT_THROW( Invalid_Argument );
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_index_forget_element( CFF_Index  idx,
                             FT_Byte**  pbytes )
   {
     if ( idx->bytes == 0 )
     {
       FT_Stream  stream = idx->stream;
 
 
       FT_FRAME_RELEASE( *pbytes );
     }
   }
 
 
   /* get an entry from Name INDEX */
   FT_LOCAL_DEF( FT_String* )
   cff_index_get_name( CFF_Font  font,
                       FT_UInt   element )
   {
     CFF_Index   idx = &font->name_index;
     FT_Memory   memory;
     FT_Byte*    bytes;
     FT_ULong    byte_len;
     FT_Error    error;
     FT_String*  name = 0;
 
 
     if ( !idx->stream )  /* CFF2 does not include a name index */
       goto Exit;
 
     memory = idx->stream->memory;
 
     error = cff_index_access_element( idx, element, &bytes, &byte_len );
     if ( error )
       goto Exit;
 
     if ( !FT_ALLOC( name, byte_len + 1 ) )
     {
       if ( byte_len )
         FT_MEM_COPY( name, bytes, byte_len );
       name[byte_len] = 0;
     }
     cff_index_forget_element( idx, &bytes );
 
   Exit:
     return name;
   }
 
 
   /* get an entry from String INDEX */
   FT_LOCAL_DEF( FT_String* )
   cff_index_get_string( CFF_Font  font,
                         FT_UInt   element )
   {
     return ( element < font->num_strings )
              ? (FT_String*)font->strings[element]
              : NULL;
   }
 
 
   FT_LOCAL_DEF( FT_String* )
   cff_index_get_sid_string( CFF_Font  font,
                             FT_UInt   sid )
   {
     /* value 0xFFFFU indicates a missing dictionary entry */
     if ( sid == 0xFFFFU )
       return NULL;
 
     /* if it is not a standard string, return it */
     if ( sid > 390 )
       return cff_index_get_string( font, sid - 391 );
 
     /* CID-keyed CFF fonts don't have glyph names */
     if ( !font->psnames )
       return NULL;
 
     /* this is a standard string */
     return (FT_String *)font->psnames->adobe_std_strings( sid );
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /***                                                                   ***/
   /***   FD Select table support                                         ***/
   /***                                                                   ***/
   /*************************************************************************/
   /*************************************************************************/
 
 
   static void
   CFF_Done_FD_Select( CFF_FDSelect  fdselect,
                       FT_Stream     stream )
   {
     if ( fdselect->data )
       FT_FRAME_RELEASE( fdselect->data );
 
     fdselect->data_size   = 0;
     fdselect->format      = 0;
     fdselect->range_count = 0;
   }
 
 
   static FT_Error
   CFF_Load_FD_Select( CFF_FDSelect  fdselect,
                       FT_UInt       num_glyphs,
                       FT_Stream     stream,
                       FT_ULong      offset )
   {
     FT_Error  error;
     FT_Byte   format;
     FT_UInt   num_ranges;
 
 
     /* read format */
     if ( FT_STREAM_SEEK( offset ) || FT_READ_BYTE( format ) )
       goto Exit;
 
     fdselect->format      = format;
     fdselect->cache_count = 0;   /* clear cache */
 
     switch ( format )
     {
     case 0:     /* format 0, that's simple */
       fdselect->data_size = num_glyphs;
       goto Load_Data;
 
     case 3:     /* format 3, a tad more complex */
       if ( FT_READ_USHORT( num_ranges ) )
         goto Exit;
 
       if ( !num_ranges )
       {
         FT_TRACE0(( "CFF_Load_FD_Select: empty FDSelect array\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       fdselect->data_size = num_ranges * 3 + 2;
 
     Load_Data:
       if ( FT_FRAME_EXTRACT( fdselect->data_size, fdselect->data ) )
         goto Exit;
       break;
 
     default:    /* hmm... that's wrong */
       error = FT_THROW( Invalid_File_Format );
     }
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Byte )
   cff_fd_select_get( CFF_FDSelect  fdselect,
                      FT_UInt       glyph_index )
   {
     FT_Byte  fd = 0;
 
     /* if there is no FDSelect, return zero               */
     /* Note: CFF2 with just one Font Dict has no FDSelect */
     if ( fdselect->data == NULL )
       goto Exit;
 
     switch ( fdselect->format )
     {
     case 0:
       fd = fdselect->data[glyph_index];
       break;
 
     case 3:
       /* first, compare to the cache */
       if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <
                         fdselect->cache_count )
       {
         fd = fdselect->cache_fd;
         break;
       }
 
       /* then, look up the ranges array */
       {
         FT_Byte*  p       = fdselect->data;
         FT_Byte*  p_limit = p + fdselect->data_size;
         FT_Byte   fd2;
         FT_UInt   first, limit;
 
 
         first = FT_NEXT_USHORT( p );
         do
         {
           if ( glyph_index < first )
             break;
 
           fd2   = *p++;
           limit = FT_NEXT_USHORT( p );
 
           if ( glyph_index < limit )
           {
             fd = fd2;
 
             /* update cache */
             fdselect->cache_first = first;
             fdselect->cache_count = limit - first;
             fdselect->cache_fd    = fd2;
             break;
           }
           first = limit;
 
         } while ( p < p_limit );
       }
       break;
 
     default:
       ;
     }
 
   Exit:
     return fd;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /***                                                                   ***/
   /***   CFF font support                                                ***/
   /***                                                                   ***/
   /*************************************************************************/
   /*************************************************************************/
 
   static FT_Error
   cff_charset_compute_cids( CFF_Charset  charset,
                             FT_UInt      num_glyphs,
                             FT_Memory    memory )
   {
     FT_Error   error   = FT_Err_Ok;
     FT_UInt    i;
     FT_Long    j;
     FT_UShort  max_cid = 0;
 
 
     if ( charset->max_cid > 0 )
       goto Exit;
 
     for ( i = 0; i < num_glyphs; i++ )
     {
       if ( charset->sids[i] > max_cid )
         max_cid = charset->sids[i];
     }
 
     if ( FT_NEW_ARRAY( charset->cids, (FT_ULong)max_cid + 1 ) )
       goto Exit;
 
     /* When multiple GIDs map to the same CID, we choose the lowest */
     /* GID.  This is not described in any spec, but it matches the  */
     /* behaviour of recent Acroread versions.                       */
     for ( j = (FT_Long)num_glyphs - 1; j >= 0; j-- )
       charset->cids[charset->sids[j]] = (FT_UShort)j;
 
     charset->max_cid    = max_cid;
     charset->num_glyphs = num_glyphs;
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_UInt )
   cff_charset_cid_to_gindex( CFF_Charset  charset,
                              FT_UInt      cid )
   {
     FT_UInt  result = 0;
 
 
     if ( cid <= charset->max_cid )
       result = charset->cids[cid];
 
     return result;
   }
 
 
   static void
   cff_charset_free_cids( CFF_Charset  charset,
                          FT_Memory    memory )
   {
     FT_FREE( charset->cids );
     charset->max_cid = 0;
   }
 
 
   static void
   cff_charset_done( CFF_Charset  charset,
                     FT_Stream    stream )
   {
     FT_Memory  memory = stream->memory;
 
 
     cff_charset_free_cids( charset, memory );
 
     FT_FREE( charset->sids );
     charset->format = 0;
     charset->offset = 0;
   }
 
 
   static FT_Error
   cff_charset_load( CFF_Charset  charset,
                     FT_UInt      num_glyphs,
                     FT_Stream    stream,
                     FT_ULong     base_offset,
                     FT_ULong     offset,
                     FT_Bool      invert )
   {
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
     FT_UShort  glyph_sid;
 
 
     /* If the offset is greater than 2, we have to parse the charset */
     /* table.                                                        */
     if ( offset > 2 )
     {
       FT_UInt  j;
 
 
       charset->offset = base_offset + offset;
 
       /* Get the format of the table. */
       if ( FT_STREAM_SEEK( charset->offset ) ||
            FT_READ_BYTE( charset->format )   )
         goto Exit;
 
       /* Allocate memory for sids. */
       if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
         goto Exit;
 
       /* assign the .notdef glyph */
       charset->sids[0] = 0;
 
       switch ( charset->format )
       {
       case 0:
         if ( num_glyphs > 0 )
         {
           if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )
             goto Exit;
 
           for ( j = 1; j < num_glyphs; j++ )
             charset->sids[j] = FT_GET_USHORT();
 
           FT_FRAME_EXIT();
         }
         break;
 
       case 1:
       case 2:
         {
           FT_UInt  nleft;
           FT_UInt  i;
 
 
           j = 1;
 
           while ( j < num_glyphs )
           {
             /* Read the first glyph sid of the range. */
             if ( FT_READ_USHORT( glyph_sid ) )
               goto Exit;
 
             /* Read the number of glyphs in the range.  */
             if ( charset->format == 2 )
             {
               if ( FT_READ_USHORT( nleft ) )
                 goto Exit;
             }
             else
             {
               if ( FT_READ_BYTE( nleft ) )
                 goto Exit;
             }
 
             /* try to rescue some of the SIDs if `nleft' is too large */
             if ( glyph_sid > 0xFFFFL - nleft )
             {
               FT_ERROR(( "cff_charset_load: invalid SID range trimmed"
                          " nleft=%d -> %d\n", nleft, 0xFFFFL - glyph_sid ));
               nleft = ( FT_UInt )( 0xFFFFL - glyph_sid );
             }
 
             /* Fill in the range of sids -- `nleft + 1' glyphs. */
             for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )
               charset->sids[j] = glyph_sid;
           }
         }
         break;
 
       default:
         FT_ERROR(( "cff_charset_load: invalid table format\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
     }
     else
     {
       /* Parse default tables corresponding to offset == 0, 1, or 2.  */
       /* CFF specification intimates the following:                   */
       /*                                                              */
       /* In order to use a predefined charset, the following must be  */
       /* true: The charset constructed for the glyphs in the font's   */
       /* charstrings dictionary must match the predefined charset in  */
       /* the first num_glyphs.                                        */
 
       charset->offset = offset;  /* record charset type */
 
       switch ( (FT_UInt)offset )
       {
       case 0:
         if ( num_glyphs > 229 )
         {
           FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
                      "predefined charset (Adobe ISO-Latin)\n" ));
           error = FT_THROW( Invalid_File_Format );
           goto Exit;
         }
 
         /* Allocate memory for sids. */
         if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
           goto Exit;
 
         /* Copy the predefined charset into the allocated memory. */
         FT_ARRAY_COPY( charset->sids, cff_isoadobe_charset, num_glyphs );
 
         break;
 
       case 1:
         if ( num_glyphs > 166 )
         {
           FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
                      "predefined charset (Adobe Expert)\n" ));
           error = FT_THROW( Invalid_File_Format );
           goto Exit;
         }
 
         /* Allocate memory for sids. */
         if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
           goto Exit;
 
         /* Copy the predefined charset into the allocated memory.     */
         FT_ARRAY_COPY( charset->sids, cff_expert_charset, num_glyphs );
 
         break;
 
       case 2:
         if ( num_glyphs > 87 )
         {
           FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
                      "predefined charset (Adobe Expert Subset)\n" ));
           error = FT_THROW( Invalid_File_Format );
           goto Exit;
         }
 
         /* Allocate memory for sids. */
         if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
           goto Exit;
 
         /* Copy the predefined charset into the allocated memory.     */
         FT_ARRAY_COPY( charset->sids, cff_expertsubset_charset, num_glyphs );
 
         break;
 
       default:
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
     }
 
     /* we have to invert the `sids' array for subsetted CID-keyed fonts */
     if ( invert )
       error = cff_charset_compute_cids( charset, num_glyphs, memory );
 
   Exit:
     /* Clean up if there was an error. */
     if ( error )
     {
       FT_FREE( charset->sids );
       FT_FREE( charset->cids );
       charset->format = 0;
       charset->offset = 0;
       charset->sids   = 0;
     }
 
     return error;
   }
 
 
+  static void
+  cff_vstore_done( CFF_VStoreRec*  vstore,
+                   FT_Memory       memory )
+  {
+    FT_UInt  i;
+
+
+    /* free regionList and axisLists */
+    if ( vstore->varRegionList )
+    {
+      for ( i = 0; i < vstore->regionCount; i++ )
+        FT_FREE( vstore->varRegionList[i].axisList );
+    }
+    FT_FREE( vstore->varRegionList );
+
+    /* free varData and indices */
+    if ( vstore->varData )
+    {
+      for ( i = 0; i < vstore->dataCount; i++ )
+        FT_FREE( vstore->varData[i].regionIndices );
+    }
+    FT_FREE( vstore->varData );
+  }
+
+
+  /* convert 2.14 to Fixed */
+  #define FT_fdot14ToFixed( x )  ( ( (FT_Fixed)( (FT_Int16)(x) ) ) << 2 )
+
+
+  static FT_Error
+  cff_vstore_load( CFF_VStoreRec*  vstore,
+                   FT_Stream       stream,
+                   FT_ULong        base_offset,
+                   FT_ULong        offset )
+  {
+    FT_Memory  memory = stream->memory;
+    FT_Error   error  = FT_ERR( Invalid_File_Format );
+
+    FT_ULong*  dataOffsetArray = NULL;
+    FT_UInt    i, j;
+
+
+    /* no offset means no vstore to parse */
+    if ( offset )
+    {
+      FT_UInt   vsSize;     /* currently unused */
+      FT_UInt   vsOffset;
+      FT_UInt   format;
+      FT_ULong  regionListOffset;
+
+
+      /* we need to parse the table to determine its size */
+      if ( FT_STREAM_SEEK( base_offset + offset ) ||
+           FT_READ_USHORT( vsSize )               )
+        goto Exit;
+
+      /* actual variation store begins after the length */
+      vsOffset = FT_STREAM_POS();
+
+      /* check the header */
+      if ( FT_READ_USHORT( format ) )
+        goto Exit;
+      if ( format != 1 )
+      {
+        error = FT_THROW( Invalid_File_Format );
+        goto Exit;
+      }
+
+      /* read top level fields */
+      if ( FT_READ_ULONG( regionListOffset )   ||
+           FT_READ_USHORT( vstore->dataCount ) )
+        goto Exit;
+
+      /* make temporary copy of item variation data offsets; */
+      /* we'll parse region list first, then come back       */
+      if ( FT_NEW_ARRAY( dataOffsetArray, vstore->dataCount ) )
+        goto Exit;
+
+      for ( i = 0; i < vstore->dataCount; i++ )
+      {
+        if ( FT_READ_ULONG( dataOffsetArray[i] ) )
+          goto Exit;
+      }
+
+      /* parse regionList and axisLists */
+      if ( FT_STREAM_SEEK( vsOffset + regionListOffset ) ||
+           FT_READ_USHORT( vstore->axisCount )           ||
+           FT_READ_USHORT( vstore->regionCount )         )
+        goto Exit;
+
+      if ( FT_NEW_ARRAY( vstore->varRegionList, vstore->regionCount ) )
+        goto Exit;
+
+      for ( i = 0; i < vstore->regionCount; i++ )
+      {
+        CFF_VarRegion*  region = &vstore->varRegionList[i];
+
+
+        if ( FT_NEW_ARRAY( region->axisList, vstore->axisCount ) )
+          goto Exit;
+
+        for ( j = 0; j < vstore->axisCount; j++ )
+        {
+          CFF_AxisCoords*  axis = &region->axisList[j];
+
+          FT_Int16  start14, peak14, end14;
+
+
+          if ( FT_READ_SHORT( start14 ) ||
+               FT_READ_SHORT( peak14 )  ||
+               FT_READ_SHORT( end14 )   )
+            goto Exit;
+
+          axis->startCoord = FT_fdot14ToFixed( start14 );
+          axis->peakCoord  = FT_fdot14ToFixed( peak14 );
+          axis->endCoord   = FT_fdot14ToFixed( end14 );
+        }
+      }
+
+      /* use dataOffsetArray now to parse varData items */
+      if ( FT_NEW_ARRAY( vstore->varData, vstore->dataCount ) )
+        goto Exit;
+
+      for ( i = 0; i < vstore->dataCount; i++ )
+      {
+        CFF_VarData*  data = &vstore->varData[i];
+
+
+        if ( FT_STREAM_SEEK( vsOffset + dataOffsetArray[i] ) )
+          goto Exit;
+
+        /* ignore `itemCount' and `shortDeltaCount' */
+        /* because CFF2 has no delta sets           */
+        if ( FT_STREAM_SKIP( 4 ) )
+          goto Exit;
+
+        /* Note: just record values; consistency is checked later    */
+        /*       by cff_blend_build_vector when it consumes `vstore' */
+
+        if ( FT_READ_USHORT( data->regionIdxCount ) )
+          goto Exit;
+
+        if ( FT_NEW_ARRAY( data->regionIndices, data->regionIdxCount ) )
+          goto Exit;
+
+        for ( j = 0; j < data->regionIdxCount; j++ )
+        {
+          if ( FT_READ_USHORT( data->regionIndices[j] ) )
+            goto Exit;
+        }
+      }
+    }
+
+    error = FT_Err_Ok;
+
+  Exit:
+    FT_FREE( dataOffsetArray );
+    if ( error )
+      cff_vstore_done( vstore, memory );
+
+    return error;
+  }
+
+
+  /* Clear blend stack (after blend values are consumed). */
+  /*                                                      */
+  /* TODO: Should do this in cff_run_parse, but subFont   */
+  /*       ref is not available there.                    */
+  /*                                                      */
+  /* Allocation is not changed when stack is cleared.     */
+  FT_LOCAL_DEF( void )
+  cff_blend_clear( CFF_SubFont  subFont )
+  {
+    subFont->blend_top  = subFont->blend_stack;
+    subFont->blend_used = 0;
+  }
+
+
+  /* Blend numOperands on the stack,                       */
+  /* store results into the first numBlends values,        */
+  /* then pop remaining arguments.                         */
+  /*                                                       */
+  /* This is comparable to `cf2_doBlend' but               */
+  /* the cffparse stack is different and can't be written. */
+  /* Blended values are written to a different buffer,     */
+  /* using reserved operator 255.                          */
+  /*                                                       */
+  /* Blend calculation is done in 16.16 fixed point.       */
+  FT_LOCAL_DEF( FT_Error )
+  cff_blend_doBlend( CFF_SubFont  subFont,
+                     CFF_Parser   parser,
+                     FT_UInt      numBlends )
+  {
+    FT_UInt  delta;
+    FT_UInt  base;
+    FT_UInt  i, j;
+    FT_UInt  size;
+
+    CFF_Blend  blend = &subFont->blend;
+
+    FT_Memory  memory = subFont->blend.font->memory; /* for FT_REALLOC */
+    FT_Error   error  = FT_Err_Ok;                   /* for FT_REALLOC */
+
+    /* compute expected number of operands for this blend */
+    FT_UInt  numOperands = (FT_UInt)( numBlends * blend->lenBV );
+    FT_UInt  count       = (FT_UInt)( parser->top - 1 - parser->stack );
+
+
+    if ( numOperands > count )
+    {
+      FT_TRACE4(( " cff_blend_doBlend: Stack underflow %d args\n", count ));
+
+      error = FT_THROW( Stack_Underflow );
+      goto Exit;
+    }
+
+    /* check whether we have room for `numBlends' values at `blend_top' */
+    size = 5 * numBlends;           /* add 5 bytes per entry    */
+    if ( subFont->blend_used + size > subFont->blend_alloc )
+    {
+      /* increase or allocate `blend_stack' and reset `blend_top'; */
+      /* prepare to append `numBlends' values to the buffer        */
+      if ( FT_REALLOC( subFont->blend_stack,
+                       subFont->blend_alloc,
+                       subFont->blend_alloc + size ) )
+        goto Exit;
+
+      subFont->blend_top    = subFont->blend_stack + subFont->blend_used;
+      subFont->blend_alloc += size;
+    }
+    subFont->blend_used += size;
+
+    base  = count - numOperands;     /* index of first blend arg */
+    delta = base + numBlends;        /* index of first delta arg */
+
+    for ( i = 0; i < numBlends; i++ )
+    {
+      const FT_Int32*  weight = &blend->BV[1];
+      FT_Int32         sum;
+
+
+      /* convert inputs to 16.16 fixed point */
+      sum = cff_parse_num( parser, &parser->stack[i + base] ) << 16;
+
+      for ( j = 1; j < blend->lenBV; j++ )
+        sum += FT_MulFix( *weight++,
+                          cff_parse_num( parser,
+                                         &parser->stack[delta++] ) << 16 );
+
+      /* point parser stack to new value on blend_stack */
+      parser->stack[i + base] = subFont->blend_top;
+
+      /* Push blended result as Type 2 5-byte fixed point number (except   */
+      /* that host byte order is used).  This will not conflict with       */
+      /* actual DICTs because 255 is a reserved opcode in both CFF and     */
+      /* CFF2 DICTs.  See `cff_parse_num' for decode of this, which rounds */
+      /* to an integer.                                                    */
+      *subFont->blend_top++             = 255;
+      *((FT_UInt32*)subFont->blend_top) = sum; /* write 4 bytes */
+      subFont->blend_top               += 4;
+    }
+
+    /* leave only numBlends results on parser stack */
+    parser->top = &parser->stack[base + numBlends];
+
+  Exit:
+    return error;
+  }
+
+
+  /* Compute a blend vector from variation store index and normalized  */
+  /* vector based on pseudo-code in OpenType Font Variations Overview. */
+  /*                                                                   */
+  /* Note: lenNDV == 0 produces a default blend vector, (1,0,0,...).   */
+  FT_LOCAL_DEF( FT_Error )
+  cff_blend_build_vector( CFF_Blend  blend,
+                          FT_UInt    vsindex,
+                          FT_UInt    lenNDV,
+                          FT_Fixed*  NDV )
+  {
+    FT_Error   error  = FT_Err_Ok;            /* for FT_REALLOC */
+    FT_Memory  memory = blend->font->memory;  /* for FT_REALLOC */
+
+    FT_UInt       len;
+    CFF_VStore    vs;
+    CFF_VarData*  varData;
+    FT_UInt       master;
+
+
+    FT_ASSERT( lenNDV == 0 || NDV );
+
+    blend->builtBV = FALSE;
+
+    vs = &blend->font->vstore;
+
+    /* VStore and fvar must be consistent */
+    if ( lenNDV != 0 && lenNDV != vs->axisCount )
+    {
+      FT_TRACE4(( " cff_blend_build_vector: Axis count mismatch\n" ));
+      error = FT_THROW( Invalid_File_Format );
+      goto Exit;
+    }
+
+    if ( vsindex >= vs->dataCount )
+    {
+      FT_TRACE4(( " cff_blend_build_vector: vsindex out of range\n" ));
+      error = FT_THROW( Invalid_File_Format );
+      goto Exit;
+    }
+
+    /* select the item variation data structure */
+    varData = &vs->varData[vsindex];
+
+    /* prepare buffer for the blend vector */
+    len = varData->regionIdxCount + 1;    /* add 1 for default component */
+    if ( FT_REALLOC( blend->BV,
+                     blend->lenBV * sizeof( *blend->BV ),
+                     len * sizeof( *blend->BV ) ) )
+      goto Exit;
+
+    blend->lenBV = len;
+
+    /* outer loop steps through master designs to be blended */
+    for ( master = 0; master < len; master++ )
+    {
+      FT_UInt         j;
+      FT_UInt         idx;
+      CFF_VarRegion*  varRegion;
+
+
+      /* default factor is always one */
+      if ( master == 0 )
+      {
+        blend->BV[master] = FT_FIXED_ONE;
+        FT_TRACE4(( "   build blend vector len %d\n"
+                    "   [ %f ",
+                    len,
+                    blend->BV[master] / 65536.0 ));
+        continue;
+      }
+
+      /* VStore array does not include default master, so subtract one */
+      idx       = varData->regionIndices[master - 1];
+      varRegion = &vs->varRegionList[idx];
+
+      if ( idx >= vs->regionCount )
+      {
+        FT_TRACE4(( " cff_blend_build_vector:"
+                    " region index out of range\n" ));
+        error = FT_THROW( Invalid_File_Format );
+        goto Exit;
+      }
+
+      /* Note: `lenNDV' could be zero.                              */
+      /*       In that case, build default blend vector (1,0,0...). */
+      /*       In the normal case, initialize each component to 1   */
+      /*       before inner loop.                                   */
+      if ( lenNDV != 0 )
+        blend->BV[master] = FT_FIXED_ONE; /* default */
+
+      /* inner loop steps through axes in this region */
+      for ( j = 0; j < lenNDV; j++ )
+      {
+        CFF_AxisCoords*  axis = &varRegion->axisList[j];
+        FT_Fixed         axisScalar;
+
+
+        /* compute the scalar contribution of this axis; */
+        /* ignore invalid ranges                         */
+        if ( axis->startCoord > axis->peakCoord ||
+             axis->peakCoord > axis->endCoord   )
+          axisScalar = FT_FIXED_ONE;
+
+        else if ( axis->startCoord < 0 &&
+                  axis->endCoord > 0   &&
+                  axis->peakCoord != 0 )
+          axisScalar = FT_FIXED_ONE;
+
+        /* peak of 0 means ignore this axis */
+        else if ( axis->peakCoord == 0 )
+          axisScalar = FT_FIXED_ONE;
+
+        /* ignore this region if coords are out of range */
+        else if ( NDV[j] < axis->startCoord ||
+                  NDV[j] > axis->endCoord   )
+          axisScalar = 0;
+
+        /* calculate a proportional factor */
+        else
+        {
+          if ( NDV[j] == axis->peakCoord )
+            axisScalar = FT_FIXED_ONE;
+          else if ( NDV[j] < axis->peakCoord )
+            axisScalar = FT_DivFix( NDV[j] - axis->startCoord,
+                                    axis->peakCoord - axis->startCoord );
+          else
+            axisScalar = FT_DivFix( axis->endCoord - NDV[j],
+                                    axis->endCoord - axis->peakCoord );
+        }
+
+        /* take product of all the axis scalars */
+        blend->BV[master] = FT_MulFix( blend->BV[master], axisScalar );
+      }
+
+      FT_TRACE4(( ", %f ",
+                  blend->BV[master] / 65536.0 ));
+    }
+
+    FT_TRACE4(( "]\n" ));
+
+    /* record the parameters used to build the blend vector */
+    blend->lastVsindex = vsindex;
+
+    if ( lenNDV != 0 )
+    {
+      /* user has set a normalized vector */
+      if ( FT_REALLOC( blend->lastNDV,
+                       blend->lenNDV * sizeof ( *NDV ),
+                       lenNDV * sizeof ( *NDV ) ) )
+      {
+        error = FT_THROW( Out_Of_Memory );
+        goto Exit;
+      }
+
+      blend->lenNDV = lenNDV;
+      FT_MEM_COPY( blend->lastNDV,
+                   NDV,
+                   lenNDV * sizeof ( *NDV ) );
+    }
+
+    blend->builtBV = TRUE;
+
+  Exit:
+    return error;
+  }
+
+
+  /* `lenNDV' is zero for default vector;           */
+  /* return TRUE if blend vector needs to be built. */
+  FT_LOCAL_DEF( FT_Bool )
+  cff_blend_check_vector( CFF_Blend  blend,
+                          FT_UInt    vsindex,
+                          FT_UInt    lenNDV,
+                          FT_Fixed*  NDV )
+  {
+    if ( !blend->builtBV                             ||
+         blend->lastVsindex != vsindex               ||
+         blend->lenNDV != lenNDV                     ||
+         ( lenNDV                                  &&
+           memcmp( NDV,
+                   blend->lastNDV,
+                   lenNDV * sizeof ( *NDV ) ) != 0 ) )
+    {
+      /* need to build blend vector */
+      return TRUE;
+    }
+
+    return FALSE;
+  }
+
+
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
   FT_LOCAL_DEF( FT_Error )
   cff_get_var_blend( CFF_Face    face,
                      FT_UInt    *num_coords,
                      FT_Fixed*  *coords )
   {
     FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;
 
 
     return mm->get_var_blend( FT_FACE( face ), num_coords, coords );
   }
 
 
   FT_LOCAL_DEF( void )
   cff_done_blend( CFF_Face  face )
   {
     FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face->mm;
 
 
     mm->done_blend( FT_FACE( face ) );
   }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
   static void
   cff_encoding_done( CFF_Encoding  encoding )
   {
     encoding->format = 0;
     encoding->offset = 0;
     encoding->count  = 0;
   }
 
 
   static FT_Error
   cff_encoding_load( CFF_Encoding  encoding,
                      CFF_Charset   charset,
                      FT_UInt       num_glyphs,
                      FT_Stream     stream,
                      FT_ULong      base_offset,
                      FT_ULong      offset )
   {
     FT_Error   error = FT_Err_Ok;
     FT_UInt    count;
     FT_UInt    j;
     FT_UShort  glyph_sid;
     FT_UInt    glyph_code;
 
 
     /* Check for charset->sids.  If we do not have this, we fail. */
     if ( !charset->sids )
     {
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     /* Zero out the code to gid/sid mappings. */
     for ( j = 0; j < 256; j++ )
     {
       encoding->sids [j] = 0;
       encoding->codes[j] = 0;
     }
 
     /* Note: The encoding table in a CFF font is indexed by glyph index;  */
     /* the first encoded glyph index is 1.  Hence, we read the character  */
     /* code (`glyph_code') at index j and make the assignment:            */
     /*                                                                    */
     /*    encoding->codes[glyph_code] = j + 1                             */
     /*                                                                    */
     /* We also make the assignment:                                       */
     /*                                                                    */
     /*    encoding->sids[glyph_code] = charset->sids[j + 1]               */
     /*                                                                    */
     /* This gives us both a code to GID and a code to SID mapping.        */
 
     if ( offset > 1 )
     {
       encoding->offset = base_offset + offset;
 
       /* we need to parse the table to determine its size */
       if ( FT_STREAM_SEEK( encoding->offset ) ||
            FT_READ_BYTE( encoding->format )   ||
            FT_READ_BYTE( count )              )
         goto Exit;
 
       switch ( encoding->format & 0x7F )
       {
       case 0:
         {
           FT_Byte*  p;
 
 
           /* By convention, GID 0 is always ".notdef" and is never */
           /* coded in the font.  Hence, the number of codes found  */
           /* in the table is `count+1'.                            */
           /*                                                       */
           encoding->count = count + 1;
 
           if ( FT_FRAME_ENTER( count ) )
             goto Exit;
 
           p = (FT_Byte*)stream->cursor;
 
           for ( j = 1; j <= count; j++ )
           {
             glyph_code = *p++;
 
             /* Make sure j is not too big. */
             if ( j < num_glyphs )
             {
               /* Assign code to GID mapping. */
               encoding->codes[glyph_code] = (FT_UShort)j;
 
               /* Assign code to SID mapping. */
               encoding->sids[glyph_code] = charset->sids[j];
             }
           }
 
           FT_FRAME_EXIT();
         }
         break;
 
       case 1:
         {
           FT_UInt  nleft;
           FT_UInt  i = 1;
           FT_UInt  k;
 
 
           encoding->count = 0;
 
           /* Parse the Format1 ranges. */
           for ( j = 0;  j < count; j++, i += nleft )
           {
             /* Read the first glyph code of the range. */
             if ( FT_READ_BYTE( glyph_code ) )
               goto Exit;
 
             /* Read the number of codes in the range. */
             if ( FT_READ_BYTE( nleft ) )
               goto Exit;
 
             /* Increment nleft, so we read `nleft + 1' codes/sids. */
             nleft++;
 
             /* compute max number of character codes */
             if ( (FT_UInt)nleft > encoding->count )
               encoding->count = nleft;
 
             /* Fill in the range of codes/sids. */
             for ( k = i; k < nleft + i; k++, glyph_code++ )
             {
               /* Make sure k is not too big. */
               if ( k < num_glyphs && glyph_code < 256 )
               {
                 /* Assign code to GID mapping. */
                 encoding->codes[glyph_code] = (FT_UShort)k;
 
                 /* Assign code to SID mapping. */
                 encoding->sids[glyph_code] = charset->sids[k];
               }
             }
           }
 
           /* simple check; one never knows what can be found in a font */
           if ( encoding->count > 256 )
             encoding->count = 256;
         }
         break;
 
       default:
         FT_ERROR(( "cff_encoding_load: invalid table format\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       /* Parse supplemental encodings, if any. */
       if ( encoding->format & 0x80 )
       {
         FT_UInt  gindex;
 
 
         /* count supplements */
         if ( FT_READ_BYTE( count ) )
           goto Exit;
 
         for ( j = 0; j < count; j++ )
         {
           /* Read supplemental glyph code. */
           if ( FT_READ_BYTE( glyph_code ) )
             goto Exit;
 
           /* Read the SID associated with this glyph code. */
           if ( FT_READ_USHORT( glyph_sid ) )
             goto Exit;
 
           /* Assign code to SID mapping. */
           encoding->sids[glyph_code] = glyph_sid;
 
           /* First, look up GID which has been assigned to */
           /* SID glyph_sid.                                */
           for ( gindex = 0; gindex < num_glyphs; gindex++ )
           {
             if ( charset->sids[gindex] == glyph_sid )
             {
               encoding->codes[glyph_code] = (FT_UShort)gindex;
               break;
             }
           }
         }
       }
     }
     else
     {
       /* We take into account the fact a CFF font can use a predefined */
       /* encoding without containing all of the glyphs encoded by this */
       /* encoding (see the note at the end of section 12 in the CFF    */
       /* specification).                                               */
 
       switch ( (FT_UInt)offset )
       {
       case 0:
         /* First, copy the code to SID mapping. */
         FT_ARRAY_COPY( encoding->sids, cff_standard_encoding, 256 );
         goto Populate;
 
       case 1:
         /* First, copy the code to SID mapping. */
         FT_ARRAY_COPY( encoding->sids, cff_expert_encoding, 256 );
 
       Populate:
         /* Construct code to GID mapping from code to SID mapping */
         /* and charset.                                           */
 
         encoding->count = 0;
 
         error = cff_charset_compute_cids( charset, num_glyphs,
                                           stream->memory );
         if ( error )
           goto Exit;
 
         for ( j = 0; j < 256; j++ )
         {
           FT_UInt  sid = encoding->sids[j];
           FT_UInt  gid = 0;
 
 
           if ( sid )
             gid = cff_charset_cid_to_gindex( charset, sid );
 
           if ( gid != 0 )
           {
             encoding->codes[j] = (FT_UShort)gid;
             encoding->count    = j + 1;
           }
           else
           {
             encoding->codes[j] = 0;
             encoding->sids [j] = 0;
           }
         }
         break;
 
       default:
         FT_ERROR(( "cff_encoding_load: invalid table format\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
     }
 
   Exit:
 
     /* Clean up if there was an error. */
     return error;
   }
 
 
+  /* Parse private dictionary; first call is always from `cff_face_init', */
+  /* so NDV has not been set for CFF2 variation.                          */
+  /*                                                                      */
+  /* `cff_slot_load' must call this function each time NDV changes.       */
   static FT_Error
   cff_load_private_dict( CFF_Font     font,
-                         CFF_SubFont  subfont )
+                         CFF_SubFont  subfont,
+                         FT_UInt      lenNDV,
+                         FT_Fixed*    NDV )
   {
     FT_Error         error  = FT_Err_Ok;
     CFF_ParserRec    parser;
     CFF_FontRecDict  top    = &subfont->font_dict;
     CFF_Private      priv   = &subfont->private_dict;
     FT_Stream        stream = font->stream;
     FT_UInt          stackSize;
 
 
     if ( !top->private_offset || !top->private_size )
       goto Exit2;       /* no private DICT, do nothing */
 
+    /* store handle needed to access memory, vstore for blend */
+    subfont->blend.font   = font;
+    subfont->blend.usedBV = FALSE;  /* clear state */
+
     /* set defaults */
     FT_ZERO( priv );
 
     priv->blue_shift       = 7;
     priv->blue_fuzz        = 1;
     priv->lenIV            = -1;
     priv->expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
     priv->blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );
 
-    priv->subfont = subfont;
+    /* provide inputs for blend calculations */
+    priv->subfont   = subfont;
+    subfont->lenNDV = lenNDV;
+    subfont->NDV    = NDV;
 
     stackSize = font->cff2 ? font->top_font.font_dict.maxstack
                            : CFF_MAX_STACK_DEPTH + 1;
 
     if ( cff_parser_init( &parser,
                           font->cff2 ? CFF2_CODE_PRIVATE : CFF_CODE_PRIVATE,
                           priv,
                           font->library,
                           stackSize,
                           top->num_designs,
                           top->num_axes ) )
       goto Exit;
 
     if ( FT_STREAM_SEEK( font->base_offset + top->private_offset ) ||
          FT_FRAME_ENTER( top->private_size )                       )
       goto Exit;
 
     FT_TRACE4(( " private dictionary:\n" ));
     error = cff_parser_run( &parser,
                             (FT_Byte*)stream->cursor,
                             (FT_Byte*)stream->limit );
     FT_FRAME_EXIT();
 
     if ( error )
       goto Exit;
 
     /* ensure that `num_blue_values' is even */
     priv->num_blue_values &= ~1;
 
   Exit:
     /* clean up */
+    cff_blend_clear( subfont ); /* clear blend stack */
     cff_parser_done( &parser ); /* free parser stack */
 
   Exit2:
     /* no clean up (parser not initialized) */
     return error;
   }
 
 
   /* There are 3 ways to call this function, distinguished by code.  */
   /*                                                                 */
   /* . CFF_CODE_TOPDICT for either a CFF Top DICT or a CFF Font DICT */
   /* . CFF2_CODE_TOPDICT for CFF2 Top DICT                           */
   /* . CFF2_CODE_FONTDICT for CFF2 Font DICT                         */
 
   static FT_Error
   cff_subfont_load( CFF_SubFont  subfont,
                     CFF_Index    idx,
                     FT_UInt      font_index,
                     FT_Stream    stream,
                     FT_ULong     base_offset,
                     FT_UInt      code,
                     CFF_Font     font )
   {
     FT_Error         error;
     CFF_ParserRec    parser;
     FT_Byte*         dict = NULL;
     FT_ULong         dict_len;
     CFF_FontRecDict  top  = &subfont->font_dict;
     CFF_Private      priv = &subfont->private_dict;
 
     FT_Bool  cff2      = ( code == CFF2_CODE_TOPDICT  ||
                            code == CFF2_CODE_FONTDICT );
     FT_UInt  stackSize = cff2 ? CFF2_DEFAULT_STACK
                               : CFF_MAX_STACK_DEPTH;
 
 
     /* Note: We use default stack size for CFF2 Font DICT because        */
     /*       Top and Font DICTs are not allowed to have blend operators. */
     if ( cff_parser_init( &parser,
                           code,
                           &subfont->font_dict,
                           font->library,
                           stackSize,
                           0,
                           0 ) )
       goto Exit;
 
     /* set defaults */
     FT_ZERO( top );
 
     top->underline_position  = -( 100L << 16 );
     top->underline_thickness = 50L << 16;
     top->charstring_type     = 2;
     top->font_matrix.xx      = 0x10000L;
     top->font_matrix.yy      = 0x10000L;
     top->cid_count           = 8720;
 
     /* we use the implementation specific SID value 0xFFFF to indicate */
     /* missing entries                                                 */
     top->version             = 0xFFFFU;
     top->notice              = 0xFFFFU;
     top->copyright           = 0xFFFFU;
     top->full_name           = 0xFFFFU;
     top->family_name         = 0xFFFFU;
     top->weight              = 0xFFFFU;
     top->embedded_postscript = 0xFFFFU;
 
     top->cid_registry        = 0xFFFFU;
     top->cid_ordering        = 0xFFFFU;
     top->cid_font_name       = 0xFFFFU;
 
     /* set default stack size */
     top->maxstack            = cff2 ? CFF2_DEFAULT_STACK : 48;
 
     if ( idx->count )   /* count is nonzero for a real index */
       error = cff_index_access_element( idx, font_index, &dict, &dict_len );
     else
     {
       /* CFF2 has a fake top dict index;     */
       /* simulate `cff_index_access_element' */
 
       /* Note: macros implicitly use `stream' and set `error' */
       if ( FT_STREAM_SEEK( idx->data_offset )       ||
            FT_FRAME_EXTRACT( idx->data_size, dict ) )
         goto Exit;
 
       dict_len = idx->data_size;
     }
 
     if ( !error )
     {
       FT_TRACE4(( " top dictionary:\n" ));
       error = cff_parser_run( &parser, dict, dict + dict_len );
     }
 
     /* clean up regardless of error */
     if ( idx->count )
       cff_index_forget_element( idx, &dict );
     else
       FT_FRAME_RELEASE( dict );
 
     if ( error )
       goto Exit;
 
     /* if it is a CID font, we stop there */
     if ( top->cid_registry != 0xFFFFU )
       goto Exit;
 
     /* Parse the private dictionary, if any.                   */
     /*                                                         */
     /* CFF2 does not have a private dictionary in the Top DICT */
     /* but may have one in a Font DICT.  We need to parse      */
     /* the latter here in order to load any local subrs.       */
-    error = cff_load_private_dict( font, subfont );
+    error = cff_load_private_dict( font, subfont, 0, 0 );
     if ( error )
       goto Exit;
 
     /* read the local subrs, if any */
     if ( priv->local_subrs_offset )
     {
       if ( FT_STREAM_SEEK( base_offset + top->private_offset +
                            priv->local_subrs_offset ) )
         goto Exit;
 
       error = cff_index_init( &subfont->local_subrs_index, stream, 1, cff2 );
       if ( error )
         goto Exit;
 
       error = cff_index_get_pointers( &subfont->local_subrs_index,
                                       &subfont->local_subrs, NULL, NULL );
       if ( error )
         goto Exit;
     }
 
   Exit:
     cff_parser_done( &parser ); /* free parser stack */
 
     return error;
   }
 
 
   static void
   cff_subfont_done( FT_Memory    memory,
                     CFF_SubFont  subfont )
   {
     if ( subfont )
     {
       cff_index_done( &subfont->local_subrs_index );
       FT_FREE( subfont->local_subrs );
+
+      FT_FREE( subfont->blend.lastNDV );
+      FT_FREE( subfont->blend.BV );
+      FT_FREE( subfont->blend_stack );
     }
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_font_load( FT_Library library,
                  FT_Stream  stream,
                  FT_Int     face_index,
                  CFF_Font   font,
                  FT_Bool    pure_cff,
                  FT_Bool    cff2 )
   {
     static const FT_Frame_Field  cff_header_fields[] =
     {
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_FontRec
 
       FT_FRAME_START( 3 ),
         FT_FRAME_BYTE( version_major ),
         FT_FRAME_BYTE( version_minor ),
         FT_FRAME_BYTE( header_size ),
       FT_FRAME_END
     };
 
     FT_Error         error;
     FT_Memory        memory = stream->memory;
     FT_ULong         base_offset;
     CFF_FontRecDict  dict;
     CFF_IndexRec     string_index;
     FT_UInt          subfont_index;
 
 
     FT_ZERO( font );
     FT_ZERO( &string_index );
 
     dict        = &font->top_font.font_dict;
     base_offset = FT_STREAM_POS();
 
     font->library     = library;
     font->stream      = stream;
     font->memory      = memory;
     font->cff2        = cff2;
     font->base_offset = base_offset;
 
     /* read CFF font header */
     if ( FT_STREAM_READ_FIELDS( cff_header_fields, font ) )
       goto Exit;
 
     if ( cff2 )
     {
       if ( font->version_major != 2 ||
            font->header_size < 5    )
       {
         FT_TRACE2(( "  not a CFF2 font header\n" ));
         error = FT_THROW( Unknown_File_Format );
         goto Exit;
       }
 
       if ( FT_READ_USHORT( font->top_dict_length ) )
         goto Exit;
     }
     else
     {
       if ( font->version_major != 1 ||
            font->header_size < 4    )
       {
         FT_TRACE2(( "  not a CFF font header\n" ));
         error = FT_THROW( Unknown_File_Format );
         goto Exit;
       }
     }
 
     /* skip the rest of the header */
     if ( FT_STREAM_SEEK( base_offset + font->header_size ) )
       goto Exit;
 
     if ( cff2 )
     {
       /* For CFF2, the top dict data immediately follow the header    */
       /* and the length is stored in the header `offSize' field;      */
       /* there is no index for it.                                    */
       /*                                                              */
       /* Use the `font_dict_index' to save the current position       */
       /* and length of data, but leave count at zero as an indicator. */
       FT_ZERO( &font->font_dict_index );
 
       font->font_dict_index.data_offset = FT_STREAM_POS();
       font->font_dict_index.data_size   = font->top_dict_length;
 
       /* skip the top dict data for now, we will parse it later */
       if ( FT_STREAM_SKIP( font->top_dict_length ) )
         goto Exit;
 
       /* next, read the global subrs index */
       if ( FT_SET_ERROR( cff_index_init( &font->global_subrs_index,
                                          stream, 1, cff2 ) ) )
         goto Exit;
     }
     else
     {
       /* for CFF, read the name, top dict, string and global subrs index */
       if ( FT_SET_ERROR( cff_index_init( &font->name_index,
                                          stream, 0, cff2 ) )                 ||
            FT_SET_ERROR( cff_index_init( &font->font_dict_index,
                                          stream, 0, cff2 ) )                 ||
            FT_SET_ERROR( cff_index_init( &string_index,
                                          stream, 1, cff2 ) )                 ||
            FT_SET_ERROR( cff_index_init( &font->global_subrs_index,
                                          stream, 1, cff2 ) )                 ||
            FT_SET_ERROR( cff_index_get_pointers( &string_index,
                                                  &font->strings,
                                                  &font->string_pool,
                                                  &font->string_pool_size ) ) )
         goto Exit;
     }
 
     font->num_strings = string_index.count;
 
     if ( pure_cff )
     {
       /* well, we don't really forget the `disabled' fonts... */
       subfont_index = (FT_UInt)( face_index & 0xFFFF );
 
       if ( face_index > 0 && subfont_index >= font->name_index.count )
       {
         FT_ERROR(( "cff_font_load:"
                    " invalid subfont index for pure CFF font (%d)\n",
                    subfont_index ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
 
       font->num_faces = font->name_index.count;
     }
     else
     {
       subfont_index = 0;
 
       if ( font->name_index.count > 1 )
       {
         FT_ERROR(( "cff_font_load:"
                    " invalid CFF font with multiple subfonts\n"
                    "              "
                    " in SFNT wrapper\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
     }
 
     /* in case of a font format check, simply exit now */
     if ( face_index < 0 )
       goto Exit;
 
     /* now, parse the top-level font dictionary */
     FT_TRACE4(( "parsing top-level\n" ));
     error = cff_subfont_load( &font->top_font,
                               &font->font_dict_index,
                               subfont_index,
                               stream,
                               base_offset,
                               cff2 ? CFF2_CODE_TOPDICT : CFF_CODE_TOPDICT,
                               font );
     if ( error )
       goto Exit;
 
     if ( FT_STREAM_SEEK( base_offset + dict->charstrings_offset ) )
       goto Exit;
 
     error = cff_index_init( &font->charstrings_index, stream, 0, cff2 );
     if ( error )
       goto Exit;
 
     /* now, check for a CID or CFF2 font */
     if ( dict->cid_registry != 0xFFFFU ||
          cff2                          )
     {
       CFF_IndexRec  fd_index;
       CFF_SubFont   sub = NULL;
       FT_UInt       idx;
 
 
+      /* for CFF2, read the Variation Store if available;                 */
+      /* this must follow the Top DICT parse and precede any Private DICT */
+      error = cff_vstore_load( &font->vstore,
+                               stream,
+                               base_offset,
+                               dict->vstore_offset );
+      if ( error )
+        goto Exit;
+
       /* this is a CID-keyed font, we must now allocate a table of */
       /* sub-fonts, then load each of them separately              */
       if ( FT_STREAM_SEEK( base_offset + dict->cid_fd_array_offset ) )
         goto Exit;
 
       error = cff_index_init( &fd_index, stream, 0, cff2 );
       if ( error )
         goto Exit;
 
       /* Font Dicts are not limited to 256 for CFF2. */
       /* TODO: support this for CFF2                 */
       if ( fd_index.count > CFF_MAX_CID_FONTS )
       {
         FT_TRACE0(( "cff_font_load: FD array too large in CID font\n" ));
         goto Fail_CID;
       }
 
       /* allocate & read each font dict independently */
       font->num_subfonts = fd_index.count;
       if ( FT_NEW_ARRAY( sub, fd_index.count ) )
         goto Fail_CID;
 
       /* set up pointer table */
       for ( idx = 0; idx < fd_index.count; idx++ )
         font->subfonts[idx] = sub + idx;
 
       /* now load each subfont independently */
       for ( idx = 0; idx < fd_index.count; idx++ )
       {
         sub = font->subfonts[idx];
         FT_TRACE4(( "parsing subfont %u\n", idx ));
         error = cff_subfont_load( sub,
                                   &fd_index,
                                   idx,
                                   stream,
                                   base_offset,
                                   cff2 ? CFF2_CODE_FONTDICT
                                        : CFF_CODE_TOPDICT,
                                   font );
         if ( error )
           goto Fail_CID;
       }
 
       /* now load the FD Select array;               */
       /* CFF2 omits FDSelect if there is only one FD */
       if ( !cff2 || fd_index.count > 1 )
         error = CFF_Load_FD_Select( &font->fd_select,
                                     font->charstrings_index.count,
                                     stream,
                                     base_offset + dict->cid_fd_select_offset );
 
     Fail_CID:
       cff_index_done( &fd_index );
 
       if ( error )
         goto Exit;
     }
     else
       font->num_subfonts = 0;
 
     /* read the charstrings index now */
     if ( dict->charstrings_offset == 0 )
     {
       FT_ERROR(( "cff_font_load: no charstrings offset\n" ));
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     font->num_glyphs = font->charstrings_index.count;
 
     error = cff_index_get_pointers( &font->global_subrs_index,
                                     &font->global_subrs, NULL, NULL );
 
     if ( error )
       goto Exit;
 
     /* read the Charset and Encoding tables if available */
     if ( !cff2 && font->num_glyphs > 0 )
     {
       FT_Bool  invert = FT_BOOL( dict->cid_registry != 0xFFFFU && pure_cff );
 
 
       error = cff_charset_load( &font->charset, font->num_glyphs, stream,
                                 base_offset, dict->charset_offset, invert );
       if ( error )
         goto Exit;
 
       /* CID-keyed CFFs don't have an encoding */
       if ( dict->cid_registry == 0xFFFFU )
       {
         error = cff_encoding_load( &font->encoding,
                                    &font->charset,
                                    font->num_glyphs,
                                    stream,
                                    base_offset,
                                    dict->encoding_offset );
         if ( error )
           goto Exit;
       }
     }
 
     /* get the font name (/CIDFontName for CID-keyed fonts, */
     /* /FontName otherwise)                                 */
     font->font_name = cff_index_get_name( font, subfont_index );
 
   Exit:
     cff_index_done( &string_index );
 
     return error;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_font_done( CFF_Font  font )
   {
     FT_Memory  memory = font->memory;
     FT_UInt    idx;
 
 
     cff_index_done( &font->global_subrs_index );
     cff_index_done( &font->font_dict_index );
     cff_index_done( &font->name_index );
     cff_index_done( &font->charstrings_index );
 
     /* release font dictionaries, but only if working with */
     /* a CID keyed CFF font or a CFF2 font                 */
     if ( font->num_subfonts > 0 )
     {
       for ( idx = 0; idx < font->num_subfonts; idx++ )
         cff_subfont_done( memory, font->subfonts[idx] );
 
       /* the subfonts array has been allocated as a single block */
       FT_FREE( font->subfonts[0] );
     }
 
     cff_encoding_done( &font->encoding );
     cff_charset_done( &font->charset, font->stream );
+    cff_vstore_done( &font->vstore, memory );
 
     cff_subfont_done( memory, &font->top_font );
 
     CFF_Done_FD_Select( &font->fd_select, font->stream );
 
     FT_FREE( font->font_info );
 
     FT_FREE( font->font_name );
     FT_FREE( font->global_subrs );
     FT_FREE( font->strings );
     FT_FREE( font->string_pool );
 
     if ( font->cf2_instance.finalizer )
     {
       font->cf2_instance.finalizer( font->cf2_instance.data );
       FT_FREE( font->cf2_instance.data );
     }
   }
 
 
 /* END */
diff --git a/src/cff/cffload.h b/src/cff/cffload.h
index e087fcd2c..9924a8a1d 100644
--- a/src/cff/cffload.h
+++ b/src/cff/cffload.h
@@ -1,87 +1,107 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cffload.h                                                              */
 /*                                                                         */
 /*    OpenType & CFF data/program tables loader (specification).           */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #ifndef CFFLOAD_H_
 #define CFFLOAD_H_
 
 
 #include <ft2build.h>
 #include "cfftypes.h"
+#include "cffparse.h"
 
 
 FT_BEGIN_HEADER
 
   FT_LOCAL( FT_UShort )
   cff_get_standard_encoding( FT_UInt  charcode );
 
 
   FT_LOCAL( FT_String* )
   cff_index_get_string( CFF_Font  font,
                         FT_UInt   element );
 
   FT_LOCAL( FT_String* )
   cff_index_get_sid_string( CFF_Font  font,
                             FT_UInt   sid );
 
 
   FT_LOCAL( FT_Error )
   cff_index_access_element( CFF_Index  idx,
                             FT_UInt    element,
                             FT_Byte**  pbytes,
                             FT_ULong*  pbyte_len );
 
   FT_LOCAL( void )
   cff_index_forget_element( CFF_Index  idx,
                             FT_Byte**  pbytes );
 
   FT_LOCAL( FT_String* )
   cff_index_get_name( CFF_Font  font,
                       FT_UInt   element );
 
 
   FT_LOCAL( FT_UInt )
   cff_charset_cid_to_gindex( CFF_Charset  charset,
                              FT_UInt      cid );
 
 
   FT_LOCAL( FT_Error )
   cff_font_load( FT_Library  library,
                  FT_Stream   stream,
                  FT_Int      face_index,
                  CFF_Font    font,
                  FT_Bool     pure_cff,
                  FT_Bool     cff2 );
 
   FT_LOCAL( void )
   cff_font_done( CFF_Font  font );
 
 
   FT_LOCAL( FT_Byte )
   cff_fd_select_get( CFF_FDSelect  fdselect,
                      FT_UInt       glyph_index );
 
+  FT_LOCAL( FT_Bool )
+  cff_blend_check_vector( CFF_Blend  blend,
+                          FT_UInt    vsindex,
+                          FT_UInt    lenNDV,
+                          FT_Fixed*  NDV );
+
+  FT_LOCAL( FT_Error )
+  cff_blend_build_vector( CFF_Blend  blend,
+                          FT_UInt    vsindex,
+                          FT_UInt    lenNDV,
+                          FT_Fixed*  NDV );
+
+  FT_LOCAL( void )
+  cff_blend_clear( CFF_SubFont  subFont );
+
+  FT_LOCAL( FT_Error )
+  cff_blend_doBlend( CFF_SubFont  subfont,
+                     CFF_Parser   parser,
+                     FT_UInt      numBlends );
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
   FT_LOCAL( FT_Error )
   cff_get_var_blend( CFF_Face    face,
                      FT_UInt    *num_coords,
                      FT_Fixed*  *coords );
 
   FT_LOCAL( void )
   cff_done_blend( CFF_Face  face );
 #endif
diff --git a/src/cff/cffobjs.c b/src/cff/cffobjs.c
index 7302e0326..394633b16 100644
--- a/src/cff/cffobjs.c
+++ b/src/cff/cffobjs.c
@@ -1,1136 +1,1141 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cffobjs.c                                                              */
 /*                                                                         */
 /*    OpenType objects manager (body).                                     */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include <ft2build.h>
 
 #include FT_INTERNAL_DEBUG_H
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_STREAM_H
 #include FT_ERRORS_H
 #include FT_TRUETYPE_IDS_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_INTERNAL_SFNT_H
 #include FT_CFF_DRIVER_H
 
 #include "cffobjs.h"
 #include "cffload.h"
 #include "cffcmap.h"
 #include "cffpic.h"
 
 #include "cfferrs.h"
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_cffobjs
 
 
   /*************************************************************************/
   /*                                                                       */
   /*                            SIZE FUNCTIONS                             */
   /*                                                                       */
   /*  Note that we store the global hints in the size's `internal' root    */
   /*  field.                                                               */
   /*                                                                       */
   /*************************************************************************/
 
 
   static PSH_Globals_Funcs
   cff_size_get_globals_funcs( CFF_Size  size )
   {
     CFF_Face          face     = (CFF_Face)size->root.face;
     CFF_Font          font     = (CFF_Font)face->extra.data;
     PSHinter_Service  pshinter = font->pshinter;
     FT_Module         module;
 
 
     module = FT_Get_Module( size->root.face->driver->root.library,
                             "pshinter" );
     return ( module && pshinter && pshinter->get_globals_funcs )
            ? pshinter->get_globals_funcs( module )
            : 0;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_size_done( FT_Size  cffsize )        /* CFF_Size */
   {
     CFF_Size      size     = (CFF_Size)cffsize;
     CFF_Face      face     = (CFF_Face)size->root.face;
     CFF_Font      font     = (CFF_Font)face->extra.data;
     CFF_Internal  internal = (CFF_Internal)cffsize->internal;
 
 
     if ( internal )
     {
       PSH_Globals_Funcs  funcs;
 
 
       funcs = cff_size_get_globals_funcs( size );
       if ( funcs )
       {
         FT_UInt  i;
 
 
         funcs->destroy( internal->topfont );
 
         for ( i = font->num_subfonts; i > 0; i-- )
           funcs->destroy( internal->subfonts[i - 1] );
       }
 
       /* `internal' is freed by destroy_size (in ftobjs.c) */
     }
   }
 
 
   /* CFF and Type 1 private dictionaries have slightly different      */
   /* structures; we need to synthesize a Type 1 dictionary on the fly */
 
   static void
   cff_make_private_dict( CFF_SubFont  subfont,
                          PS_Private   priv )
   {
     CFF_Private  cpriv = &subfont->private_dict;
     FT_UInt      n, count;
 
 
     FT_ZERO( priv );
 
     count = priv->num_blue_values = cpriv->num_blue_values;
     for ( n = 0; n < count; n++ )
       priv->blue_values[n] = (FT_Short)cpriv->blue_values[n];
 
     count = priv->num_other_blues = cpriv->num_other_blues;
     for ( n = 0; n < count; n++ )
       priv->other_blues[n] = (FT_Short)cpriv->other_blues[n];
 
     count = priv->num_family_blues = cpriv->num_family_blues;
     for ( n = 0; n < count; n++ )
       priv->family_blues[n] = (FT_Short)cpriv->family_blues[n];
 
     count = priv->num_family_other_blues = cpriv->num_family_other_blues;
     for ( n = 0; n < count; n++ )
       priv->family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];
 
     priv->blue_scale = cpriv->blue_scale;
     priv->blue_shift = (FT_Int)cpriv->blue_shift;
     priv->blue_fuzz  = (FT_Int)cpriv->blue_fuzz;
 
     priv->standard_width[0]  = (FT_UShort)cpriv->standard_width;
     priv->standard_height[0] = (FT_UShort)cpriv->standard_height;
 
     count = priv->num_snap_widths = cpriv->num_snap_widths;
     for ( n = 0; n < count; n++ )
       priv->snap_widths[n] = (FT_Short)cpriv->snap_widths[n];
 
     count = priv->num_snap_heights = cpriv->num_snap_heights;
     for ( n = 0; n < count; n++ )
       priv->snap_heights[n] = (FT_Short)cpriv->snap_heights[n];
 
     priv->force_bold     = cpriv->force_bold;
     priv->language_group = cpriv->language_group;
     priv->lenIV          = cpriv->lenIV;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_size_init( FT_Size  cffsize )         /* CFF_Size */
   {
     CFF_Size           size  = (CFF_Size)cffsize;
     FT_Error           error = FT_Err_Ok;
     PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
 
 
     if ( funcs )
     {
       CFF_Face      face     = (CFF_Face)cffsize->face;
       CFF_Font      font     = (CFF_Font)face->extra.data;
       CFF_Internal  internal = NULL;
 
       PS_PrivateRec  priv;
       FT_Memory      memory = cffsize->face->memory;
 
       FT_UInt  i;
 
 
       if ( FT_NEW( internal ) )
         goto Exit;
 
       cff_make_private_dict( &font->top_font, &priv );
       error = funcs->create( cffsize->face->memory, &priv,
                              &internal->topfont );
       if ( error )
         goto Exit;
 
       for ( i = font->num_subfonts; i > 0; i-- )
       {
         CFF_SubFont  sub = font->subfonts[i - 1];
 
 
         cff_make_private_dict( sub, &priv );
         error = funcs->create( cffsize->face->memory, &priv,
                                &internal->subfonts[i - 1] );
         if ( error )
           goto Exit;
       }
 
       cffsize->internal = (FT_Size_Internal)(void*)internal;
     }
 
     size->strike_index = 0xFFFFFFFFUL;
 
   Exit:
     return error;
   }
 
 
 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
   FT_LOCAL_DEF( FT_Error )
   cff_size_select( FT_Size   size,
                    FT_ULong  strike_index )
   {
     CFF_Size           cffsize = (CFF_Size)size;
     PSH_Globals_Funcs  funcs;
 
 
     cffsize->strike_index = strike_index;
 
     FT_Select_Metrics( size->face, strike_index );
 
     funcs = cff_size_get_globals_funcs( cffsize );
 
     if ( funcs )
     {
       CFF_Face      face     = (CFF_Face)size->face;
       CFF_Font      font     = (CFF_Font)face->extra.data;
       CFF_Internal  internal = (CFF_Internal)size->internal;
 
       FT_Long  top_upm  = (FT_Long)font->top_font.font_dict.units_per_em;
       FT_UInt  i;
 
 
       funcs->set_scale( internal->topfont,
                         size->metrics.x_scale, size->metrics.y_scale,
                         0, 0 );
 
       for ( i = font->num_subfonts; i > 0; i-- )
       {
         CFF_SubFont  sub     = font->subfonts[i - 1];
         FT_Long      sub_upm = (FT_Long)sub->font_dict.units_per_em;
         FT_Pos       x_scale, y_scale;
 
 
         if ( top_upm != sub_upm )
         {
           x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
           y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
         }
         else
         {
           x_scale = size->metrics.x_scale;
           y_scale = size->metrics.y_scale;
         }
 
         funcs->set_scale( internal->subfonts[i - 1],
                           x_scale, y_scale, 0, 0 );
       }
     }
 
     return FT_Err_Ok;
   }
 
 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_size_request( FT_Size          size,
                     FT_Size_Request  req )
   {
     CFF_Size           cffsize = (CFF_Size)size;
     PSH_Globals_Funcs  funcs;
 
 
 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
     if ( FT_HAS_FIXED_SIZES( size->face ) )
     {
       CFF_Face      cffface = (CFF_Face)size->face;
       SFNT_Service  sfnt    = (SFNT_Service)cffface->sfnt;
       FT_ULong      strike_index;
 
 
       if ( sfnt->set_sbit_strike( cffface, req, &strike_index ) )
         cffsize->strike_index = 0xFFFFFFFFUL;
       else
         return cff_size_select( size, strike_index );
     }
 
 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 
     FT_Request_Metrics( size->face, req );
 
     funcs = cff_size_get_globals_funcs( cffsize );
 
     if ( funcs )
     {
       CFF_Face      cffface  = (CFF_Face)size->face;
       CFF_Font      font     = (CFF_Font)cffface->extra.data;
       CFF_Internal  internal = (CFF_Internal)size->internal;
 
       FT_Long  top_upm  = (FT_Long)font->top_font.font_dict.units_per_em;
       FT_UInt  i;
 
 
       funcs->set_scale( internal->topfont,
                         size->metrics.x_scale, size->metrics.y_scale,
                         0, 0 );
 
       for ( i = font->num_subfonts; i > 0; i-- )
       {
         CFF_SubFont  sub     = font->subfonts[i - 1];
         FT_Long      sub_upm = (FT_Long)sub->font_dict.units_per_em;
         FT_Pos       x_scale, y_scale;
 
 
         if ( top_upm != sub_upm )
         {
           x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
           y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
         }
         else
         {
           x_scale = size->metrics.x_scale;
           y_scale = size->metrics.y_scale;
         }
 
         funcs->set_scale( internal->subfonts[i - 1],
                           x_scale, y_scale, 0, 0 );
       }
     }
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /*                            SLOT  FUNCTIONS                            */
   /*                                                                       */
   /*************************************************************************/
 
   FT_LOCAL_DEF( void )
   cff_slot_done( FT_GlyphSlot  slot )
   {
     slot->internal->glyph_hints = NULL;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_slot_init( FT_GlyphSlot  slot )
   {
     CFF_Face          face     = (CFF_Face)slot->face;
     CFF_Font          font     = (CFF_Font)face->extra.data;
     PSHinter_Service  pshinter = font->pshinter;
 
 
     if ( pshinter )
     {
       FT_Module  module;
 
 
       module = FT_Get_Module( slot->face->driver->root.library,
                               "pshinter" );
       if ( module )
       {
         T2_Hints_Funcs  funcs;
 
 
         funcs = pshinter->get_t2_funcs( module );
         slot->internal->glyph_hints = (void*)funcs;
       }
     }
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /*                           FACE  FUNCTIONS                             */
   /*                                                                       */
   /*************************************************************************/
 
   static FT_String*
   cff_strcpy( FT_Memory         memory,
               const FT_String*  source )
   {
     FT_Error    error;
     FT_String*  result;
 
 
     (void)FT_STRDUP( result, source );
 
     FT_UNUSED( error );
 
     return result;
   }
 
 
   /* Strip all subset prefixes of the form `ABCDEF+'.  Usually, there */
   /* is only one, but font names like `APCOOG+JFABTD+FuturaBQ-Bold'   */
   /* have been seen in the wild.                                      */
 
   static void
   remove_subset_prefix( FT_String*  name )
   {
     FT_Int32  idx             = 0;
     FT_Int32  length          = (FT_Int32)strlen( name ) + 1;
     FT_Bool   continue_search = 1;
 
 
     while ( continue_search )
     {
       if ( length >= 7 && name[6] == '+' )
       {
         for ( idx = 0; idx < 6; idx++ )
         {
           /* ASCII uppercase letters */
           if ( !( 'A' <= name[idx] && name[idx] <= 'Z' ) )
             continue_search = 0;
         }
 
         if ( continue_search )
         {
           for ( idx = 7; idx < length; idx++ )
             name[idx - 7] = name[idx];
           length -= 7;
         }
       }
       else
         continue_search = 0;
     }
   }
 
 
   /* Remove the style part from the family name (if present). */
 
   static void
   remove_style( FT_String*        family_name,
                 const FT_String*  style_name )
   {
     FT_Int32  family_name_length, style_name_length;
 
 
     family_name_length = (FT_Int32)strlen( family_name );
     style_name_length  = (FT_Int32)strlen( style_name );
 
     if ( family_name_length > style_name_length )
     {
       FT_Int  idx;
 
 
       for ( idx = 1; idx <= style_name_length; ++idx )
       {
         if ( family_name[family_name_length - idx] !=
              style_name[style_name_length - idx] )
           break;
       }
 
       if ( idx > style_name_length )
       {
         /* family_name ends with style_name; remove it */
         idx = family_name_length - style_name_length - 1;
 
         /* also remove special characters     */
         /* between real family name and style */
         while ( idx > 0                     &&
                 ( family_name[idx] == '-' ||
                   family_name[idx] == ' ' ||
                   family_name[idx] == '_' ||
                   family_name[idx] == '+' ) )
           --idx;
 
         if ( idx > 0 )
           family_name[idx + 1] = '\0';
       }
     }
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_face_init( FT_Stream      stream,
                  FT_Face        cffface,        /* CFF_Face */
                  FT_Int         face_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
   {
     CFF_Face            face        = (CFF_Face)cffface;
     FT_Error            error;
     SFNT_Service        sfnt;
     FT_Service_PsCMaps  psnames;
     PSHinter_Service    pshinter;
     FT_Bool             pure_cff    = 1;
     FT_Bool             cff2        = 0;
     FT_Bool             sfnt_format = 0;
     FT_Library          library     = cffface->driver->root.library;
 
 
     sfnt = (SFNT_Service)FT_Get_Module_Interface(
              library, "sfnt" );
     if ( !sfnt )
     {
       FT_ERROR(( "cff_face_init: cannot access `sfnt' module\n" ));
       error = FT_THROW( Missing_Module );
       goto Exit;
     }
 
     FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
 
     pshinter = (PSHinter_Service)FT_Get_Module_Interface(
                  library, "pshinter" );
 
     FT_TRACE2(( "CFF driver\n" ));
 
     /* create input stream from resource */
     if ( FT_STREAM_SEEK( 0 ) )
       goto Exit;
 
     /* check whether we have a valid OpenType file */
     error = sfnt->init_face( stream, face, face_index, num_params, params );
     if ( !error )
     {
       if ( face->format_tag != TTAG_OTTO )  /* `OTTO'; OpenType/CFF font */
       {
         FT_TRACE2(( "  not an OpenType/CFF font\n" ));
         error = FT_THROW( Unknown_File_Format );
         goto Exit;
       }
 
       /* if we are performing a simple font format check, exit immediately */
       if ( face_index < 0 )
         return FT_Err_Ok;
 
       sfnt_format = 1;
 
       /* now, the font can be either an OpenType/CFF font, or an SVG CEF */
       /* font; in the latter case it doesn't have a `head' table         */
       error = face->goto_table( face, TTAG_head, stream, 0 );
       if ( !error )
       {
         pure_cff = 0;
 
         /* load font directory */
         error = sfnt->load_face( stream, face, face_index,
                                  num_params, params );
         if ( error )
           goto Exit;
       }
       else
       {
         /* load the `cmap' table explicitly */
         error = sfnt->load_cmap( face, stream );
         if ( error )
           goto Exit;
       }
 
       /* now load the CFF part of the file; */
       /* give priority to CFF2              */
       error = face->goto_table( face, TTAG_CFF2, stream, 0 );
       if ( !error )
       {
         cff2         = 1;
         face->isCFF2 = cff2;
       }
 
       if ( FT_ERR_EQ( error, Table_Missing ) )
         error = face->goto_table( face, TTAG_CFF, stream, 0 );
 
       if ( error )
         goto Exit;
     }
     else
     {
       /* rewind to start of file; we are going to load a pure-CFF font */
       if ( FT_STREAM_SEEK( 0 ) )
         goto Exit;
       error = FT_Err_Ok;
     }
 
     /* now load and parse the CFF table in the file */
     {
       CFF_Font         cff = NULL;
       CFF_FontRecDict  dict;
       FT_Memory        memory = cffface->memory;
       FT_Int32         flags;
       FT_UInt          i;
 
 
       if ( FT_NEW( cff ) )
         goto Exit;
 
       face->extra.data = cff;
       error = cff_font_load( library,
                              stream,
                              face_index,
                              cff,
                              pure_cff,
                              cff2 );
       if ( error )
         goto Exit;
 
       /* if we are performing a simple font format check, exit immediately */
       /* (this is here for pure CFF)                                       */
       if ( face_index < 0 )
       {
         cffface->num_faces = (FT_Long)cff->num_faces;
         return FT_Err_Ok;
       }
 
       cff->pshinter = pshinter;
       cff->psnames  = psnames;
 
       cffface->face_index = face_index & 0xFFFF;
 
       /* Complement the root flags with some interesting information. */
       /* Note that this is only necessary for pure CFF and CEF fonts; */
       /* SFNT based fonts use the `name' table instead.               */
 
       cffface->num_glyphs = (FT_Long)cff->num_glyphs;
 
       dict = &cff->top_font.font_dict;
 
       /* we need the `PSNames' module for CFF and CEF formats */
       /* which aren't CID-keyed                               */
       if ( dict->cid_registry == 0xFFFFU && !psnames )
       {
         FT_ERROR(( "cff_face_init:"
                    " cannot open CFF & CEF fonts\n"
                    "              "
                    " without the `PSNames' module\n" ));
         error = FT_THROW( Missing_Module );
         goto Exit;
       }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
       {
         FT_UInt     idx;
         FT_String*  s;
 
 
         FT_TRACE4(( "SIDs\n" ));
 
         /* dump string index, including default strings for convenience */
         for ( idx = 0; idx <= 390; idx++ )
         {
           s = cff_index_get_sid_string( cff, idx );
           if ( s )
             FT_TRACE4(( "  %5d %s\n", idx, s ));
         }
 
         /* In Multiple Master CFFs, two SIDs hold the Normalize Design  */
         /* Vector (NDV) and Convert Design Vector (CDV) charstrings,    */
         /* which may contain NULL bytes in the middle of the data, too. */
         /* We thus access `cff->strings' directly.                      */
         for ( idx = 1; idx < cff->num_strings; idx++ )
         {
           FT_Byte*    s1    = cff->strings[idx - 1];
           FT_Byte*    s2    = cff->strings[idx];
           FT_PtrDist  s1len = s2 - s1 - 1; /* without the final NULL byte */
           FT_PtrDist  l;
 
 
           FT_TRACE4(( "  %5d ", idx + 390 ));
           for ( l = 0; l < s1len; l++ )
             FT_TRACE4(( "%c", s1[l] ));
           FT_TRACE4(( "\n" ));
         }
 
         /* print last element */
         if ( cff->num_strings )
         {
           FT_Byte*    s1    = cff->strings[cff->num_strings - 1];
           FT_Byte*    s2    = cff->string_pool + cff->string_pool_size;
           FT_PtrDist  s1len = s2 - s1 - 1;
           FT_PtrDist  l;
 
 
           FT_TRACE4(( "  %5d ", cff->num_strings + 390 ));
           for ( l = 0; l < s1len; l++ )
             FT_TRACE4(( "%c", s1[l] ));
           FT_TRACE4(( "\n" ));
         }
       }
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
       if ( !dict->has_font_matrix )
         dict->units_per_em = pure_cff ? 1000 : face->root.units_per_EM;
 
       /* Normalize the font matrix so that `matrix->yy' is 1; if  */
       /* it is zero, we use `matrix->yx' instead.  The scaling is */
       /* done with `units_per_em' then (at this point, it already */
       /* contains the scaling factor, but without normalization   */
       /* of the matrix).                                          */
       /*                                                          */
       /* Note that the offsets must be expressed in integer font  */
       /* units.                                                   */
 
       {
         FT_Matrix*  matrix = &dict->font_matrix;
         FT_Vector*  offset = &dict->font_offset;
         FT_ULong*   upm    = &dict->units_per_em;
         FT_Fixed    temp;
 
 
         temp = matrix->yy ? FT_ABS( matrix->yy )
                           : FT_ABS( matrix->yx );
 
         if ( temp != 0x10000L )
         {
           *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );
 
           matrix->xx = FT_DivFix( matrix->xx, temp );
           matrix->yx = FT_DivFix( matrix->yx, temp );
           matrix->xy = FT_DivFix( matrix->xy, temp );
           matrix->yy = FT_DivFix( matrix->yy, temp );
           offset->x  = FT_DivFix( offset->x,  temp );
           offset->y  = FT_DivFix( offset->y,  temp );
         }
 
         offset->x >>= 16;
         offset->y >>= 16;
       }
 
       for ( i = cff->num_subfonts; i > 0; i-- )
       {
         CFF_FontRecDict  sub = &cff->subfonts[i - 1]->font_dict;
         CFF_FontRecDict  top = &cff->top_font.font_dict;
 
         FT_Matrix*  matrix;
         FT_Vector*  offset;
         FT_ULong*   upm;
         FT_Fixed    temp;
 
 
         if ( sub->has_font_matrix )
         {
           FT_Long  scaling;
 
 
           /* if we have a top-level matrix, */
           /* concatenate the subfont matrix */
 
           if ( top->has_font_matrix )
           {
             if ( top->units_per_em > 1 && sub->units_per_em > 1 )
               scaling = (FT_Long)FT_MIN( top->units_per_em,
                                          sub->units_per_em );
             else
               scaling = 1;
 
             FT_Matrix_Multiply_Scaled( &top->font_matrix,
                                        &sub->font_matrix,
                                        scaling );
             FT_Vector_Transform_Scaled( &sub->font_offset,
                                         &top->font_matrix,
                                         scaling );
 
             sub->units_per_em = (FT_ULong)
                                   FT_MulDiv( (FT_Long)sub->units_per_em,
                                              (FT_Long)top->units_per_em,
                                              scaling );
           }
         }
         else
         {
           sub->font_matrix = top->font_matrix;
           sub->font_offset = top->font_offset;
 
           sub->units_per_em = top->units_per_em;
         }
 
         matrix = &sub->font_matrix;
         offset = &sub->font_offset;
         upm    = &sub->units_per_em;
 
         temp = matrix->yy ? FT_ABS( matrix->yy )
                           : FT_ABS( matrix->yx );
 
 
         if ( temp != 0x10000L )
         {
           *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );
 
           matrix->xx = FT_DivFix( matrix->xx, temp );
           matrix->yx = FT_DivFix( matrix->yx, temp );
           matrix->xy = FT_DivFix( matrix->xy, temp );
           matrix->yy = FT_DivFix( matrix->yy, temp );
           offset->x  = FT_DivFix( offset->x,  temp );
           offset->y  = FT_DivFix( offset->y,  temp );
         }
 
         offset->x >>= 16;
         offset->y >>= 16;
       }
 
       if ( pure_cff )
       {
         char*  style_name = NULL;
 
 
         /* set up num_faces */
         cffface->num_faces = (FT_Long)cff->num_faces;
 
         /* compute number of glyphs */
         if ( dict->cid_registry != 0xFFFFU )
           cffface->num_glyphs = (FT_Long)( cff->charset.max_cid + 1 );
         else
           cffface->num_glyphs = (FT_Long)cff->charstrings_index.count;
 
         /* set global bbox, as well as EM size */
         cffface->bbox.xMin =   dict->font_bbox.xMin            >> 16;
         cffface->bbox.yMin =   dict->font_bbox.yMin            >> 16;
         /* no `U' suffix here to 0xFFFF! */
         cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFF ) >> 16;
         cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFF ) >> 16;
 
         cffface->units_per_EM = (FT_UShort)( dict->units_per_em );
 
         cffface->ascender  = (FT_Short)( cffface->bbox.yMax );
         cffface->descender = (FT_Short)( cffface->bbox.yMin );
 
         cffface->height = (FT_Short)( ( cffface->units_per_EM * 12 ) / 10 );
         if ( cffface->height < cffface->ascender - cffface->descender )
           cffface->height = (FT_Short)( cffface->ascender - cffface->descender );
 
         cffface->underline_position  =
           (FT_Short)( dict->underline_position >> 16 );
         cffface->underline_thickness =
           (FT_Short)( dict->underline_thickness >> 16 );
 
         /* retrieve font family & style name */
         cffface->family_name = cff_index_get_name(
                                  cff,
                                  (FT_UInt)( face_index & 0xFFFF ) );
         if ( cffface->family_name )
         {
           char*  full   = cff_index_get_sid_string( cff,
                                                     dict->full_name );
           char*  fullp  = full;
           char*  family = cffface->family_name;
           char*  family_name = NULL;
 
 
           remove_subset_prefix( cffface->family_name );
 
           if ( dict->family_name )
           {
             family_name = cff_index_get_sid_string( cff,
                                                     dict->family_name );
             if ( family_name )
               family = family_name;
           }
 
           /* We try to extract the style name from the full name.   */
           /* We need to ignore spaces and dashes during the search. */
           if ( full && family )
           {
             while ( *fullp )
             {
               /* skip common characters at the start of both strings */
               if ( *fullp == *family )
               {
                 family++;
                 fullp++;
                 continue;
               }
 
               /* ignore spaces and dashes in full name during comparison */
               if ( *fullp == ' ' || *fullp == '-' )
               {
                 fullp++;
                 continue;
               }
 
               /* ignore spaces and dashes in family name during comparison */
               if ( *family == ' ' || *family == '-' )
               {
                 family++;
                 continue;
               }
 
               if ( !*family && *fullp )
               {
                 /* The full name begins with the same characters as the  */
                 /* family name, with spaces and dashes removed.  In this */
                 /* case, the remaining string in `fullp' will be used as */
                 /* the style name.                                       */
                 style_name = cff_strcpy( memory, fullp );
 
                 /* remove the style part from the family name (if present) */
                 remove_style( cffface->family_name, style_name );
               }
               break;
             }
           }
         }
         else
         {
           char  *cid_font_name =
                    cff_index_get_sid_string( cff,
                                              dict->cid_font_name );
 
 
           /* do we have a `/FontName' for a CID-keyed font? */
           if ( cid_font_name )
             cffface->family_name = cff_strcpy( memory, cid_font_name );
         }
 
         if ( style_name )
           cffface->style_name = style_name;
         else
           /* assume "Regular" style if we don't know better */
           cffface->style_name = cff_strcpy( memory, (char *)"Regular" );
 
         /*******************************************************************/
         /*                                                                 */
         /* Compute face flags.                                             */
         /*                                                                 */
         flags = FT_FACE_FLAG_SCALABLE   | /* scalable outlines */
                 FT_FACE_FLAG_HORIZONTAL | /* horizontal data   */
                 FT_FACE_FLAG_HINTER;      /* has native hinter */
 
         if ( sfnt_format )
           flags |= FT_FACE_FLAG_SFNT;
 
         /* fixed width font? */
         if ( dict->is_fixed_pitch )
           flags |= FT_FACE_FLAG_FIXED_WIDTH;
 
   /* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
 #if 0
         /* kerning available? */
         if ( face->kern_pairs )
           flags |= FT_FACE_FLAG_KERNING;
 #endif
 
         cffface->face_flags |= flags;
 
         /*******************************************************************/
         /*                                                                 */
         /* Compute style flags.                                            */
         /*                                                                 */
         flags = 0;
 
         if ( dict->italic_angle )
           flags |= FT_STYLE_FLAG_ITALIC;
 
         {
           char  *weight = cff_index_get_sid_string( cff,
                                                     dict->weight );
 
 
           if ( weight )
             if ( !ft_strcmp( weight, "Bold"  ) ||
                  !ft_strcmp( weight, "Black" ) )
               flags |= FT_STYLE_FLAG_BOLD;
         }
 
         /* double check */
         if ( !(flags & FT_STYLE_FLAG_BOLD) && cffface->style_name )
           if ( !ft_strncmp( cffface->style_name, "Bold", 4 )  ||
                !ft_strncmp( cffface->style_name, "Black", 5 ) )
             flags |= FT_STYLE_FLAG_BOLD;
 
         cffface->style_flags = flags;
       }
 
 
 #ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES
       /* CID-keyed CFF fonts don't have glyph names -- the SFNT loader */
       /* has unset this flag because of the 3.0 `post' table.          */
       if ( dict->cid_registry == 0xFFFFU )
         cffface->face_flags |= FT_FACE_FLAG_GLYPH_NAMES;
 #endif
 
       if ( dict->cid_registry != 0xFFFFU && pure_cff )
         cffface->face_flags |= FT_FACE_FLAG_CID_KEYED;
 
 
       /*******************************************************************/
       /*                                                                 */
       /* Compute char maps.                                              */
       /*                                                                 */
 
       /* Try to synthesize a Unicode charmap if there is none available */
       /* already.  If an OpenType font contains a Unicode "cmap", we    */
       /* will use it, whatever be in the CFF part of the file.          */
       {
         FT_CharMapRec  cmaprec;
         FT_CharMap     cmap;
         FT_UInt        nn;
         CFF_Encoding   encoding = &cff->encoding;
 
 
         for ( nn = 0; nn < (FT_UInt)cffface->num_charmaps; nn++ )
         {
           cmap = cffface->charmaps[nn];
 
           /* Windows Unicode? */
           if ( cmap->platform_id == TT_PLATFORM_MICROSOFT &&
                cmap->encoding_id == TT_MS_ID_UNICODE_CS   )
             goto Skip_Unicode;
 
           /* Apple Unicode platform id? */
           if ( cmap->platform_id == TT_PLATFORM_APPLE_UNICODE )
             goto Skip_Unicode; /* Apple Unicode */
         }
 
         /* since CID-keyed fonts don't contain glyph names, we can't */
         /* construct a cmap                                          */
         if ( pure_cff && cff->top_font.font_dict.cid_registry != 0xFFFFU )
           goto Exit;
 
         /* we didn't find a Unicode charmap -- synthesize one */
         cmaprec.face        = cffface;
         cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
         cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
         cmaprec.encoding    = FT_ENCODING_UNICODE;
 
         nn = (FT_UInt)cffface->num_charmaps;
 
         error = FT_CMap_New( &CFF_CMAP_UNICODE_CLASS_REC_GET, NULL,
                              &cmaprec, NULL );
         if ( error                                      &&
              FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
           goto Exit;
         error = FT_Err_Ok;
 
         /* if no Unicode charmap was previously selected, select this one */
         if ( cffface->charmap == NULL && nn != (FT_UInt)cffface->num_charmaps )
           cffface->charmap = cffface->charmaps[nn];
 
       Skip_Unicode:
         if ( encoding->count > 0 )
         {
           FT_CMap_Class  clazz;
 
 
           cmaprec.face        = cffface;
           cmaprec.platform_id = TT_PLATFORM_ADOBE;  /* Adobe platform id */
 
           if ( encoding->offset == 0 )
           {
             cmaprec.encoding_id = TT_ADOBE_ID_STANDARD;
             cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;
             clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
           }
           else if ( encoding->offset == 1 )
           {
             cmaprec.encoding_id = TT_ADOBE_ID_EXPERT;
             cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;
             clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
           }
           else
           {
             cmaprec.encoding_id = TT_ADOBE_ID_CUSTOM;
             cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;
             clazz               = &CFF_CMAP_ENCODING_CLASS_REC_GET;
           }
 
           error = FT_CMap_New( clazz, NULL, &cmaprec, NULL );
         }
       }
     }
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_face_done( FT_Face  cffface )         /* CFF_Face */
   {
     CFF_Face      face = (CFF_Face)cffface;
     FT_Memory     memory;
     SFNT_Service  sfnt;
 
 
     if ( !face )
       return;
 
     memory = cffface->memory;
     sfnt   = (SFNT_Service)face->sfnt;
 
     if ( sfnt )
       sfnt->done_face( face );
 
     {
       CFF_Font  cff = (CFF_Font)face->extra.data;
 
 
       if ( cff )
       {
         cff_font_done( cff );
         FT_FREE( face->extra.data );
       }
     }
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+    cff_done_blend( face );
+    face->blend = NULL;
+#endif
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_driver_init( FT_Module  module )        /* CFF_Driver */
   {
     CFF_Driver  driver = (CFF_Driver)module;
 
 
     /* set default property values, cf. `ftcffdrv.h' */
 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
     driver->hinting_engine = FT_CFF_HINTING_FREETYPE;
 #else
     driver->hinting_engine = FT_CFF_HINTING_ADOBE;
 #endif
 
     driver->no_stem_darkening = TRUE;
 
     driver->darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
     driver->darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
     driver->darken_params[2] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2;
     driver->darken_params[3] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2;
     driver->darken_params[4] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3;
     driver->darken_params[5] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3;
     driver->darken_params[6] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4;
     driver->darken_params[7] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4;
 
     return FT_Err_Ok;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_driver_done( FT_Module  module )        /* CFF_Driver */
   {
     FT_UNUSED( module );
   }
 
 
 /* END */
diff --git a/src/cff/cffparse.c b/src/cff/cffparse.c
index 4a81230b0..022c28951 100644
--- a/src/cff/cffparse.c
+++ b/src/cff/cffparse.c
@@ -1,1491 +1,1611 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cffparse.c                                                             */
 /*                                                                         */
 /*    CFF token stream parser (body)                                       */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #include <ft2build.h>
 #include "cffparse.h"
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_DEBUG_H
 
 #include "cfferrs.h"
 #include "cffpic.h"
 #include "cffgload.h"
+#include "cffload.h"
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_cffparse
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_parser_init( CFF_Parser  parser,
                    FT_UInt     code,
                    void*       object,
                    FT_Library  library,
                    FT_UInt     stackSize,
                    FT_UShort   num_designs,
                    FT_UShort   num_axes )
   {
     FT_Memory  memory = library->memory;    /* for FT_NEW_ARRAY */
     FT_Error   error;                       /* for FT_NEW_ARRAY */
 
 
     FT_ZERO( parser );
 
 #if 0
     parser->top         = parser->stack;
 #endif
     parser->object_code = code;
     parser->object      = object;
     parser->library     = library;
     parser->num_designs = num_designs;
     parser->num_axes    = num_axes;
 
     /* allocate the stack buffer */
     if ( FT_NEW_ARRAY( parser->stack, stackSize ) )
     {
       FT_FREE( parser->stack );
       goto Exit;
     }
 
     parser->stackSize = stackSize;
     parser->top       = parser->stack;    /* empty stack */
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( void )
   cff_parser_done( CFF_Parser  parser )
   {
     FT_Memory  memory = parser->library->memory;    /* for FT_FREE */
 
 
     FT_FREE( parser->stack );
   }
 
 
   /* read an integer */
   static FT_Long
   cff_parse_integer( FT_Byte*  start,
                      FT_Byte*  limit )
   {
     FT_Byte*  p   = start;
     FT_Int    v   = *p++;
     FT_Long   val = 0;
 
 
     if ( v == 28 )
     {
       if ( p + 2 > limit )
         goto Bad;
 
       val = (FT_Short)( ( (FT_UShort)p[0] << 8 ) | p[1] );
     }
     else if ( v == 29 )
     {
       if ( p + 4 > limit )
         goto Bad;
 
       val = (FT_Long)( ( (FT_ULong)p[0] << 24 ) |
                        ( (FT_ULong)p[1] << 16 ) |
                        ( (FT_ULong)p[2] <<  8 ) |
                          (FT_ULong)p[3]         );
     }
     else if ( v < 247 )
     {
       val = v - 139;
     }
     else if ( v < 251 )
     {
       if ( p + 1 > limit )
         goto Bad;
 
       val = ( v - 247 ) * 256 + p[0] + 108;
     }
     else
     {
       if ( p + 1 > limit )
         goto Bad;
 
       val = -( v - 251 ) * 256 - p[0] - 108;
     }
 
   Exit:
     return val;
 
   Bad:
     val = 0;
     FT_TRACE4(( "!!!END OF DATA:!!!" ));
     goto Exit;
   }
 
 
   static const FT_Long power_tens[] =
   {
     1L,
     10L,
     100L,
     1000L,
     10000L,
     100000L,
     1000000L,
     10000000L,
     100000000L,
     1000000000L
   };
 
 
   /* read a real */
   static FT_Fixed
   cff_parse_real( FT_Byte*  start,
                   FT_Byte*  limit,
                   FT_Long   power_ten,
                   FT_Long*  scaling )
   {
     FT_Byte*  p = start;
     FT_Int    nib;
     FT_UInt   phase;
 
     FT_Long   result, number, exponent;
     FT_Int    sign = 0, exponent_sign = 0, have_overflow = 0;
     FT_Long   exponent_add, integer_length, fraction_length;
 
 
     if ( scaling )
       *scaling = 0;
 
     result = 0;
 
     number   = 0;
     exponent = 0;
 
     exponent_add    = 0;
     integer_length  = 0;
     fraction_length = 0;
 
     /* First of all, read the integer part. */
     phase = 4;
 
     for (;;)
     {
       /* If we entered this iteration with phase == 4, we need to */
       /* read a new byte.  This also skips past the initial 0x1E. */
       if ( phase )
       {
         p++;
 
         /* Make sure we don't read past the end. */
         if ( p >= limit )
           goto Bad;
       }
 
       /* Get the nibble. */
       nib   = (FT_Int)( p[0] >> phase ) & 0xF;
       phase = 4 - phase;
 
       if ( nib == 0xE )
         sign = 1;
       else if ( nib > 9 )
         break;
       else
       {
         /* Increase exponent if we can't add the digit. */
         if ( number >= 0xCCCCCCCL )
           exponent_add++;
         /* Skip leading zeros. */
         else if ( nib || number )
         {
           integer_length++;
           number = number * 10 + nib;
         }
       }
     }
 
     /* Read fraction part, if any. */
     if ( nib == 0xA )
       for (;;)
       {
         /* If we entered this iteration with phase == 4, we need */
         /* to read a new byte.                                   */
         if ( phase )
         {
           p++;
 
           /* Make sure we don't read past the end. */
           if ( p >= limit )
             goto Bad;
         }
 
         /* Get the nibble. */
         nib   = ( p[0] >> phase ) & 0xF;
         phase = 4 - phase;
         if ( nib >= 10 )
           break;
 
         /* Skip leading zeros if possible. */
         if ( !nib && !number )
           exponent_add--;
         /* Only add digit if we don't overflow. */
         else if ( number < 0xCCCCCCCL && fraction_length < 9 )
         {
           fraction_length++;
           number = number * 10 + nib;
         }
       }
 
     /* Read exponent, if any. */
     if ( nib == 12 )
     {
       exponent_sign = 1;
       nib           = 11;
     }
 
     if ( nib == 11 )
     {
       for (;;)
       {
         /* If we entered this iteration with phase == 4, */
         /* we need to read a new byte.                   */
         if ( phase )
         {
           p++;
 
           /* Make sure we don't read past the end. */
           if ( p >= limit )
             goto Bad;
         }
 
         /* Get the nibble. */
         nib   = ( p[0] >> phase ) & 0xF;
         phase = 4 - phase;
         if ( nib >= 10 )
           break;
 
         /* Arbitrarily limit exponent. */
         if ( exponent > 1000 )
           have_overflow = 1;
         else
           exponent = exponent * 10 + nib;
       }
 
       if ( exponent_sign )
         exponent = -exponent;
     }
 
     if ( !number )
       goto Exit;
 
     if ( have_overflow )
     {
       if ( exponent_sign )
         goto Underflow;
       else
         goto Overflow;
     }
 
     /* We don't check `power_ten' and `exponent_add'. */
     exponent += power_ten + exponent_add;
 
     if ( scaling )
     {
       /* Only use `fraction_length'. */
       fraction_length += integer_length;
       exponent        += integer_length;
 
       if ( fraction_length <= 5 )
       {
         if ( number > 0x7FFFL )
         {
           result   = FT_DivFix( number, 10 );
           *scaling = exponent - fraction_length + 1;
         }
         else
         {
           if ( exponent > 0 )
           {
             FT_Long  new_fraction_length, shift;
 
 
             /* Make `scaling' as small as possible. */
             new_fraction_length = FT_MIN( exponent, 5 );
             shift               = new_fraction_length - fraction_length;
 
             if ( shift > 0 )
             {
               exponent -= new_fraction_length;
               number   *= power_tens[shift];
               if ( number > 0x7FFFL )
               {
                 number   /= 10;
                 exponent += 1;
               }
             }
             else
               exponent -= fraction_length;
           }
           else
             exponent -= fraction_length;
 
           result   = (FT_Long)( (FT_ULong)number << 16 );
           *scaling = exponent;
         }
       }
       else
       {
         if ( ( number / power_tens[fraction_length - 5] ) > 0x7FFFL )
         {
           result   = FT_DivFix( number, power_tens[fraction_length - 4] );
           *scaling = exponent - 4;
         }
         else
         {
           result   = FT_DivFix( number, power_tens[fraction_length - 5] );
           *scaling = exponent - 5;
         }
       }
     }
     else
     {
       integer_length  += exponent;
       fraction_length -= exponent;
 
       if ( integer_length > 5 )
         goto Overflow;
       if ( integer_length < -5 )
         goto Underflow;
 
       /* Remove non-significant digits. */
       if ( integer_length < 0 )
       {
         number          /= power_tens[-integer_length];
         fraction_length += integer_length;
       }
 
       /* this can only happen if exponent was non-zero */
       if ( fraction_length == 10 )
       {
         number          /= 10;
         fraction_length -= 1;
       }
 
       /* Convert into 16.16 format. */
       if ( fraction_length > 0 )
       {
         if ( ( number / power_tens[fraction_length] ) > 0x7FFFL )
           goto Exit;
 
         result = FT_DivFix( number, power_tens[fraction_length] );
       }
       else
       {
         number *= power_tens[-fraction_length];
 
         if ( number > 0x7FFFL )
           goto Overflow;
 
         result = (FT_Long)( (FT_ULong)number << 16 );
       }
     }
 
   Exit:
     if ( sign )
       result = -result;
 
     return result;
 
   Overflow:
     result = 0x7FFFFFFFL;
     FT_TRACE4(( "!!!OVERFLOW:!!!" ));
     goto Exit;
 
   Underflow:
     result = 0;
     FT_TRACE4(( "!!!UNDERFLOW:!!!" ));
     goto Exit;
 
   Bad:
     result = 0;
     FT_TRACE4(( "!!!END OF DATA:!!!" ));
     goto Exit;
   }
 
 
   /* read a number, either integer or real */
   FT_LOCAL_DEF( FT_Long )
   cff_parse_num( CFF_Parser  parser,
                  FT_Byte**   d )
   {
     if ( **d == 30 )
     {
       /* binary-coded decimal is truncated to integer */
       return cff_parse_real( *d, parser->limit, 0, NULL ) >> 16;
     }
+
+    else if ( **d == 255 )
+    {
+      /* 16.16 fixed point is used internally for CFF2 blend results. */
+      /* Since these are trusted values, a limit check is not needed. */
+
+      /* After the 255, 4 bytes are in host order. */
+      /* Blend result is rounded to integer.       */
+      return (FT_Long)( *( (FT_UInt32 *) ( d[0] + 1 ) ) + 0x8000U ) >> 16;
+    }
+
     else
       return cff_parse_integer( *d, parser->limit );
   }
 
 
   /* read a floating point number, either integer or real */
   static FT_Fixed
   do_fixed( CFF_Parser  parser,
             FT_Byte**   d,
             FT_Long     scaling )
   {
     if ( **d == 30 )
       return cff_parse_real( *d, parser->limit, scaling, NULL );
     else
     {
       FT_Long  val = cff_parse_integer( *d, parser->limit );
 
 
       if ( scaling )
         val *= power_tens[scaling];
 
       if ( val > 0x7FFF )
       {
         val = 0x7FFFFFFFL;
         goto Overflow;
       }
       else if ( val < -0x7FFF )
       {
         val = -0x7FFFFFFFL;
         goto Overflow;
       }
 
       return (FT_Long)( (FT_ULong)val << 16 );
 
     Overflow:
       FT_TRACE4(( "!!!OVERFLOW:!!!" ));
       return val;
     }
   }
 
 
   /* read a floating point number, either integer or real */
   static FT_Fixed
   cff_parse_fixed( CFF_Parser  parser,
                    FT_Byte**   d )
   {
     return do_fixed( parser, d, 0 );
   }
 
 
   /* read a floating point number, either integer or real, */
   /* but return `10^scaling' times the number read in      */
   static FT_Fixed
   cff_parse_fixed_scaled( CFF_Parser  parser,
                           FT_Byte**   d,
                           FT_Long     scaling )
   {
     return do_fixed( parser, d, scaling );
   }
 
 
   /* read a floating point number, either integer or real,     */
   /* and return it as precise as possible -- `scaling' returns */
   /* the scaling factor (as a power of 10)                     */
   static FT_Fixed
   cff_parse_fixed_dynamic( CFF_Parser  parser,
                            FT_Byte**   d,
                            FT_Long*    scaling )
   {
     FT_ASSERT( scaling );
 
     if ( **d == 30 )
       return cff_parse_real( *d, parser->limit, 0, scaling );
     else
     {
       FT_Long  number;
       FT_Int   integer_length;
 
 
       number = cff_parse_integer( d[0], d[1] );
 
       if ( number > 0x7FFFL )
       {
         for ( integer_length = 5; integer_length < 10; integer_length++ )
           if ( number < power_tens[integer_length] )
             break;
 
         if ( ( number / power_tens[integer_length - 5] ) > 0x7FFFL )
         {
           *scaling = integer_length - 4;
           return FT_DivFix( number, power_tens[integer_length - 4] );
         }
         else
         {
           *scaling = integer_length - 5;
           return FT_DivFix( number, power_tens[integer_length - 5] );
         }
       }
       else
       {
         *scaling = 0;
         return (FT_Long)( (FT_ULong)number << 16 );
       }
     }
   }
 
 
   static FT_Error
   cff_parse_font_matrix( CFF_Parser  parser )
   {
     CFF_FontRecDict  dict   = (CFF_FontRecDict)parser->object;
     FT_Matrix*       matrix = &dict->font_matrix;
     FT_Vector*       offset = &dict->font_offset;
     FT_ULong*        upm    = &dict->units_per_em;
     FT_Byte**        data   = parser->stack;
     FT_Error         error  = FT_ERR( Stack_Underflow );
 
 
     if ( parser->top >= parser->stack + 6 )
     {
       FT_Fixed  values[6];
       FT_Long   scalings[6];
 
       FT_Long  min_scaling, max_scaling;
       int      i;
 
 
       error = FT_Err_Ok;
 
       dict->has_font_matrix = TRUE;
 
       /* We expect a well-formed font matrix, this is, the matrix elements */
       /* `xx' and `yy' are of approximately the same magnitude.  To avoid  */
       /* loss of precision, we use the magnitude of the largest matrix     */
       /* element to scale all other elements.  The scaling factor is then  */
       /* contained in the `units_per_em' value.                            */
 
       max_scaling = FT_LONG_MIN;
       min_scaling = FT_LONG_MAX;
 
       for ( i = 0; i < 6; i++ )
       {
         values[i] = cff_parse_fixed_dynamic( parser, data++, &scalings[i] );
         if ( values[i] )
         {
           if ( scalings[i] > max_scaling )
             max_scaling = scalings[i];
           if ( scalings[i] < min_scaling )
             min_scaling = scalings[i];
         }
       }
 
       if ( max_scaling < -9                  ||
            max_scaling > 0                   ||
            ( max_scaling - min_scaling ) < 0 ||
            ( max_scaling - min_scaling ) > 9 )
       {
         /* Return default matrix in case of unlikely values. */
 
         FT_TRACE1(( "cff_parse_font_matrix:"
                     " strange scaling values (minimum %d, maximum %d),\n"
                     "                      "
                     " using default matrix\n", min_scaling, max_scaling ));
 
         matrix->xx = 0x10000L;
         matrix->yx = 0;
         matrix->xy = 0;
         matrix->yy = 0x10000L;
         offset->x  = 0;
         offset->y  = 0;
         *upm       = 1;
 
         goto Exit;
       }
 
       for ( i = 0; i < 6; i++ )
       {
         FT_Fixed  value = values[i];
         FT_Long   divisor, half_divisor;
 
 
         if ( !value )
           continue;
 
         divisor      = power_tens[max_scaling - scalings[i]];
         half_divisor = divisor >> 1;
 
         if ( value < 0 )
         {
           if ( FT_LONG_MIN + half_divisor < value )
             values[i] = ( value - half_divisor ) / divisor;
           else
             values[i] = FT_LONG_MIN / divisor;
         }
         else
         {
           if ( FT_LONG_MAX - half_divisor > value )
             values[i] = ( value + half_divisor ) / divisor;
           else
             values[i] = FT_LONG_MAX / divisor;
         }
       }
 
       matrix->xx = values[0];
       matrix->yx = values[1];
       matrix->xy = values[2];
       matrix->yy = values[3];
       offset->x  = values[4];
       offset->y  = values[5];
 
       *upm = (FT_ULong)power_tens[-max_scaling];
 
       FT_TRACE4(( " [%f %f %f %f %f %f]\n",
                   (double)matrix->xx / *upm / 65536,
                   (double)matrix->xy / *upm / 65536,
                   (double)matrix->yx / *upm / 65536,
                   (double)matrix->yy / *upm / 65536,
                   (double)offset->x  / *upm / 65536,
                   (double)offset->y  / *upm / 65536 ));
     }
 
   Exit:
     return error;
   }
 
 
   static FT_Error
   cff_parse_font_bbox( CFF_Parser  parser )
   {
     CFF_FontRecDict  dict = (CFF_FontRecDict)parser->object;
     FT_BBox*         bbox = &dict->font_bbox;
     FT_Byte**        data = parser->stack;
     FT_Error         error;
 
 
     error = FT_ERR( Stack_Underflow );
 
     if ( parser->top >= parser->stack + 4 )
     {
       bbox->xMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
       bbox->yMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
       bbox->xMax = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
       bbox->yMax = FT_RoundFix( cff_parse_fixed( parser, data   ) );
       error = FT_Err_Ok;
 
       FT_TRACE4(( " [%d %d %d %d]\n",
                   bbox->xMin / 65536,
                   bbox->yMin / 65536,
                   bbox->xMax / 65536,
                   bbox->yMax / 65536 ));
     }
 
     return error;
   }
 
 
   static FT_Error
   cff_parse_private_dict( CFF_Parser  parser )
   {
     CFF_FontRecDict  dict = (CFF_FontRecDict)parser->object;
     FT_Byte**        data = parser->stack;
     FT_Error         error;
 
 
     error = FT_ERR( Stack_Underflow );
 
     if ( parser->top >= parser->stack + 2 )
     {
       FT_Long  tmp;
 
 
       tmp = cff_parse_num( parser, data++ );
       if ( tmp < 0 )
       {
         FT_ERROR(( "cff_parse_private_dict: Invalid dictionary size\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Fail;
       }
       dict->private_size = (FT_ULong)tmp;
 
       tmp = cff_parse_num( parser, data );
       if ( tmp < 0 )
       {
         FT_ERROR(( "cff_parse_private_dict: Invalid dictionary offset\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Fail;
       }
       dict->private_offset = (FT_ULong)tmp;
 
       FT_TRACE4(( " %lu %lu\n",
                   dict->private_size, dict->private_offset ));
 
       error = FT_Err_Ok;
     }
 
   Fail:
     return error;
   }
 
 
   /* The `MultipleMaster' operator comes before any  */
   /* top DICT operators that contain T2 charstrings. */
 
   static FT_Error
   cff_parse_multiple_master( CFF_Parser  parser )
   {
     CFF_FontRecDict  dict = (CFF_FontRecDict)parser->object;
     FT_Error         error;
 
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     /* beautify tracing message */
     if ( ft_trace_levels[FT_COMPONENT] < 4 )
       FT_TRACE1(( "Multiple Master CFFs not supported yet,"
                   " handling first master design only\n" ));
     else
       FT_TRACE1(( " (not supported yet,"
                   " handling first master design only)\n" ));
 #endif
 
     error = FT_ERR( Stack_Underflow );
 
     /* currently, we handle only the first argument */
     if ( parser->top >= parser->stack + 5 )
     {
       FT_Long  num_designs = cff_parse_num( parser, parser->stack );
 
 
       if ( num_designs > 16 || num_designs < 2 )
       {
         FT_ERROR(( "cff_parse_multiple_master:"
                    " Invalid number of designs\n" ));
         error = FT_THROW( Invalid_File_Format );
       }
       else
       {
         dict->num_designs   = (FT_UShort)num_designs;
         dict->num_axes      = (FT_UShort)( parser->top - parser->stack - 4 );
 
         parser->num_designs = dict->num_designs;
         parser->num_axes    = dict->num_axes;
 
         error = FT_Err_Ok;
       }
     }
 
     return error;
   }
 
 
   static FT_Error
   cff_parse_cid_ros( CFF_Parser  parser )
   {
     CFF_FontRecDict  dict = (CFF_FontRecDict)parser->object;
     FT_Byte**        data = parser->stack;
     FT_Error         error;
 
 
     error = FT_ERR( Stack_Underflow );
 
     if ( parser->top >= parser->stack + 3 )
     {
       dict->cid_registry = (FT_UInt)cff_parse_num( parser, data++ );
       dict->cid_ordering = (FT_UInt)cff_parse_num( parser, data++ );
       if ( **data == 30 )
         FT_TRACE1(( "cff_parse_cid_ros: real supplement is rounded\n" ));
       dict->cid_supplement = cff_parse_num( parser, data );
       if ( dict->cid_supplement < 0 )
         FT_TRACE1(( "cff_parse_cid_ros: negative supplement %d is found\n",
                    dict->cid_supplement ));
       error = FT_Err_Ok;
 
       FT_TRACE4(( " %d %d %d\n",
                   dict->cid_registry,
                   dict->cid_ordering,
                   dict->cid_supplement ));
     }
 
     return error;
   }
 
 
+  static FT_Error
+  cff_parse_vsindex( CFF_Parser  parser )
+  {
+    /* vsindex operator can only be used in a Private DICT */
+    CFF_Private  priv = (CFF_Private)parser->object;
+    FT_Byte**    data = parser->stack;
+    CFF_Blend    blend;
+    FT_Error     error;
+
+
+    if ( !priv || !priv->subfont )
+    {
+      error = FT_THROW( Invalid_File_Format );
+      goto Exit;
+    }
+
+    blend = &priv->subfont->blend;
+
+    if ( blend->usedBV )
+    {
+      FT_ERROR(( " cff_parse_vsindex: vsindex not allowed after blend\n" ));
+      error = FT_THROW( Syntax_Error );
+      goto Exit;
+    }
+
+    priv->vsindex = (FT_UInt)cff_parse_num( parser, data++ );
+
+    FT_TRACE4(( " %d\n", priv->vsindex ));
+
+    error = FT_Err_Ok;
+
+  Exit:
+    return error;
+  }
+
+
+  static FT_Error
+  cff_parse_blend( CFF_Parser  parser )
+  {
+    /* blend operator can only be used in a Private DICT */
+    CFF_Private  priv = (CFF_Private)parser->object;
+    CFF_SubFont  subFont;
+    CFF_Blend    blend;
+    FT_UInt      numBlends;
+    FT_Error     error;
+
+
+    error = FT_ERR( Stack_Underflow );
+
+    if ( !priv || !priv->subfont )
+    {
+      error = FT_THROW( Invalid_File_Format );
+      goto Exit;
+    }
+
+    subFont = priv->subfont;
+    blend   = &subFont->blend;
+
+    if ( cff_blend_check_vector( blend,
+                                 priv->vsindex,
+                                 subFont->lenNDV,
+                                 subFont->NDV ) )
+    {
+      error = cff_blend_build_vector( blend,
+                                      priv->vsindex,
+                                      subFont->lenNDV,
+                                      subFont->NDV );
+      if ( error != FT_Err_Ok )
+        goto Exit;
+    }
+
+    numBlends = (FT_UInt)cff_parse_num( parser, parser->top - 1 );
+
+    FT_TRACE4(( "   %d values blended\n", numBlends ));
+
+    error = cff_blend_doBlend( subFont, parser, numBlends );
+
+    blend->usedBV = TRUE;
+
+  Exit:
+    return error;
+  }
+
+
   /* maxstack operator increases parser and operand stacks for CFF2 */
   static FT_Error
   cff_parse_maxstack( CFF_Parser  parser )
   {
     /* maxstack operator can only be used in a Top DICT */
     CFF_FontRecDict  dict  = (CFF_FontRecDict)parser->object;
     FT_Byte**        data  = parser->stack;
     FT_Error         error = FT_Err_Ok;
 
 
     if ( !dict )
     {
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     dict->maxstack = (FT_UInt)cff_parse_num( parser, data++ );
     if ( dict->maxstack > CFF2_MAX_STACK )
       dict->maxstack = CFF2_MAX_STACK;
     if ( dict->maxstack < CFF2_DEFAULT_STACK )
       dict->maxstack = CFF2_DEFAULT_STACK;
 
     FT_TRACE4(( " %d\n", dict->maxstack ));
 
   Exit:
     return error;
   }
 
 
 #define CFF_FIELD_NUM( code, name, id )             \
           CFF_FIELD( code, name, id, cff_kind_num )
 #define CFF_FIELD_FIXED( code, name, id )             \
           CFF_FIELD( code, name, id, cff_kind_fixed )
 #define CFF_FIELD_FIXED_1000( code, name, id )                 \
           CFF_FIELD( code, name, id, cff_kind_fixed_thousand )
 #define CFF_FIELD_STRING( code, name, id )             \
           CFF_FIELD( code, name, id, cff_kind_string )
 #define CFF_FIELD_BOOL( code, name, id )             \
           CFF_FIELD( code, name, id, cff_kind_bool )
 
 
 #ifndef FT_CONFIG_OPTION_PIC
 
 
 #undef  CFF_FIELD
 #undef  CFF_FIELD_DELTA
 
 
 #ifndef FT_DEBUG_LEVEL_TRACE
 
 
 #define CFF_FIELD_CALLBACK( code, name, id ) \
           {                                  \
             cff_kind_callback,               \
             code | CFFCODE,                  \
             0, 0,                            \
             cff_parse_ ## name,              \
             0, 0                             \
           },
 
+#define CFF_FIELD_BLEND( code, id ) \
+          {                         \
+            cff_kind_blend,         \
+            code | CFFCODE,         \
+            0, 0,                   \
+            cff_parse_blend,        \
+            0, 0                    \
+          },
+
 #define CFF_FIELD( code, name, id, kind ) \
           {                               \
             kind,                         \
             code | CFFCODE,               \
             FT_FIELD_OFFSET( name ),      \
             FT_FIELD_SIZE( name ),        \
             0, 0, 0                       \
           },
 
 #define CFF_FIELD_DELTA( code, name, max, id ) \
           {                                    \
             cff_kind_delta,                    \
             code | CFFCODE,                    \
             FT_FIELD_OFFSET( name ),           \
             FT_FIELD_SIZE_DELTA( name ),       \
             0,                                 \
             max,                               \
             FT_FIELD_OFFSET( num_ ## name )    \
           },
 
   static const CFF_Field_Handler  cff_field_handlers[] =
   {
 
 #include "cfftoken.h"
 
     { 0, 0, 0, 0, 0, 0, 0 }
   };
 
 
 #else /* FT_DEBUG_LEVEL_TRACE */
 
 
 
 #define CFF_FIELD_CALLBACK( code, name, id ) \
           {                                  \
             cff_kind_callback,               \
             code | CFFCODE,                  \
             0, 0,                            \
             cff_parse_ ## name,              \
             0, 0,                            \
             id                               \
           },
 
+#define CFF_FIELD_BLEND( code, id ) \
+          {                         \
+            cff_kind_blend,         \
+            code | CFFCODE,         \
+            0, 0,                   \
+            cff_parse_blend,        \
+            0, 0,                   \
+            id                      \
+          },
+
 #define CFF_FIELD( code, name, id, kind ) \
           {                               \
             kind,                         \
             code | CFFCODE,               \
             FT_FIELD_OFFSET( name ),      \
             FT_FIELD_SIZE( name ),        \
             0, 0, 0,                      \
             id                            \
           },
 
 #define CFF_FIELD_DELTA( code, name, max, id ) \
           {                                    \
             cff_kind_delta,                    \
             code | CFFCODE,                    \
             FT_FIELD_OFFSET( name ),           \
             FT_FIELD_SIZE_DELTA( name ),       \
             0,                                 \
             max,                               \
             FT_FIELD_OFFSET( num_ ## name ),   \
             id                                 \
           },
 
   static const CFF_Field_Handler  cff_field_handlers[] =
   {
 
 #include "cfftoken.h"
 
     { 0, 0, 0, 0, 0, 0, 0, 0 }
   };
 
 
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
 
 #else /* FT_CONFIG_OPTION_PIC */
 
 
   void
   FT_Destroy_Class_cff_field_handlers( FT_Library          library,
                                        CFF_Field_Handler*  clazz )
   {
     FT_Memory  memory = library->memory;
 
 
     if ( clazz )
       FT_FREE( clazz );
   }
 
 
   FT_Error
   FT_Create_Class_cff_field_handlers( FT_Library           library,
                                       CFF_Field_Handler**  output_class )
   {
     CFF_Field_Handler*  clazz  = NULL;
     FT_Error            error;
     FT_Memory           memory = library->memory;
 
     int  i = 0;
 
 
 #undef CFF_FIELD
 #define CFF_FIELD( code, name, id, kind ) i++;
 #undef CFF_FIELD_DELTA
 #define CFF_FIELD_DELTA( code, name, max, id ) i++;
 #undef CFF_FIELD_CALLBACK
 #define CFF_FIELD_CALLBACK( code, name, id ) i++;
 
 #include "cfftoken.h"
 
     i++; /* { 0, 0, 0, 0, 0, 0, 0 } */
 
     if ( FT_ALLOC( clazz, sizeof ( CFF_Field_Handler ) * i ) )
       return error;
 
     i = 0;
 
 
 #ifndef FT_DEBUG_LEVEL_TRACE
 
 
 #undef CFF_FIELD_CALLBACK
 #define CFF_FIELD_CALLBACK( code_, name_, id_ )        \
           clazz[i].kind         = cff_kind_callback;   \
           clazz[i].code         = code_ | CFFCODE;     \
           clazz[i].offset       = 0;                   \
           clazz[i].size         = 0;                   \
           clazz[i].reader       = cff_parse_ ## name_; \
           clazz[i].array_max    = 0;                   \
           clazz[i].count_offset = 0;                   \
           i++;
 
 #undef  CFF_FIELD
 #define CFF_FIELD( code_, name_, id_, kind_ )               \
           clazz[i].kind         = kind_;                    \
           clazz[i].code         = code_ | CFFCODE;          \
           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \
           clazz[i].size         = FT_FIELD_SIZE( name_ );   \
           clazz[i].reader       = 0;                        \
           clazz[i].array_max    = 0;                        \
           clazz[i].count_offset = 0;                        \
           i++;                                              \
 
 #undef  CFF_FIELD_DELTA
 #define CFF_FIELD_DELTA( code_, name_, max_, id_ )                  \
           clazz[i].kind         = cff_kind_delta;                   \
           clazz[i].code         = code_ | CFFCODE;                  \
           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \
           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \
           clazz[i].reader       = 0;                                \
           clazz[i].array_max    = max_;                             \
           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \
           i++;
 
 #include "cfftoken.h"
 
     clazz[i].kind         = 0;
     clazz[i].code         = 0;
     clazz[i].offset       = 0;
     clazz[i].size         = 0;
     clazz[i].reader       = 0;
     clazz[i].array_max    = 0;
     clazz[i].count_offset = 0;
 
 
 #else /* FT_DEBUG_LEVEL_TRACE */
 
 
 #undef CFF_FIELD_CALLBACK
 #define CFF_FIELD_CALLBACK( code_, name_, id_ )        \
           clazz[i].kind         = cff_kind_callback;   \
           clazz[i].code         = code_ | CFFCODE;     \
           clazz[i].offset       = 0;                   \
           clazz[i].size         = 0;                   \
           clazz[i].reader       = cff_parse_ ## name_; \
           clazz[i].array_max    = 0;                   \
           clazz[i].count_offset = 0;                   \
           clazz[i].id           = id_;                 \
           i++;
 
 #undef  CFF_FIELD
 #define CFF_FIELD( code_, name_, id_, kind_ )               \
           clazz[i].kind         = kind_;                    \
           clazz[i].code         = code_ | CFFCODE;          \
           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \
           clazz[i].size         = FT_FIELD_SIZE( name_ );   \
           clazz[i].reader       = 0;                        \
           clazz[i].array_max    = 0;                        \
           clazz[i].count_offset = 0;                        \
           clazz[i].id           = id_;                      \
           i++;                                              \
 
 #undef  CFF_FIELD_DELTA
 #define CFF_FIELD_DELTA( code_, name_, max_, id_ )                  \
           clazz[i].kind         = cff_kind_delta;                   \
           clazz[i].code         = code_ | CFFCODE;                  \
           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \
           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \
           clazz[i].reader       = 0;                                \
           clazz[i].array_max    = max_;                             \
           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \
           clazz[i].id           = id_;                              \
           i++;
 
 #include "cfftoken.h"
 
     clazz[i].kind         = 0;
     clazz[i].code         = 0;
     clazz[i].offset       = 0;
     clazz[i].size         = 0;
     clazz[i].reader       = 0;
     clazz[i].array_max    = 0;
     clazz[i].count_offset = 0;
     clazz[i].id           = 0;
 
 
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
 
     *output_class = clazz;
 
     return FT_Err_Ok;
   }
 
 
 #endif /* FT_CONFIG_OPTION_PIC */
 
 
   FT_LOCAL_DEF( FT_Error )
   cff_parser_run( CFF_Parser  parser,
                   FT_Byte*    start,
                   FT_Byte*    limit )
   {
     FT_Byte*    p       = start;
     FT_Error    error   = FT_Err_Ok;
     FT_Library  library = parser->library;
     FT_UNUSED( library );
 
 
     parser->top    = parser->stack;
     parser->start  = start;
     parser->limit  = limit;
     parser->cursor = start;
 
     while ( p < limit )
     {
       FT_UInt  v = *p;
 
-
-      if ( v >= 27 && v != 31 )
+      /* Opcode 31 is legacy MM T2 operator, not a number.      */
+      /* Opcode 255 is reserved and should not appear in fonts; */
+      /* it is used internally for CFF2 blends.                 */
+      if ( v >= 27 && v != 31 && v != 255 )
       {
         /* it's a number; we will push its position on the stack */
         if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
           goto Stack_Overflow;
 
         *parser->top++ = p;
 
         /* now, skip it */
         if ( v == 30 )
         {
           /* skip real number */
           p++;
           for (;;)
           {
             /* An unterminated floating point number at the */
             /* end of a dictionary is invalid but harmless. */
             if ( p >= limit )
               goto Exit;
             v = p[0] >> 4;
             if ( v == 15 )
               break;
             v = p[0] & 0xF;
             if ( v == 15 )
               break;
             p++;
           }
         }
         else if ( v == 28 )
           p += 2;
         else if ( v == 29 )
           p += 4;
         else if ( v > 246 )
           p += 1;
       }
 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
       else if ( v == 31 )
       {
         /* a Type 2 charstring */
 
         CFF_Decoder  decoder;
         CFF_FontRec  cff_rec;
         FT_Byte*     charstring_base;
         FT_ULong     charstring_len;
 
         FT_Fixed*  stack;
         FT_Byte*   q;
 
 
         charstring_base = ++p;
 
         /* search `endchar' operator */
         for (;;)
         {
           if ( p >= limit )
             goto Exit;
           if ( *p == 14 )
             break;
           p++;
         }
 
         charstring_len = (FT_ULong)( p - charstring_base ) + 1;
 
         /* construct CFF_Decoder object */
         FT_ZERO( &decoder );
         FT_ZERO( &cff_rec );
 
         cff_rec.top_font.font_dict.num_designs = parser->num_designs;
         cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
         decoder.cff                            = &cff_rec;
 
         error = cff_decoder_parse_charstrings( &decoder,
                                                charstring_base,
                                                charstring_len,
                                                1 );
 
         /* Now copy the stack data in the temporary decoder object,    */
         /* converting it back to charstring number representations     */
         /* (this is ugly, I know).                                     */
         /*                                                             */
         /* We overwrite the original top DICT charstring under the     */
         /* assumption that the charstring representation of the result */
         /* of `cff_decoder_parse_charstrings' is shorter, which should */
         /* be always true.                                             */
 
         q     = charstring_base - 1;
         stack = decoder.stack;
 
         while ( stack < decoder.top )
         {
           FT_ULong  num;
           FT_Bool   neg;
 
 
           if ( (FT_UInt)( parser->top - parser->stack ) >= parser->stackSize )
             goto Stack_Overflow;
 
           *parser->top++ = q;
 
           if ( *stack < 0 )
           {
             num = (FT_ULong)-*stack;
             neg = 1;
           }
           else
           {
             num = (FT_ULong)*stack;
             neg = 0;
           }
 
           if ( num & 0xFFFFU )
           {
             if ( neg )
               num = (FT_ULong)-num;
 
             *q++ = 255;
             *q++ = ( num & 0xFF000000U ) >> 24;
             *q++ = ( num & 0x00FF0000U ) >> 16;
             *q++ = ( num & 0x0000FF00U ) >>  8;
             *q++ =   num & 0x000000FFU;
           }
           else
           {
             num >>= 16;
 
             if ( neg )
             {
               if ( num <= 107 )
                 *q++ = (FT_Byte)( 139 - num );
               else if ( num <= 1131 )
               {
                 *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
                 *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
               }
               else
               {
                 num = (FT_ULong)-num;
 
                 *q++ = 28;
                 *q++ = (FT_Byte)( num >> 8 );
                 *q++ = (FT_Byte)( num & 0xFF );
               }
             }
             else
             {
               if ( num <= 107 )
                 *q++ = (FT_Byte)( num + 139 );
               else if ( num <= 1131 )
               {
                 *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
                 *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
               }
               else
               {
                 *q++ = 28;
                 *q++ = (FT_Byte)( num >> 8 );
                 *q++ = (FT_Byte)( num & 0xFF );
               }
             }
           }
 
           stack++;
         }
       }
 #endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
       else
       {
         /* This is not a number, hence it's an operator.  Compute its code */
         /* and look for it in our current list.                            */
 
         FT_UInt                   code;
         FT_UInt                   num_args = (FT_UInt)
                                              ( parser->top - parser->stack );
         const CFF_Field_Handler*  field;
 
 
         *parser->top = p;
         code = v;
         if ( v == 12 )
         {
           /* two byte operator */
           p++;
           if ( p >= limit )
             goto Syntax_Error;
 
           code = 0x100 | p[0];
         }
         code = code | parser->object_code;
 
         for ( field = CFF_FIELD_HANDLERS_GET; field->kind; field++ )
         {
           if ( field->code == (FT_Int)code )
           {
             /* we found our field's handler; read it */
             FT_Long   val;
             FT_Byte*  q = (FT_Byte*)parser->object + field->offset;
 
 
 #ifdef FT_DEBUG_LEVEL_TRACE
             FT_TRACE4(( "  %s", field->id ));
 #endif
 
             /* check that we have enough arguments -- except for */
             /* delta encoded arrays, which can be empty          */
             if ( field->kind != cff_kind_delta && num_args < 1 )
               goto Stack_Underflow;
 
             switch ( field->kind )
             {
             case cff_kind_bool:
             case cff_kind_string:
             case cff_kind_num:
               val = cff_parse_num( parser, parser->stack );
               goto Store_Number;
 
             case cff_kind_fixed:
               val = cff_parse_fixed( parser, parser->stack );
               goto Store_Number;
 
             case cff_kind_fixed_thousand:
               val = cff_parse_fixed_scaled( parser, parser->stack, 3 );
 
             Store_Number:
               switch ( field->size )
               {
               case (8 / FT_CHAR_BIT):
                 *(FT_Byte*)q = (FT_Byte)val;
                 break;
 
               case (16 / FT_CHAR_BIT):
                 *(FT_Short*)q = (FT_Short)val;
                 break;
 
               case (32 / FT_CHAR_BIT):
                 *(FT_Int32*)q = (FT_Int)val;
                 break;
 
               default:  /* for 64-bit systems */
                 *(FT_Long*)q = val;
               }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
               switch ( field->kind )
               {
               case cff_kind_bool:
                 FT_TRACE4(( " %s\n", val ? "true" : "false" ));
                 break;
 
               case cff_kind_string:
                 FT_TRACE4(( " %ld (SID)\n", val ));
                 break;
 
               case cff_kind_num:
                 FT_TRACE4(( " %ld\n", val ));
                 break;
 
               case cff_kind_fixed:
                 FT_TRACE4(( " %f\n", (double)val / 65536 ));
                 break;
 
               case cff_kind_fixed_thousand:
                 FT_TRACE4(( " %f\n", (double)val / 65536 / 1000 ));
 
               default:
                 ; /* never reached */
               }
 #endif
 
               break;
 
             case cff_kind_delta:
               {
                 FT_Byte*   qcount = (FT_Byte*)parser->object +
                                       field->count_offset;
 
                 FT_Byte**  data = parser->stack;
 
 
                 if ( num_args > field->array_max )
                   num_args = field->array_max;
 
                 FT_TRACE4(( " [" ));
 
                 /* store count */
                 *qcount = (FT_Byte)num_args;
 
                 val = 0;
                 while ( num_args > 0 )
                 {
                   val += cff_parse_num( parser, data++ );
                   switch ( field->size )
                   {
                   case (8 / FT_CHAR_BIT):
                     *(FT_Byte*)q = (FT_Byte)val;
                     break;
 
                   case (16 / FT_CHAR_BIT):
                     *(FT_Short*)q = (FT_Short)val;
                     break;
 
                   case (32 / FT_CHAR_BIT):
                     *(FT_Int32*)q = (FT_Int)val;
                     break;
 
                   default:  /* for 64-bit systems */
                     *(FT_Long*)q = val;
                   }
 
                   FT_TRACE4(( " %ld", val ));
 
                   q += field->size;
                   num_args--;
                 }
 
                 FT_TRACE4(( "]\n" ));
               }
               break;
 
-            default:  /* callback */
+            default:  /* callback or blend */
               error = field->reader( parser );
               if ( error )
                 goto Exit;
             }
             goto Found;
           }
         }
 
         /* this is an unknown operator, or it is unsupported; */
         /* we will ignore it for now.                         */
 
       Found:
         /* clear stack */
-        parser->top = parser->stack;
+        /* TODO: could clear blend stack here,       */
+        /*       but we don't have access to subFont */
+        if ( field->kind != cff_kind_blend )
+          parser->top = parser->stack;
       }
       p++;
     }
 
   Exit:
     return error;
 
   Stack_Overflow:
     error = FT_THROW( Invalid_Argument );
     goto Exit;
 
   Stack_Underflow:
     error = FT_THROW( Invalid_Argument );
     goto Exit;
 
   Syntax_Error:
     error = FT_THROW( Invalid_Argument );
     goto Exit;
   }
 
 
 /* END */
diff --git a/src/cff/cffparse.h b/src/cff/cffparse.h
index 939e551f4..6088fec21 100644
--- a/src/cff/cffparse.h
+++ b/src/cff/cffparse.h
@@ -28,91 +28,92 @@
 FT_BEGIN_HEADER
 
 
   /* CFF uses constant parser stack size; */
   /* CFF2 can increase from default 193   */
 #define CFF_MAX_STACK_DEPTH  96
 #define CFF2_MAX_STACK      513
 #define CFF2_DEFAULT_STACK  193
 
 #define CFF_CODE_TOPDICT    0x1000
 #define CFF_CODE_PRIVATE    0x2000
 #define CFF2_CODE_TOPDICT   0x3000
 #define CFF2_CODE_FONTDICT  0x4000
 #define CFF2_CODE_PRIVATE   0x5000
 
 
   typedef struct  CFF_ParserRec_
   {
     FT_Library  library;
     FT_Byte*    start;
     FT_Byte*    limit;
     FT_Byte*    cursor;
 
     FT_Byte**   stack;
     FT_Byte**   top;
     FT_UInt     stackSize;  /* allocated size */
 
     FT_UInt     object_code;
     void*       object;
 
     FT_UShort   num_designs; /* a copy of `CFF_FontRecDict->num_designs' */
     FT_UShort   num_axes;    /* a copy of `CFF_FontRecDict->num_axes'    */
 
   } CFF_ParserRec, *CFF_Parser;
 
 
   FT_LOCAL( FT_Long )
   cff_parse_num( CFF_Parser  parser,
                  FT_Byte**   d );
 
   FT_LOCAL( FT_Error )
   cff_parser_init( CFF_Parser  parser,
                    FT_UInt     code,
                    void*       object,
                    FT_Library  library,
                    FT_UInt     stackSize,
                    FT_UShort   num_designs,
                    FT_UShort   num_axes );
 
   FT_LOCAL( void )
   cff_parser_done( CFF_Parser  parser );
 
   FT_LOCAL( FT_Error )
   cff_parser_run( CFF_Parser  parser,
                   FT_Byte*    start,
                   FT_Byte*    limit );
 
 
   enum
   {
     cff_kind_none = 0,
     cff_kind_num,
     cff_kind_fixed,
     cff_kind_fixed_thousand,
     cff_kind_string,
     cff_kind_bool,
     cff_kind_delta,
     cff_kind_callback,
+    cff_kind_blend,
 
     cff_kind_max  /* do not remove */
   };
 
 
   /* now generate handlers for the most simple fields */
   typedef FT_Error  (*CFF_Field_Reader)( CFF_Parser  parser );
 
   typedef struct  CFF_Field_Handler_
   {
     int               kind;
     int               code;
     FT_UInt           offset;
     FT_Byte           size;
     CFF_Field_Reader  reader;
     FT_UInt           array_max;
     FT_UInt           count_offset;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     const char*       id;
 #endif
 
   } CFF_Field_Handler;
diff --git a/src/cff/cfftoken.h b/src/cff/cfftoken.h
index 6e671b91a..fd41c6c71 100644
--- a/src/cff/cfftoken.h
+++ b/src/cff/cfftoken.h
@@ -1,147 +1,150 @@
 /***************************************************************************/
 /*                                                                         */
 /*  cfftoken.h                                                             */
 /*                                                                         */
 /*    CFF token definitions (specification only).                          */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_FontRecDictRec
 
 #undef  CFFCODE
 #define CFFCODE       CFF_CODE_TOPDICT
 
   CFF_FIELD_STRING  ( 0,     version,             "Version" )
   CFF_FIELD_STRING  ( 1,     notice,              "Notice" )
   CFF_FIELD_STRING  ( 0x100, copyright,           "Copyright" )
   CFF_FIELD_STRING  ( 2,     full_name,           "FullName" )
   CFF_FIELD_STRING  ( 3,     family_name,         "FamilyName" )
   CFF_FIELD_STRING  ( 4,     weight,              "Weight" )
   CFF_FIELD_BOOL    ( 0x101, is_fixed_pitch,      "isFixedPitch" )
   CFF_FIELD_FIXED   ( 0x102, italic_angle,        "ItalicAngle" )
   CFF_FIELD_FIXED   ( 0x103, underline_position,  "UnderlinePosition" )
   CFF_FIELD_FIXED   ( 0x104, underline_thickness, "UnderlineThickness" )
   CFF_FIELD_NUM     ( 0x105, paint_type,          "PaintType" )
   CFF_FIELD_NUM     ( 0x106, charstring_type,     "CharstringType" )
   CFF_FIELD_CALLBACK( 0x107, font_matrix,         "FontMatrix" )
   CFF_FIELD_NUM     ( 13,    unique_id,           "UniqueID" )
   CFF_FIELD_CALLBACK( 5,     font_bbox,           "FontBBox" )
   CFF_FIELD_NUM     ( 0x108, stroke_width,        "StrokeWidth" )
 #if 0
   CFF_FIELD_DELTA   ( 14,    xuid, 16,            "XUID" )
 #endif
   CFF_FIELD_NUM     ( 15,    charset_offset,      "charset" )
   CFF_FIELD_NUM     ( 16,    encoding_offset,     "Encoding" )
   CFF_FIELD_NUM     ( 17,    charstrings_offset,  "CharStrings" )
   CFF_FIELD_CALLBACK( 18,    private_dict,        "Private" )
   CFF_FIELD_NUM     ( 0x114, synthetic_base,      "SyntheticBase" )
   CFF_FIELD_STRING  ( 0x115, embedded_postscript, "PostScript" )
 
 #if 0
   CFF_FIELD_STRING  ( 0x116, base_font_name,      "BaseFontName" )
   CFF_FIELD_DELTA   ( 0x117, base_font_blend, 16, "BaseFontBlend" )
 #endif
 
   /* the next two operators were removed from the Type2 specification */
   /* in version 16-March-2000                                         */
   CFF_FIELD_CALLBACK( 0x118, multiple_master,     "MultipleMaster" )
 #if 0
   CFF_FIELD_CALLBACK( 0x11A, blend_axis_types,    "BlendAxisTypes" )
 #endif
 
   CFF_FIELD_CALLBACK( 0x11E, cid_ros,              "ROS" )
   CFF_FIELD_NUM     ( 0x11F, cid_font_version,     "CIDFontVersion" )
   CFF_FIELD_NUM     ( 0x120, cid_font_revision,    "CIDFontRevision" )
   CFF_FIELD_NUM     ( 0x121, cid_font_type,        "CIDFontType" )
   CFF_FIELD_NUM     ( 0x122, cid_count,            "CIDCount" )
   CFF_FIELD_NUM     ( 0x123, cid_uid_base,         "UIDBase" )
   CFF_FIELD_NUM     ( 0x124, cid_fd_array_offset,  "FDArray" )
   CFF_FIELD_NUM     ( 0x125, cid_fd_select_offset, "FDSelect" )
   CFF_FIELD_STRING  ( 0x126, cid_font_name,        "FontName" )
 
 #if 0
   CFF_FIELD_NUM     ( 0x127, chameleon, "Chameleon" )
 #endif
 
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_PrivateRec
 #undef  CFFCODE
 #define CFFCODE       CFF_CODE_PRIVATE
 
   CFF_FIELD_DELTA     ( 6,     blue_values, 14,        "BlueValues" )
   CFF_FIELD_DELTA     ( 7,     other_blues, 10,        "OtherBlues" )
   CFF_FIELD_DELTA     ( 8,     family_blues, 14,       "FamilyBlues" )
   CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, "FamilyOtherBlues" )
   CFF_FIELD_FIXED_1000( 0x109, blue_scale,             "BlueScale" )
   CFF_FIELD_NUM       ( 0x10A, blue_shift,             "BlueShift" )
   CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              "BlueFuzz" )
   CFF_FIELD_NUM       ( 10,    standard_width,         "StdHW" )
   CFF_FIELD_NUM       ( 11,    standard_height,        "StdVW" )
   CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        "StemSnapH" )
   CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       "StemSnapV" )
   CFF_FIELD_BOOL      ( 0x10E, force_bold,             "ForceBold" )
   CFF_FIELD_FIXED     ( 0x10F, force_bold_threshold,   "ForceBoldThreshold" )
   CFF_FIELD_NUM       ( 0x110, lenIV,                  "lenIV" )
   CFF_FIELD_NUM       ( 0x111, language_group,         "LanguageGroup" )
   CFF_FIELD_FIXED     ( 0x112, expansion_factor,       "ExpansionFactor" )
   CFF_FIELD_NUM       ( 0x113, initial_random_seed,    "initialRandomSeed" )
   CFF_FIELD_NUM       ( 19,    local_subrs_offset,     "Subrs" )
   CFF_FIELD_NUM       ( 20,    default_width,          "defaultWidthX" )
   CFF_FIELD_NUM       ( 21,    nominal_width,          "nominalWidthX" )
 
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_FontRecDictRec
 #undef  CFFCODE
 #define CFFCODE       CFF2_CODE_TOPDICT
 
   CFF_FIELD_CALLBACK( 0x107, font_matrix,          "FontMatrix" )
   CFF_FIELD_NUM     ( 17,    charstrings_offset,   "CharStrings" )
   CFF_FIELD_NUM     ( 0x124, cid_fd_array_offset,  "FDArray" )
   CFF_FIELD_NUM     ( 0x125, cid_fd_select_offset, "FDSelect" )
+  CFF_FIELD_NUM     ( 24,    vstore_offset,        "vstore" )
   CFF_FIELD_CALLBACK( 25,    maxstack,             "maxstack" )
 
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_FontRecDictRec
 #undef  CFFCODE
 #define CFFCODE       CFF2_CODE_FONTDICT
 
   CFF_FIELD_CALLBACK( 18,    private_dict, "Private" )
   CFF_FIELD_CALLBACK( 0x107, font_matrix,  "FontMatrix" )
 
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  CFF_PrivateRec
 #undef  CFFCODE
 #define CFFCODE       CFF2_CODE_PRIVATE
 
   CFF_FIELD_DELTA     ( 6,     blue_values, 14,        "BlueValues" )
   CFF_FIELD_DELTA     ( 7,     other_blues, 10,        "OtherBlues" )
   CFF_FIELD_DELTA     ( 8,     family_blues, 14,       "FamilyBlues" )
   CFF_FIELD_DELTA     ( 9,     family_other_blues, 10, "FamilyOtherBlues" )
   CFF_FIELD_FIXED_1000( 0x109, blue_scale,             "BlueScale" )
   CFF_FIELD_NUM       ( 0x10A, blue_shift,             "BlueShift" )
   CFF_FIELD_NUM       ( 0x10B, blue_fuzz,              "BlueFuzz" )
   CFF_FIELD_NUM       ( 10,    standard_width,         "StdHW" )
   CFF_FIELD_NUM       ( 11,    standard_height,        "StdVW" )
   CFF_FIELD_DELTA     ( 0x10C, snap_widths, 13,        "StemSnapH" )
   CFF_FIELD_DELTA     ( 0x10D, snap_heights, 13,       "StemSnapV" )
   CFF_FIELD_NUM       ( 0x111, language_group,         "LanguageGroup" )
   CFF_FIELD_FIXED     ( 0x112, expansion_factor,       "ExpansionFactor" )
+  CFF_FIELD_CALLBACK  ( 22,    vsindex,                "vsindex" )
+  CFF_FIELD_BLEND     ( 23,                            "blend" )
   CFF_FIELD_NUM       ( 19,    local_subrs_offset,     "Subrs" )
 
 
 /* END */
diff --git a/src/cff/cfftypes.h b/src/cff/cfftypes.h
index 97534afd2..4dae0f281 100644
--- a/src/cff/cfftypes.h
+++ b/src/cff/cfftypes.h
@@ -32,271 +32,366 @@
 FT_BEGIN_HEADER
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Struct>                                                              */
   /*    CFF_IndexRec                                                       */
   /*                                                                       */
   /* <Description>                                                         */
   /*    A structure used to model a CFF Index table.                       */
   /*                                                                       */
   /* <Fields>                                                              */
   /*    stream      :: The source input stream.                            */
   /*                                                                       */
   /*    start       :: The position of the first index byte in the         */
   /*                   input stream.                                       */
   /*                                                                       */
   /*    count       :: The number of elements in the index.                */
   /*                                                                       */
   /*    off_size    :: The size in bytes of object offsets in index.       */
   /*                                                                       */
   /*    data_offset :: The position of first data byte in the index's      */
   /*                   bytes.                                              */
   /*                                                                       */
   /*    data_size   :: The size of the data table in this index.           */
   /*                                                                       */
   /*    offsets     :: A table of element offsets in the index.  Must be   */
   /*                   loaded explicitly.                                  */
   /*                                                                       */
   /*    bytes       :: If the index is loaded in memory, its bytes.        */
   /*                                                                       */
   typedef struct  CFF_IndexRec_
   {
     FT_Stream  stream;
     FT_ULong   start;
     FT_UInt    hdr_size;
     FT_UInt    count;
     FT_Byte    off_size;
     FT_ULong   data_offset;
     FT_ULong   data_size;
 
     FT_ULong*  offsets;
     FT_Byte*   bytes;
 
   } CFF_IndexRec, *CFF_Index;
 
 
   typedef struct  CFF_EncodingRec_
   {
     FT_UInt     format;
     FT_ULong    offset;
 
     FT_UInt     count;
     FT_UShort   sids [256];  /* avoid dynamic allocations */
     FT_UShort   codes[256];
 
   } CFF_EncodingRec, *CFF_Encoding;
 
 
   typedef struct  CFF_CharsetRec_
   {
 
     FT_UInt     format;
     FT_ULong    offset;
 
     FT_UShort*  sids;
     FT_UShort*  cids;       /* the inverse mapping of `sids'; only needed */
                             /* for CID-keyed fonts                        */
     FT_UInt     max_cid;
     FT_UInt     num_glyphs;
 
   } CFF_CharsetRec, *CFF_Charset;
 
 
+  /* cf. similar fields in file `ttgxvar.h' from the `truetype' module */
+
+  typedef struct  CFF_VarData_
+  {
+#if 0
+    FT_UInt  itemCount;       /* not used; always zero */
+    FT_UInt  shortDeltaCount; /* not used; always zero */
+#endif
+
+    FT_UInt   regionIdxCount; /* number of regions in this var data */
+    FT_UInt*  regionIndices;  /* array of `regionCount' indices;    */
+                              /* these index `varRegionList'        */
+  } CFF_VarData;
+
+
+  /* contribution of one axis to a region */
+  typedef struct  CFF_AxisCoords_
+  {
+    FT_Fixed  startCoord;
+    FT_Fixed  peakCoord;      /* zero peak means no effect (factor = 1) */
+    FT_Fixed  endCoord;
+
+  } CFF_AxisCoords;
+
+
+  typedef struct  CFF_VarRegion_
+  {
+    CFF_AxisCoords*  axisList;      /* array of axisCount records */
+
+  } CFF_VarRegion;
+
+
+  typedef struct  CFF_VStoreRec_
+  {
+    FT_UInt         dataCount;
+    CFF_VarData*    varData;        /* array of dataCount records      */
+                                    /* vsindex indexes this array      */
+    FT_UShort       axisCount;
+    FT_UInt         regionCount;    /* total number of regions defined */
+    CFF_VarRegion*  varRegionList;
+
+  } CFF_VStoreRec, *CFF_VStore;
+
+
+  /* forward reference */
+  typedef struct CFF_FontRec_*  CFF_Font;
+
+
+  /* This object manages one cached blend vector.                  */
+  /*                                                               */
+  /* There is a BlendRec for Private DICT parsing in each subfont  */
+  /* and a BlendRec for charstrings in CF2_Font instance data.     */
+  /* A cached BV may be used across DICTs or Charstrings if inputs */
+  /* have not changed.                                             */
+  /*                                                               */
+  /* `usedBV' is reset at the start of each parse or charstring.   */
+  /* vsindex cannot be changed after a BV is used.                 */
+  /*                                                               */
+  /* Note: NDV is long (32/64 bit), while BV is 16.16 (FT_Int32).  */
+  typedef struct  CFF_BlendRec_
+  {
+    FT_Bool    builtBV;        /* blendV has been built           */
+    FT_Bool    usedBV;         /* blendV has been used            */
+    CFF_Font   font;           /* top level font struct           */
+    FT_UInt    lastVsindex;    /* last vsindex used               */
+    FT_UInt    lenNDV;         /* normDV length (aka numAxes)     */
+    FT_Fixed*  lastNDV;        /* last NDV used                   */
+    FT_UInt    lenBV;          /* BlendV length (aka numMasters)  */
+    FT_Int32*  BV;             /* current blendV (per DICT/glyph) */
+
+  } CFF_BlendRec, *CFF_Blend;
+
+
   typedef struct  CFF_FontRecDictRec_
   {
     FT_UInt    version;
     FT_UInt    notice;
     FT_UInt    copyright;
     FT_UInt    full_name;
     FT_UInt    family_name;
     FT_UInt    weight;
     FT_Bool    is_fixed_pitch;
     FT_Fixed   italic_angle;
     FT_Fixed   underline_position;
     FT_Fixed   underline_thickness;
     FT_Int     paint_type;
     FT_Int     charstring_type;
     FT_Matrix  font_matrix;
     FT_Bool    has_font_matrix;
     FT_ULong   units_per_em;  /* temporarily used as scaling value also */
     FT_Vector  font_offset;
     FT_ULong   unique_id;
     FT_BBox    font_bbox;
     FT_Pos     stroke_width;
     FT_ULong   charset_offset;
     FT_ULong   encoding_offset;
     FT_ULong   charstrings_offset;
     FT_ULong   private_offset;
     FT_ULong   private_size;
     FT_Long    synthetic_base;
     FT_UInt    embedded_postscript;
 
     /* these should only be used for the top-level font dictionary */
     FT_UInt    cid_registry;
     FT_UInt    cid_ordering;
     FT_Long    cid_supplement;
 
     FT_Long    cid_font_version;
     FT_Long    cid_font_revision;
     FT_Long    cid_font_type;
     FT_ULong   cid_count;
     FT_ULong   cid_uid_base;
     FT_ULong   cid_fd_array_offset;
     FT_ULong   cid_fd_select_offset;
     FT_UInt    cid_font_name;
 
     /* the next fields come from the data of the deprecated          */
     /* `MultipleMaster' operator; they are needed to parse the (also */
     /* deprecated) `blend' operator in Type 2 charstrings            */
     FT_UShort  num_designs;
     FT_UShort  num_axes;
 
     /* fields for CFF2 */
+    FT_ULong   vstore_offset;
     FT_UInt    maxstack;
 
   } CFF_FontRecDictRec, *CFF_FontRecDict;
 
 
   /* forward reference */
   typedef struct CFF_SubFontRec_*  CFF_SubFont;
 
 
   typedef struct  CFF_PrivateRec_
   {
     FT_Byte   num_blue_values;
     FT_Byte   num_other_blues;
     FT_Byte   num_family_blues;
     FT_Byte   num_family_other_blues;
 
     FT_Pos    blue_values[14];
     FT_Pos    other_blues[10];
     FT_Pos    family_blues[14];
     FT_Pos    family_other_blues[10];
 
     FT_Fixed  blue_scale;
     FT_Pos    blue_shift;
     FT_Pos    blue_fuzz;
     FT_Pos    standard_width;
     FT_Pos    standard_height;
 
     FT_Byte   num_snap_widths;
     FT_Byte   num_snap_heights;
     FT_Pos    snap_widths[13];
     FT_Pos    snap_heights[13];
     FT_Bool   force_bold;
     FT_Fixed  force_bold_threshold;
     FT_Int    lenIV;
     FT_Int    language_group;
     FT_Fixed  expansion_factor;
     FT_Long   initial_random_seed;
     FT_ULong  local_subrs_offset;
     FT_Pos    default_width;
     FT_Pos    nominal_width;
 
     /* fields for CFF2 */
+    FT_UInt      vsindex;
     CFF_SubFont  subfont;
 
   } CFF_PrivateRec, *CFF_Private;
 
 
   typedef struct  CFF_FDSelectRec_
   {
     FT_Byte   format;
     FT_UInt   range_count;
 
     /* that's the table, taken from the file `as is' */
     FT_Byte*  data;
     FT_UInt   data_size;
 
     /* small cache for format 3 only */
     FT_UInt   cache_first;
     FT_UInt   cache_count;
     FT_Byte   cache_fd;
 
   } CFF_FDSelectRec, *CFF_FDSelect;
 
 
   /* A SubFont packs a font dict and a private dict together.  They are */
   /* needed to support CID-keyed CFF fonts.                             */
   typedef struct  CFF_SubFontRec_
   {
     CFF_FontRecDictRec  font_dict;
     CFF_PrivateRec      private_dict;
 
+    /* fields for CFF2 */
+    CFF_BlendRec  blend;      /* current blend vector       */
+    FT_UInt       lenNDV;     /* current length NDV or zero */
+    FT_Fixed*     NDV;        /* ptr to current NDV or NULL */
+
+    /* `blend_stack' is a writable buffer to hold blend results.          */
+    /* This buffer is to the side of the normal cff parser stack;         */
+    /* `cff_parse_blend' and `cff_blend_doBlend' push blend results here. */
+    /* The normal stack then points to these values instead of the DICT   */
+    /* because all other operators in Private DICT clear the stack.       */
+    /* `blend_stack' could be cleared at each operator other than blend.  */
+    /* Blended values are stored as 5-byte fixed point values.            */
+
+    FT_Byte*  blend_stack;    /* base of stack allocation     */
+    FT_Byte*  blend_top;      /* first empty slot             */
+    FT_UInt   blend_used;     /* number of bytes in use       */
+    FT_UInt   blend_alloc;    /* number of bytes allocated    */
+
     CFF_IndexRec  local_subrs_index;
     FT_Byte**     local_subrs; /* array of pointers           */
                                /* into Local Subrs INDEX data */
 
   } CFF_SubFontRec;
 
 
 #define CFF_MAX_CID_FONTS  256
 
 
   typedef struct  CFF_FontRec_
   {
     FT_Library       library;
     FT_Stream        stream;
     FT_Memory        memory;        /* TODO: take this from stream->memory? */
     FT_ULong         base_offset;   /* offset to start of CFF */
     FT_UInt          num_faces;
     FT_UInt          num_glyphs;
 
     FT_Byte          version_major;
     FT_Byte          version_minor;
     FT_Byte          header_size;
 
     FT_UInt          top_dict_length;   /* cff2 only */
 
     FT_Bool          cff2;
 
     CFF_IndexRec     name_index;
     CFF_IndexRec     top_dict_index;
     CFF_IndexRec     global_subrs_index;
 
     CFF_EncodingRec  encoding;
     CFF_CharsetRec   charset;
 
     CFF_IndexRec     charstrings_index;
     CFF_IndexRec     font_dict_index;
     CFF_IndexRec     private_index;
     CFF_IndexRec     local_subrs_index;
 
     FT_String*       font_name;
 
     /* array of pointers into Global Subrs INDEX data */
     FT_Byte**        global_subrs;
 
     /* array of pointers into String INDEX data stored at string_pool */
     FT_UInt          num_strings;
     FT_Byte**        strings;
     FT_Byte*         string_pool;
     FT_ULong         string_pool_size;
 
     CFF_SubFontRec   top_font;
     FT_UInt          num_subfonts;
     CFF_SubFont      subfonts[CFF_MAX_CID_FONTS];
 
     CFF_FDSelectRec  fd_select;
 
     /* interface to PostScript hinter */
     PSHinter_Service  pshinter;
 
     /* interface to Postscript Names service */
     FT_Service_PsCMaps  psnames;
 
     /* since version 2.3.0 */
     PS_FontInfoRec*  font_info;   /* font info dictionary */
 
     /* since version 2.3.6 */
     FT_String*       registry;
     FT_String*       ordering;
 
     /* since version 2.4.12 */
     FT_Generic       cf2_instance;
 
-  } CFF_FontRec, *CFF_Font;
+    CFF_VStoreRec    vstore;        /* parsed vstore structure */
+
+  } CFF_FontRec;
 
 
 FT_END_HEADER
diff --git a/src/truetype/ttgxvar.c b/src/truetype/ttgxvar.c
index affa6199e..8df6b1164 100644
--- a/src/truetype/ttgxvar.c
+++ b/src/truetype/ttgxvar.c
@@ -1,2854 +1,2859 @@
 /***************************************************************************/
 /*                                                                         */
 /*  ttgxvar.c                                                              */
 /*                                                                         */
 /*    TrueType GX Font Variation loader                                    */
 /*                                                                         */
 /*  Copyright 2004-2016 by                                                 */
 /*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 /*  this file you indicate that you have read the license and              */
 /*  understand and accept it fully.                                        */
 /*                                                                         */
 /***************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
   /*                                                                       */
   /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html */
   /*                                                                       */
   /* The documentation for `fvar' is inconsistent.  At one point it says   */
   /* that `countSizePairs' should be 3, at another point 2.  It should     */
   /* be 2.                                                                 */
   /*                                                                       */
   /* The documentation for `gvar' is not intelligible; `cvar' refers you   */
   /* to `gvar' and is thus also incomprehensible.                          */
   /*                                                                       */
   /* The documentation for `avar' appears correct, but Apple has no fonts  */
   /* with an `avar' table, so it is hard to test.                          */
   /*                                                                       */
   /* Many thanks to John Jenkins (at Apple) in figuring this out.          */
   /*                                                                       */
   /*                                                                       */
   /* Apple's `kern' table has some references to tuple indices, but as     */
   /* there is no indication where these indices are defined, nor how to    */
   /* interpolate the kerning values (different tuples have different       */
   /* classes) this issue is ignored.                                       */
   /*                                                                       */
   /*************************************************************************/
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_MULTIPLE_MASTERS_H
 
 #include "ttpload.h"
 #include "ttgxvar.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
 #define FT_Stream_FTell( stream )                         \
           (FT_ULong)( (stream)->cursor - (stream)->base )
 #define FT_Stream_SeekSet( stream, off )                  \
           ( (stream)->cursor = (stream)->base + (off) )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
   /* messages during execution.                                            */
   /*                                                                       */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_ttgxvar
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                       Internal Routines                       *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
   /* indicates that there is a delta for every point without needing to    */
   /* enumerate all of them.                                                */
   /*                                                                       */
 
   /* ensure that value `0' has the same width as a pointer */
 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
 
 
 #define GX_PT_POINTS_ARE_WORDS      0x80U
 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackedpoints                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of points to which the following deltas will apply.     */
   /*    Points are packed with a run length encoding.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /*    size      :: The size of the table holding the data.               */
   /*                                                                       */
   /* <Output>                                                              */
   /*    point_cnt :: The number of points read.  A zero value means that   */
   /*                 all points in the glyph will be affected, without     */
   /*                 enumerating them individually.                        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_UShort containing the affected points or the        */
   /*    special value ALL_POINTS.                                          */
   /*                                                                       */
   static FT_UShort*
   ft_var_readpackedpoints( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt   *point_cnt )
   {
     FT_UShort *points = NULL;
     FT_UInt    n;
     FT_UInt    runcnt;
     FT_UInt    i, j;
     FT_UShort  first;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     *point_cnt = 0;
 
     n = FT_GET_BYTE();
     if ( n == 0 )
       return ALL_POINTS;
 
     if ( n & GX_PT_POINTS_ARE_WORDS )
     {
       n  &= GX_PT_POINT_RUN_COUNT_MASK;
       n <<= 8;
       n  |= FT_GET_BYTE();
     }
 
     if ( n > size )
     {
       FT_TRACE1(( "ft_var_readpackedpoints: number of points too large\n" ));
       return NULL;
     }
 
     /* in the nested loops below we increase `i' twice; */
     /* it is faster to simply allocate one more slot    */
     /* than to add another test within the loop         */
     if ( FT_NEW_ARRAY( points, n + 1 ) )
       return NULL;
 
     *point_cnt = n;
 
     first = 0;
     i     = 0;
     while ( i < n )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_PT_POINTS_ARE_WORDS )
       {
         runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;
         first      += FT_GET_USHORT();
         points[i++] = first;
 
         /* first point not included in run count */
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_USHORT();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
       else
       {
         first      += FT_GET_BYTE();
         points[i++] = first;
 
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_BYTE();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
     }
 
     return points;
   }
 
 
 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_readpackeddeltas                                            */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Read a set of deltas.  These are packed slightly differently than  */
   /*    points.  In particular there is no overall count.                  */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream    :: The data stream.                                      */
   /*                                                                       */
   /*    size      :: The size of the table holding the data.               */
   /*                                                                       */
   /*    delta_cnt :: The number of deltas to be read.                      */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An array of FT_Short containing the deltas for the affected        */
   /*    points.  (This only gets the deltas for one dimension.  It will    */
   /*    generally be called twice, once for x, once for y.  When used in   */
   /*    cvt table, it will only be called once.)                           */
   /*                                                                       */
   static FT_Short*
   ft_var_readpackeddeltas( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt    delta_cnt )
   {
     FT_Short  *deltas = NULL;
     FT_UInt    runcnt, cnt;
     FT_UInt    i, j;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     if ( delta_cnt > size )
     {
       FT_TRACE1(( "ft_var_readpackeddeltas: number of points too large\n" ));
       return NULL;
     }
 
     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
       return NULL;
 
     i = 0;
     while ( i < delta_cnt )
     {
       runcnt = FT_GET_BYTE();
       cnt    = runcnt & GX_DT_DELTA_RUN_COUNT_MASK;
 
       if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
       {
         /* `runcnt' zeroes get added */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = 0;
       }
       else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
       {
         /* `runcnt' shorts from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_GET_SHORT();
       }
       else
       {
         /* `runcnt' signed bytes from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_GET_CHAR();
       }
 
       if ( j <= cnt )
       {
         /* bad format */
         FT_FREE( deltas );
         return NULL;
       }
     }
 
     return deltas;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_avar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `avar' table if present.  It need not be, so we return   */
   /*    nothing.                                                           */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   static void
   ft_var_load_avar( TT_Face  face )
   {
     FT_Stream       stream = FT_FACE_STREAM( face );
     FT_Memory       memory = stream->memory;
     GX_Blend        blend  = face->blend;
     GX_AVarSegment  segment;
     FT_Error        error = FT_Err_Ok;
     FT_Long         version;
     FT_Long         axisCount;
     FT_Int          i, j;
     FT_ULong        table_len;
 
     FT_UNUSED( error );
 
 
     FT_TRACE2(( "AVAR " ));
 
     blend->avar_checked = TRUE;
     error = face->goto_table( face, TTAG_avar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
       return;
 
     version   = FT_GET_LONG();
     axisCount = FT_GET_LONG();
 
     if ( version != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( axisCount != (FT_Long)blend->mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_load_avar: number of axes in `avar' and `cvar'\n"
                   "                  table are different\n" ));
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )
       goto Exit;
 
     segment = &blend->avar_segment[0];
     for ( i = 0; i < axisCount; i++, segment++ )
     {
       FT_TRACE5(( "  axis %d:\n", i ));
 
       segment->pairCount = FT_GET_USHORT();
       if ( (FT_ULong)segment->pairCount * 4 > table_len                ||
            FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )
       {
         /* Failure.  Free everything we have done so far.  We must do */
         /* it right now since loading the `avar' table is optional.   */
 
         for ( j = i - 1; j >= 0; j-- )
           FT_FREE( blend->avar_segment[j].correspondence );
 
         FT_FREE( blend->avar_segment );
         blend->avar_segment = NULL;
         goto Exit;
       }
 
       for ( j = 0; j < segment->pairCount; j++ )
       {
         /* convert to Fixed */
         segment->correspondence[j].fromCoord = FT_GET_SHORT() * 4;
         segment->correspondence[j].toCoord   = FT_GET_SHORT() * 4;
 
         FT_TRACE5(( "    mapping %.4f to %.4f\n",
                     segment->correspondence[j].fromCoord / 65536.0,
                     segment->correspondence[j].toCoord / 65536.0 ));
       }
 
       FT_TRACE5(( "\n" ));
     }
 
   Exit:
     FT_FRAME_EXIT();
   }
 
 
   /* some macros we need */
   #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )
 
   #define FT_fdot14ToFixed( x )                    \
           ( ( (FT_Fixed)( (FT_Int16)(x) ) ) << 2 )
   #define FT_intToFixed( i )                     \
           ( (FT_Fixed)( (FT_UInt32)(i) << 16 ) )
   #define FT_fixedToInt( x )                                   \
           ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_hvar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `HVAR' table and set `blend->hvar_loaded' to TRUE.       */
   /*                                                                       */
   /*    On success, `blend->hvar_checked' is set to TRUE.                  */
   /*                                                                       */
   /*    Some memory may remain allocated on error; it is always freed in   */
   /*    `tt_done_blend', however.                                          */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   ft_var_load_hvar( TT_Face  face )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend  blend = face->blend;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_UShort  minorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_ULong   store_offset;
     FT_ULong   map_offset;
 
     FT_ULong*  dataOffsetArray = NULL;
 
 
     blend->hvar_loaded = TRUE;
 
     FT_TRACE2(( "HVAR " ));
 
     error = face->goto_table( face, TTAG_HVAR, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     table_offset = FT_STREAM_POS();
 
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_READ_USHORT( minorVersion ) )
       goto Exit;
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( FT_READ_ULONG( store_offset ) ||
          FT_READ_ULONG( map_offset )   )
       goto Exit;
 
     /* parse item variation store */
     {
       FT_UShort  format;
       FT_ULong   region_offset;
       FT_UInt    i, j, k;
       FT_UInt    shortDeltaCount;
 
       GX_HVStore    itemStore;
       GX_HVarTable  hvarTable;
       GX_HVarData   hvarData;
 
 
       if ( FT_STREAM_SEEK( table_offset + store_offset ) ||
            FT_READ_USHORT( format )                      )
         goto Exit;
       if ( format != 1 )
       {
         FT_TRACE2(( "bad store format %d\n", format ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       if ( FT_NEW( blend->hvar_table ) )    /* allocate table at top level */
         goto Exit;
 
       hvarTable = blend->hvar_table;
       itemStore = &hvarTable->itemStore;
 
       /* read top level fields */
       if ( FT_READ_ULONG( region_offset )         ||
            FT_READ_USHORT( itemStore->dataCount ) )
         goto Exit;
 
       /* make temporary copy of item variation data offsets; */
       /* we will parse region list first, then come back     */
       if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         if ( FT_READ_ULONG( dataOffsetArray[i] ) )
           goto Exit;
       }
 
       /* parse array of region records (region list) */
       if ( FT_STREAM_SEEK( table_offset + store_offset + region_offset ) )
         goto Exit;
 
       if ( FT_READ_USHORT( itemStore->axisCount )   ||
            FT_READ_USHORT( itemStore->regionCount ) )
         goto Exit;
 
       if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->regionCount; i++ )
       {
         GX_AxisCoords  axisCoords;
 
 
         if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,
                            itemStore->axisCount ) )
           goto Exit;
 
         axisCoords = itemStore->varRegionList[i].axisList;
 
         for ( j = 0; j < itemStore->axisCount; j++ )
         {
           FT_Short  start, peak, end;
 
 
           if ( FT_READ_SHORT( start ) ||
                FT_READ_SHORT( peak )  ||
                FT_READ_SHORT( end )   )
             goto Exit;
 
           axisCoords[j].startCoord = FT_fdot14ToFixed( start );
           axisCoords[j].peakCoord  = FT_fdot14ToFixed( peak );
           axisCoords[j].endCoord   = FT_fdot14ToFixed( end );
         }
       }
 
       /* end of region list parse */
 
       /* use dataOffsetArray now to parse varData items */
       if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )
         goto Exit;
 
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         hvarData = &itemStore->varData[i];
 
         if ( FT_STREAM_SEEK( table_offset       +
                              store_offset       +
                              dataOffsetArray[i] ) )
           goto Exit;
 
         if ( FT_READ_USHORT( hvarData->itemCount )      ||
              FT_READ_USHORT( shortDeltaCount )          ||
              FT_READ_USHORT( hvarData->regionIdxCount ) )
           goto Exit;
 
         /* check some data consistency */
         if ( shortDeltaCount > hvarData->regionIdxCount )
         {
           FT_TRACE2(( "bad short count %d or region count %d\n",
                       shortDeltaCount,
                       hvarData->regionIdxCount ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         if ( hvarData->regionIdxCount > itemStore->regionCount )
         {
           FT_TRACE2(( "inconsistent regionCount %d in varData[%d]\n",
                       hvarData->regionIdxCount,
                       i ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         /* parse region indices */
         if ( FT_NEW_ARRAY( hvarData->regionIndices,
                            hvarData->regionIdxCount ) )
           goto Exit;
 
         for ( j = 0; j < hvarData->regionIdxCount; j++ )
         {
           if ( FT_READ_USHORT( hvarData->regionIndices[j] ) )
             goto Exit;
 
           if ( hvarData->regionIndices[j] >= itemStore->regionCount )
           {
             FT_TRACE2(( "bad region index %d\n",
                         hvarData->regionIndices[j] ));
             error = FT_THROW( Invalid_Table );
             goto Exit;
           }
         }
 
         /* Parse delta set.                                                */
         /*                                                                 */
         /* On input, deltas are ( shortDeltaCount + regionIdxCount ) bytes */
         /* each; on output, deltas are expanded to `regionIdxCount' shorts */
         /* each.                                                           */
         if ( FT_NEW_ARRAY( hvarData->deltaSet,
                            hvarData->regionIdxCount * hvarData->itemCount ) )
           goto Exit;
 
         /* the delta set is stored as a 2-dimensional array of shorts; */
         /* sign-extend signed bytes to signed shorts                   */
         for ( j = 0; j < hvarData->itemCount * hvarData->regionIdxCount; )
         {
           for ( k = 0; k < shortDeltaCount; k++, j++ )
           {
             /* read the short deltas */
             FT_Short  delta;
 
 
             if ( FT_READ_SHORT( delta ) )
               goto Exit;
 
             hvarData->deltaSet[j] = delta;
           }
 
           for ( ; k < hvarData->regionIdxCount; k++, j++ )
           {
             /* read the (signed) byte deltas */
             FT_Char  delta;
 
 
             if ( FT_READ_CHAR( delta ) )
               goto Exit;
 
             hvarData->deltaSet[j] = delta;
           }
         }
       }
     }
 
     /* end parse item variation store */
 
     /* parse width map */
     {
       GX_WidthMap  widthMap;
 
       FT_UShort  format;
       FT_UInt    entrySize;
       FT_UInt    innerBitCount;
       FT_UInt    innerIndexMask;
       FT_UInt    i, j;
 
 
       widthMap = &blend->hvar_table->widthMap;
 
       if ( FT_READ_USHORT( format )             ||
            FT_READ_USHORT( widthMap->mapCount ) )
         goto Exit;
 
       if ( format & 0xFFC0 )
       {
         FT_TRACE2(( "bad map format %d\n", format ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       /* bytes per entry: 1, 2, 3, or 4 */
       entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;
       innerBitCount  = ( format & 0x000F ) + 1;
       innerIndexMask = ( 1 << innerBitCount ) - 1;
 
       if ( FT_NEW_ARRAY( widthMap->innerIndex, widthMap->mapCount ) )
         goto Exit;
 
       if ( FT_NEW_ARRAY( widthMap->outerIndex, widthMap->mapCount ) )
         goto Exit;
 
       for ( i = 0; i < widthMap->mapCount; i++ )
       {
         FT_UInt  mapData = 0;
         FT_UInt  outerIndex, innerIndex;
 
 
         /* read map data one unsigned byte at a time, big endian */
         for ( j = 0; j < entrySize; j++ )
         {
           FT_Byte  data;
 
 
           if ( FT_READ_BYTE( data ) )
             goto Exit;
 
           mapData = ( mapData << 8 ) | data;
         }
 
         outerIndex = mapData >> innerBitCount;
 
         if ( outerIndex >= blend->hvar_table->itemStore.dataCount )
         {
           FT_TRACE2(( "outerIndex[%d] == %d out of range\n",
                       i,
                       outerIndex ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
 
         widthMap->outerIndex[i] = outerIndex;
 
         innerIndex = mapData & innerIndexMask;
 
         if ( innerIndex >=
                blend->hvar_table->itemStore.varData[outerIndex].itemCount )
         {
           FT_TRACE2(( "innerIndex[%d] == %d out of range\n",
                       i,
                       innerIndex ));
           error = FT_THROW( Invalid_Table );
             goto Exit;
         }
 
         widthMap->innerIndex[i] = innerIndex;
       }
     }
 
     /* end parse width map */
 
     FT_TRACE2(( "loaded\n" ));
     error = FT_Err_Ok;
 
   Exit:
     FT_FREE( dataOffsetArray );
 
     if ( !error )
       blend->hvar_checked = TRUE;
 
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_hadvance_adjust                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Apply HVAR advance width adjustment of a given glyph.              */
   /*                                                                       */
   /* <Input>                                                               */
   /*    gindex :: The glyph index.                                         */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: The font face.                                           */
   /*                                                                       */
   /*    adelta :: Points to width value that gets modified.                */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_hadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     FT_Error  error = FT_Err_Ok;
 
     GX_HVarData  varData;
 
     FT_UInt    innerIndex, outerIndex;
     FT_UInt    master, j;
     FT_Fixed   netAdjustment = 0;     /* accumulated adjustment */
     FT_Fixed   scaledDelta;
     FT_Short*  deltaSet;
     FT_Fixed   delta;
 
 
     if ( !face->blend )
       goto Exit;
 
     if ( !face->blend->hvar_loaded )
     {
       /* initialize hvar table */
       face->blend->hvar_error = ft_var_load_hvar( face );
     }
 
     if ( !face->blend->hvar_checked )
     {
       error = face->blend->hvar_error;
       goto Exit;
     }
 
     if ( gindex >= face->blend->hvar_table->widthMap.mapCount )
     {
       FT_TRACE2(( "gindex %d out of range\n", gindex ));
       error = FT_THROW( Invalid_Argument );
       goto Exit;
     }
 
     /* trust that HVAR parser has checked indices */
     outerIndex = face->blend->hvar_table->widthMap.outerIndex[gindex];
     innerIndex = face->blend->hvar_table->widthMap.innerIndex[gindex];
     varData    = &face->blend->hvar_table->itemStore.varData[outerIndex];
     deltaSet   = &varData->deltaSet[varData->regionIdxCount * innerIndex];
 
     /* See pseudo code from `Font Variations Overview' */
     /* in the OpenType specification.                  */
 
     /* outer loop steps through master designs to be blended */
     for ( master = 0; master < varData->regionIdxCount; master++ )
     {
       FT_Fixed  scalar      = FT_FIXED_ONE;
       FT_UInt   regionIndex = varData->regionIndices[master];
 
       GX_AxisCoords  axis = face->blend
                               ->hvar_table
                               ->itemStore.varRegionList[regionIndex]
                                          .axisList;
 
 
       /* inner loop steps through axes in this region */
       for ( j = 0;
             j < face->blend->hvar_table->itemStore.axisCount;
             j++, axis++ )
       {
         FT_Fixed  axisScalar;
 
 
         /* compute the scalar contribution of this axis; */
         /* ignore invalid ranges                         */
         if ( axis->startCoord > axis->peakCoord ||
              axis->peakCoord > axis->endCoord   )
           axisScalar = FT_FIXED_ONE;
 
         else if ( axis->startCoord < 0 &&
                   axis->endCoord > 0   &&
                   axis->peakCoord != 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* peak of 0 means ignore this axis */
         else if ( axis->peakCoord == 0 )
           axisScalar = FT_FIXED_ONE;
 
         /* ignore this region if coords are out of range */
         else if ( face->blend->normalizedcoords[j] < axis->startCoord ||
                   face->blend->normalizedcoords[j] > axis->endCoord   )
           axisScalar = 0;
 
         /* calculate a proportional factor */
         else
         {
           if ( face->blend->normalizedcoords[j] == axis->peakCoord )
             axisScalar = FT_FIXED_ONE;
           else if ( face->blend->normalizedcoords[j] < axis->peakCoord )
             axisScalar =
               FT_DivFix( face->blend->normalizedcoords[j] - axis->startCoord,
                          axis->peakCoord - axis->startCoord );
           else
             axisScalar =
               FT_DivFix( axis->endCoord - face->blend->normalizedcoords[j],
                          axis->endCoord - axis->peakCoord );
         }
 
         /* take product of all the axis scalars */
         scalar = FT_MulFix( scalar, axisScalar );
 
       } /* per-axis loop */
 
       FT_TRACE4(( ", %f ", scalar / 65536.0 ));
 
       /* get the scaled delta for this region */
       delta       = FT_intToFixed( deltaSet[master] );
       scaledDelta = FT_MulFix( scalar, delta );
 
       /* accumulate the adjustments from each region */
       netAdjustment = netAdjustment + scaledDelta;
 
     } /* per-region loop */
 
     FT_TRACE4(( "]\n" ));
 
     /* apply the accumulated adjustment to derive the interpolated value */
     *avalue += FT_fixedToInt( netAdjustment );
 
   Exit:
     return error;
   }
 
 
   typedef struct  GX_GVar_Head_
   {
     FT_Long    version;
     FT_UShort  axisCount;
     FT_UShort  globalCoordCount;
     FT_ULong   offsetToCoord;
     FT_UShort  glyphCount;
     FT_UShort  flags;
     FT_ULong   offsetToData;
 
   } GX_GVar_Head;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_load_gvar                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Parse the `gvar' table if present.  If `fvar' is there, `gvar' had */
   /*    better be there too.                                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face :: The font face.                                             */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   static FT_Error
   ft_var_load_gvar( TT_Face  face )
   {
     FT_Stream     stream = FT_FACE_STREAM( face );
     FT_Memory     memory = stream->memory;
     GX_Blend      blend  = face->blend;
     FT_Error      error;
     FT_UInt       i, j;
     FT_ULong      table_len;
     FT_ULong      gvar_start;
     FT_ULong      offsetToData;
     GX_GVar_Head  gvar_head;
 
     static const FT_Frame_Field  gvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_GVar_Head
 
       FT_FRAME_START( 20 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( globalCoordCount ),
         FT_FRAME_ULONG ( offsetToCoord ),
         FT_FRAME_USHORT( glyphCount ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_ULONG ( offsetToData ),
       FT_FRAME_END
     };
 
 
     FT_TRACE2(( "GVAR " ));
 
     if ( ( error = face->goto_table( face,
                                      TTAG_gvar,
                                      stream,
                                      &table_len ) ) != 0 )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     gvar_start = FT_STREAM_POS( );
     if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )
       goto Exit;
 
     if ( gvar_head.version != 0x00010000L )
     {
       FT_TRACE1(( "bad table version\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
     {
       FT_TRACE1(( "ft_var_load_gvar: number of axes in `gvar' and `cvar'\n"
                   "                  table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check, ignoring offsets */
     if ( (FT_ULong)gvar_head.globalCoordCount * gvar_head.axisCount >
            table_len / 2 )
     {
       FT_TRACE1(( "ft_var_load_gvar:"
                   " invalid number of global coordinates\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check: offsets can be either 2 or 4 bytes, */
     /* and a single variation needs at least 4 bytes per glyph */
     if ( (FT_ULong)gvar_head.glyphCount *
            ( ( gvar_head.flags & 1 ) ? 8 : 6 ) > table_len )
     {
       FT_TRACE1(( "ft_var_load_gvar: invalid number of glyphs\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     blend->gvar_size   = table_len;
     blend->tuplecount  = gvar_head.globalCoordCount;
     blend->gv_glyphcnt = gvar_head.glyphCount;
     offsetToData       = gvar_start + gvar_head.offsetToData;
 
     FT_TRACE5(( "gvar: there are %d shared coordinates:\n",
                 blend->tuplecount ));
 
     if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )
       goto Exit;
 
     if ( gvar_head.flags & 1 )
     {
       /* long offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_ULONG();
 
       FT_FRAME_EXIT();
     }
     else
     {
       /* short offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
         blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
                                                /* XXX: Undocumented: `*2'! */
 
       FT_FRAME_EXIT();
     }
 
     if ( blend->tuplecount != 0 )
     {
       if ( FT_NEW_ARRAY( blend->tuplecoords,
                          gvar_head.axisCount * blend->tuplecount ) )
         goto Exit;
 
       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
            FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L ) )
         goto Exit;
 
       for ( i = 0; i < blend->tuplecount; i++ )
       {
         FT_TRACE5(( "  [ " ));
         for ( j = 0; j < (FT_UInt)gvar_head.axisCount; j++ )
         {
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */
           FT_TRACE5(( "%.4f ",
             blend->tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
         }
         FT_TRACE5(( "]\n" ));
       }
 
       FT_TRACE5(( "\n" ));
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    ft_var_apply_tuple                                                 */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Figure out whether a given tuple (design) applies to the current   */
   /*    blend, and if so, what is the scaling factor.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    blend           :: The current blend of the font.                  */
   /*                                                                       */
   /*    tupleIndex      :: A flag saying whether this is an intermediate   */
   /*                       tuple or not.                                   */
   /*                                                                       */
   /*    tuple_coords    :: The coordinates of the tuple in normalized axis */
   /*                       units.                                          */
   /*                                                                       */
   /*    im_start_coords :: The initial coordinates where this tuple starts */
   /*                       to apply (for intermediate coordinates).        */
   /*                                                                       */
   /*    im_end_coords   :: The final coordinates after which this tuple no */
   /*                       longer applies (for intermediate coordinates).  */
   /*                                                                       */
   /* <Return>                                                              */
   /*    An FT_Fixed value containing the scaling factor.                   */
   /*                                                                       */
   static FT_Fixed
   ft_var_apply_tuple( GX_Blend   blend,
                       FT_UShort  tupleIndex,
                       FT_Fixed*  tuple_coords,
                       FT_Fixed*  im_start_coords,
                       FT_Fixed*  im_end_coords )
   {
     FT_UInt   i;
     FT_Fixed  apply = 0x10000L;
 
 
     for ( i = 0; i < blend->num_axis; i++ )
     {
       FT_TRACE6(( "    axis coordinate %d (%.4f):\n",
                   i, blend->normalizedcoords[i] / 65536.0 ));
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
         FT_TRACE6(( "      intermediate coordinates %d (%.4f, %.4f):\n",
                     i,
                     im_start_coords[i] / 65536.0,
                     im_end_coords[i] / 65536.0 ));
 
       /* It's not clear why (for intermediate tuples) we don't need     */
       /* to check against start/end -- the documentation says we don't. */
       /* Similarly, it's unclear why we don't need to scale along the   */
       /* axis.                                                          */
 
       if ( tuple_coords[i] == 0 )
       {
         FT_TRACE6(( "      tuple coordinate is zero, ignored\n", i ));
         continue;
       }
 
       if ( blend->normalizedcoords[i] == 0 )
       {
         FT_TRACE6(( "      axis coordinate is zero, stop\n" ));
         apply = 0;
         break;
       }
 
       if ( blend->normalizedcoords[i] == tuple_coords[i] )
       {
         FT_TRACE6(( "      tuple coordinate value %.4f fits perfectly\n",
                     tuple_coords[i] / 65536.0 ));
         /* `apply' does not change */
         continue;
       }
 
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
       {
         /* not an intermediate tuple */
 
         if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||
              blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )
         {
           FT_TRACE6(( "      tuple coordinate value %.4f is exceeded, stop\n",
                       tuple_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         FT_TRACE6(( "      tuple coordinate value %.4f fits\n",
                     tuple_coords[i] / 65536.0 ));
         apply = FT_MulDiv( apply,
                            blend->normalizedcoords[i],
                            tuple_coords[i] );
       }
       else
       {
         /* intermediate tuple */
 
         if ( blend->normalizedcoords[i] < im_start_coords[i] ||
              blend->normalizedcoords[i] > im_end_coords[i]   )
         {
           FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] is exceeded,"
                       " stop\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         else if ( blend->normalizedcoords[i] < tuple_coords[i] )
         {
           FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              blend->normalizedcoords[i] - im_start_coords[i],
                              tuple_coords[i] - im_start_coords[i] );
         }
 
         else
         {
           FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = FT_MulDiv( apply,
                              im_end_coords[i] - blend->normalizedcoords[i],
                              im_end_coords[i] - tuple_coords[i] );
         }
       }
     }
 
     FT_TRACE6(( "    apply factor is %.4f\n", apply / 65536.0 ));
 
     return apply;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   typedef struct  GX_FVar_Head_
   {
     FT_Long    version;
     FT_UShort  offsetToData;
     FT_UShort  countSizePairs;
     FT_UShort  axisCount;
     FT_UShort  axisSize;
     FT_UShort  instanceCount;
     FT_UShort  instanceSize;
 
   } GX_FVar_Head;
 
 
   typedef struct  fvar_axis_
   {
     FT_ULong   axisTag;
     FT_Fixed   minValue;
     FT_Fixed   defaultValue;
     FT_Fixed   maxValue;
     FT_UShort  flags;
     FT_UShort  nameID;
 
   } GX_FVar_Axis;
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_MM_Var                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Check that the font's `fvar' table is valid, parse it, and return  */
   /*    those data.                                                        */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: The font face.                                           */
   /*              TT_Get_MM_Var initializes the blend structure.           */
   /*                                                                       */
   /* <Output>                                                              */
   /*    master :: The `fvar' data (must be freed by caller).  Can be NULL, */
   /*              which makes this function simply load MM support.        */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Var( TT_Face      face,
                  FT_MM_Var*  *master )
   {
     FT_Stream            stream = face->root.stream;
     FT_Memory            memory = face->root.memory;
     FT_ULong             table_len;
     FT_Error             error  = FT_Err_Ok;
     FT_ULong             fvar_start;
     FT_Int               i, j;
     FT_MM_Var*           mmvar = NULL;
     FT_Fixed*            next_coords;
     FT_String*           next_name;
     FT_Var_Axis*         a;
     FT_Var_Named_Style*  ns;
     GX_FVar_Head         fvar_head;
     FT_Bool              usePsName;
 
     static const FT_Frame_Field  fvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Head
 
       FT_FRAME_START( 16 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( offsetToData ),
         FT_FRAME_USHORT( countSizePairs ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( axisSize ),
         FT_FRAME_USHORT( instanceCount ),
         FT_FRAME_USHORT( instanceSize ),
       FT_FRAME_END
     };
 
     static const FT_Frame_Field  fvaraxis_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Axis
 
       FT_FRAME_START( 20 ),
         FT_FRAME_ULONG ( axisTag ),
         FT_FRAME_LONG  ( minValue ),
         FT_FRAME_LONG  ( defaultValue ),
         FT_FRAME_LONG  ( maxValue ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_USHORT( nameID ),
       FT_FRAME_END
     };
 
 
     /* read the font data and set up the internal representation */
     /* if not already done                                       */
 
     if ( face->blend == NULL )
     {
       FT_TRACE2(( "FVAR " ));
 
       /* both `fvar' and `gvar' must be present */
       if ( ( error = face->goto_table( face, TTAG_gvar,
                                        stream, &table_len ) ) != 0 )
       {
-        FT_TRACE1(( "\n"
-                    "TT_Get_MM_Var: `gvar' table is missing\n" ));
-        goto Exit;
+        /* CFF2 is an alternate to gvar here */
+        if ( ( error = face->goto_table( face, TTAG_CFF2,
+                                         stream, &table_len ) ) != 0 )
+        {
+          FT_TRACE1(( "\n"
+                      "TT_Get_MM_Var: `gvar' or `CFF2' table is missing\n" ));
+          goto Exit;
+        }
       }
 
       if ( ( error = face->goto_table( face, TTAG_fvar,
                                        stream, &table_len ) ) != 0 )
       {
         FT_TRACE1(( "is missing\n" ));
         goto Exit;
       }
 
       fvar_start = FT_STREAM_POS( );
 
       if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )
         goto Exit;
 
       if ( fvar_head.version != (FT_Long)0x00010000L                      ||
 #if 0
            /* fonts like `JamRegular.ttf' have an incorrect value for */
            /* `countSizePairs'; since value 2 is hard-coded in `fvar' */
            /* version 1.0, we simply ignore it                        */
            fvar_head.countSizePairs != 2                                  ||
 #endif
            fvar_head.axisSize != 20                                       ||
            /* axisCount limit implied by 16-bit instanceSize */
            fvar_head.axisCount > 0x3FFE                                   ||
            fvar_head.instanceCount > 0x7EFF                               ||
            fvar_head.offsetToData + fvar_head.axisCount * 20U +
              fvar_head.instanceCount * fvar_head.instanceSize > table_len )
       {
         FT_TRACE1(( "\n"
                     "TT_Get_MM_Var: invalid `fvar' header\n" ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       if ( fvar_head.instanceSize == 4 + 4 * fvar_head.axisCount )
         usePsName = FALSE;
       else if ( fvar_head.instanceSize == 6 + 4 * fvar_head.axisCount )
         usePsName = TRUE;
       else
       {
         FT_TRACE1(( "\n"
                     "TT_Get_MM_Var: invalid `fvar' header\n" ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       FT_TRACE2(( "loaded\n" ));
 
       FT_TRACE5(( "number of GX style axes: %d\n", fvar_head.axisCount ));
 
       if ( FT_NEW( face->blend ) )
         goto Exit;
 
       /* cannot overflow 32-bit arithmetic because of limits above */
       face->blend->mmvar_len =
         sizeof ( FT_MM_Var ) +
         fvar_head.axisCount * sizeof ( FT_Var_Axis ) +
         fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +
         fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +
         5 * fvar_head.axisCount;
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       face->blend->mmvar = mmvar;
 
       /* set up pointers and offsets into the `mmvar' array; */
       /* the data gets filled in later on                    */
 
       mmvar->num_axis =
         fvar_head.axisCount;
       mmvar->num_designs =
         ~0U;                   /* meaningless in this context; each glyph */
                                /* may have a different number of designs  */
                                /* (or tuples, as called by Apple)         */
       mmvar->num_namedstyles =
         fvar_head.instanceCount;
       mmvar->axis =
         (FT_Var_Axis*)&( mmvar[1] );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&( mmvar->axis[fvar_head.axisCount] );
 
       next_coords =
         (FT_Fixed*)&( mmvar->namedstyle[fvar_head.instanceCount] );
       for ( i = 0; i < fvar_head.instanceCount; i++ )
       {
         mmvar->namedstyle[i].coords  = next_coords;
         next_coords                 += fvar_head.axisCount;
       }
 
       next_name = (FT_String*)next_coords;
       for ( i = 0; i < fvar_head.axisCount; i++ )
       {
         mmvar->axis[i].name  = next_name;
         next_name           += 5;
       }
 
       /* now fill in the data */
 
       if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )
         goto Exit;
 
       a = mmvar->axis;
       for ( i = 0; i < fvar_head.axisCount; i++ )
       {
         GX_FVar_Axis  axis_rec;
 
 
         if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )
           goto Exit;
         a->tag     = axis_rec.axisTag;
         a->minimum = axis_rec.minValue;
         a->def     = axis_rec.defaultValue;
         a->maximum = axis_rec.maxValue;
         a->strid   = axis_rec.nameID;
 
         a->name[0] = (FT_String)(   a->tag >> 24 );
         a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
         a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );
         a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );
         a->name[4] = '\0';
 
         FT_TRACE5(( "  \"%s\": minimum=%.4f, default=%.4f, maximum=%.4f\n",
                     a->name,
                     a->minimum / 65536.0,
                     a->def / 65536.0,
                     a->maximum / 65536.0 ));
 
         a++;
       }
 
       FT_TRACE5(( "\n" ));
 
       ns = mmvar->namedstyle;
       for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )
       {
         /* PostScript names add 2 bytes to the instance record size */
         if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +
                              4L * fvar_head.axisCount ) )
           goto Exit;
 
         ns->strid       =    FT_GET_USHORT();
         (void) /* flags = */ FT_GET_USHORT();
 
         for ( j = 0; j < fvar_head.axisCount; j++ )
           ns->coords[j] = FT_GET_LONG();
 
         if ( usePsName )
           ns->psid = FT_GET_USHORT();
 
         FT_FRAME_EXIT();
       }
     }
 
     /* fill the output array if requested */
 
     if ( master != NULL )
     {
       FT_UInt  n;
 
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );
 
       mmvar->axis =
         (FT_Var_Axis*)&( mmvar[1] );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)&( mmvar->axis[mmvar->num_axis] );
       next_coords =
         (FT_Fixed*)&( mmvar->namedstyle[mmvar->num_namedstyles] );
 
       for ( n = 0; n < mmvar->num_namedstyles; n++ )
       {
         mmvar->namedstyle[n].coords  = next_coords;
         next_coords                 += mmvar->num_axis;
       }
 
       a         = mmvar->axis;
       next_name = (FT_String*)next_coords;
       for ( n = 0; n < mmvar->num_axis; n++ )
       {
         a->name = next_name;
 
         /* standard PostScript names for some standard apple tags */
         if ( a->tag == TTAG_wght )
           a->name = (char*)"Weight";
         else if ( a->tag == TTAG_wdth )
           a->name = (char*)"Width";
         else if ( a->tag == TTAG_opsz )
           a->name = (char*)"OpticalSize";
         else if ( a->tag == TTAG_slnt )
           a->name = (char*)"Slant";
 
         next_name += 5;
         a++;
       }
 
       *master = mmvar;
     }
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_MM_Blend                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the blend (normalized) coordinates for this instance of the    */
   /*    font.  Check that the `gvar' table is reasonable and does some     */
   /*    initial preparation.                                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font.                                            */
   /*                  Initialize the blend structure with `gvar' data.     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, ignore the excess    */
   /*                  values.  If it is smaller than the number of axes,   */
   /*                  use the default value (0) for the remaining axes.    */
   /*                                                                       */
   /*    coords     :: An array of `num_coords', each between [-1,1].       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error    error = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
     FT_Bool     is_default_instance = 1;
     FT_Memory   memory = face->root.memory;
 
     enum
     {
       mcvt_retain,
       mcvt_modify,
       mcvt_load
 
     } manageCvt;
 
 
     face->doblend = FALSE;
 
     if ( face->blend == NULL )
     {
       if ( ( error = TT_Get_MM_Var( face, NULL ) ) != 0 )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_MM_Blend: only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     FT_TRACE5(( "normalized design coordinates:\n" ));
 
     for ( i = 0; i < num_coords; i++ )
     {
       FT_TRACE5(( "  %.4f\n", coords[i] / 65536.0 ));
       if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
       {
         FT_TRACE1(( "TT_Set_MM_Blend: normalized design coordinate %.4f\n"
                     "                 is out of range [-1;1]\n",
                     coords[i] / 65536.0 ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
 
       if ( coords[i] != 0 )
         is_default_instance = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
-    if ( blend->glyphoffsets == NULL )
+    if ( !face->isCFF2 && blend->glyphoffsets == NULL )
       if ( ( error = ft_var_load_gvar( face ) ) != 0 )
         goto Exit;
 
     if ( blend->normalizedcoords == NULL )
     {
       if ( FT_NEW_ARRAY( blend->normalizedcoords, mmvar->num_axis ) )
         goto Exit;
 
       manageCvt = mcvt_modify;
 
       /* If we have not set the blend coordinates before this, then the  */
       /* cvt table will still be what we read from the `cvt ' table and  */
       /* we don't need to reload it.  We may need to change it though... */
     }
     else
     {
       manageCvt = mcvt_retain;
 
       for ( i = 0; i < num_coords; i++ )
       {
         if ( blend->normalizedcoords[i] != coords[i] )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       for ( ; i < mmvar->num_axis; i++ )
       {
         if ( blend->normalizedcoords[i] != 0 )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       /* If we don't change the blend coords then we don't need to do  */
       /* anything to the cvt table.  It will be correct.  Otherwise we */
       /* no longer have the original cvt (it was modified when we set  */
       /* the blend last time), so we must reload and then modify it.   */
     }
 
     blend->num_axis = mmvar->num_axis;
     FT_MEM_COPY( blend->normalizedcoords,
                  coords,
                  num_coords * sizeof ( FT_Fixed ) );
 
     face->doblend = TRUE;
 
     if ( face->cvt != NULL )
     {
       switch ( manageCvt )
       {
       case mcvt_load:
         /* The cvt table has been loaded already; every time we change the */
         /* blend we may need to reload and remodify the cvt table.         */
         FT_FREE( face->cvt );
         face->cvt = NULL;
 
         error = tt_face_load_cvt( face, face->root.stream );
         break;
 
       case mcvt_modify:
         /* The original cvt table is in memory.  All we need to do is */
         /* apply the `cvar' table (if any).                           */
         error = tt_face_vary_cvt( face, face->root.stream );
         break;
 
       case mcvt_retain:
         /* The cvt table is correct for this set of coordinates. */
         break;
       }
     }
 
     face->is_default_instance = is_default_instance;
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Get_MM_Blend                                                    */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Get the blend (normalized) coordinates for this instance of the    */
   /*    font.                                                              */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font.                                            */
   /*                  Initialize the blend structure with `gvar' data.     */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, set the excess       */
   /*                  values to 0.                                         */
   /*                                                                       */
   /*    coords     :: An array of `num_coords', each between [-1,1].       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( face->blend == NULL )
     {
       if ( ( error = TT_Get_MM_Var( face, NULL ) ) != 0 )
         return error;
     }
 
     blend = face->blend;
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_MM_Blend: only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     for ( i = 0; i < nc; ++i )
       coords[i] = blend->normalizedcoords[i];
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Set_Var_Design                                                  */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Set the coordinates for the instance, measured in the user         */
   /*    coordinate system.  Parse the `avar' table (if present) to convert */
   /*    from user to normalized coordinates.                               */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face       :: The font face.                                       */
   /*                  Initialize the blend struct with `gvar' data.        */
   /*                                                                       */
   /* <Input>                                                               */
   /*    num_coords :: The number of available coordinates.  If it is       */
   /*                  larger than the number of axes, ignore the excess    */
   /*                  values.  If it is smaller than the number of axes,   */
   /*                  use the default values for the remaining axes.       */
   /*                                                                       */
   /*    coords     :: A coordinate array with `num_coords' elements.       */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error        error      = FT_Err_Ok;
     FT_Fixed*       normalized = NULL;
     GX_Blend        blend;
     FT_MM_Var*      mmvar;
     FT_UInt         i, j;
     FT_Var_Axis*    a;
     GX_AVarSegment  av;
     FT_Memory       memory = face->root.memory;
 
 
     if ( face->blend == NULL )
     {
       if ( ( error = TT_Get_MM_Var( face, NULL ) ) != 0 )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     /* Axis normalization is a two stage process.  First we normalize */
     /* based on the [min,def,max] values for the axis to be [-1,0,1]. */
     /* Then, if there's an `avar' table, we renormalize this range.   */
 
     if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )
       goto Exit;
 
     FT_TRACE5(( "design coordinates:\n" ));
 
     a = mmvar->axis;
     for ( i = 0; i < num_coords; i++, a++ )
     {
       FT_Fixed  coord = coords[i];
 
 
       FT_TRACE5(( "  %.4f\n", coord / 65536.0 ));
       if ( coord > a->maximum || coord < a->minimum )
       {
         FT_TRACE1((
           "TT_Set_Var_Design: normalized design coordinate %.4f\n"
           "                   is out of range [%.4f;%.4f]; clamping\n",
           coord / 65536.0,
           a->minimum / 65536.0,
           a->maximum / 65536.0 ));
 
         if ( coord > a->maximum)
           coord = a->maximum;
         else
           coord = a->minimum;
       }
 
       if ( coord < a->def )
         normalized[i] = -FT_DivFix( coords[i] - a->def,
                                     a->minimum - a->def );
       else if ( coord > a->def )
         normalized[i] = FT_DivFix( coords[i] - a->def,
                                    a->maximum - a->def );
       else
         normalized[i] = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( ; i < mmvar->num_axis; i++ )
       normalized[i] = 0;
 
     if ( !blend->avar_checked )
       ft_var_load_avar( face );
 
     if ( blend->avar_segment != NULL )
     {
       FT_TRACE5(( "normalized design coordinates"
                   " before applying `avar' data:\n" ));
 
       av = blend->avar_segment;
       for ( i = 0; i < mmvar->num_axis; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           FT_TRACE5(( "  %.4f\n", normalized[i] / 65536.0 ));
           if ( normalized[i] < av->correspondence[j].fromCoord )
           {
             normalized[i] =
               FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord ) +
               av->correspondence[j - 1].toCoord;
             break;
           }
         }
       }
     }
 
     error = TT_Set_MM_Blend( face, mmvar->num_axis, normalized );
 
   Exit:
     FT_FREE( normalized );
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   TT_Get_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_UNUSED( face );
     FT_UNUSED( num_coords );
     FT_UNUSED( coords );
 
     /* TODO: Implement this function. */
     return FT_THROW( Unimplemented_Feature );
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                     GX VAR PARSING ROUTINES                   *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_face_vary_cvt                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Modify the loaded cvt table according to the `cvar' table and the  */
   /*    font's blend.                                                      */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    face   :: A handle to the target face object.                      */
   /*                                                                       */
   /* <Input>                                                               */
   /*    stream :: A handle to the input stream.                            */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   /*    Most errors are ignored.  It is perfectly valid not to have a      */
   /*    `cvar' table even if there is a `gvar' and `fvar' table.           */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_face_vary_cvt( TT_Face    face,
                     FT_Stream  stream )
   {
     FT_Error    error;
     FT_Memory   memory = stream->memory;
     FT_ULong    table_start;
     FT_ULong    table_len;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     GX_Blend    blend           = face->blend;
     FT_UInt     point_count;
     FT_UShort*  localpoints;
     FT_Short*   deltas;
 
 
     FT_TRACE2(( "CVAR " ));
 
     if ( blend == NULL )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no blend specified\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( face->cvt == NULL )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no `cvt ' table\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     error = face->goto_table( face, TTAG_cvar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
 
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
     {
       error = FT_Err_Ok;
       goto Exit;
     }
 
     table_start = FT_Stream_FTell( stream );
     if ( FT_GET_LONG() != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
 
       error = FT_Err_Ok;
       goto FExit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto FExit;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + tupleCount * 4 > table_len )
     {
       FT_TRACE2(( "tt_face_vary_cvt:"
                   " invalid CVT variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto FExit;
     }
 
     offsetToData += table_start;
 
     /* The documentation implies there are flags packed into              */
     /* `tupleCount', but John Jenkins says that shared points don't apply */
     /* to `cvar', and no other flags are defined.                         */
 
     FT_TRACE5(( "cvar: there are %d tuples:\n", tupleCount & 0xFFF ));
 
     for ( i = 0; i < ( tupleCount & 0xFFF ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       /* There is no provision here for a global tuple coordinate section, */
       /* so John says.  There are no tuple indices, just embedded tuples.  */
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;  /* convert from        */
                                                  /* short frac to fixed */
       }
       else
       {
         /* skip this tuple; it makes no sense */
 
         if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
           for ( j = 0; j < 2 * blend->num_axis; j++ )
             (void)FT_GET_SHORT();
 
         offsetToData += tupleDataSize;
         continue;
       }
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
       if ( /* tuple isn't active for our blend */
            apply == 0                                    ||
            /* global points not allowed,           */
            /* if they aren't local, makes no sense */
            !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       localpoints = ft_var_readpackedpoints( stream,
                                              table_len,
                                              &point_count );
       deltas      = ft_var_readpackeddeltas( stream,
                                              table_len,
                                              point_count == 0 ? face->cvt_size
                                                               : point_count );
       if ( localpoints == NULL || deltas == NULL )
         ; /* failure, ignore it */
 
       else if ( localpoints == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         /* this means that there are deltas for every entry in cvt */
         for ( j = 0; j < face->cvt_size; j++ )
         {
           FT_Long  orig_cvt = face->cvt[j];
 
 
           face->cvt[j] = (FT_Short)( orig_cvt +
                                      FT_MulFix( deltas[j], apply ) );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( orig_cvt != face->cvt[j] )
           {
             FT_TRACE7(( "      %d: %d -> %d\n",
                         j, orig_cvt, face->cvt[j] ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         for ( j = 0; j < point_count; j++ )
         {
           int      pindex;
           FT_Long  orig_cvt;
 
 
           pindex = localpoints[j];
           if ( (FT_ULong)pindex >= face->cvt_size )
             continue;
 
           orig_cvt          = face->cvt[pindex];
           face->cvt[pindex] = (FT_Short)( orig_cvt +
                                           FT_MulFix( deltas[j], apply ) );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( orig_cvt != face->cvt[pindex] )
           {
             FT_TRACE7(( "      %d: %d -> %d\n",
                         pindex, orig_cvt, face->cvt[pindex] ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
   FExit:
     FT_FRAME_EXIT();
 
   Exit:
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     return error;
   }
 
 
   /* Shift the original coordinates of all points between indices `p1' */
   /* and `p2', using the same difference as given by index `ref'.      */
 
   /* modeled after `af_iup_shift' */
 
   static void
   tt_delta_shift( int         p1,
                   int         p2,
                   int         ref,
                   FT_Vector*  in_points,
                   FT_Vector*  out_points )
   {
     int        p;
     FT_Vector  delta;
 
 
     delta.x = out_points[ref].x - in_points[ref].x;
     delta.y = out_points[ref].y - in_points[ref].y;
 
     if ( delta.x == 0 && delta.y == 0 )
       return;
 
     for ( p = p1; p < ref; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
 
     for ( p = ref + 1; p <= p2; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
   }
 
 
   /* Interpolate the original coordinates of all points with indices */
   /* between `p1' and `p2', using `ref1' and `ref2' as the reference */
   /* point indices.                                                  */
 
   /* modeled after `af_iup_interp', `_iup_worker_interpolate', and */
   /* `Ins_IUP'                                                     */
 
   static void
   tt_delta_interpolate( int         p1,
                         int         p2,
                         int         ref1,
                         int         ref2,
                         FT_Vector*  in_points,
                         FT_Vector*  out_points )
   {
     int  p, i;
 
     FT_Pos  out, in1, in2, out1, out2, d1, d2;
 
 
     if ( p1 > p2 )
       return;
 
     /* handle both horizontal and vertical coordinates */
     for ( i = 0; i <= 1; i++ )
     {
       /* shift array pointers so that we can access `foo.y' as `foo.x' */
       in_points  = (FT_Vector*)( (FT_Pos*)in_points + i );
       out_points = (FT_Vector*)( (FT_Pos*)out_points + i );
 
       if ( in_points[ref1].x > in_points[ref2].x )
       {
         p    = ref1;
         ref1 = ref2;
         ref2 = p;
       }
 
       in1  = in_points[ref1].x;
       in2  = in_points[ref2].x;
       out1 = out_points[ref1].x;
       out2 = out_points[ref2].x;
       d1   = out1 - in1;
       d2   = out2 - in2;
 
       if ( out1 == out2 || in1 == in2 )
       {
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1;
 
           out_points[p].x = out;
         }
       }
       else
       {
         FT_Fixed  scale = FT_DivFix( out2 - out1, in2 - in1 );
 
 
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1 + FT_MulFix( out - in1, scale );
 
           out_points[p].x = out;
         }
       }
     }
   }
 
 
   /* Interpolate points without delta values, similar to */
   /* the `IUP' hinting instruction.                      */
 
   /* modeled after `Ins_IUP */
 
   static void
   tt_interpolate_deltas( FT_Outline*  outline,
                          FT_Vector*   out_points,
                          FT_Vector*   in_points,
                          FT_Bool*     has_delta )
   {
     FT_Int  first_point;
     FT_Int  end_point;
 
     FT_Int  first_delta;
     FT_Int  cur_delta;
 
     FT_Int    point;
     FT_Short  contour;
 
 
     /* ignore empty outlines */
     if ( !outline->n_contours )
       return;
 
     contour = 0;
     point   = 0;
 
     do
     {
       end_point   = outline->contours[contour];
       first_point = point;
 
       /* search first point that has a delta */
       while ( point <= end_point && !has_delta[point] )
         point++;
 
       if ( point <= end_point )
       {
         first_delta = point;
         cur_delta   = point;
 
         point++;
 
         while ( point <= end_point )
         {
           /* search next point that has a delta  */
           /* and interpolate intermediate points */
           if ( has_delta[point] )
           {
             tt_delta_interpolate( cur_delta + 1,
                                   point - 1,
                                   cur_delta,
                                   point,
                                   in_points,
                                   out_points );
             cur_delta = point;
           }
 
           point++;
         }
 
         /* shift contour if we only have a single delta */
         if ( cur_delta == first_delta )
           tt_delta_shift( first_point,
                           end_point,
                           cur_delta,
                           in_points,
                           out_points );
         else
         {
           /* otherwise handle remaining points       */
           /* at the end and beginning of the contour */
           tt_delta_interpolate( cur_delta + 1,
                                 end_point,
                                 cur_delta,
                                 first_delta,
                                 in_points,
                                 out_points );
 
           if ( first_delta > 0 )
             tt_delta_interpolate( first_point,
                                   first_delta - 1,
                                   cur_delta,
                                   first_delta,
                                   in_points,
                                   out_points );
         }
       }
       contour++;
 
     } while ( contour < outline->n_contours );
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    TT_Vary_Apply_Glyph_Deltas                                         */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Apply the appropriate deltas to the current glyph.                 */
   /*                                                                       */
   /* <Input>                                                               */
   /*    face        :: A handle to the target face object.                 */
   /*                                                                       */
   /*    glyph_index :: The index of the glyph being modified.              */
   /*                                                                       */
   /*    n_points    :: The number of the points in the glyph, including    */
   /*                   phantom points.                                     */
   /*                                                                       */
   /* <InOut>                                                               */
   /*    outline     :: The outline to change.                              */
   /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                               FT_UInt      glyph_index,
                               FT_Outline*  outline,
                               FT_UInt      n_points )
   {
     FT_Stream   stream = face->root.stream;
     FT_Memory   memory = stream->memory;
     GX_Blend    blend  = face->blend;
 
     FT_Vector*  points_org = NULL;
     FT_Vector*  points_out = NULL;
     FT_Bool*    has_delta  = NULL;
 
     FT_Error    error;
     FT_ULong    glyph_start;
     FT_UInt     tupleCount;
     FT_ULong    offsetToData;
     FT_ULong    here;
     FT_UInt     i, j;
     FT_Fixed*   tuple_coords    = NULL;
     FT_Fixed*   im_start_coords = NULL;
     FT_Fixed*   im_end_coords   = NULL;
     FT_UInt     point_count, spoint_count = 0;
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
     FT_Short    *deltas_x, *deltas_y;
 
 
     if ( !face->doblend || blend == NULL )
       return FT_THROW( Invalid_Argument );
 
     if ( glyph_index >= blend->gv_glyphcnt      ||
          blend->glyphoffsets[glyph_index] ==
            blend->glyphoffsets[glyph_index + 1] )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " no variation data for this glyph\n" ));
       return FT_Err_Ok;
     }
 
     if ( FT_NEW_ARRAY( points_org, n_points ) ||
          FT_NEW_ARRAY( points_out, n_points ) ||
          FT_NEW_ARRAY( has_delta, n_points )  )
       goto Fail1;
 
     if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] )   ||
          FT_FRAME_ENTER( blend->glyphoffsets[glyph_index + 1] -
                            blend->glyphoffsets[glyph_index] ) )
       goto Fail1;
 
     glyph_start = FT_Stream_FTell( stream );
 
     /* each set of glyph variation data is formatted similarly to `cvar' */
     /* (except we get shared points and global tuples)                   */
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto Fail2;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            blend->gvar_size )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " invalid glyph variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto Fail2;
     }
 
     offsetToData += glyph_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               blend->gvar_size,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "gvar: there are %d tuples:\n",
                 tupleCount & GX_TC_TUPLE_COUNT_MASK ));
 
     for ( j = 0; j < n_points; j++ )
       points_org[j] = outline->points[j];
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_GET_SHORT() * 4;   /* convert from        */
                                                   /* short frac to fixed */
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto Fail2;
       }
       else
         FT_MEM_COPY(
           tuple_coords,
           &blend->tuplecoords[( tupleIndex & 0xFFF ) * blend->num_axis],
           blend->num_axis * sizeof ( FT_Fixed ) );
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_GET_SHORT() * 4;
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_GET_SHORT() * 4;
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                blend->gvar_size,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas_x = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
       deltas_y = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
 
       if ( points == NULL || deltas_y == NULL || deltas_x == NULL )
         ; /* failure, ignore it */
 
       else if ( points == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         /* this means that there are deltas for every point in the glyph */
         for ( j = 0; j < n_points; j++ )
         {
           FT_Pos  delta_x = FT_MulFix( deltas_x[j], apply );
           FT_Pos  delta_y = FT_MulFix( deltas_y[j], apply );
 
 
           /* Experimental fix for double adjustment of advance width: */
           /* adjust phantom point 2 only if there's no HVAR.          */
           /*                                                          */
           /* TODO: handle LSB (pp1) and VVAR (pp3, pp4) too           */
           if ( j != ( n_points - 3 ) || blend->hvar_checked == FALSE )
             outline->points[j].x += delta_x;
 
           outline->points[j].y += delta_y;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( delta_x || delta_y )
           {
             FT_TRACE7(( "      %d: (%d, %d) -> (%d, %d)\n",
                         j,
                         outline->points[j].x - delta_x,
                         outline->points[j].y - delta_y,
                         outline->points[j].x,
                         outline->points[j].y ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         /* we have to interpolate the missing deltas similar to the */
         /* IUP bytecode instruction                                 */
         for ( j = 0; j < n_points; j++ )
         {
           has_delta[j]  = FALSE;
           points_out[j] = points_org[j];
         }
 
         for ( j = 0; j < point_count; j++ )
         {
           FT_UShort  idx = points[j];
 
 
           if ( idx >= n_points )
             continue;
 
           has_delta[idx] = TRUE;
 
           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
         }
 
         /* no need to handle phantom points here,      */
         /* since solitary points can't be interpolated */
         tt_interpolate_deltas( outline,
                                points_out,
                                points_org,
                                has_delta );
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         for ( j = 0; j < n_points; j++ )
         {
           FT_Pos  delta_x = points_out[j].x - points_org[j].x;
           FT_Pos  delta_y = points_out[j].y - points_org[j].y;
 
 
           outline->points[j].x += delta_x;
           outline->points[j].y += delta_y;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( delta_x || delta_y )
           {
             FT_TRACE7(( "      %d: (%d, %d) -> (%d, %d)\n",
                         j,
                         outline->points[j].x - delta_x,
                         outline->points[j].y - delta_y,
                         outline->points[j].x,
                         outline->points[j].y ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas_x );
       FT_FREE( deltas_y );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
   Fail2:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     FT_FRAME_EXIT();
 
   Fail1:
     FT_FREE( points_org );
     FT_FREE( points_out );
     FT_FREE( has_delta );
 
     return error;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_get_var_blend                                                   */
   /*                                                                       */
   /* <Description>                                                         */
   /*    An internal version of `TT_Get_MM_Blend' that just returns         */
   /*    pointers instead of copying data, without any initialization of    */
   /*    the MM machinery in case it isn't loaded yet.                      */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   tt_get_var_blend( TT_Face     face,
                     FT_UInt    *num_coords,
                     FT_Fixed*  *coords )
   {
     if ( face->blend )
     {
       *num_coords = face->blend->num_axis;
       *coords     = face->blend->normalizedcoords;
     }
     else
     {
       *num_coords = 0;
       *coords     = NULL;
     }
 
     return FT_Err_Ok;
   }
 
 
   /*************************************************************************/
   /*                                                                       */
   /* <Function>                                                            */
   /*    tt_done_blend                                                      */
   /*                                                                       */
   /* <Description>                                                         */
   /*    Free the blend internal data structure.                            */
   /*                                                                       */
   FT_LOCAL_DEF( void )
   tt_done_blend( TT_Face  face )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     GX_Blend   blend  = face->blend;
 
 
     if ( blend != NULL )
     {
       FT_UInt  i, num_axes;
 
 
       /* blend->num_axis might not be set up yet */
       num_axes = blend->mmvar->num_axis;
 
       FT_FREE( blend->normalizedcoords );
       FT_FREE( blend->mmvar );
 
       if ( blend->avar_segment != NULL )
       {
         for ( i = 0; i < num_axes; i++ )
           FT_FREE( blend->avar_segment[i].correspondence );
         FT_FREE( blend->avar_segment );
       }
 
       if ( blend->hvar_table != NULL )
       {
         if ( blend->hvar_table->itemStore.varData )
         {
           for ( i = 0; i < blend->hvar_table->itemStore.dataCount; i++ )
           {
             FT_FREE( blend->hvar_table->itemStore.varData[i].regionIndices );
             FT_FREE( blend->hvar_table->itemStore.varData[i].deltaSet );
           }
           FT_FREE( blend->hvar_table->itemStore.varData );
         }
 
         if ( blend->hvar_table->itemStore.varRegionList )
         {
           for ( i = 0; i < blend->hvar_table->itemStore.regionCount; i++ )
             FT_FREE( blend->hvar_table->itemStore.varRegionList[i].axisList );
           FT_FREE( blend->hvar_table->itemStore.varRegionList );
         }
 
         FT_FREE( blend->hvar_table->widthMap.innerIndex );
         FT_FREE( blend->hvar_table->widthMap.outerIndex );
         FT_FREE( blend->hvar_table );
       }
 
       FT_FREE( blend->tuplecoords );
       FT_FREE( blend->glyphoffsets );
       FT_FREE( blend );
     }
   }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
 /* END */
