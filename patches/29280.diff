commit c473b21cff5e1a459b4467f18bf7414114f848fd
Author: Francesc Alted <francesc@blosc.org>
Date:   Tue Jan 19 13:20:31 2021 +0100

    Zero runlen (#195)
    
    * Support for zero detection run-lenghts in whole chunks is complete
    
    * Add a new blosc2_chunk_zeros()
    
    * Offsets are now stored as 128-bit values
    
    * Fix a bug in little-endian writes to frames
    
    * Revert back to 64-bit offsets
    
    * Do not free the chunk when appending in frames, as it is not necessary
    
    * Add a new version for frame format, fixing endianness of counters.
    
    * Entire chunks that are a zero run-length are encoded in offsets now
    
    * Implement support for zero runlens in blosc_getitem
    
    * Go back to use default codec for offsets in frame
    
    * Support for runlen NANs
    
    * Blosc1 backward (but not forward!) compatibility is tested now:
    
    * Ability to generate Blosc1 headers with the envvar BLOSC_BLOSC1_COMPAT.
    * Make sure that we can read chunks from Blosc1.
    * Bonus: Support for optimized repeated values (new `blosc2_chunk_repeatval()`).
    
    * Add the math lib
    
    * Undo the previous attempt to include math lib
    
    * Properly add math lib
    
    * Fix *some* warnings discovered by MSVC
    
    * Improve tests on Blosc1 compat.  Fix some Win errors.
    
    * Fix some Win errors.
    
    * Do not run blosc1_compat on win
    
    * Fix more MSVC warnings
    
    * Add Aleix's cutest.h testing framework
    
    * Do not attempt to run tests that require more than 4 GB on 32-bit platforms
    
    * Reduce memory footprint of the test suite
    
    * Continue the quest towards warning-free on MSVC
    
    * Do a free of the chunk when appending in a frame
    
    * Fix some leaks
    
    * Increase the range for chunk offsets
    
    * Documented the special values for the offsets in a frame
    
    * Better comments
    
    * A more complete check of special values
    
    * Add previously removed example
    
    * Update chunk format docs.
    
    * Don't be unnecessaily explicit
    
    * Small improvements in API docs
    
    * Rewrite special value condition
    
    * Use 4 threads when compressing offsets chunk
    
    * Fix the bench for zero detection
    
    * WIP: Support for 0-runlen in update/insert
    
    * Support for 0-runlen in update/insert
    
    * Add zero_runlen test
    
    Co-authored-by: Aleix Alcacer <aleixalcacer@gmail.com>

diff --git a/README_CHUNK_FORMAT.rst b/README_CHUNK_FORMAT.rst
index 926a386f..63abb662 100644
--- a/README_CHUNK_FORMAT.rst
+++ b/README_CHUNK_FORMAT.rst
@@ -30,111 +30,122 @@ Starting in Blosc 2.0.0, there is an extension of the header above that allows
 for encoding blocks with a filter pipeline::
 
   1+|-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|
     |     filter codes      |   ^   |     filter meta       | ^ | ^ |
                                 |                             |   |
                                 +-reserved                    |   +-blosc2_flags
                                                               +-reserved
 
 :version:
     (``uint8``) Blosc format version.
 
 :versionlz:
     (``uint8``) Version of the *format* of the internal compressor used (normally always 1).
 
 :flags and compressor enumeration:
     (``bitfield``) The flags of the buffer
 
     :bit 0 (``0x01``):
         Whether the byte-shuffle filter has been applied or not.
     :bit 1 (``0x02``):
         Whether the internal buffer is a pure memcpy or not.
     :bit 2 (``0x04``):
         Whether the bit-shuffle filter has been applied or not.
     :bit 3 (``0x08``):
         Whether the delta codec has been applied or not.
     :bit 4 (``0x10``):
         If set, blocks are *not* split into multiple compressed data streams.
     :bit 5 (``0x20``):
         Part of the enumeration for compressors.
     :bit 6 (``0x40``):
         Part of the enumeration for compressors.
     :bit 7 (``0x80``):
         Part of the enumeration for compressors.
 
     Note:: If both bit 0 and bit 2 are both set, that means that an
         extended header (see above) is used.
 
     The last three bits form an enumeration that allows for the use of alternative compressors.
 
     :``0``:
         ``blosclz``
     :``1``:
         ``lz4`` or ``lz4hc``
     :``2``:
         ``snappy``
     :``3``:
         ``zlib``
     :``4``:
         ``zstd``
     :``5``:
         ``lizard``
     :``6``:
         Reserved
     :``7``:
         The compressor is defined in the super-chunk.
 
 :typesize:
     (``uint8``) Number of bytes for the atomic type.
 
 :nbytes:
     (``int32``) Uncompressed size of the buffer (this header is not included).
 
 :blocksize:
     (``int32``) Size of internal blocks.
 
 :cbytes:
     (``int32``) Compressed size of the buffer (including this header).
 
 :filter_codes:
     (``uint8``) Filter code.
 
     :``0``:
         No shuffle (for compatibility with Blosc1).
     :``0``:
         No filter.
     :``1``:
         Byte-wise shuffle.
     :``2``:
         Bit-wise shuffle.
     :``3``:
         Delta filter.
     :``4``:
         Truncate precision filter.
 
     The filter pipeline has 6 reserved slots for the filters. They are applied sequentially to the chunk according
     to their index in increasing order. The type of filter applied is specified by the `filter_code`. Each
     `filter_code` has an associated field in `filter_meta` that can contain metadata about the filter.
 
 :filter_meta:
     (``uint8``) Filter metadata.
 
     Possible metadata associated with a filter code.
 
 :blosc2_flags:
     (``bitfield``) The flags for a Blosc2 buffer.
 
     :bit 0 (``0x01``):
         Whether the codec uses dictionaries or not.
     :bit 1 (``0x02``):
         Whether the header is extended with +32 bytes coming right after this byte.
     :bit 2 (``0x04``):
         Whether the codec is stored in a byte previous to this compressed buffer
         or it is in the global `flags` for chunk.
     :bit 3 (``0x08``):
         Whether the chunk is 'lazy' or not.  A lazy chunk has the header and bstarts
         in place, but not the actual block data.  In addition, they have an additional
         trailer for making it easy to read the data blocks.  In general, lazy chunks
         appear when reading data from disk.
+    :bits 4 and 5:
+        Indicate run-lengths for the entire chunk.
+
+            :``0``:
+                No run.
+            :``1``:
+                A run of zeros.
+            :``2``:
+                A run of NaN (Not-a-Number) floats (whether f32 or f64 depends on typesize).
+            :``3``:
+                Run-length of a value that follows the header (i.e. no blocks section).
 
 
 Blocks
@@ -190,23 +201,16 @@ If negative, the stream is stored like this::
 where `uint8_t token` is a byte for providing different meanings to `int32 csize`:
 
 :token:
     (``bitfield``) Flags for different meanings.
 
     :bits 0 and 1:
-        Indicates a run-length stream for the whole chunk.
-        For more info, see the **Run-Length Encoding** section below.
-
-            :``0``:
-                No run.
-            :``1``:
-                Zero value.
-            :``2``:
-                NaN (Not-a-Number) float value.
-            :``3``:
-                Run-length of a value that follows the header (i.e. no blocks section).
+        Reserved for future use.
 
     :bits 2 and 3:
-        Reserved for two-codes in a row. TODO: complete description
+        Reserved for two-codecs in a row. TODO: complete description
+
+    :bits 4, 5 and 6:
+        Reserved for secondary codec. TODO: complete description
 
 If bit 4 of the `flags` header field is set, each block is stored in a single data stream::
 
@@ -227,20 +231,6 @@ If bit 4 of the `flags` header is *not* set, each block can be stored using mult
 The uncompressed size for each block is equivalent to the `blocksize` field in the header, with the exception
 of the last block which may be equal to or less than the `blocksize`.
 
-**Run-Length Encoding**
-
-*Only for C-Blosc2*
-
-The `csize` field of each compressed data stream can be used to support run-length encoding for blocks as follows:
-
-    - When the most significant bit is *not* set, `csize` represents the size of the compressed
-      data stream that follows. (as in C-Blosc1)
-    - When the most significant bit is set, the least significant byte of `csize` is used to fill the entire
-      block.
-
-For example, a csize of 10000 means that the compressed data stream that follows is 10000 bytes long
-and a csize of -32 means that the whole block is made of bytes with a value of 32.
-
 Trailer
 -------
 
diff --git a/README_FRAME_FORMAT.rst b/README_FRAME_FORMAT.rst
index a47bc617..c506306a 100644
--- a/README_FRAME_FORMAT.rst
+++ b/README_FRAME_FORMAT.rst
@@ -17,7 +17,7 @@ Each of the three parts of the frame are variable length; with the header and tr
 
 
 Header
-------------------
+------
 
 The header contains information needed to decompress the Blosc chunks contained in the frame. It is encoded using
 `msgpack <https://msgpack.org>`_ and the format is as follows::
@@ -76,84 +76,84 @@ frame. It is up to the user to store whatever data they want with the only (stro
 using the msgpack format. Here is the format for the *metalayers*::
 
   |-52|-53|-54|-55|-56|-----------------------
   | 93| cd| idx   | de| map_of_metalayers
   |---|---------------|-----------------------
     ^   ^    ^      ^
     |   |    |      |
     |   |    |      +--[msgpack] map of name/offset pairs
     |   |    +--size of the map
     |   +--[msgpack] uint16
     +-- [msgpack] fixarray with 3 elements
 
 :header_size:
     (``int32``) Size of the header of the frame (including metalayers).
 
 :frame_size:
     (``uint64``) Size of the whole frame (including compressed data).
 
 :general_flags:
     (``uint8``) General flags.
 
     :``0`` to ``3``:
         Format version.
     :``4`` and ``5``:
         Enumerated for chunk offsets.
-        
+
         :``0``:
-            16-bit
-        :``1``:
             32-bit
-        :``2``:
+        :``1``:
             64-bit
+        :``2``:
+            128-bit
         :``3``:
-            Reserved
+            256-bit
     :``6``:
         Chunks of fixed length (0) or variable length (1)
     :``7``:
         Reserved
 
 :codec_flags:
     (``uint8``) Compressor enumeration (defaults for all the chunks in storage).
 
     :``0`` to ``3``:
         Enumerated for codecs (up to 16).
         
         :``0``:
             ``blosclz``
         :``1``:
             ``lz4`` or ``lz4hc``
         :``2``:
             ``snappy``
         :``3``:
             ``zlib``
         :``4``:
             ``zstd``
         :``5``:
             ``lizard``
     :``4`` to ``7``: Compression level (up to 16)
 
 :reserved_flags:
     (``uint8``) Space reserved.
 
 :uncompressed_size:
     (``int64``) Size of uncompressed data in frame (excluding metadata).
 
 :compressed_size:
     (``int64``) Size of compressed data in frame (excluding metadata).
 
 :type_size:
     (``int32``) Size of each item.
 
 :chunk_size:
     (``int32``) Size of each data chunk.  0 if not a fixed chunksize.
 
 :tcomp:
     (``int16``) Number of threads for compression.  If 0, same than `cctx`.
 
 :tdecomp:
     (``int16``) Number of threads for decompression.  If 0, same than `dctx`.
 
 :map of metalayers:
     This is a *msgpack-formattted* map for the different metalayers.  The keys will be a string (0xa0 + namelen) for
     the names of the metalayers, followed by an int32 (0xd2) for the *offset* of the value of this metalayer.  The
     actual value will be encoded as a bin32 (0xc6) value later in frame.
@@ -171,9 +171,42 @@ Each chunk is stored sequentially and follows the format described in the
 `chunk format <README_CHUNK_FORMAT.rst>`_ document.
 
 The `chunk idx` is a Blosc chunk containing the indexes to each chunk in this section.  The data in the
-chunk is a list of (16-bit, 32-bit or 64-bit, see above) offsets to each chunk. The index chunk follows
+chunk is a list of (32-bit, 64-bit or more, see above) offsets to each chunk. The index chunk follows
 the regular Blosc chunk format and can be compressed.
 
+**Note:** The offsets can take *special values* so as to represent chunks with run-length (equal) values.
+The codification for the offsets is as follows::
+
+    +========+========+========+========+
+    | byte 0 | byte 1 |   ...  | byte N |
+    +========+========+========+========+
+                                   ^
+                                   |
+                                   +--> Byte for special values
+
+If the most significant bit (7) of the most significant byte above (byte N, as little endian is used) is set,
+that represents a chunk with a run-length of special values.  The supported special values are:
+
+:special_values:
+    (``uint8``) Flags for special values.
+
+        :``0``:
+            A run-length of zeros.
+        :``1``:
+            A run-length of NaNs. The size of the NaN depends on the typesize.
+        :``2``:
+            Reserved.
+        :``3``:
+            Reserved.
+        :``4``:
+            Reserved.
+        :``5``:
+            Reserved.
+        :``6``:
+            Reserved.
+        :``7``:
+            Indicates a special value.  If not set, a regular value.
+
 
 Trailer
 -------
diff --git a/RELEASE_NOTES.md b/RELEASE_NOTES.md
index b0ae8b83..3c859a48 100644
--- a/RELEASE_NOTES.md
+++ b/RELEASE_NOTES.md
@@ -5,11 +5,16 @@
 Changes from 2.0.0-beta.5 to 2.0.0.beta6
 ========================================
 
 * [API change] `blosc2_decompress_ctx()` gets a new `srcsize`
  parameter to ensure that it does not read past the end
  of the provided buffer.  See #144.  Thanks to Nathan Moinvaziri
  (@nmoinvaz).
 
+* [BREAKING CHANGE] The format for frames has changed and
+  BLOSC2_VERSION_FRAME_FORMAT is now set to 2.  There is no attempt to support
+  previous formats, but there will probably be backward compatibility support
+  starting from version 2 on.
+
 * Internal Zstd sources updated to 1.4.5.
 
 
diff --git a/bench/CMakeLists.txt b/bench/CMakeLists.txt
index f8357c1d..b43fc702 100644
--- a/bench/CMakeLists.txt
+++ b/bench/CMakeLists.txt
@@ -1,10 +1,10 @@
 # sources for main bench
 set(SOURCES b2bench.c)
-# sources for delta filter
+# other benchmarks
 set(SOURCES_DELTA delta_schunk.c)
-# sources for trunc_prec filter
 set(SOURCES_TRUNC_PREC trunc_prec_schunk.c)
 set(SOURCES_SUM_OPENMP sum_openmp.c)
+set(SOURCES_ZERO_RUNLEN zero_runlen.c)
 
 # targets
 set(BENCH_EXE b2bench)
@@ -12,6 +12,7 @@ add_executable(${BENCH_EXE} ${SOURCES})
 add_executable(delta_schunk ${SOURCES_DELTA})
 add_executable(trunc_prec_schunk ${SOURCES_TRUNC_PREC})
 add_executable(sum_openmp ${SOURCES_SUM_OPENMP})
+add_executable(zero_runlen ${SOURCES_ZERO_RUNLEN})
 if(UNIX AND NOT APPLE)
     # cmake is complaining about LINK_PRIVATE in original PR
     # and removing it does not seem to hurt, so be it.
@@ -16,10 +17,11 @@ if(UNIX AND NOT APPLE)
     # cmake is complaining about LINK_PRIVATE in original PR
     # and removing it does not seem to hurt, so be it.
     # target_link_libraries(${BENCH_EXE} LINK_PRIVATE rt)
     target_link_libraries(${BENCH_EXE} rt)
     target_link_libraries(delta_schunk rt)
     target_link_libraries(trunc_prec_schunk rt)
     target_link_libraries(sum_openmp rt)
+    target_link_libraries(zero_runlen rt)
 endif()
 if(UNIX)
     # Avoid a warning when using gcc without -fopenmp
@@ -29,6 +31,7 @@ target_link_libraries(${BENCH_EXE} blosc2_shared)
 target_link_libraries(delta_schunk blosc2_shared)
 target_link_libraries(trunc_prec_schunk blosc2_shared)
 target_link_libraries(sum_openmp blosc2_shared)
+target_link_libraries(zero_runlen blosc2_shared)
 
 
 # have to copy blosc dlls on Windows
@@ -164,4 +167,9 @@ if(BUILD_TESTS)
         add_test(test_bench_sum_openmp sum_openmp)
     endif()
 
+    option(TEST_INCLUDE_BENCH_ZERO_RUNLEN "Include zero_runlen in the tests" ON)
+    if(TEST_INCLUDE_BENCH_ZERO_RUNLEN)
+        add_test(test_bench_zero_runlen zero_runlen)
+    endif()
+
 endif()
diff --git a/bench/delta_schunk.c b/bench/delta_schunk.c
index 2074ef42..589dd1ed 100644
--- a/bench/delta_schunk.c
+++ b/bench/delta_schunk.c
@@ -1,26 +1,26 @@
 /*
   Copyright (C) 2015  Francesc Alted
   http://blosc.org
   License: BSD (see LICENSE.txt)
 
   Benchmark showing Blosc filter from C code.
 
   To compile this program:
 
   $ gcc -O3 delta_schunk.c -o delta_schunk -lblosc2
 
 */
 
 #include <stdio.h>
 #include <stdint.h>
 #include <assert.h>
 #include <blosc2.h>
 
 #define KB  1024
 #define MB  (1024*KB)
 #define GB  (1024*MB)
 
-#define CHUNKSIZE (5 * 1000 * 1000)
+#define CHUNKSIZE (50 * 1000)
 #define NCHUNKS 100
 // Setting NTHREADS > 1 increases the likelihood of a crash.  See #112.
 #define NTHREADS 1
@@ -29,89 +29,89 @@
 int main(void) {
   int32_t *data, *data_dest;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk *schunk;
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   int nchunk;
   int nchunks = 0;
   blosc_timestamp_t last, current;
   double totaltime;
   float totalsize = (float)(isize * NCHUNKS);
 
   data = malloc(CHUNKSIZE * sizeof(int32_t));
   data_dest = malloc(CHUNKSIZE * sizeof(int32_t));
   for (int i = 0; i < CHUNKSIZE; i++) {
     data[i] = i;
   }
 
   printf("Blosc version info: %s (%s)\n", BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.filters[0] = BLOSC_DELTA;
   //cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 1;
   cparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   /* Append chunks (the first will be taken as reference for delta) */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   printf("[Compr] Elapsed time:\t %6.3f s.  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   printf("Compression super-chunk: %ld -> %ld (%.1fx)\n",
          (long)nbytes, (long)cbytes, (1. * nbytes) / cbytes);
 
   /* Retrieve and decompress the chunks */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     assert (dsize == (int)isize);
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   totalsize = (float)(isize * nchunks);
   printf("[Decompr] Elapsed time:\t %6.3f s.  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   printf("Decompression successful!\n");
 
   for (int i = 0; i < CHUNKSIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original %d, %d, %d!\n",
              i, data[i], data_dest[i]);
       return -1;
     }
   }
 
   printf("Successful roundtrip!\n");
 
   /* Free resources */
   free(data);
   free(data_dest);
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return 0;
 }
diff --git a/bench/sum_openmp.c b/bench/sum_openmp.c
index 5dd01ec6..357502d6 100644
--- a/bench/sum_openmp.c
+++ b/bench/sum_openmp.c
@@ -74,170 +74,170 @@
 int main(void) {
   static DTYPE udata[N];
   DTYPE chunk_buf[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(DTYPE);
+  int32_t isize = CHUNKSIZE * sizeof(DTYPE);
   DTYPE sum, compressed_sum;
   int64_t nbytes, cbytes;
   blosc2_schunk* schunk;
   int i, j, nchunk;
   blosc_timestamp_t last, current;
   double ttotal, itotal;
   char* envvar = NULL;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   // Fill the buffer for a chunk
   if (SYNTHETIC) {
     for (j = 0; j < CHUNKSIZE; j++) {
       chunk_buf[j] = j;
     }
   }
   else {
     struct stat info;
     const char *filegrid = "rainfall-grid-150x150.bin";
     if (stat(filegrid, &info) != 0) {
       printf("Grid file %s not found!", filegrid);
       exit(1);
     }
     char *cdata = malloc(info.st_size);
 
     FILE *f = fopen(filegrid, "rb");
     size_t blocks_read = fread(cdata, info.st_size, 1, f);
     assert(blocks_read == 1);
     fclose(f);
 
     int dsize = blosc_getitem(cdata, 0, CHUNKSIZE, chunk_buf);
     if (dsize < 0) {
       printf("blosc_getitem() error.  Error code: %d\n.  Probaly reading too much data?", dsize);
       exit(1);
     }
     free(cdata);
   }
 
   // Fill the uncompressed dataset with data chunks
   for (i = 0; i < N / CHUNKSIZE; i++) {
     for (j = 0; j < CHUNKSIZE; j++) {
       udata[i * CHUNKSIZE + j] = chunk_buf[j];
     }
   }
 
   // Reduce uncompressed dataset
   ttotal = 1e10;
   sum = 0;
   for (int n = 0; n < NITER; n++) {
     sum = 0;
     blosc_set_timestamp(&last);
 #pragma omp parallel for reduction (+:sum)
     for (i = 0; i < N; i++) {
       sum += udata[i];
     }
     blosc_set_timestamp(&current);
     itotal = blosc_elapsed_secs(last, current);
     if (itotal < ttotal) ttotal = itotal;
   }
   printf("Sum for uncompressed data: %10.0f\n", (double)sum);
   printf("Sum time for uncompressed data: %.3g s, %.1f MB/s\n",
          ttotal, (double)(isize * NCHUNKS) / (double)(ttotal * MB));
 
   // Create a super-chunk container for the compressed container
   long codec = CODEC;
   envvar = getenv("SUM_COMPRESSOR");
   if (envvar != NULL) {
     codec = blosc_compname_to_compcode(envvar);
     if (codec < 0) {
       printf("Unknown compresssor: %s\n", envvar);
       return 1;
     }
   }
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.compcode = (uint8_t)codec;
 
   long clevel = CLEVEL;
   envvar = getenv("SUM_CLEVEL");
   if (envvar != NULL) {
     clevel = strtol(envvar, NULL, 10);
   }
   cparams.clevel = (uint8_t)clevel;
 
   cparams.typesize = sizeof(DTYPE);
   cparams.nthreads = 1;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = 1;
   blosc_set_timestamp(&last);
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       chunk_buf[i] = udata[i + nchunk * CHUNKSIZE];
     }
     blosc2_schunk_append_buffer(schunk, chunk_buf, isize);
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   int nthreads = NTHREADS;
   envvar = getenv("OMP_NUM_THREADS");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value >= 0)) {
       nthreads = (int)value;
     }
   }
   // Build buffers and contexts for computations
   int nchunks_thread = NCHUNKS / nthreads;
   int remaining_chunks = NCHUNKS - nchunks_thread * nthreads;
   blosc2_context **dctx = malloc(nthreads * sizeof(void*));
   DTYPE** chunk = malloc(nthreads * sizeof(void*));
   for (j = 0; j < nthreads; j++) {
     chunk[j] = malloc(CHUNKSIZE * sizeof(DTYPE));
   }
 
   // Reduce uncompressed dataset
   blosc_set_timestamp(&last);
   ttotal = 1e10;
   compressed_sum = 0;
   for (int n = 0; n < NITER; n++) {
     compressed_sum = 0;
     #pragma omp parallel for private(nchunk) reduction (+:compressed_sum)
     for (j = 0; j < nthreads; j++) {
       dctx[j] = blosc2_create_dctx(dparams);
       for (nchunk = 0; nchunk < nchunks_thread; nchunk++) {
         blosc2_decompress_ctx(dctx[j], schunk->data[j * nchunks_thread + nchunk], INT32_MAX, 
                               (void*)(chunk[j]), isize);
         for (i = 0; i < CHUNKSIZE; i++) {
           compressed_sum += chunk[j][i];
           //compressed_sum += i + (j * nchunks_thread + nchunk) * CHUNKSIZE;
         }
       }
     }
     for (nchunk = NCHUNKS - remaining_chunks; nchunk < NCHUNKS; nchunk++) {
       blosc2_decompress_ctx(dctx[0], schunk->data[nchunk], INT32_MAX, (void*)(chunk[0]), isize);
       for (i = 0; i < CHUNKSIZE; i++) {
         compressed_sum += chunk[0][i];
         //compressed_sum += i + nchunk * CHUNKSIZE;
       }
     }
     blosc_set_timestamp(&current);
     itotal = blosc_elapsed_secs(last, current);
     if (itotal < ttotal) ttotal = itotal;
   }
   printf("Sum for *compressed* data: %10.0f\n", (double)compressed_sum);
   printf("Sum time for *compressed* data: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
   //printf("sum, csum: %f, %f\n", sum, compressed_sum);
   if (SYNTHETIC) {
     // difficult to fulfill for single precision
     assert(sum == compressed_sum);
   }
   /* Free resources */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
diff --git a/bench/trunc_prec_schunk.c b/bench/trunc_prec_schunk.c
index 4625ef1c..68e3cbe9 100644
--- a/bench/trunc_prec_schunk.c
+++ b/bench/trunc_prec_schunk.c
@@ -40,102 +40,102 @@ void fill_buffer(double *buffer, int nchunk) {
 
 int main(void) {
   blosc2_schunk *schunk;
-  size_t isize = CHUNKSIZE * sizeof(double);
+  int32_t isize = CHUNKSIZE * sizeof(double);
   int dsize;
   int64_t nbytes, cbytes;
   int nchunk, nchunks = 0;
   blosc_timestamp_t last, current;
   double totaltime;
   float totalsize = (float)(isize * NCHUNKS);
   double *data_buffer = malloc(CHUNKSIZE * sizeof(double));
   double *rec_buffer = malloc(CHUNKSIZE * sizeof(double));
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.filters[0] = BLOSC_TRUNC_PREC;
   cparams.filters_meta[0] = 23;  // treat doubles as floats
   cparams.typesize = sizeof(double);
   // DELTA makes compression ratio quite worse in this case
   //cparams.filters[1] = BLOSC_DELTA;
   // BLOSC_BITSHUFFLE is not compressing better and it quite slower here
   //cparams.filters[BLOSC_LAST_FILTER - 1] = BLOSC_BITSHUFFLE;
   // Good codec params for this dataset
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .sequential=true};
   schunk = blosc2_schunk_new(storage);
 
   /* Append the chunks */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     fill_buffer(data_buffer, nchunk);
     nchunks = blosc2_schunk_append_buffer(schunk, data_buffer, isize);
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   printf("[Compr] Elapsed time:\t %6.3f s."
                  "  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   printf("Compression super-chunk: %ld -> %ld (%.1fx)\n",
          (long)nbytes, (long)cbytes, (1. * nbytes) / cbytes);
 
   /* Retrieve and decompress the chunks */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, rec_buffer, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     assert (dsize == (int)isize);
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   totalsize = (float)(isize * nchunks);
   printf("[Decompr] Elapsed time:\t %6.3f s."
                  "  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   /* Check that all the values are in the precision range */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) rec_buffer, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     assert (dsize == (int)isize);
     fill_buffer(data_buffer, nchunk);
     for (int i = 0; i < CHUNKSIZE; i++) {
       if (fabs(data_buffer[i] - rec_buffer[i]) > 1e-5) {
         printf("Value not in tolerance margin: ");
         printf("%g - %g: %g, (nchunk: %d, nelem: %d)\n",
                data_buffer[i], rec_buffer[i],
                (data_buffer[i] - rec_buffer[i]), nchunk, i);
         return -1;
       }
     }
   }
   printf("All data did a good roundtrip!\n");
 
   /* Free resources */
   free(data_buffer);
   free(rec_buffer);
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return 0;
 }
diff --git a/bench/zero_runlen.c b/bench/zero_runlen.c
new file mode 100644
index 00000000..33c48ee2
--- /dev/null
+++ b/bench/zero_runlen.c
@@ -0,0 +1,257 @@
+/*
+  Copyright (C) 2020  The Blosc Developers
+  http://blosc.org
+  License: BSD (see LICENSE.txt)
+
+  Benchmark showing Blosc zero detection capabilities via run-length.
+
+*/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <assert.h>
+#include <math.h>
+
+#include "blosc2.h"
+
+
+#define KB  1024
+#define MB  (1024*KB)
+#define GB  (1024*MB)
+
+#define NCHUNKS (2000)
+#define CHUNKSIZE (500 * 1000)  // > NCHUNKS for the bench purposes
+#define NTHREADS 4
+
+enum {
+  ZERO_DETECTION = 0,
+  CHECK_ZEROS = 1,
+  CHECK_NANS = 2,
+  CHECK_VALUES = 3,
+};
+#define REPEATED_VALUE 1
+
+
+int check_special_values(int svalue) {
+  blosc2_schunk *schunk;
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t osize = CHUNKSIZE * sizeof(int32_t) + BLOSC_MAX_OVERHEAD;
+  int dsize, csize;
+  int64_t nbytes, frame_len;
+  int nchunk, nchunks = 0;
+  int rc;
+  int32_t value = REPEATED_VALUE;
+  float fvalue;
+  blosc_timestamp_t last, current;
+  double totaltime;
+  double totalsize = (double)isize * NCHUNKS;
+  int32_t *data_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
+  int32_t *rec_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
+
+  printf("Blosc version info: %s (%s)\n",
+         BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
+
+  /* Initialize the Blosc compressor */
+  blosc_init();
+
+  /* Create a super-chunk container */
+  blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
+  cparams.typesize = sizeof(int32_t);
+  cparams.compcode = BLOSC_BLOSCLZ;
+  cparams.clevel = 9;
+  cparams.nthreads = NTHREADS;
+  blosc2_storage storage = {.cparams=&cparams, .sequential=true};
+  schunk = blosc2_schunk_new(storage);
+
+  /* Append the chunks */
+  blosc_set_timestamp(&last);
+  void* chunk = malloc(BLOSC_EXTENDED_HEADER_LENGTH + isize);
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    switch (svalue) {
+      case ZERO_DETECTION:
+        memset(data_buffer, 0, isize);
+        csize = blosc2_compress(5, 1, sizeof(int32_t), data_buffer, isize, chunk, osize);
+        break;
+      case CHECK_ZEROS:
+        csize = blosc2_chunk_zeros(isize, sizeof(int32_t), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
+        break;
+      case CHECK_NANS:
+        csize = blosc2_chunk_nans(isize, sizeof(float), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
+        break;
+      case CHECK_VALUES:
+        csize = blosc2_chunk_repeatval(isize, sizeof(int32_t), chunk,
+                                       BLOSC_EXTENDED_HEADER_LENGTH + sizeof(int32_t), &value);
+        break;
+      default:
+        printf("Unrecognized case");
+        exit(1);
+    }
+    if (csize < 0) {
+      printf("Error creating chunk: %d\n", csize);
+      exit(1);
+    }
+    nchunks = blosc2_schunk_append_chunk(schunk, chunk, true);
+    if (nchunks < 0) {
+      printf("Error appending chunk: %d\n", nchunks);
+      exit(1);
+    }
+  }
+
+  blosc_set_timestamp(&current);
+  free(chunk);
+  totaltime = blosc_elapsed_secs(last, current);
+  printf("[Compr] Elapsed time:\t %6.3f s."
+                 "  Processed data: %.3f GB (%.3f GB/s)\n",
+         totaltime, totalsize / GB, totalsize / (GB * totaltime));
+
+  /* Gather some info */
+  nbytes = schunk->nbytes;
+  frame_len = schunk->frame->len;
+  printf("Compression super-chunk: %ld -> %ld (%.1fx)\n",
+         (long)nbytes, (long)frame_len, (1. * nbytes) / frame_len);
+
+  /* Retrieve and decompress the chunks */
+  blosc_set_timestamp(&last);
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, rec_buffer, isize);
+    if (dsize < 0) {
+      printf("Decompression error.  Error code: %d\n", dsize);
+      exit(dsize);
+    }
+    assert (dsize == (int)isize);
+  }
+  blosc_set_timestamp(&current);
+  totaltime = blosc_elapsed_secs(last, current);
+  totalsize = (double)(isize) * nchunks;
+  printf("[Decompr] Elapsed time:\t %6.3f s."
+         "  Processed data: %.3f GB (%.3f GB/s)\n",
+         totaltime, totalsize / GB, totalsize / (GB * totaltime));
+
+  /* Exercise the getitem */
+  blosc_set_timestamp(&last);
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    bool needs_free;
+    uint8_t* chunk_;
+    csize = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_, &needs_free);
+    if (csize < 0) {
+      printf("blosc2_schunk_get_chunk error.  Error code: %d\n", dsize);
+      return csize;
+    }
+    switch (svalue) {
+      case CHECK_VALUES:
+        rc = blosc_getitem(chunk_, nchunk, 1, &value);
+        if (rc < 0) {
+          printf("Error in getitem of a special value\n");
+          return rc;
+        }
+        if (value != REPEATED_VALUE) {
+          printf("Wrong value!");
+          exit(1);
+        }
+        break;
+      case CHECK_NANS:
+        rc = blosc_getitem(chunk_, nchunk, 1, &fvalue);
+        if (rc < 0) {
+          printf("Error in getitem of a special value\n");
+          return rc;
+        }
+        if (!isnan(fvalue)) {
+          printf("Wrong value!");
+          exit(1);
+        }
+        break;
+      default:
+        // It can only be zeros
+        rc = blosc_getitem(chunk_, nchunk, 1, &value);
+        if (rc < 0) {
+          printf("Error in getitem of a special value\n");
+          return rc;
+        }
+        if (value != 0) {
+        printf("Wrong value!");
+        exit(1);
+      }
+    }
+    if (needs_free) {
+      free(chunk_);
+    }
+  }
+  blosc_set_timestamp(&current);
+  totaltime = blosc_elapsed_secs(last, current);
+  printf("[getitem] Elapsed time:\t %6.3f s.\n", totaltime);
+
+//  /* Check that all the values have a good roundtrip */
+//  blosc_set_timestamp(&last);
+//  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+//    dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) rec_buffer, isize);
+//    if (dsize < 0) {
+//      printf("Decompression error.  Error code: %d\n", dsize);
+//      return dsize;
+//    }
+//    assert (dsize == (int)isize);
+//    if (CHECK_VALUE) {
+//      int32_t* buffer = (int32_t*)rec_buffer;
+//      for (int i = 0; i < CHUNKSIZE; i++) {
+//        if (buffer[i] != REPEATED_VALUE) {
+//          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
+//          return -1;
+//        }
+//      }
+//    }
+//    else if (CHECK_NAN) {
+//      float* buffer = (float*)rec_buffer;
+//      for (int i = 0; i < CHUNKSIZE; i++) {
+//        if (!isnan(buffer[i])) {
+//          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
+//          return -1;
+//        }
+//      }
+//    }
+//    else {
+//      int32_t* buffer = (int32_t*)rec_buffer;
+//      for (int i = 0; i < CHUNKSIZE; i++) {
+//        if (buffer[i] != 0) {
+//          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
+//          return -1;
+//        }
+//      }
+//    }
+//  }
+//  printf("All data did a good roundtrip!\n");
+
+  /* Free resources */
+  free(data_buffer);
+  free(rec_buffer);
+  /* Destroy the super-chunk */
+  blosc2_schunk_free(schunk);
+  /* Destroy the Blosc environment */
+  blosc_destroy();
+
+  return 0;
+}
+
+
+int main(void) {
+  int rc;
+  // TODO: Check why this is not working...
+  printf("Testing zero detection...");
+  rc = check_special_values(ZERO_DETECTION);
+  if (rc < 0) {
+    return rc;
+  }
+  printf("*** Testing special zeros...");
+  rc = check_special_values(CHECK_ZEROS);
+  if (rc < 0) {
+    return rc;
+  }
+  printf("*** Testing special NaNs...");
+  rc = check_special_values(CHECK_NANS);
+  if (rc < 0) {
+    return rc;
+  }
+  printf("*** Testing special values...");
+  rc = check_special_values(CHECK_VALUES);
+  if (rc < 0) {
+    return rc;
+  }
+}
diff --git a/blosc/CMakeLists.txt b/blosc/CMakeLists.txt
index 772c233c..df657d53 100644
--- a/blosc/CMakeLists.txt
+++ b/blosc/CMakeLists.txt
@@ -158,6 +158,7 @@ endif()
 
 if(UNIX AND NOT APPLE)
     set(LIBS ${LIBS} "rt")
+    set(LIBS ${LIBS} "m")
 endif()
 
 # targets
diff --git a/blosc/blosc2.c b/blosc/blosc2.c
index 1fa7947a..35a85145 100644
--- a/blosc/blosc2.c
+++ b/blosc/blosc2.c
@@ -1,86 +1,87 @@
 /*********************************************************************
   Blosc - Blocked Shuffling and Compression Library
 
   Author: The Blosc Developers <blosc@blosc.org>
   Creation date: 2009-05-20
 
   See LICENSE.txt for details about copyright and rights to use.
 **********************************************************************/
 
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
 #include <sys/types.h>
 #include <assert.h>
+#include <math.h>
 
 #include "blosc2.h"
 #include "blosc-private.h"
 #include "blosc2-common.h"
 
 #if defined(USING_CMAKE)
   #include "config.h"
 #endif /*  USING_CMAKE */
 #include "context.h"
 
 #include "shuffle.h"
 #include "delta.h"
 #include "trunc-prec.h"
 #include "blosclz.h"
 #include "btune.h"
 
 #if defined(HAVE_LZ4)
   #include "lz4.h"
   #include "lz4hc.h"
   #ifdef HAVE_IPP
     #include <ipps.h>
     #include <ippdc.h>
   #endif
 #endif /*  HAVE_LZ4 */
 #if defined(HAVE_LIZARD)
   #include "lizard_compress.h"
   #include "lizard_decompress.h"
 #endif /*  HAVE_LIZARD */
 #if defined(HAVE_SNAPPY)
   #include "snappy-c.h"
 #endif /*  HAVE_SNAPPY */
 #if defined(HAVE_MINIZ)
   #include "miniz.c"
 #elif defined(HAVE_ZLIB)
   #include "zlib.h"
 #endif /*  HAVE_MINIZ */
 #if defined(HAVE_ZSTD)
   #include "zstd.h"
   #include "zstd_errors.h"
   // #include "cover.h"  // for experimenting with fast cover training for building dicts
   #include "zdict.h"
 #endif /*  HAVE_ZSTD */
 
 
 #if defined(_WIN32) && !defined(__MINGW32__)
   #include <windows.h>
   #include <malloc.h>
 
 /* stdint.h only available in VS2010 (VC++ 16.0) and newer */
   #if defined(_MSC_VER) && _MSC_VER < 1600
     #include "win32/stdint-windows.h"
   #else
     #include <stdint.h>
   #endif
 
   #define fseek _fseeki64
 
   #include <process.h>
   #define getpid _getpid
 #else
   #include <unistd.h>
 #endif  /* _WIN32 */
 
 #if defined(_WIN32) && !defined(__GNUC__)
   #include "win32/pthread.c"
 #endif
 
 /* Synchronization variables */
 
 /* Global context for non-contextual API */
@@ -708,192 +709,193 @@ static bool get_run(const uint8_t* ip, const uint8_t* ip_bound) {
 /* Shuffle & compress a single block */
 static int blosc_c(struct thread_context* thread_context, int32_t bsize,
                    int32_t leftoverblock, int32_t ntbytes, int32_t destsize,
                    const uint8_t* src, const int32_t offset, uint8_t* dest,
                    uint8_t* tmp, uint8_t* tmp2) {
   blosc2_context* context = thread_context->parent_context;
   int dont_split = (context->header_flags & 0x10) >> 4;
   int dict_training = context->use_dict && context->dict_cdict == NULL;
   int32_t j, neblock, nstreams;
   int32_t cbytes;                   /* number of compressed bytes in split */
   int32_t ctbytes = 0;              /* number of compressed bytes in block */
   int64_t maxout;
   int32_t typesize = context->typesize;
   const char* compname;
   int accel;
   const uint8_t* _src;
   uint8_t *_tmp = tmp, *_tmp2 = tmp2;
   uint8_t *_tmp3 = thread_context->tmp4;
   int last_filter_index = last_filter(context->filters, 'c');
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
   if (last_filter_index >= 0 || context->prefilter != NULL) {
     /* Apply the filter pipeline just for the prefilter */
     if (memcpyed && context->prefilter != NULL) {
       // We only need the prefilter output
       _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);
 
       if (_src == NULL) {
         return -9;  // signals a problem with the filter pipeline
       }
       return bsize;
     }
     /* Apply regular filter pipeline */
     _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);
 
     if (_src == NULL) {
       return -9;  // signals a problem with the filter pipeline
     }
   } else {
     _src = src + offset;
   }
 
   assert(context->clevel > 0);
 
   /* Calculate acceleration for different compressors */
   accel = get_accel(context);
 
   /* The number of compressed data streams for this block */
   if (!dont_split && !leftoverblock && !dict_training) {
     nstreams = (int32_t)typesize;
   }
   else {
     nstreams = 1;
   }
   neblock = bsize / nstreams;
   for (j = 0; j < nstreams; j++) {
     if (!dict_training) {
       dest += sizeof(int32_t);
       ntbytes += sizeof(int32_t);
       ctbytes += sizeof(int32_t);
 
+      const uint8_t *ip = (uint8_t *) _src + j * neblock;
+      const uint8_t *ipbound = (uint8_t *) _src + (j + 1) * neblock;
+
       // See whether we have a run here
-      const uint8_t* ip = (uint8_t*)_src + j * neblock;
-      const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;
-      if (get_run(ip, ipbound)) {
+      if (context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH && get_run(ip, ipbound)) {
         // A run
         int32_t value = _src[j * neblock];
         if (ntbytes > destsize) {
           /* Not enough space to write out compressed block size */
           return -1;
         }
         // Encode the repeated byte in the first (LSB) byte of the length of the split.
         _sw32(dest - 4, -value);    // write the value in two's complement
         if (value > 0) {
           // Mark the encoding as a run-length (== 0 is always a 0's run)
           ntbytes += 1;
           ctbytes += 1;
           if (ntbytes > destsize) {
             /* Not enough space to write out compressed block size */
             return -1;
           }
           // Set MSB bit (sign) to 1 (not really necessary here, but for demonstration purposes)
           // dest[-1] |= 0x80;
           dest[0] = 0x1;   // set run-length bit (0) in token
           dest += 1;
         }
         continue;
       }
     }
 
     maxout = neblock;
   #if defined(HAVE_SNAPPY)
     if (context->compcode == BLOSC_SNAPPY) {
       maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);
     }
   #endif /*  HAVE_SNAPPY */
     if (ntbytes + maxout > destsize) {
       /* avoid buffer * overrun */
       maxout = (int64_t)destsize - (int64_t)ntbytes;
       if (maxout <= 0) {
         return 0;                  /* non-compressible block */
       }
     }
     if (dict_training) {
       // We are in the build dict state, so don't compress
       // TODO: copy only a percentage for sampling
       memcpy(dest, _src + j * neblock, (unsigned int)neblock);
       cbytes = (int32_t)neblock;
     }
     else if (context->compcode == BLOSC_BLOSCLZ) {
       cbytes = blosclz_compress(context->clevel, _src + j * neblock,
                                 (int)neblock, dest, (int)maxout);
     }
   #if defined(HAVE_LZ4)
     else if (context->compcode == BLOSC_LZ4) {
       void *hash_table = NULL;
     #ifdef HAVE_IPP
       hash_table = (void*)thread_context->lz4_hash_table;
     #endif
       cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,
                                  (char*)dest, (size_t)maxout, accel, hash_table);
     }
     else if (context->compcode == BLOSC_LZ4HC) {
       cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,
                                    (char*)dest, (size_t)maxout, context->clevel);
     }
   #endif /* HAVE_LZ4 */
   #if defined(HAVE_LIZARD)
     else if (context->compcode == BLOSC_LIZARD) {
       cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,
                                     (char*)dest, (size_t)maxout, accel);
     }
   #endif /* HAVE_LIZARD */
   #if defined(HAVE_SNAPPY)
     else if (context->compcode == BLOSC_SNAPPY) {
       cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,
                                     (char*)dest, (size_t)maxout);
     }
   #endif /* HAVE_SNAPPY */
   #if defined(HAVE_ZLIB)
     else if (context->compcode == BLOSC_ZLIB) {
       cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,
                                   (char*)dest, (size_t)maxout, context->clevel);
     }
   #endif /* HAVE_ZLIB */
   #if defined(HAVE_ZSTD)
     else if (context->compcode == BLOSC_ZSTD) {
       cbytes = zstd_wrap_compress(thread_context,
                                   (char*)_src + j * neblock, (size_t)neblock,
                                   (char*)dest, (size_t)maxout, context->clevel);
     }
   #endif /* HAVE_ZSTD */
 
     else {
       blosc_compcode_to_compname(context->compcode, &compname);
       BLOSC_TRACE_ERROR("Blosc has not been compiled with '%s' compression support."
                         "Please use one having it.", compname);
       return -5;    /* signals no compression support */
     }
 
     if (cbytes > maxout) {
       /* Buffer overrun caused by compression (should never happen) */
       return -1;
     }
     if (cbytes < 0) {
       /* cbytes should never be negative */
       return -2;
     }
     if (!dict_training) {
       if (cbytes == 0 || cbytes == neblock) {
         /* The compressor has been unable to compress data at all. */
         /* Before doing the copy, check that we are not running into a
            buffer overflow. */
         if ((ntbytes + neblock) > destsize) {
           return 0;    /* Non-compressible data */
         }
         memcpy(dest, _src + j * neblock, (unsigned int)neblock);
         cbytes = neblock;
       }
       _sw32(dest - 4, cbytes);
     }
     dest += cbytes;
     ntbytes += cbytes;
     ctbytes += cbytes;
   }  /* Closes j < nstreams */
 
   //printf("c%d", ctbytes);
   return ctbytes;
 }
 
 
 /* Process the filter pipeline (decompression mode) */
@@ -984,303 +986,304 @@ int pipeline_d(blosc2_context* context, const int32_t bsize, uint8_t* dest,
 /* Decompress & unshuffle a single block */
 static int blosc_d(
     struct thread_context* thread_context, int32_t bsize,
     int32_t leftoverblock, const uint8_t* src, int32_t srcsize, int32_t src_offset,
     int32_t nblock, uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {
   blosc2_context* context = thread_context->parent_context;
   uint8_t* filters = context->filters;
   uint8_t *tmp3 = thread_context->tmp4;
   int32_t compformat = (context->header_flags & (uint8_t)0xe0) >> 5u;
   int dont_split = (context->header_flags & (uint8_t)0x10) >> 4u;
   //uint8_t blosc_version_format = src[BLOSC2_CHUNK_VERSION];
   int nstreams;
   int32_t neblock;
   int32_t nbytes;                /* number of decompressed bytes in split */
   int32_t cbytes;                /* number of compressed bytes in split */
   int32_t ctbytes = 0;           /* number of compressed bytes in block */
   int32_t ntbytes = 0;           /* number of uncompressed bytes in block */
   uint8_t* _dest;
   int32_t typesize = context->typesize;
   const char* compname;
 
   if (context->block_maskout != NULL && context->block_maskout[nblock]) {
     // Do not decompress, but act as if we successfully decompressed everything
     return bsize;
   }
 
-  bool is_lazy = context->blosc2_flags & 0x08u;
+  bool is_lazy = ((context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) &&
+          (context->blosc2_flags & 0x08u));
   if (is_lazy) {
     // The chunk is on disk, so just lazily load the block
     if (context->schunk == NULL) {
       BLOSC_TRACE_ERROR("Lazy chunk needs an associated super-chunk.");
       return -11;
     }
     if (context->schunk->frame == NULL) {
       BLOSC_TRACE_ERROR("Lazy chunk needs an associated frame.");
       return -12;
     }
     char* urlpath = context->schunk->frame->urlpath;
     int32_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + context->nblocks * sizeof(int32_t);
     int32_t non_lazy_chunklen = srcsize - trailer_len;
     int32_t nchunk;
     int64_t chunk_offset;
     if (context->schunk->frame->eframe) {
       // The nchunk of the actual chunk is in the trailer
       nchunk = *(int32_t*)(src + non_lazy_chunklen);
     }
     else {
       // The offset of the actual chunk is in the trailer
       chunk_offset = *(int64_t*)(src + non_lazy_chunklen + sizeof(int32_t));
     }
     // Get the csize of the nblock
     int32_t *block_csizes = (int32_t *)(src + non_lazy_chunklen + sizeof(int32_t) + sizeof(int64_t));
     int32_t block_csize = block_csizes[nblock];
     // Read the lazy block on disk
     FILE* fp = NULL;
     if (context->schunk->frame->eframe) {
       // The chunk is not in the frame
       char* chunkpath = malloc(strlen(context->schunk->frame->urlpath) + 1 + 8 + strlen(".chunk") + 1);
       sprintf(chunkpath, "%s/%08X.chunk", context->schunk->frame->urlpath, nchunk);
       fp = fopen(chunkpath, "rb");
       free(chunkpath);
       // The offset of the block is src_offset
       fseek(fp, 0 + src_offset, SEEK_SET);
     }
     else {
       fp = fopen(urlpath, "rb");
       // The offset of the block is src_offset
       fseek(fp, chunk_offset + src_offset, SEEK_SET);
     }
     size_t rbytes = fread((void*)(src + src_offset), 1, block_csize, fp);
     fclose(fp);
     if (rbytes != block_csize) {
       BLOSC_TRACE_ERROR("Cannot read the (lazy) block out of the fileframe.");
       return -13;
     }
   }
 
   // If the chunk is memcpyed, we just have to copy the block to dest and return
   int memcpyed = src[BLOSC2_CHUNK_FLAGS] & (uint8_t)BLOSC_MEMCPYED;
   if (memcpyed) {
     int32_t chunk_nbytes = *(int32_t*)(src + BLOSC2_CHUNK_NBYTES);
     int32_t chunk_cbytes = *(int32_t*)(src + BLOSC2_CHUNK_CBYTES);
-    if (chunk_nbytes + BLOSC_MAX_OVERHEAD != chunk_cbytes) {
+    if (chunk_nbytes + context->header_overhead != chunk_cbytes) {
       return -1;
     }
     int bsize_ = leftoverblock ? chunk_nbytes % context->blocksize : bsize;
-    if (chunk_cbytes < BLOSC_MAX_OVERHEAD + (nblock * context->blocksize) + bsize_) {
+    if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {
       /* Not enough input to copy block */
       return -1;
     }
-    memcpy(dest + dest_offset, src + BLOSC_MAX_OVERHEAD + nblock * context->blocksize, bsize_);
+    memcpy(dest + dest_offset, src + context->header_overhead + nblock * context->blocksize, bsize_);
     return bsize_;
   }
 
   if (src_offset <= 0 || src_offset >= srcsize) {
     /* Invalid block src offset encountered */
     return -1;
   }
 
   src += src_offset;
   srcsize -= src_offset;
 
   int last_filter_index = last_filter(filters, 'd');
 
   if ((last_filter_index >= 0) &&
           (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) {
    // We are making use of some filter, so use a temp for destination
    _dest = tmp;
   } else {
     // If no filters, or only DELTA in pipeline
    _dest = dest + dest_offset;
   }
 
   /* The number of compressed data streams for this block */
   if (!dont_split && !leftoverblock && !context->use_dict) {
     // We don't want to split when in a training dict state
     nstreams = (int32_t)typesize;
   }
   else {
     nstreams = 1;
   }
 
   neblock = bsize / nstreams;
   for (int j = 0; j < nstreams; j++) {
     if (srcsize < sizeof(int32_t)) {
       /* Not enough input to read compressed size */
       return -1;
     }
     srcsize -= sizeof(int32_t);
     cbytes = sw32_(src);      /* amount of compressed bytes */
     if (cbytes > 0) {
       if (srcsize < cbytes) {
         /* Not enough input to read compressed bytes */
         return -1;
       }
       srcsize -= cbytes;
     }
     src += sizeof(int32_t);
     ctbytes += (int32_t)sizeof(int32_t);
 
     /* Uncompress */
     if (cbytes == 0) {
       // A run of 0's
       memset(_dest, 0, (unsigned int)neblock);
       nbytes = neblock;
     }
     else if (cbytes < 0) {
       // A negative number means some encoding depending on the token that comes next
       uint8_t token;
 
       if (srcsize < sizeof(uint8_t)) {
         // Not enough input to read token */
         return -1;
       }
       srcsize -= sizeof(uint8_t);
 
       token = src[0];
       src += 1;
       ctbytes += 1;
 
       if (token & 0x1) {
         // A run of bytes that are different than 0
         if (cbytes < -255) {
           // Runs can only encode a byte
           return -2;
         }
         uint8_t value = -cbytes;
         memset(_dest, value, (unsigned int) neblock);
         nbytes = neblock;
         cbytes = 0;  // everything is encoded in the cbytes token
       }
     }
     else if (cbytes == neblock) {
       memcpy(_dest, src, (unsigned int)neblock);
       nbytes = (int32_t)neblock;
     }
     else {
       if (compformat == BLOSC_BLOSCLZ_FORMAT) {
         nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);
       }
   #if defined(HAVE_LZ4)
       else if (compformat == BLOSC_LZ4_FORMAT) {
         nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                      (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_LZ4 */
   #if defined(HAVE_LIZARD)
       else if (compformat == BLOSC_LIZARD_FORMAT) {
         nbytes = lizard_wrap_decompress((char*)src, (size_t)cbytes,
                                         (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_LIZARD */
   #if defined(HAVE_SNAPPY)
       else if (compformat == BLOSC_SNAPPY_FORMAT) {
         nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,
                                         (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_SNAPPY */
   #if defined(HAVE_ZLIB)
       else if (compformat == BLOSC_ZLIB_FORMAT) {
         nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZLIB */
   #if defined(HAVE_ZSTD)
       else if (compformat == BLOSC_ZSTD_FORMAT) {
         nbytes = zstd_wrap_decompress(thread_context,
                                       (char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZSTD */
       else {
         compname = clibcode_to_clibname(compformat);
         BLOSC_TRACE_ERROR(
                 "Blosc has not been compiled with decompression "
                 "support for '%s' format.  "
                 "Please recompile for adding this support.", compname);
         return -5;    /* signals no decompression support */
       }
 
       /* Check that decompressed bytes number is correct */
       if (nbytes != neblock) {
         return -2;
       }
 
     }
     src += cbytes;
     ctbytes += cbytes;
     _dest += nbytes;
     ntbytes += nbytes;
   } /* Closes j < nstreams */
 
   if (last_filter_index >= 0) {
     int errcode = pipeline_d(context, bsize, dest, dest_offset, tmp, tmp2, tmp3,
                              last_filter_index);
     if (errcode < 0)
       return errcode;
   }
 
   /* Return the number of uncompressed bytes */
   return (int)ntbytes;
 }
 
 
 /* Serial version for compression/decompression */
 static int serial_blosc(struct thread_context* thread_context) {
   blosc2_context* context = thread_context->parent_context;
   int32_t j, bsize, leftoverblock;
   int32_t cbytes;
   int32_t ntbytes = (int32_t)context->output_bytes;
   int32_t* bstarts = context->bstarts;
   uint8_t* tmp = thread_context->tmp;
   uint8_t* tmp2 = thread_context->tmp2;
   int dict_training = context->use_dict && (context->dict_cdict == NULL);
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
   for (j = 0; j < context->nblocks; j++) {
     if (context->do_compress && !memcpyed && !dict_training) {
       _sw32(bstarts + j, ntbytes);
     }
     bsize = context->blocksize;
     leftoverblock = 0;
     if ((j == context->nblocks - 1) && (context->leftover > 0)) {
       bsize = context->leftover;
       leftoverblock = 1;
     }
     if (context->do_compress) {
       if (memcpyed && !context->prefilter) {
         /* We want to memcpy only */
-        memcpy(context->dest + BLOSC_MAX_OVERHEAD + j * context->blocksize,
-                 context->src + j * context->blocksize,
-                 (unsigned int)bsize);
+        memcpy(context->dest + context->header_overhead + j * context->blocksize,
+               context->src + j * context->blocksize, (unsigned int)bsize);
         cbytes = (int32_t)bsize;
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                          context->destsize, context->src, j * context->blocksize,
                          context->dest + ntbytes, tmp, tmp2);
         if (cbytes == 0) {
           ntbytes = 0;              /* uncompressible data */
           break;
         }
       }
     }
     else {
       /* Regular decompression */
       // If memcpyed we don't have a bstarts section (because it is not needed)
-      int32_t src_offset = memcpyed ? BLOSC_MAX_OVERHEAD + j * context->blocksize : sw32_(bstarts + j);
+      int32_t src_offset = memcpyed ?
+          context->header_overhead + j * context->blocksize : sw32_(bstarts + j);
       cbytes = blosc_d(thread_context, bsize, leftoverblock,
                        context->src, context->srcsize, src_offset, j,
                        context->dest, j * context->blocksize, tmp, tmp2);
     }
 
     if (cbytes < 0) {
       ntbytes = cbytes;         /* error in blosc_c or blosc_d */
       break;
     }
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
@@ -1593,278 +1596,276 @@ static uint8_t get_filter_flags(const uint8_t header_flags,
 static int initialize_context_decompression(blosc2_context* context, const void* src, int32_t srcsize,
                                             void* dest, int32_t destsize) {
   int32_t cbytes;
-  int32_t bstarts_offset;
   int32_t bstarts_end;
 
   context->do_compress = 0;
   context->src = (const uint8_t*)src;
   context->srcsize = srcsize;
   context->dest = (uint8_t*)dest;
   context->destsize = destsize;
   context->output_bytes = 0;
   context->end_threads = 0;
 
   if (context->srcsize < BLOSC_MIN_HEADER_LENGTH) {
     /* Not enough input to read minimum header */
     return -1;
   }
 
   context->header_flags = context->src[BLOSC2_CHUNK_FLAGS];
   context->typesize = context->src[BLOSC2_CHUNK_TYPESIZE];
   context->sourcesize = sw32_(context->src + BLOSC2_CHUNK_NBYTES);
   context->blocksize = sw32_(context->src + BLOSC2_CHUNK_BLOCKSIZE);
   cbytes = sw32_(context->src + BLOSC2_CHUNK_CBYTES);
 
   // Some checks for malformed headers
   if (context->blocksize <= 0 || context->blocksize > destsize ||
       context->typesize <= 0 || context->typesize > BLOSC_MAX_TYPESIZE ||
       cbytes > srcsize) {
     return -1;
   }
   /* Check that we have enough space to decompress */
   if (context->sourcesize > (int32_t)destsize) {
     return -1;
   }
 
   /* Total blocks */
   context->nblocks = context->sourcesize / context->blocksize;
   context->leftover = context->sourcesize % context->blocksize;
   context->nblocks = (context->leftover > 0) ?
                       context->nblocks + 1 : context->nblocks;
 
   if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {
     BLOSC_TRACE_ERROR("The number of items in block_maskout (%d) must match the number"
                       " of blocks in chunk (%d).",
                       context->block_maskout_nitems, context->nblocks);
     return -2;
   }
 
   if ((context->header_flags & BLOSC_DOSHUFFLE) &&
       (context->header_flags & BLOSC_DOBITSHUFFLE)) {
     /* Extended header */
     if (context->srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
       /* Not enough input to read extended header */
       return -1;
     }
+    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
     uint8_t* filters = (uint8_t*)(context->src + BLOSC_MIN_HEADER_LENGTH);
     uint8_t* filters_meta = filters + 8;
     uint8_t header_version = context->src[BLOSC2_CHUNK_VERSION];
     // The number of filters depends on the version of the header
     // (we need to read less because filters where not initialized to zero in blosc2 alpha series)
     int max_filters = (header_version == BLOSC2_VERSION_FORMAT_ALPHA) ? 5 : BLOSC2_MAX_FILTERS;
     for (int i = 0; i < max_filters; i++) {
       context->filters[i] = filters[i];
       context->filters_meta[i] = filters_meta[i];
     }
     context->filter_flags = filters_to_flags(filters);
     context->blosc2_flags = context->src[BLOSC2_CHUNK_BLOSC2_FLAGS];
-    bstarts_offset = BLOSC_EXTENDED_HEADER_LENGTH;
   } else {
     /* Regular (Blosc1) header */
+    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
     context->filter_flags = get_filter_flags(context->header_flags,
                                              context->typesize);
     flags_to_filters(context->header_flags, context->filters);
-    bstarts_offset = BLOSC_MIN_HEADER_LENGTH;
   }
 
-  context->bstarts = (int32_t*)(context->src + bstarts_offset);
-
+  context->bstarts = (int32_t*)(context->src + context->header_overhead);
   if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
     /* If chunk is a memcpy, bstarts does not exist */
-    bstarts_end = bstarts_offset;
+    bstarts_end = context->header_overhead;
   } else {
-    bstarts_end = bstarts_offset + (context->nblocks * sizeof(int32_t));
+    bstarts_end = context->header_overhead + (context->nblocks * sizeof(int32_t));
   }
+
   if (srcsize < bstarts_end) {
     /* Not enough input to read entire `bstarts` section */
     return -1;
   }
   srcsize -= bstarts_end;
 
   /* Read optional dictionary if flag set */
   if (context->blosc2_flags & BLOSC2_USEDICT) {
 #if defined(HAVE_ZSTD)
     context->use_dict = 1;
     if (context->dict_ddict != NULL) {
       // Free the existing dictionary (probably from another chunk)
       ZSTD_freeDDict(context->dict_ddict);
     }
     // The trained dictionary is after the bstarts block
     if (srcsize < sizeof(int32_t)) {
       /* Not enough input to size of dictionary */
       return -1;
     }
     srcsize -= sizeof(int32_t);
     context->dict_size = (size_t)sw32_(context->src + bstarts_end);
     if (context->dict_size <= 0 || context->dict_size > BLOSC2_MAXDICTSIZE) {
       /* Dictionary size is smaller than minimum or larger than maximum allowed */
       return -1;
     }
     if (srcsize < (int32_t)context->dict_size) {
       /* Not enough input to read entire dictionary */
       return -1;
     }
     srcsize -= context->dict_size;
     context->dict_buffer = (void*)(context->src + bstarts_end + sizeof(int32_t));
     context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);
 #endif   // HAVE_ZSTD
   }
 
   return 0;
 }
 
 
-static int write_compression_header(blosc2_context* context,
-                                    bool extended_header) {
+static int write_compression_header(blosc2_context* context, bool extended_header) {
   int32_t compformat;
   int dont_split;
   int dict_training = context->use_dict && (context->dict_cdict == NULL);
 
   // Set the whole header to zeros so that the reserved values are zeroed
   if (extended_header) {
     memset(context->dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
+    context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
   }
   else {
     memset(context->dest, 0, BLOSC_MIN_HEADER_LENGTH);
+    context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
   }
 
   /* Write version header for this block */
   context->dest[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
 
   /* Write compressor format */
   compformat = -1;
   switch (context->compcode) {
     case BLOSC_BLOSCLZ:
       compformat = BLOSC_BLOSCLZ_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
       break;
 
 #if defined(HAVE_LZ4)
     case BLOSC_LZ4:
       compformat = BLOSC_LZ4_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_LZ4_VERSION_FORMAT;
       break;
     case BLOSC_LZ4HC:
       compformat = BLOSC_LZ4HC_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_LZ4HC_VERSION_FORMAT;
       break;
 #endif /*  HAVE_LZ4 */
 
 #if defined(HAVE_LIZARD)
     case BLOSC_LIZARD:
       compformat = BLOSC_LIZARD_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_LIZARD_VERSION_FORMAT;
       break;
 #endif /*  HAVE_LIZARD */
 
 #if defined(HAVE_SNAPPY)
     case BLOSC_SNAPPY:
       compformat = BLOSC_SNAPPY_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_SNAPPY_VERSION_FORMAT;
       break;
 #endif /*  HAVE_SNAPPY */
 
 #if defined(HAVE_ZLIB)
     case BLOSC_ZLIB:
       compformat = BLOSC_ZLIB_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_ZLIB_VERSION_FORMAT;
       break;
 #endif /*  HAVE_ZLIB */
 
 #if defined(HAVE_ZSTD)
     case BLOSC_ZSTD:
       compformat = BLOSC_ZSTD_FORMAT;
       context->dest[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_ZSTD_VERSION_FORMAT;
       break;
 #endif /*  HAVE_ZSTD */
 
     default: {
       const char* compname;
       compname = clibcode_to_clibname(compformat);
       BLOSC_TRACE_ERROR("Blosc has not been compiled with '%s' "
                         "compression support.  Please use one having it.",
                         compname);
       return -5;    /* signals no compression support */
       break;
     }
   }
 
   if (context->clevel == 0) {
     /* Compression level 0 means buffer to be memcpy'ed */
     context->header_flags |= (uint8_t)BLOSC_MEMCPYED;
   }
 
   if (context->sourcesize < BLOSC_MIN_BUFFERSIZE) {
     /* Buffer is too small.  Try memcpy'ing. */
     context->header_flags |= (uint8_t)BLOSC_MEMCPYED;
   }
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
   context->dest[BLOSC2_CHUNK_FLAGS] = 0;                               /* zeroes flags */
   context->dest[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)context->typesize;
   _sw32(context->dest + BLOSC2_CHUNK_NBYTES, (int32_t)context->sourcesize);
   _sw32(context->dest + BLOSC2_CHUNK_BLOCKSIZE, (int32_t)context->blocksize);
   if (extended_header) {
-    /* Mark that we are handling an extended header */
+    /* Indicate that we are building an extended header */
     context->header_flags |= (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);
     /* Store filter pipeline info at the end of the header */
     uint8_t *filters = context->dest + BLOSC_MIN_HEADER_LENGTH;
     uint8_t *filters_meta = filters + 8;
     for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
       filters[i] = context->filters[i];
       filters_meta[i] = context->filters_meta[i];
     }
     uint8_t* blosc2_flags = context->dest + BLOSC2_CHUNK_BLOSC2_FLAGS;
     *blosc2_flags = 0;    // zeroes flags
     *blosc2_flags |= is_little_endian() ? 0 : BLOSC2_BIGENDIAN;  // endianness
     if (dict_training || memcpyed) {
       context->bstarts = NULL;
-      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH;
+      context->output_bytes = context->header_overhead;
     } else {
-      context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);
-      context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +
-                              sizeof(int32_t) * context->nblocks;
+      context->bstarts = (int32_t*)(context->dest + context->header_overhead);
+      context->output_bytes = context->header_overhead + sizeof(int32_t) * context->nblocks;
     }
     if (context->use_dict) {
       *blosc2_flags |= BLOSC2_USEDICT;
     }
   } else {
     // Regular header
     if (memcpyed) {
       context->bstarts = NULL;
-      context->output_bytes = BLOSC_MIN_HEADER_LENGTH;
+      context->output_bytes = context->header_overhead;
     } else {
-      context->bstarts = (int32_t *) (context->dest + BLOSC_MIN_HEADER_LENGTH);
-      context->output_bytes = BLOSC_MIN_HEADER_LENGTH +
-                              sizeof(int32_t) * context->nblocks;
+      context->bstarts = (int32_t *) (context->dest + context->header_overhead);
+      context->output_bytes = context->header_overhead + sizeof(int32_t) * context->nblocks;
     }
   }
 
   // when memcpyed bit is set, there is no point in dealing with others
   if (!memcpyed) {
     if (context->filter_flags & BLOSC_DOSHUFFLE) {
       /* Byte-shuffle is active */
       context->header_flags |= BLOSC_DOSHUFFLE;
     }
 
     if (context->filter_flags & BLOSC_DOBITSHUFFLE) {
       /* Bit-shuffle is active */
       context->header_flags |= BLOSC_DOBITSHUFFLE;
     }
 
     if (context->filter_flags & BLOSC_DODELTA) {
       /* Delta is active */
       context->header_flags |= BLOSC_DODELTA;
     }
 
     dont_split = !split_block(context, context->typesize,
                               context->blocksize, extended_header);
     context->header_flags |= dont_split << 4;  /* dont_split is in bit 4 */
     context->header_flags |= compformat << 5;  /* codec starts at bit 5 */
   }
 
   // store header flags in dest
   context->dest[BLOSC2_CHUNK_FLAGS] = context->header_flags;
 
   return 1;
 }
@@ -1873,162 +1874,178 @@ static int write_compression_header(blosc2_context* context,
 int blosc_compress_context(blosc2_context* context) {
   int ntbytes = 0;
   blosc_timestamp_t last, current;
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
 
   blosc_set_timestamp(&last);
 
   if (!memcpyed) {
     /* Do the actual compression */
     ntbytes = do_job(context);
     if (ntbytes < 0) {
       return -1;
     }
     if (ntbytes == 0) {
       // Try out with a memcpy later on (last chance for fitting src buffer in dest).
       context->header_flags |= (uint8_t)BLOSC_MEMCPYED;
       memcpyed = true;
     }
   }
 
   if (memcpyed) {
-    if (context->sourcesize + BLOSC_MAX_OVERHEAD > context->destsize) {
+    if (context->sourcesize + context->header_overhead > context->destsize) {
       /* We are exceeding maximum output size */
       ntbytes = 0;
     }
     else {
-      context->output_bytes = BLOSC_MAX_OVERHEAD;
+      context->output_bytes = context->header_overhead;
       ntbytes = do_job(context);
       if (ntbytes < 0) {
         return -1;
       }
       // Success!  update the memcpy bit in header
       context->dest[BLOSC2_CHUNK_FLAGS] = context->header_flags;
       // and clear the memcpy bit in context (for next reuse)
       context->header_flags &= ~(uint8_t)BLOSC_MEMCPYED;
     }
   }
+  else {
+    // Check whether we have a run for the whole chunk
+    int start_csizes = context->header_overhead + 4 * context->nblocks;
+    int dont_split = (context->header_flags & 0x10) >> 4;
+    int nstreams = context->nblocks;
+    if (!dont_split) {
+      // When splitting, the number of streams is computed differently
+      nstreams = (context->nblocks - 1) * context->typesize;
+      if (context->leftover) {
+        nstreams += 1;
+      }
+    }
+    if (ntbytes == start_csizes + nstreams * sizeof(int32_t)) {
+      // The streams are all zero runs (by construction).  Encode it...
+      context->dest[BLOSC2_CHUNK_BLOSC2_FLAGS] |= BLOSC2_ZERO_RUNLEN << 4;
+      // ...and assign the new chunk length
+      ntbytes = context->header_overhead;
+    }
+  }
 
   /* Set the number of compressed bytes in header */
   _sw32(context->dest + BLOSC2_CHUNK_CBYTES, ntbytes);
 
   /* Set the number of bytes in dest buffer (might be useful for btune) */
   context->destsize = ntbytes;
 
-  assert(ntbytes <= context->destsize);
-
   if (context->btune != NULL) {
     blosc_set_timestamp(&current);
     double ctime = blosc_elapsed_secs(last, current);
     btune_update(context, ctime);
   }
 
   return ntbytes;
 }
 
 
 /* The public secure routine for compression with context. */
 int blosc2_compress_ctx(blosc2_context* context, const void* src, int32_t srcsize,
                         void* dest, int32_t destsize) {
   int error, cbytes;
 
   if (context->do_compress != 1) {
     BLOSC_TRACE_ERROR("Context is not meant for compression.  Giving up.");
     return -10;
   }
 
   error = initialize_context_compression(
     context, src, srcsize, dest, destsize,
     context->clevel, context->filters, context->filters_meta,
     context->typesize, context->compcode, context->blocksize,
     context->new_nthreads, context->nthreads, context->schunk);
   if (error <= 0) {
     return error;
   }
 
   /* Write the extended header */
   error = write_compression_header(context, true);
   if (error < 0) {
     return error;
   }
 
   cbytes = blosc_compress_context(context);
   if (cbytes < 0) {
     return cbytes;
   }
 
   if (context->use_dict && context->dict_cdict == NULL) {
 
     if (context->compcode != BLOSC_ZSTD) {
       const char* compname;
       compname = clibcode_to_clibname(context->compcode);
       BLOSC_TRACE_ERROR("Codec %s does not support dicts.  Giving up.",
                         compname);
       return -20;
     }
 
 #ifdef HAVE_ZSTD
     // Build the dictionary out of the filters outcome and compress with it
     int32_t dict_maxsize = BLOSC2_MAXDICTSIZE;
     // Do not make the dict more than 5% larger than uncompressed buffer
     if (dict_maxsize > srcsize / 20) {
       dict_maxsize = srcsize / 20;
     }
-    void* samples_buffer = context->dest + BLOSC_EXTENDED_HEADER_LENGTH;
+    void* samples_buffer = context->dest + context->header_overhead;
     unsigned nblocks = 8;  // the minimum that accepts zstd as of 1.4.0
     unsigned sample_fraction = 1;  // 1 allows to use most of the chunk for training
     size_t sample_size = context->sourcesize / nblocks / sample_fraction;
 
     // Populate the samples sizes for training the dictionary
     size_t* samples_sizes = malloc(nblocks * sizeof(void*));
     for (size_t i = 0; i < nblocks; i++) {
       samples_sizes[i] = sample_size;
     }
 
     // Train from samples
     void* dict_buffer = malloc(dict_maxsize);
-    size_t dict_actual_size = ZDICT_trainFromBuffer(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks);
+    int32_t dict_actual_size = (int32_t)ZDICT_trainFromBuffer(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks);
 
     // TODO: experiment with parameters of low-level fast cover algorithm
     // Note that this API is still unstable.  See: https://github.com/facebook/zstd/issues/1599
     // ZDICT_fastCover_params_t fast_cover_params;
     // memset(&fast_cover_params, 0, sizeof(fast_cover_params));
     // fast_cover_params.d = nblocks;
     // fast_cover_params.steps = 4;
     // fast_cover_params.zParams.compressionLevel = context->clevel;
     //size_t dict_actual_size = ZDICT_optimizeTrainFromBuffer_fastCover(dict_buffer, dict_maxsize, samples_buffer, samples_sizes, nblocks, &fast_cover_params);
 
     if (ZDICT_isError(dict_actual_size) != ZSTD_error_no_error) {
       BLOSC_TRACE_ERROR("Error in ZDICT_trainFromBuffer(): '%s'."
                         "  Giving up.", ZDICT_getErrorName(dict_actual_size));
       return -20;
     }
     assert(dict_actual_size > 0);
     free(samples_sizes);
 
     // Update bytes counter and pointers to bstarts for the new compressed buffer
-    context->bstarts = (int32_t*)(context->dest + BLOSC_EXTENDED_HEADER_LENGTH);
-    context->output_bytes = BLOSC_EXTENDED_HEADER_LENGTH +
-                            sizeof(int32_t) * context->nblocks;
+    context->bstarts = (int32_t*)(context->dest + context->header_overhead);
+    context->output_bytes = context->header_overhead + sizeof(int32_t) * context->nblocks;
     /* Write the size of trained dict at the end of bstarts */
     _sw32(context->dest + context->output_bytes, (int32_t)dict_actual_size);
     context->output_bytes += sizeof(int32_t);
     /* Write the trained dict afterwards */
     context->dict_buffer = context->dest + context->output_bytes;
     memcpy(context->dict_buffer, dict_buffer, (unsigned int)dict_actual_size);
     context->dict_cdict = ZSTD_createCDict(dict_buffer, dict_actual_size, 1);  // TODO: use get_accel()
     free(dict_buffer);      // the dictionary is copied in the header now
     context->output_bytes += (int32_t)dict_actual_size;
     context->dict_size = dict_actual_size;
 
     /* Compress with dict */
     cbytes = blosc_compress_context(context);
 
     // Invalidate the dictionary for compressing other chunks using the same context
     context->dict_buffer = NULL;
     ZSTD_freeCDict(context->dict_cdict);
     context->dict_cdict = NULL;
 #endif  // HAVE_ZSTD
   }
 
   return cbytes;
 }
@@ -2049,142 +2066,148 @@ void build_filters(const int doshuffle, const int delta,
 /* The public secure routine for compression. */
 int blosc2_compress(int clevel, int doshuffle, int32_t typesize,
                     const void* src, int32_t srcsize, void* dest, int32_t destsize) {
   int error;
   int result;
   char* envvar;
 
   /* Check whether the library should be initialized */
   if (!g_initlib) blosc_init();
 
   /* Check for a BLOSC_CLEVEL environment variable */
   envvar = getenv("BLOSC_CLEVEL");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value >= 0)) {
       clevel = (int)value;
     }
   }
 
   /* Check for a BLOSC_SHUFFLE environment variable */
   envvar = getenv("BLOSC_SHUFFLE");
   if (envvar != NULL) {
     if (strcmp(envvar, "NOSHUFFLE") == 0) {
       doshuffle = BLOSC_NOSHUFFLE;
     }
     if (strcmp(envvar, "SHUFFLE") == 0) {
       doshuffle = BLOSC_SHUFFLE;
     }
     if (strcmp(envvar, "BITSHUFFLE") == 0) {
       doshuffle = BLOSC_BITSHUFFLE;
     }
   }
 
   /* Check for a BLOSC_DELTA environment variable */
   envvar = getenv("BLOSC_DELTA");
   if (envvar != NULL) {
     if (strcmp(envvar, "1") == 0) {
       blosc_set_delta(1);
     } else {
       blosc_set_delta(0);
     }
   }
 
   /* Check for a BLOSC_TYPESIZE environment variable */
   envvar = getenv("BLOSC_TYPESIZE");
   if (envvar != NULL) {
     long value;
     value = strtol(envvar, NULL, 10);
     if ((value != EINVAL) && (value > 0)) {
       typesize = (size_t)value;
     }
   }
 
   /* Check for a BLOSC_COMPRESSOR environment variable */
   envvar = getenv("BLOSC_COMPRESSOR");
   if (envvar != NULL) {
     result = blosc_set_compressor(envvar);
     if (result < 0) { return result; }
   }
 
   /* Check for a BLOSC_COMPRESSOR environment variable */
   envvar = getenv("BLOSC_BLOCKSIZE");
   if (envvar != NULL) {
     long blocksize;
     blocksize = strtol(envvar, NULL, 10);
     if ((blocksize != EINVAL) && (blocksize > 0)) {
       blosc_set_blocksize((size_t)blocksize);
     }
   }
 
   /* Check for a BLOSC_NTHREADS environment variable */
   envvar = getenv("BLOSC_NTHREADS");
   if (envvar != NULL) {
     long nthreads;
     nthreads = strtol(envvar, NULL, 10);
     if ((nthreads != EINVAL) && (nthreads > 0)) {
       result = blosc_set_nthreads((int)nthreads);
       if (result < 0) { return result; }
     }
   }
 
   /* Check for a BLOSC_NOLOCK environment variable.  It is important
      that this should be the last env var so that it can take the
      previous ones into account */
   envvar = getenv("BLOSC_NOLOCK");
   if (envvar != NULL) {
     // TODO: here is the only place that returns an extended header from
     //   a blosc_compress() call.  This should probably be fixed.
     const char *compname;
     blosc2_context *cctx;
     blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
 
     blosc_compcode_to_compname(g_compressor, &compname);
     /* Create a context for compression */
     build_filters(doshuffle, g_delta, typesize, cparams.filters);
     // TODO: cparams can be shared in a multithreaded environment.  do a copy!
     cparams.typesize = (uint8_t)typesize;
     cparams.compcode = (uint8_t)g_compressor;
     cparams.clevel = (uint8_t)clevel;
     cparams.nthreads = (uint8_t)g_nthreads;
     cctx = blosc2_create_cctx(cparams);
     /* Do the actual compression */
     result = blosc2_compress_ctx(cctx, src, srcsize, dest, destsize);
     /* Release context resources */
     blosc2_free_ctx(cctx);
     return result;
   }
 
   pthread_mutex_lock(&global_comp_mutex);
 
   /* Initialize a context compression */
   uint8_t* filters = calloc(1, BLOSC2_MAX_FILTERS);
   uint8_t* filters_meta = calloc(1, BLOSC2_MAX_FILTERS);
   build_filters(doshuffle, g_delta, typesize, filters);
   error = initialize_context_compression(
     g_global_context, src, srcsize, dest, destsize, clevel, filters,
     filters_meta, (int32_t)typesize, g_compressor, g_force_blocksize, g_nthreads, g_nthreads,
     g_schunk);
   free(filters);
   free(filters_meta);
   if (error <= 0) {
     pthread_mutex_unlock(&global_comp_mutex);
     return error;
   }
 
-  /* Write chunk header without extended header (Blosc1 compatibility mode) */
-  error = write_compression_header(g_global_context, false);
+  envvar = getenv("BLOSC_BLOSC1_COMPAT");
+  if (envvar != NULL) {
+    /* Write chunk header without extended header (Blosc1 compatibility mode) */
+    error = write_compression_header(g_global_context, false);
+  }
+  else {
+    error = write_compression_header(g_global_context, true);
+  }
   if (error < 0) {
     pthread_mutex_unlock(&global_comp_mutex);
     return error;
   }
 
   result = blosc_compress_context(g_global_context);
 
   pthread_mutex_unlock(&global_comp_mutex);
 
   return result;
 }
 
 
 /* The public routine for compression. */
@@ -2194,37 +2217,159 @@ int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,
 }
 
 
+int set_nans(uint8_t* src, int32_t nitems, uint8_t* dest, int32_t destsize) {
+  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
+  int32_t nbytes_chunk = sw32_(src + BLOSC2_CHUNK_NBYTES);;
+  int32_t nbytes = nitems * typesize;
+  int32_t cbytes_chunk = sw32_(src + BLOSC2_CHUNK_CBYTES);;
+  if (nbytes_chunk % typesize != 0) {
+    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
+    return -1;
+  }
+  if (cbytes_chunk < BLOSC_EXTENDED_HEADER_LENGTH) {
+    BLOSC_TRACE_ERROR("Not enough space in src");
+    return -1;
+  }
+  if (nbytes > destsize) {
+    BLOSC_TRACE_ERROR("Not enough space in dest");
+    return -1;
+  }
+  if (typesize == 4) {
+    float* dest_ = (float*)dest;
+    for (int i = 0; i < nitems; i++) {
+      dest_[i] = nanf("");
+    }
+    return nbytes;
+  }
+  else if (typesize == 8) {
+    double* dest_ = (double*)dest;
+    for (int i = 0; i < nitems; i++) {
+      dest_[i] = nan("");
+    }
+    return nbytes;
+  }
+
+  BLOSC_TRACE_ERROR("Unsupported typesize for NaN");
+  return -1;
+}
+
+
+int set_values(uint8_t* src, int32_t nitems, uint8_t* dest, int32_t destsize) {
+  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
+  int32_t nbytes_chunk = sw32_(src + BLOSC2_CHUNK_NBYTES);;
+  int32_t nbytes = nitems * typesize;
+  int32_t cbytes_chunk = sw32_(src + BLOSC2_CHUNK_CBYTES);;
+  if (nbytes_chunk % typesize != 0) {
+    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
+    return -1;
+  }
+  if (cbytes_chunk < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
+    BLOSC_TRACE_ERROR("Not enough space in src");
+    return -1;
+  }
+  if (nbytes > destsize) {
+    BLOSC_TRACE_ERROR("Not enough space in dest");
+    return -1;
+  }
+
+  // Get the value at the end of the header
+  void* value = malloc(typesize);
+  memcpy(value, src + BLOSC_EXTENDED_HEADER_LENGTH, typesize);
+  // And copy it to dest
+  for (int i = 0; i < nitems; i++) {
+    memcpy(dest + i * typesize, value, typesize);
+  }
+  free(value);
+
+  return nbytes_chunk;
+}
+
+
+// Return > 0 if runlen.  0 if not a runlen.
+int handle_runlen(blosc2_context* context, uint8_t* src, uint32_t nbytes, uint8_t* dest, int32_t destsize) {
+  bool doshuffle_flag = src[BLOSC2_CHUNK_FLAGS] & BLOSC_DOSHUFFLE;
+  bool dobitshuffle_flag = src[BLOSC2_CHUNK_FLAGS] & BLOSC_DOBITSHUFFLE;
+  if (!(doshuffle_flag & dobitshuffle_flag)) {
+    // Not a Blosc2 chunk.  It cannot have a runlen.
+    return 0;
+  }
+  context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;  // a Blosc2 chunk
+  int32_t cbytes_chunk = src[BLOSC2_CHUNK_CBYTES];
+  int32_t typesize = src[BLOSC2_CHUNK_TYPESIZE];
+  bool all_zeros = src[BLOSC2_CHUNK_BLOSC2_FLAGS] & (BLOSC2_ZERO_RUNLEN << 4);
+  bool all_nans = src[BLOSC2_CHUNK_BLOSC2_FLAGS] & (BLOSC2_NAN_RUNLEN << 4);
+  if ((cbytes_chunk != context->header_overhead + typesize) && (cbytes_chunk != context->header_overhead)) {
+    return 0;
+  }
+  // all_values need to be checked first!
+  if (all_zeros && all_nans) {
+    // All repeated values
+    int32_t nitems = nbytes / typesize;
+    int rc = set_values(src, nitems, dest, destsize);
+    return rc;
+  }
+  else if (all_nans) {
+    int32_t nitems = nbytes / typesize;
+    int rc = set_nans(src, nitems, dest, destsize);
+    return rc;
+  }
+  else if (all_zeros) {
+    memset(dest, 0, nbytes);
+    return nbytes;
+  }
+
+  // 0 means no special value
+  return 0;
+}
+
+
 int blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,
                                          void* dest, int32_t destsize) {
   int32_t ntbytes;
   uint8_t* _src = (uint8_t*)src;
   uint8_t version;
   int error;
 
   if (srcsize <= 0) {
     /* Invalid argument */
     return -1;
   }
   version = _src[BLOSC2_CHUNK_VERSION];                        /* blosc format version */
   if (version > BLOSC_VERSION_FORMAT) {
     /* Version from future */
     return -1;
   }
 
+  ntbytes = sw32_(_src + BLOSC2_CHUNK_NBYTES);
+  if (ntbytes > destsize) {
+    // Not enough space for writing into the destination
+    return -1;
+  }
+
+  // Is that a chunk with a special value (runlen)?
+  int rc = handle_runlen(context, _src, ntbytes, dest, destsize);
+  if (rc < 0) {
+    return -1;
+  }
+  if (rc > 0) {
+    // This means that we have found a special value and we are done.
+    return rc;
+  }
+
   error = initialize_context_decompression(context, src, srcsize, dest, destsize);
   if (error < 0) {
     return error;
   }
 
   /* Do the actual decompression */
   ntbytes = do_job(context);
   if (ntbytes < 0) {
     return -1;
   }
 
   assert(ntbytes <= (int32_t)destsize);
   return ntbytes;
 }
 
 
 /* The public secure routine for decompression with context. */
@@ -2303,201 +2448,212 @@ int blosc_decompress(const void* src, void* dest, size_t destsize) {
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  This does not use threads because
    it would affect negatively to performance. */
 int _blosc_getitem(blosc2_context* context, const void* src, int32_t srcsize,
                    int start, int nitems, void* dest) {
   uint8_t* _src = NULL;             /* current pos for source buffer */
   uint8_t flags;                    /* flags for header */
   int32_t ntbytes = 0;              /* the number of uncompressed bytes */
   int32_t nblocks;                   /* number of total blocks in buffer */
   int32_t leftover;                  /* extra bytes at end of buffer */
   int32_t* bstarts;                /* start pointers for each block */
   int32_t typesize, blocksize, nbytes;
   int32_t bsize, bsize2, ebsize, leftoverblock;
   int32_t cbytes;
   int32_t startb, stopb;
   int32_t stop = start + nitems;
   int j;
 
   if (nitems == 0) {
     // We have nothing to do
     return 0;
   }
 
   if (srcsize < BLOSC_MIN_HEADER_LENGTH) {
     /* Not enough input to parse Blosc1 header */
     return -1;
   }
   _src = (uint8_t*)(src);
 
   /* Read the header block */
   flags = _src[BLOSC2_CHUNK_FLAGS];                  /* flags */
   bool memcpyed = flags & (uint8_t)BLOSC_MEMCPYED;
   typesize = (int32_t)_src[BLOSC2_CHUNK_TYPESIZE];      /* typesize */
   nbytes = sw32_(_src + BLOSC2_CHUNK_NBYTES);         /* buffer size */
   blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);      /* block size */
   cbytes = sw32_(_src + BLOSC2_CHUNK_CBYTES);    /* compressed buffer size */
-
   ebsize = blocksize + typesize * (int32_t)sizeof(int32_t);
 
+  // Is that a chunk with a special value (runlen)?
+  int rc = handle_runlen(context, _src, nitems * typesize, dest, nitems * typesize);
+  if (rc < 0) {
+    return -1;
+  }
+  if (rc > 0) {
+    // This means that we have found a special value and we are done.
+    return rc;
+  }
+
   if (blocksize <= 0) {
     /* Invalid block size */
     return -1;
   }
 
   /* Total blocks */
   nblocks = nbytes / blocksize;
   leftover = nbytes % blocksize;
   nblocks = (leftover > 0) ? nblocks + 1 : nblocks;
 
-  int32_t header_overhead = BLOSC_MIN_HEADER_LENGTH;
-  if ((context->header_flags & BLOSC_DOSHUFFLE) &&
-      (context->header_flags & BLOSC_DOBITSHUFFLE)) {
+  if (srcsize < context->header_overhead) {
+    /* Not enough input to parse header */
+    return -1;
+  }
+
+  if (context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) {
     /* Extended header */
-    if (srcsize < BLOSC_EXTENDED_HEADER_LENGTH) {
-      /* Not enough input to parse Blosc2 header */
-      return -1;
-    }
-    header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
     uint8_t* filters = _src + BLOSC_MIN_HEADER_LENGTH;
     uint8_t* filters_meta = filters + 8;
     for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
       context->filters[i] = filters[i];
       context->filters_meta[i] = filters_meta[i];
     }
-    bstarts = (int32_t*)(_src + BLOSC_EXTENDED_HEADER_LENGTH);
+    bstarts = (int32_t*)(_src + context->header_overhead);
     // The next is needed for lazy chunks
     context->nblocks = nblocks;
     context->blosc2_flags = _src[BLOSC2_CHUNK_BLOSC2_FLAGS];
   } else {
     /* Minimal header */
     flags_to_filters(flags, context->filters);
-    bstarts = (int32_t*)(_src + BLOSC_MIN_HEADER_LENGTH);
+    bstarts = (int32_t*)(_src + context->header_overhead);
   }
 
   // Some checks for malformed buffers
   if (blocksize <= 0 || blocksize > nbytes || typesize <= 0 || typesize > BLOSC_MAX_TYPESIZE) {
     return -1;
   }
 
   /* Check region boundaries */
   if ((start < 0) || (start * typesize > nbytes)) {
     BLOSC_TRACE_ERROR("`start` out of bounds.");
     return -1;
   }
 
   if ((stop < 0) || (stop * typesize > nbytes)) {
     BLOSC_TRACE_ERROR("`start`+`nitems` out of bounds.");
     return -1;
   }
 
   if (_src + srcsize < (uint8_t *)(bstarts + nblocks)) {
     /* Not enough input to read all `bstarts` */
     return -1;
   }
 
   for (j = 0; j < nblocks; j++) {
     bsize = blocksize;
     leftoverblock = 0;
     if ((j == nblocks - 1) && (leftover > 0)) {
       bsize = leftover;
       leftoverblock = 1;
     }
 
     /* Compute start & stop for each block */
     startb = start * typesize - j * blocksize;
     stopb = stop * typesize - j * blocksize;
     if (stopb <= 0) {
       // We can exit as soon as this block is beyond stop
       break;
     }
     if (startb >= blocksize) {
       continue;
     }
     if (startb < 0) {
       startb = 0;
     }
     if (stopb > blocksize) {
       stopb = blocksize;
     }
     bsize2 = stopb - startb;
 
     /* Do the actual data copy */
     struct thread_context* scontext = context->serial_context;
 
     /* Resize the temporaries in serial context if needed */
     if (blocksize != scontext->tmp_blocksize) {
       my_free(scontext->tmp);
       scontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;
       scontext->tmp = my_malloc(scontext->tmp_nbytes);
       scontext->tmp2 = scontext->tmp + blocksize;
       scontext->tmp3 = scontext->tmp + blocksize + ebsize;
       scontext->tmp4 = scontext->tmp + 2 * blocksize + ebsize;
       scontext->tmp_blocksize = (int32_t)blocksize;
     }
 
     // Regular decompression.  Put results in tmp2.
     // If the block is aligned and the worst case fits in destination, let's avoid a copy
     bool get_single_block = ((startb == 0) && (bsize == nitems * typesize));
     uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;
     // If memcpyed we don't have a bstarts section (because it is not needed)
-    int32_t src_offset = memcpyed ? header_overhead + j * bsize : sw32_(bstarts + j);
+    int32_t src_offset = memcpyed ? context->header_overhead + j * bsize : sw32_(bstarts + j);
     cbytes = blosc_d(context->serial_context, bsize, leftoverblock,
                      src, srcsize, src_offset, j,
                      tmp2, 0, scontext->tmp, scontext->tmp3);
     if (cbytes < 0) {
       ntbytes = cbytes;
       break;
     }
     if (!get_single_block) {
       /* Copy to destination */
       memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
     }
     cbytes = (int)bsize2;
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
 
 
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  Public non-contextual API. */
 int blosc_getitem(const void* src, int start, int nitems, void* dest) {
   uint8_t* _src = (uint8_t*)(src);
   blosc2_context context;
   int result;
 
   uint8_t version = _src[BLOSC2_CHUNK_VERSION];                        /* blosc format version */
   if (version > BLOSC_VERSION_FORMAT) {
     /* Version from future */
     return -1;
   }
 
   /* Minimally populate the context */
   memset(&context, 0, sizeof(blosc2_context));
   context.src = src;
   context.dest = dest;
   context.typesize = (uint8_t)_src[BLOSC2_CHUNK_TYPESIZE];
   context.blocksize = sw32_(_src + BLOSC2_CHUNK_BLOCKSIZE);
   context.header_flags = *(_src + 2);
   context.filter_flags = get_filter_flags(context.header_flags, context.typesize);
   context.schunk = g_schunk;
   context.nthreads = 1;  // force a serial decompression; fixes #95
   context.serial_context = create_thread_context(&context, 0);
   if ((context.header_flags & BLOSC_DOSHUFFLE) &&
       (context.header_flags & BLOSC_DOBITSHUFFLE)) {
     // Support for lazy chunks exists only for Blosc2, and needs the context.
     context.blosc2_flags = _src[BLOSC2_CHUNK_BLOSC2_FLAGS];
+    context.header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
     if (context.blosc2_flags & 0x08) {
       BLOSC_TRACE_ERROR("blosc_getitem does not support lazy chunks.  Use blosc2_getitem_ctx instead.");
       return -2;
     }
   }
+  else {
+    context.header_overhead = BLOSC_MIN_HEADER_LENGTH;
+  }
 
   /* Call the actual getitem function */
   result = _blosc_getitem(&context, src, INT32_MAX, start, nitems, dest);
 
   /* Release resources */
   free_thread_context(context.serial_context);
   return result;
 }
@@ -2525,186 +2681,187 @@ int blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize
 /* execute single compression/decompression job for a single thread_context */
 static void t_blosc_do_job(void *ctxt)
 {
   struct thread_context* thcontext = (struct thread_context*)ctxt;
   blosc2_context* context = thcontext->parent_context;
   int32_t cbytes;
   int32_t ntdest;
   int32_t tblocks;               /* number of blocks per thread */
   int32_t tblock;                /* limit block on a thread */
   int32_t nblock_;              /* private copy of nblock */
   int32_t bsize;
   int32_t leftoverblock;
   /* Parameters for threads */
   int32_t blocksize;
   int32_t ebsize;
   int32_t srcsize;
   bool compress = context->do_compress != 0;
   int32_t maxbytes;
   int32_t nblocks;
   int32_t leftover;
   int32_t leftover2;
   int32_t* bstarts;
   const uint8_t* src;
   uint8_t* dest;
   uint8_t* tmp;
   uint8_t* tmp2;
   uint8_t* tmp3;
 
   /* Get parameters for this thread before entering the main loop */
   blocksize = context->blocksize;
   ebsize = blocksize + context->typesize * sizeof(int32_t);
   maxbytes = context->destsize;
   nblocks = context->nblocks;
   leftover = context->leftover;
   bstarts = context->bstarts;
   src = context->src;
   srcsize = context->srcsize;
   dest = context->dest;
 
   /* Resize the temporaries if needed */
   if (blocksize != thcontext->tmp_blocksize) {
     my_free(thcontext->tmp);
     thcontext->tmp_nbytes = (size_t)3 * context->blocksize + ebsize;
     thcontext->tmp = my_malloc(thcontext->tmp_nbytes);
     thcontext->tmp2 = thcontext->tmp + blocksize;
     thcontext->tmp3 = thcontext->tmp + blocksize + ebsize;
     thcontext->tmp4 = thcontext->tmp + 2 * blocksize + ebsize;
     thcontext->tmp_blocksize = blocksize;
   }
 
   tmp = thcontext->tmp;
   tmp2 = thcontext->tmp2;
   tmp3 = thcontext->tmp3;
 
   // Determine whether we can do a static distribution of workload among different threads
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
   bool static_schedule = (!compress || memcpyed) && context->block_maskout == NULL;
   if (static_schedule) {
       /* Blocks per thread */
       tblocks = nblocks / context->nthreads;
       leftover2 = nblocks % context->nthreads;
       tblocks = (leftover2 > 0) ? tblocks + 1 : tblocks;
       nblock_ = thcontext->tid * tblocks;
       tblock = nblock_ + tblocks;
       if (tblock > nblocks) {
           tblock = nblocks;
       }
   }
   else {
     // Use dynamic schedule via a queue.  Get the next block.
     pthread_mutex_lock(&context->count_mutex);
     context->thread_nblock++;
     nblock_ = context->thread_nblock;
     pthread_mutex_unlock(&context->count_mutex);
     tblock = nblocks;
   }
 
   /* Loop over blocks */
   leftoverblock = 0;
   while ((nblock_ < tblock) && (context->thread_giveup_code > 0)) {
     bsize = blocksize;
     if (nblock_ == (nblocks - 1) && (leftover > 0)) {
       bsize = leftover;
       leftoverblock = 1;
     }
     if (compress) {
       if (memcpyed) {
         if (!context->prefilter) {
           /* We want to memcpy only */
-          memcpy(dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,
+          memcpy(dest + context->header_overhead + nblock_ * blocksize,
                  src + nblock_ * blocksize, (unsigned int) bsize);
           cbytes = (int32_t) bsize;
         }
         else {
           /* Only the prefilter has to be executed, and this is done in blosc_c().
            * However, no further actions are needed, so we can put the result
            * directly in dest. */
           cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                            ebsize, src, nblock_ * blocksize,
-                           dest + BLOSC_MAX_OVERHEAD + nblock_ * blocksize,
+                           dest + context->header_overhead + nblock_ * blocksize,
                            tmp, tmp3);
         }
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                           ebsize, src, nblock_ * blocksize, tmp2, tmp, tmp3);
       }
     }
     else {
       /* Regular decompression */
-      if (srcsize < (int32_t)(BLOSC_MAX_OVERHEAD + (sizeof(int32_t) * nblocks))) {
+      if (srcsize < (int32_t)(context->header_overhead + (sizeof(int32_t) * nblocks))) {
         /* Not enough input to read all `bstarts` */
         cbytes = -1;
       }
       else {
         // If memcpyed we don't have a bstarts section (because it is not needed)
-        int32_t src_offset = memcpyed ? BLOSC_MAX_OVERHEAD + nblock_ * blocksize : sw32_(bstarts + nblock_);
+        int32_t src_offset = memcpyed ?
+            context->header_overhead + nblock_ * blocksize : sw32_(bstarts + nblock_);
         cbytes = blosc_d(thcontext, bsize, leftoverblock,
                           src, srcsize, src_offset, nblock_,
                           dest, nblock_ * blocksize, tmp, tmp2);
       }
     }
 
     /* Check whether current thread has to giveup */
     if (context->thread_giveup_code <= 0) {
       break;
     }
 
     /* Check results for the compressed/decompressed block */
     if (cbytes < 0) {            /* compr/decompr failure */
       /* Set giveup_code error */
       pthread_mutex_lock(&context->count_mutex);
       context->thread_giveup_code = cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       break;
     }
 
     if (compress && !memcpyed) {
       /* Start critical section */
       pthread_mutex_lock(&context->count_mutex);
       ntdest = context->output_bytes;
       // Note: do not use a typical local dict_training variable here
       // because it is probably cached from previous calls if the number of
       // threads does not change (the usual thing).
       if (!(context->use_dict && context->dict_cdict == NULL)) {
         _sw32(bstarts + nblock_, (int32_t) ntdest);
       }
 
       if ((cbytes == 0) || (ntdest + cbytes > maxbytes)) {
         context->thread_giveup_code = 0;  /* uncompressible buf */
         pthread_mutex_unlock(&context->count_mutex);
         break;
       }
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       /* End of critical section */
 
       /* Copy the compressed buffer to destination */
       memcpy(dest + ntdest, tmp2, (unsigned int) cbytes);
     }
     else if (static_schedule) {
       nblock_++;
     }
     else {
       pthread_mutex_lock(&context->count_mutex);
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
     }
 
   } /* closes while (nblock_) */
 
   if (static_schedule) {
     context->output_bytes = context->sourcesize;
     if (compress) {
-      context->output_bytes += BLOSC_MAX_OVERHEAD;
+      context->output_bytes += context->header_overhead;
     }
   }
 
 }
 
 /* Decompress & unshuffle several blocks in a single thread */
@@ -3246,3 +3403,109 @@ int blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {
 
   return 0;
 }
+
+
+/* Create a chunk made of zeros */
+int blosc2_chunk_zeros(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
+  uint8_t* dest_ = dest;
+  int32_t nbytes_ = (int32_t)nbytes;
+
+  if (typesize > 255) {
+    BLOSC_TRACE_ERROR("typesize cannot be larger than 255 bytes");
+    return -1;
+  }
+
+  if (nbytes % typesize != 0) {
+    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
+    return -1;
+  }
+
+  if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
+    BLOSC_TRACE_ERROR("dest buffer is not long enough");
+    return -1;
+  }
+
+  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
+  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
+  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
+  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH);
+  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_ZERO_RUNLEN << 4;  // mark chunk as all zeros
+
+  return BLOSC_EXTENDED_HEADER_LENGTH;
+}
+
+
+/* Create a chunk made of nans */
+int blosc2_chunk_nans(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
+  uint8_t* dest_ = dest;
+  int32_t nbytes_ = (int32_t)nbytes;
+
+  if (typesize > 255) {
+    BLOSC_TRACE_ERROR("typesize cannot be larger than 255 bytes");
+    return -1;
+  }
+
+  if (nbytes % typesize != 0) {
+    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
+    return -1;
+  }
+
+  if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
+    BLOSC_TRACE_ERROR("dest buffer is not long enough");
+    return -1;
+  }
+
+  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
+  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
+  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
+  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH);
+  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_NAN_RUNLEN << 4;  // mark chunk as all NaNs
+
+  return BLOSC_EXTENDED_HEADER_LENGTH;
+}
+
+
+/* Create a chunk made of repeated values */
+int blosc2_chunk_repeatval(const size_t nbytes, const size_t typesize, void* dest,
+                           size_t destsize, void* repeatval) {
+  uint8_t* dest_ = dest;
+  int32_t nbytes_ = (int32_t)nbytes;
+
+  if (typesize > 255) {
+    BLOSC_TRACE_ERROR("typesize cannot be larger than 255 bytes");
+    return -1;
+  }
+
+  if (nbytes % typesize != 0) {
+    BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
+    return -1;
+  }
+
+  if (destsize < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
+    BLOSC_TRACE_ERROR("dest buffer is not long enough");
+    return -1;
+  }
+
+  memset(dest, 0, BLOSC_EXTENDED_HEADER_LENGTH);
+  dest_[BLOSC2_CHUNK_VERSION] = BLOSC_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_VERSIONLZ] = BLOSC_BLOSCLZ_VERSION_FORMAT;
+  dest_[BLOSC2_CHUNK_FLAGS] = (BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE);  // extended header
+  dest_[BLOSC2_CHUNK_TYPESIZE] = (uint8_t)typesize;
+  _sw32(dest_ + BLOSC2_CHUNK_NBYTES, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_BLOCKSIZE, nbytes_);
+  _sw32(dest_ + BLOSC2_CHUNK_CBYTES, BLOSC_EXTENDED_HEADER_LENGTH + (int32_t)typesize);
+  dest_[BLOSC2_CHUNK_BLOSC2_FLAGS] = BLOSC2_VALUE_RUNLEN << 4;  // mark chunk as all repeated value
+
+  // The repeated value comes after the header
+  memcpy(dest_ + BLOSC_EXTENDED_HEADER_LENGTH, repeatval, typesize);
+
+  return BLOSC_EXTENDED_HEADER_LENGTH + (uint8_t)typesize;
+}
diff --git a/blosc/blosc2.h b/blosc/blosc2.h
index 7439d12d..dba0e506 100644
--- a/blosc/blosc2.h
+++ b/blosc/blosc2.h
@@ -68,15 +68,13 @@ enum {
 /* The FRAME_FORMAT_VERSION symbols below should be just 4-bit long */
 enum {
   /* Blosc format version
-   *  4 -> First version (introduced in beta.1)
-   *  1 -> Second version (introduced in beta.2)
+   *  1 -> First version (introduced in beta.2)
+   *  2 -> Second version (introduced in beta.6)
    *
-   *  *Important note*: version 4 should be avoided because it was used
-   *  for beta.1 and before, and it won't be supported anymore.
    */
-  BLOSC2_VERSION_FRAME_FORMAT_BETA1 = 4,  // for beta.1 and before
-  BLOSC2_VERSION_FRAME_FORMAT_BETA2 = 1,  // for beta.2 and after
-  BLOSC2_VERSION_FRAME_FORMAT = BLOSC2_VERSION_FRAME_FORMAT_BETA2,
+  BLOSC2_VERSION_FRAME_FORMAT_BETA2 = 1,  // for 2.0.0-beta2 and after
+  BLOSC2_VERSION_FRAME_FORMAT_BETA6 = 2,  // for 2.0.0-beta6 and after
+  BLOSC2_VERSION_FRAME_FORMAT = BLOSC2_VERSION_FRAME_FORMAT_BETA6,
 };
 
 enum {
@@ -229,26 +227,35 @@ enum {
 /**
  * @brief Offsets for fields in Blosc2 chunk header
  */
 enum {
     BLOSC2_CHUNK_VERSION = 0x0,       //!< the version for the chunk format
     BLOSC2_CHUNK_VERSIONLZ = 0x1,     //!< the version for the format of internal codec
     BLOSC2_CHUNK_FLAGS = 0x2,         //!< flags and codec info
     BLOSC2_CHUNK_TYPESIZE = 0x3,      //!< (uint8) the number of bytes of the atomic type
     BLOSC2_CHUNK_NBYTES = 0x4,        //!< (int32) uncompressed size of the buffer (this header is not included)
     BLOSC2_CHUNK_BLOCKSIZE = 0x8,     //!< (int32) size of internal blocks
     BLOSC2_CHUNK_CBYTES = 0xc,        //!< (int32) compressed size of the buffer (including this header)
     BLOSC2_CHUNK_FILTER_CODES = 0x10, //!< the codecs for the filter pipeline (1 byte per code)
     BLOSC2_CHUNK_FILTER_META = 0x18,  //!< meta info for the filter pipeline (1 byte per code)
     BLOSC2_CHUNK_BLOSC2_FLAGS = 0x1F, //!< flags specific for Blosc2 functionality
 };
 
+/**
+ * @brief Run lengths for special values for chunks/frames
+ */
+enum {
+    BLOSC2_NO_RUNLEN = 0x0,       //!< no run-length
+    BLOSC2_ZERO_RUNLEN = 0x1,     //!< zero run-length
+    BLOSC2_NAN_RUNLEN = 0x2,      //!< NaN run-length
+    BLOSC2_VALUE_RUNLEN = 0x3,    //!< generic value run-length
+};
 
 
 /**
  * @brief Initialize the Blosc library environment.
  *
  * You must call this previous to any other Blosc call, unless you want
  * Blosc to be used simultaneously in a multi-threaded environment, in
  * which case you can use the
  * @see #blosc2_compress_ctx #blosc2_decompress_ctx pair.
  */
@@ -313,43 +320,95 @@ BLOSC_EXPORT int blosc_compress(int clevel, int doshuffle, size_t typesize,
 /**
  * @brief Decompress a block of compressed data in @p src, put the result in
  * @p dest and returns the size of the decompressed block.
  *
  * @warning The @p src buffer and the @p dest buffer can not overlap.
  *
  * @remark Decompression is memory safe and guaranteed not to write the @p dest
  * buffer more than what is specified in @p destsize.
  *
  * @remark In case you want to keep under control the number of bytes read from
  * source, you can call #blosc_cbuffer_sizes first to check whether the
  * @p nbytes (i.e. the number of bytes to be read from @p src buffer by this
  * function) in the compressed buffer is ok with you.
  *
  * @param src The buffer to be decompressed.
  * @param dest The buffer where the decompressed data will be put.
  * @param destsize The size of the @p dest buffer.
  *
  * @return The number of bytes decompressed.
  * If an error occurs, e.g. the compressed data is corrupted or the
  * output buffer is not large enough, then 0 (zero) or a negative value
  * will be returned instead.
  *
  * This function supports all the configuration based environment variables
  * available in blosc2_decompress.
  */
 BLOSC_EXPORT int blosc_decompress(const void* src, void* dest, size_t destsize);
 
 
+/**
+ * @brief Create a chunk made of zeros.
+ *
+ * @param nbytes The size (in bytes) of the chunk.
+ * @param typesize The size (in bytes) of the type.
+ * @param dest The buffer where the data chunk will be put.
+ * @param destsize The size (in bytes) of the @p dest buffer;
+ * must be BLOSC_EXTENDED_HEADER_LENGTH at least.
+ *
+ * @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH).
+ * If negative, there has been an error and @dest is unusable.
+ * */
+BLOSC_EXPORT int blosc2_chunk_zeros(size_t nbytes, size_t typesize,
+                                    void* dest, size_t destsize);
+
+
+/**
+ * @brief Create a chunk made of nans.
+ *
+ * @param nbytes The size (in bytes) of the chunk.
+ * @param typesize The size (in bytes) of the type;
+ * only 4 bytes (float) and 8 bytes (double) are supported.
+ * @param dest The buffer where the data chunk will be put.
+ * @param destsize The size (in bytes) of the @p dest buffer;
+ * must be BLOSC_EXTENDED_HEADER_LENGTH at least.
+ *
+ * @note Whether the NaNs are floats or doubles will be given by the typesize.
+ *
+ * @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH).
+ * If negative, there has been an error and @dest is unusable.
+ * */
+BLOSC_EXPORT int blosc2_chunk_nans(size_t nbytes, size_t typesize,
+                                   void* dest, size_t destsize);
+
+
+/**
+ * @brief Create a chunk made of repeated values.
+ *
+ * @param nbytes The size (in bytes) of the chunk.
+ * @param typesize The size (in bytes) of the type.
+ * @param dest The buffer where the data chunk will be put.
+ * @param destsize The size (in bytes) of the @p dest buffer.
+ * @param repeatval A pointer to the repeated value (little endian).
+ * The size of the value is given by @p typesize param.
+ *
+ * @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH + typesize).
+ * If negative, there has been an error and @dest is unusable.
+ * */
+BLOSC_EXPORT int blosc2_chunk_repeatval(size_t nbytes, size_t typesize,
+                                        void* dest, size_t destsize, void* repeatval);
+
+
 /**
  * @brief Get @p nitems (of @p typesize size) in @p src buffer starting in @p start.
  * The items are returned in @p dest buffer, which has to have enough
  * space for storing all items.
  *
  * @param src The compressed buffer from data will be decompressed.
  * @param start The position of the first item (of @p typesize size) from where data
  * will be retrieved.
  * @param nitems The number of items (of @p typesize size) that will be retrieved.
  * @param dest The buffer where the decompressed data retrieved will be put.
  *
  * @return The number of bytes copied to @p dest or a negative value if
  * some error happens.
  */
diff --git a/blosc/blosclz.c b/blosc/blosclz.c
index 11b36d5f..7043893d 100644
--- a/blosc/blosclz.c
+++ b/blosc/blosclz.c
@@ -397,110 +397,110 @@ static uint8_t* get_run_or_match(uint8_t* ip, uint8_t* ip_bound, const uint8_t*
 // Get the compressed size of a buffer.  Useful for testing compression ratios for high clevels.
 static int get_csize(uint8_t* ibase, int maxlen, bool force_3b_shift) {
   uint8_t* ip = ibase;
   int32_t oc = 0;
   uint8_t* ip_bound = ibase + maxlen - 1;
   uint8_t* ip_limit = ibase + maxlen - 12;
   uint32_t htab[1U << (uint8_t)HASH_LOG];
   uint32_t hval;
   uint32_t seq;
   uint8_t copy;
 
   // Initialize the hash table to distances of 0
   for (unsigned i = 0; i < (1U << HASH_LOG); i++) {
     htab[i] = 0;
   }
 
   /* we start with literal copy */
   copy = 4;
   oc += 5;
 
   /* main loop */
   while (BLOSCLZ_LIKELY(ip < ip_limit)) {
     const uint8_t* ref;
     unsigned distance;
     uint8_t* anchor = ip;    /* comparison starting-point */
 
     /* find potential match */
     seq = BLOSCLZ_READU32(ip);
     HASH_FUNCTION(hval, seq, HASH_LOG)
     ref = ibase + htab[hval];
 
     /* calculate distance to the match */
-    distance = anchor - ref;
+    distance = (unsigned int)(anchor - ref);
 
     /* update hash table */
     htab[hval] = (uint32_t) (anchor - ibase);
 
     if (distance == 0 || (distance >= MAX_FARDISTANCE)) {
       LITERAL2(ip, oc, anchor, copy)
       continue;
     }
 
     /* is this a match? check the first 4 bytes */
     if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {
       ref += 4;
     }
     else {
       /* no luck, copy as a literal */
       LITERAL2(ip, oc, anchor, copy)
       continue;
     }
 
     /* last matched byte */
     ip = anchor + 4;
 
     /* distance is biased */
     distance--;
 
     /* get runs or matches; zero distance means a run */
     ip = get_run_or_match(ip, ip_bound, ref, !distance);
 
     ip -= force_3b_shift ? 3 : 4;
     unsigned len = (int)(ip - anchor);
     // If match is close, let's reduce the minimum length to encode it
     unsigned minlen = (distance < MAX_DISTANCE) ? 3 : 4;
     // Encoding short lengths is expensive during decompression
     if (len < minlen) {
       LITERAL2(ip, oc, anchor, copy)
       continue;
     }
 
     /* if we have'nt copied anything, adjust the output counter */
     if (!copy)
       oc--;
     /* reset literal counter */
     copy = 0;
 
     /* encode the match */
     if (distance < MAX_DISTANCE) {
       if (len >= 7) {
         oc += ((len - 7) / 255) + 1;
       }
       oc += 2;
     }
     else {
       /* far away, but not yet in the another galaxy... */
       if (len >= 7) {
         oc += ((len - 7) / 255) + 1;
       }
       oc += 4;
     }
 
     /* update the hash at match boundary */
     seq = BLOSCLZ_READU32(ip);
     HASH_FUNCTION(hval, seq, HASH_LOG)
     htab[hval] = (uint32_t) (ip++ - ibase);
     seq >>= 8U;
     HASH_FUNCTION(hval, seq, HASH_LOG)
     htab[hval] = (uint32_t) (ip++ - ibase);
     /* assuming literal copy */
     oc++;
 
   }
 
   /* if we have copied something, adjust the copy length */
   if (!copy)
     oc--;
 
   return (int)oc;
 }
@@ -509,221 +509,221 @@ static int get_csize(uint8_t* ibase, int maxlen, bool force_3b_shift) {
 int blosclz_compress(const int clevel, const void* input, int length,
                      void* output, int maxout) {
   uint8_t* ibase = (uint8_t*)input;
   uint8_t* ip = ibase;
   uint8_t* ip_bound = ibase + length - 1;
   uint8_t* ip_limit = ibase + length - 12;
   uint8_t* op = (uint8_t*)output;
   uint8_t* op_limit;
   uint32_t htab[1U << (uint8_t)HASH_LOG];
   uint32_t hval;
   uint32_t seq;
   uint8_t copy;
 
   op_limit = op + maxout;
 
   // Minimum lengths for encoding
   unsigned minlen_[10] = {0, 12, 12, 11, 10, 9, 8, 7, 6, 5};
 
   // Minimum compression ratios for initiate encoding
   double cratio_[10] = {0, 2, 2, 2, 2, 1.8, 1.6, 1.4, 1.2, 1.1};
 
   uint8_t hashlog_[10] = {0, HASH_LOG - 2, HASH_LOG - 1, HASH_LOG, HASH_LOG,
                           HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG, HASH_LOG};
   uint8_t hashlog = hashlog_[clevel];
   // Initialize the hash table to distances of 0
   for (unsigned i = 0; i < (1U << hashlog); i++) {
     htab[i] = 0;
   }
 
   /* input and output buffer cannot be less than 16 and 66 bytes or we can get into trouble */
   if (length < 16 || maxout < 66) {
     return 0;
   }
 
   /* When we go back in a match (shift), we obtain quite different compression properties.
    * It looks like 4 is more useful in combination with bitshuffle and small typesizes
    * (compress better and faster in e.g. `b2bench blosclz bitshuffle single 6 6291456 1 19`).
    * Fallback to 4 because it provides more consistent results on small itemsizes.
    *
    * In this block we also check cratios for the beginning of the buffers and
    * eventually discard those that are small (take too long to decompress).
    * This process is called _entropy probing_.
    */
   int ipshift = 4;
   int maxlen;  // maximum length for entropy probing
   int csize_3b;
   int csize_4b;
   double cratio = 0;
   switch (clevel) {
     case 1:
     case 2:
     case 3:
       maxlen = length / 8;
       csize_4b = get_csize(ibase, maxlen, false);
       cratio = (double)maxlen / csize_4b;
       break;
     case 4:
     case 5:
     case 6:
     case 7:
     case 8:
       maxlen = length / 8;
       csize_4b = get_csize(ibase, maxlen, false);
       cratio = (double)maxlen / csize_4b;
       break;
     case 9:
       // case 9 is special.  we need to asses the optimal shift
       maxlen = length / 8;
       csize_3b = get_csize(ibase, maxlen, true);
       csize_4b = get_csize(ibase, maxlen, false);
       ipshift = (csize_3b < csize_4b) ? 3 : 4;
       cratio = (csize_3b < csize_4b) ? ((double)maxlen / csize_3b) : ((double)maxlen / csize_4b);
       break;
     default:
       break;
   }
   // discard probes with small compression ratios (too expensive)
   if (cratio < cratio_ [clevel]) {
     goto out;
   }
 
   /* we start with literal copy */
   copy = 4;
   *op++ = MAX_COPY - 1;
   *op++ = *ip++;
   *op++ = *ip++;
   *op++ = *ip++;
   *op++ = *ip++;
 
   /* main loop */
   while (BLOSCLZ_LIKELY(ip < ip_limit)) {
     const uint8_t* ref;
     unsigned distance;
     uint8_t* anchor = ip;    /* comparison starting-point */
 
     /* find potential match */
     seq = BLOSCLZ_READU32(ip);
     HASH_FUNCTION(hval, seq, hashlog)
     ref = ibase + htab[hval];
 
     /* calculate distance to the match */
-    distance = anchor - ref;
+    distance = (unsigned int)(anchor - ref);
 
     /* update hash table */
     htab[hval] = (uint32_t) (anchor - ibase);
 
     if (distance == 0 || (distance >= MAX_FARDISTANCE)) {
       LITERAL(ip, op, op_limit, anchor, copy)
       continue;
     }
 
     /* is this a match? check the first 4 bytes */
     if (BLOSCLZ_UNLIKELY(BLOSCLZ_READU32(ref) == BLOSCLZ_READU32(ip))) {
       ref += 4;
     } else {
       /* no luck, copy as a literal */
       LITERAL(ip, op, op_limit, anchor, copy)
       continue;
     }
 
     /* last matched byte */
     ip = anchor + 4;
 
     /* distance is biased */
     distance--;
 
     /* get runs or matches; zero distance means a run */
     ip = get_run_or_match(ip, ip_bound, ref, !distance);
 
     /* length is biased, '1' means a match of 3 bytes */
     ip -= ipshift;
 
     unsigned len = (int)(ip - anchor);
     // If match is close, let's reduce the minimum length to encode it
     unsigned minlen = (clevel == 9) ? ipshift : minlen_[clevel];
 
     // Encoding short lengths is expensive during decompression
     // Encode only for reasonable lengths (extensive experiments done)
     if (len < minlen || (len <= 5 && distance >= MAX_DISTANCE)) {
       LITERAL(ip, op, op_limit, anchor, copy)
       continue;
     }
 
     /* if we have copied something, adjust the copy count */
     if (copy)
       /* copy is biased, '0' means 1 byte copy */
       *(op - copy - 1) = (uint8_t)(copy - 1);
     else
       /* back, to overwrite the copy count */
       op--;
     /* reset literal counter */
     copy = 0;
 
     /* encode the match */
     if (distance < MAX_DISTANCE) {
       if (len < 7) {
         MATCH_SHORT(op, op_limit, len, distance)
       } else {
         MATCH_LONG(op, op_limit, len, distance)
       }
     } else {
       /* far away, but not yet in the another galaxy... */
       distance -= MAX_DISTANCE;
       if (len < 7) {
         MATCH_SHORT_FAR(op, op_limit, len, distance)
       } else {
         MATCH_LONG_FAR(op, op_limit, len, distance)
       }
     }
 
     /* update the hash at match boundary */
     seq = BLOSCLZ_READU32(ip);
     HASH_FUNCTION(hval, seq, hashlog)
     htab[hval] = (uint32_t) (ip++ - ibase);
     seq >>= 8U;
     HASH_FUNCTION(hval, seq, hashlog)
     htab[hval] = (uint32_t) (ip++ - ibase);
     /* assuming literal copy */
 
     if (BLOSCLZ_UNLIKELY(op + 1 > op_limit))
       goto out;
     *op++ = MAX_COPY - 1;
   }
 
   /* left-over as literal copy */
   while (BLOSCLZ_UNLIKELY(ip <= ip_bound)) {
     if (BLOSCLZ_UNLIKELY(op + 2 > op_limit)) goto out;
     *op++ = *ip++;
     copy++;
     if (BLOSCLZ_UNLIKELY(copy == MAX_COPY)) {
       copy = 0;
       *op++ = MAX_COPY - 1;
     }
   }
 
   /* if we have copied something, adjust the copy length */
   if (copy)
     *(op - copy - 1) = (uint8_t)(copy - 1);
   else
     op--;
 
   /* marker for blosclz */
   *(uint8_t*)output |= (1U << 5U);
 
   return (int)(op - (uint8_t*)output);
 
   out:
   return 0;
 }
 
 // See https://habr.com/en/company/yandex/blog/457612/
 #ifdef __AVX2__
 
 #if defined(_MSC_VER)
 #define ALIGNED_(x) __declspec(align(x))
 #else
 #if defined(__GNUC__)
 #define ALIGNED_(x) __attribute__ ((aligned(x)))
 #endif
 #endif
 #define ALIGNED_TYPE_(t, x) t ALIGNED_(x)
diff --git a/blosc/btune.h b/blosc/btune.h
index e1504797..bb301b71 100644
--- a/blosc/btune.h
+++ b/blosc/btune.h
@@ -34,20 +34,21 @@ void btune_free(blosc2_context * context);
 /* Conditions for splitting a block before compressing with a codec. */
 static int split_block(blosc2_context* context, int32_t typesize,
                        int32_t blocksize, bool extended_header) {
   // Normally all the compressors designed for speed benefit from a split.
   int compcode = context->compcode;
   bool shuffle = context->filter_flags & BLOSC_DOSHUFFLE;
   return (
     // fast codecs like blosclz prefer to split with shuffle
-    ((compcode == BLOSC_BLOSCLZ && shuffle) ||
+    (
+     (compcode == BLOSC_BLOSCLZ && shuffle) ||
      // Generally, LZ4 without IPP works better without splitting blocks
      //(compcode == BLOSC_LZ4  && shuffle) ||
      // For forward compatibility with Blosc1 (http://blosc.org/posts/new-forward-compat-policy/)
      (!extended_header && compcode == BLOSC_LZ4HC) ||
      (!extended_header && compcode == BLOSC_ZLIB) ||
      (compcode == BLOSC_SNAPPY)) &&
      (typesize <= MAX_STREAMS) &&
      (blocksize / typesize) >= BLOSC_MIN_BUFFERSIZE);
 }
 
 #endif  /* BTUNE_H */
diff --git a/blosc/context.h b/blosc/context.h
index e5ebe692..0a150b07 100644
--- a/blosc/context.h
+++ b/blosc/context.h
@@ -35,92 +35,94 @@
 struct blosc2_context_s {
   const uint8_t* src;
   /* The source buffer */
   uint8_t* dest;
   /* The destination buffer */
   uint8_t header_flags;
   /* Flags for header */
   uint8_t blosc2_flags;
   /* Flags specific for blosc2 */
   int32_t sourcesize;
   /* Number of bytes in source buffer */
+  int32_t header_overhead;
+  /* The number of bytes in chunk header */
   int32_t nblocks;
   /* Number of total blocks in buffer */
   int32_t leftover;
   /* Extra bytes at end of buffer */
   int32_t blocksize;
   /* Length of the block in bytes */
   int32_t output_bytes;
   /* Counter for the number of input bytes */
   int32_t srcsize;
   /* Counter for the number of output bytes */
   int32_t destsize;
   /* Maximum size for destination buffer */
   int32_t typesize;
   /* Type size */
   int32_t* bstarts;
   /* Starts for every block inside the compressed buffer */
   int compcode;
   /* Compressor code to use */
   int clevel;
   /* Compression level (1-9) */
   int use_dict;
   /* Whether to use dicts or not */
   void* dict_buffer;
   /* The buffer to keep the trained dictionary */
-  size_t dict_size;
+  int32_t dict_size;
   /* The size of the trained dictionary */
   void* dict_cdict;
   /* The dictionary in digested form for compression */
   void* dict_ddict;
   /* The dictionary in digested form for decompression */
   uint8_t filter_flags;
   /* The filter flags in the filter pipeline */
   uint8_t filters[BLOSC2_MAX_FILTERS];
   /* the (sequence of) filters */
   uint8_t filters_meta[BLOSC2_MAX_FILTERS];
   /* the metainfo for filters */
   blosc2_prefilter_fn prefilter;
   /* prefilter function */
   blosc2_prefilter_params *pparams;
   /* prefilter params */
   bool* block_maskout;
   /* The blocks that are not meant to be decompressed.
    * If NULL (default), all blocks in a chunk should be read. */
   int block_maskout_nitems;
   /* The number of items in block_maskout array (must match
    * the number of blocks in chunk) */
   blosc2_schunk* schunk;
   /* Associated super-chunk (if available) */
   struct thread_context* serial_context;
   /* Cache for temporaries for serial operation */
   int do_compress;
   /* 1 if we are compressing, 0 if decompressing */
   void *btune;
   /* Entry point for BTune persistence between runs */
 
   /* Threading */
   int nthreads;
   int new_nthreads;
   int threads_started;
   int end_threads;
   pthread_t *threads;
   struct thread_context *thread_contexts; /* only for user-managed threads */
   pthread_mutex_t count_mutex;
 #ifdef BLOSC_POSIX_BARRIERS
   pthread_barrier_t barr_init;
   pthread_barrier_t barr_finish;
 #else
   int count_threads;
   pthread_mutex_t count_threads_mutex;
   pthread_cond_t count_threads_cv;
 #endif
 #if !defined(_WIN32)
   pthread_attr_t ct_attr;      /* creation time attrs for threads */
 #endif
   int thread_giveup_code;
   /* error code when give up */
   int thread_nblock;       /* block counter */
   int dref_not_init;       /* data ref in delta not initialized */
   pthread_mutex_t delta_mutex;
   pthread_cond_t delta_cv;
 };
diff --git a/blosc/eframe.c b/blosc/eframe.c
index f3f211d0..1ae1afa9 100644
--- a/blosc/eframe.c
+++ b/blosc/eframe.c
@@ -37,22 +37,22 @@
 
 
 /* Append an existing chunk into an extended frame. */
-void* eframe_append_chunk(blosc2_frame* frame, uint8_t* chunk, int32_t nchunk, int64_t cbytes) {
+void* eframe_create_chunk(blosc2_frame* frame, uint8_t* chunk, int32_t nchunk, int64_t cbytes) {
   // Get directory/nchunk.chunk with 8 zeros of padding
   char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(".chunk") + 1);
   sprintf(chunkpath, "%s/%08X.chunk", frame->urlpath, nchunk);
   FILE* fpc = fopen(chunkpath, "wb");
   free(chunkpath);
 
   size_t wbytes = fwrite(chunk, 1, (size_t)cbytes, fpc);
   fclose(fpc);
   if (wbytes != (size_t)cbytes) {
     BLOSC_TRACE_ERROR("Cannot write the full chunk.");
     return NULL;
   }
 
   return frame;
 }
 
 
 /*Get chunk from extended frame. */
diff --git a/blosc/eframe.h b/blosc/eframe.h
index ccaa1232..b32cbd73 100644
--- a/blosc/eframe.h
+++ b/blosc/eframe.h
@@ -10,7 +10,7 @@
 #define BLOSC_EFRAME_H
 
 
-void* eframe_append_chunk(blosc2_frame* frame, uint8_t* chunk, int32_t nchunk, int64_t cbytes);
+void* eframe_create_chunk(blosc2_frame* frame, uint8_t* chunk, int32_t nchunk, int64_t cbytes);
 int eframe_get_chunk(blosc2_frame* frame, int32_t nchunk, uint8_t** chunk, bool* needs_free);
 
 #endif //BLOSC_EFRAME_H
\ No newline at end of file
diff --git a/blosc/frame.c b/blosc/frame.c
index 27845444..0fb300cd 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -1,83 +1,84 @@
 /*********************************************************************
   Blosc - Blocked Shuffling and Compression Library
 
   Author: The Blosc Developers <blosc@blosc.org>
   Creation date: 2018-07-04
 
   See LICENSE.txt for details about copyright and rights to use.
 **********************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <assert.h>
 #include <stdbool.h>
 #include <sys/stat.h>
 #include "blosc2.h"
 #include "blosc-private.h"
 #include "context.h"
 #include "frame.h"
 #include "eframe.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #include <windows.h>
   #include <malloc.h>
 
 /* stdint.h only available in VS2010 (VC++ 16.0) and newer */
   #if defined(_MSC_VER) && _MSC_VER < 1600
     #include "win32/stdint-windows.h"
   #else
     #include <stdint.h>
   #endif
 
   #define fseek _fseeki64
 
 #endif  /* _WIN32 */
 
 /* If C11 is supported, use it's built-in aligned allocation. */
 #if __STDC_VERSION__ >= 201112L
 #include <stdalign.h>
 #endif
 
 
 // big <-> little-endian and store it in a memory position.  Sizes supported: 1, 2, 4, 8 bytes.
 void swap_store(void *dest, const void *pa, int size) {
-    uint8_t* pa_ = (uint8_t*)pa;
-    uint8_t* pa2_ = malloc((size_t)size);
-
     bool little_endian = is_little_endian();
     if (little_endian) {
-        switch (size) {
-            case 8:
-                pa2_[0] = pa_[7];
-                pa2_[1] = pa_[6];
-                pa2_[2] = pa_[5];
-                pa2_[3] = pa_[4];
-                pa2_[4] = pa_[3];
-                pa2_[5] = pa_[2];
-                pa2_[6] = pa_[1];
-                pa2_[7] = pa_[0];
-                break;
-            case 4:
-                pa2_[0] = pa_[3];
-                pa2_[1] = pa_[2];
-                pa2_[2] = pa_[1];
-                pa2_[3] = pa_[0];
-                break;
-            case 2:
-                pa2_[0] = pa_[1];
-                pa2_[1] = pa_[0];
-                break;
-            case 1:
-                pa2_[0] = pa_[1];
-                break;
-            default:
-              BLOSC_TRACE_ERROR("Unhandled size: %d.", size);
-        }
+      memcpy(dest, pa, size);
+    }
+    else {
+      uint8_t* pa_ = (uint8_t*)pa;
+      uint8_t* pa2_ = malloc((size_t)size);
+      switch (size) {
+        case 8:
+          pa2_[0] = pa_[7];
+          pa2_[1] = pa_[6];
+          pa2_[2] = pa_[5];
+          pa2_[3] = pa_[4];
+          pa2_[4] = pa_[3];
+          pa2_[5] = pa_[2];
+          pa2_[6] = pa_[1];
+          pa2_[7] = pa_[0];
+          break;
+      case 4:
+          pa2_[0] = pa_[3];
+          pa2_[1] = pa_[2];
+          pa2_[2] = pa_[1];
+          pa2_[3] = pa_[0];
+          break;
+      case 2:
+          pa2_[0] = pa_[1];
+          pa2_[1] = pa_[0];
+          break;
+      case 1:
+          pa2_[0] = pa_[1];
+          break;
+      default:
+        BLOSC_TRACE_ERROR("Unhandled size: %d.", size);
     }
     memcpy(dest, pa2_, size);
     free(pa2_);
+  }
 }
 
 
 /* Create a new (empty) frame */
@@ -115,264 +116,264 @@ int blosc2_frame_free(blosc2_frame *frame) {
 void *new_header_frame(blosc2_schunk *schunk, blosc2_frame *frame) {
   if (frame == NULL) {
     return NULL;
   }
   uint8_t* h2 = calloc(FRAME_HEADER_MINLEN, 1);
   uint8_t* h2p = h2;
 
   // The msgpack header starts here
   *h2p = 0x90;  // fixarray...
   *h2p += 13;   // ...with 13 elements
   h2p += 1;
 
   // Magic number
   *h2p = 0xa0 + 8;  // str with 8 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
   strcpy((char*)h2p, "b2frame");
   h2p += 8;
 
   // Header size
   *h2p = 0xd2;  // int32
   h2p += 1 + 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Total frame size
   *h2p = 0xcf;  // uint64
   // Fill it with frame->len which is known *after* the creation of the frame (e.g. when updating the header)
   int64_t flen = frame->len;
   swap_store(h2 + FRAME_LEN, &flen, sizeof(flen));
   h2p += 1 + 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Flags
   *h2p = 0xa0 + 4;  // str with 4 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // General flags
   *h2p = BLOSC2_VERSION_FRAME_FORMAT;  // version
-  *h2p += 0x20;  // 64-bit offsets
+  *h2p += 0x10;  // 64-bit offsets.  We only support this for now.
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Reserved flags
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Codec flags
   *h2p = schunk->compcode;
   *h2p += (schunk->clevel) << 4u;  // clevel
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Reserved flags
   *h2p = 0;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Uncompressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t nbytes = schunk->nbytes;
   swap_store(h2p, &nbytes, sizeof(nbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Compressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t cbytes = schunk->cbytes;
   swap_store(h2p, &cbytes, sizeof(cbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Type size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t typesize = schunk->typesize;
   swap_store(h2p, &typesize, sizeof(typesize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Chunk size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t chunksize = schunk->chunksize;
   swap_store(h2p, &chunksize, sizeof(chunksize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for compression
   *h2p = 0xd1;  // int16
   h2p += 1;
   int16_t nthreads = (int16_t)schunk->cctx->nthreads;
   swap_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for decompression
   *h2p = 0xd1;  // int16
   h2p += 1;
   nthreads = (int16_t)schunk->dctx->nthreads;
   swap_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // The boolean for FRAME_HAS_USERMETA
   *h2p = (schunk->usermeta_len > 0) ? (uint8_t)0xc3 : (uint8_t)0xc2;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // The space for FRAME_FILTER_PIPELINE
   *h2p = 0xd8;  //  fixext 16
   h2p += 1;
   if (BLOSC2_MAX_FILTERS > FRAME_FILTER_PIPELINE_MAX) {
     return NULL;
   }
   // Store the filter pipeline in header
   uint8_t* mp_filters = h2 + FRAME_FILTER_PIPELINE + 1;
   uint8_t* mp_meta = h2 + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
   int nfilters = 0;
   for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
     if (schunk->filters[i] != BLOSC_NOFILTER) {
       mp_filters[nfilters] = schunk->filters[i];
       mp_meta[nfilters] = schunk->filters_meta[i];
       nfilters++;
     }
   }
   *h2p = (uint8_t)nfilters;
   h2p += 1;
   h2p += 16;
   if (h2p - h2 != FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   int32_t hsize = FRAME_HEADER_MINLEN;
 
   // Now, deal with metalayers
   int16_t nmetalayers = schunk->nmetalayers;
 
   // Make space for the header of metalayers (array marker, size, map of offsets)
   h2 = realloc(h2, (size_t)hsize + 1 + 1 + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // The msgpack header for the metalayers (array_marker, size, map of offsets, list of metalayers)
   *h2p = 0x90 + 3;  // array with 3 elements
   h2p += 1;
 
   // Size for the map (index) of offsets, including this uint16 size (to be filled out later on)
   *h2p = 0xcd;  // uint16
   h2p += 1 + 2;
 
   // Map (index) of offsets for optional metalayers
   *h2p = 0xde;  // map 16 with N keys
   h2p += 1;
   swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   int32_t current_header_len = (int32_t)(h2p - h2);
   int32_t *offtooff = malloc(nmetalayers * sizeof(int32_t));
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     uint8_t namelen = (uint8_t) strlen(metalayer->name);
     h2 = realloc(h2, (size_t)current_header_len + 1 + namelen + 1 + 4);
     h2p = h2 + current_header_len;
     // Store the metalayer
     if (namelen >= (1U << 5U)) {  // metalayer strings cannot be longer than 32 bytes
       return NULL;
     }
     *h2p = (uint8_t)0xa0 + namelen;  // str
     h2p += 1;
     memcpy(h2p, metalayer->name, namelen);
     h2p += namelen;
     // Space for storing the offset for the value of this metalayer
     *h2p = 0xd2;  // int32
     h2p += 1;
     offtooff[nmetalayer] = (int32_t)(h2p - h2);
     h2p += 4;
     current_header_len += 1 + namelen + 1 + 4;
   }
   int32_t hsize2 = (int32_t)(h2p - h2);
   if (hsize2 != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Map size + int16 size
   if ((uint32_t) (hsize2 - hsize) >= (1U << 16U)) {
     return NULL;
   }
   uint16_t map_size = (uint16_t) (hsize2 - hsize);
   swap_store(h2 + FRAME_IDX_SIZE, &map_size, sizeof(map_size));
 
   // Make space for an (empty) array
   hsize = (int32_t)(h2p - h2);
   h2 = realloc(h2, (size_t)hsize + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // Now, store the values in an array
   *h2p = 0xdc;  // array 16 with N elements
   h2p += 1;
   swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   current_header_len = (int32_t)(h2p - h2);
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     h2 = realloc(h2, (size_t)current_header_len + 1 + 4 + metalayer->content_len);
     h2p = h2 + current_header_len;
     // Store the serialized contents for this metalayer
     *h2p = 0xc6;  // bin32
     h2p += 1;
     swap_store(h2p, &(metalayer->content_len), sizeof(metalayer->content_len));
     h2p += 4;
     memcpy(h2p, metalayer->content, metalayer->content_len);  // buffer, no need to swap
     h2p += metalayer->content_len;
     // Update the offset now that we know it
     swap_store(h2 + offtooff[nmetalayer], &current_header_len, sizeof(current_header_len));
     current_header_len += 1 + 4 + metalayer->content_len;
   }
   free(offtooff);
   hsize = (int32_t)(h2p - h2);
   if (hsize != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Set the length of the whole header now that we know it
   swap_store(h2 + FRAME_HEADER_LEN, &hsize, sizeof(hsize));
 
   return h2;
 }
@@ -381,107 +382,106 @@ void *new_header_frame(blosc2_schunk *schunk, blosc2_frame *frame) {
 int get_header_info(blosc2_frame *frame, int32_t *header_len, int64_t *frame_len, int64_t *nbytes,
                     int64_t *cbytes, int32_t *chunksize, int32_t *nchunks, int32_t *typesize,
                     uint8_t *compcode, uint8_t *clevel, uint8_t *filters, uint8_t *filters_meta) {
   uint8_t* framep = frame->sdata;
   uint8_t header[FRAME_HEADER_MINLEN];
 
   if (frame->len <= 0) {
     return -1;
   }
 
   if (frame->sdata == NULL) {
     size_t rbytes = 0;
     FILE* fp = NULL;
     if (frame->eframe) {
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb");
       free(eframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, FRAME_HEADER_MINLEN, fp);
       fclose(fp);
     }
     (void) rbytes;
     if (rbytes != FRAME_HEADER_MINLEN) {
       return -1;
     }
     framep = header;
   }
 
   // Fetch some internal lengths
   swap_store(header_len, framep + FRAME_HEADER_LEN, sizeof(*header_len));
   swap_store(frame_len, framep + FRAME_LEN, sizeof(*frame_len));
   swap_store(nbytes, framep + FRAME_NBYTES, sizeof(*nbytes));
   swap_store(cbytes, framep + FRAME_CBYTES, sizeof(*cbytes));
   swap_store(chunksize, framep + FRAME_CHUNKSIZE, sizeof(*chunksize));
   if (typesize != NULL) {
     swap_store(typesize, framep + FRAME_TYPESIZE, sizeof(*typesize));
   }
 
   if (*header_len > *frame_len) {
     BLOSC_TRACE_ERROR("Header length exceeds length of the frame.");
     return -1;
   }
 
   // Codecs
   uint8_t frame_codecs = framep[FRAME_CODECS];
   if (clevel != NULL) {
     *clevel = frame_codecs >> 4u;
   }
   if (compcode != NULL) {
     *compcode = frame_codecs & 0xFu;
   }
 
   // Filters
   if (filters != NULL && filters_meta != NULL) {
     uint8_t nfilters = framep[FRAME_FILTER_PIPELINE];
     if (nfilters > BLOSC2_MAX_FILTERS) {
       BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
       return -1;
     }
     uint8_t *filters_ = framep + FRAME_FILTER_PIPELINE + 1;
     uint8_t *filters_meta_ = framep + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
     for (int i = 0; i < nfilters; i++) {
       filters[i] = filters_[i];
       filters_meta[i] = filters_meta_[i];
     }
   }
 
   if (*nbytes > 0 && *chunksize > 0) {
     // We can compute the number of chunks only when the frame has actual data
     *nchunks = (int32_t) (*nbytes / *chunksize);
     if (*nbytes % *chunksize > 0) {
       if (*nchunks == INT32_MAX) {
         BLOSC_TRACE_ERROR("Number of chunks exceeds maximum allowed.");
         return -1;
       }
       *nchunks += 1;
     }
 
     // Sanity check for compressed sizes
-    if ((*cbytes < 0) || (*nbytes > 0 && *cbytes == 0) || ((int64_t)*nchunks * *chunksize < *nbytes)) {
+    if ((*cbytes < 0) || ((int64_t)*nchunks * *chunksize < *nbytes)) {
       BLOSC_TRACE_ERROR("Invalid compressed size in frame header.");
       return -1;
     }
   } else {
     *nchunks = 0;
   }
 
   return 0;
 }
 
 
-int64_t get_trailer_offset(blosc2_frame *frame, int32_t header_len, int64_t cbytes) {
-  if (cbytes == 0) {
+int64_t get_trailer_offset(blosc2_frame *frame, int32_t header_len, bool has_coffsets) {
+  if (!has_coffsets) {
     // No data chunks yet
     return header_len;
   }
-
   return frame->len - frame->trailer_len;
 }
 
 
 // Update the length in the header
@@ -518,229 +518,229 @@ int update_frame_len(blosc2_frame* frame, int64_t len) {
 int frame_update_trailer(blosc2_frame* frame, blosc2_schunk* schunk) {
   if (frame != NULL && frame->len == 0) {
     BLOSC_TRACE_ERROR("The trailer cannot be updated on empty frames.");
   }
 
   // Create the trailer in msgpack (see the frame format document)
   uint32_t trailer_len = FRAME_TRAILER_MINLEN + schunk->usermeta_len;
   uint8_t* trailer = (uint8_t*)calloc((size_t)trailer_len, 1);
   uint8_t* ptrailer = trailer;
   *ptrailer = 0x90 + 4;  // fixarray with 4 elements
   ptrailer += 1;
   // Trailer format version
   *ptrailer = FRAME_TRAILER_VERSION;
   ptrailer += 1;
   // usermeta
   *ptrailer = 0xc6;     // bin32
   ptrailer += 1;
   swap_store(ptrailer, &(schunk->usermeta_len), 4);
   ptrailer += 4;
   if (schunk->usermeta_len > 0)
     memcpy(ptrailer, schunk->usermeta, schunk->usermeta_len);
   ptrailer += schunk->usermeta_len;
   // Trailer length
   *ptrailer = 0xce;  // uint32
   ptrailer += 1;
   swap_store(ptrailer, &(trailer_len), sizeof(uint32_t));
   ptrailer += sizeof(uint32_t);
   // Up to 16 bytes for frame fingerprint (using XXH3 included in https://github.com/Cyan4973/xxHash)
   // Maybe someone would need 256-bit in the future, but for the time being 128-bit seems like a good tradeoff
   *ptrailer = 0xd8;  // fixext 16
   ptrailer += 1;
   *ptrailer = 0;  // fingerprint type: 0 -> no fp; 1 -> 32-bit; 2 -> 64-bit; 3 -> 128-bit
   ptrailer += 1;
   // Uncomment this when we compute an actual fingerprint
   // memcpy(ptrailer, xxh3_fingerprint, sizeof(xxh3_fingerprint));
   ptrailer += 16;
   // Sanity check
   if (ptrailer - trailer != trailer_len) {
     return -1;
   }
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return -1;
   }
 
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
+  int64_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
 
   // Update the trailer.  As there are no internal offsets to the trailer section,
   // and it is always at the end of the frame, we can just write (or overwrite) it
   // at the end of the frame.
   if (frame->sdata != NULL) {
     frame->sdata = realloc(frame->sdata, (size_t)(trailer_offset + trailer_len));
     if (frame->sdata == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return -1;
     }
     memcpy(frame->sdata + trailer_offset, trailer, trailer_len);
   }
   else {
     FILE* fp = NULL;
     if (frame->eframe) {
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     fseek(fp, trailer_offset, SEEK_SET);
     size_t wbytes = fwrite(trailer, 1, trailer_len, fp);
     fclose(fp);
     if (wbytes != (size_t)trailer_len) {
       BLOSC_TRACE_ERROR("Cannot write the trailer length in trailer.");
       return -2;
     }
   }
   free(trailer);
 
   int rc = update_frame_len(frame, trailer_offset + trailer_len);
   if (rc < 0) {
     return rc;
   }
   frame->len = trailer_offset + trailer_len;
   frame->trailer_len = trailer_len;
 
   return 1;
 }
 
 
 /* Create a frame out of a super-chunk. */
 int64_t blosc2_frame_from_schunk(blosc2_schunk *schunk, blosc2_frame *frame) {
   int32_t nchunks = schunk->nchunks;
   int64_t cbytes = schunk->cbytes;
   FILE* fp = NULL;
 
   uint8_t* h2 = new_header_frame(schunk, frame);
   if (h2 == NULL) {
     return -1;
   }
   uint32_t h2len;
   swap_store(&h2len, h2 + FRAME_HEADER_LEN, sizeof(h2len));
   // Build the offsets chunk
   int32_t chunksize = -1;
   int32_t off_cbytes = 0;
   uint64_t coffset = 0;
-  int32_t off_nbytes = nchunks * 8;
+  int32_t off_nbytes = nchunks * sizeof(int64_t);
   uint64_t* data_tmp = malloc(off_nbytes);
   bool needs_free = false;
   for (int i = 0; i < nchunks; i++) {
     uint8_t* data_chunk;
     if (frame->eframe) {
       eframe_get_chunk(frame, i, &data_chunk, &needs_free);
     }
     else {
       data_chunk = schunk->data[i];
     }
     int32_t chunk_cbytes = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
     data_tmp[i] = coffset;
     coffset += chunk_cbytes;
     int32_t chunksize_ = sw32_(data_chunk + BLOSC2_CHUNK_NBYTES);
     if (i == 0) {
       chunksize = chunksize_;
     }
     else if (chunksize != chunksize_) {
       // Variable size  // TODO: update flags for this (or do not use them at all)
       chunksize = 0;
     }
     if (needs_free) {
       free(data_chunk);
     }
   }
   if ((int64_t)coffset != cbytes) {
     return -1;
   }
   uint8_t *off_chunk = NULL;
   if (nchunks > 0) {
     // Compress the chunk of offsets
     off_chunk = malloc(off_nbytes + BLOSC_MAX_OVERHEAD);
     blosc2_context *cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
-    cctx->typesize = 8;
+    cctx->typesize = sizeof(int64_t);
     off_cbytes = blosc2_compress_ctx(cctx, data_tmp, off_nbytes, off_chunk,
                                      off_nbytes + BLOSC_MAX_OVERHEAD);
     blosc2_free_ctx(cctx);
     if (off_cbytes < 0) {
       free(off_chunk);
       free(h2);
       return -1;
     }
   }
   else {
     off_cbytes = 0;
   }
   free(data_tmp);
 
   // Now that we know them, fill the chunksize and frame length in header
   swap_store(h2 + FRAME_CHUNKSIZE, &chunksize, sizeof(chunksize));
   frame->len = h2len + cbytes + off_cbytes + FRAME_TRAILER_MINLEN + schunk->usermeta_len;
   if (frame->eframe) {
     frame->len = h2len + off_cbytes + FRAME_TRAILER_MINLEN + schunk->usermeta_len;
   }
   int64_t tbytes = frame->len;
   swap_store(h2 + FRAME_LEN, &tbytes, sizeof(tbytes));
 
   // Create the frame and put the header at the beginning
   if (frame->urlpath == NULL) {
     frame->sdata = malloc((size_t)frame->len);
     memcpy(frame->sdata, h2, h2len);
   }
   else {
     if (frame->eframe) {
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "wb");
       fwrite(h2, h2len, 1, fp);
       free(eframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "wb");
       fwrite(h2, h2len, 1, fp);
     }
   }
   free(h2);
 
   // Fill the frame with the actual data chunks
   if (!frame->eframe) {
     coffset = 0;
     for (int i = 0; i < nchunks; i++) {
       uint8_t* data_chunk = schunk->data[i];
       int32_t chunk_cbytes = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
       if (frame->urlpath == NULL) {
         memcpy(frame->sdata + h2len + coffset, data_chunk, (size_t)chunk_cbytes);
       } else {
         fwrite(data_chunk, (size_t)chunk_cbytes, 1, fp);
       }
       coffset += chunk_cbytes;
     }
     if ((int64_t)coffset != cbytes) {
       return -1;
     }
   }
 
   // Copy the offsets chunk at the end of the frame
   if (frame->urlpath == NULL) {
     memcpy(frame->sdata + h2len + cbytes, off_chunk, off_cbytes);
   }
   else {
     fwrite(off_chunk, (size_t)off_cbytes, 1, fp);
     fclose(fp);
   }
   free(off_chunk);
   int rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return frame->len;
 }
 
 
 /* Create an in-memory frame out of a super-chunk */
@@ -903,32 +903,50 @@ blosc2_frame* blosc2_frame_from_sframe(uint8_t *sframe, int64_t len, bool copy)
 // Get the compressed data offsets
 uint8_t* get_coffsets(blosc2_frame *frame, int32_t header_len, int64_t cbytes, int32_t *off_cbytes) {
   if (frame->coffsets != NULL) {
     if (off_cbytes != NULL) {
       *off_cbytes = *(int32_t *) (frame->coffsets + BLOSC2_CHUNK_CBYTES);
     }
     return frame->coffsets;
   }
   if (frame->sdata != NULL) {
     // For in-memory frames, the coffset is just one pointer away
     uint8_t* off_start = frame->sdata + header_len + cbytes;
     if (off_cbytes != NULL) {
       *off_cbytes = *(int32_t*) (off_start + BLOSC2_CHUNK_CBYTES);
     }
     return off_start;
   }
+
   int64_t trailer_offset = get_trailer_offset(frame, header_len, true);
-  int32_t coffsets_cbytes = (int32_t)(trailer_offset - (header_len + cbytes));
-  if (off_cbytes != NULL)
+  int32_t coffsets_cbytes;
+  if (frame->eframe) {
+    coffsets_cbytes = (int32_t) (trailer_offset - (header_len + 0));
+  }
+  else {
+    coffsets_cbytes = (int32_t) (trailer_offset - (header_len + cbytes));
+  }
+  if (off_cbytes != NULL) {
     *off_cbytes = coffsets_cbytes;
-  FILE* fp = fopen(frame->urlpath, "rb");
+  }
+  FILE* fp = NULL;
   uint8_t* coffsets = malloc((size_t)coffsets_cbytes);
-  fseek(fp, header_len + cbytes, SEEK_SET);
+  if (frame->eframe) {
+    char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
+    sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
+    fp = fopen(eframe_name, "rb");
+    free(eframe_name);
+    fseek(fp, header_len + 0, SEEK_SET);
+  }
+  else {
+    fp = fopen(frame->urlpath, "rb");
+    fseek(fp, header_len + cbytes, SEEK_SET);
+  }
   size_t rbytes = fread(coffsets, 1, (size_t)coffsets_cbytes, fp);
   fclose(fp);
   if (rbytes != (size_t)coffsets_cbytes) {
     BLOSC_TRACE_ERROR("Cannot read the offsets out of the fileframe.");
     return NULL;
   }
   frame->coffsets = coffsets;
   return coffsets;
 }
@@ -1022,87 +1040,87 @@ int frame_update_header(blosc2_frame* frame, blosc2_schunk* schunk, bool new) {
 /* Get the (compressed) usermeta chunk out of a frame */
 int32_t frame_get_usermeta(blosc2_frame* frame, uint8_t** usermeta) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
     return -1;
   }
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
+  int64_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
   if (trailer_offset < 0) {
     BLOSC_TRACE_ERROR("Unable to get the trailer offset from frame.");
     return -1;
   }
   if (trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET > frame_len) {
     BLOSC_TRACE_ERROR("Invalid trailer offset exceeds frame length.");
     return -1;
   }
 
   // Get the size of usermeta (inside the trailer)
   int32_t usermeta_len_network;
   if (frame->sdata != NULL) {
     memcpy(&usermeta_len_network, frame->sdata + trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, sizeof(int32_t));
   }
   else {
     FILE* fp = NULL;
     if (frame->eframe) {
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb");
       free(eframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, SEEK_SET);
     size_t rbytes = fread(&usermeta_len_network, 1, sizeof(int32_t), fp);
     fclose(fp);
     if (rbytes != sizeof(int32_t)) {
       BLOSC_TRACE_ERROR("Cannot access the usermeta_len out of the fileframe.");
       return -1;
     }
   }
   int32_t usermeta_len;
   swap_store(&usermeta_len, &usermeta_len_network, sizeof(int32_t));
 
   if (usermeta_len < 0) {
     BLOSC_TRACE_ERROR("Invalid usermeta length.");
     return -1;
   }
   if (usermeta_len == 0) {
     *usermeta = NULL;
     return 0;
   }
 
   *usermeta = malloc(usermeta_len);
   if (frame->sdata != NULL) {
     memcpy(*usermeta, frame->sdata + trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, usermeta_len);
   }
   else {
     FILE* fp = NULL;
     if (frame->eframe) {
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, SEEK_SET);
     size_t rbytes = fread(*usermeta, 1, usermeta_len, fp);
     fclose(fp);
     if (rbytes != (size_t)usermeta_len) {
       BLOSC_TRACE_ERROR("Cannot read the complete usermeta chunk in frame. %ld != %ld.",
               (long)rbytes, (long)usermeta_len);
       return -1;
     }
   }
 
   return usermeta_len;
 }
@@ -1256,199 +1274,200 @@ int frame_get_metalayers(blosc2_frame* frame, blosc2_schunk* schunk) {
 /* Get a super-chunk out of a frame */
 blosc2_schunk* blosc2_frame_to_schunk(blosc2_frame* frame, bool copy) {
   int32_t header_len;
   int64_t frame_len;
 
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->frame = frame;
   int ret = get_header_info(frame, &header_len, &frame_len, &schunk->nbytes, &schunk->cbytes,
                             &schunk->chunksize, &schunk->nchunks, &schunk->typesize,
                             &schunk->compcode, &schunk->clevel, schunk->filters, schunk->filters_meta);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     free(schunk);
     return NULL;
   }
   int32_t nchunks = schunk->nchunks;
   int64_t nbytes = schunk->nbytes;
   (void) nbytes;
   int64_t cbytes = schunk->cbytes;
 
   // Compression and decompression contexts
   blosc2_cparams *cparams;
   blosc2_schunk_get_cparams(schunk, &cparams);
   schunk->cctx = blosc2_create_cctx(*cparams);
   free(cparams);
   blosc2_dparams *dparams;
   blosc2_schunk_get_dparams(schunk, &dparams);
   schunk->dctx = blosc2_create_dctx(*dparams);
   free(dparams);
 
   if (!copy) {
     goto out;
   }
 
   // We are not attached to a frame anymore
   schunk->frame = NULL;
 
   if (nchunks == 0) {
     goto out;
   }
 
   // Get the compressed offsets
   int32_t coffsets_cbytes = 0;
   uint8_t* coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
   if (coffsets == NULL) {
     blosc2_free_ctx(schunk->cctx);
     blosc2_free_ctx(schunk->dctx);
     free(schunk);
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     return NULL;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int64_t* offsets = (int64_t *) malloc((size_t)nchunks * 8);
-  int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
+  int32_t off_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
+                                             offsets, nchunks * sizeof(int64_t));
   blosc2_free_ctx(dctx);
   if (off_nbytes < 0) {
     free(offsets);
     blosc2_free_ctx(schunk->cctx);
     blosc2_free_ctx(schunk->dctx);
     free(schunk);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return NULL;
   }
 
   // We want the sequential schunk, so create the actual data chunks (and, while doing this,
   // get a guess at the blocksize used in this frame)
   int64_t acc_nbytes = 0;
   int64_t acc_cbytes = 0;
   int32_t blocksize = 0;
   int32_t csize = 0;
   uint8_t* data_chunk = NULL;
   int32_t prev_alloc = BLOSC_MIN_HEADER_LENGTH;
   FILE* fp = NULL;
   if (frame->sdata == NULL) {
     data_chunk = malloc((size_t)prev_alloc);
     if (!frame->eframe) {
       // If not the chunks won't be in the frame
       fp = fopen(frame->urlpath, "rb");
       if (fp == NULL) {
         free(offsets);
         blosc2_free_ctx(schunk->cctx);
         blosc2_free_ctx(schunk->dctx);
         free(schunk);
         return NULL;
       }
     }
   }
   schunk->data = malloc(nchunks * sizeof(void*));
   for (int i = 0; i < nchunks; i++) {
     if (frame->sdata != NULL) {
       data_chunk = frame->sdata + header_len + offsets[i];
       csize = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
     }
     else {
       size_t rbytes;
       bool needs_free = false;
       if (frame->eframe) {
         rbytes = eframe_get_chunk(frame, offsets[i], &data_chunk, &needs_free);
       }
       else {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, BLOSC_MIN_HEADER_LENGTH, fp);
         if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
           fclose(fp);
           return NULL;
         }
       }
       if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
         if (frame->eframe) {
           free(data_chunk);
         }
         else {
           fclose(fp);
         }
         free(offsets);
         blosc2_free_ctx(schunk->cctx);
         blosc2_free_ctx(schunk->dctx);
         free(schunk);
         return NULL;
       }
       csize = sw32_(data_chunk + BLOSC2_CHUNK_CBYTES);
       if (csize > prev_alloc) {
         data_chunk = realloc(data_chunk, (size_t)csize);
         prev_alloc = csize;
       }
       if (!frame->eframe) {
         fseek(fp, header_len + offsets[i], SEEK_SET);
         rbytes = fread(data_chunk, 1, (size_t)csize, fp);
         if (rbytes != (size_t)csize) {
           fclose(fp);
           free(offsets);
           blosc2_free_ctx(schunk->cctx);
           blosc2_free_ctx(schunk->dctx);
           free(schunk);
           return NULL;
         }
       }
     }
     uint8_t* new_chunk = malloc((size_t)csize);
     memcpy(new_chunk, data_chunk, (size_t)csize);
     schunk->data[i] = new_chunk;
     acc_nbytes += sw32_(data_chunk + BLOSC2_CHUNK_NBYTES);
     acc_cbytes += csize;
     int32_t blocksize_ = sw32_(data_chunk + BLOSC2_CHUNK_BLOCKSIZE);
     if (i == 0) {
       blocksize = blocksize_;
     }
     else if (blocksize != blocksize_) {
       // Blocksize varies
       blocksize = 0;
     }
   }
   schunk->blocksize = blocksize;
 
   if (frame->sdata == NULL) {
     free(data_chunk);
     if (!frame->eframe) {
       fclose(fp);
     }
   }
   free(offsets);
 
   if (acc_nbytes != nbytes || acc_cbytes != cbytes) {
     blosc2_free_ctx(schunk->cctx);
     blosc2_free_ctx(schunk->dctx);
     free(schunk);
     return NULL;
   }
 
   uint8_t* usermeta;
   int32_t usermeta_len;
 
   int rc;
   out:
   rc = frame_get_metalayers(frame, schunk);
   if (rc < 0) {
     blosc2_free_ctx(schunk->cctx);
     blosc2_free_ctx(schunk->dctx);
     free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the metalayers.");
     return NULL;
   }
 
   usermeta_len = frame_get_usermeta(frame, &usermeta);
   if (usermeta_len < 0) {
     blosc2_free_ctx(schunk->cctx);
     blosc2_free_ctx(schunk->dctx);
     free(schunk);
     BLOSC_TRACE_ERROR("Cannot access the usermeta chunk.");
     return NULL;
   }
   schunk->usermeta = usermeta;
   schunk->usermeta_len = usermeta_len;
 
   return schunk;
 }
@@ -1470,867 +1489,991 @@ int sort_offset(const void* a, const void* b) {
 int64_t get_coffset(blosc2_frame* frame, int32_t header_len, int64_t cbytes, int32_t nchunk) {
   // Get the offset to nchunk
   int64_t offset;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, NULL);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offset for chunk %d for the frame.", nchunk);
     return -3;
   }
 
+  // Get the 64-bit offset
   int rc = blosc_getitem(coffsets, nchunk, 1, &offset);
   if (rc < 0) {
-    size_t nbytes_, cbytes_, blocksize_;
-    blosc_cbuffer_sizes(coffsets, &nbytes_, &cbytes_, &blocksize_);
     BLOSC_TRACE_ERROR("Problems retrieving a chunk offset.");
     return -4;
   }
   return offset;
 }
 
+
+// Detect and return a chunk with special values in offsets (only zeros and NaNs)
+int frame_special_chunk(int64_t special_value, int32_t nbytes, int32_t typesize,
+                        uint8_t** chunk, int32_t cbytes, bool *needs_free) {
+  *chunk = malloc(cbytes);
+  *needs_free = true;
+
+  // Detect the kind of special value
+  uint64_t zeros_mask = (uint64_t) BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+  uint64_t nans_mask = (uint64_t) BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+  if (special_value & zeros_mask) {
+    int rc = blosc2_chunk_zeros(nbytes, typesize, *chunk, cbytes);
+    if (rc < 0) {
+      BLOSC_TRACE_ERROR("Error creating a zero chunk");
+      return -1;
+    }
+  }
+  else if (special_value & nans_mask) {
+    int rc = blosc2_chunk_nans(nbytes, typesize, *chunk, cbytes);
+    if (rc < 0) {
+      BLOSC_TRACE_ERROR("Error creating a nan chunk");
+      return -1;
+    }
+  }
+  else {
+    BLOSC_TRACE_ERROR("Special value not recognized: %lld", special_value);
+    return -1;
+  }
+
+  return 0;
+}
+
+
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (compressed) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that a pointer to the location in frame is returned
  * in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
 int frame_get_chunk(blosc2_frame *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
+  int32_t typesize;
+  int32_t chunk_cbytes;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
-                            NULL, NULL, NULL, NULL, NULL);
+                            &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return -1;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                     "('%d') in frame.", nchunk, nchunks);
     return -2;
   }
 
   // Get the offset to nchunk
   int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
+  if (offset < 0) {
+    // Special value
+    chunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
+    int rc = frame_special_chunk(offset, chunksize, typesize, chunk, chunk_cbytes, needs_free);
+    if (rc < 0) {
+      return rc;
+    }
+    goto end;
+  }
+
   if (frame->eframe) {
     // Sparse on-disk
     nchunk = offset;
     return eframe_get_chunk(frame, nchunk, chunk, needs_free);
   }
-  int32_t chunk_cbytes;
   if (frame->sdata == NULL) {
     FILE* fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + offset + BLOSC2_CHUNK_CBYTES, SEEK_SET);
     size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
     if (rbytes != sizeof(chunk_cbytes)) {
       BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the fileframe.");
       fclose(fp);
       return -5;
     }
     chunk_cbytes = sw32_(&chunk_cbytes);
     *chunk = malloc((size_t)chunk_cbytes);
     fseek(fp, header_len + offset, SEEK_SET);
     rbytes = fread(*chunk, 1, (size_t)chunk_cbytes, fp);
     fclose(fp);
     if (rbytes != (size_t)chunk_cbytes) {
       BLOSC_TRACE_ERROR("Cannot read the chunk out of the fileframe.");
       return -6;
     }
     *needs_free = true;
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->sdata + header_len + offset;
     chunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
+  end:
   return chunk_cbytes;
 }
 
 
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (lazy) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that the frame is in memory and that just a
  * pointer to the location of the chunk in memory is returned.
  *
  * The size of the (compressed, potentially lazy) chunk is returned.  If some problem is detected,
  * a negative code is returned instead.
 */
 int frame_get_lazychunk(blosc2_frame *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
+  int32_t typesize;
+  size_t lazychunk_cbytes;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
-                            NULL, NULL, NULL, NULL, NULL);
+                            &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return -1;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                       "('%d') in frame.", nchunk, nchunks);
     return -2;
   }
 
   // Get the offset to nchunk
   int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
-  size_t lazychunk_cbytes = 0;
+  if (offset < 0) {
+    // Special value
+    lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
+    int rc = frame_special_chunk(offset, chunksize, typesize, chunk,
+                                 (int32_t)lazychunk_cbytes, needs_free);
+    if (rc < 0) {
+      return rc;
+    }
+    goto end;
+  }
+
   if (frame->sdata == NULL) {
     // TODO: make this portable across different endianness
     // Get info for building a lazy chunk
     size_t chunk_nbytes;
     size_t chunk_cbytes;
     size_t chunk_blocksize;
     uint8_t header[BLOSC_MIN_HEADER_LENGTH];
     FILE* fp = NULL;
     if (frame->eframe) {
       // The chunk is not in the frame
       char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(".chunk") + 1);
-      sprintf(chunkpath, "%s/%08X.chunk", frame->urlpath, offset);
+      sprintf(chunkpath, "%s/%08X.chunk", frame->urlpath, (unsigned int)offset);
       fp = fopen(chunkpath, "rb");
       free(chunkpath);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
       fseek(fp, header_len + offset, SEEK_SET);
     }
     size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
     if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
       BLOSC_TRACE_ERROR("Cannot read the header for chunk in the fileframe.");
       fclose(fp);
       return -5;
     }
     blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
     size_t nblocks = chunk_nbytes / chunk_blocksize;
     size_t leftover_block = chunk_nbytes % chunk_blocksize;
     nblocks = leftover_block ? nblocks + 1 : nblocks;
     // Allocate space for lazy chunk (cbytes + trailer)
     size_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);
     lazychunk_cbytes = chunk_cbytes + trailer_len;
     *chunk = malloc(lazychunk_cbytes);
     *needs_free = true;
     // Read just the full header and bstarts section too (lazy partial length)
     if (frame->eframe) {
       fseek(fp, 0, SEEK_SET);
     }
     else {
       fseek(fp, header_len + offset, SEEK_SET);
     }
     size_t lazy_partial_len = BLOSC_EXTENDED_HEADER_LENGTH + nblocks * sizeof(int32_t);
     rbytes = fread(*chunk, 1, lazy_partial_len, fp);
     fclose(fp);
     if (rbytes != lazy_partial_len) {
       BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the fileframe.");
       return -6;
     }
 
     // Mark chunk as lazy
     uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;
     *blosc2_flags |= 0x08U;
 
     // Add the trailer (currently, nchunk + offset + block_csizes)
     *(int32_t*)(*chunk + chunk_cbytes) = nchunk;
     *(int64_t*)(*chunk + chunk_cbytes + sizeof(int32_t)) = header_len + offset;
 
     int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));
 
     int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;
     if (memcpyed) {
       // When memcpyed the blocksizes are trivial to compute
       for (int i = 0; i < (int)nblocks; i++) {
         block_csizes[i] = (int)chunk_blocksize;
       }
     }
     else {
       // In regular, compressed chunks, we need to sort the bstarts (they can be out
       // of order because of multi-threading), and get a reverse index too.
       memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));
       // Helper structure to keep track of original indexes
       struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));
       for (int n = 0; n < (int)nblocks; n++) {
         csize_idx[n].val = block_csizes[n];
         csize_idx[n].idx = n;
       }
       qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);
       // Compute the actual csizes
       int idx;
       for (int n = 0; n < (int)nblocks - 1; n++) {
         idx = csize_idx[n].idx;
         block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;
       }
       idx = csize_idx[nblocks - 1].idx;
       block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;
       free(csize_idx);
     }
     // Copy the csizes at the end of the trailer
     void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);
     memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));
     free(block_csizes);
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->sdata + header_len + offset;
     lazychunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
+  end:
   return (int)lazychunk_cbytes;
 }
 
 
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame* frame, void* chunk, blosc2_schunk* schunk) {
+  int8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
-  int64_t trailer_len = frame->len - trailer_offset;
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t nbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
-  int64_t new_cbytes = cbytes + cbytes_chunk;
 
   if ((nchunks > 0) && (nbytes_chunk > chunksize)) {
     BLOSC_TRACE_ERROR("Appending chunks with a larger chunksize than frame is "
                       "not allowed yet %d != %d.", nbytes_chunk, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   if (chunksize == 0 && (nchunks > 0) && (nbytes_chunk < chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     int retcode = frame_get_lazychunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (retcode < 0) {
       BLOSC_TRACE_ERROR("Cannot get the last chunk (in position %d).",
                         nchunks - 1);
       return NULL;
     }
     int32_t last_nbytes = sw32_(last_chunk + BLOSC2_CHUNK_NBYTES);
     if (needs_free) {
       free(last_chunk);
     }
     if ((last_nbytes < chunksize) && (nbytes < chunksize)) {
       BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                         "than the frame chunksize is not allowed yet: %d != %d.",
                         nbytes_chunk, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
-  int32_t off_nbytes = (nchunks + 1) * 8;
+  int32_t off_nbytes = (nchunks + 1) * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
-    int32_t coffsets_cbytes = 0;
+    int32_t coffsets_cbytes;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
+    if (coffsets_cbytes == 0) {
+      coffsets_cbytes = cbytes;
+    }
+
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
-    int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
+    int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
+                                                nchunks * sizeof(int64_t));
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
-  if (frame->eframe) {
-    offsets[nchunks] = nchunks;
-  }
-  else {
-    offsets[nchunks] = cbytes;
+  int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+  uint64_t offset_value = ((uint64_t)1 << 63);
+  switch (special_value) {
+    case BLOSC2_ZERO_RUNLEN:
+      // Zero chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+      swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+      break;
+    case BLOSC2_NAN_RUNLEN:
+      // NaN chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
+      swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+      break;
+    default:
+      if (frame->eframe) {
+        offsets[nchunks] = nchunks;
+      }
+      else {
+        offsets[nchunks] = cbytes;
+      }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
-  cctx->typesize = 8;
+  cctx->typesize = sizeof(int64_t);  // 64-bit offsets
+  // The params below have been fine-tuned with the zero_runlen bench
+  cctx->nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
+  // cctx->compcode = BLOSC_LZ4;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
-          off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
+                                               off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
-//  // You may want to uncomment this code block for debugging
-//  int64_t offset;
-//  int rc2 = blosc_getitem(off_chunk, nchunks, 1, &offset);
-//  // Safety check.  This is cheap and can save time while debugging.
-//  if (rc2 != 8 || offset != cbytes) {
-//    fprintf(stderr, "Chunk offset has not being compressed correctly!\n");
-//    return NULL;
-//  }
-
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
-  int64_t new_frame_len = header_len + new_cbytes + new_off_cbytes + trailer_len;
+  int64_t new_cbytes = cbytes + cbytes_chunk;
+  int64_t new_frame_len;
   if (frame->eframe) {
-    new_frame_len = header_len + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
+  }
+  else {
+    new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->sdata != NULL) {
     uint8_t* framep = frame->sdata;
     /* Make space for the new chunk and copy it */
     frame->sdata = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     size_t wbytes;
     if (frame->eframe) {
-      //Create nchunks.chunk file
-      eframe_append_chunk(frame, chunk, nchunks, cbytes_chunk);
-      // fileframe
+      // Update the offsets chunk in the chunks frame
+      if (cbytes_chunk != 0) {
+        if (eframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
+          BLOSC_TRACE_ERROR("Cannot write the full chunk.");
+          return NULL;
+        }
+      }
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
       fseek(fp, header_len, SEEK_SET);
       wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     }
     else {
-      // fileframe
+      // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
         fclose(fp);
         return NULL;
       }
       wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     }
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
       return NULL;
     }
   }
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
-  free(chunk);
+  free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
 
 
 void* frame_insert_chunk(blosc2_frame* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
+  uint8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
-  int64_t trailer_len = frame->len - trailer_offset;
-
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
-  int32_t nbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_NBYTES);
-  int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
-  int64_t new_cbytes = cbytes + cbytes_chunk;
+  int32_t nbytes_chunk = sw32_(chunk_ + BLOSC2_CHUNK_NBYTES);
+  int32_t cbytes_chunk = sw32_(chunk_ + BLOSC2_CHUNK_CBYTES);
 
   // Get the current offsets
   int32_t off_nbytes = (nchunks + 1) * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // TODO: Improvement: Check if new chunk is smaller than previous one
 
   // Add the new offset
-  for (int i = nchunks; i > nchunk; i--) {
-    offsets[i] = offsets[i - 1];
-  }
-  if (frame->eframe) {
-    offsets[nchunk] = nchunks;
-  }
-  else {
-    offsets[nchunk] = cbytes;
+  int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+  uint64_t offset_value = ((uint64_t)1 << 63);
+  switch (special_value) {
+    case BLOSC2_ZERO_RUNLEN:
+      // Zero chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+      for (int i = nchunks; i > nchunk; i--) {
+        offsets[i] = offsets[i - 1];
+      }
+      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+          break;
+    case BLOSC2_NAN_RUNLEN:
+      // NaN chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
+      for (int i = nchunks; i > nchunk; i--) {
+        offsets[i] = offsets[i - 1];
+      }
+      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+      break;
+    default:
+      // Add the new offset
+      for (int i = nchunks; i > nchunk; i--) {
+        offsets[i] = offsets[i - 1];
+      }
+      if (frame->eframe) {
+        offsets[nchunk] = nchunks;
+      }
+      else {
+        offsets[nchunk] = cbytes;
+      }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
+  int64_t new_cbytes = cbytes + cbytes_chunk;
+
   int64_t new_frame_len;
   if (frame->eframe) {
-    new_frame_len = header_len + 0 + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
-    new_frame_len = header_len + new_cbytes + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
+  // Add the chunk and update meta
   FILE* fp = NULL;
   if (frame->sdata != NULL) {
     uint8_t* framep = frame->sdata;
     /* Make space for the new chunk and copy it */
     frame->sdata = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->eframe) {
-      if (eframe_append_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
-        BLOSC_TRACE_ERROR("Cannot write the full chunk.");
-        return NULL;
+      if (cbytes_chunk != 0) {
+        if (eframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
+          BLOSC_TRACE_ERROR("Cannot write the full chunk.");
+          return NULL;
+        }
       }
-      // Fileframe for updating the offsets chunk
+      // Update the offsets chunk in the chunks frame
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
-      // fileframe
+      // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
+  free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
 
 
 void* frame_update_chunk(blosc2_frame* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
+  uint8_t *chunk_ = (uint8_t *) chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("The chunk must already exist.");
     return NULL;
   }
 
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
-  int64_t trailer_len = frame->len - trailer_offset;
-
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t nbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
-  int64_t new_cbytes = cbytes + cbytes_chunk;
 
   // Get the current offsets
   int32_t off_nbytes = nchunks * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
-  // TODO: Improvement: Check if new chunk is smaller than previous one
-
-  if (frame->eframe) {
-    // In case there was a reorder
-    nchunk = offsets[nchunk];
-  }
-  else {
-    // Add the new offset
-    offsets[nchunk] = cbytes;
+  // Add the new offset
+  int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+  uint64_t offset_value = ((uint64_t)1 << 63);
+  switch (special_value) {
+    case BLOSC2_ZERO_RUNLEN:
+      // Zero chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
+      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+      break;
+    case BLOSC2_NAN_RUNLEN:
+      // NaN chunk.  Code it in a special way.
+      offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
+      swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
+      cbytes_chunk = 0;   // we don't need to store the chunk
+      break;
+    default:
+      if (frame->eframe) {
+        // In case there was a reorder
+        offsets[nchunk] = nchunk;
+      }
+      else {
+        // Add the new offset
+        offsets[nchunk] = cbytes;
+      }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
+  int64_t new_cbytes = schunk->cbytes;
   int64_t new_frame_len;
   if (frame->eframe) {
     // The chunk is not stored in the frame
-    new_frame_len = header_len + 0 + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
-    new_frame_len = header_len + new_cbytes + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->sdata != NULL) {
     uint8_t* framep = frame->sdata;
     /* Make space for the new chunk and copy it */
     frame->sdata = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->eframe) {
-      if (eframe_append_chunk(frame, chunk, nchunk, cbytes_chunk) == NULL) {
-        BLOSC_TRACE_ERROR("Cannot write the full chunk.");
-        return NULL;
+      if (cbytes_chunk) {
+        if (eframe_create_chunk(frame, chunk, nchunk, cbytes_chunk) == NULL) {
+          BLOSC_TRACE_ERROR("Cannot write the full chunk.");
+          return NULL;
+        }
       }
-      // Fileframe for updating the offsets chunk
+      // Update the offsets chunk in the chunks frame
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
-      // fileframe
+      // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
         BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
+  free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
 
 
-/* Decompress and return a chunk that is part of a frame. */
-int frame_decompress_chunk(blosc2_context *dctx, blosc2_frame *frame, int nchunk, void *dest, int32_t nbytes) {
-  uint8_t* src;
-  bool needs_free;
-  int chunk_cbytes;
-  if (frame->eframe) {
-    chunk_cbytes = frame_get_chunk(frame, nchunk, &src, &needs_free);
-  }
-  else {
-    // Use a lazychunk here in order to do a potential parallel read.
-    chunk_cbytes = frame_get_lazychunk(frame, nchunk, &src, &needs_free);
-  }
-  if (chunk_cbytes < 0) {
-    BLOSC_TRACE_ERROR("Cannot get the chunk in position %d.", nchunk);
-    return -1;
-  }
-  if (chunk_cbytes < sizeof(int32_t)) {
-    /* Not enough input to read `nbytes` */
-    return -1;
-  }
-
-  /* Create a buffer for destination */
-  int32_t nbytes_ = sw32_(src + BLOSC2_CHUNK_NBYTES);
-  if (nbytes_ > (int32_t)nbytes) {
-    BLOSC_TRACE_ERROR("Not enough space for decompressing in dest.");
-    return -1;
-  }
-  /* And decompress it */
-  int32_t chunksize = blosc2_decompress_ctx(dctx, src, chunk_cbytes, dest, nbytes);
-  if (chunksize < 0 || chunksize != nbytes_) {
-    BLOSC_TRACE_ERROR("Error in decompressing chunk.");
-    return -11;
-  }
-
-  if (needs_free) {
-    free(src);
-  }
-  return (int)chunksize;
-}
-
-int frame_reorder_offsets(blosc2_frame *frame, int *offsets_order, blosc2_schunk* schunk) {
+int frame_reorder_offsets(blosc2_frame* frame, int* offsets_order, blosc2_schunk* schunk) {
   // Get header info
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
 
   // Get the current offsets and add one more
-  int32_t off_nbytes = nchunks * 8;
+  int32_t off_nbytes = nchunks * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
 
   int32_t coffsets_cbytes = 0;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     return -1;
   }
 
-  int64_t trailer_offset = get_trailer_offset(frame, header_len, cbytes);
-  int64_t trailer_len = frame->len - trailer_offset;
-
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
-  int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
+  int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
+                                              offsets, off_nbytes);
   blosc2_free_ctx(dctx);
   if (prev_nbytes < 0) {
     free(offsets);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return -1;
   }
 
   // Make a copy of the chunk offsets and reorder it
   int64_t *offsets_copy = malloc(prev_nbytes);
   memcpy(offsets_copy, offsets, prev_nbytes);
 
   for (int i = 0; i < nchunks; ++i) {
     offsets[i] = offsets_copy[offsets_order[i]];
   }
   free(offsets_copy);
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
-  cctx->typesize = 8;
+  cctx->typesize = sizeof(int64_t);
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return -1;
   }
   free(offsets);
   int64_t new_frame_len;
   if (frame->eframe) {
     // The chunks are not in the frame
-    new_frame_len = header_len + 0 + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
-    new_frame_len = header_len + cbytes + new_off_cbytes + trailer_len;
+    new_frame_len = header_len + cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   if (frame->sdata != NULL) {
     uint8_t* framep = frame->sdata;
     /* Make space for the new chunk and copy it */
     frame->sdata = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return -1;
     }
     /* Copy the offsets */
     memcpy(framep + header_len + cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     FILE* fp = NULL;
     if (frame->eframe) {
-      // Fileframe for updating the offsets chunk
+      // Update the offsets chunk in the chunks frame
       char* eframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(eframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(eframe_name, "rb+");
       free(eframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
-      // fileframe
+      // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
     }
     size_t wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
       BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
       return -1;
     }
   }
+
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(off_chunk);
 
   frame->len = new_frame_len;
   int rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return -1;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return -1;
   }
 
   return 0;
 }
+
+
+/* Decompress and return a chunk that is part of a frame. */
+int frame_decompress_chunk(blosc2_context *dctx, blosc2_frame *frame, int nchunk, void *dest, int32_t nbytes) {
+  uint8_t* src;
+  bool needs_free;
+  int chunk_cbytes;
+  if (frame->eframe) {
+    chunk_cbytes = frame_get_chunk(frame, nchunk, &src, &needs_free);
+  }
+  else {
+    // Use a lazychunk here in order to do a potential parallel read.
+    chunk_cbytes = frame_get_lazychunk(frame, nchunk, &src, &needs_free);
+  }
+  if (chunk_cbytes < 0) {
+    BLOSC_TRACE_ERROR("Cannot get the chunk in position %d.", nchunk);
+    return -1;
+  }
+  if (chunk_cbytes < sizeof(int32_t)) {
+    /* Not enough input to read `nbytes` */
+    return -1;
+  }
+
+  /* Create a buffer for destination */
+  int32_t nbytes_ = sw32_(src + BLOSC2_CHUNK_NBYTES);
+  if (nbytes_ > (int32_t)nbytes) {
+    BLOSC_TRACE_ERROR("Not enough space for decompressing in dest.");
+    return -1;
+  }
+  /* And decompress it */
+  dctx->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
+  int32_t chunksize = blosc2_decompress_ctx(dctx, src, chunk_cbytes, dest, nbytes);
+  if (chunksize < 0 || chunksize != nbytes_) {
+    BLOSC_TRACE_ERROR("Error in decompressing chunk.");
+    return -11;
+  }
+
+  if (needs_free) {
+    free(src);
+  }
+  return (int)chunksize;
+}
diff --git a/blosc/frame.h b/blosc/frame.h
index 0bdd4bc8..f0dfa94c 100644
--- a/blosc/frame.h
+++ b/blosc/frame.h
@@ -43,13 +43,13 @@
 void* frame_append_chunk(blosc2_frame* frame, void* chunk, blosc2_schunk* schunk);
 void* frame_insert_chunk(blosc2_frame* frame, int nchunk, void* chunk, blosc2_schunk* schunk);
 void* frame_update_chunk(blosc2_frame* frame, int nchunk, void* chunk, blosc2_schunk* schunk);
+int frame_reorder_offsets(blosc2_frame *frame, int *offsets_order, blosc2_schunk* schunk);
+
 int frame_get_chunk(blosc2_frame *frame, int nchunk, uint8_t **chunk, bool *needs_free);
 int frame_get_lazychunk(blosc2_frame *frame, int nchunk, uint8_t **chunk, bool *needs_free);
 int frame_decompress_chunk(blosc2_context *dctx, blosc2_frame *frame, int nchunk,
                            void *dest, int32_t nbytes);
 
-int frame_reorder_offsets(blosc2_frame *frame, int *offsets_order, blosc2_schunk* schunk);
-
 int frame_update_header(blosc2_frame* frame, blosc2_schunk* schunk, bool new);
 int frame_update_trailer(blosc2_frame* frame, blosc2_schunk* schunk);
 
diff --git a/blosc/schunk.c b/blosc/schunk.c
index 6b746199..e48fd987 100644
--- a/blosc/schunk.c
+++ b/blosc/schunk.c
@@ -299,137 +299,163 @@ blosc2_schunk* blosc2_schunk_open_sframe(uint8_t *sframe, int64_t len) {
 /* Append an existing chunk into a super-chunk. */
 int blosc2_schunk_append_chunk(blosc2_schunk *schunk, uint8_t *chunk, bool copy) {
   int32_t nchunks = schunk->nchunks;
   int32_t nbytes = sw32_(chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes = sw32_(chunk + BLOSC2_CHUNK_CBYTES);
 
   if (schunk->chunksize == -1) {
     schunk->chunksize = nbytes;  // The super-chunk is initialized now
   }
   if (nbytes > schunk->chunksize) {
     BLOSC_TRACE_ERROR("Appending chunks that have different lengths in the same schunk "
                       "is not supported yet: %d > %d.", nbytes, schunk->chunksize);
     return -1;
   }
 
   /* Update counters */
   schunk->nchunks = nchunks + 1;
   schunk->nbytes += nbytes;
-  schunk->cbytes += cbytes;
-  // Update super-chunk or frame
   if (schunk->frame == NULL) {
-    if (schunk->storage->urlpath != NULL) {
-      BLOSC_TRACE_ERROR("The persistent sparse storage is not supported yet.");
-      return -1;
+    schunk->cbytes += cbytes;
+  } else {
+    // A frame
+    int special_value = (chunk[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+    switch (special_value) {
+      case BLOSC2_ZERO_RUNLEN:
+        schunk->cbytes += 0;
+            break;
+      case BLOSC2_NAN_RUNLEN:
+        schunk->cbytes += 0;
+            break;
+      default:
+        schunk->cbytes += cbytes;
     }
+  }
+
+  if (copy) {
+    // Make a copy of the chunk
+    uint8_t *chunk_copy = malloc(cbytes);
+    memcpy(chunk_copy, chunk, cbytes);
+    chunk = chunk_copy;
+  }
+
+  // Update super-chunk or frame
+  if (schunk->frame == NULL) {
     // Check that we are not appending a small chunk after another small chunk
     if ((schunk->nchunks > 0) && (nbytes < schunk->chunksize)) {
       uint8_t* last_chunk = schunk->data[nchunks - 1];
       int32_t last_nbytes = sw32_(last_chunk + BLOSC2_CHUNK_NBYTES);
       if ((last_nbytes < schunk->chunksize) && (nbytes < schunk->chunksize)) {
         BLOSC_TRACE_ERROR(
                 "Appending two consecutive chunks with a chunksize smaller than the schunk chunksize "
                 "is not allowed yet: %d != %d.", nbytes, schunk->chunksize);
         return -1;
       }
     }
 
-    if (copy) {
-        // Make a copy of the chunk
-        uint8_t *chunk_copy = malloc(cbytes);
-        memcpy(chunk_copy, chunk, cbytes);
-        chunk = chunk_copy;
-    }
-    else if (cbytes < nbytes) {
+    if (!copy && (cbytes < nbytes)) {
       // We still want to do a shrink of the chunk
       chunk = realloc(chunk, cbytes);
     }
 
     /* Make space for appending the copy of the chunk and do it */
     if ((nchunks + 1) * sizeof(void *) > schunk->data_len) {
       // Extend the data pointer by one memory page (4k)
       schunk->data_len += 4096;  // must be a multiple of sizeof(void*)
       schunk->data = realloc(schunk->data, schunk->data_len);
     }
     schunk->data[nchunks] = chunk;
   }
   else {
     if (frame_append_chunk(schunk->frame, chunk, schunk) == NULL) {
       BLOSC_TRACE_ERROR("Problems appending a chunk.");
       return -1;
     }
   }
-
-  /* printf("Compression chunk #%lld: %d -> %d (%.1fx)\n", */
-  /*         nchunks, nbytes, cbytes, (1.*nbytes) / cbytes); */
   return schunk->nchunks;
 }
 
 
 /* Insert an existing @p chunk in a specified position on a super-chunk */
 int blosc2_schunk_insert_chunk(blosc2_schunk *schunk, int nchunk, uint8_t *chunk, bool copy) {
   int32_t nchunks = schunk->nchunks;
   int32_t nbytes = sw32_(chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes = sw32_(chunk + BLOSC2_CHUNK_CBYTES);
 
   if (schunk->chunksize == -1) {
     schunk->chunksize = nbytes;  // The super-chunk is initialized now
   }
 
   if (nbytes > schunk->chunksize) {
     BLOSC_TRACE_ERROR("Inserting chunks that have different lengths in the same schunk "
                       "is not supported yet: %d > %d.", nbytes, schunk->chunksize);
     return -1;
   }
 
   /* Update counters */
   schunk->nchunks = nchunks + 1;
   schunk->nbytes += nbytes;
-  schunk->cbytes += cbytes;
+  if (schunk->frame == NULL) {
+    schunk->cbytes += cbytes;
+  } else {
+    // A frame
+    int special_value = (chunk[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+    switch (special_value) {
+      case BLOSC2_ZERO_RUNLEN:
+        schunk->cbytes += 0;
+            break;
+      case BLOSC2_NAN_RUNLEN:
+        schunk->cbytes += 0;
+            break;
+      default:
+        schunk->cbytes += cbytes;
+    }
+  }
+
+  if (copy) {
+    // Make a copy of the chunk
+    uint8_t *chunk_copy = malloc(cbytes);
+    memcpy(chunk_copy, chunk, cbytes);
+    chunk = chunk_copy;
+  }
 
   // Update super-chunk or frame
   if (schunk->frame == NULL) {
     // Check that we are not appending a small chunk after another small chunk
     if ((schunk->nchunks > 0) && (nbytes < schunk->chunksize)) {
       uint8_t* last_chunk = schunk->data[nchunks - 1];
       int32_t last_nbytes = sw32_(last_chunk + BLOSC2_CHUNK_NBYTES);
       if ((last_nbytes < schunk->chunksize) && (nbytes < schunk->chunksize)) {
         BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                           "than the schunk chunksize is not allowed yet:  %d != %d",
                           nbytes, schunk->chunksize);
         return -1;
       }
     }
 
-    if (copy) {
-      // Make a copy of the chunk
-      uint8_t *chunk_copy = malloc(cbytes);
-      memcpy(chunk_copy, chunk, cbytes);
-      chunk = chunk_copy;
-    }
-    else if (cbytes < nbytes) {
+    if (!copy && (cbytes < nbytes)) {
       // We still want to do a shrink of the chunk
       chunk = realloc(chunk, cbytes);
     }
 
     // Make space for appending the copy of the chunk and do it
     if ((nchunks + 1) * sizeof(void *) > schunk->data_len) {
       // Extend the data pointer by one memory page (4k)
       schunk->data_len += 4096;  // must be a multiple of sizeof(void*)
       schunk->data = realloc(schunk->data, schunk->data_len);
     }
 
     // Reorder the offsets and insert the new chunk
     for (int i = nchunks; i > nchunk; --i) {
       schunk->data[i] = schunk->data[i-1];
     }
     schunk->data[nchunk] = chunk;
   }
 
   else {
     if (frame_insert_chunk(schunk->frame, nchunk, chunk, schunk) == NULL) {
       BLOSC_TRACE_ERROR("Problems updating a chunk in a frame.");
       return -1;
     }
   }
   return schunk->nchunks;
 }
@@ -438,91 +464,124 @@ int blosc2_schunk_insert_chunk(blosc2_schunk *schunk, int nchunk, uint8_t *chunk
 int blosc2_schunk_update_chunk(blosc2_schunk *schunk, int nchunk, uint8_t *chunk, bool copy) {
   int32_t nbytes = sw32_(chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes = sw32_(chunk + BLOSC2_CHUNK_CBYTES);
 
   if (schunk->chunksize == -1) {
     schunk->chunksize = nbytes;  // The super-chunk is initialized now
   }
 
   if ((schunk->chunksize != 0) && (nbytes != schunk->chunksize)) {
     BLOSC_TRACE_ERROR("Inserting chunks that have different lengths in the same schunk "
                       "is not supported yet: %d > %d.", nbytes, schunk->chunksize);
     return -1;
   }
 
   bool needs_free;
   uint8_t *chunk_old;
   int err = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_old, &needs_free);
   if (err < 0) {
     BLOSC_TRACE_ERROR("%d chunk con not obtenined from schunk.", nchunk);
   }
   int32_t cbytes_old;
   int32_t nbytes_old;
 
   if (chunk_old == 0) {
     nbytes_old = 0;
     cbytes_old = 0;
   } else {
     nbytes_old = sw32_(chunk_old + BLOSC2_CHUNK_NBYTES);
     cbytes_old = sw32_(chunk_old + BLOSC2_CHUNK_CBYTES);
+    if (cbytes_old == BLOSC_MAX_OVERHEAD) {
+        cbytes_old = 0;
+    }
   }
   if (needs_free) {
     free(chunk_old);
   }
 
-  // Update super-chunk or frame
+  if (copy) {
+    // Make a copy of the chunk
+    uint8_t *chunk_copy = malloc(cbytes);
+    memcpy(chunk_copy, chunk, cbytes);
+    chunk = chunk_copy;
+  }
+
   if (schunk->frame == NULL) {
     /* Update counters */
     schunk->nbytes += nbytes;
     schunk->nbytes -= nbytes_old;
     schunk->cbytes += cbytes;
     schunk->cbytes -= cbytes_old;
-
-    if (copy) {
-      // Make a copy of the chunk
-      uint8_t *chunk_copy = malloc(cbytes);
-      memcpy(chunk_copy, chunk, cbytes);
-      chunk = chunk_copy;
+  } else {
+    // A frame
+    int special_value = (chunk[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
+    switch (special_value) {
+      case BLOSC2_ZERO_RUNLEN:
+        schunk->nbytes += nbytes;
+        schunk->nbytes -= nbytes_old;
+        if (schunk->frame->eframe) {
+          schunk->cbytes -= cbytes_old;
+        }
+        break;
+      case BLOSC2_NAN_RUNLEN:
+        schunk->nbytes += nbytes;
+        schunk->nbytes -= nbytes_old;
+        if (schunk->frame->eframe) {
+          schunk->cbytes -= cbytes_old;
+        }
+        break;
+      default:
+        /* Update counters */
+        schunk->nbytes += nbytes;
+        schunk->nbytes -= nbytes_old;
+        schunk->cbytes += cbytes;
+        if (schunk->frame->eframe) {
+          schunk->cbytes -= cbytes_old;
+        }
     }
-    else if (cbytes < nbytes) {
+  }
+
+  // Update super-chunk or frame
+  if (schunk->frame == NULL) {
+    if (!copy && (cbytes < nbytes)) {
       // We still want to do a shrink of the chunk
       chunk = realloc(chunk, cbytes);
     }
 
     // Free old chunk and add reference to new chunk
     if (schunk->data[nchunk] != 0) {
       free(schunk->data[nchunk]);
     }
     schunk->data[nchunk] = chunk;
   }
   else {
-    /* Update counters */
-    schunk->nbytes += nbytes;
-    schunk->cbytes += cbytes;
-
     if (frame_update_chunk(schunk->frame, nchunk, chunk, schunk) == NULL) {
         BLOSC_TRACE_ERROR("Problems updating a chunk in a frame.");
         return -1;
     }
   }
 
   return schunk->nchunks;
 }
 
 
 /* Append a data buffer to a super-chunk. */
 int blosc2_schunk_append_buffer(blosc2_schunk *schunk, void *src, int32_t nbytes) {
   uint8_t* chunk = malloc(nbytes + BLOSC_MAX_OVERHEAD);
   /* Compress the src buffer using super-chunk context */
   int cbytes = blosc2_compress_ctx(schunk->cctx, src, nbytes, chunk,
                                    nbytes + BLOSC_MAX_OVERHEAD);
   if (cbytes < 0) {
     free(chunk);
     return cbytes;
   }
   // We don't need a copy of the chunk, as it will be shrinked if necessary
   int nchunks = blosc2_schunk_append_chunk(schunk, chunk, false);
+  if (nchunks < 0) {
+    BLOSC_TRACE_ERROR("Error appending a buffer in super-chunk");
+    return nchunks;
+  }
 
   return nchunks;
 }
 
 /* Decompress and return a chunk that is part of a super-chunk. */
diff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt
index 1f03f5c2..6c20b63b 100644
--- a/examples/CMakeLists.txt
+++ b/examples/CMakeLists.txt
@@ -1,12 +1,17 @@
 # sources for examples
 set(SOURCES contexts delta_schunk_ex multithread simple frame_metalayers noinit find_roots)
 if(NOT DEACTIVATE_LZ4)
-    set(SOURCES ${SOURCES} schunk_simple frame_simple frame_big frame_backed_schunk compress_file eframe_simple)
+    set(SOURCES ${SOURCES} schunk_simple frame_simple eframe_simple frame_backed_schunk compress_file)
 endif()
 if(NOT DEACTIVATE_ZSTD)
     set(SOURCES ${SOURCES} zstd_dict)
 endif()
 
+if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "8")
+    # frame_big uses containers of more than 4 GB and cannot run on 32-bit platforms
+    set(SOURCES ${SOURCES} frame_big)
+endif()
+
 if(EXISTS btune_schunk.c)
     set(SOURCES ${SOURCES} btune_schunk.c)
 endif()
diff --git a/examples/compress_file.c b/examples/compress_file.c
index e9d04837..2a9e50f1 100644
--- a/examples/compress_file.c
+++ b/examples/compress_file.c
@@ -31,65 +31,65 @@
 
 int main(int argc, char* argv[]) {
   static int32_t data[CHUNKSIZE];
-  int32_t isize;
+  size_t isize;
   int64_t nbytes, cbytes;
   blosc_timestamp_t last, current;
   double ttotal;
 
   if (argc != 3) {
     fprintf(stderr, "Usage: compress_file input_file output_file.b2frame\n");
     return -1;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Create a super-chunk container */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = 1;
   cparams.compcode = BLOSC_BLOSCLZ;
   //cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = NTHREADS;
 
   /* Create a super-chunk backed by an in-memory frame */
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams,
                             .sequential=true, .urlpath=argv[2]};
   blosc2_schunk* schunk = blosc2_schunk_new(storage);
 
   // Compress the file
   blosc_set_timestamp(&last);
   FILE* finput = fopen(argv[1], "rb");
   if (finput == NULL) {
     printf("Input file cannot be open.");
     exit(1);
   }
-  while ((isize = fread(data, 1, CHUNKSIZE, finput)) == CHUNKSIZE) {
+  while ((isize = (int32_t)fread(data, 1, CHUNKSIZE, finput)) == CHUNKSIZE) {
     if (blosc2_schunk_append_buffer(schunk, data, isize) < 0) {
       fprintf(stderr, "Error in appending data to destination file");
       return -1;
     }
   }
   if (blosc2_schunk_append_buffer(schunk, data, isize) < 0) {
     fprintf(stderr, "Error in appending data to destination file");
     return -1;
   }
   fclose(finput);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Free resources */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
diff --git a/examples/contexts.c b/examples/contexts.c
index eaac3510..4f203738 100644
--- a/examples/contexts.c
+++ b/examples/contexts.c
@@ -1,29 +1,29 @@
 /*
     Copyright (C) 2014  Francesc Alted
     http://blosc.org
     License: BSD 3-Clause (see LICENSE.txt)
 
     Example program demonstrating the use of a Blosc from C code.
 
     To compile this program:
 
     $ gcc -O contexts.c -o contexts -lblosc2
 
     To run:
 
     $ ./contexts
     Blosc version info: 2.0.0a2 ($Date:: 2016-01-08 #$)
     Compression: 40000000 -> 999393 (40.0x)
     Correctly extracted 5 elements from compressed chunk!
     Decompression succesful!
     Succesful roundtrip!
 
 */
 
 #include <stdio.h>
 #include "blosc2.h"
 
-#define SIZE 10 * 1000 * 1000
+#define SIZE (100 * 1000)
 #define NTHREADS 2
 
 
diff --git a/examples/find_roots.c b/examples/find_roots.c
index 4363b5a1..fc2aa4a6 100644
--- a/examples/find_roots.c
+++ b/examples/find_roots.c
@@ -74,92 +74,92 @@ void find_root(const double *x, const double *y,
 int compute_vectors(void) {
   static double buffer_x[CHUNKSIZE];
   static double buffer_y[CHUNKSIZE];
-  const size_t isize = CHUNKSIZE * sizeof(double);
+  const int32_t isize = CHUNKSIZE * sizeof(double);
   int dsize;
   long nbytes = 0;
   blosc2_schunk *sc_x, *sc_y;
   int nchunk;
   blosc_timestamp_t last, current;
   double ttotal;
   double prev_value;
 
   /* Create a super-chunk container for input (X values) */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = sizeof(double);
   cparams.compcode = BLOSC_LZ4;
   cparams.clevel = 9;
   cparams.filters[0] = BLOSC_TRUNC_PREC;
   cparams.filters_meta[0] = 23;  // treat doubles as floats
   cparams.nthreads = NTHREADS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   sc_x = blosc2_schunk_new(storage);
 
   /* Create a super-chunk container for output (Y values) */
   sc_y = blosc2_schunk_new(storage);
 
   /* Now fill the buffer with even values between 0 and 10 */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     fill_buffer(buffer_x, nchunk);
     blosc2_schunk_append_buffer(sc_x, buffer_x, isize);
     nbytes += (long) isize;
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Creation time for X values: %.3g s, %.1f MB/s\n",
          ttotal, (double) nbytes / (ttotal * MB));
   printf("Compression for X values: %.1f MB -> %.1f MB (%.1fx)\n",
          sc_x->nbytes / MB, sc_x->cbytes / MB,
          (1. * sc_x->nbytes) / sc_x->cbytes);
 
   /* Retrieve the chunks and compute the polynomial in another super-chunk */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(sc_x, nchunk, buffer_x, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     process_data(buffer_x, buffer_y);
     blosc2_schunk_append_buffer(sc_y, buffer_y, isize);
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Computing Y polynomial: %.3g s, %.1f MB/s\n",
          ttotal, 2. * (double) nbytes / (ttotal * MB));    // 2 super-chunks involved
   printf("Compression for Y values: %.1f MB -> %.1f MB (%.1fx)\n",
          sc_y->nbytes / MB, sc_y->cbytes / MB,
          (1. * sc_y->nbytes) / sc_y->cbytes);
 
   /* Find the roots of the polynomial */
   printf("Roots found at: ");
   blosc_set_timestamp(&last);
   prev_value = buffer_y[0];
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(sc_y, nchunk, (void *) buffer_y, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     dsize = blosc2_schunk_decompress_chunk(sc_x, nchunk, (void *) buffer_x, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
     find_root(buffer_x, buffer_y, prev_value);
     prev_value = buffer_y[CHUNKSIZE - 1];
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("\n");
   printf("Find root time:  %.3g s, %.1f MB/s\n",
          ttotal, 2. * (double) nbytes / (ttotal * MB));    // 2 super-chunks involved
 
   /* Free resources */
   /* Destroy the super-chunk */
   blosc2_schunk_free(sc_x);
   blosc2_schunk_free(sc_y);
   return 0;
 }
diff --git a/examples/schunk_simple.c b/examples/schunk_simple.c
index db5ad2d9..aeb70c15 100644
--- a/examples/schunk_simple.c
+++ b/examples/schunk_simple.c
@@ -34,76 +34,76 @@
 int main(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int i, nchunk;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n", blosc_get_version_string(), BLOSC_VERSION_DATE);
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i * nchunk;
     }
     int nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     if (nchunks != nchunk + 1) {
         printf("Unexpected nchunks!");
         return -1;
     }
   }
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Retrieve and decompress the chunks (0-based count) */
   blosc_set_timestamp(&last);
   for (nchunk = NCHUNKS-1; nchunk >= 0; nchunk--) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Decompression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Check integrity of the second chunk (made of non-zeros) */
   blosc2_schunk_decompress_chunk(schunk, 1, data_dest, isize);
   for (i = 0; i < CHUNKSIZE; i++) {
     if (data_dest[i] != i) {
       printf("Decompressed data differs from original %d, %d!\n",
              i, data_dest[i]);
       return -1;
     }
   }
 
   printf("Successful roundtrip data <-> schunk !\n");
 
   /* Free resources */
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
diff --git a/examples/zstd_dict.c b/examples/zstd_dict.c
index defcd40f..17544132 100644
--- a/examples/zstd_dict.c
+++ b/examples/zstd_dict.c
@@ -1,31 +1,30 @@
 /*
   Copyright (C) 2017  Francesc Alted
   http://blosc.org
   License: BSD (see LICENSE.txt)
 
   Example program demonstrating use of the Blosc filter from C code.
 
   To compile this program:
 
   $ gcc -O zstd_dict.c -o zstd_dict -lblosc2
 
   To run:
 
   $ ./zstd_dict
   TODO ...
 
 */
 
 #include <stdio.h>
 #include <assert.h>
 #include <time.h>
-#include <blosc2.h>
 #include "blosc2.h"
 
 #define KB  1024.
 #define MB  (1024*KB)
 #define GB  (1024*MB)
 
 #define CHUNKSIZE (200 * 1000)
 #define NCHUNKS 20
 #define NTHREADS 4
@@ -34,83 +33,83 @@
 int main(void) {
   static int64_t data[CHUNKSIZE];
   static int64_t data_dest[CHUNKSIZE];
-  const size_t isize = CHUNKSIZE * sizeof(int64_t);
+  const int32_t isize = CHUNKSIZE * sizeof(int64_t);
   int dsize = 0;
   int64_t nbytes, cbytes;
   blosc2_schunk* schunk;
   int i;
   int32_t nchunk;
   int32_t nchunks;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = 8;
   //cparams.filters[0] = BLOSC_DELTA;
   cparams.compcode = BLOSC_ZSTD;
   cparams.use_dict = 1;
   //cparams.clevel = 7;
   cparams.blocksize = 1024 * 4;  // a page size
   //cparams.blocksize = 1024 * 32;
   cparams.nthreads = NTHREADS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + (int64_t)nchunk * CHUNKSIZE;
     }
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     assert(nchunks == nchunk + 1);
   }
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Retrieve and decompress the chunks (0-based count) */
   blosc_set_timestamp(&last);
   for (nchunk = NCHUNKS - 1; nchunk >= 0; nchunk--) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
   }
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return dsize;
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Decompression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Check integrity of the first chunk */
   for (i = 0; i < CHUNKSIZE; i++) {
     if (data_dest[i] != (int64_t)i) {
       printf("Decompressed data differs from original %d, %ld!\n",
              i, (long)data_dest[i]);
       return -1;
     }
   }
 
   printf("Successful roundtrip!\n");
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   blosc_destroy();
 
   return 0;
 }
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index f3d270ee..4d77b743 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -13,139 +13,140 @@ endif()
 # targets and tests
 foreach(source ${SOURCES})
     get_filename_component(target ${source} NAME_WE)
 
-    # test_nolock and test_noinit will be enabled only for Unix
+    # Some tests will be enabled only for Unix
     if(WIN32)
         if(target STREQUAL test_nolock OR
             target STREQUAL test_noinit OR
-            target STREQUAL test_compressor)
+            target STREQUAL test_compressor OR
+            target STREQUAL test_blosc1_compat)
             message("Skipping ${target} on Windows systems")
             continue()
         endif()
     endif()
 
     # Disable targets that use lz4 compressor when lz4 is deactivated
     if((target STREQUAL test_compressor) OR
        (target STREQUAL test_bitshuffle_leftovers) AND DEACTIVATE_LZ4)
         message("Skipping ${target} on non-LZ4 builds")
         continue()
     endif()
     # Disable targets that use zstd compressor when zstd is deactivated
     if((target STREQUAL test_dict_schunk) AND DEACTIVATE_ZSTD)
         message("Skipping ${target} on non-ZSTD builds")
         continue()
     endif()
 
     # Enable support for testing accelerated shuffles
     if(COMPILER_SUPPORT_SSE2 AND SSE2_FOUND)
         # Define a symbol so tests for SSE2 shuffle/unshuffle will be compiled in *and* there is support in the CPU for it.
         set_property(
                 SOURCE ${source}
                 APPEND PROPERTY COMPILE_DEFINITIONS SHUFFLE_SSE2_ENABLED)
     elseif(target STREQUAL test_shuffle_roundtrip_sse2)
         message("Skipping ${target} on non-SSE2 builds")
         continue()
     endif()
 
     if(COMPILER_SUPPORT_AVX2 AND AVX2_FOUND)
         # Define a symbol so tests for AVX2 shuffle/unshuffle will be compiled in *and* there is support in the CPU for it.
         set_property(
                 SOURCE ${source}
                 APPEND PROPERTY COMPILE_DEFINITIONS SHUFFLE_AVX2_ENABLED)
     elseif(target STREQUAL test_shuffle_roundtrip_avx2)
         message("Skipping ${target} on non-AVX2 builds")
         continue()
     endif()
 
     if(COMPILER_SUPPORT_NEON)
          # Define a symbol so tests for NEON shuffle/unshuffle will be compiled in.
          set_property(
                 SOURCE ${source}
                 APPEND PROPERTY COMPILE_DEFINITIONS SHUFFLE_NEON_ENABLED)
     elseif(target STREQUAL test_shuffle_roundtrip_neon)
         message("Skipping ${target} on non-NEON builds")
         continue()
     endif()
 
     if(COMPILER_SUPPORT_ALTIVEC)
          # Define a symbol so tests for NEON shuffle/unshuffle will be compiled in.
          set_property(
                 SOURCE ${source}
                 APPEND PROPERTY COMPILE_DEFINITIONS SHUFFLE_ALTIVEC_ENABLED)
     elseif(target STREQUAL test_shuffle_roundtrip_altivec)
         message("Skipping ${target} on non-ALTIVEC builds")
         continue()
     endif()
 
     add_executable(${target} ${source})
 
     # Define the BLOSC_TESTING symbol so normally-hidden functions
     # aren't hidden from the view of the test programs.
     set_property(
             TARGET ${target}
             APPEND PROPERTY COMPILE_DEFINITIONS BLOSC_TESTING)
 
     # have to copy dlls for Visual Studio
     if(MSVC)
         add_custom_command(
                 TARGET ${target}
                 POST_BUILD
                 COMMAND ${CMAKE_COMMAND}
                 ARGS -E copy_if_different
                 "${PROJECT_BINARY_DIR}/blosc/\$\(Configuration\)/blosc_testing.dll"
                 "${CMAKE_CURRENT_BINARY_DIR}/\$\(Configuration\)/blosc_testing.dll")
     elseif(MINGW)
         add_custom_command(
                 TARGET ${target}
                 POST_BUILD
                 COMMAND ${CMAKE_COMMAND}
                 ARGS -E copy_if_different
                 "${PROJECT_BINARY_DIR}/blosc/libblosc_testing.dll"
                 "${CMAKE_CURRENT_BINARY_DIR}/libblosc_testing.dll")
     endif()
 
     target_link_libraries(${target} blosc_testing)
     add_dependencies(${target} blosc_shared_testing)
 
     # If there's a CSV file present for this test, read it to get the list
     # of test parameters then add a test for each parameter set.
     # Otherwise, this is a simple test so just add it once.
     get_filename_component(source_extension ${source} EXT)
     string(REGEX REPLACE "${source_extension}$" ".csv"
             test_params_file ${source})
     if(EXISTS "${test_params_file}")
         # Read the file contents into a CMake list
         file(READ "${test_params_file}" test_params_contents)
 
         string(REGEX REPLACE ";" "\\\\;"
                 test_params_contents "${test_params_contents}")
         string(REGEX REPLACE "\n" ";"
                 test_params_contents "${test_params_contents}")
 
         # How many parameter sets for this test?
         # If there's not at least one (accounting for the CSV header line),
         # that's probably not correct so emit an error and stop configuring.
         list(LENGTH test_params_contents test_params_count)
         if("${test_params_count}" LESS 2)
             message(ERROR "Invalid test parameters file: ${test_params_file}")
         endif()
 
         # Remove the header line.
         list(REMOVE_AT test_params_contents 0)
 
         # Add a test for each parameter set in the file.
         foreach(test_params_raw ${test_params_contents})
             string(REGEX REPLACE "," " " test_params "${test_params_raw}")
 
             # Create the test name.
             # NOTE: The documentation for add_test says the test name "may not contain
             # spaces, quotes, or other characters special in CMake syntax."
             string(REGEX REPLACE "\"| " "_" test_name_params "${test_params}")
             set(test_name "${target}_${test_name_params}")
 
             separate_arguments(test_params)
             add_test(${test_name} ${target} ${test_params})
         endforeach()
     else()
         add_test(${target} ${target})
     endif()
diff --git a/tests/cutest.h b/tests/cutest.h
new file mode 100644
index 00000000..1916ef00
--- /dev/null
+++ b/tests/cutest.h
@@ -0,0 +1,206 @@
+/*
+  Copyright (C) 2021 Aleix Alcacer
+  Copyright (C) 2021 The Blosc Developers
+  http://blosc.org
+  License: BSD (see LICENSE.txt)
+
+  Creation date: 2021-01-15
+
+  See LICENSE.txt for details about copyright and rights to use.
+*/
+
+#ifndef CUTEST_CUTEST_H
+#define CUTEST_CUTEST_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+
+#define RED     "\033[31m"      /* Red */
+#define GREEN   "\033[32m"      /* Green */
+#define RESET   "\033[0m"
+
+
+#define CUNIT_OK 0
+#define CUNIT_FAIL 1
+
+
+#define CUTEST_DATA(...) __VA_ARGS__
+
+
+#define CUTEST_PARAMETRIZE(name, type, ...)                                      \
+    do {                                                                         \
+        type cutest_##name[] = {__VA_ARGS__};                                    \
+        _cutest_parametrize(#name, cutest_##name,                                \
+                            sizeof(cutest_##name) / sizeof(type), sizeof(type)); \
+    } while(0)
+
+#define CUTEST_PARAMETRIZE2(name, type, params_len, params)                                      \
+    do {                                                                         \
+        type *cutest_##name = params;                                    \
+        _cutest_parametrize(#name, cutest_##name, params_len, sizeof(type)); \
+    } while(0)
+
+#define CUTEST_GET_PARAMETER(name, type) \
+    type name = * (type *) _cutest_get_parameter(#name)
+
+#define CUTEST_TEST_DATA(sname) \
+    struct sname##_data
+
+#define CUTEST_TEST_SETUP(sname) \
+    void sname##_setup(struct sname##_data *data)
+
+#define CUTEST_TEST_TEARDOWN(sname) \
+    void sname##_teardown(struct sname##_data *data)
+
+#define CUTEST_TEST_TEST(sname)                           \
+    static struct sname##_data test_##sname##_data;  \
+    CUTEST_TEST_SETUP(sname);                        \
+    CUTEST_TEST_TEARDOWN(sname);                     \
+    int sname##_test(struct sname##_data* data);     \
+    int sname##_test(struct sname##_data* data)      \
+
+
+#define CUTEST_TEST_RUN(sname)                           \
+    _cutest_setup();                                     \
+    sname##_setup(&test_##sname##_data);                 \
+    int rc = _cutest_run((int (*)(void *)) sname##_test, \
+                         (void *) &test_##sname##_data,  \
+                         #sname);                        \
+    sname##_teardown(&test_##sname##_data);              \
+    _cutest_teardown();                                  \
+    return rc;
+
+
+#define CUTEST_ASSERT(msg, cond)                                                    \
+    do {                                                                            \
+        if (!(cond)) {                                                              \
+            sprintf(_cutest_error_msg, "Error: %s %s:%d", msg, __FILE__, __LINE__); \
+            return CUNIT_FAIL;                                                      \
+        }                                                                           \
+    } while(0)
+
+
+
+#define _CUTEST_PARAMS_MAX 16
+
+
+typedef struct {
+  char *name;
+  uint8_t *params;
+  int32_t params_len;
+  int32_t param_size;
+} _cutest_param_t;
+
+static _cutest_param_t _cutest_params[_CUTEST_PARAMS_MAX] = {0};
+static int32_t _cutest_params_ind[_CUTEST_PARAMS_MAX] = {0};
+
+
+void _cutest_parametrize(char* name, void *params, int32_t params_len, int32_t param_size) {
+  int i = 0;
+  while(_cutest_params[i].name != NULL) {
+    i++;
+  }
+  uint8_t *new_params = malloc(param_size * params_len);
+  char *new_name = strdup(name);
+  memcpy(new_params, params, param_size * params_len);
+  _cutest_params[i].name = new_name;
+  _cutest_params[i].params = new_params;
+  _cutest_params[i].param_size = param_size;
+  _cutest_params[i].params_len = params_len;
+}
+
+uint8_t *_cutest_get_parameter(char *name) {
+  int i = 0;
+  while(strcmp(_cutest_params[i].name, name) != 0) {
+    i++;
+  }
+  return _cutest_params[i].params + _cutest_params_ind[i] * _cutest_params[i].param_size;
+}
+
+
+void _cutest_setup() {
+  for (int i = 0; i < _CUTEST_PARAMS_MAX; ++i) {
+    _cutest_params[i].name = NULL;
+  }
+}
+
+
+void _cutest_teardown() {
+  int i = 0;
+  while(_cutest_params[i].name != NULL) {
+    free(_cutest_params[i].params);
+    free(_cutest_params[i].name);
+    i++;
+  }
+}
+
+
+char _cutest_error_msg[1024];
+
+
+int _cutest_run(int (*test)(void *), void *test_data, char *name) {
+  int cutest_ok = 0;
+  int cutest_failed = 0;
+  int cutest_total = 0;
+
+  int nparams = 0;
+  while(_cutest_params[nparams].name != NULL) {
+    nparams++;
+  }
+
+  int niters = 1;
+  for (int i = 0; i < nparams; ++i) {
+    niters *= _cutest_params[i].params_len;
+  }
+
+  int32_t params_strides[_CUTEST_PARAMS_MAX] = {0};
+  params_strides[0] = 1;
+  for (int i = 1; i < nparams; ++i) {
+    params_strides[i] = params_strides[i - 1] * _cutest_params[i - 1].params_len;
+  }
+
+  char test_name[1024];
+  int count = 0;
+  int num = niters;
+  do { count++; num /= 10;} while(num != 0);
+  for (int niter = 0; niter < niters; ++niter) {
+    sprintf(test_name, "[%0*d/%d] %s(", count, niter + 1, niters, name);
+    for (int i = 0; i < nparams; ++i) {
+      _cutest_params_ind[i] = niter / params_strides[i] % _cutest_params[i].params_len;
+      sprintf(test_name, "%s%s[%d], ", test_name, _cutest_params[i].name,
+              _cutest_params_ind[i]);
+    }
+    test_name[strlen(test_name) - 1] = 0;
+    test_name[strlen(test_name) - 1] = 0;
+    sprintf(test_name, "%s)", test_name);
+    if (nparams == 0) {
+      test_name[strlen(test_name) - 1] = 0;
+    }
+    printf("%s ", test_name);
+
+    cutest_total++;
+
+    int rc = test(test_data);
+    if (rc == CUNIT_OK) {
+      cutest_ok++;
+      fprintf(stdout, GREEN "[  OK  ]\n" RESET);
+    } else {
+      cutest_failed++;
+      fprintf(stdout, RED   "[FAILED]\n" RESET);
+    }
+    if (_cutest_error_msg[0] != 0) {
+      fprintf(stdout, RED "    %s\n" RESET, _cutest_error_msg);
+      _cutest_error_msg[0] = 0;
+    }
+  }
+
+  printf("\nTEST RESULTS: %d tests (%d ok, %d failed)\n",
+         cutest_total, cutest_ok, cutest_failed);
+
+  return cutest_failed;
+}
+
+
+#endif //CUTEST_CUTEST_H
diff --git a/tests/fuzz/fuzz_compress_frame.c b/tests/fuzz/fuzz_compress_frame.c
index 8d2d073f..01f738f8 100644
--- a/tests/fuzz/fuzz_compress_frame.c
+++ b/tests/fuzz/fuzz_compress_frame.c
@@ -11,86 +11,86 @@ extern "C" {
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
   const char *compressors[] = { "blosclz", "lz4", "lz4hc", "snappy", "zlib", "zstd" };
   int32_t i = 0, dsize = 0, filter = BLOSC_BITSHUFFLE;
   int32_t nchunk = 0,  nchunks = 0, max_chunksize = 512;
 
   blosc_init();
 
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = 1;
   /* Find next available compressor */
   cparams.compcode = 0;
   while (blosc_set_compressor(compressors[cparams.compcode % 6]) == -1 && i < 6) {
     cparams.compcode++, i++;
   }
   if (i == 6) {
     /* No compressors available */
     blosc_destroy();
     return 0;
   }
   if (size > 0) {
     /* Variable size compression level and max chunksize */
     cparams.clevel = data[0] % (9 + 1);
     max_chunksize *= data[0];
   }
   if (size > 1) {
     filter = data[1];
   }
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = filter % (BLOSC_BITSHUFFLE + 1);
   cparams.filters_meta[BLOSC2_MAX_FILTERS - 1] = filter;
   cparams.nthreads = 1;
 
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   dparams.nthreads = 1;
 
   /* Create a super-chunk backed by an in-memory frame */
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   blosc2_schunk* schunk = blosc2_schunk_new(storage);
   if (schunk == NULL) {
     blosc_destroy();
     return 0;
   }
 
   /* Compress data */
   int32_t chunksize = max_chunksize;
-  for (i = 0; chunksize > 0 && i < size; i += chunksize, nchunks++) {
-    if (i + chunksize > size)
+  for (i = 0; chunksize > 0 && i < (int32_t)size; i += chunksize, nchunks++) {
+    if (i + chunksize > (int32_t)size)
       chunksize = size - i;
     nchunks = blosc2_schunk_append_buffer(schunk, (uint8_t *)data + i, chunksize);
     if (nchunks < 0) {
       printf("Compression error.  Error code: %d\n", nchunks);
       break;
     }
   }
 
   /* Decompress data */
   uint8_t *uncompressed_data = (uint8_t *)malloc(size+1);
   if (uncompressed_data != NULL) {
     for (i = 0, nchunk = 0; nchunk < nchunks-1; nchunk++) {
       dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, uncompressed_data + i, chunksize);
       if (dsize < 0) {
         printf("Decompression error.  Error code: %d\n", dsize);
         break;
       }
       i += dsize;
     }
 
     /* Compare decompressed data with original */
     if (size > 0 && nchunks > 0) {
       if (dsize < 0 || memcmp(data, uncompressed_data, size) != 0) {
         printf("Decompression data does not match original %d\n", dsize);
       }
     }
 
     free(uncompressed_data);
   }
 
   /* Free resources */
   blosc2_schunk_free(schunk);
 
   blosc_destroy();
   return 0;
 }
 
 #ifdef __cplusplus
 }
 #endif
diff --git a/tests/test_blosc1_compat.c b/tests/test_blosc1_compat.c
new file mode 100644
index 00000000..8f7b5692
--- /dev/null
+++ b/tests/test_blosc1_compat.c
@@ -0,0 +1,147 @@
+/*********************************************************************
+  Blosc - Blocked Shuffling and Compression Library
+
+  Unit tests for BLOSC_BLOSC1_COMPAT environment variable in Blosc.
+
+  Creation date: 2021-01-14
+  Author: The Blosc Developers <blosc@blosc.org>
+
+  See LICENSE.txt for details about copyright and rights to use.
+**********************************************************************/
+
+#include "test_common.h"
+
+#define BUFFER_ALIGN_SIZE 32
+#define NTHREADS 1
+
+int tests_run = 0;
+
+/* Global vars */
+void *src, *srccpy, *dest, *dest2;
+int nbytes, cbytes;
+int clevel = 1;
+int doshuffle = 1;
+size_t typesize = sizeof(int32_t);
+size_t size = sizeof(int32_t) * 1000 * 1000;
+
+
+/* Check compressing + decompressing */
+static char *test_compress_decompress(void) {
+  int32_t *_src = (int32_t *)src;
+  for (int i = 0; i < (int)(size / sizeof(int32_t)); i++) {
+    _src[i] = (int32_t)i;
+  }
+  memcpy(srccpy, src, size);
+
+  /* Get a compressed buffer */
+  cbytes = blosc_compress(clevel, doshuffle, typesize, size, src,
+                          dest, size + BLOSC_MIN_HEADER_LENGTH);
+  mu_assert("ERROR: cbytes is not correct", cbytes < (int)size);
+
+  /* Decompress the buffer */
+  nbytes = blosc_decompress(dest, dest2, size);
+  mu_assert("ERROR: nbytes incorrect(1)", nbytes == (int)size);
+
+  // Check roundtrip
+  int exit_code = memcmp(srccpy, dest2, size) ? EXIT_FAILURE : EXIT_SUCCESS;
+  mu_assert("ERROR: Bad roundtrip!", exit_code == EXIT_SUCCESS);
+
+  return 0;
+}
+
+
+/* Check compressing + decompressing */
+static char *test_compress_decompress_zeros(void) {
+  int32_t *_src = (int32_t *)src;
+  for (int i = 0; i < (int)(size / sizeof(int32_t)); i++) {
+    _src[i] = 0;
+  }
+  memcpy(srccpy, src, size);
+
+  /* Get a compressed buffer */
+  cbytes = blosc_compress(clevel, doshuffle, typesize, size, src,
+                          dest, size + BLOSC_MIN_HEADER_LENGTH);
+  mu_assert("ERROR: cbytes is not correct", cbytes < (int)size);
+
+  /* Decompress the buffer */
+  nbytes = blosc_decompress(dest, dest2, size);
+  mu_assert("ERROR: nbytes incorrect(1)", nbytes == (int)size);
+
+  // Check roundtrip
+  int exit_code = memcmp(srccpy, dest2, size) ? EXIT_FAILURE : EXIT_SUCCESS;
+  mu_assert("ERROR: Bad roundtrip!", exit_code == EXIT_SUCCESS);
+
+  return 0;
+}
+
+
+/* Check compressing + getitem */
+static char *test_compress_getitem(void) {
+  int32_t *_src = (int32_t *)src;
+  for (int i = 0; i < (int)(size / sizeof(int32_t)); i++) {
+    _src[i] = (int32_t)i;
+  }
+  memcpy(srccpy, src, size);
+
+  /* Get a compressed buffer */
+  cbytes = blosc_compress(clevel, doshuffle, typesize, size, src,
+                          dest, size + BLOSC_MIN_HEADER_LENGTH);
+  mu_assert("ERROR: cbytes is not correct", cbytes < (int)size);
+
+  /* Decompress the buffer */
+  nbytes = blosc_getitem(dest, 1, 10, dest2);
+  mu_assert("ERROR: nbytes incorrect(1)", nbytes == 10 * typesize);
+
+  // Check roundtrip
+  int exit_code = memcmp(srccpy + typesize, dest2, 10 * typesize) ? EXIT_FAILURE : EXIT_SUCCESS;
+  mu_assert("ERROR: Bad roundtrip!", exit_code == EXIT_SUCCESS);
+
+  return 0;
+}
+
+static char *all_tests(void) {
+  mu_run_test(test_compress_decompress);
+  mu_run_test(test_compress_getitem);
+  mu_run_test(test_compress_decompress_zeros);
+
+  return 0;
+}
+
+
+int main(void) {
+  char *result;
+
+  /* Activate the BLOSC_BLOSC1_COMPAT variable */
+  setenv("BLOSC_BLOSC1_COMPAT", "TRUE", 0);
+
+  blosc_init();
+  blosc_set_nthreads(NTHREADS);
+
+  /* Initialize buffers */
+  src = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
+  srccpy = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
+  dest = blosc_test_malloc(BUFFER_ALIGN_SIZE, size + BLOSC_MIN_HEADER_LENGTH);
+  dest2 = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
+
+  /* Run all the suite */
+  result = all_tests();
+  if (result != 0) {
+    printf(" (%s)\n", result);
+  }
+  else {
+    printf(" ALL TESTS PASSED\n");
+  }
+  printf("\tTests run: %d\n", tests_run);
+
+  blosc_test_free(src);
+  blosc_test_free(srccpy);
+  blosc_test_free(dest);
+  blosc_test_free(dest2);
+
+  blosc_destroy();
+
+  /* Reset envvar */
+  unsetenv("BLOSC_BLOSC1_COMPAT");
+
+  return result != 0;
+}
diff --git a/tests/test_change_nthreads_append.c b/tests/test_change_nthreads_append.c
index 7d77abbe..6ec7d66e 100644
--- a/tests/test_change_nthreads_append.c
+++ b/tests/test_change_nthreads_append.c
@@ -20,78 +20,78 @@ int tests_run = 0;
 static char* all_tests(void) {
   static int64_t data[CHUNKSIZE];
   static int64_t data_dest[CHUNKSIZE];
-  const size_t isize = CHUNKSIZE * sizeof(int64_t);
+  const int32_t isize = CHUNKSIZE * sizeof(int64_t);
   int dsize = 0;
   size_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int32_t i;
   int32_t nchunk;
   int32_t nchunks;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
 /* Initialize the Blosc compressor */
   blosc_init();
 
 /* Create a super-chunk container */
   cparams.typesize = 8;
   cparams.filters[0] = BLOSC_DELTA;
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   struct blosc2_context_s * cctx = schunk->cctx;
   blosc_set_timestamp(&last);
   for (nchunk = 1; nchunk <= NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i * (int64_t)nchunk;
     }
     // Alternate between 1 and NTHREADS
     cctx->new_nthreads = nchunk % NTHREADS + 1;
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: nchunk is not correct", nchunks == nchunk);
   }
   /* Gather some info */
   nbytes = (size_t)schunk->nbytes;
   cbytes = (size_t)schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          (double)nbytes / MB, (double)cbytes / MB, (double)nbytes / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Retrieve and decompress the chunks (0-based count) */
   struct blosc2_context_s * dctx = schunk->dctx;
   blosc_set_timestamp(&last);
   for (nchunk = NCHUNKS-1; nchunk >= 0; nchunk--) {
     // Alternate between 1 and NTHREADS
     dctx->new_nthreads = nchunk % NTHREADS + 1;
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
   }
   mu_assert("ERROR: chunk decompression error", dsize > 0);
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Decompression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Check integrity of the first chunk */
   for (i = 0; i < CHUNKSIZE; i++) {
     mu_assert("ERROR: decompressed data differs from original", data_dest[i] == (int64_t)i);
   }
 
   printf("Successful roundtrip!\n");
 
   /* Free resources */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
diff --git a/tests/test_contexts.c b/tests/test_contexts.c
index c96d97e6..d012299c 100644
--- a/tests/test_contexts.c
+++ b/tests/test_contexts.c
@@ -15,79 +15,79 @@
 int main(void) {
   static int32_t data[SIZE];
   static int32_t data_out[SIZE];
   static int32_t data_dest[SIZE];
   int32_t data_subset[5];
   int32_t data_subset_ref[5] = {5, 6, 7, 8, 9};
-  size_t isize = SIZE * sizeof(int32_t), osize = SIZE * sizeof(int32_t);
+  int32_t isize = SIZE * sizeof(int32_t), osize = SIZE * sizeof(int32_t);
   int dsize = SIZE * sizeof(int32_t), csize;
   int i, ret;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *cctx, *dctx;
 
   /* Initialize dataset */
   for (i = 0; i < SIZE; i++) {
     data[i] = i;
   }
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   install_blosc_callback_test(); /* optionally install callback test */
 
   /* Create a context for compression */
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_SHUFFLE;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cctx = blosc2_create_cctx(cparams);
 
   /* Compress with clevel=5 and shuffle active  */
   csize = blosc2_compress_ctx(cctx, data, isize, data_out, osize);
   blosc2_free_ctx(cctx);
   if (csize == 0) {
     printf("Buffer is uncompressible.  Giving up.\n");
     return EXIT_FAILURE;
   }
   if (csize < 0) {
     printf("Compression error.  Error code: %d\n", csize);
     return EXIT_FAILURE;
   }
 
   /* Create a context for decompression */
   dparams.nthreads = NTHREADS;
   dctx = blosc2_create_dctx(dparams);
 
   ret = blosc2_getitem_ctx(dctx, data_out, csize, 5, 5, data_subset);
   if (ret < 0) {
     printf("Error in blosc2_getitem_ctx().  Giving up.\n");
     blosc2_free_ctx(dctx);
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < 5; i++) {
     if (data_subset[i] != data_subset_ref[i]) {
       printf("blosc2_getitem_ctx() fetched data differs from original!\n");
       blosc2_free_ctx(dctx);
       return EXIT_FAILURE;
     }
   }
 
   /* Decompress  */
   dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   blosc2_free_ctx(dctx);
   if (dsize < 0) {
     printf("Decompression error.  Error code: %d\n", dsize);
     return EXIT_FAILURE;
   }
 
   for (i = 0; i < SIZE; i++) {
     if (data[i] != data_dest[i]) {
       printf("Decompressed data differs from original!\n");
       return EXIT_FAILURE;
     }
   }
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_delta_schunk.c b/tests/test_delta_schunk.c
index b6f21a3c..e0c6aa2a 100644
--- a/tests/test_delta_schunk.c
+++ b/tests/test_delta_schunk.c
@@ -16,64 +16,64 @@
 int main(void) {
   static int32_t data[SIZE];
   static int32_t data_dest[SIZE];
-  size_t isize = SIZE * sizeof(int32_t);
+  int32_t isize = SIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int32_t nchunks;
 
   printf("Blosc version info: %s (%s)\n",
          BLOSC_VERSION_STRING, BLOSC_VERSION_DATE);
 
   /* Initialize the Blosc compressor */
   install_blosc_callback_test(); /* optionally install callback test */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.filters[0] = BLOSC_DELTA;
   cparams.filters[BLOSC2_MAX_FILTERS - 1] = BLOSC_BITSHUFFLE;
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   for (int nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (int i = 0; i < SIZE; i++) {
       data[i] = i * nchunk;
     }
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     if (nchunks != (nchunk + 1)) return EXIT_FAILURE;
   }
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (cbytes > nbytes) {
     return EXIT_FAILURE;
   }
 
   /* Retrieve and decompress the chunks (0-based count) */
   for (int nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     if (dsize < 0) {
       return EXIT_FAILURE;
     }
     for (int i = 0; i < SIZE; i++) {
       if (data_dest[i] != i  * nchunk) {
         fprintf(stderr, "First error in: %u, %d, %d\n",
                 nchunk, i, data_dest[i]);
         return EXIT_FAILURE;
       }
     }
   }
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_dict_schunk.c b/tests/test_dict_schunk.c
index 483351b2..474451a5 100644
--- a/tests/test_dict_schunk.c
+++ b/tests/test_dict_schunk.c
@@ -23,127 +23,127 @@ int use_dict;
 static char* test_dict(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int32_t nchunks;
   blosc_timestamp_t last, current;
   double cttotal, dttotal;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_ZSTD;
   cparams.use_dict = use_dict;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   cparams.blocksize = blocksize;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   blosc_set_timestamp(&last);
   for (int nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: incorrect nchunks value", nchunks == (nchunk + 1));
   }
   blosc_set_timestamp(&current);
   cttotal = blosc_elapsed_secs(last, current);
 
   /* Retrieve and decompress the chunks */
   blosc_set_timestamp(&last);
   for (int nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: Decompression error.", dsize > 0);
   }
   blosc_set_timestamp(&current);
   dttotal = blosc_elapsed_secs(last, current);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   float cratio = nbytes / (float)cbytes;
   float cspeed = nbytes / ((float)cttotal * MB);
   float dspeed = nbytes / ((float)dttotal * MB);
   if (tests_run == 0) printf("\n");
   if (blocksize > 0) {
     printf("[blocksize: %d KB] ", blocksize / 1024);
   } else {
     printf("[blocksize: automatic] ");
   }
   if (!use_dict) {
     printf("cratio w/o dict: %.1fx (compr @ %.1f MB/s, decompr @ %.1f MB/s)\n",
             cratio, cspeed, dspeed);
     switch (blocksize) {
       case 1 * KB:
         mu_assert("ERROR: No dict does not reach expected compression ratio",
                   3 * cbytes < nbytes);
         break;
       case 4 * KB:
         mu_assert("ERROR: No dict does not reach expected compression ratio",
                   10 * cbytes < nbytes);
         break;
       case 32 * KB:
         mu_assert("ERROR: No dict does not reach expected compression ratio",
                   70 * cbytes < nbytes);
         break;
       case 256 * KB:
         mu_assert("ERROR: No dict does not reach expected compression ratio",
                   190 * cbytes < nbytes);
         break;
       default:
         mu_assert("ERROR: No dict does not reach expected compression ratio",
                   170 * cbytes < nbytes);
     }
   } else {
     printf("cratio with dict: %.1fx (compr @ %.1f MB/s, decompr @ %.1f MB/s)\n",
            cratio, cspeed, dspeed);
     switch (blocksize) {
       case 1 * KB:
         mu_assert("ERROR: Dict does not reach expected compression ratio",
                   8 * cbytes < nbytes);
         break;
       case 4 * KB:
         mu_assert("ERROR: Dict does not reach expected compression ratio",
                   15 * cbytes < nbytes);
         break;
       case 32 * KB:
         mu_assert("ERROR: Dict does not reach expected compression ratio",
                   100 * cbytes < nbytes);
         break;
       case 256 * KB:
         mu_assert("ERROR: Dict does not reach expected compression ratio",
                   260 * cbytes < nbytes);
         break;
       default:
         mu_assert("ERROR: Dict does not reach expected compression ratio",
                   260 * cbytes < nbytes);
     }
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",
                 data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_eframe.c b/tests/test_eframe.c
index b60f8e77..5b4a3d51 100644
--- a/tests/test_eframe.c
+++ b/tests/test_eframe.c
@@ -210,53 +210,54 @@ static char* test_eframe(void) {
 static char* test_eframe_simple(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.sequential=false, .urlpath=directory, .cparams=&cparams, .dparams=&dparams};
+  blosc2_remove_dir(storage.urlpath);
   schunk = blosc2_schunk_new(storage);
   mu_assert("Error in creating schunk", schunk != NULL);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk;
     }
     int _nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in eframe", _nchunks > 0);
   }
 
   /* Retrieve and decompress the chunks (0-based count) */
   for (int nchunk = nchunks-1; nchunk >= 0; nchunk--) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
     mu_assert("Decompression error", dsize>=0);
   }
 
   if (nchunks >= 2) {
     /* Check integrity of the second chunk (made of non-zeros) */
     blosc2_schunk_decompress_chunk(schunk, 1, data_dest, isize);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("Decompressed data differs from original", data_dest[i]==(i+1));
     }
   }
 
   /* Remove directory */
   blosc2_remove_dir(storage.urlpath);
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
@@ -265,54 +266,54 @@ static char* test_eframe_simple(void) {
 static char *all_tests(void) {
   directory = "dir1.b2eframe";
 
   nchunks = 0;
   mu_run_test(test_eframe_simple);
 
   nchunks = 1;
   mu_run_test(test_eframe_simple);
 
-  nchunks = 10;
+  nchunks = 2;
   mu_run_test(test_eframe_simple);
 
-  nchunks = 100;
+  nchunks = 10;
   mu_run_test(test_eframe_simple);
 
   // Check directory with a trailing slash
   directory = "dir1.b2eframe/";
   nchunks = 0;
   mu_run_test(test_eframe_simple);
 
   nchunks = 1;
   mu_run_test(test_eframe_simple);
 
   // Iterate over all different parameters
   for (int i = 0; i < (int)sizeof(nchunks_) / (int)sizeof(int); i++) {
     nchunks = nchunks_[i];
     for (int isplits = 0; isplits < 2; isplits++) {
       for (int imultithread = 0; imultithread < 2; imultithread++) {
         for (int ifree_new = 0; ifree_new < 2; ifree_new++) {
           for (int ifilter_pipeline = 0; ifilter_pipeline < 2; ifilter_pipeline++) {
             for (int imetalayers = 0; imetalayers < 2; imetalayers++) {
               for (int iusermeta = 0; iusermeta < 2; iusermeta++) {
                 splits = (bool) isplits;
                 multithread = (bool) imultithread;
                 free_new = (bool) ifree_new;
                 filter_pipeline = (bool) ifilter_pipeline;
                 metalayers = (bool) imetalayers;
                 usermeta = (bool) iusermeta;
                 snprintf(buf, sizeof(buf), "test_eframe_nc%d.b2eframe", nchunks);
                 directory = buf;
                 mu_run_test(test_eframe);
                 snprintf(buf, sizeof(buf), "test_eframe_nc%d.b2eframe/", nchunks);
                 directory = buf;
                 mu_run_test(test_eframe);
               }
             }
           }
         }
       }
     }
   }
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_empty_schunk.c b/tests/test_empty_schunk.c
index ed537103..1f3b7ee1 100644
--- a/tests/test_empty_schunk.c
+++ b/tests/test_empty_schunk.c
@@ -23,120 +23,120 @@ bool copy;
 static char* test_schunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_empty(nchunks, storage);
 
   // Add a couple of metalayers
   blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
 
   bool needs_free;
   int32_t datasize = sizeof(int32_t) * CHUNKSIZE;
   int32_t chunksize = sizeof(int32_t) * CHUNKSIZE + BLOSC_MAX_OVERHEAD;
 
   // Feed it with data
   uint8_t *chunk;
   int csize;
   int nchunks_;
 
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
 
     chunk = malloc(chunksize);
     csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
     nchunks_ = blosc2_schunk_update_chunk(schunk, nchunk, chunk, copy);
     mu_assert("ERROR: bad append in schunk", nchunks_ == nchunks);
 
     chunk = malloc(chunksize);
     csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
     nchunks_ = blosc2_schunk_update_chunk(schunk, nchunk, chunk, copy);
 
     mu_assert("ERROR: bad append in schunk", nchunks_ == nchunks);
 
     if (copy) {
       free(chunk);
     }
   }
 
   blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   // Attach some user metadata into it
   blosc2_update_usermeta(schunk, (uint8_t *) "testing the usermeta", 16, BLOSC2_CPARAMS_DEFAULTS);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Exercise the metadata retrieval machinery
   size_t nbytes_, cbytes_, blocksize;
   nbytes = 0;
   cbytes = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes_ = blosc2_schunk_get_chunk(schunk, nchunk, &chunk, &needs_free);
     mu_assert("ERROR: chunk cannot be retrieved correctly.", cbytes_ >= 0);
     blosc_cbuffer_sizes(chunk, &nbytes_, &cbytes_, &blocksize);
     nbytes += nbytes_;
     cbytes += cbytes_;
     if (needs_free) {
       free(chunk);
     }
   }
   mu_assert("ERROR: nbytes is not correct", nbytes == schunk->nbytes);
   mu_assert("ERROR: cbytes is not correct", cbytes == schunk->cbytes);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", cbytes >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   // metalayers
   uint8_t* content;
   uint32_t content_len;
   blosc2_get_metalayer(schunk, "metalayer1", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer1", content_len) == 0);
   if (content != NULL) {
     free(content);
   }
   blosc2_get_metalayer(schunk, "metalayer2", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer2", content_len) == 0);
   if (content != NULL) {
     free(content);
   }
 
   // Check the usermeta
   uint8_t* content2;
   int32_t content2_len = blosc2_get_usermeta(schunk, &content2);
   mu_assert("ERROR: bad usermeta", strncmp((char*)content2, "testing the usermeta", 16) == 0);
   mu_assert("ERROR: bad usermeta_len", content2_len == 16);
   free(content2);
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_frame.c b/tests/test_frame.c
index 8cb2a140..5fc08a5e 100644
--- a/tests/test_frame.c
+++ b/tests/test_frame.c
@@ -1,27 +1,27 @@
 /*
   Copyright (C) 2020 The Blosc Developers
   http://blosc.org
   License: BSD (see LICENSE.txt)
 
   Creation date: 2019-08-06
 
   See LICENSE.txt for details about copyright and rights to use.
 */
 
 #include <stdio.h>
 #include <stdbool.h>
 #include "test_common.h"
 #include "frame.h"
 
 #if defined(_WIN32)
 #define snprintf _snprintf
 #endif
 
-#define CHUNKSIZE (200 * 1000)
+#define CHUNKSIZE (20 * 1000)
 #define NTHREADS (4)
 
 /* Global vars */
-int nchunks_[] = {0, 1, 2, 10};
+int nchunks_[] = {0, 1, 2, 5};
 int tests_run = 0;
 int nchunks;
 bool multithread;
@@ -31,219 +31,218 @@ bool sparse_schunk;
 bool filter_pipeline;
 bool metalayers;
 bool usermeta;
-bool check_sframe;
 char *fname;
 char buf[256];
 
 
 static char* test_frame(void) {
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int32_t *data = malloc(isize);
   int32_t *data_dest = malloc(isize);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   if (filter_pipeline) {
     cparams.filters[BLOSC2_MAX_FILTERS - 2] = BLOSC_DELTA;
     cparams.filters_meta[BLOSC2_MAX_FILTERS - 2] = 0;
   }
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a frame container */
   cparams.typesize = sizeof(int32_t);
   if (splits) {
     // Use a codec that splits blocks (important for lazy chunks).
     // Only BLOSCLZ is doing that.
     cparams.compcode = BLOSC_BLOSCLZ;
   }
 #if defined(HAVE_LZ4)
   else {
     cparams.compcode = BLOSC_LZ4;
   }
 #endif
   if (multithread) {
     cparams.nthreads = NTHREADS;
     dparams.nthreads = NTHREADS;
   }
   else {
     cparams.nthreads = 1;
     dparams.nthreads = 1;
   }
   blosc2_storage storage = {.sequential=true, .urlpath=fname, .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
   mu_assert("blosc2_schunk_new() failed", schunk != NULL);
   char* content = "This is a pretty long string with a good number of chars";
   char* content2 = "This is a pretty long string with a good number of chars; longer than content";
   char* content3 = "This is a short string, and shorter than content";
   uint8_t* content_;
   size_t content_len = strlen(content);
   size_t content_len2 = strlen(content2);
   size_t content_len3 = strlen(content3);
 
   if (metalayers) {
     blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
     blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   }
 
   if (usermeta) {
     blosc2_update_usermeta(schunk, (uint8_t *) content, (int32_t) content_len, BLOSC2_CPARAMS_DEFAULTS);
   }
 
   if (!sparse_schunk) {
     if (free_new) {
       if (fname != NULL) {
         blosc2_schunk_free(schunk);
         blosc2_storage storage2 = {.sequential=true, .urlpath=fname};
         schunk = blosc2_schunk_open(storage2);
         mu_assert("blosc2_schunk_open() failed", schunk != NULL);
         mu_assert("storage is not recovered correctly",
                   schunk->storage->sequential == true);
         mu_assert("cparams are not recovered correctly",
                   schunk->storage->cparams->clevel == BLOSC2_CPARAMS_DEFAULTS.clevel);
         mu_assert("dparams are not recovered correctly",
                   schunk->storage->dparams->nthreads == BLOSC2_DPARAMS_DEFAULTS.nthreads);
       } else {
-        // Dump the schunk to a sframe and regenerate it from there
+        // Dump the schunk into a sframe and regenerate it from there
         uint8_t* sframe;
         int64_t sframe_len = blosc2_schunk_to_sframe(schunk, &sframe);
         blosc2_schunk_free(schunk);
         schunk = blosc2_schunk_open_sframe(sframe, sframe_len);
         mu_assert("blosc2_schunk_open_sframe() failed", schunk != NULL);
       }
     }
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
     int content_len_ = blosc2_get_usermeta(schunk, &content_);
     mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len);
     mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content, content_len) == 0);
     free(content_);
     blosc2_update_usermeta(schunk, (uint8_t *) content2, (int32_t) content_len2, BLOSC2_CPARAMS_DEFAULTS);
   }
 
   // Feed it with data
   int _nchunks = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     _nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", _nchunks >= 0);
   }
   mu_assert("ERROR: wrong number of append chunks", _nchunks == nchunks);
 
   if (!sparse_schunk) {
     blosc2_frame* frame = schunk->frame;
     mu_assert("ERROR: frame->len must be larger or equal than schunk->cbytes",
               frame->len >= schunk->cbytes + FRAME_HEADER_MINLEN);
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   }
 
   if (usermeta) {
     int content_len_ = blosc2_get_usermeta(schunk, &content_);
     mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len2);
     mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content2, content_len2) == 0);
     free(content_);
     blosc2_update_usermeta(schunk, (uint8_t *) content3, (int32_t) content_len3, BLOSC2_CPARAMS_DEFAULTS);
   }
 
   if (!sparse_schunk) {
     if (free_new) {
       if (fname != NULL) {
         blosc2_schunk_free(schunk);
         blosc2_storage storage2 = {.sequential=true, .urlpath=fname};
         schunk = blosc2_schunk_open(storage2);
       } else {
         // Dump the schunk to a sframe and regenerate it from there
         uint8_t* sframe;
         int64_t sframe_len = blosc2_schunk_to_sframe(schunk, &sframe);
         blosc2_schunk_free(schunk);
         schunk = blosc2_schunk_open_sframe(sframe, sframe_len);
-        mu_assert("blosc2_schunk_open_sframe() failed", schunk != NULL);
+        mu_assert("blosc2_schunk_open_sframe() failed (2)", schunk != NULL);
 
       }
     }
   }
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   if (metalayers) {
     uint8_t* _content;
     uint32_t _content_len;
     blosc2_get_metalayer(schunk, "metalayer1", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer1", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
     blosc2_get_metalayer(schunk, "metalayer2", &_content, &_content_len);
     mu_assert("ERROR: bad metalayer content", strncmp((char*)_content, "my metalayer2", _content_len) == 0);
     if (_content != NULL) {
       free(_content);
     }
   }
 
   if (usermeta) {
     int content_len_ = blosc2_get_usermeta(schunk, &content_);
     mu_assert("ERROR: bad usermeta length in frame", (size_t) content_len_ == content_len3);
     mu_assert("ERROR: bad usermeta data in frame", strncmp((char*)content_, content3, content_len3) == 0);
     free(content_);
   }
 
   /* Free resources */
   free(data_dest);
   free(data);
   blosc2_schunk_free(schunk);
 
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_insert_chunk.c b/tests/test_insert_chunk.c
index d0ac6841..8f3f0936 100644
--- a/tests/test_insert_chunk.c
+++ b/tests/test_insert_chunk.c
@@ -60,76 +60,83 @@ bool tcopy[] = {
 };
 
 static char* test_insert_chunk(void) {
+  /* Free resources */
+  if (tdata.urlpath != NULL && tdata.sequential == false) {
+    blosc2_remove_dir(tdata.urlpath);
+  }
+
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams,
                             .urlpath=tdata.urlpath, .sequential=tdata.sequential};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < tdata.nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append", nchunks_ > 0);
   }
 
   for (int i = 0; i < tdata.ninsertions; ++i) {
     // Create chunk
     for (int j = 0; j < CHUNKSIZE; ++j) {
       data[j] = i;
     }
     int32_t datasize = sizeof(int32_t) * CHUNKSIZE;
     int32_t chunksize = sizeof(int32_t) * CHUNKSIZE + BLOSC_MAX_OVERHEAD;
     uint8_t *chunk = malloc(chunksize);
     int csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
 
     // Insert in a random position
     int pos = rand() % (schunk->nchunks + 1);
     int _nchunks = blosc2_schunk_insert_chunk(schunk, pos, chunk, tdata.copy);
     mu_assert("ERROR: chunk cannot be inserted correctly", _nchunks > 0);
 
     // Check that the inserted chunk can be decompressed correctly
     dsize = blosc2_schunk_decompress_chunk(schunk, pos, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly", dsize >= 0);
     for (int j = 0; j < CHUNKSIZE; j++) {
-      mu_assert("ERROR: bad roundtrip", data_dest[j] == i);
+      int32_t a = data_dest[j];
+      int32_t b = a + 1;
+      mu_assert("ERROR: bad roundtrip", a == i);
     }
     // Free allocated chunk
     if (tdata.copy) {
       free(chunk);
     }
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < schunk->nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly", dsize >= 0);
   }
 
 
   /* Free resources */
   if (!storage.sequential && storage.urlpath != NULL) {
     blosc2_remove_dir(storage.urlpath);
   }
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_lazychunk.c b/tests/test_lazychunk.c
index 93a6d17d..6cdbac96 100644
--- a/tests/test_lazychunk.c
+++ b/tests/test_lazychunk.c
@@ -25,78 +25,78 @@ int nthreads;
 static char* test_lazy_chunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container, backed by a frame */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = clevel;
   cparams.nthreads = nthreads;
   cparams.blocksize = BLOCKSIZE * cparams.typesize;
   dparams.nthreads = nthreads;
   blosc2_storage storage = {.sequential=true, .urlpath="test_lazy_chunk.b2frame", .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         data[j + i * BLOCKSIZE] = j + i * BLOCKSIZE + nchunk * CHUNKSIZE;
       }
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   /* Gather some info */
   if (nchunks > 0 && clevel > 0) {
     mu_assert("ERROR: bad compression ratio in frame", schunk->nbytes > 10 * schunk->cbytes);
   }
 
   // Check that blosc2_getitem_ctx works correctly with lazy chunks
   bool needs_free;
   uint8_t* lazy_chunk;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     for (int i = 0; i < NBLOCKS - 1; i++) {
       memset(data_dest, 0, isize);
       dsize = blosc2_getitem_ctx(schunk->dctx, lazy_chunk, cbytes, i * BLOCKSIZE, BLOCKSIZE * 2, data_dest);
       mu_assert("ERROR: blosc2_getitem_ctx does not work correctly.", dsize >= 0);
       for (int j = 0; j < BLOCKSIZE * 2; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_getitem_ctx)",
                   data_dest[j] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
     if (needs_free) {
       free(lazy_chunk);
     }
   }
 
   // Check that lazy chunks can be decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     memset(data_dest, 0, isize);
     cbytes = blosc2_schunk_get_lazychunk(schunk, nchunk, &lazy_chunk, &needs_free);
     dsize = blosc2_decompress_ctx(schunk->dctx, lazy_chunk, cbytes, data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < NBLOCKS; i++) {
       for (int j = 0; j < BLOCKSIZE; j++) {
         mu_assert("ERROR: bad roundtrip (blosc2_decompress_ctx)",
                   data_dest[j + i * BLOCKSIZE] == j + i * BLOCKSIZE + nchunk * CHUNKSIZE);
       }
     }
   }
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_nolock.c b/tests/test_nolock.c
index 1ed364de..875ece97 100644
--- a/tests/test_nolock.c
+++ b/tests/test_nolock.c
@@ -67,46 +67,49 @@ static char *all_tests(void) {
 int main(void) {
   int32_t *_src;
   char *result;
 
   /* Activate the BLOSC_NOLOCK variable */
   setenv("BLOSC_NOLOCK", "TRUE", 0);
 
   /* Launch several subprocesses */
   for (int i = 1; i <= NCHILDREN; i++) {
     int pid = fork();
     assert(pid >= 0);
   }
 
   blosc_init();
   blosc_set_nthreads(NTHREADS);
 
   /* Initialize buffers */
   src = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
   srccpy = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
   dest = blosc_test_malloc(BUFFER_ALIGN_SIZE, size + BLOSC_MAX_OVERHEAD);
   dest2 = blosc_test_malloc(BUFFER_ALIGN_SIZE, size);
   _src = (int32_t *)src;
   for (int i = 0; i < (int)(size / sizeof(int32_t)); i++) {
     _src[i] = (int32_t)i;
   }
   memcpy(srccpy, src, size);
 
   /* Run all the suite */
   result = all_tests();
   if (result != 0) {
     printf(" (%s)\n", result);
   }
   else {
     printf(" ALL TESTS PASSED\n");
   }
   printf("\tTests run: %d\n", tests_run);
 
   blosc_test_free(src);
   blosc_test_free(srccpy);
   blosc_test_free(dest);
   blosc_test_free(dest2);
 
   blosc_destroy();
 
+  /* Reset envvar */
+  unsetenv("BLOSC_NOLOCK");
+
   return result != 0;
 }
diff --git a/tests/test_prefilter.c b/tests/test_prefilter.c
index 0452b0bc..a8026957 100644
--- a/tests/test_prefilter.c
+++ b/tests/test_prefilter.c
@@ -26,8 +26,8 @@ static int32_t data[SIZE];
 static int32_t data2[SIZE];
 static int32_t data_out[SIZE + BLOSC_MAX_OVERHEAD / sizeof(int32_t)];
 static int32_t data_dest[SIZE];
-size_t isize = SIZE * sizeof(int32_t);
-size_t osize = SIZE * sizeof(int32_t) + BLOSC_MAX_OVERHEAD;
+int32_t isize = SIZE * sizeof(int32_t);
+int32_t osize = SIZE * sizeof(int32_t) + BLOSC_MAX_OVERHEAD;
 int dsize = SIZE * sizeof(int32_t);
 int csize;
 
@@ -58,33 +58,33 @@ int prefilter_func(blosc2_prefilter_params *pparams) {
 static char *test_prefilter1(void) {
   // Set some prefilter parameters and function
   cparams.prefilter = (blosc2_prefilter_fn)prefilter_func;
   // We need to zero the contents of the pparams.  TODO: make a constructor for ppparams.
   blosc2_prefilter_params pparams = {0};
   test_pparams tpparams = {0};
   tpparams.ninputs = 1;
   tpparams.inputs[0] = (uint8_t*)data;
   tpparams.input_typesizes[0] = cparams.typesize;
   pparams.user_data = (void*)&tpparams;
   cparams.pparams = &pparams;
   cctx = blosc2_create_cctx(cparams);
 
-  csize = blosc2_compress_ctx(cctx, data, isize, data_out, osize);
+  csize = blosc2_compress_ctx(cctx, data, isize, data_out, (size_t)osize);
   mu_assert("Compression error", csize > 0);
 
   /* Create a context for decompression */
   dctx = blosc2_create_dctx(dparams);
 
   /* Decompress  */
   dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   mu_assert("Decompression error", dsize > 0);
 
   for (int i = 0; i < SIZE; i++) {
     mu_assert("Decompressed data differs from original!", data[i] == data_dest[i]);
   }
 
   /* Free resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return 0;
 }
@@ -93,39 +93,39 @@ static char *test_prefilter1(void) {
 static char *test_prefilter2(void) {
   // Set some prefilter parameters and function
   cparams.prefilter = (blosc2_prefilter_fn)prefilter_func;
   // We need to zero the contents of the pparams.  TODO: make a constructor for ppparams.
   blosc2_prefilter_params pparams = {0};
   test_pparams tpparams = {0};
   tpparams.ninputs = 2;
   tpparams.inputs[0] = (uint8_t*)data;
   tpparams.inputs[1] = (uint8_t*)data2;
   tpparams.input_typesizes[0] = cparams.typesize;
   tpparams.input_typesizes[1] = cparams.typesize;
   pparams.user_data = (void*)&tpparams;
   cparams.pparams = &pparams;
   cctx = blosc2_create_cctx(cparams);
 
-  csize = blosc2_compress_ctx(cctx, data, isize, data_out, osize);
+  csize = blosc2_compress_ctx(cctx, data, isize, data_out, (size_t)osize);
   mu_assert("Buffer is uncompressible", csize != 0);
   mu_assert("Compression error", csize > 0);
 
   /* Create a context for decompression */
   dctx = blosc2_create_dctx(dparams);
 
   /* Decompress  */
   dsize = blosc2_decompress_ctx(dctx, data_out, csize, data_dest, (size_t)dsize);
   mu_assert("Decompression error", dsize > 0);
 
   for (int i = 0; i < SIZE; i++) {
     if ((data[i] + data2[i]) != data_dest[i]) {
       printf("Error in pos '%d': (%d + %d) != %d\n", i, data[i], data2[i], data_dest[i]);
     }
     mu_assert("Decompressed data differs from original!", (data[i] + data2[i]) == data_dest[i]);
   }
 
   /* Free resources */
   blosc2_free_ctx(cctx);
   blosc2_free_ctx(dctx);
 
   return 0;
 }
diff --git a/tests/test_reorder_offsets.c b/tests/test_reorder_offsets.c
index 15a89e47..ecf67601 100644
--- a/tests/test_reorder_offsets.c
+++ b/tests/test_reorder_offsets.c
@@ -33,9 +33,9 @@ typedef struct {
 }test_storage;
 
 test_storage tstorage[] = {
-    {false, NULL},  // memory - schunk
-    {true, NULL},  // memory - frame
-    {true, "test_reorder_offsets.b2frame"}, // disk - frame
+    // {false, NULL},  // memory - schunk
+    // {true, NULL},  // memory - frame
+    // {true, "test_reorder_offsets.b2frame"}, // disk - frame
     {false, "test_reorder_offsets.b2eframe"}, // disk - eframe
 };
 
@@ -45,56 +45,61 @@ int32_t *data;
 int32_t *data_dest;
 
 static char* test_reorder_offsets(void) {
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  /* Free resources */
+  if (tdata.urlpath != NULL && tdata.sequential == false) {
+    blosc2_remove_dir(tdata.urlpath);
+  }
+
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.sequential=tdata.sequential, .urlpath=tdata.urlpath, .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < tdata.nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   int *offsets_order = malloc(sizeof(int) * tdata.nchunks);
   for (int i = 0; i < tdata.nchunks; ++i) {
     offsets_order[i] = (i + 3) % tdata.nchunks;
   }
   int err = blosc2_schunk_reorder_offsets(schunk, offsets_order);
   mu_assert("ERROR: can not reorder chunks", err >= 0);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < tdata.nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + (offsets_order[nchunk]) * CHUNKSIZE);
     }
   }
 
   /* Free resources */
   if (!storage.sequential && storage.urlpath != NULL) {
     blosc2_remove_dir(storage.urlpath);
   }
   free(offsets_order);
   blosc2_schunk_free(schunk);
 
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_schunk.c b/tests/test_schunk.c
index 9b44540f..8419d847 100644
--- a/tests/test_schunk.c
+++ b/tests/test_schunk.c
@@ -22,97 +22,97 @@ int nchunks;
 static char* test_schunk(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   // Add a couple of metalayers
   blosc2_add_metalayer(schunk, "metalayer1", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
   blosc2_add_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer1", sizeof("my metalayer1"));
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   blosc2_update_metalayer(schunk, "metalayer2", (uint8_t*)"my metalayer2", sizeof("my metalayer2"));
   // Attach some user metadata into it
   blosc2_update_usermeta(schunk, (uint8_t *) "testing the usermeta", 16, BLOSC2_CPARAMS_DEFAULTS);
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   if (nchunks > 0) {
     mu_assert("ERROR: bad compression ratio in frame", nbytes > 10 * cbytes);
   }
 
   // Exercise the metadata retrieval machinery
   bool needs_free;
   uint8_t* chunk;
   size_t nbytes_, cbytes_, blocksize;
   nbytes = 0;
   cbytes = 0;
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_get_chunk(schunk, nchunk, &chunk, &needs_free);
     mu_assert("ERROR: chunk cannot be retrieved correctly.", dsize >= 0);
     blosc_cbuffer_sizes(chunk, &nbytes_, &cbytes_, &blocksize);
     nbytes += nbytes_;
     cbytes += cbytes_;
     if (needs_free) {
       free(chunk);
     }
   }
   mu_assert("ERROR: nbytes is not correct", nbytes == schunk->nbytes);
   mu_assert("ERROR: cbytes is not correct", cbytes == schunk->cbytes);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   // metalayers
   uint8_t* content;
   uint32_t content_len;
   blosc2_get_metalayer(schunk, "metalayer1", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer1", content_len) == 0);
   free(content);
   blosc2_get_metalayer(schunk, "metalayer2", &content, &content_len);
   mu_assert("ERROR: bad metalayer content", strncmp((char*)content, "my metalayer2", content_len) == 0);
   free(content);
 
   // Check the usermeta
   uint8_t* content2;
   int32_t content2_len = blosc2_get_usermeta(schunk, &content2);
   mu_assert("ERROR: bad usermeta", strncmp((char*)content2, "testing the usermeta", 16) == 0);
   mu_assert("ERROR: bad usermeta_len", content2_len == 16);
   free(content2);
 
   /* Free resources */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_schunk_frame.c b/tests/test_schunk_frame.c
index 7fccddb6..55772511 100644
--- a/tests/test_schunk_frame.c
+++ b/tests/test_schunk_frame.c
@@ -21,53 +21,53 @@ int sequential = false;
 
 
 static char* test_schunk_sframe(void) {
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int32_t *data = malloc(isize);
   int32_t *data_dest = malloc(isize);
   int dsize;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   blosc2_storage storage = {.sequential=sequential};
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append in frame", nchunks_ > 0);
   }
 
   // Get a memory frame out of the schunk
   uint8_t* sframe;
   int64_t len = blosc2_schunk_to_sframe(schunk, &sframe);
   mu_assert("Error in getting a sframe", len > 0);
 
   // Free completely schunk
   blosc2_schunk_free(schunk);
   // ...and another schunk backed by the sframe
   schunk = blosc2_schunk_open_sframe(sframe, len);
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly.", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip",data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   /* Free resources */
   free(data);
   free(data_dest);
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_update_chunk.c b/tests/test_update_chunk.c
index 9e5140fc..74d30c90 100644
--- a/tests/test_update_chunk.c
+++ b/tests/test_update_chunk.c
@@ -32,8 +32,9 @@ typedef struct {
 } test_ndata;
 
 test_ndata tndata[] = {
+    {1, 4},
     {10, 4},
     {5,  0},
     {33, 32},
     {1,  0}
 };
@@ -51,83 +52,86 @@ test_storage tstorage[] = {
 };
 
 static char* test_update_chunk(void) {
+  /* Free resources */
+  if (tdata.urlpath != NULL && tdata.sequential == false) {
+    blosc2_remove_dir(tdata.urlpath);
+  }
+
   static int32_t data[CHUNKSIZE];
-  int32_t *data_dest = malloc(CHUNKSIZE * sizeof(int32_t));
-  size_t isize = CHUNKSIZE * sizeof(int32_t);
+  static int32_t data_dest[CHUNKSIZE];
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 5;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
   blosc2_storage storage = {.cparams=&cparams, .dparams=&dparams,
                             .urlpath = tdata.urlpath,
                             .sequential = tdata.sequential};
 
   schunk = blosc2_schunk_new(storage);
 
   // Feed it with data
   for (int nchunk = 0; nchunk < tdata.nchunks; nchunk++) {
     for (int i = 0; i < CHUNKSIZE; i++) {
       data[i] = i + nchunk * CHUNKSIZE;
     }
     int nchunks_ = blosc2_schunk_append_buffer(schunk, data, isize);
     mu_assert("ERROR: bad append", nchunks_ > 0);
   }
 
   // Check that the chunks have been decompressed correctly
   for (int nchunk = 0; nchunk < tdata.nchunks; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly", dsize >= 0);
     for (int i = 0; i < CHUNKSIZE; i++) {
       mu_assert("ERROR: bad roundtrip", data_dest[i] == i + nchunk * CHUNKSIZE);
     }
   }
 
   for (int i = 0; i < tdata.nupdates; ++i) {
     // Create chunk
     for (int j = 0; j < CHUNKSIZE; ++j) {
       data[j] = i;
     }
 
     int32_t datasize = sizeof(int32_t) * CHUNKSIZE;
     int32_t chunksize = sizeof(int32_t) * CHUNKSIZE + BLOSC_MAX_OVERHEAD;
     uint8_t *chunk = malloc(chunksize);
     int csize = blosc2_compress_ctx(schunk->cctx, data, datasize, chunk, chunksize);
     mu_assert("ERROR: chunk cannot be compressed", csize >= 0);
 
     // Update a random position
     int pos = rand() % schunk->nchunks;
     int _nchunks = blosc2_schunk_update_chunk(schunk, pos, chunk, true);
     mu_assert("ERROR: chunk cannot be updated correctly", _nchunks > 0);
     free(chunk);
 
     // Assert updated chunk
     dsize = blosc2_schunk_decompress_chunk(schunk, pos, (void *) data_dest, isize);
     mu_assert("ERROR: chunk cannot be decompressed correctly", dsize >= 0);
     for (int j = 0; j < CHUNKSIZE; j++) {
       int32_t a = data_dest[j];
       mu_assert("ERROR: bad roundtrip", a == i);
     }
   }
   /* Free resources */
   if (!storage.sequential && storage.urlpath != NULL) {
     blosc2_remove_dir(storage.urlpath);
   }
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
-  free(data_dest);
-
   return EXIT_SUCCESS;
 }
 
diff --git a/tests/test_zero_runlen.c b/tests/test_zero_runlen.c
new file mode 100644
index 00000000..0f200608
--- /dev/null
+++ b/tests/test_zero_runlen.c
@@ -0,0 +1,217 @@
+/*
+  Copyright (C) 2020  The Blosc Developers
+  http://blosc.org
+  License: BSD (see LICENSE.txt)
+
+  Benchmark showing Blosc zero detection capabilities via run-length.
+
+*/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <assert.h>
+#include <math.h>
+
+#include "blosc2.h"
+#include "cutest.h"
+
+
+#define KB  1024
+#define MB  (1024*KB)
+#define GB  (1024*MB)
+
+#define NCHUNKS (10)
+#define CHUNKSIZE (5 * 1000)  // > NCHUNKS for the bench purposes
+#define NTHREADS 4
+
+#define REPEATED_VALUE 1
+
+enum {
+  ZERO_DETECTION = 0,
+  CHECK_ZEROS = 1,
+  CHECK_NANS = 2,
+  CHECK_VALUES = 3,
+};
+
+typedef struct {
+  bool sequential;
+  char *urlpath;
+}test_zero_runlen_backend;
+
+CUTEST_TEST_DATA(zero_runlen) {
+  blosc2_cparams cparams;
+};
+
+CUTEST_TEST_SETUP(zero_runlen) {
+  blosc_init();
+  data->cparams = BLOSC2_CPARAMS_DEFAULTS;
+  data->cparams.typesize = sizeof(int32_t);
+  data->cparams.compcode = BLOSC_BLOSCLZ;
+  data->cparams.clevel = 9;
+  data->cparams.nthreads = NTHREADS;
+
+  CUTEST_PARAMETRIZE(svalue, int, CUTEST_DATA(
+      ZERO_DETECTION,
+      CHECK_ZEROS,
+      CHECK_NANS,
+      CHECK_VALUES
+  ));
+  CUTEST_PARAMETRIZE(backend, test_zero_runlen_backend, CUTEST_DATA(
+      {false, NULL},  // memory - schunk
+      {true, NULL},  // memory - frame
+      {true, "test_zero_runlen.b2frame"}, // disk - frame
+      {false, "test_zero_runlen.b2eframe"}, // disk - eframe
+  ));
+}
+
+
+CUTEST_TEST_TEST(zero_runlen) {
+
+  CUTEST_GET_PARAMETER(svalue, int);
+  CUTEST_GET_PARAMETER(backend, test_zero_runlen_backend);
+
+  /* Free resources */
+  if (backend.urlpath != NULL && backend.sequential == false) {
+    blosc2_remove_dir(backend.urlpath);
+  }
+
+  blosc2_schunk *schunk;
+  int32_t isize = CHUNKSIZE * sizeof(int32_t);
+  int32_t osize = CHUNKSIZE * sizeof(int32_t) + BLOSC_MAX_OVERHEAD;
+  int dsize, csize;
+  int nchunk, nchunks;
+  int rc;
+  int32_t value = REPEATED_VALUE;
+  float fvalue;
+
+  int32_t *data_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
+  int32_t *rec_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
+
+  /* Initialize the Blosc compressor */
+  blosc_init();
+
+  /* Create a super-chunk container */
+  blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
+  cparams.typesize = sizeof(int32_t);
+  cparams.compcode = BLOSC_BLOSCLZ;
+  cparams.clevel = 9;
+  cparams.nthreads = NTHREADS;
+  blosc2_storage storage = {.cparams=&cparams, .sequential=backend.sequential, .urlpath = backend.urlpath};
+  schunk = blosc2_schunk_new(storage);
+
+  /* Append the chunks */
+  void* chunk = malloc(BLOSC_EXTENDED_HEADER_LENGTH + isize);
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    switch (svalue) {
+      case ZERO_DETECTION:
+        memset(data_buffer, 0, isize);
+        csize = blosc2_compress(5, 1, sizeof(int32_t), data_buffer, isize, chunk, osize);
+        break;
+      case CHECK_ZEROS:
+        csize = blosc2_chunk_zeros(isize, sizeof(int32_t), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
+        break;
+      case CHECK_NANS:
+        csize = blosc2_chunk_nans(isize, sizeof(float), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
+        break;
+      case CHECK_VALUES:
+        csize = blosc2_chunk_repeatval(isize, sizeof(int32_t), chunk,
+                                       BLOSC_EXTENDED_HEADER_LENGTH + sizeof(int32_t), &value);
+        break;
+      default:
+        CUTEST_ASSERT("Unrecognized case", false);
+    }
+
+    CUTEST_ASSERT("Error creating chunk", csize >= 0);
+
+    nchunks = blosc2_schunk_append_chunk(schunk, chunk, true);
+    CUTEST_ASSERT("Error appending chunk", nchunks >= 0);
+  }
+  free(chunk);
+
+
+  /* Retrieve and decompress the chunks */
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, rec_buffer, isize);
+    CUTEST_ASSERT("Decompression error", dsize >= 0);
+
+    CUTEST_ASSERT("", dsize == (int)isize);
+  }
+
+  /* Exercise the getitem */
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    bool needs_free;
+    uint8_t* chunk_;
+    csize = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_, &needs_free);
+    CUTEST_ASSERT("blosc2_schunk_get_chunk error.  Error code: %d\n", csize >= 0);
+
+    switch (svalue) {
+      case CHECK_VALUES:
+        rc = blosc_getitem(chunk_, nchunk, 1, &value);
+        CUTEST_ASSERT("Error in getitem of a special value", rc >= 0);
+        CUTEST_ASSERT("Wrong value!", value == REPEATED_VALUE);
+        break;
+      case CHECK_NANS:
+        rc = blosc_getitem(chunk_, nchunk, 1, &fvalue);
+        CUTEST_ASSERT("Error in getitem of a special value", rc >= 0);
+        CUTEST_ASSERT("Wrong value!", isnan(fvalue));
+        break;
+      default:
+        // It can only be zeros
+        rc = blosc_getitem(chunk_, nchunk, 1, &value);
+        CUTEST_ASSERT("Error in getitem of a special value", rc >= 0);
+        CUTEST_ASSERT("Wrong value!", value == 0);
+    }
+    if (needs_free) {
+      free(chunk_);
+    }
+  }
+
+  /* Check that all the values have a good roundtrip */
+  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
+    dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) rec_buffer, isize);
+    CUTEST_ASSERT("Decompression error", dsize >= 0);
+
+    CUTEST_ASSERT("Dest size is not equal to src size", dsize == (int)isize);
+    if (svalue == CHECK_VALUES) {
+      int32_t* buffer = (int32_t*)rec_buffer;
+      for (int i = 0; i < CHUNKSIZE; i++) {
+        CUTEST_ASSERT("Value is not correct in chunk", buffer[i] == REPEATED_VALUE);
+      }
+    }
+    else if (svalue == CHECK_NANS) {
+      float* buffer = (float*)rec_buffer;
+      for (int i = 0; i < CHUNKSIZE; i++) {
+        CUTEST_ASSERT("Value is not correct in chunk", isnan(buffer[i]));
+      }
+    }
+    else {
+      int32_t* buffer = (int32_t*)rec_buffer;
+      for (int i = 0; i < CHUNKSIZE; i++) {
+        CUTEST_ASSERT("Value is not correct in chunk", buffer[i] == 0);
+      }
+    }
+  }
+
+  /* Free resources */
+  free(data_buffer);
+  free(rec_buffer);
+  /* Destroy the super-chunk */
+  blosc2_schunk_free(schunk);
+  /* Destroy the Blosc environment */
+
+  /* Free resources */
+  if (backend.urlpath != NULL && backend.sequential == false) {
+    blosc2_remove_dir(backend.urlpath);
+  }
+
+  return 0;
+}
+
+CUTEST_TEST_TEARDOWN(zero_runlen) {
+  blosc_destroy();
+}
+
+
+int main() {
+  CUTEST_TEST_RUN(zero_runlen)
+}
