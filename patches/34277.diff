commit 7fa93c0cfdfa3163910c1fa191867dc315d634f6
Merge: 6d3586322e c4c0aa1975
Author: Mark <mark.raasveldt@gmail.com>
Date:   Tue Jun 1 14:10:43 2021 +0200

    Merge pull request #1776 from hannesmuehleisen/ossfuzz
    
    Fixing some issues flagged by ossfuzz

diff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp
index 6ec090423c..86b58c2b15 100644
--- a/src/include/duckdb/parser/transformer.hpp
+++ b/src/include/duckdb/parser/transformer.hpp
@@ -28,29 +28,33 @@ struct CommonTableExpressionInfo;
 //! The transformer class is responsible for transforming the internal Postgres
 //! parser representation into the DuckDB representation
 class Transformer {
+	static constexpr const idx_t DEFAULT_MAX_EXPRESSION_DEPTH = 1000;
+
 public:
-	explicit Transformer(Transformer *parent = nullptr) : parent(parent) {
+	explicit Transformer(Transformer *parent = nullptr, idx_t max_expression_depth_p = DEFAULT_MAX_EXPRESSION_DEPTH)
+	    : parent(parent), max_expression_depth(parent ? parent->max_expression_depth : max_expression_depth_p) {
 	}
 
 	//! Transforms a Postgres parse tree into a set of SQL Statements
 	bool TransformParseTree(duckdb_libpgquery::PGList *tree, vector<unique_ptr<SQLStatement>> &statements);
 	string NodetypeToString(duckdb_libpgquery::PGNodeTag type);
 
 	idx_t ParamCount() {
 		return parent ? parent->ParamCount() : prepared_statement_parameter_index;
 	}
 
 private:
 	Transformer *parent;
+	idx_t max_expression_depth;
 	//! The current prepared statement parameter index
 	idx_t prepared_statement_parameter_index = 0;
 	//! Holds window expressions defined by name. We need those when transforming the expressions referring to them.
 	unordered_map<string, duckdb_libpgquery::PGWindowDef *> window_clauses;
 
 	void SetParamCount(idx_t new_count) {
 		if (parent) {
 			parent->SetParamCount(new_count);
 		} else {
 			this->prepared_statement_parameter_index = new_count;
 		}
 	}
@@ -58,175 +62,177 @@ private:
 private:
 	//! Transforms a Postgres statement into a single SQL statement
 	unique_ptr<SQLStatement> TransformStatement(duckdb_libpgquery::PGNode *stmt);
 	//===--------------------------------------------------------------------===//
 	// Statement transformation
 	//===--------------------------------------------------------------------===//
 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a SelectStatement
 	unique_ptr<SelectStatement> TransformSelect(duckdb_libpgquery::PGNode *node, bool isSelect = true);
 	//! Transform a Postgres T_AlterStmt node into a AlterStatement
 	unique_ptr<AlterStatement> TransformAlter(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGRenameStmt node into a RenameStatement
 	unique_ptr<AlterStatement> TransformRename(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
 	unique_ptr<CreateStatement> TransformCreateTable(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateStmt node into a CreateStatement
 	unique_ptr<CreateStatement> TransformCreateTableAs(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres node into a CreateStatement
 	unique_ptr<CreateStatement> TransformCreateSchema(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateSeqStmt node into a CreateStatement
 	unique_ptr<CreateStatement> TransformCreateSequence(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGViewStmt node into a CreateStatement
 	unique_ptr<CreateStatement> TransformCreateView(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGIndexStmt node into CreateStatement
 	unique_ptr<CreateStatement> TransformCreateIndex(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGCreateFunctionStmt node into CreateStatement
 	unique_ptr<CreateStatement> TransformCreateFunction(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGDropStmt node into a Drop[Table,Schema]Statement
 	unique_ptr<SQLStatement> TransformDrop(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGInsertStmt node into a InsertStatement
 	unique_ptr<InsertStatement> TransformInsert(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGCopyStmt node into a CopyStatement
 	unique_ptr<CopyStatement> TransformCopy(duckdb_libpgquery::PGNode *node);
 	void TransformCopyOptions(CopyInfo &info, duckdb_libpgquery::PGList *options);
 	//! Transform a Postgres duckdb_libpgquery::T_PGTransactionStmt node into a TransactionStatement
 	unique_ptr<TransactionStatement> TransformTransaction(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres T_DeleteStatement node into a DeleteStatement
 	unique_ptr<DeleteStatement> TransformDelete(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGUpdateStmt node into a UpdateStatement
 	unique_ptr<UpdateStatement> TransformUpdate(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGPragmaStmt node into a PragmaStatement
 	unique_ptr<PragmaStatement> TransformPragma(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGExportStmt node into a ExportStatement
 	unique_ptr<ExportStatement> TransformExport(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres duckdb_libpgquery::T_PGImportStmt node into a PragmaStatement
 	unique_ptr<PragmaStatement> TransformImport(duckdb_libpgquery::PGNode *node);
 	unique_ptr<ExplainStatement> TransformExplain(duckdb_libpgquery::PGNode *node);
 	unique_ptr<VacuumStatement> TransformVacuum(duckdb_libpgquery::PGNode *node);
 	unique_ptr<PragmaStatement> TransformShow(duckdb_libpgquery::PGNode *node);
 	unique_ptr<ShowStatement> TransformShowSelect(duckdb_libpgquery::PGNode *node);
 
 	unique_ptr<PrepareStatement> TransformPrepare(duckdb_libpgquery::PGNode *node);
 	unique_ptr<ExecuteStatement> TransformExecute(duckdb_libpgquery::PGNode *node);
 	unique_ptr<CallStatement> TransformCall(duckdb_libpgquery::PGNode *node);
 	unique_ptr<DropStatement> TransformDeallocate(duckdb_libpgquery::PGNode *node);
 	unique_ptr<SetStatement> TransformSet(duckdb_libpgquery::PGNode *node);
 	unique_ptr<SQLStatement> TransformCheckpoint(duckdb_libpgquery::PGNode *node);
 	unique_ptr<LoadStatement> TransformLoad(duckdb_libpgquery::PGNode *node);
 
 	//===--------------------------------------------------------------------===//
 	// Query Node Transform
 	//===--------------------------------------------------------------------===//
 	//! Transform a Postgres duckdb_libpgquery::T_PGSelectStmt node into a QueryNode
 	unique_ptr<QueryNode> TransformSelectNode(duckdb_libpgquery::PGSelectStmt *node);
 
 	//===--------------------------------------------------------------------===//
 	// Expression Transform
 	//===--------------------------------------------------------------------===//
 	//! Transform a Postgres boolean expression into an Expression
-	unique_ptr<ParsedExpression> TransformBoolExpr(duckdb_libpgquery::PGBoolExpr *root);
+	unique_ptr<ParsedExpression> TransformBoolExpr(duckdb_libpgquery::PGBoolExpr *root, idx_t depth);
 	//! Transform a Postgres case expression into an Expression
-	unique_ptr<ParsedExpression> TransformCase(duckdb_libpgquery::PGCaseExpr *root);
+	unique_ptr<ParsedExpression> TransformCase(duckdb_libpgquery::PGCaseExpr *root, idx_t depth);
 	//! Transform a Postgres type cast into an Expression
-	unique_ptr<ParsedExpression> TransformTypeCast(duckdb_libpgquery::PGTypeCast *root);
+	unique_ptr<ParsedExpression> TransformTypeCast(duckdb_libpgquery::PGTypeCast *root, idx_t depth);
 	//! Transform a Postgres coalesce into an Expression
-	unique_ptr<ParsedExpression> TransformCoalesce(duckdb_libpgquery::PGAExpr *root);
+	unique_ptr<ParsedExpression> TransformCoalesce(duckdb_libpgquery::PGAExpr *root, idx_t depth);
 	//! Transform a Postgres column reference into an Expression
-	unique_ptr<ParsedExpression> TransformColumnRef(duckdb_libpgquery::PGColumnRef *root);
+	unique_ptr<ParsedExpression> TransformColumnRef(duckdb_libpgquery::PGColumnRef *root, idx_t depth);
 	//! Transform a Postgres constant value into an Expression
-	unique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val);
+	unique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val, idx_t depth);
 	//! Transform a Postgres operator into an Expression
-	unique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr *root);
+	unique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr *root, idx_t depth);
 	//! Transform a Postgres abstract expression into an Expression
-	unique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode *node);
+	unique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode *node, idx_t depth);
 	//! Transform a Postgres function call into an Expression
-	unique_ptr<ParsedExpression> TransformFuncCall(duckdb_libpgquery::PGFuncCall *root);
+	unique_ptr<ParsedExpression> TransformFuncCall(duckdb_libpgquery::PGFuncCall *root, idx_t depth);
 	//! Transform a Postgres boolean expression into an Expression
-	unique_ptr<ParsedExpression> TransformInterval(duckdb_libpgquery::PGIntervalConstant *root);
+	unique_ptr<ParsedExpression> TransformInterval(duckdb_libpgquery::PGIntervalConstant *root, idx_t depth);
 	//! Transform a Postgres lambda node [e.g. (x, y) -> x + y] into a lambda expression
-	unique_ptr<ParsedExpression> TransformLambda(duckdb_libpgquery::PGLambdaFunction *node);
+	unique_ptr<ParsedExpression> TransformLambda(duckdb_libpgquery::PGLambdaFunction *node, idx_t depth);
 	//! Transform a Postgres array access node (e.g. x[1] or x[1:3])
-	unique_ptr<ParsedExpression> TransformArrayAccess(duckdb_libpgquery::PGAIndirection *node);
+	unique_ptr<ParsedExpression> TransformArrayAccess(duckdb_libpgquery::PGAIndirection *node, idx_t depth);
 	//! Transform a positional reference (e.g. #1)
-	unique_ptr<ParsedExpression> TransformPositionalReference(duckdb_libpgquery::PGPositionalReference *node);
+	unique_ptr<ParsedExpression> TransformPositionalReference(duckdb_libpgquery::PGPositionalReference *node,
+	                                                          idx_t depth);
 
 	//! Transform a Postgres constant value into an Expression
-	unique_ptr<ParsedExpression> TransformConstant(duckdb_libpgquery::PGAConst *c);
+	unique_ptr<ParsedExpression> TransformConstant(duckdb_libpgquery::PGAConst *c, idx_t depth);
 
-	unique_ptr<ParsedExpression> TransformResTarget(duckdb_libpgquery::PGResTarget *root);
-	unique_ptr<ParsedExpression> TransformNullTest(duckdb_libpgquery::PGNullTest *root);
-	unique_ptr<ParsedExpression> TransformParamRef(duckdb_libpgquery::PGParamRef *node);
-	unique_ptr<ParsedExpression> TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr *root);
+	unique_ptr<ParsedExpression> TransformResTarget(duckdb_libpgquery::PGResTarget *root, idx_t depth);
+	unique_ptr<ParsedExpression> TransformNullTest(duckdb_libpgquery::PGNullTest *root, idx_t depth);
+	unique_ptr<ParsedExpression> TransformParamRef(duckdb_libpgquery::PGParamRef *node, idx_t depth);
+	unique_ptr<ParsedExpression> TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr *root, idx_t depth);
 
-	unique_ptr<ParsedExpression> TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction *node);
+	unique_ptr<ParsedExpression> TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction *node, idx_t depth);
 
-	unique_ptr<ParsedExpression> TransformSubquery(duckdb_libpgquery::PGSubLink *root);
+	unique_ptr<ParsedExpression> TransformSubquery(duckdb_libpgquery::PGSubLink *root, idx_t depth);
 	//===--------------------------------------------------------------------===//
 	// Constraints transform
 	//===--------------------------------------------------------------------===//
 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell *cell);
 
 	unique_ptr<Constraint> TransformConstraint(duckdb_libpgquery::PGListCell *cell, ColumnDefinition &column,
 	                                           idx_t index);
 
 	//===--------------------------------------------------------------------===//
 	// Collation transform
 	//===--------------------------------------------------------------------===//
-	unique_ptr<ParsedExpression> TransformCollateExpr(duckdb_libpgquery::PGCollateClause *collate);
+	unique_ptr<ParsedExpression> TransformCollateExpr(duckdb_libpgquery::PGCollateClause *collate, idx_t depth);
 
 	string TransformCollation(duckdb_libpgquery::PGCollateClause *collate);
 
 	ColumnDefinition TransformColumnDefinition(duckdb_libpgquery::PGColumnDef *cdef);
 	//===--------------------------------------------------------------------===//
 	// Helpers
 	//===--------------------------------------------------------------------===//
 	string TransformAlias(duckdb_libpgquery::PGAlias *root, vector<string> &column_name_alias);
 	void TransformCTE(duckdb_libpgquery::PGWithClause *de_with_clause, QueryNode &select);
 	unique_ptr<SelectStatement> TransformRecursiveCTE(duckdb_libpgquery::PGCommonTableExpr *node,
 	                                                  CommonTableExpressionInfo &info);
 	// Operator String to ExpressionType (e.g. + => OPERATOR_ADD)
 	ExpressionType OperatorToExpressionType(const string &op);
 
 	unique_ptr<ParsedExpression> TransformUnaryOperator(const string &op, unique_ptr<ParsedExpression> child);
 	unique_ptr<ParsedExpression> TransformBinaryOperator(const string &op, unique_ptr<ParsedExpression> left,
 	                                                     unique_ptr<ParsedExpression> right);
 	//===--------------------------------------------------------------------===//
 	// TableRef transform
 	//===--------------------------------------------------------------------===//
 	//! Transform a Postgres node into a TableRef
 	unique_ptr<TableRef> TransformTableRefNode(duckdb_libpgquery::PGNode *node);
 	//! Transform a Postgres FROM clause into a TableRef
 	unique_ptr<TableRef> TransformFrom(duckdb_libpgquery::PGList *root);
 	//! Transform a Postgres table reference into a TableRef
 	unique_ptr<TableRef> TransformRangeVar(duckdb_libpgquery::PGRangeVar *root);
 	//! Transform a Postgres table-producing function into a TableRef
 	unique_ptr<TableRef> TransformRangeFunction(duckdb_libpgquery::PGRangeFunction *root);
 	//! Transform a Postgres join node into a TableRef
 	unique_ptr<TableRef> TransformJoin(duckdb_libpgquery::PGJoinExpr *root);
 	//! Transform a table producing subquery into a TableRef
 	unique_ptr<TableRef> TransformRangeSubselect(duckdb_libpgquery::PGRangeSubselect *root);
 	//! Transform a VALUES list into a set of expressions
 	unique_ptr<TableRef> TransformValuesList(duckdb_libpgquery::PGList *list);
 
 	//! Transform a range var into a (schema) qualified name
 	QualifiedName TransformQualifiedName(duckdb_libpgquery::PGRangeVar *root);
 
 	//! Transform a Postgres TypeName string into a LogicalType
 	LogicalType TransformTypeName(duckdb_libpgquery::PGTypeName *name);
 
 	//! Transform a Postgres GROUP BY expression into a list of Expression
 	bool TransformGroupBy(duckdb_libpgquery::PGList *group, vector<unique_ptr<ParsedExpression>> &result);
 	//! Transform a Postgres ORDER BY expression into an OrderByDescription
 	bool TransformOrderBy(duckdb_libpgquery::PGList *order, vector<OrderByNode> &result);
 
 	//! Transform a Postgres SELECT clause into a list of Expressions
-	bool TransformExpressionList(duckdb_libpgquery::PGList *list, vector<unique_ptr<ParsedExpression>> &result);
+	bool TransformExpressionList(duckdb_libpgquery::PGList *list, vector<unique_ptr<ParsedExpression>> &result,
+	                             idx_t depth);
 
 	//! Transform a Postgres PARTITION BY/ORDER BY specification into lists of expressions
-	void TransformWindowDef(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr);
+	void TransformWindowDef(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr, idx_t depth);
 	//! Transform a Postgres window frame specification into frame expressions
-	void TransformWindowFrame(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr);
+	void TransformWindowFrame(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr, idx_t depth);
 
 	unique_ptr<SampleOptions> TransformSampleOptions(duckdb_libpgquery::PGNode *options);
 };
 
 } // namespace duckdb
diff --git a/src/parser/transform/constraint/transform_constraint.cpp b/src/parser/transform/constraint/transform_constraint.cpp
index f5ff8d4129..6f7deb3d80 100644
--- a/src/parser/transform/constraint/transform_constraint.cpp
+++ b/src/parser/transform/constraint/transform_constraint.cpp
@@ -8,26 +8,26 @@ namespace duckdb {
 unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGListCell *cell) {
 	auto constraint = reinterpret_cast<duckdb_libpgquery::PGConstraint *>(cell->data.ptr_value);
 	switch (constraint->contype) {
 	case duckdb_libpgquery::PG_CONSTR_UNIQUE:
 	case duckdb_libpgquery::PG_CONSTR_PRIMARY: {
 		bool is_primary_key = constraint->contype == duckdb_libpgquery::PG_CONSTR_PRIMARY;
 		vector<string> columns;
 		for (auto kc = constraint->keys->head; kc; kc = kc->next) {
 			columns.emplace_back(reinterpret_cast<duckdb_libpgquery::PGValue *>(kc->data.ptr_value)->val.str);
 		}
 		return make_unique<UniqueConstraint>(columns, is_primary_key);
 	}
 	case duckdb_libpgquery::PG_CONSTR_CHECK: {
-		auto expression = TransformExpression(constraint->raw_expr);
+		auto expression = TransformExpression(constraint->raw_expr, 0);
 		if (expression->HasSubquery()) {
 			throw ParserException("subqueries prohibited in CHECK constraints");
 		}
 		if (expression->IsAggregate()) {
 			throw ParserException("aggregates prohibited in CHECK constraints");
 		}
-		return make_unique<CheckConstraint>(TransformExpression(constraint->raw_expr));
+		return make_unique<CheckConstraint>(TransformExpression(constraint->raw_expr, 0));
 	}
 	default:
 		throw NotImplementedException("Constraint type not handled yet!");
 	}
 }
@@ -35,25 +35,25 @@ unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGLis
 unique_ptr<Constraint> Transformer::TransformConstraint(duckdb_libpgquery::PGListCell *cell, ColumnDefinition &column,
                                                         idx_t index) {
 	auto constraint = reinterpret_cast<duckdb_libpgquery::PGConstraint *>(cell->data.ptr_value);
 	D_ASSERT(constraint);
 	switch (constraint->contype) {
 	case duckdb_libpgquery::PG_CONSTR_NOTNULL:
 		return make_unique<NotNullConstraint>(index);
 	case duckdb_libpgquery::PG_CONSTR_CHECK:
 		return TransformConstraint(cell);
 	case duckdb_libpgquery::PG_CONSTR_PRIMARY:
 		return make_unique<UniqueConstraint>(index, true);
 	case duckdb_libpgquery::PG_CONSTR_UNIQUE:
 		return make_unique<UniqueConstraint>(index, false);
 	case duckdb_libpgquery::PG_CONSTR_NULL:
 		return nullptr;
 	case duckdb_libpgquery::PG_CONSTR_DEFAULT:
-		column.default_value = TransformExpression(constraint->raw_expr);
+		column.default_value = TransformExpression(constraint->raw_expr, 0);
 		return nullptr;
 	case duckdb_libpgquery::PG_CONSTR_FOREIGN:
 	default:
 		throw NotImplementedException("Constraint not implemented!");
 	}
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_array_access.cpp b/src/parser/transform/expression/transform_array_access.cpp
index 80ba5f1602..ef56960d54 100644
--- a/src/parser/transform/expression/transform_array_access.cpp
+++ b/src/parser/transform/expression/transform_array_access.cpp
@@ -6,55 +6,56 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformArrayAccess(duckdb_libpgquery::PGAIndirection *indirection_node) {
+unique_ptr<ParsedExpression> Transformer::TransformArrayAccess(duckdb_libpgquery::PGAIndirection *indirection_node,
+                                                               idx_t depth) {
 	// transform the source expression
 	unique_ptr<ParsedExpression> result;
-	result = TransformExpression(indirection_node->arg);
+	result = TransformExpression(indirection_node->arg, depth + 1);
 
 	// now go over the indices
 	// note that a single indirection node can contain multiple indices
 	// this happens for e.g. more complex accesses (e.g. (foo).field1[42])
 	for (auto node = indirection_node->indirection->head; node != nullptr; node = node->next) {
 		auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value);
 		if (!target) {
 			break;
 		}
 		switch (target->type) {
 		case duckdb_libpgquery::T_PGAIndices: {
 			// index access (either slice or extract)
 			auto index = (duckdb_libpgquery::PGAIndices *)target;
 			vector<unique_ptr<ParsedExpression>> children;
 			children.push_back(move(result));
 			if (index->is_slice) {
 				// slice
 				children.push_back(!index->lidx ? make_unique<ConstantExpression>(Value())
-				                                : TransformExpression(index->lidx));
+				                                : TransformExpression(index->lidx, depth + 1));
 				children.push_back(!index->uidx ? make_unique<ConstantExpression>(Value())
-				                                : TransformExpression(index->uidx));
+				                                : TransformExpression(index->uidx, depth + 1));
 				result = make_unique<OperatorExpression>(ExpressionType::ARRAY_SLICE, move(children));
 			} else {
 				// array access
 				D_ASSERT(!index->lidx);
 				D_ASSERT(index->uidx);
-				children.push_back(TransformExpression(index->uidx));
+				children.push_back(TransformExpression(index->uidx, depth + 1));
 				result = make_unique<OperatorExpression>(ExpressionType::ARRAY_EXTRACT, move(children));
 			}
 			break;
 		}
 		case duckdb_libpgquery::T_PGString: {
 			auto val = (duckdb_libpgquery::PGValue *)target;
 			vector<unique_ptr<ParsedExpression>> children;
 			children.push_back(move(result));
-			children.push_back(TransformValue(*val));
+			children.push_back(TransformValue(*val, depth + 1));
 			result = make_unique<OperatorExpression>(ExpressionType::STRUCT_EXTRACT, move(children));
 			break;
 		}
 		case duckdb_libpgquery::T_PGAStar:
 		default:
 			throw NotImplementedException("Unimplemented subscript type");
 		}
 	}
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_bool_expr.cpp b/src/parser/transform/expression/transform_bool_expr.cpp
index cdd4e93310..47e0d53231 100644
--- a/src/parser/transform/expression/transform_bool_expr.cpp
+++ b/src/parser/transform/expression/transform_bool_expr.cpp
@@ -4,47 +4,47 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformBoolExpr(duckdb_libpgquery::PGBoolExpr *root) {
+unique_ptr<ParsedExpression> Transformer::TransformBoolExpr(duckdb_libpgquery::PGBoolExpr *root, idx_t depth) {
 	unique_ptr<ParsedExpression> result;
 	for (auto node = root->args->head; node != nullptr; node = node->next) {
-		auto next = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value));
+		auto next = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value), depth + 1);
 
 		switch (root->boolop) {
 		case duckdb_libpgquery::PG_AND_EXPR: {
 			if (!result) {
 				result = move(next);
 			} else {
 				result = make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(result), move(next));
 			}
 			break;
 		}
 		case duckdb_libpgquery::PG_OR_EXPR: {
 			if (!result) {
 				result = move(next);
 			} else {
 				result = make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_OR, move(result), move(next));
 			}
 			break;
 		}
 		case duckdb_libpgquery::PG_NOT_EXPR: {
 			if (next->type == ExpressionType::COMPARE_IN) {
 				// convert COMPARE_IN to COMPARE_NOT_IN
 				next->type = ExpressionType::COMPARE_NOT_IN;
 				result = move(next);
 			} else if (next->type >= ExpressionType::COMPARE_EQUAL &&
 			           next->type <= ExpressionType::COMPARE_GREATERTHANOREQUALTO) {
 				// NOT on a comparison: we can negate the comparison
 				// e.g. NOT(x > y) is equivalent to x <= y
 				next->type = NegateComparisionExpression(next->type);
 				result = move(next);
 			} else {
 				result = make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(next));
 			}
 			break;
 		}
 		}
 	}
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_case.cpp b/src/parser/transform/expression/transform_case.cpp
index 06e8ae30aa..b02d38b30b 100644
--- a/src/parser/transform/expression/transform_case.cpp
+++ b/src/parser/transform/expression/transform_case.cpp
@@ -5,37 +5,38 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformCase(duckdb_libpgquery::PGCaseExpr *root) {
+unique_ptr<ParsedExpression> Transformer::TransformCase(duckdb_libpgquery::PGCaseExpr *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
 	// CASE expression WHEN value THEN result [WHEN ...] ELSE result uses this,
 	// but we rewrite to CASE WHEN expression = value THEN result ... to only
 	// have to handle one case downstream.
 	auto case_node = make_unique<CaseExpression>();
 	for (auto cell = root->args->head; cell != nullptr; cell = cell->next) {
 		CaseCheck case_check;
 
 		auto w = reinterpret_cast<duckdb_libpgquery::PGCaseWhen *>(cell->data.ptr_value);
-		auto test_raw = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(w->expr));
+		auto test_raw = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(w->expr), depth + 1);
 		unique_ptr<ParsedExpression> test;
-		auto arg = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->arg));
+		auto arg = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->arg), depth + 1);
 		if (arg) {
 			case_check.when_expr =
 			    make_unique<ComparisonExpression>(ExpressionType::COMPARE_EQUAL, move(arg), move(test_raw));
 		} else {
 			case_check.when_expr = move(test_raw);
 		}
-		case_check.then_expr = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(w->result));
+		case_check.then_expr = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(w->result), depth + 1);
 		case_node->case_checks.push_back(move(case_check));
 	}
 
 	if (root->defresult) {
-		case_node->else_expr = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->defresult));
+		case_node->else_expr =
+		    TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->defresult), depth + 1);
 	} else {
 		case_node->else_expr = make_unique<ConstantExpression>(Value(LogicalType::SQLNULL));
 	}
 	return move(case_node);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_cast.cpp b/src/parser/transform/expression/transform_cast.cpp
index 7ecd4a6f72..b29c94a96c 100644
--- a/src/parser/transform/expression/transform_cast.cpp
+++ b/src/parser/transform/expression/transform_cast.cpp
@@ -6,27 +6,27 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformTypeCast(duckdb_libpgquery::PGTypeCast *root) {
+unique_ptr<ParsedExpression> Transformer::TransformTypeCast(duckdb_libpgquery::PGTypeCast *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
 	// get the type to cast to
 	auto type_name = root->typeName;
 	LogicalType target_type = TransformTypeName(type_name);
 
 	// check for a constant BLOB value, then return ConstantExpression with BLOB
 	if (target_type == LogicalType::BLOB && root->arg->type == duckdb_libpgquery::T_PGAConst) {
 		auto c = reinterpret_cast<duckdb_libpgquery::PGAConst *>(root->arg);
 		if (c->val.type == duckdb_libpgquery::T_PGString) {
 			return make_unique<ConstantExpression>(Value::BLOB(string(c->val.val.str)));
 		}
 	}
 	// transform the expression node
-	auto expression = TransformExpression(root->arg);
+	auto expression = TransformExpression(root->arg, depth + 1);
 	bool try_cast = root->tryCast;
 
 	// now create a cast operation
 	return make_unique<CastExpression>(target_type, move(expression), try_cast);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_coalesce.cpp b/src/parser/transform/expression/transform_coalesce.cpp
index 7e10b71716..07fb44a3d8 100644
--- a/src/parser/transform/expression/transform_coalesce.cpp
+++ b/src/parser/transform/expression/transform_coalesce.cpp
@@ -5,20 +5,21 @@ namespace duckdb {
 
 // COALESCE(a,b,c) returns the first argument that is NOT NULL, so
 // rewrite into CASE(a IS NOT NULL, a, CASE(b IS NOT NULL, b, c))
-unique_ptr<ParsedExpression> Transformer::TransformCoalesce(duckdb_libpgquery::PGAExpr *root) {
+unique_ptr<ParsedExpression> Transformer::TransformCoalesce(duckdb_libpgquery::PGAExpr *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
 	auto coalesce_args = reinterpret_cast<duckdb_libpgquery::PGList *>(root->lexpr);
 	D_ASSERT(coalesce_args->length > 0); // parser ensures this already
 
 	auto coalesce_op = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
 	for (auto cell = coalesce_args->head; cell; cell = cell->next) {
 		// get the value of the COALESCE
-		auto value_expr = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(cell->data.ptr_value));
+		auto value_expr =
+		    TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(cell->data.ptr_value), depth + 1);
 		coalesce_op->children.push_back(move(value_expr));
 	}
 	return move(coalesce_op);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_columnref.cpp b/src/parser/transform/expression/transform_columnref.cpp
index 2f008bb553..801aa65a19 100644
--- a/src/parser/transform/expression/transform_columnref.cpp
+++ b/src/parser/transform/expression/transform_columnref.cpp
@@ -6,46 +6,46 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformColumnRef(duckdb_libpgquery::PGColumnRef *root) {
+unique_ptr<ParsedExpression> Transformer::TransformColumnRef(duckdb_libpgquery::PGColumnRef *root, idx_t depth) {
 	auto fields = root->fields;
 	switch ((reinterpret_cast<duckdb_libpgquery::PGNode *>(fields->head->data.ptr_value))->type) {
 	case duckdb_libpgquery::T_PGString: {
 		if (fields->length < 1) {
 			throw ParserException("Unexpected field length");
 		}
 		string column_name, table_name;
 		if (fields->length == 1) {
 			column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
 			auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
 			colref->query_location = root->location;
 			return move(colref);
 		} else if (fields->length == 2) {
 			table_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(fields->head->data.ptr_value)->val.str);
 			auto col_node = reinterpret_cast<duckdb_libpgquery::PGNode *>(fields->head->next->data.ptr_value);
 			switch (col_node->type) {
 			case duckdb_libpgquery::T_PGString: {
 				column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(col_node)->val.str);
 				auto colref = make_unique<ColumnRefExpression>(column_name, table_name);
 				colref->query_location = root->location;
 				return move(colref);
 			}
 			case duckdb_libpgquery::T_PGAStar: {
 				return make_unique<TableStarExpression>(table_name);
 			}
 			default:
 				throw NotImplementedException("ColumnRef not implemented!");
 			}
 		} else {
 			throw NotImplementedException("ColumnRef not implemented!");
 		}
 	}
 	case duckdb_libpgquery::T_PGAStar: {
 		return make_unique<StarExpression>();
 	}
 	default:
 		break;
 	}
 	throw NotImplementedException("ColumnRef not implemented!");
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_constant.cpp b/src/parser/transform/expression/transform_constant.cpp
index 191a2ec615..90ea2717f3 100644
--- a/src/parser/transform/expression/transform_constant.cpp
+++ b/src/parser/transform/expression/transform_constant.cpp
@@ -6,75 +6,75 @@
 
 namespace duckdb {
 
-unique_ptr<ConstantExpression> Transformer::TransformValue(duckdb_libpgquery::PGValue val) {
+unique_ptr<ConstantExpression> Transformer::TransformValue(duckdb_libpgquery::PGValue val, idx_t depth) {
 	switch (val.type) {
 	case duckdb_libpgquery::T_PGInteger:
 		D_ASSERT(val.val.ival <= NumericLimits<int32_t>::Maximum());
 		return make_unique<ConstantExpression>(Value::INTEGER((int32_t)val.val.ival));
 	case duckdb_libpgquery::T_PGBitString: // FIXME: this should actually convert to BLOB
 	case duckdb_libpgquery::T_PGString:
 		return make_unique<ConstantExpression>(Value(string(val.val.str)));
 	case duckdb_libpgquery::T_PGFloat: {
 		string_t str_val(val.val.str);
 		bool try_cast_as_integer = true;
 		bool try_cast_as_decimal = true;
 		int decimal_position = -1;
 		for (idx_t i = 0; i < str_val.GetSize(); i++) {
 			if (val.val.str[i] == '.') {
 				// decimal point: cast as either decimal or double
 				try_cast_as_integer = false;
 				decimal_position = i;
 			}
 			if (val.val.str[i] == 'e' || val.val.str[i] == 'E') {
 				// found exponent, cast as double
 				try_cast_as_integer = false;
 				try_cast_as_decimal = false;
 			}
 		}
 		if (try_cast_as_integer) {
 			int64_t bigint_value;
 			// try to cast as bigint first
 			if (TryCast::Operation<string_t, int64_t>(str_val, bigint_value)) {
 				// successfully cast to bigint: bigint value
 				return make_unique<ConstantExpression>(Value::BIGINT(bigint_value));
 			}
 			hugeint_t hugeint_value;
 			// if that is not successful; try to cast as hugeint
 			if (TryCast::Operation<string_t, hugeint_t>(str_val, hugeint_value)) {
 				// successfully cast to bigint: bigint value
 				return make_unique<ConstantExpression>(Value::HUGEINT(hugeint_value));
 			}
 		}
 		if (try_cast_as_decimal && decimal_position >= 0 && str_val.GetSize() < Decimal::MAX_WIDTH_DECIMAL + 2) {
 			// figure out the width/scale based on the decimal position
 			auto width = uint8_t(str_val.GetSize() - 1);
 			auto scale = uint8_t(width - decimal_position);
 			if (val.val.str[0] == '-') {
 				width--;
 			}
 			if (width <= Decimal::MAX_WIDTH_DECIMAL) {
 				// we can cast the value as a decimal
 				Value val = Value(str_val);
 				val = val.CastAs(LogicalType(LogicalTypeId::DECIMAL, width, scale));
 				return make_unique<ConstantExpression>(move(val));
 			}
 		}
 		// if there is a decimal or the value is too big to cast as either hugeint or bigint
 		double dbl_value = Cast::Operation<string_t, double>(str_val);
 		if (!Value::DoubleIsValid(dbl_value)) {
 			throw ParserException("Double value \"%s\" is out of range!", val.val.str);
 		}
 		return make_unique<ConstantExpression>(Value::DOUBLE(dbl_value));
 	}
 	case duckdb_libpgquery::T_PGNull:
 		return make_unique<ConstantExpression>(Value(LogicalType::SQLNULL));
 	default:
 		throw NotImplementedException("Value not implemented!");
 	}
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformConstant(duckdb_libpgquery::PGAConst *c) {
-	return TransformValue(c->val);
+unique_ptr<ParsedExpression> Transformer::TransformConstant(duckdb_libpgquery::PGAConst *c, idx_t depth) {
+	return TransformValue(c->val, depth + 1);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_expression.cpp b/src/parser/transform/expression/transform_expression.cpp
index 4f8caab2c1..a2057dfa5a 100644
--- a/src/parser/transform/expression/transform_expression.cpp
+++ b/src/parser/transform/expression/transform_expression.cpp
@@ -4,99 +4,102 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformResTarget(duckdb_libpgquery::PGResTarget *root) {
+unique_ptr<ParsedExpression> Transformer::TransformResTarget(duckdb_libpgquery::PGResTarget *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
-	auto expr = TransformExpression(root->val);
+	auto expr = TransformExpression(root->val, depth + 1);
 	if (!expr) {
 		return nullptr;
 	}
 	if (root->name) {
 		expr->alias = string(root->name);
 	}
 	return expr;
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr *root) {
+unique_ptr<ParsedExpression> Transformer::TransformNamedArg(duckdb_libpgquery::PGNamedArgExpr *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
-	auto expr = TransformExpression((duckdb_libpgquery::PGNode *)root->arg);
+	auto expr = TransformExpression((duckdb_libpgquery::PGNode *)root->arg, depth + 1);
 	if (root->name) {
 		expr->alias = string(root->name);
 	}
 	return expr;
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformExpression(duckdb_libpgquery::PGNode *node) {
+unique_ptr<ParsedExpression> Transformer::TransformExpression(duckdb_libpgquery::PGNode *node, idx_t depth) {
 	if (!node) {
 		return nullptr;
 	}
+	if (depth > max_expression_depth) {
+		throw ParserException("Expression tree is too deep (maximum depth %d)", max_expression_depth);
+	}
 
 	switch (node->type) {
 	case duckdb_libpgquery::T_PGColumnRef:
-		return TransformColumnRef(reinterpret_cast<duckdb_libpgquery::PGColumnRef *>(node));
+		return TransformColumnRef(reinterpret_cast<duckdb_libpgquery::PGColumnRef *>(node), depth);
 	case duckdb_libpgquery::T_PGAConst:
-		return TransformConstant(reinterpret_cast<duckdb_libpgquery::PGAConst *>(node));
+		return TransformConstant(reinterpret_cast<duckdb_libpgquery::PGAConst *>(node), depth);
 	case duckdb_libpgquery::T_PGAExpr:
-		return TransformAExpr(reinterpret_cast<duckdb_libpgquery::PGAExpr *>(node));
+		return TransformAExpr(reinterpret_cast<duckdb_libpgquery::PGAExpr *>(node), depth);
 	case duckdb_libpgquery::T_PGFuncCall:
-		return TransformFuncCall(reinterpret_cast<duckdb_libpgquery::PGFuncCall *>(node));
+		return TransformFuncCall(reinterpret_cast<duckdb_libpgquery::PGFuncCall *>(node), depth);
 	case duckdb_libpgquery::T_PGBoolExpr:
-		return TransformBoolExpr(reinterpret_cast<duckdb_libpgquery::PGBoolExpr *>(node));
+		return TransformBoolExpr(reinterpret_cast<duckdb_libpgquery::PGBoolExpr *>(node), depth);
 	case duckdb_libpgquery::T_PGTypeCast:
-		return TransformTypeCast(reinterpret_cast<duckdb_libpgquery::PGTypeCast *>(node));
+		return TransformTypeCast(reinterpret_cast<duckdb_libpgquery::PGTypeCast *>(node), depth);
 	case duckdb_libpgquery::T_PGCaseExpr:
-		return TransformCase(reinterpret_cast<duckdb_libpgquery::PGCaseExpr *>(node));
+		return TransformCase(reinterpret_cast<duckdb_libpgquery::PGCaseExpr *>(node), depth);
 	case duckdb_libpgquery::T_PGSubLink:
-		return TransformSubquery(reinterpret_cast<duckdb_libpgquery::PGSubLink *>(node));
+		return TransformSubquery(reinterpret_cast<duckdb_libpgquery::PGSubLink *>(node), depth);
 	case duckdb_libpgquery::T_PGCoalesceExpr:
-		return TransformCoalesce(reinterpret_cast<duckdb_libpgquery::PGAExpr *>(node));
+		return TransformCoalesce(reinterpret_cast<duckdb_libpgquery::PGAExpr *>(node), depth);
 	case duckdb_libpgquery::T_PGNullTest:
-		return TransformNullTest(reinterpret_cast<duckdb_libpgquery::PGNullTest *>(node));
+		return TransformNullTest(reinterpret_cast<duckdb_libpgquery::PGNullTest *>(node), depth);
 	case duckdb_libpgquery::T_PGResTarget:
-		return TransformResTarget(reinterpret_cast<duckdb_libpgquery::PGResTarget *>(node));
+		return TransformResTarget(reinterpret_cast<duckdb_libpgquery::PGResTarget *>(node), depth);
 	case duckdb_libpgquery::T_PGParamRef:
-		return TransformParamRef(reinterpret_cast<duckdb_libpgquery::PGParamRef *>(node));
+		return TransformParamRef(reinterpret_cast<duckdb_libpgquery::PGParamRef *>(node), depth);
 	case duckdb_libpgquery::T_PGNamedArgExpr:
-		return TransformNamedArg(reinterpret_cast<duckdb_libpgquery::PGNamedArgExpr *>(node));
+		return TransformNamedArg(reinterpret_cast<duckdb_libpgquery::PGNamedArgExpr *>(node), depth);
 	case duckdb_libpgquery::T_PGSQLValueFunction:
-		return TransformSQLValueFunction(reinterpret_cast<duckdb_libpgquery::PGSQLValueFunction *>(node));
+		return TransformSQLValueFunction(reinterpret_cast<duckdb_libpgquery::PGSQLValueFunction *>(node), depth);
 	case duckdb_libpgquery::T_PGSetToDefault:
 		return make_unique<DefaultExpression>();
 	case duckdb_libpgquery::T_PGCollateClause:
-		return TransformCollateExpr(reinterpret_cast<duckdb_libpgquery::PGCollateClause *>(node));
+		return TransformCollateExpr(reinterpret_cast<duckdb_libpgquery::PGCollateClause *>(node), depth);
 	case duckdb_libpgquery::T_PGIntervalConstant:
-		return TransformInterval(reinterpret_cast<duckdb_libpgquery::PGIntervalConstant *>(node));
+		return TransformInterval(reinterpret_cast<duckdb_libpgquery::PGIntervalConstant *>(node), depth);
 	case duckdb_libpgquery::T_PGLambdaFunction:
-		return TransformLambda(reinterpret_cast<duckdb_libpgquery::PGLambdaFunction *>(node));
+		return TransformLambda(reinterpret_cast<duckdb_libpgquery::PGLambdaFunction *>(node), depth);
 	case duckdb_libpgquery::T_PGAIndirection:
-		return TransformArrayAccess(reinterpret_cast<duckdb_libpgquery::PGAIndirection *>(node));
+		return TransformArrayAccess(reinterpret_cast<duckdb_libpgquery::PGAIndirection *>(node), depth);
 	case duckdb_libpgquery::T_PGPositionalReference:
-		return TransformPositionalReference(reinterpret_cast<duckdb_libpgquery::PGPositionalReference *>(node));
+		return TransformPositionalReference(reinterpret_cast<duckdb_libpgquery::PGPositionalReference *>(node), depth);
 	default:
 		throw NotImplementedException("Expr of type %d not implemented\n", (int)node->type);
 	}
 }
 
-bool Transformer::TransformExpressionList(duckdb_libpgquery::PGList *list,
-                                          vector<unique_ptr<ParsedExpression>> &result) {
+bool Transformer::TransformExpressionList(duckdb_libpgquery::PGList *list, vector<unique_ptr<ParsedExpression>> &result,
+                                          idx_t depth) {
 	if (!list) {
 		return false;
 	}
 	for (auto node = list->head; node != nullptr; node = node->next) {
 		auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value);
 		if (!target) {
 			return false;
 		}
-		auto expr = TransformExpression(target);
+		auto expr = TransformExpression(target, depth + 1);
 		if (!expr) {
 			return false;
 		}
 		result.push_back(move(expr));
 	}
 	return true;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_function.cpp b/src/parser/transform/expression/transform_function.cpp
index 00034affa4..bfcb36b5d1 100644
--- a/src/parser/transform/expression/transform_function.cpp
+++ b/src/parser/transform/expression/transform_function.cpp
@@ -37,198 +37,199 @@ static ExpressionType WindowToExpressionType(string &fun_name) {
 	return ExpressionType::WINDOW_AGGREGATE;
 }
 
-void Transformer::TransformWindowDef(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr) {
+void Transformer::TransformWindowDef(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr, idx_t depth) {
 	D_ASSERT(window_spec);
 	D_ASSERT(expr);
 
 	// next: partitioning/ordering expressions
-	TransformExpressionList(window_spec->partitionClause, expr->partitions);
+	TransformExpressionList(window_spec->partitionClause, expr->partitions, depth);
 	TransformOrderBy(window_spec->orderClause, expr->orders);
 }
 
-void Transformer::TransformWindowFrame(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr) {
+void Transformer::TransformWindowFrame(duckdb_libpgquery::PGWindowDef *window_spec, WindowExpression *expr,
+                                       idx_t depth) {
 	D_ASSERT(window_spec);
 	D_ASSERT(expr);
 
 	// finally: specifics of bounds
-	expr->start_expr = TransformExpression(window_spec->startOffset);
-	expr->end_expr = TransformExpression(window_spec->endOffset);
+	expr->start_expr = TransformExpression(window_spec->startOffset, depth + 1);
+	expr->end_expr = TransformExpression(window_spec->endOffset, depth + 1);
 
 	if ((window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_PRECEDING) ||
 	    (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING)) {
 		throw Exception(
 		    "Window frames starting with unbounded following or ending in unbounded preceding make no sense");
 	}
 
 	if (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_PRECEDING) {
 		expr->start = WindowBoundary::UNBOUNDED_PRECEDING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_START_UNBOUNDED_FOLLOWING) {
 		expr->start = WindowBoundary::UNBOUNDED_FOLLOWING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_START_VALUE_PRECEDING) {
 		expr->start = WindowBoundary::EXPR_PRECEDING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_START_VALUE_FOLLOWING) {
 		expr->start = WindowBoundary::EXPR_FOLLOWING;
 	} else if ((window_spec->frameOptions & FRAMEOPTION_START_CURRENT_ROW) &&
 	           (window_spec->frameOptions & FRAMEOPTION_RANGE)) {
 		expr->start = WindowBoundary::CURRENT_ROW_RANGE;
 	} else if ((window_spec->frameOptions & FRAMEOPTION_START_CURRENT_ROW) &&
 	           (window_spec->frameOptions & FRAMEOPTION_ROWS)) {
 		expr->start = WindowBoundary::CURRENT_ROW_ROWS;
 	}
 
 	if (window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_PRECEDING) {
 		expr->end = WindowBoundary::UNBOUNDED_PRECEDING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_END_UNBOUNDED_FOLLOWING) {
 		expr->end = WindowBoundary::UNBOUNDED_FOLLOWING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_END_VALUE_PRECEDING) {
 		expr->end = WindowBoundary::EXPR_PRECEDING;
 	} else if (window_spec->frameOptions & FRAMEOPTION_END_VALUE_FOLLOWING) {
 		expr->end = WindowBoundary::EXPR_FOLLOWING;
 	} else if ((window_spec->frameOptions & FRAMEOPTION_END_CURRENT_ROW) &&
 	           (window_spec->frameOptions & FRAMEOPTION_RANGE)) {
 		expr->end = WindowBoundary::CURRENT_ROW_RANGE;
 	} else if ((window_spec->frameOptions & FRAMEOPTION_END_CURRENT_ROW) &&
 	           (window_spec->frameOptions & FRAMEOPTION_ROWS)) {
 		expr->end = WindowBoundary::CURRENT_ROW_ROWS;
 	}
 
 	D_ASSERT(expr->start != WindowBoundary::INVALID && expr->end != WindowBoundary::INVALID);
 	if (((expr->start == WindowBoundary::EXPR_PRECEDING || expr->start == WindowBoundary::EXPR_PRECEDING) &&
 	     !expr->start_expr) ||
 	    ((expr->end == WindowBoundary::EXPR_PRECEDING || expr->end == WindowBoundary::EXPR_PRECEDING) &&
 	     !expr->end_expr)) {
 		throw Exception("Failed to transform window boundary expression");
 	}
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformFuncCall(duckdb_libpgquery::PGFuncCall *root) {
+unique_ptr<ParsedExpression> Transformer::TransformFuncCall(duckdb_libpgquery::PGFuncCall *root, idx_t depth) {
 	auto name = root->funcname;
 	string schema, function_name;
 	if (name->length == 2) {
 		// schema + name
 		schema = reinterpret_cast<duckdb_libpgquery::PGValue *>(name->head->data.ptr_value)->val.str;
 		function_name = reinterpret_cast<duckdb_libpgquery::PGValue *>(name->head->next->data.ptr_value)->val.str;
 	} else {
 		// unqualified name
 		//		schema = DEFAULT_SCHEMA;
 		schema = INVALID_SCHEMA;
 		function_name = reinterpret_cast<duckdb_libpgquery::PGValue *>(name->head->data.ptr_value)->val.str;
 	}
 
 	auto lowercase_name = StringUtil::Lower(function_name);
 
 	if (root->agg_order) {
 		throw ParserException("ORDER BY is not implemented for aggregates");
 	}
 
 	if (root->over) {
 		if (root->agg_distinct) {
 			throw ParserException("DISTINCT is not implemented for window functions!");
 		}
 
 		auto win_fun_type = WindowToExpressionType(lowercase_name);
 		if (win_fun_type == ExpressionType::INVALID) {
 			throw Exception("Unknown/unsupported window function");
 		}
 
 		auto expr = make_unique<WindowExpression>(win_fun_type, schema, lowercase_name);
 
 		if (root->args) {
 			vector<unique_ptr<ParsedExpression>> function_list;
-			auto res = TransformExpressionList(root->args, function_list);
+			auto res = TransformExpressionList(root->args, function_list, depth);
 			if (!res) {
 				throw Exception("Failed to transform window function children");
 			}
 			if (win_fun_type == ExpressionType::WINDOW_AGGREGATE) {
 				for (auto &child : function_list) {
 					expr->children.push_back(move(child));
 				}
 			} else {
 				if (!function_list.empty()) {
 					expr->children.push_back(move(function_list[0]));
 				}
 				if (function_list.size() > 1) {
 					D_ASSERT(win_fun_type == ExpressionType::WINDOW_LEAD || win_fun_type == ExpressionType::WINDOW_LAG);
 					expr->offset_expr = move(function_list[1]);
 				}
 				if (function_list.size() > 2) {
 					D_ASSERT(win_fun_type == ExpressionType::WINDOW_LEAD || win_fun_type == ExpressionType::WINDOW_LAG);
 					expr->default_expr = move(function_list[2]);
 				}
 				D_ASSERT(function_list.size() <= 3);
 			}
 		}
 		auto window_spec = reinterpret_cast<duckdb_libpgquery::PGWindowDef *>(root->over);
 		if (window_spec->name) {
 			auto it = window_clauses.find(StringUtil::Lower(string(window_spec->name)));
 			if (it == window_clauses.end()) {
 				throw ParserException("window \"%s\" does not exist", window_spec->name);
 			}
 			window_spec = it->second;
 			D_ASSERT(window_spec);
 		}
 		auto window_ref = window_spec;
 		if (window_ref->refname) {
 			auto it = window_clauses.find(StringUtil::Lower(string(window_spec->refname)));
 			if (it == window_clauses.end()) {
 				throw ParserException("window \"%s\" does not exist", window_spec->refname);
 			}
 			window_ref = it->second;
 			D_ASSERT(window_ref);
 		}
-		TransformWindowDef(window_ref, expr.get());
-		TransformWindowFrame(window_spec, expr.get());
+		TransformWindowDef(window_ref, expr.get(), depth);
+		TransformWindowFrame(window_spec, expr.get(), depth);
 
 		return move(expr);
 	}
 
 	//  TransformExpressionList??
 	vector<unique_ptr<ParsedExpression>> children;
 	if (root->args != nullptr) {
 		for (auto node = root->args->head; node != nullptr; node = node->next) {
-			auto child_expr = TransformExpression((duckdb_libpgquery::PGNode *)node->data.ptr_value);
+			auto child_expr = TransformExpression((duckdb_libpgquery::PGNode *)node->data.ptr_value, depth + 1);
 			children.push_back(move(child_expr));
 		}
 	}
 	unique_ptr<ParsedExpression> filter_expr;
 	if (root->agg_filter) {
-		filter_expr = TransformExpression(root->agg_filter);
+		filter_expr = TransformExpression(root->agg_filter, depth + 1);
 	}
 
 	// star gets eaten in the parser
 	if (lowercase_name == "count" && children.empty()) {
 		lowercase_name = "count_star";
 	}
 
 	if (lowercase_name == "if") {
 		if (children.size() != 3) {
 			throw ParserException("Wrong number of arguments to IF.");
 		}
 		auto expr = make_unique<CaseExpression>();
 		CaseCheck check;
 		check.when_expr = move(children[0]);
 		check.then_expr = move(children[1]);
 		expr->case_checks.push_back(move(check));
 		expr->else_expr = move(children[2]);
 		return move(expr);
 	} else if (lowercase_name == "construct_array") {
 		auto construct_array = make_unique<OperatorExpression>(ExpressionType::ARRAY_CONSTRUCTOR);
 		construct_array->children = move(children);
 		return move(construct_array);
 	} else if (lowercase_name == "ifnull") {
 		if (children.size() != 2) {
 			throw ParserException("Wrong number of arguments to IFNULL.");
 		}
 
 		//  Two-argument COALESCE
 		auto coalesce_op = make_unique<OperatorExpression>(ExpressionType::OPERATOR_COALESCE);
 		coalesce_op->children.push_back(move(children[0]));
 		coalesce_op->children.push_back(move(children[1]));
 		return move(coalesce_op);
 	}
 
 	auto function = make_unique<FunctionExpression>(schema, lowercase_name.c_str(), children, move(filter_expr),
 	                                                root->agg_distinct);
 	function->query_location = root->location;
 	return move(function);
 }
@@ -270,13 +271,14 @@ static string SQLValueOpToString(duckdb_libpgquery::PGSQLValueFunctionOp op) {
 	}
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction *node) {
+unique_ptr<ParsedExpression> Transformer::TransformSQLValueFunction(duckdb_libpgquery::PGSQLValueFunction *node,
+                                                                    idx_t depth) {
 	if (!node) {
 		return nullptr;
 	}
 	vector<unique_ptr<ParsedExpression>> children;
 	auto fname = SQLValueOpToString(node->op);
 	return make_unique<FunctionExpression>(DEFAULT_SCHEMA, fname, children);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_interval.cpp b/src/parser/transform/expression/transform_interval.cpp
index 6fdad6aabf..e937b3175b 100644
--- a/src/parser/transform/expression/transform_interval.cpp
+++ b/src/parser/transform/expression/transform_interval.cpp
@@ -6,114 +6,114 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformInterval(duckdb_libpgquery::PGIntervalConstant *node) {
+unique_ptr<ParsedExpression> Transformer::TransformInterval(duckdb_libpgquery::PGIntervalConstant *node, idx_t depth) {
 	// handle post-fix notation of INTERVAL
 
 	// three scenarios
 	// interval (expr) year
 	// interval 'string' year
 	// interval int year
 	unique_ptr<ParsedExpression> expr;
 	switch (node->val_type) {
 	case duckdb_libpgquery::T_PGAExpr:
-		expr = TransformExpression(node->eval);
+		expr = TransformExpression(node->eval, depth + 1);
 		break;
 	case duckdb_libpgquery::T_PGString:
 		expr = make_unique<ConstantExpression>(Value(node->sval));
 		break;
 	case duckdb_libpgquery::T_PGInteger:
 		expr = make_unique<ConstantExpression>(Value(node->ival));
 		break;
 	default:
 		throw ParserException("Unsupported interval transformation");
 	}
 
 	if (!node->typmods) {
 		return make_unique<CastExpression>(LogicalType::INTERVAL, move(expr));
 	}
 
 	int32_t mask = ((duckdb_libpgquery::PGAConst *)node->typmods->head->data.ptr_value)->val.val.ival;
 	// these seemingly random constants are from datetime.hpp
 	// they are copied here to avoid having to include this header
 	// the bitshift is from the function INTERVAL_MASK in the parser
 	constexpr int32_t MONTH_MASK = 1 << 1;
 	constexpr int32_t YEAR_MASK = 1 << 2;
 	constexpr int32_t DAY_MASK = 1 << 3;
 	constexpr int32_t HOUR_MASK = 1 << 10;
 	constexpr int32_t MINUTE_MASK = 1 << 11;
 	constexpr int32_t SECOND_MASK = 1 << 12;
 	constexpr int32_t MILLISECOND_MASK = 1 << 13;
 	constexpr int32_t MICROSECOND_MASK = 1 << 14;
 
 	// we need to check certain combinations
 	// because certain interval masks (e.g. INTERVAL '10' HOURS TO DAYS) set multiple bits
 	// for now we don't support all of the combined ones
 	// (we might add support if someone complains about it)
 
 	string fname;
 	LogicalType target_type;
 	if (mask & YEAR_MASK && mask & MONTH_MASK) {
 		// DAY TO HOUR
 		throw ParserException("YEAR TO MONTH is not supported");
 	} else if (mask & DAY_MASK && mask & HOUR_MASK) {
 		// DAY TO HOUR
 		throw ParserException("DAY TO HOUR is not supported");
 	} else if (mask & DAY_MASK && mask & MINUTE_MASK) {
 		// DAY TO MINUTE
 		throw ParserException("DAY TO MINUTE is not supported");
 	} else if (mask & DAY_MASK && mask & SECOND_MASK) {
 		// DAY TO SECOND
 		throw ParserException("DAY TO SECOND is not supported");
 	} else if (mask & HOUR_MASK && mask & MINUTE_MASK) {
 		// DAY TO SECOND
 		throw ParserException("HOUR TO MINUTE is not supported");
 	} else if (mask & HOUR_MASK && mask & SECOND_MASK) {
 		// DAY TO SECOND
 		throw ParserException("HOUR TO SECOND is not supported");
 	} else if (mask & MINUTE_MASK && mask & SECOND_MASK) {
 		// DAY TO SECOND
 		throw ParserException("MINUTE TO SECOND is not supported");
 	} else if (mask & YEAR_MASK) {
 		// YEAR
 		fname = "to_years";
 		target_type = LogicalType::INTEGER;
 	} else if (mask & MONTH_MASK) {
 		// MONTH
 		fname = "to_months";
 		target_type = LogicalType::INTEGER;
 	} else if (mask & DAY_MASK) {
 		// DAY
 		fname = "to_days";
 		target_type = LogicalType::INTEGER;
 	} else if (mask & HOUR_MASK) {
 		// HOUR
 		fname = "to_hours";
 		target_type = LogicalType::BIGINT;
 	} else if (mask & MINUTE_MASK) {
 		// MINUTE
 		fname = "to_minutes";
 		target_type = LogicalType::BIGINT;
 	} else if (mask & SECOND_MASK) {
 		// SECOND
 		fname = "to_seconds";
 		target_type = LogicalType::BIGINT;
 	} else if (mask & MILLISECOND_MASK) {
 		// MILLISECOND
 		fname = "to_milliseconds";
 		target_type = LogicalType::BIGINT;
 	} else if (mask & MICROSECOND_MASK) {
 		// SECOND
 		fname = "to_microseconds";
 		target_type = LogicalType::BIGINT;
 	} else {
 		throw ParserException("Unsupported interval post-fix");
 	}
 	// first push a cast to the target type
 	expr = make_unique<CastExpression>(target_type, move(expr));
 	// now push the operation
 	vector<unique_ptr<ParsedExpression>> children;
 	children.push_back(move(expr));
 	return make_unique<FunctionExpression>(fname, children);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_is_null.cpp b/src/parser/transform/expression/transform_is_null.cpp
index fca817d61e..13ff6676b9 100644
--- a/src/parser/transform/expression/transform_is_null.cpp
+++ b/src/parser/transform/expression/transform_is_null.cpp
@@ -4,17 +4,17 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformNullTest(duckdb_libpgquery::PGNullTest *root) {
+unique_ptr<ParsedExpression> Transformer::TransformNullTest(duckdb_libpgquery::PGNullTest *root, idx_t depth) {
 	D_ASSERT(root);
-	auto arg = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->arg));
+	auto arg = TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(root->arg), depth + 1);
 	if (root->argisrow) {
 		throw NotImplementedException("IS NULL argisrow");
 	}
 	ExpressionType expr_type = (root->nulltesttype == duckdb_libpgquery::PG_IS_NULL)
 	                               ? ExpressionType::OPERATOR_IS_NULL
 	                               : ExpressionType::OPERATOR_IS_NOT_NULL;
 
 	return unique_ptr<ParsedExpression>(new OperatorExpression(expr_type, move(arg)));
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_lambda.cpp b/src/parser/transform/expression/transform_lambda.cpp
index 1be827b783..1e95daf0fe 100644
--- a/src/parser/transform/expression/transform_lambda.cpp
+++ b/src/parser/transform/expression/transform_lambda.cpp
@@ -16,19 +16,19 @@ static string ExtractColumnFromLambda(ParsedExpression &expr) {
 	return colref.column_name;
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformLambda(duckdb_libpgquery::PGLambdaFunction *node) {
+unique_ptr<ParsedExpression> Transformer::TransformLambda(duckdb_libpgquery::PGLambdaFunction *node, idx_t depth) {
 	vector<unique_ptr<ParsedExpression>> parameter_expressions;
-	if (!TransformExpressionList(node->parameters, parameter_expressions)) {
+	if (!TransformExpressionList(node->parameters, parameter_expressions, depth + 1)) {
 		throw ParserException("Failed to transform expression list");
 	}
 	vector<string> parameters;
 	parameters.reserve(parameter_expressions.size());
 	for (auto &expr : parameter_expressions) {
 		parameters.push_back(ExtractColumnFromLambda(*expr));
 	}
 
-	auto lambda_function = TransformExpression(node->function);
+	auto lambda_function = TransformExpression(node->function, depth + 1);
 	return make_unique<LambdaExpression>(move(parameters), move(lambda_function));
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_operator.cpp b/src/parser/transform/expression/transform_operator.cpp
index bc0a1c99c7..1eeab6e443 100644
--- a/src/parser/transform/expression/transform_operator.cpp
+++ b/src/parser/transform/expression/transform_operator.cpp
@@ -69,126 +69,128 @@ unique_ptr<ParsedExpression> Transformer::TransformBinaryOperator(const string &
 	}
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformAExpr(duckdb_libpgquery::PGAExpr *root) {
+unique_ptr<ParsedExpression> Transformer::TransformAExpr(duckdb_libpgquery::PGAExpr *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
 	auto name = string((reinterpret_cast<duckdb_libpgquery::PGValue *>(root->name->head->data.ptr_value))->val.str);
 
 	switch (root->kind) {
 	case duckdb_libpgquery::PG_AEXPR_IN: {
-		auto left_expr = TransformExpression(root->lexpr);
+		auto left_expr = TransformExpression(root->lexpr, depth + 1);
 		ExpressionType operator_type;
 		// this looks very odd, but seems to be the way to find out its NOT IN
 		if (name == "<>") {
 			// NOT IN
 			operator_type = ExpressionType::COMPARE_NOT_IN;
 		} else {
 			// IN
 			operator_type = ExpressionType::COMPARE_IN;
 		}
 		auto result = make_unique<OperatorExpression>(operator_type, move(left_expr));
-		TransformExpressionList((duckdb_libpgquery::PGList *)root->rexpr, result->children);
+		TransformExpressionList((duckdb_libpgquery::PGList *)root->rexpr, result->children, depth);
 		return move(result);
 	}
 	// rewrite NULLIF(a, b) into CASE WHEN a=b THEN NULL ELSE a END
 	case duckdb_libpgquery::PG_AEXPR_NULLIF: {
 		vector<unique_ptr<ParsedExpression>> children;
-		children.push_back(TransformExpression(root->lexpr));
-		children.push_back(TransformExpression(root->rexpr));
+		children.push_back(TransformExpression(root->lexpr, depth + 1));
+		children.push_back(TransformExpression(root->rexpr, depth + 1));
 		return make_unique<FunctionExpression>("nullif", children);
 	}
 	// rewrite (NOT) X BETWEEN A AND B into (NOT) AND(GREATERTHANOREQUALTO(X,
 	// A), LESSTHANOREQUALTO(X, B))
 	case duckdb_libpgquery::PG_AEXPR_BETWEEN:
 	case duckdb_libpgquery::PG_AEXPR_NOT_BETWEEN: {
 		auto between_args = reinterpret_cast<duckdb_libpgquery::PGList *>(root->rexpr);
 		if (between_args->length != 2 || !between_args->head->data.ptr_value || !between_args->tail->data.ptr_value) {
 			throw Exception("(NOT) BETWEEN needs two args");
 		}
 
-		auto between_left =
-		    TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(between_args->head->data.ptr_value));
-		auto between_right =
-		    TransformExpression(reinterpret_cast<duckdb_libpgquery::PGNode *>(between_args->tail->data.ptr_value));
-
-		auto compare_left = make_unique<ComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,
-		                                                      TransformExpression(root->lexpr), move(between_left));
-		auto compare_right = make_unique<ComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,
-		                                                       TransformExpression(root->lexpr), move(between_right));
+		auto between_left = TransformExpression(
+		    reinterpret_cast<duckdb_libpgquery::PGNode *>(between_args->head->data.ptr_value), depth + 1);
+		auto between_right = TransformExpression(
+		    reinterpret_cast<duckdb_libpgquery::PGNode *>(between_args->tail->data.ptr_value), depth + 1);
+
+		auto compare_left =
+		    make_unique<ComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,
+		                                      TransformExpression(root->lexpr, depth + 1), move(between_left));
+		auto compare_right =
+		    make_unique<ComparisonExpression>(ExpressionType::COMPARE_LESSTHANOREQUALTO,
+		                                      TransformExpression(root->lexpr, depth + 1), move(between_right));
 		auto compare_between = make_unique<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(compare_left),
 		                                                          move(compare_right));
 		if (root->kind == duckdb_libpgquery::PG_AEXPR_BETWEEN) {
 			return move(compare_between);
 		} else {
 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(compare_between));
 		}
 	}
 	// rewrite SIMILAR TO into regexp_full_match('asdf', '.*sd.*')
 	case duckdb_libpgquery::PG_AEXPR_SIMILAR: {
-		auto left_expr = TransformExpression(root->lexpr);
-		auto right_expr = TransformExpression(root->rexpr);
+		auto left_expr = TransformExpression(root->lexpr, depth + 1);
+		auto right_expr = TransformExpression(root->rexpr, depth + 1);
 
 		vector<unique_ptr<ParsedExpression>> children;
 		children.push_back(move(left_expr));
 
 		auto &similar_func = reinterpret_cast<FunctionExpression &>(*right_expr);
 		D_ASSERT(similar_func.function_name == "similar_escape");
 		D_ASSERT(similar_func.children.size() == 2);
 		if (similar_func.children[1]->type != ExpressionType::VALUE_CONSTANT) {
 			throw NotImplementedException("Custom escape in SIMILAR TO");
 		}
 		auto &constant = (ConstantExpression &)*similar_func.children[1];
 		if (!constant.value.is_null) {
 			throw NotImplementedException("Custom escape in SIMILAR TO");
 		}
 		// take the child of the similar_func
 		children.push_back(move(similar_func.children[0]));
 
 		// this looks very odd, but seems to be the way to find out its NOT IN
 		bool invert_similar = false;
 		if (name == "!~") {
 			// NOT SIMILAR TO
 			invert_similar = true;
 		}
 		const auto schema = DEFAULT_SCHEMA;
 		const auto regex_function = "regexp_full_match";
 		auto result = make_unique<FunctionExpression>(schema, regex_function, children);
 
 		if (invert_similar) {
 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(result));
 		} else {
 			return move(result);
 		}
 	}
 	case duckdb_libpgquery::PG_AEXPR_NOT_DISTINCT: {
-		auto left_expr = TransformExpression(root->lexpr);
-		auto right_expr = TransformExpression(root->rexpr);
+		auto left_expr = TransformExpression(root->lexpr, depth + 1);
+		auto right_expr = TransformExpression(root->rexpr, depth + 1);
 		return make_unique<ComparisonExpression>(ExpressionType::COMPARE_NOT_DISTINCT_FROM, move(left_expr),
 		                                         move(right_expr));
 	}
 	case duckdb_libpgquery::PG_AEXPR_DISTINCT: {
-		auto left_expr = TransformExpression(root->lexpr);
-		auto right_expr = TransformExpression(root->rexpr);
+		auto left_expr = TransformExpression(root->lexpr, depth + 1);
+		auto right_expr = TransformExpression(root->rexpr, depth + 1);
 		return make_unique<ComparisonExpression>(ExpressionType::COMPARE_DISTINCT_FROM, move(left_expr),
 		                                         move(right_expr));
 	}
 
 	default:
 		break;
 	}
-	auto left_expr = TransformExpression(root->lexpr);
-	auto right_expr = TransformExpression(root->rexpr);
+	auto left_expr = TransformExpression(root->lexpr, depth + 1);
+	auto right_expr = TransformExpression(root->rexpr, depth + 1);
 
 	if (!left_expr) {
 		// prefix operator
 		return TransformUnaryOperator(name, move(right_expr));
 	} else if (!right_expr) {
 		// postfix operator, only ! is currently supported
 		return TransformUnaryOperator(name + "__postfix", move(left_expr));
 	} else {
 		return TransformBinaryOperator(name, move(left_expr), move(right_expr));
 	}
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_param_ref.cpp b/src/parser/transform/expression/transform_param_ref.cpp
index 6c8dd58101..c4990cd9ba 100644
--- a/src/parser/transform/expression/transform_param_ref.cpp
+++ b/src/parser/transform/expression/transform_param_ref.cpp
@@ -4,18 +4,18 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformParamRef(duckdb_libpgquery::PGParamRef *node) {
+unique_ptr<ParsedExpression> Transformer::TransformParamRef(duckdb_libpgquery::PGParamRef *node, idx_t depth) {
 	if (!node) {
 		return nullptr;
 	}
 	auto expr = make_unique<ParameterExpression>();
 	if (node->number == 0) {
 		expr->parameter_nr = ParamCount() + 1;
 	} else {
 		expr->parameter_nr = node->number;
 	}
 	SetParamCount(MaxValue<idx_t>(ParamCount(), expr->parameter_nr));
 	return move(expr);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_positional_reference.cpp b/src/parser/transform/expression/transform_positional_reference.cpp
index a771620071..11ab434631 100644
--- a/src/parser/transform/expression/transform_positional_reference.cpp
+++ b/src/parser/transform/expression/transform_positional_reference.cpp
@@ -4,13 +4,14 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformPositionalReference(duckdb_libpgquery::PGPositionalReference *node) {
+unique_ptr<ParsedExpression> Transformer::TransformPositionalReference(duckdb_libpgquery::PGPositionalReference *node,
+                                                                       idx_t depth) {
 	if (node->position <= 0) {
 		throw ParserException("Positional reference node needs to be >= 1");
 	}
 	auto result = make_unique<PositionalReferenceExpression>(node->position);
 	result->query_location = node->location;
 	return move(result);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp
index 8b9ae67cd0..a13cc86afd 100644
--- a/src/parser/transform/expression/transform_subquery.cpp
+++ b/src/parser/transform/expression/transform_subquery.cpp
@@ -4,61 +4,61 @@
 
 namespace duckdb {
 
-unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::PGSubLink *root) {
+unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::PGSubLink *root, idx_t depth) {
 	if (!root) {
 		return nullptr;
 	}
 	auto subquery_expr = make_unique<SubqueryExpression>();
 	subquery_expr->subquery = TransformSelect(root->subselect);
 	if (!subquery_expr->subquery) {
 		return nullptr;
 	}
 	D_ASSERT(subquery_expr->subquery->node->GetSelectList().size() > 0);
 
 	switch (root->subLinkType) {
 	case duckdb_libpgquery::PG_EXISTS_SUBLINK: {
 		subquery_expr->subquery_type = SubqueryType::EXISTS;
 		break;
 	}
 	case duckdb_libpgquery::PG_ANY_SUBLINK:
 	case duckdb_libpgquery::PG_ALL_SUBLINK: {
 		// comparison with ANY() or ALL()
 		subquery_expr->subquery_type = SubqueryType::ANY;
-		subquery_expr->child = TransformExpression(root->testexpr);
+		subquery_expr->child = TransformExpression(root->testexpr, depth + 1);
 		// get the operator name
 		if (!root->operName) {
 			// simple IN
 			subquery_expr->comparison_type = ExpressionType::COMPARE_EQUAL;
 		} else {
 			auto operator_name =
 			    string((reinterpret_cast<duckdb_libpgquery::PGValue *>(root->operName->head->data.ptr_value))->val.str);
 			subquery_expr->comparison_type = OperatorToExpressionType(operator_name);
 		}
 		D_ASSERT(subquery_expr->comparison_type == ExpressionType::COMPARE_EQUAL ||
 		         subquery_expr->comparison_type == ExpressionType::COMPARE_NOTEQUAL ||
 		         subquery_expr->comparison_type == ExpressionType::COMPARE_GREATERTHAN ||
 		         subquery_expr->comparison_type == ExpressionType::COMPARE_GREATERTHANOREQUALTO ||
 		         subquery_expr->comparison_type == ExpressionType::COMPARE_LESSTHAN ||
 		         subquery_expr->comparison_type == ExpressionType::COMPARE_LESSTHANOREQUALTO);
 		if (root->subLinkType == duckdb_libpgquery::PG_ALL_SUBLINK) {
 			// ALL sublink is equivalent to NOT(ANY) with inverted comparison
 			// e.g. [= ALL()] is equivalent to [NOT(<> ANY())]
 			// first invert the comparison type
 			subquery_expr->comparison_type = NegateComparisionExpression(subquery_expr->comparison_type);
 			return make_unique<OperatorExpression>(ExpressionType::OPERATOR_NOT, move(subquery_expr));
 		}
 		break;
 	}
 	case duckdb_libpgquery::PG_EXPR_SUBLINK: {
 		// return a single scalar value from the subquery
 		// no child expression to compare to
 		subquery_expr->subquery_type = SubqueryType::SCALAR;
 		break;
 	}
 	default:
 		throw NotImplementedException("Subquery of type %d not implemented\n", (int)root->subLinkType);
 	}
 	return move(subquery_expr);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/helpers/transform_groupby.cpp b/src/parser/transform/helpers/transform_groupby.cpp
index d80dd74265..38f425067a 100644
--- a/src/parser/transform/helpers/transform_groupby.cpp
+++ b/src/parser/transform/helpers/transform_groupby.cpp
@@ -6,14 +6,14 @@ namespace duckdb {
 // FIXME: what is the difference between GroupBy and expression list?
 bool Transformer::TransformGroupBy(duckdb_libpgquery::PGList *group, vector<unique_ptr<ParsedExpression>> &result) {
 	if (!group) {
 		return false;
 	}
 
 	for (auto node = group->head; node != nullptr; node = node->next) {
 		auto n = reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value);
-		result.push_back(TransformExpression(n));
+		result.push_back(TransformExpression(n, 0));
 	}
 	return true;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/helpers/transform_orderby.cpp b/src/parser/transform/helpers/transform_orderby.cpp
index 37c64b8ca1..e3d4c5b0c6 100644
--- a/src/parser/transform/helpers/transform_orderby.cpp
+++ b/src/parser/transform/helpers/transform_orderby.cpp
@@ -7,40 +7,40 @@ namespace duckdb {
 bool Transformer::TransformOrderBy(duckdb_libpgquery::PGList *order, vector<OrderByNode> &result) {
 	if (!order) {
 		return false;
 	}
 
 	for (auto node = order->head; node != nullptr; node = node->next) {
 		auto temp = reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value);
 		if (temp->type == duckdb_libpgquery::T_PGSortBy) {
 			OrderType type;
 			OrderByNullType null_order;
 			auto sort = reinterpret_cast<duckdb_libpgquery::PGSortBy *>(temp);
 			auto target = sort->node;
 			if (sort->sortby_dir == duckdb_libpgquery::PG_SORTBY_DEFAULT) {
 				type = OrderType::ORDER_DEFAULT;
 			} else if (sort->sortby_dir == duckdb_libpgquery::PG_SORTBY_ASC) {
 				type = OrderType::ASCENDING;
 			} else if (sort->sortby_dir == duckdb_libpgquery::PG_SORTBY_DESC) {
 				type = OrderType::DESCENDING;
 			} else {
 				throw NotImplementedException("Unimplemented order by type");
 			}
 			if (sort->sortby_nulls == duckdb_libpgquery::PG_SORTBY_NULLS_DEFAULT) {
 				null_order = OrderByNullType::ORDER_DEFAULT;
 			} else if (sort->sortby_nulls == duckdb_libpgquery::PG_SORTBY_NULLS_FIRST) {
 				null_order = OrderByNullType::NULLS_FIRST;
 			} else if (sort->sortby_nulls == duckdb_libpgquery::PG_SORTBY_NULLS_LAST) {
 				null_order = OrderByNullType::NULLS_LAST;
 			} else {
 				throw NotImplementedException("Unimplemented order by type");
 			}
-			auto order_expression = TransformExpression(target);
+			auto order_expression = TransformExpression(target, 0);
 			result.emplace_back(type, null_order, move(order_expression));
 		} else {
 			throw NotImplementedException("ORDER BY list member type %d\n", temp->type);
 		}
 	}
 	return true;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/helpers/transform_sample.cpp b/src/parser/transform/helpers/transform_sample.cpp
index b1c6b47ddd..dbf6a10033 100644
--- a/src/parser/transform/helpers/transform_sample.cpp
+++ b/src/parser/transform/helpers/transform_sample.cpp
@@ -21,34 +21,34 @@ static SampleMethod GetSampleMethod(const string &method) {
 unique_ptr<SampleOptions> Transformer::TransformSampleOptions(duckdb_libpgquery::PGNode *options) {
 	if (!options) {
 		return nullptr;
 	}
 	auto result = make_unique<SampleOptions>();
 	auto &sample_options = (duckdb_libpgquery::PGSampleOptions &)*options;
 	auto &sample_size = (duckdb_libpgquery::PGSampleSize &)*sample_options.sample_size;
-	auto sample_value = TransformValue(sample_size.sample_size)->value;
+	auto sample_value = TransformValue(sample_size.sample_size, 0)->value;
 	result->is_percentage = sample_size.is_percentage;
 	if (sample_size.is_percentage) {
 		// sample size is given in sample_size: use system sampling
 		auto percentage = sample_value.GetValue<double>();
 		if (percentage < 0 || percentage > 100) {
 			throw ParserException("Sample sample_size %llf out of range, must be between 0 and 100", percentage);
 		}
 		result->sample_size = Value::DOUBLE(percentage);
 		result->method = SampleMethod::SYSTEM_SAMPLE;
 	} else {
 		// sample size is given in rows: use reservoir sampling
 		auto rows = sample_value.GetValue<int64_t>();
 		if (rows < 0) {
 			throw ParserException("Sample rows %lld out of range, must be bigger than or equal to 0", rows);
 		}
 		result->sample_size = Value::BIGINT(rows);
 		result->method = SampleMethod::RESERVOIR_SAMPLE;
 	}
 	if (sample_options.method) {
 		result->method = GetSampleMethod(sample_options.method);
 	}
 	result->seed = sample_options.seed;
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/helpers/transform_typename.cpp b/src/parser/transform/helpers/transform_typename.cpp
index 0cc6e915aa..e9cd94aac7 100644
--- a/src/parser/transform/helpers/transform_typename.cpp
+++ b/src/parser/transform/helpers/transform_typename.cpp
@@ -10,115 +10,117 @@ namespace duckdb {
 LogicalType Transformer::TransformTypeName(duckdb_libpgquery::PGTypeName *type_name) {
 	auto name = (reinterpret_cast<duckdb_libpgquery::PGValue *>(type_name->names->tail->data.ptr_value)->val.str);
 	// transform it to the SQL type
 	LogicalType base_type = TransformStringToLogicalType(name);
 
 	if (base_type == LogicalTypeId::STRUCT) {
-		D_ASSERT(type_name->typmods && type_name->typmods->length > 0);
+		if (!type_name->typmods || type_name->typmods->length == 0) {
+			throw ParserException("Struct needs a name and entries");
+		}
 		child_list_t<LogicalType> children;
 		unordered_set<string> name_collision_set;
 
 		for (auto node = type_name->typmods->head; node; node = node->next) {
 			auto &type_val = *((duckdb_libpgquery::PGList *)node->data.ptr_value);
 			D_ASSERT(type_val.length == 2);
 
 			auto entry_name_node = (duckdb_libpgquery::PGValue *)(type_val.head->data.ptr_value);
 			D_ASSERT(entry_name_node->type == duckdb_libpgquery::T_PGString);
 			auto entry_type_node = (duckdb_libpgquery::PGValue *)(type_val.tail->data.ptr_value);
 			D_ASSERT(entry_type_node->type == duckdb_libpgquery::T_PGTypeName);
 
 			auto entry_name = string(entry_name_node->val.str);
 			D_ASSERT(!entry_name.empty());
 
 			if (name_collision_set.find(entry_name) != name_collision_set.end()) {
 				throw ParserException("Duplicate struct entry name \"%s\"", entry_name);
 			}
 			name_collision_set.insert(entry_name);
 
 			auto entry_type = TransformTypeName((duckdb_libpgquery::PGTypeName *)entry_type_node);
 			children.push_back(make_pair(entry_name, entry_type));
 		}
 		D_ASSERT(!children.empty());
 		return LogicalType(base_type.id(), children);
 	}
 
 	if (base_type == LogicalTypeId::MAP) {
 		//! We transform MAP<TYPE_KEY, TYPE_VALUE> to STRUCT<LIST<key: TYPE_KEY>, LIST<value: TYPE_VALUE>>
 
 		if (!type_name->typmods || type_name->typmods->length != 2) {
 			throw ParserException("Map type needs exactly two entries, key and value type");
 		}
 		child_list_t<LogicalType> children;
 
 		child_list_t<LogicalType> key_type, value_type;
 		key_type.push_back(
 		    {"", TransformTypeName((duckdb_libpgquery::PGTypeName *)type_name->typmods->head->data.ptr_value)});
 		value_type.push_back(
 		    {"", TransformTypeName((duckdb_libpgquery::PGTypeName *)type_name->typmods->tail->data.ptr_value)});
 
 		children.push_back({"key", {LogicalTypeId::LIST, key_type}});
 		children.push_back({"value", {LogicalTypeId::LIST, value_type}});
 
 		D_ASSERT(children.size() == 2);
 
 		return LogicalType(LogicalTypeId::MAP, children);
 	}
 
 	int8_t width = base_type.width(), scale = base_type.scale();
 	// check any modifiers
 	int modifier_idx = 0;
 	if (type_name->typmods) {
 		for (auto node = type_name->typmods->head; node; node = node->next) {
 			auto &const_val = *((duckdb_libpgquery::PGAConst *)node->data.ptr_value);
 			if (const_val.type != duckdb_libpgquery::T_PGAConst ||
 			    const_val.val.type != duckdb_libpgquery::T_PGInteger) {
 				throw ParserException("Expected an integer constant as type modifier");
 			}
 			if (const_val.val.val.ival < 0) {
 				throw ParserException("Negative modifier not supported");
 			}
 			if (modifier_idx == 0) {
 				width = const_val.val.val.ival;
 			} else if (modifier_idx == 1) {
 				scale = const_val.val.val.ival;
 			} else {
 				throw ParserException("A maximum of two modifiers is supported");
 			}
 			modifier_idx++;
 		}
 	}
 	switch (base_type.id()) {
 	case LogicalTypeId::VARCHAR:
 		if (modifier_idx > 1) {
 			throw ParserException("VARCHAR only supports a single modifier");
 		}
 		// FIXME: create CHECK constraint based on varchar width
 		width = 0;
 		break;
 	case LogicalTypeId::DECIMAL:
 		if (modifier_idx == 1) {
 			// only width is provided: set scale to 0
 			scale = 0;
 		}
 		if (width <= 0 || width > Decimal::MAX_WIDTH_DECIMAL) {
 			throw ParserException("Width must be between 1 and %d!", (int)Decimal::MAX_WIDTH_DECIMAL);
 		}
 		if (scale > width) {
 			throw ParserException("Scale cannot be bigger than width");
 		}
 		break;
 	case LogicalTypeId::INTERVAL:
 		if (modifier_idx > 1) {
 			throw ParserException("INTERVAL only supports a single modifier");
 		}
 		width = 0;
 		break;
 	default:
 		if (modifier_idx > 0) {
 			throw ParserException("Type %s does not support any modifiers!", base_type.ToString());
 		}
 	}
 
 	return LogicalType(base_type.id(), width, scale);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_alter_table.cpp b/src/parser/transform/statement/transform_alter_table.cpp
index 2a07ff5423..c26ad20f94 100644
--- a/src/parser/transform/statement/transform_alter_table.cpp
+++ b/src/parser/transform/statement/transform_alter_table.cpp
@@ -9,63 +9,63 @@ namespace duckdb {
 unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGAlterTableStmt *>(node);
 	D_ASSERT(stmt);
 	D_ASSERT(stmt->relation);
 
 	auto result = make_unique<AlterStatement>();
 
 	auto qname = TransformQualifiedName(stmt->relation);
 
 	// first we check the type of ALTER
 	for (auto c = stmt->cmds->head; c != nullptr; c = c->next) {
 		auto command = reinterpret_cast<duckdb_libpgquery::PGAlterTableCmd *>(lfirst(c));
 		// TODO: Include more options for command->subtype
 		switch (command->subtype) {
 		case duckdb_libpgquery::PG_AT_AddColumn: {
 			auto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;
 			auto centry = TransformColumnDefinition(cdef);
 			if (cdef->constraints) {
 				for (auto constr = cdef->constraints->head; constr != nullptr; constr = constr->next) {
 					auto constraint = TransformConstraint(constr, centry, 0);
 					if (constraint) {
 						throw ParserException("Adding columns with constraints not yet supported");
 					}
 				}
 			}
 			result->info = make_unique<AddColumnInfo>(qname.schema, qname.name, move(centry));
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_DropColumn: {
 			result->info = make_unique<RemoveColumnInfo>(qname.schema, qname.name, command->name, command->missing_ok);
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_ColumnDefault: {
-			auto expr = TransformExpression(command->def);
+			auto expr = TransformExpression(command->def, 0);
 			result->info = make_unique<SetDefaultInfo>(qname.schema, qname.name, command->name, move(expr));
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_AlterColumnType: {
 			auto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;
 			auto column_definition = TransformColumnDefinition(cdef);
 
 			unique_ptr<ParsedExpression> expr;
 			if (cdef->raw_default) {
-				expr = TransformExpression(cdef->raw_default);
+				expr = TransformExpression(cdef->raw_default, 0);
 			} else {
 				auto colref = make_unique<ColumnRefExpression>(command->name);
 				expr = make_unique<CastExpression>(column_definition.type, move(colref));
 			}
 			result->info = make_unique<ChangeColumnTypeInfo>(qname.schema, qname.name, command->name,
 			                                                 column_definition.type, move(expr));
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_DropConstraint:
 		case duckdb_libpgquery::PG_AT_DropNotNull:
 		default:
 			throw NotImplementedException("ALTER TABLE option not supported yet!");
 		}
 	}
 
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_call.cpp b/src/parser/transform/statement/transform_call.cpp
index 4a8d5da323..2a03b653b7 100644
--- a/src/parser/transform/statement/transform_call.cpp
+++ b/src/parser/transform/statement/transform_call.cpp
@@ -6,10 +6,10 @@ namespace duckdb {
 unique_ptr<CallStatement> Transformer::TransformCall(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGCallStmt *>(node);
 	D_ASSERT(stmt);
 
 	auto result = make_unique<CallStatement>();
-	result->function = TransformFuncCall((duckdb_libpgquery::PGFuncCall *)stmt->func);
+	result->function = TransformFuncCall((duckdb_libpgquery::PGFuncCall *)stmt->func, 0);
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_copy.cpp b/src/parser/transform/statement/transform_copy.cpp
index 79e8e26073..097cd1e69a 100644
--- a/src/parser/transform/statement/transform_copy.cpp
+++ b/src/parser/transform/statement/transform_copy.cpp
@@ -12,45 +12,45 @@ namespace duckdb {
 void Transformer::TransformCopyOptions(CopyInfo &info, duckdb_libpgquery::PGList *options) {
 	if (!options) {
 		return;
 	}
 	duckdb_libpgquery::PGListCell *cell = nullptr;
 
 	// iterate over each option
 	for_each_cell(cell, options->head) {
 		auto *def_elem = reinterpret_cast<duckdb_libpgquery::PGDefElem *>(cell->data.ptr_value);
 		if (StringUtil::Lower(def_elem->defname) == "format") {
 			// format specifier: interpret this option
 			auto *format_val = (duckdb_libpgquery::PGValue *)(def_elem->arg);
 			if (!format_val || format_val->type != duckdb_libpgquery::T_PGString) {
 				throw ParserException("Unsupported parameter type for FORMAT: expected e.g. FORMAT 'csv', 'parquet'");
 			}
 			info.format = StringUtil::Lower(format_val->val.str);
 			continue;
 		}
 		// otherwise
 		if (info.options.find(def_elem->defname) != info.options.end()) {
 			throw ParserException("Unexpected duplicate option \"%s\"", def_elem->defname);
 		}
 		if (!def_elem->arg) {
 			info.options[def_elem->defname] = vector<Value>();
 			continue;
 		}
 		switch (def_elem->arg->type) {
 		case duckdb_libpgquery::T_PGList: {
 			auto column_list = (duckdb_libpgquery::PGList *)(def_elem->arg);
 			for (auto c = column_list->head; c != nullptr; c = lnext(c)) {
 				auto target = (duckdb_libpgquery::PGResTarget *)(c->data.ptr_value);
 				info.options[def_elem->defname].push_back(Value(target->name));
 			}
 			break;
 		}
 		case duckdb_libpgquery::T_PGAStar:
 			info.options[def_elem->defname].push_back(Value("*"));
 			break;
 		default:
 			info.options[def_elem->defname].push_back(
-			    TransformValue(*((duckdb_libpgquery::PGValue *)def_elem->arg))->value);
+			    TransformValue(*((duckdb_libpgquery::PGValue *)def_elem->arg), 0)->value);
 			break;
 		}
 	}
 }
diff --git a/src/parser/transform/statement/transform_create_function.cpp b/src/parser/transform/statement/transform_create_function.cpp
index 2f8d75235f..647846ed90 100644
--- a/src/parser/transform/statement/transform_create_function.cpp
+++ b/src/parser/transform/statement/transform_create_function.cpp
@@ -9,57 +9,57 @@ namespace duckdb {
 unique_ptr<CreateStatement> Transformer::TransformCreateFunction(duckdb_libpgquery::PGNode *node) {
 	D_ASSERT(node);
 	D_ASSERT(node->type == duckdb_libpgquery::T_PGCreateFunctionStmt);
 
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGCreateFunctionStmt *>(node);
 	D_ASSERT(stmt);
 
 	auto result = make_unique<CreateStatement>();
 	auto info = make_unique<CreateMacroInfo>();
 
 	auto qname = TransformQualifiedName(stmt->name);
 	info->schema = qname.schema;
 	info->name = qname.name;
 
-	auto function = TransformExpression(stmt->function);
+	auto function = TransformExpression(stmt->function, 0);
 	D_ASSERT(function);
 	auto macro_func = make_unique<MacroFunction>(move(function));
 
 	if (stmt->params) {
 		vector<unique_ptr<ParsedExpression>> parameters;
-		auto res = TransformExpressionList(stmt->params, parameters);
+		auto res = TransformExpressionList(stmt->params, parameters, 0);
 		if (!res) {
 			throw ParserException("Failed to transform macro parameters!");
 		}
 		for (auto &param : parameters) {
 			if (param->type == ExpressionType::COMPARE_EQUAL) {
 				// parameters with default value
 				auto &comp_expr = (ComparisonExpression &)*param;
 				if (comp_expr.left->GetExpressionClass() != ExpressionClass::COLUMN_REF) {
 					throw ParserException("Invalid parameter: '%s'", comp_expr.left->ToString());
 				}
 				if (comp_expr.right->GetExpressionClass() != ExpressionClass::CONSTANT) {
 					throw ParserException("Parameters may only have constants as default value!");
 				}
 				auto &param_name_expr = (ColumnRefExpression &)*comp_expr.left;
 				if (!param_name_expr.table_name.empty()) {
 					throw BinderException("Invalid parameter name '%s'", param_name_expr.ToString());
 				}
 				macro_func->default_parameters[comp_expr.left->ToString()] = move(comp_expr.right);
 			} else if (param->GetExpressionClass() == ExpressionClass::COLUMN_REF) {
 				// positional parameters
 				if (!macro_func->default_parameters.empty()) {
 					throw ParserException("Positional parameters cannot come after parameters with a default value!");
 				}
 				macro_func->parameters.push_back(move(param));
 			} else {
 				throw ParserException("Invalid parameter: '%s'", param->ToString());
 			}
 		}
 	}
 
 	info->function = move(macro_func);
 	result->info = move(info);
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_create_index.cpp b/src/parser/transform/statement/transform_create_index.cpp
index fb8b8b3e8a..3301615df2 100644
--- a/src/parser/transform/statement/transform_create_index.cpp
+++ b/src/parser/transform/statement/transform_create_index.cpp
@@ -22,46 +22,46 @@ static IndexType StringToIndexType(const string &str) {
 unique_ptr<CreateStatement> Transformer::TransformCreateIndex(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGIndexStmt *>(node);
 	D_ASSERT(stmt);
 	auto result = make_unique<CreateStatement>();
 	auto info = make_unique<CreateIndexInfo>();
 
 	info->unique = stmt->unique;
 	info->on_conflict =
 	    stmt->if_not_exists ? OnCreateConflict::IGNORE_ON_CONFLICT : OnCreateConflict::ERROR_ON_CONFLICT;
 
 	for (auto cell = stmt->indexParams->head; cell != nullptr; cell = cell->next) {
 		auto index_element = (duckdb_libpgquery::PGIndexElem *)cell->data.ptr_value;
 		if (index_element->collation) {
 			throw NotImplementedException("Index with collation not supported yet!");
 		}
 		if (index_element->opclass) {
 			throw NotImplementedException("Index with opclass not supported yet!");
 		}
 
 		if (index_element->name) {
 			// create a column reference expression
 			info->expressions.push_back(make_unique<ColumnRefExpression>(index_element->name, stmt->relation->relname));
 		} else {
 			// parse the index expression
 			D_ASSERT(index_element->expr);
-			info->expressions.push_back(TransformExpression(index_element->expr));
+			info->expressions.push_back(TransformExpression(index_element->expr, 0));
 		}
 	}
 
 	info->index_type = StringToIndexType(string(stmt->accessMethod));
 	auto tableref = make_unique<BaseTableRef>();
 	tableref->table_name = stmt->relation->relname;
 	if (stmt->relation->schemaname) {
 		tableref->schema_name = stmt->relation->schemaname;
 	}
 	info->table = move(tableref);
 	if (stmt->idxname) {
 		info->index_name = stmt->idxname;
 	} else {
 		throw NotImplementedException("Index wout a name not supported yet!");
 	}
 	result->info = move(info);
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_create_table.cpp b/src/parser/transform/statement/transform_create_table.cpp
index 3205f4aa60..6a57434815 100644
--- a/src/parser/transform/statement/transform_create_table.cpp
+++ b/src/parser/transform/statement/transform_create_table.cpp
@@ -26,8 +26,9 @@ string Transformer::TransformCollation(duckdb_libpgquery::PGCollateClause *colla
 	return collation;
 }
 
-unique_ptr<ParsedExpression> Transformer::TransformCollateExpr(duckdb_libpgquery::PGCollateClause *collate) {
-	auto child = TransformExpression(collate->arg);
+unique_ptr<ParsedExpression> Transformer::TransformCollateExpr(duckdb_libpgquery::PGCollateClause *collate,
+                                                               idx_t depth) {
+	auto child = TransformExpression(collate->arg, depth + 1);
 	auto collation = TransformCollation(collate);
 	return make_unique<CollateExpression>(collation, move(child));
 }
diff --git a/src/parser/transform/statement/transform_delete.cpp b/src/parser/transform/statement/transform_delete.cpp
index 6dc61d5af8..cb3dd2df02 100644
--- a/src/parser/transform/statement/transform_delete.cpp
+++ b/src/parser/transform/statement/transform_delete.cpp
@@ -7,21 +7,21 @@ namespace duckdb {
 unique_ptr<DeleteStatement> Transformer::TransformDelete(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGDeleteStmt *>(node);
 	D_ASSERT(stmt);
 	auto result = make_unique<DeleteStatement>();
 
-	result->condition = TransformExpression(stmt->whereClause);
+	result->condition = TransformExpression(stmt->whereClause, 0);
 	result->table = TransformRangeVar(stmt->relation);
 	if (result->table->type != TableReferenceType::BASE_TABLE) {
 		throw Exception("Can only delete from base tables!");
 	}
 	if (stmt->usingClause) {
 		for (auto n = stmt->usingClause->head; n != nullptr; n = n->next) {
 			auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(n->data.ptr_value);
 			auto using_entry = TransformTableRefNode(target);
 			result->using_clauses.push_back(move(using_entry));
 		}
 	}
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_insert.cpp b/src/parser/transform/statement/transform_insert.cpp
index 50da6c9038..8e6405b3bf 100644
--- a/src/parser/transform/statement/transform_insert.cpp
+++ b/src/parser/transform/statement/transform_insert.cpp
@@ -7,19 +7,19 @@ namespace duckdb {
 unique_ptr<TableRef> Transformer::TransformValuesList(duckdb_libpgquery::PGList *list) {
 	auto result = make_unique<ExpressionListRef>();
 	for (auto value_list = list->head; value_list != nullptr; value_list = value_list->next) {
 		auto target = (duckdb_libpgquery::PGList *)(value_list->data.ptr_value);
 
 		vector<unique_ptr<ParsedExpression>> insert_values;
-		if (!TransformExpressionList(target, insert_values)) {
+		if (!TransformExpressionList(target, insert_values, 0)) {
 			throw ParserException("Could not parse expression list!");
 		}
 		if (!result->values.empty()) {
 			if (result->values[0].size() != insert_values.size()) {
 				throw ParserException("VALUES lists must all be the same length");
 			}
 		}
 		result->values.push_back(move(insert_values));
 	}
 	result->alias = "valueslist";
 	return move(result);
 }
diff --git a/src/parser/transform/statement/transform_pragma.cpp b/src/parser/transform/statement/transform_pragma.cpp
index 9fa355f47e..25e2737323 100644
--- a/src/parser/transform/statement/transform_pragma.cpp
+++ b/src/parser/transform/statement/transform_pragma.cpp
@@ -9,49 +9,49 @@ namespace duckdb {
 unique_ptr<PragmaStatement> Transformer::TransformPragma(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGPragmaStmt *>(node);
 
 	auto result = make_unique<PragmaStatement>();
 	auto &info = *result->info;
 
 	info.name = stmt->name;
 	// parse the arguments, if any
 	if (stmt->args) {
 		for (auto cell = stmt->args->head; cell != nullptr; cell = cell->next) {
 			auto node = reinterpret_cast<duckdb_libpgquery::PGNode *>(cell->data.ptr_value);
-			auto expr = TransformExpression(node);
+			auto expr = TransformExpression(node, 0);
 
 			if (expr->type == ExpressionType::COMPARE_EQUAL) {
 				auto &comp = (ComparisonExpression &)*expr;
 				info.named_parameters[comp.left->ToString()] = Value(comp.right->ToString());
 			} else if (node->type == duckdb_libpgquery::T_PGAConst) {
-				auto constant = TransformConstant((duckdb_libpgquery::PGAConst *)node);
+				auto constant = TransformConstant((duckdb_libpgquery::PGAConst *)node, 0);
 				info.parameters.push_back(((ConstantExpression &)*constant).value);
 			} else {
 				info.parameters.emplace_back(expr->ToString());
 			}
 		}
 	}
 	// now parse the pragma type
 	switch (stmt->kind) {
 	case duckdb_libpgquery::PG_PRAGMA_TYPE_NOTHING:
 		if (!info.parameters.empty() || !info.named_parameters.empty()) {
 			throw ParserException("PRAGMA statement that is not a call or assignment cannot contain parameters");
 		}
 		break;
 	case duckdb_libpgquery::PG_PRAGMA_TYPE_ASSIGNMENT:
 		if (info.parameters.size() != 1) {
 			throw ParserException("PRAGMA statement with assignment should contain exactly one parameter");
 		}
 		if (!info.named_parameters.empty()) {
 			throw ParserException("PRAGMA statement with assignment cannot have named parameters");
 		}
 		break;
 	case duckdb_libpgquery::PG_PRAGMA_TYPE_CALL:
 		break;
 	default:
 		throw ParserException("Unknown pragma type");
 	}
 
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_prepare.cpp b/src/parser/transform/statement/transform_prepare.cpp
index 01e2d31da6..ccacca626f 100644
--- a/src/parser/transform/statement/transform_prepare.cpp
+++ b/src/parser/transform/statement/transform_prepare.cpp
@@ -24,15 +24,15 @@ unique_ptr<PrepareStatement> Transformer::TransformPrepare(duckdb_libpgquery::PG
 unique_ptr<ExecuteStatement> Transformer::TransformExecute(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGExecuteStmt *>(node);
 	D_ASSERT(stmt);
 
 	auto result = make_unique<ExecuteStatement>();
 	result->name = string(stmt->name);
 
-	TransformExpressionList(stmt->params, result->values);
+	TransformExpressionList(stmt->params, result->values, 0);
 	for (auto &expr : result->values) {
 		if (!expr->IsScalar()) {
 			throw Exception("Only scalar parameters or NULL supported for EXECUTE");
 		}
 	}
 	return result;
 }
diff --git a/src/parser/transform/statement/transform_select_node.cpp b/src/parser/transform/statement/transform_select_node.cpp
index d4c300a9fc..19ef233cd5 100644
--- a/src/parser/transform/statement/transform_select_node.cpp
+++ b/src/parser/transform/statement/transform_select_node.cpp
@@ -11,129 +11,129 @@ namespace duckdb {
 unique_ptr<QueryNode> Transformer::TransformSelectNode(duckdb_libpgquery::PGSelectStmt *stmt) {
 	unique_ptr<QueryNode> node;
 
 	switch (stmt->op) {
 	case duckdb_libpgquery::PG_SETOP_NONE: {
 		node = make_unique<SelectNode>();
 		auto result = (SelectNode *)node.get();
 		if (stmt->withClause) {
 			TransformCTE(reinterpret_cast<duckdb_libpgquery::PGWithClause *>(stmt->withClause), *node);
 		}
 		if (stmt->windowClause) {
 			for (auto window_ele = stmt->windowClause->head; window_ele != nullptr; window_ele = window_ele->next) {
 				auto window_def = reinterpret_cast<duckdb_libpgquery::PGWindowDef *>(window_ele->data.ptr_value);
 				D_ASSERT(window_def);
 				D_ASSERT(window_def->name);
 				auto window_name = StringUtil::Lower(string(window_def->name));
 
 				auto it = window_clauses.find(window_name);
 				if (it != window_clauses.end()) {
 					throw ParserException("window \"%s\" is already defined", window_name);
 				}
 				window_clauses[window_name] = window_def;
 			}
 		}
 
 		// checks distinct clause
 		if (stmt->distinctClause != nullptr) {
 			auto modifier = make_unique<DistinctModifier>();
 			// checks distinct on clause
 			auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(stmt->distinctClause->head->data.ptr_value);
 			if (target) {
 				//  add the columns defined in the ON clause to the select list
-				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets)) {
+				if (!TransformExpressionList(stmt->distinctClause, modifier->distinct_on_targets, 0)) {
 					throw Exception("Failed to transform expression list from DISTINCT ON.");
 				}
 			}
 			result->modifiers.push_back(move(modifier));
 		}
 
 		// do this early so the value lists also have a `FROM`
 		if (stmt->valuesLists) {
 			// VALUES list, create an ExpressionList
 			D_ASSERT(!stmt->fromClause);
 			result->from_table = TransformValuesList(stmt->valuesLists);
 			result->select_list.push_back(make_unique<StarExpression>());
 		} else {
 			if (!stmt->targetList) {
 				throw ParserException("SELECT clause without selection list");
 			}
 			// select list
-			if (!TransformExpressionList(stmt->targetList, result->select_list)) {
+			if (!TransformExpressionList(stmt->targetList, result->select_list, 0)) {
 				throw InternalException("Failed to transform expression list.");
 			}
 			result->from_table = TransformFrom(stmt->fromClause);
 		}
 
 		// where
-		result->where_clause = TransformExpression(stmt->whereClause);
+		result->where_clause = TransformExpression(stmt->whereClause, 0);
 		// group by
 		TransformGroupBy(stmt->groupClause, result->groups);
 		// having
-		result->having = TransformExpression(stmt->havingClause);
+		result->having = TransformExpression(stmt->havingClause, 0);
 		// sample
 		result->sample = TransformSampleOptions(stmt->sampleOptions);
 		break;
 	}
 	case duckdb_libpgquery::PG_SETOP_UNION:
 	case duckdb_libpgquery::PG_SETOP_EXCEPT:
 	case duckdb_libpgquery::PG_SETOP_INTERSECT: {
 		node = make_unique<SetOperationNode>();
 		auto result = (SetOperationNode *)node.get();
 		if (stmt->withClause) {
 			TransformCTE(reinterpret_cast<duckdb_libpgquery::PGWithClause *>(stmt->withClause), *node);
 		}
 		result->left = TransformSelectNode(stmt->larg);
 		result->right = TransformSelectNode(stmt->rarg);
 		if (!result->left || !result->right) {
 			throw Exception("Failed to transform setop children.");
 		}
 
 		bool select_distinct = true;
 		switch (stmt->op) {
 		case duckdb_libpgquery::PG_SETOP_UNION:
 			select_distinct = !stmt->all;
 			result->setop_type = SetOperationType::UNION;
 			break;
 		case duckdb_libpgquery::PG_SETOP_EXCEPT:
 			result->setop_type = SetOperationType::EXCEPT;
 			break;
 		case duckdb_libpgquery::PG_SETOP_INTERSECT:
 			result->setop_type = SetOperationType::INTERSECT;
 			break;
 		default:
 			throw Exception("Unexpected setop type");
 		}
 		if (select_distinct) {
 			result->modifiers.push_back(make_unique<DistinctModifier>());
 		}
 		if (stmt->sampleOptions) {
 			throw ParserException("SAMPLE clause is only allowed in regular SELECT statements");
 		}
 		break;
 	}
 	default:
 		throw NotImplementedException("Statement type %d not implemented!", stmt->op);
 	}
 	// transform the common properties
 	// both the set operations and the regular select can have an ORDER BY/LIMIT attached to them
 	vector<OrderByNode> orders;
 	TransformOrderBy(stmt->sortClause, orders);
 	if (!orders.empty()) {
 		auto order_modifier = make_unique<OrderModifier>();
 		order_modifier->orders = move(orders);
 		node->modifiers.push_back(move(order_modifier));
 	}
 	if (stmt->limitCount || stmt->limitOffset) {
 		auto limit_modifier = make_unique<LimitModifier>();
 		if (stmt->limitCount) {
-			limit_modifier->limit = TransformExpression(stmt->limitCount);
+			limit_modifier->limit = TransformExpression(stmt->limitCount, 0);
 		}
 		if (stmt->limitOffset) {
-			limit_modifier->offset = TransformExpression(stmt->limitOffset);
+			limit_modifier->offset = TransformExpression(stmt->limitOffset, 0);
 		}
 		node->modifiers.push_back(move(limit_modifier));
 	}
 	return node;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_set.cpp b/src/parser/transform/statement/transform_set.cpp
index 9f115f1858..cdd4b8b380 100644
--- a/src/parser/transform/statement/transform_set.cpp
+++ b/src/parser/transform/statement/transform_set.cpp
@@ -7,21 +7,21 @@ namespace duckdb {
 unique_ptr<SetStatement> Transformer::TransformSet(duckdb_libpgquery::PGNode *node) {
 	D_ASSERT(node->type == duckdb_libpgquery::T_PGVariableSetStmt);
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGVariableSetStmt *>(node);
 
 	if (stmt->kind != duckdb_libpgquery::VariableSetKind::VAR_SET_VALUE) {
 		throw ParserException("Can only SET a variable to a value");
 	}
 	auto name = std::string(stmt->name);
 	D_ASSERT(!name.empty()); // parser protect us!
 	if (stmt->args->length != 1) {
 		throw ParserException("SET needs a single scalar value parameter");
 	}
 	D_ASSERT(stmt->args->head && stmt->args->head->data.ptr_value);
 	D_ASSERT(((duckdb_libpgquery::PGNode *)stmt->args->head->data.ptr_value)->type == duckdb_libpgquery::T_PGAConst);
 
-	auto value = TransformValue(((duckdb_libpgquery::PGAConst *)stmt->args->head->data.ptr_value)->val)->value;
+	auto value = TransformValue(((duckdb_libpgquery::PGAConst *)stmt->args->head->data.ptr_value)->val, 0)->value;
 
 	return make_unique<SetStatement>(name, value);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/statement/transform_update.cpp b/src/parser/transform/statement/transform_update.cpp
index d373a33be4..78425258ac 100644
--- a/src/parser/transform/statement/transform_update.cpp
+++ b/src/parser/transform/statement/transform_update.cpp
@@ -6,23 +6,23 @@ namespace duckdb {
 unique_ptr<UpdateStatement> Transformer::TransformUpdate(duckdb_libpgquery::PGNode *node) {
 	auto stmt = reinterpret_cast<duckdb_libpgquery::PGUpdateStmt *>(node);
 	D_ASSERT(stmt);
 
 	auto result = make_unique<UpdateStatement>();
 
 	result->table = TransformRangeVar(stmt->relation);
 	if (stmt->fromClause) {
 		result->from_table = TransformFrom(stmt->fromClause);
 	}
 
 	auto root = stmt->targetList;
 	for (auto cell = root->head; cell != nullptr; cell = cell->next) {
 		auto target = (duckdb_libpgquery::PGResTarget *)(cell->data.ptr_value);
 		result->columns.emplace_back(target->name);
-		result->expressions.push_back(TransformExpression(target->val));
+		result->expressions.push_back(TransformExpression(target->val, 0));
 	}
 
-	result->condition = TransformExpression(stmt->whereClause);
+	result->condition = TransformExpression(stmt->whereClause, 0);
 	return result;
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/tableref/transform_join.cpp b/src/parser/transform/tableref/transform_join.cpp
index 2e2b185f14..1056555190 100644
--- a/src/parser/transform/tableref/transform_join.cpp
+++ b/src/parser/transform/tableref/transform_join.cpp
@@ -9,56 +9,56 @@ namespace duckdb {
 unique_ptr<TableRef> Transformer::TransformJoin(duckdb_libpgquery::PGJoinExpr *root) {
 	auto result = make_unique<JoinRef>();
 	switch (root->jointype) {
 	case duckdb_libpgquery::PG_JOIN_INNER: {
 		result->type = JoinType::INNER;
 		break;
 	}
 	case duckdb_libpgquery::PG_JOIN_LEFT: {
 		result->type = JoinType::LEFT;
 		break;
 	}
 	case duckdb_libpgquery::PG_JOIN_FULL: {
 		result->type = JoinType::OUTER;
 		break;
 	}
 	case duckdb_libpgquery::PG_JOIN_RIGHT: {
 		result->type = JoinType::RIGHT;
 		break;
 	}
 	case duckdb_libpgquery::PG_JOIN_SEMI: {
 		result->type = JoinType::SEMI;
 		break;
 	}
 	default: {
 		throw NotImplementedException("Join type %d not supported yet...\n", root->jointype);
 	}
 	}
 
 	// Check the type of left arg and right arg before transform
 	result->left = TransformTableRefNode(root->larg);
 	result->right = TransformTableRefNode(root->rarg);
 	result->is_natural = root->isNatural;
 	result->query_location = root->location;
 
 	if (root->usingClause && root->usingClause->length > 0) {
 		// usingClause is a list of strings
 		for (auto node = root->usingClause->head; node != nullptr; node = node->next) {
 			auto target = reinterpret_cast<duckdb_libpgquery::PGNode *>(node->data.ptr_value);
 			D_ASSERT(target->type == duckdb_libpgquery::T_PGString);
 			auto column_name = string(reinterpret_cast<duckdb_libpgquery::PGValue *>(target)->val.str);
 			result->using_columns.push_back(column_name);
 		}
 		return move(result);
 	}
 
 	if (!root->quals && result->using_columns.empty() && !result->is_natural) { // CROSS PRODUCT
 		auto cross = make_unique<CrossProductRef>();
 		cross->left = move(result->left);
 		cross->right = move(result->right);
 		return move(cross);
 	}
-	result->condition = TransformExpression(root->quals);
+	result->condition = TransformExpression(root->quals, 0);
 	return move(result);
 }
 
 } // namespace duckdb
diff --git a/src/parser/transform/tableref/transform_table_function.cpp b/src/parser/transform/tableref/transform_table_function.cpp
index 22063b537d..cc9f7b9762 100644
--- a/src/parser/transform/tableref/transform_table_function.cpp
+++ b/src/parser/transform/tableref/transform_table_function.cpp
@@ -7,35 +7,44 @@ namespace duckdb {
 unique_ptr<TableRef> Transformer::TransformRangeFunction(duckdb_libpgquery::PGRangeFunction *root) {
 	if (root->lateral) {
 		throw NotImplementedException("LATERAL not implemented");
 	}
 	if (root->ordinality) {
 		throw NotImplementedException("WITH ORDINALITY not implemented");
 	}
 	if (root->is_rowsfrom) {
 		throw NotImplementedException("ROWS FROM() not implemented");
 	}
 	if (root->functions->length != 1) {
 		throw NotImplementedException("Need exactly one function");
 	}
 	auto function_sublist = (duckdb_libpgquery::PGList *)root->functions->head->data.ptr_value;
 	D_ASSERT(function_sublist->length == 2);
 	auto call_tree = (duckdb_libpgquery::PGNode *)function_sublist->head->data.ptr_value;
 	auto coldef = function_sublist->head->next->data.ptr_value;
 
-	D_ASSERT(call_tree->type == duckdb_libpgquery::T_PGFuncCall);
 	if (coldef) {
 		throw NotImplementedException("Explicit column definition not supported yet");
 	}
-	auto func_call = (duckdb_libpgquery::PGFuncCall *)call_tree;
 	// transform the function call
 	auto result = make_unique<TableFunctionRef>();
-	result->function = TransformFuncCall(func_call);
+	switch (call_tree->type) {
+	case duckdb_libpgquery::T_PGFuncCall: {
+		auto func_call = (duckdb_libpgquery::PGFuncCall *)call_tree;
+		result->function = TransformFuncCall(func_call, 0);
+		result->query_location = func_call->location;
+		break;
+	}
+	case duckdb_libpgquery::T_PGSQLValueFunction:
+		result->function = TransformSQLValueFunction((duckdb_libpgquery::PGSQLValueFunction *)call_tree, 0);
+		break;
+	default:
+		throw ParserException("Not a function call or value function");
+	}
 	result->alias = TransformAlias(root->alias, result->column_name_alias);
-	result->query_location = func_call->location;
 	if (root->sample) {
 		result->sample = TransformSampleOptions(root->sample);
 	}
 	return move(result);
 }
 
 } // namespace duckdb
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 2f8cacbea0..8cb2a54da9 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -10,6 +10,7 @@ add_subdirectory(extension)
 add_subdirectory(helpers)
 add_subdirectory(sql)
 add_subdirectory(sqlite)
+add_subdirectory(ossfuzz)
 
 if(NOT WIN32 AND NOT SUN)
   if(${BUILD_TPCE})
diff --git a/test/ossfuzz/CMakeLists.txt b/test/ossfuzz/CMakeLists.txt
new file mode 100644
index 0000000000..da7581d625
--- /dev/null
+++ b/test/ossfuzz/CMakeLists.txt
@@ -0,0 +1,4 @@
+add_library_unity(test_ossfuzz OBJECT test_ossfuzz.cpp)
+set(ALL_OBJECT_FILES
+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_ossfuzz>
+    PARENT_SCOPE)
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4857993532407808 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4857993532407808
new file mode 100644
index 0000000000..e977f3e151
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4857993532407808
@@ -0,0 +1,4 @@
+pragma
+
+
+w(W1+2201@140114000000000114000000000000038386150157+97544044047544044+-5540+.289754044+t!~~~~!~~~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~*~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~^~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~*~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~^~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~*~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~^~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~*~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~^~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~0000000138658*798.00002*00013574300000000693291890.000000*00013574302,030,gess~40950000000088888888.*0.3574302,030,gess~4095000088888888.*0.0005055%88210095,gess++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_cataW+r@aim$v$sil~KK=m+s~,@eK=m+s~,Km+s~,KiKi~++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_catalog+*4`++*4`+8`++*5``Z+*4`++*5`il~KK=m+s~,@eK=m+s~,KiKi~++*current_catalog+*3+`+*K=m+s~,@eK=m+s~,KiKi~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~0000000138658*798.00002*00013574300000000693291890.000000*00013574302,030,gess~40950000000088888888.*0.3574302,030,gess~4095000088888888.*0.0005055%88210095,gess++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_cataW+r@aim$v$sil~KK=m+s~,@eK=m+s~,Km+s~,KiKi~++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_catalog+*4`++*4`+8`++*5``Z+*4`++*5`il~KK=m+s~,@eK=m+s~,KiKi~++*current_catalo~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~~!~~^~~t!22222^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A%~-554.038897597544044043880+.289754044+-554.038897597544044043889759+.289754044~~t!~A~~^~~t!~~!~~~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~1~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~t!~~~~!~~~!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~~!~~~~^~~~~!~~~~!~~~~^~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~!~~~~~~0000000138658*798.00002*00013574300000000693291890.000000*00013574302,030,gess~40950000000088888888.*0.3574302,030,gess~4095000088888888.*0.0005055%88210095,gess++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_cataW+r@aim$v$sil~KK=m+s~,@eK=m+s~,Km+s~,KiKi~++*current_catalog+*7`++*K=m+s~,@eK=m+s~,KiKi~++*current_catalog+*4`++*4`+8`++*5``Z+*4`++*5`il~KK=m+s~,@eK=m+s~,KiKi~++*current_catalog+*3+`+*K=m+s~,@eK=m+s~,KiKi~!~~~^~~t!~A~~^~~t!~~!~~~0~~~^~~t!~A~~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~0~^~t!~~!~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~!~~~0~^~t!^~t!~~~~!~~~~~^~t~~~~!~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~!~~~0~^~t!~~!~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~*~0~~~^~~t!~A%~^~~t!~~!~~~0~^~t!^~t!~~~~!~~~~~~!~~~~!~~~~^~t~~!~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~~~~!~~~^~~^~t!~~~~~~!~~~~!~~~~^~t!~~~~!~~~~~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~b~~t!~~!~~~1~^~t!~~!~!~~~~~~!~!~~~~~~!~~~~!~~~~~~!~~~^~~t!~A~~^~~t!~~!~~~-2~^~t!~~~t!~~!~!~~~~~~!~!~~~~~~!~~!~~~~~~!~!~~~~~~!~~~^+-554.038890+.289754044+-554.038848862336+.54044+-557544044047544044+-5868208,8355157+233333333233+2201@14018386057+2083868208,8355157+233333333233+2201@14018386057+2333333332331433332.314~)
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4918294185377792 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4918294185377792
new file mode 100644
index 0000000000..6a810adbd3
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-4918294185377792
@@ -0,0 +1 @@
+:::::::::::::::::
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5061856420036608 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5061856420036608
new file mode 100644
index 0000000000..028975cc44
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5061856420036608
@@ -0,0 +1 @@
+calln(==g@c==g@c==g@co@c==tru@c========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================g@c==g@co@cl)
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5096106838065152 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5096106838065152
new file mode 100644
index 0000000000..97dfff338b
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5096106838065152
@@ -0,0 +1 @@
+select-8e-8004
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5239305812443136 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5239305812443136
new file mode 100644
index 0000000000..b98090d174
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5239305812443136
@@ -0,0 +1 @@
+select struct''
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5926232345673728 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5926232345673728
new file mode 100644
index 0000000000..667b2c7dce
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-5926232345673728
@@ -0,0 +1,4 @@
+
+
+pragma
+(054000%%%%%%%%%%%*%%@@@@false@and@@@@@@@analyz0000394133963betw@?@asenc4775801*.99999999994799923-3720268547758^^^^~^isnull@@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@*-170141183460469231731687303715884105728-+-+-+-05+-+-+*-170141183460469231731687303715884105728-+-+-+-+-+++-+-+-+41888581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-54000%%%%%%%%%%%*%%@@@@false@and@@@@@@@analyz0000394133963betw@?@asenc4775801*.99999999994799923-3720268547758^^^^~^isnull@@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@*-170141183460469231731687303715884105728-+-+-+-05+-+-+*-170141183460469231731687303715884105728-+-+-+-+-+++-+-+-+41888581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@00isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@@@@75811*.9999991134783514-9-999*9999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@0@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@9999999994799923-3720268547758^^^^~^isnull@@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@*-170141183460469231731687303715884105728-+-+-+-05+-+-+*-170141183460469231731687303715884105728-+-+-+-+-+++-+-+-+41888581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@00isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@@@@75811*.9999991134783514-9-999*9999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@0@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-0/0.00700%%%%%%*%000000000000000008547758^^^47758^^^^%@@@wne@false@and@99999999943999*999999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@00isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@@@@75811*.9999991134783514-9-999*9999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@0@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@9999999994799923-3720268547758^^^^~^isnull@@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@*-170141183460469231731687303715884105728-+-+-+-05+-+-+*-170141183460469231731687303715884105728-+-+-+-+-+++-+-+-+41888581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-00.00700%%%%%%*%%@@@wne@false@and@@@@@75811*.9999991134783514-9-999*999999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@00isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@@@@75811*.9999991134783514-9-999*9999999999947999929223-3720268547.9@?@asenc4775801*.99999998^^^^~^isnull@@=@@@0@=@@@00000000000000000000538314215between-0568>-600.00700%%%%%%*%%@@@zone@false@and@@@@@?@asenc4771811*.99999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-0/0.00700%%%%%%*%000000000000000008547758^^^47758^^^^%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^47758^^^^~^isnull@@=@@@0000000000000000000053831421>-00.00700%%%%%%*%%@@@zone@false@00000000000000000008547758^^^^~^isnull@@=@@@00000000000000000000538314215between-05686>-0/0.00700%%%%%%*%000000000000000008547758^^^47758^^^^%@@@wne@false@and@9999999994392979-37202685477581147758^^^^~^isnull@@=@@@00000000000000000008547758^^^47758^^^^~^isnull@@=@@@0000000000000000000053831421>-00.00700%%%%%%*%%@@@zone@false@and@@@@@75811*.999467440737095737095446773`09551616,730975446744073709551667516002082498624,gess~,gess)
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6131030948970496 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6131030948970496
new file mode 100644
index 0000000000..d1f4912e71
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6131030948970496
@@ -0,0 +1 @@
+select''from currEnt_time
\ No newline at end of file
diff --git a/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6306994567905280 b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6306994567905280
new file mode 100644
index 0000000000..0f8c95faf9
--- /dev/null
+++ b/test/ossfuzz/cases/clusterfuzz-testcase-minimized-parse_fuzz_test-6306994567905280
@@ -0,0 +1 @@
+select+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++td9iew2+++++z
\ No newline at end of file
diff --git a/test/ossfuzz/test_ossfuzz.cpp b/test/ossfuzz/test_ossfuzz.cpp
new file mode 100644
index 0000000000..6b364be17e
--- /dev/null
+++ b/test/ossfuzz/test_ossfuzz.cpp
@@ -0,0 +1,38 @@
+#include "catch.hpp"
+#include "duckdb/common/file_system.hpp"
+#include "test_helpers.hpp"
+
+#include <fstream>
+#include <streambuf>
+#include <string>
+
+using namespace duckdb;
+using namespace std;
+
+constexpr const char *QUERY_DIRECTORY = "test/ossfuzz/cases";
+static FileSystem fs;
+
+static void test_runner() {
+	auto file_name = Catch::getResultCapture().getCurrentTestName();
+	auto fname = fs.JoinPath(QUERY_DIRECTORY, file_name);
+
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+	ifstream t(fname);
+	string query((istreambuf_iterator<char>(t)), istreambuf_iterator<char>());
+	con.Query(query.c_str());
+	// we don't know whether the query fails or not and we don't know the
+	// correct result we just don't want it to crash
+	REQUIRE(1 == 1);
+}
+
+struct RegisterOssfuzzTests {
+	RegisterOssfuzzTests() {
+		// register a separate test for each file in the QUERY_DIRECTORY
+		fs.ListFiles(QUERY_DIRECTORY, [&](const string &path, bool) {
+			REGISTER_TEST_CASE(test_runner, string(QUERY_DIRECTORY) + "/" + path, "[ossfuzz][.]");
+		});
+	}
+};
+RegisterOssfuzzTests register_ossfuzz_test;
