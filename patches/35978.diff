commit ed51987e3a4838dd9aef27dfab2c0651f2f52836
Author: Toni <matzeton@googlemail.com>
Date:   Mon Oct 18 23:16:32 2021 +0200

    Fix broken fuzz_process_packet fuzzer by adding a call to ndpi_finalize_initialization(). (#1334)
    
     * fixed several memory errors (heap-overflow, unitialized memory, etc)
     * ability to build fuzz_process_packet with a main()
       allowing to replay crash data generated with fuzz_process_packet
       by LLVMs libfuzzer
     * temporarily disable fuzzing if `tests/do.sh`
       executed with env FUZZY_TESTING_ENABLED=1
    
    Signed-off-by: Toni Uhlig <matzeton@googlemail.com>

diff --git a/example/reader_util.c b/example/reader_util.c
index 453660ce..35632920 100644
--- a/example/reader_util.c
+++ b/example/reader_util.c
@@ -958,39 +958,39 @@ static struct ndpi_flow_info *get_ndpi_flow_info(struct ndpi_workflow * workflow
 static struct ndpi_flow_info *get_ndpi_flow_info6(struct ndpi_workflow * workflow,
 						  u_int16_t vlan_id,
 						  ndpi_packet_tunnel tunnel_type,
 						  const struct ndpi_ipv6hdr *iph6,
 						  u_int16_t ip_offset,
 						  u_int16_t ipsize,
 						  struct ndpi_tcphdr **tcph,
 						  struct ndpi_udphdr **udph,
 						  u_int16_t *sport, u_int16_t *dport,
 						  struct ndpi_id_struct **src,
 						  struct ndpi_id_struct **dst,
 						  u_int8_t *proto,
 						  u_int8_t **payload,
 						  u_int16_t *payload_len,
 						  u_int8_t *src_to_dst_direction,
                                                   pkt_timeval when) {
   struct ndpi_iphdr iph;
 
   memset(&iph, 0, sizeof(iph));
   iph.version = IPVERSION;
   iph.saddr = iph6->ip6_src.u6_addr.u6_addr32[2] + iph6->ip6_src.u6_addr.u6_addr32[3];
   iph.daddr = iph6->ip6_dst.u6_addr.u6_addr32[2] + iph6->ip6_dst.u6_addr.u6_addr32[3];
   u_int8_t l4proto = iph6->ip6_hdr.ip6_un1_nxt;
   u_int16_t ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
   const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
-  if(ndpi_handle_ipv6_extension_headers(NULL, &l4ptr, &ip_len, &l4proto) != 0) {
+  if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &l4proto) != 0) {
     return(NULL);
   }
   iph.protocol = l4proto;
 
   return(get_ndpi_flow_info(workflow, 6, vlan_id, tunnel_type,
 			    &iph, iph6, ip_offset, ipsize,
 			    ip_len, l4ptr - (const u_int8_t *)iph6,
 			    tcph, udph, sport, dport,
 			    src, dst, proto, payload,
 			    payload_len, src_to_dst_direction, when));
 }
 
 /* ****************************************************** */
@@ -1589,487 +1589,488 @@ int ndpi_is_datalink_supported(int datalink_type) {
 struct ndpi_proto ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
 					       const struct pcap_pkthdr *header,
 					       const u_char *packet,
 					       ndpi_risk *flow_risk,
 					       FILE * csv_fp) {
   /*
    * Declare pointers to packet headers
    */
   /* --- Ethernet header --- */
   const struct ndpi_ethhdr *ethernet;
   /* --- LLC header --- */
   const struct ndpi_llc_header_snap *llc;
 
   /* --- Cisco HDLC header --- */
   const struct ndpi_chdlc *chdlc;
 
   /* --- Radio Tap header --- */
   const struct ndpi_radiotap_header *radiotap;
   /* --- Wifi header --- */
   const struct ndpi_wifi_header *wifi;
 
   /* --- MPLS header --- */
   union mpls {
     uint32_t u32;
     struct ndpi_mpls_header mpls;
   } mpls;
 
   /** --- IP header --- **/
   struct ndpi_iphdr *iph;
   /** --- IPv6 header --- **/
   struct ndpi_ipv6hdr *iph6;
 
   struct ndpi_proto nproto = NDPI_PROTOCOL_NULL;
   ndpi_packet_tunnel tunnel_type = ndpi_no_tunnel;
 
   /* lengths and offsets */
   u_int32_t eth_offset = 0;
   u_int16_t radio_len;
   u_int16_t fc;
   u_int16_t type = 0;
   int wifi_len = 0;
   int pyld_eth_len = 0;
   int check;
   u_int64_t time_ms;
   u_int16_t ip_offset = 0, ip_len;
   u_int16_t frag_off = 0, vlan_id = 0;
   u_int8_t proto = 0, recheck_type;
   /*u_int32_t label;*/
 
   /* counters */
   u_int8_t vlan_packet = 0;
 
   *flow_risk = 0 /* NDPI_NO_RISK */;
   
   /* Increment raw packet counter */
   workflow->stats.raw_packet_count++;
 
   /* setting time */
   time_ms = ((uint64_t) header->ts.tv_sec) * TICK_RESOLUTION + header->ts.tv_usec / (1000000 / TICK_RESOLUTION);
 
   /* safety check */
   if(workflow->last_time > time_ms) {
     /* printf("\nWARNING: timestamp bug in the pcap file (ts delta: %llu, repairing)\n", ndpi_thread_info[thread_id].last_time - time); */
     time_ms = workflow->last_time;
   }
   /* update last time value */
   workflow->last_time = time_ms;
 
   /*** check Data Link type ***/
   int datalink_type;
 
 #ifdef USE_DPDK
   datalink_type = DLT_EN10MB;
 #else
   datalink_type = (int)pcap_datalink(workflow->pcap_handle);
 #endif
 
  datalink_check:
   // 20 for min iph and 8 for min UDP
   if(header->caplen < eth_offset + 28)
     return(nproto); /* Too short */
 
   /* Keep in sync with ndpi_is_datalink_supported() */
   switch(datalink_type) {
   case DLT_NULL:
     if(ntohl(*((u_int32_t*)&packet[eth_offset])) == 2)
       type = ETH_P_IP;
     else
       type = ETH_P_IPV6;
 
     ip_offset = 4 + eth_offset;
     break;
 
     /* Cisco PPP in HDLC-like framing - 50 */
   case DLT_PPP_SERIAL:
     chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
     ip_offset = sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
     type = ntohs(chdlc->proto_code);
     break;
 
     /* Cisco PPP - 9 or 104 */
   case DLT_C_HDLC:
   case DLT_PPP:
     if(packet[0] == 0x0f || packet[0] == 0x8f) {
       chdlc = (struct ndpi_chdlc *) &packet[eth_offset];
       ip_offset = sizeof(struct ndpi_chdlc); /* CHDLC_OFF = 4 */
       type = ntohs(chdlc->proto_code);
     } else {
       ip_offset = 2;
       type = ntohs(*((u_int16_t*)&packet[eth_offset]));
     }
     break;
 
 #ifdef DLT_IPV4
   case DLT_IPV4:
     type = ETH_P_IP;
     ip_offset = 0;
     break;
 #endif
 
 #ifdef DLT_IPV6
   case DLT_IPV6:
     type = ETH_P_IPV6;
     ip_offset = 0;
     break;
 #endif
 
     /* IEEE 802.3 Ethernet - 1 */
   case DLT_EN10MB:
     ethernet = (struct ndpi_ethhdr *) &packet[eth_offset];
     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;
     check = ntohs(ethernet->h_proto);
 
     if(check <= 1500)
       pyld_eth_len = check;
     else if(check >= 1536)
       type = check;
 
     if(pyld_eth_len != 0) {
       llc = (struct ndpi_llc_header_snap *)(&packet[ip_offset]);
       /* check for LLC layer with SNAP extension */
       if(llc->dsap == SNAP || llc->ssap == SNAP) {
 	type = llc->snap.proto_ID;
 	ip_offset += + 8;
       }
       /* No SNAP extension - Spanning Tree pkt must be discarted */
       else if(llc->dsap == BSTP || llc->ssap == BSTP) {
 	goto v4_warning;
       }
     }
     break;
 
     /* Linux Cooked Capture - 113 */
   case DLT_LINUX_SLL:
     type = (packet[eth_offset+14] << 8) + packet[eth_offset+15];
     ip_offset = 16 + eth_offset;
     break;
 
     /* Radiotap link-layer - 127 */
   case DLT_IEEE802_11_RADIO:
     radiotap = (struct ndpi_radiotap_header *) &packet[eth_offset];
     radio_len = radiotap->len;
 
     /* Check Bad FCS presence */
     if((radiotap->flags & BAD_FCS) == BAD_FCS) {
       workflow->stats.total_discarded_bytes +=  header->len;
       return(nproto);
     }
 
     if(header->caplen < (eth_offset + radio_len + sizeof(struct ndpi_wifi_header)))
       return(nproto);
 
     /* Calculate 802.11 header length (variable) */
     wifi = (struct ndpi_wifi_header*)( packet + eth_offset + radio_len);
     fc = wifi->fc;
 
     /* check wifi data presence */
     if(FCF_TYPE(fc) == WIFI_DATA) {
       if((FCF_TO_DS(fc) && FCF_FROM_DS(fc) == 0x0) ||
 	 (FCF_TO_DS(fc) == 0x0 && FCF_FROM_DS(fc)))
 	wifi_len = 26; /* + 4 byte fcs */
     } else   /* no data frames */
       break;
 
     /* Check ether_type from LLC */
     if(header->caplen < (eth_offset + wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap)))
       return(nproto);
     llc = (struct ndpi_llc_header_snap*)(packet + eth_offset + wifi_len + radio_len);
     if(llc->dsap == SNAP)
       type = ntohs(llc->snap.proto_ID);
 
     /* Set IP header offset */
     ip_offset = wifi_len + radio_len + sizeof(struct ndpi_llc_header_snap) + eth_offset;
     break;
 
   case DLT_RAW:
     ip_offset = eth_offset = 0;
     break;
 
   default:
     /*
      * We shoudn't be here, because we already checked that this datalink is supported.
      * Should ndpi_is_datalink_supported() be updated?
      */
     printf("Unknown datalink %d\n", datalink_type);
     return(nproto);
   }
 
  ether_type_check:
   recheck_type = 0;
 
   /* check ether type */
   switch(type) {
   case ETH_P_VLAN:
     vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
     type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
     ip_offset += 4;
     vlan_packet = 1;
 
     // double tagging for 802.1Q
     while((type == 0x8100) && (((bpf_u_int32)ip_offset) < header->caplen)) {
       vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
       type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case ETH_P_MPLS_UNI:
   case ETH_P_MPLS_MULTI:
     mpls.u32 = *((uint32_t *) &packet[ip_offset]);
     mpls.u32 = ntohl(mpls.u32);
     workflow->stats.mpls_count++;
     type = ETH_P_IP, ip_offset += 4;
 
     while(!mpls.mpls.s && (((bpf_u_int32)ip_offset) + 4 < header->caplen)) {
       mpls.u32 = *((uint32_t *) &packet[ip_offset]);
       mpls.u32 = ntohl(mpls.u32);
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case ETH_P_PPPoE:
     workflow->stats.pppoe_count++;
     type = ETH_P_IP;
     ip_offset += 8;
     recheck_type = 1;
     break;
 
   default:
     break;
   }
 
   if(recheck_type)
     goto ether_type_check;
 
   workflow->stats.vlan_count += vlan_packet;
 
  iph_check:
   /* Check and set IP header size and total packet length */
   if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
     return(nproto); /* Too short for next IP header*/
 
   iph = (struct ndpi_iphdr *) &packet[ip_offset];
 
   /* just work on Ethernet packets that contain IP */
   if(type == ETH_P_IP && header->caplen >= ip_offset) {
     frag_off = ntohs(iph->frag_off);
 
     proto = iph->protocol;
     if(header->caplen < header->len) {
       static u_int8_t cap_warning_used = 0;
 
       if(cap_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  LOG(NDPI_LOG_DEBUG,
 		   "\n\nWARNING: packet capture size is smaller than packet size, DETECTION MIGHT NOT WORK CORRECTLY\n\n");
 	cap_warning_used = 1;
       }
     }
   }
 
   if(iph->version == IPVERSION) {
     ip_len = ((u_int16_t)iph->ihl * 4);
     iph6 = NULL;
 
     if(iph->protocol == IPPROTO_IPV6
 #ifdef IPPROTO_IPIP
        || iph->protocol == IPPROTO_IPIP
 #endif
        ) {
       ip_offset += ip_len;
       if(ip_len > 0)
         goto iph_check;
     }
 
     if((frag_off & 0x1FFF) != 0) {
       static u_int8_t ipv4_frags_warning_used = 0;
       workflow->stats.fragmented_count++;
 
       if(ipv4_frags_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  LOG(NDPI_LOG_DEBUG, "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
 	ipv4_frags_warning_used = 1;
       }
 
       workflow->stats.total_discarded_bytes +=  header->len;
       return(nproto);
     }
   } else if(iph->version == 6) {
     if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
       return(nproto); /* Too short for IPv6 header*/
     
     iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
     proto = iph6->ip6_hdr.ip6_un1_nxt;
     ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
 
     if(header->caplen < (ip_offset + sizeof(struct ndpi_ipv6hdr) + ntohs(iph6->ip6_hdr.ip6_un1_plen)))
       return(nproto); /* Too short for IPv6 payload*/
 
     const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
+    u_int16_t ipsize = header->caplen - ip_offset;
 
-    if(ndpi_handle_ipv6_extension_headers(NULL, &l4ptr, &ip_len, &proto) != 0) {
+    if(ndpi_handle_ipv6_extension_headers(ipsize - sizeof(struct ndpi_ipv6hdr), &l4ptr, &ip_len, &proto) != 0) {
       return(nproto);
     }
 
     if(proto == IPPROTO_IPV6
 #ifdef IPPROTO_IPIP
        || proto == IPPROTO_IPIP
 #endif
        ) {
       if(l4ptr > packet) { /* Better safe than sorry */
         ip_offset = (l4ptr - packet);
         goto iph_check;
       }
     }
 
     iph = NULL;
   } else {
     static u_int8_t ipv4_warning_used = 0;
 
   v4_warning:
     if(ipv4_warning_used == 0) {
       if(!workflow->prefs.quiet_mode)
         LOG(NDPI_LOG_DEBUG,
 		 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
       ipv4_warning_used = 1;
     }
     
     workflow->stats.total_discarded_bytes +=  header->len;
     return(nproto);
   }
 
   if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
     if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
       return(nproto); /* Too short for UDP header*/
     else {
       struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];
       u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
 
       if(((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) &&
          (ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 8 /* Minimum GTPv1 header len */ < header->caplen)) {
 	/* Check if it's GTPv1 */
 	u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 	u_int8_t flags = packet[offset];
 	u_int8_t message_type = packet[offset+1];
 	u_int8_t exts_parsing_error = 0;
 
 	if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
 	   (message_type == 0xFF /* T-PDU */)) {
 
 	  offset += 8; /* GTPv1 header len */
 	  if(flags & 0x07)
 	    offset += 4; /* sequence_number + pdu_number + next_ext_header fields */
 	  /* Extensions parsing */
 	  if(flags & 0x04) {
 	    unsigned int ext_length = 0;
 
 	    while(offset < header->caplen) {
 	      ext_length = packet[offset] << 2;
 	      offset += ext_length;
 	      if(offset >= header->caplen || ext_length == 0) {
 	        exts_parsing_error = 1;
 	        break;
 	      }
 	      if(packet[offset - 1] == 0)
 	        break;
 	    }
 	  }
 
 	  if(offset < header->caplen && !exts_parsing_error) {
 	    /* Ok, valid GTP-U */
 	    tunnel_type = ndpi_gtp_tunnel;
 	    ip_offset = offset;
 	    iph = (struct ndpi_iphdr *)&packet[ip_offset];
 	    if(iph->version == 6) {
 	      iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 	      iph = NULL;
 	    } else if(iph->version != IPVERSION) {
 	      // printf("WARNING: not good (packet_id=%u)!\n", (unsigned int)workflow->stats.raw_packet_count);
 	      goto v4_warning;
 	    }
 	  }
 	}
       } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
 	/* https://en.wikipedia.org/wiki/TZSP */
 	if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)
 	  return(nproto); /* Too short for TZSP*/
 
 	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 	u_int8_t version       = packet[offset];
 	u_int8_t ts_type       = packet[offset+1];
 	u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));
 
 	tunnel_type = ndpi_tzsp_tunnel;
 
 	if((version == 1) && (ts_type == 0) && (encapsulates == 1)) {
 	  u_int8_t stop = 0;
 
 	  offset += 4;
 
 	  while((!stop) && (offset < header->caplen)) {
 	    u_int8_t tag_type = packet[offset];
 	    u_int8_t tag_len;
 
 	    switch(tag_type) {
 	    case 0: /* PADDING Tag */
 	      tag_len = 1;
 	      break;
 	    case 1: /* END Tag */
 	      tag_len = 1, stop = 1;
 	      break;
 	    default:
 	      tag_len = packet[offset+1];
 	      break;
 	    }
 
 	    offset += tag_len;
 
 	    if(offset >= header->caplen)
 	      return(nproto); /* Invalid packet */
 	    else {
 	      eth_offset = offset;
 	      goto datalink_check;
 	    }
 	  }
 	}
       } else if((sport == NDPI_CAPWAP_DATA_PORT) || (dport == NDPI_CAPWAP_DATA_PORT)) {
 	/* We dissect ONLY CAPWAP traffic */
 	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 
 	if((offset+1) < header->caplen) {
 	  uint8_t preamble = packet[offset];
 
 	  if((preamble & 0x0F) == 0) { /* CAPWAP header */
 	    u_int16_t msg_len = (packet[offset+1] & 0xF8) >> 1;
 
 	    offset += msg_len;
 
 	    if((offset + 32 < header->caplen)) {
 	      /* IEEE 802.11 Data */
 	      offset += 24;
 	      /* LLC header is 8 bytes */
 	      type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset+6]));
 
 	      ip_offset = offset + 8;
 
 	      tunnel_type = ndpi_capwap_tunnel;
 	      goto iph_check;
 	    }
 	  }
 	}
       }
     }
   }
 
   /* process the packet */
   return(packet_processing(workflow, time_ms, vlan_id, tunnel_type, iph, iph6,
 			   ip_offset, header->caplen - ip_offset,
 			   header->caplen, header, packet, header->ts,
 			   flow_risk, csv_fp));
 }
 
 /* ********************************************************** */
 /*       http://home.thep.lu.se/~bjorn/crc/crc32_fast.c       */
 /* ********************************************************** */
diff --git a/fuzz/Makefile.am b/fuzz/Makefile.am
index 7858c337..ade21ac5 100644
--- a/fuzz/Makefile.am
+++ b/fuzz/Makefile.am
@@ -1,4 +1,4 @@
-bin_PROGRAMS = fuzz_process_packet fuzz_ndpi_reader fuzz_ndpi_reader_with_main
+bin_PROGRAMS = fuzz_process_packet fuzz_process_packet_with_main fuzz_ndpi_reader fuzz_ndpi_reader_with_main
 
 fuzz_process_packet_SOURCES = fuzz_process_packet.c
 fuzz_process_packet_CFLAGS =
@@ -13,6 +13,15 @@ fuzz_process_packet_LINK=$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
     $(LIBTOOLFLAGS) --mode=link $(CXX) $(AM_CXXFLAGS) $(CXXFLAGS) \
     $(fuzz_process_packet_LDFLAGS) $(LDFLAGS) -o $@
 
+fuzz_process_packet_with_main_SOURCES = fuzz_process_packet.c
+fuzz_process_packet_with_main_CFLAGS = -DBUILD_MAIN
+fuzz_process_packet_with_main_LDADD = ../src/lib/libndpi.a
+fuzz_process_packet_with_main_LDFLAGS = $(ADDITIONAL_LIBS) $(LIBS)
+# force usage of CXX for linker
+fuzz_process_packet_with_main_LINK=$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+    $(LIBTOOLFLAGS) --mode=link $(CXX) $(AM_CXXFLAGS) $(CXXFLAGS) \
+    $(fuzz_process_packet_with_main_LDFLAGS) $(LDFLAGS) -o $@
+
 fuzz_ndpi_reader_SOURCES = fuzz_ndpi_reader.c
 fuzz_ndpi_reader_CFLAGS = -I../example/
 fuzz_ndpi_reader_LDADD = ../example/libndpiReader.a ../src/lib/libndpi.a
diff --git a/fuzz/fuzz_process_packet.c b/fuzz/fuzz_process_packet.c
index 5af15afb..9efd8079 100644
--- a/fuzz/fuzz_process_packet.c
+++ b/fuzz/fuzz_process_packet.c
@@ -10,19 +10,81 @@ struct ndpi_id_struct *dst;
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
   if (ndpi_info_mod == NULL) {
     ndpi_info_mod = ndpi_init_detection_module(ndpi_no_prefs);
     NDPI_PROTOCOL_BITMASK all;
     NDPI_BITMASK_SET_ALL(all);
     ndpi_set_protocol_detection_bitmask2(ndpi_info_mod, &all);
     src = ndpi_malloc(SIZEOF_ID_STRUCT);
     dst = ndpi_malloc(SIZEOF_ID_STRUCT);
+    ndpi_finalize_initialization(ndpi_info_mod);
   }
 
   struct ndpi_flow_struct *ndpi_flow = ndpi_flow_malloc(SIZEOF_FLOW_STRUCT);
   memset(ndpi_flow, 0, SIZEOF_FLOW_STRUCT);
   memset(src, 0, SIZEOF_ID_STRUCT);
   memset(dst, 0, SIZEOF_ID_STRUCT);
   ndpi_detection_process_packet(ndpi_info_mod, ndpi_flow, Data, Size, 0, src, dst);
   ndpi_free_flow(ndpi_flow);
 
   return 0;
 }
+
+#ifdef BUILD_MAIN
+int main(int argc, char ** argv)
+{
+  FILE * data_file;
+  long data_file_size;
+  uint8_t * data_buffer;
+  int test_retval;
+
+  if (argc != 2) {
+    fprintf(stderr, "usage: %s: [data-file]\n",
+            (argc > 0 ? argv[0] : "fuzz_process_packet_with_main"));
+    return 1;
+  }
+
+  data_file = fopen(argv[1], "r");
+  if (data_file == NULL) {
+    perror("fopen failed");
+    return 1;
+  }
+
+  if (fseek(data_file, 0, SEEK_END) != 0) {
+    perror("fseek(SEEK_END) failed");
+    fclose(data_file);
+    return 1;
+  }
+
+  data_file_size = ftell(data_file);
+  if (data_file_size < 0) {
+    perror("ftell failed");
+    fclose(data_file);
+    return 1;
+  }
+
+  if (fseek(data_file, 0, SEEK_SET) != 0) {
+    perror("fseek(0, SEEK_SET)  failed");
+    fclose(data_file);
+    return 1;
+  }
+
+  data_buffer = malloc(data_file_size);
+  if (data_buffer == NULL) {
+    perror("malloc failed");
+    fclose(data_file);
+    return 1;
+  }
+
+  if (fread(data_buffer, sizeof(*data_buffer), data_file_size, data_file) != (size_t)data_file_size) {
+    perror("fread failed");
+    fclose(data_file);
+    free(data_buffer);
+    return 1;
+  }
+
+  test_retval = LLVMFuzzerTestOneInput(data_buffer, data_file_size);
+  fclose(data_file);
+  free(data_buffer);
+
+  return test_retval;
+}
+#endif
diff --git a/src/include/ndpi_main.h b/src/include/ndpi_main.h
index 3e882581..35efaa0b 100644
--- a/src/include/ndpi_main.h
+++ b/src/include/ndpi_main.h
@@ -38,125 +38,125 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 
   void *ndpi_tdelete(const void * __restrict, void ** __restrict,
 		     int (*)(const void *, const void *));
   void *ndpi_tfind(const void *, void *, int (*)(const void *, const void *));
   void *ndpi_tsearch(const void *, void**, int (*)(const void *, const void *));
   void ndpi_twalk(const void *, void (*)(const void *, ndpi_VISIT, int, void*), void *user_data);
   void ndpi_tdestroy(void *vrootp, void (*freefct)(void *));
 
   int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b);
   int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a);
   void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a);
 
   extern u_int8_t ndpi_net_match(u_int32_t ip_to_check,
 				 u_int32_t net,
 				 u_int32_t num_bits);
 
   extern u_int8_t ndpi_ips_match(u_int32_t src, u_int32_t dst,
 				 u_int32_t net, u_int32_t num_bits);
 
   u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t * str,
 					    u_int16_t max_chars_to_read,
 					    u_int16_t * bytes_read);
 
   u_int32_t ndpi_bytestream_to_number(const u_int8_t * str, u_int16_t max_chars_to_read,
 				      u_int16_t * bytes_read);
   u_int64_t ndpi_bytestream_to_number64(const u_int8_t * str, u_int16_t max_chars_to_read,
 					u_int16_t * bytes_read);
   u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t * str,
 						 u_int16_t max_chars_to_read,
 						 u_int16_t * bytes_read);
   u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t * str,
 						   u_int16_t max_chars_to_read,
 						   u_int16_t * bytes_read);
   u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t * str, u_int16_t max_chars_to_read,
 				    u_int16_t * bytes_read);
 
   void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_struct,
 				  struct ndpi_flow_struct *flow,
 				  u_int16_t upper_detected_protocol,
 				  u_int16_t lower_detected_protocol);
 
   extern void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_struct,
 					  struct ndpi_flow_struct *flow);
   extern void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_struct,
 					      struct ndpi_flow_struct *flow);
 
   extern u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_struct,
 						struct ndpi_flow_struct *flow, u_int16_t counter);
 
   extern void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_struct,
 				       struct ndpi_flow_struct *flow,
 				       u_int16_t upper_detected_protocol,
 				       u_int16_t lower_detected_protocol);
   extern void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_struct,
 				       struct ndpi_flow_struct *flow,
 				       ndpi_protocol_category_t protocol_category);
 
   extern void ndpi_set_proto_subprotocols(struct ndpi_detection_module_struct *ndpi_mod,
 				      int protoId, ...);
 
   extern void ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_mod,
 				      u_int8_t is_cleartext,
 				      ndpi_protocol_breed_t protoBreed, u_int16_t protoId, char *protoName,
 				      ndpi_protocol_category_t protoCategory,
 				      ndpi_port_range *tcpDefPorts,
 				      ndpi_port_range *udpDefPorts);
 
   extern void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow);
 
   extern int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t * ip);
   extern int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t * ip);
   extern void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t * ip);
   extern void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t * ip);
 
   extern int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip);
   extern char *ndpi_get_ip_string(const ndpi_ip_addr_t * ip, char *buf, u_int buf_len);
   extern u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip);
 
   extern char* ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_mod, u_int id);
   u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_mod, const char *name);
 
   extern u_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_struct,
 					  struct ndpi_flow_struct *flow,
 					  u_int8_t proto, u_int16_t sport, u_int16_t dport,
 					  u_int8_t *user_defined_proto);
 
   extern u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p);
 
   extern u_int16_t ndpi_get_lower_proto(ndpi_protocol p);
 
 #ifdef NDPI_ENABLE_DEBUG_MESSAGES
   void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_struct,
 					     const char **file, const char **func, u_int32_t * line);
 #endif
 
   /** Checks when the @p payload starts with the string literal @p str.
    * When the string is larger than the payload, check fails.
    * @return non-zero if check succeeded
    */
   int ndpi_match_prefix(const u_int8_t *payload, size_t payload_len,
 			const char *str, size_t str_len);
 
   /* version of ndpi_match_prefix with string literal */
 #define ndpi_match_strprefix(payload, payload_len, str)			\
   ndpi_match_prefix((payload), (payload_len), (str), (sizeof(str)-1))
 
-  int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str,
+  int ndpi_handle_ipv6_extension_headers(u_int16_t l3len,
 					 const u_int8_t ** l4ptr, u_int16_t * l4len,
 					 u_int8_t * nxt_hdr);
   void ndpi_set_risk(struct ndpi_detection_module_struct *ndpi_str,
 		     struct ndpi_flow_struct *flow, ndpi_risk_enum r);
   int ndpi_is_printable_string(char const * const str, size_t len);
 #define NDPI_ENTROPY_ENCRYPTED_OR_RANDOM(entropy) (entropy > 7.0f)
   float ndpi_entropy(u_int8_t const * const buf, size_t len);
   void load_common_alpns(struct ndpi_detection_module_struct *ndpi_str);
   u_int8_t is_a_common_alpn(struct ndpi_detection_module_struct *ndpi_str,
 			    const char *alpn_to_check, u_int alpn_to_check_len);    
 #ifdef __cplusplus
 }
 #endif
 
 #endif	/* __NDPI_MAIN_H__ */
diff --git a/src/lib/ndpi_main.c b/src/lib/ndpi_main.c
index cd24e52d..f2b6aa33 100644
--- a/src/lib/ndpi_main.c
+++ b/src/lib/ndpi_main.c
@@ -3545,627 +3545,638 @@ void ndpi_set_bitmask_protocol_detection(char *label, struct ndpi_detection_modu
 void ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_str,
                                           const NDPI_PROTOCOL_BITMASK *dbm) {
   NDPI_PROTOCOL_BITMASK detection_bitmask_local;
   NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;
   u_int32_t a = 0;
 
   NDPI_BITMASK_SET(detection_bitmask_local, *dbm);
   NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);
 
   /* set this here to zero to be interrupt safe */
   ndpi_str->callback_buffer_size = 0;
 
   /* HTTP */
   init_http_dissector(ndpi_str, &a, detection_bitmask);
 
   /* STARCRAFT */
   init_starcraft_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TLS+DTLS */
   init_tls_dissector(ndpi_str, &a, detection_bitmask);
 
   /* STUN */
   init_stun_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RTP */
   init_rtp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RTSP */
   init_rtsp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RDP */
   init_rdp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SIP */
   init_sip_dissector(ndpi_str, &a, detection_bitmask);
 
   /* IMO */
   init_imo_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Teredo */
   init_teredo_dissector(ndpi_str, &a, detection_bitmask);
 
   /* EDONKEY */
   init_edonkey_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FASTTRACK */
   init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);
 
   /* GNUTELLA */
   init_gnutella_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DIRECTCONNECT */
   init_directconnect_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NATS */
   init_nats_dissector(ndpi_str, &a, detection_bitmask);
 
   /* APPLEJUICE */
   init_applejuice_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SOCKS */
   init_socks_dissector(ndpi_str, &a, detection_bitmask);
 
   /* IRC */
   init_irc_dissector(ndpi_str, &a, detection_bitmask);
 
   /* JABBER */
   init_jabber_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MAIL_POP */
   init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MAIL_IMAP */
   init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MAIL_SMTP */
   init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* USENET */
   init_usenet_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DNS */
   init_dns_dissector(ndpi_str, &a, detection_bitmask);
 
   /* VMWARE */
   init_vmware_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NON_TCP_UDP */
   init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SOPCAST */
   init_sopcast_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TVUPLAYER */
   init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);
 
   /* PPSTREAM */
   init_ppstream_dissector(ndpi_str, &a, detection_bitmask);
 
   /* IAX */
   init_iax_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MGPC */
   init_mgpc_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ZATTOO */
   init_zattoo_dissector(ndpi_str, &a, detection_bitmask);
 
   /* QQ */
   init_qq_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SSH */
   init_ssh_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AYIYA */
   init_ayiya_dissector(ndpi_str, &a, detection_bitmask);
 
   /* THUNDER */
   init_thunder_dissector(ndpi_str, &a, detection_bitmask);
 
   /* VNC */
   init_vnc_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TEAMVIEWER */
   init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DHCP */
   init_dhcp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* STEAM */
   init_steam_dissector(ndpi_str, &a, detection_bitmask);
 
   /* HALFLIFE2 */
   init_halflife2_dissector(ndpi_str, &a, detection_bitmask);
 
   /* XBOX */
   init_xbox_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SMB */
   init_smb_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MINING */
   init_mining_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TELNET */
   init_telnet_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NTP */
   init_ntp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NFS */
   init_nfs_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SSDP */
   init_ssdp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WORLD_OF_WARCRAFT */
   init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);
 
   /* POSTGRES */
   init_postgres_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MYSQL */
   init_mysql_dissector(ndpi_str, &a, detection_bitmask);
 
   /* BGP */
   init_bgp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SNMP */
   init_snmp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* KONTIKI */
   init_kontiki_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ICECAST */
   init_icecast_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SHOUTCAST */
   init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);
 
   /* KERBEROS */
   init_kerberos_dissector(ndpi_str, &a, detection_bitmask);
 
   /* OPENFT */
   init_openft_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SYSLOG */
   init_syslog_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DIRECT_DOWNLOAD_LINK */
   init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NETBIOS */
   init_netbios_dissector(ndpi_str, &a, detection_bitmask);
 
   /* IPP */
   init_ipp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* LDAP */
   init_ldap_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WARCRAFT3 */
   init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);
 
   /* XDMCP */
   init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TFTP */
   init_tftp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MSSQL_TDS */
   init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);
 
   /* PPTP */
   init_pptp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* STEALTHNET */
   init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DHCPV6 */
   init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AFP */
   init_afp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* check_mk */
   init_checkmk_dissector(ndpi_str, &a, detection_bitmask);
 
   /* cpha */
   init_cpha_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AIMINI */
   init_aimini_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FLORENSIA */
   init_florensia_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MAPLESTORY */
   init_maplestory_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DOFUS */
   init_dofus_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WORLD_OF_KUNG_FU */
   init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FIESTA */
   init_fiesta_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CROSSIFIRE */
   init_crossfire_dissector(ndpi_str, &a, detection_bitmask);
 
   /* GUILDWARS */
   init_guildwars_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ARMAGETRON */
   init_armagetron_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DROPBOX */
   init_dropbox_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SPOTIFY */
   init_spotify_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RADIUS */
   init_radius_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CITRIX */
   init_citrix_dissector(ndpi_str, &a, detection_bitmask);
 
   /* LOTUS_NOTES */
   init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);
 
   /* GTP */
   init_gtp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DCERPC */
   init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NETFLOW */
   init_netflow_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SFLOW */
   init_sflow_dissector(ndpi_str, &a, detection_bitmask);
 
   /* H323 */
   init_h323_dissector(ndpi_str, &a, detection_bitmask);
 
   /* OPENVPN */
   init_openvpn_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NOE */
   init_noe_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CISCOVPN */
   init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TEAMSPEAK */
   init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SKINNY */
   init_skinny_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RTCP */
   init_rtcp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RSYNC */
   init_rsync_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WHOIS_DAS */
   init_whois_das_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ORACLE */
   init_oracle_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CORBA */
   init_corba_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RTMP */
   init_rtmp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FTP_CONTROL */
   init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FTP_DATA */
   init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MEGACO */
   init_megaco_dissector(ndpi_str, &a, detection_bitmask);
 
   /* REDIS */
   init_redis_dissector(ndpi_str, &a, detection_bitmask);
 
   /* VHUA */
   init_vhua_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ZMQ */
   init_zmq_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TELEGRAM */
   init_telegram_dissector(ndpi_str, &a, detection_bitmask);
 
   /* QUIC */
   init_quic_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DIAMETER */
   init_diameter_dissector(ndpi_str, &a, detection_bitmask);
 
   /* APPLE_PUSH */
   init_apple_push_dissector(ndpi_str, &a, detection_bitmask);
 
   /* EAQ */
   init_eaq_dissector(ndpi_str, &a, detection_bitmask);
 
   /* KAKAOTALK_VOICE */
   init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MPEGTS */
   init_mpegts_dissector(ndpi_str, &a, detection_bitmask);
 
   /* UBNTAC2 */
   init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);
 
   /* COAP */
   init_coap_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MQTT */
   init_mqtt_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SOME/IP */
   init_someip_dissector(ndpi_str, &a, detection_bitmask);
 
   /* RX */
   init_rx_dissector(ndpi_str, &a, detection_bitmask);
 
   /* GIT */
   init_git_dissector(ndpi_str, &a, detection_bitmask);
 
   /* HANGOUT */
   init_hangout_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DRDA */
   init_drda_dissector(ndpi_str, &a, detection_bitmask);
 
   /* BJNP */
   init_bjnp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SMPP */
   init_smpp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* TINC */
   init_tinc_dissector(ndpi_str, &a, detection_bitmask);
 
   /* FIX */
   init_fix_dissector(ndpi_str, &a, detection_bitmask);
 
   /* NINTENDO */
   init_nintendo_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MODBUS */
   init_modbus_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CAPWAP */
   init_capwap_dissector(ndpi_str, &a, detection_bitmask);
 
   /* ZABBIX */
   init_zabbix_dissector(ndpi_str, &a, detection_bitmask);
 
   /*** Put false-positive sensitive protocols at the end ***/
 
   /* VIBER */
   init_viber_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SKYPE */
   init_skype_dissector(ndpi_str, &a, detection_bitmask);
 
   /* BITTORRENT */
   init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WHATSAPP */
   init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* OOKLA */
   init_ookla_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AMQP */
   init_amqp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* CSGO */
   init_csgo_dissector(ndpi_str, &a, detection_bitmask);
 
   /* LISP */
   init_lisp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AJP */
   init_ajp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Memcached */
   init_memcached_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Nest Log Sink */
   init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WireGuard VPN */
   init_wireguard_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Amazon_Video */
   init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Targus Getdata */
   init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);
 
   /* S7 comm */
   init_s7comm_dissector(ndpi_str, &a, detection_bitmask);
 
   /* IEC 60870-5-104 */
   init_104_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DNP3 */
   init_dnp3_dissector(ndpi_str, &a, detection_bitmask);
 
   /* WEBSOCKET */
   init_websocket_dissector(ndpi_str, &a, detection_bitmask);
 
   /* SOAP */
   init_soap_dissector(ndpi_str, &a, detection_bitmask);
 
   /* DNScrypt */
   init_dnscrypt_dissector(ndpi_str, &a, detection_bitmask);
 
   /* MongoDB */
   init_mongodb_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AmongUS */
   init_among_us_dissector(ndpi_str, &a, detection_bitmask);
 
   /* HP Virtual Machine Group Management */
   init_hpvirtgrp_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Genshin Impact */
   init_genshin_impact_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Z39.50 international standard clientâ€“server, application layer communications protocol */
   init_z3950_dissector(ndpi_str, &a, detection_bitmask);
 
   /* AVAST SecureDNS */
   init_avast_securedns_dissector(ndpi_str, &a, detection_bitmask);
 
   /* Cassandra */
   init_cassandra_dissector(ndpi_str, &a, detection_bitmask);
 
 #ifdef CUSTOM_NDPI_PROTOCOLS
 #include "../../../nDPI-custom/custom_ndpi_main_init.c"
 #endif
 
   /* ----------------------------------------------------------------- */
 
   ndpi_str->callback_buffer_size = a;
 
   NDPI_LOG_DBG2(ndpi_str, "callback_buffer_size is %u\n", ndpi_str->callback_buffer_size);
 
   /* now build the specific buffer for tcp, udp and non_tcp_udp */
   ndpi_str->callback_buffer_size_tcp_payload = 0;
   ndpi_str->callback_buffer_size_tcp_no_payload = 0;
   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {
     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &
 	(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |
 	 NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {
       if(_ndpi_debug_callbacks)
 	NDPI_LOG_DBG2(ndpi_str, "callback_buffer_tcp_payload, adding buffer %u as entry %u\n", a,
 		      ndpi_str->callback_buffer_size_tcp_payload);
 
       memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],
 	     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));
       ndpi_str->callback_buffer_size_tcp_payload++;
 
       if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==
 	 0) {
 	if(_ndpi_debug_callbacks)
 	  NDPI_LOG_DBG2(
                         ndpi_str,
                         "\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\n", a);
 
 	memcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],
 	       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));
 	ndpi_str->callback_buffer_size_tcp_no_payload++;
       }
     }
   }
 
   ndpi_str->callback_buffer_size_udp = 0;
   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {
     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &
 	(NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |
 	 NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {
       if(_ndpi_debug_callbacks)
 	NDPI_LOG_DBG2(ndpi_str, "callback_buffer_size_udp: adding buffer : %u as entry %u\n", a,
 		      ndpi_str->callback_buffer_size_udp);
 
       memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],
 	     sizeof(struct ndpi_call_function_struct));
       ndpi_str->callback_buffer_size_udp++;
     }
   }
 
   ndpi_str->callback_buffer_size_non_tcp_udp = 0;
   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {
     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &
 	(NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |
 	 NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||
        (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=
        0) {
       if(_ndpi_debug_callbacks)
 	NDPI_LOG_DBG2(ndpi_str, "callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\n", a,
 		      ndpi_str->callback_buffer_size_non_tcp_udp);
 
       memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],
 	     &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));
       ndpi_str->callback_buffer_size_non_tcp_udp++;
     }
   }
 }
 
 /* handle extension headers in IPv6 packets
  * arguments:
+ *  l3len: the packet length excluding the IPv6 header
  * 	l4ptr: pointer to the byte following the initial IPv6 header
- * 	l4len: the length of the IPv6 packet excluding the IPv6 header
+ * 	l4len: the length of the IPv6 packet parsed from the IPv6 header
  * 	nxt_hdr: next header value from the IPv6 header
  * result:
- * 	l4ptr: pointer to the start of the actual packet payload
- * 	l4len: length of the actual payload
- * 	nxt_hdr: protocol of the actual payload
+ * 	l4ptr: pointer to the start of the actual layer 4 header
+ * 	l4len: length of the actual layer 4 header
+ * 	nxt_hdr: first byte of the layer 4 packet
  * returns 0 upon success and 1 upon failure
  */
-int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t **l4ptr,
+int ndpi_handle_ipv6_extension_headers(u_int16_t l3len, const u_int8_t **l4ptr,
                                        u_int16_t *l4len, u_int8_t *nxt_hdr) {
-  while((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {
+  while(l3len > 1 && (*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {
     u_int16_t ehdr_len, frag_offset;
 
     // no next header
     if(*nxt_hdr == 59) {
       return(1);
     }
 
     // fragment extension header has fixed size of 8 bytes and the first byte is the next header type
     if(*nxt_hdr == 44) {
       if(*l4len < 8) {
 	return(1);
       }
 
+      if (l3len < 5) {
+        return 1;
+      }
+      l3len -= 5;
+
       *nxt_hdr = (*l4ptr)[0];
       frag_offset = ntohs(*(u_int16_t *)((*l4ptr) + 2)) >> 3;
       // Handle ipv6 fragments as the ipv4 ones: keep the first fragment, drop the others
       if (frag_offset != 0)
           return(1);
       *l4len -= 8;
       (*l4ptr) += 8;
       continue;
     }
 
     // the other extension headers have one byte for the next header type
     // and one byte for the extension header length in 8 byte steps minus the first 8 bytes
     if(*l4len < 2) {
       return(1);
     }
 
     ehdr_len = (*l4ptr)[1];
     ehdr_len *= 8;
     ehdr_len += 8;
 
+    if (ehdr_len > l3len) {
+      return 1;
+    }
+    l3len -= ehdr_len;
+
     if(*l4len < ehdr_len) {
       return(1);
     }
 
     *nxt_hdr = (*l4ptr)[0];
 
     if(*l4len < ehdr_len)
       return(1);
 
     *l4len -= ehdr_len;
     (*l4ptr) += ehdr_len;
   }
 
   return(0);
 }
 
 /* Used by dns.c */
@@ -4188,88 +4199,88 @@ u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, cons
 /*
   extract the l4 payload, if available
   returned value:
   0: ok, extracted
   1: packet too small
   2,3: fragmented, ....
   else
   0: ok, extracted
   1: error or not available
 */
 static u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,
                                                u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,
                                                u_int8_t *l4_protocol_return, u_int32_t flags) {
   const struct ndpi_iphdr *iph = NULL;
   const struct ndpi_ipv6hdr *iph_v6 = NULL;
   u_int16_t l4len = 0;
   const u_int8_t *l4ptr = NULL;
   u_int8_t l4protocol = 0;
 
   if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))
     return(1);
 
   if((iph = (const struct ndpi_iphdr *) l3) == NULL)
     return(1);
 
   if(iph->version == IPVERSION && iph->ihl >= 5) {
     NDPI_LOG_DBG2(ndpi_str, "ipv4 header\n");
   }
   else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {
     NDPI_LOG_DBG2(ndpi_str, "ipv6 header\n");
     iph_v6 = (const struct ndpi_ipv6hdr *) l3;
     iph = NULL;
   } else {
     return(1);
   }
 
   if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {
     NDPI_LOG_DBG2(ndpi_str, "ipv4 header found but excluded by flag\n");
     return(1);
   } else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {
     NDPI_LOG_DBG2(ndpi_str, "ipv6 header found but excluded by flag\n");
     return(1);
   }
 
   /* 0: fragmented; 1: not fragmented */
   if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {
     u_int16_t len = ntohs(iph->tot_len);
     u_int16_t hlen = (iph->ihl * 4);
 
     l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);
 
     if(len == 0)
       len = l3_len;
 
     l4len = (len > hlen) ? (len - hlen) : 0;
     l4protocol = iph->protocol;
   }
 
   else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {
     l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));
     l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);
     l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;
 
     // we need to handle IPv6 extension headers if present
-    if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {
+    if(ndpi_handle_ipv6_extension_headers(l3_len - sizeof(struct ndpi_ipv6hdr), &l4ptr, &l4len, &l4protocol) != 0) {
       return(1);
     }
 
   } else {
     return(1);
   }
 
   if(l4_return != NULL) {
     *l4_return = l4ptr;
   }
 
   if(l4_len_return != NULL) {
     *l4_len_return = l4len;
   }
 
   if(l4_protocol_return != NULL) {
     *l4_protocol_return = l4protocol;
   }
 
   return(0);
 }
 
 /* ****************************************************** */
@@ -7000,24 +7011,25 @@ u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_
 int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct,
 				 struct ndpi_flow_struct *flow,
 				 u_int16_t master_protocol, char *name, u_int name_len) {
   ndpi_protocol_match_result ret_match;
   u_int16_t subproto, what_len;
   char *what;
 
   if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))
     what = &name[1], what_len = name_len - 1;
   else
     what = name, what_len = name_len;
 
+  memset(&ret_match, 0, sizeof(ret_match));
   subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len,
 					 &ret_match, master_protocol);
 
   if(subproto != NDPI_PROTOCOL_UNKNOWN) {
     ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);
     ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);
     return(1);
   } else
     return(0);
 }
 
 /* ****************************************************** */
@@ -7483,299 +7495,299 @@ static int ndpi_is_vowel(char c) {
 int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,
 			struct ndpi_flow_struct *flow,
 			char *name, u_int8_t is_hostname) {
   if(ndpi_dga_function != NULL) {
     /* A custom DGA function is defined */
     int rc = ndpi_dga_function(name, is_hostname);
 
     if(rc) {
       if(flow)
 	ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);  	
     }
 
     return(rc);
   } else {
     int len, rc = 0, trigram_char_skip = 0;
     u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0, num_trigram_dots = 0;
     u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;
     ndpi_protocol_match_result ret_match;
     
     if((!name)
        || (strchr(name, '_') != NULL)
        || (ndpi_ends_with(name, "in-addr.arpa"))
        || (ndpi_ends_with(name, "ip6.arpa"))
        /* Ignore TLD .local .lan and .home */
        || (ndpi_ends_with(name, ".local"))
        || (ndpi_ends_with(name, ".lan"))
        || (ndpi_ends_with(name, ".home"))
        )
       return(0);
 
     if(flow && (flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN))
       return(0); /* Ignore DGA check for protocols already fully detected */
 
     if(ndpi_match_string_subprotocol(ndpi_str, name, strlen(name), &ret_match, 1) > 0)
       return(0); /* Ignore DGA for known domain names */
 
     if(isdigit(name[0])) {
       struct in_addr ip_addr;
-      
+
       ip_addr.s_addr = inet_addr(name);
       if(strcmp(inet_ntoa(ip_addr), name) == 0)
 	return(0); /* Ignore numeric IPs */
     }
     
     if(strncmp(name, "www.", 4) == 0)
       name = &name[4];
 
     if(ndpi_verbose_dga_detection)
       printf("[DGA check] %s\n", name);
 
     len = strlen(name);
 
     if(len >= 5) {
       int num_found = 0, num_impossible = 0, num_bigram_checks = 0,
 	num_trigram_found = 0, num_trigram_checked = 0, num_dash = 0,
 	num_digits = 0, num_vowels = 0, num_trigram_vowels = 0, num_words = 0, skip_next_bigram = 0;
       char tmp[128], *word, *tok_tmp;
       u_int i, j, max_tmp_len = sizeof(tmp)-1;
 
       len = snprintf(tmp, max_tmp_len, "%s", name);
       if(len < 0) {
 
 	if(ndpi_verbose_dga_detection)
 	  printf("[DGA] Too short");
 
 	return(0);
       } else
 	tmp[(u_int)len < max_tmp_len ? (u_int)len : max_tmp_len] = '\0';
 
       for(i=0, j=0; (i<(u_int)len) && (j<max_tmp_len); i++) {
 	tmp[j] = tolower(name[i]);
 
 	if(tmp[j] == '.') {
 	  num_dots++;
 	} else if(num_dots == 0) {
 	  if(!isdigit(tmp[j]))
 	    first_element_is_numeric = 0;
 	}
 
 	if(ndpi_is_vowel(tmp[j]))
 	  num_vowels++;
 
 	if(last_char == tmp[j]) {
 	  if(++num_char_repetitions > max_num_char_repetitions)
 	    max_num_char_repetitions = num_char_repetitions;
 	} else
 	  num_char_repetitions = 1, last_char = tmp[j];
 
 	if(isdigit(tmp[j])) {
 	  num_digits++;
 
 	  if(((j+2)<(u_int)len) && isdigit(tmp[j+1]) && (tmp[j+2] == '.')) {
 	    /* Check if there are too many digits */
 	    if(num_digits < 4)
 	      return(0); /* Double digits */
 	  }
 	}
 
 	switch(tmp[j]) {
 	case '.':
 	case '-':
 	case '_':
 	case '/':
 	case ')':
 	case '(':
 	case ';':
 	case ':':
 	case '[':
 	case ']':
 	case ' ':
 	  /*
 	    Domain/word separator chars
 
 	    NOTE:
 	    this function is used also to detect other type of issues
 	    such as invalid/suspiciuous user agent
 	  */
 	  if(curr_domain_element_len > max_domain_element_len)
 	    max_domain_element_len = curr_domain_element_len;
 
 	  curr_domain_element_len = 0;
 	  break;
 
 	default:
 	  curr_domain_element_len++;
 	  break;
 	}
 
 	j++;
       }
 
       if(num_dots == 0) /* Doesn't look like a domain name */
 	return(0);
 
       if(curr_domain_element_len > max_domain_element_len)
 	max_domain_element_len = curr_domain_element_len;
 
       if(ndpi_verbose_dga_detection)
 	printf("[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\n",
 	       max_num_char_repetitions, max_domain_element_len);
 
       if(
 	 (is_hostname
 	  && (num_dots > 5)
 	  && (!first_element_is_numeric)
 	  )
 	 || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)
 	 /*
 	   In case of a name with too many consecutive chars an alert is triggered
 	   This is the case for instance of the wildcard DNS query used by NetBIOS
 	   (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited
 	   for reflection attacks
 	   - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf
 	   - http://ubiqx.org/cifs/NetBIOS.html
 	 */
 	 || ((max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */) && ((num_char_repetitions > 1) || (num_digits > 1)))
 	 ) {
 	if(flow) {
 	  ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
 	}
 
 	if(ndpi_verbose_dga_detection)
 	  printf("[DGA] Found!");
 
 	return(1);
       }
 
       tmp[j] = '\0';
       len = j;
 
       for(word = strtok_r(tmp, ".", &tok_tmp); ; word = strtok_r(NULL, ".", &tok_tmp)) {
 	if(!word) break;
 
 	num_words++;
 
 	if(strlen(word) < 3) continue;
 
 	if(ndpi_verbose_dga_detection)
 	  printf("-> word(%s) [%s][len: %u]\n", word, name, (unsigned int)strlen(word));
 
 	trigram_char_skip = 0;
 
 	for(i = 0; word[i+1] != '\0'; i++) {
 	  switch(word[i]) {
 	  case '-':
 	    num_dash++;
 	    /*
 	      Let's check for double+consecutive --
 	      that are usually ok
 	      r2---sn-uxaxpu5ap5-2n5e.gvt1.com
 	    */
 	    if(word[i+1] == '-')
 	      return(0); /* Double dash */
 	    continue;
 
 	  case '_':
 	  case ':':
 	    continue;
 	    break;
 
 	  case '.':
 	    continue;
 	    break;
 	  }
 	  num_bigram_checks++;
 
 	  if(ndpi_verbose_dga_detection)
 	    printf("-> Checking %c%c\n", word[i], word[i+1]);
 
 	  if(ndpi_match_impossible_bigram(&word[i])) {
 	    if(ndpi_verbose_dga_detection)
 	      printf("IMPOSSIBLE %s\n", &word[i]);
 
 	    num_impossible++;
 	  } else {
 	    if(!skip_next_bigram) {
 	      if(ndpi_match_bigram(&word[i])) {
 		num_found++, skip_next_bigram = 1;
 	      }
 	    } else
 	      skip_next_bigram = 0;
 	  }
 
 	  if((num_trigram_dots < 2) && (word[i+2] != '\0')) {
 	    if(ndpi_verbose_dga_detection)
 	      printf("***> %s [trigram_char_skip: %u]\n", &word[i], trigram_char_skip);
 
 	    if(ndpi_is_trigram_char(word[i]) && ndpi_is_trigram_char(word[i+1]) && ndpi_is_trigram_char(word[i+2])) {
 	      if(trigram_char_skip) {
 		trigram_char_skip--;
 	      } else {
 		num_trigram_checked++;
 
 		if(ndpi_match_trigram(&word[i]))
 		  num_trigram_found++, trigram_char_skip = 2 /* 1 char overlap */;
 		else if(ndpi_verbose_dga_detection)
 		  printf("[NDPI] NO Trigram %c%c%c\n", word[i], word[i+1], word[i+2]);
 
 		/* Count vowels */
 		num_trigram_vowels += ndpi_is_vowel(word[i]) + ndpi_is_vowel(word[i+1]) + ndpi_is_vowel(word[i+2]);
 	      }
 	    } else {
 	      if(word[i] == '.')
 		num_trigram_dots++;
 
 	      trigram_char_skip = 0;
 	    }
 	  }
 	} /* for */
       } /* for */
 
       if(ndpi_verbose_dga_detection)
 	printf("[%s][num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u][num_trigram_vowels: %u][num_trigram_found: %u/%u][vowels: %u][rc: %u]\n",
 	       name, num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, len, num_trigram_vowels,
 	       num_trigram_checked, num_trigram_found, num_vowels, rc);
 
       if((len > 16) && (num_dots < 3) && ((num_vowels*4) < (len-num_dots))) {
 	if((num_trigram_checked > 2) && (num_trigram_vowels >= (num_trigram_found-1)))
 	  ; /* skip me */
 	else
 	  rc = 1;
       }
 
       if(num_bigram_checks
 	 && (num_dots > 0)
 	 && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3))
 	     || enough(num_found, num_impossible)
 	     || ((num_trigram_checked > 2)
 		 && ((num_trigram_found < (num_trigram_checked/2))
 		     || ((num_trigram_vowels < (num_trigram_found-1)) && (num_dash == 0) && (num_dots > 1) && (num_impossible > 0)))
 		 )
 	     )
 	 )
 	rc = 1;
 
       if((num_trigram_checked > 2) && (num_vowels == 0))
 	rc = 1;
 
       if(num_dash > 2)
 	rc = 0;
 
       if(ndpi_verbose_dga_detection) {
 	if(rc)
 	  printf("DGA %s [num_found: %u][num_impossible: %u]\n",
 		 name, num_found, num_impossible);
       }
     }
 
     if(ndpi_verbose_dga_detection)
       printf("[DGA] Result: %u\n", rc);
 
     if(rc && flow)
       ndpi_set_risk(ndpi_str, flow, NDPI_SUSPICIOUS_DGA_DOMAIN);
 
     return(rc);
   }
 }
 
 /* ******************************************************************** */
diff --git a/src/lib/protocols/bittorrent.c b/src/lib/protocols/bittorrent.c
index f49c7f31..f7870619 100644
--- a/src/lib/protocols/bittorrent.c
+++ b/src/lib/protocols/bittorrent.c
@@ -387,115 +387,118 @@ static u_int8_t is_port(u_int16_t a, u_int16_t b, u_int16_t what) {
 void ndpi_search_bittorrent(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   char *bt_proto = NULL;
 
   /* This is broadcast */
   if(packet->iph) {
     if((packet->iph->saddr == 0xFFFFFFFF) || (packet->iph->daddr == 0xFFFFFFFF))
       goto exclude_bt;
     
     if(packet->udp) {
       u_int16_t sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);
 
       if(is_port(sport, dport, 3544) /* teredo */
 	 || is_port(sport, dport, 5246) || is_port(sport, dport, 5247)/* CAPWAP */) {
       exclude_bt:
 	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 	return;
       }
     }
   }
   if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_BITTORRENT) {
     /* check for tcp retransmission here */
 
     if(packet->tcp != NULL) {
       ndpi_int_search_bittorrent_tcp(ndpi_struct, flow);
     } else if(packet->udp != NULL) {
       /* UDP */
       char *bt_search = "BT-SEARCH * HTTP/1.1\r\n";
 
       if((ntohs(packet->udp->source) < 1024)
 	 || (ntohs(packet->udp->dest) < 1024) /* High ports only */) {
 	NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 	return;
       }
       
       /*
 	Check for uTP http://www.bittorrent.org/beps/bep_0029.html
 
 	wireshark/epan/dissectors/packet-bt-utp.c
       */
 
       if(packet->payload_packet_len >= 23 /* min header size */) {
 	if(strncmp((const char*)packet->payload, bt_search, strlen(bt_search)) == 0) {
 	  ndpi_add_connection_as_bittorrent(ndpi_struct, flow, -1, 1,
 					    NDPI_PROTOCOL_SAFE_DETECTION, NDPI_PROTOCOL_PLAIN_DETECTION);
 	  return;
 	} else {
 	  /* Check if this is protocol v0 */
 	  u_int8_t v0_extension = packet->payload[17];
 	  u_int8_t v0_flags     = packet->payload[18];
 
 	  if(is_utpv1_pkt(packet->payload, packet->payload_packet_len)) {
 	    bt_proto = ndpi_strnstr((const char *)&packet->payload[20], "BitTorrent protocol", packet->payload_packet_len-20);
 	    goto bittorrent_found;
 	  } else if((packet->payload[0]== 0x60)
 	     && (packet->payload[1]== 0x0)
 	     && (packet->payload[2]== 0x0)
 	     && (packet->payload[3]== 0x0)
 	     && (packet->payload[4]== 0x0)) {
 	    /* Heuristic */
 	    bt_proto = ndpi_strnstr((const char *)&packet->payload[20], "BitTorrent protocol", packet->payload_packet_len-20);
 	    goto bittorrent_found;
 	    /* CSGO/DOTA conflict */
 	  } else if((v0_flags < 6 /* ST_NUM_STATES */) && (v0_extension < 3 /* EXT_NUM_EXT */)) {
 	    u_int32_t ts = ntohl(*((u_int32_t*)&(packet->payload[4])));
 	    u_int32_t now;
 
 	    now = (u_int32_t)time(NULL);
 
 	    if((ts < (now+86400)) && (ts > (now-86400))) {
 	      bt_proto = ndpi_strnstr((const char *)&packet->payload[20], "BitTorrent protocol", packet->payload_packet_len-20);
 	      goto bittorrent_found;
 	    }
 	  }
 	}
       }
 
       flow->bittorrent_stage++;
 
       if(flow->bittorrent_stage < 5) {
 	  /* We have detected bittorrent but we need to wait until we get a hash */
 
 	  if(packet->payload_packet_len > 19 /* min size */) {
 	    if(ndpi_strnstr((const char *)packet->payload, ":target20:", packet->payload_packet_len)
 	       || ndpi_strnstr((const char *)packet->payload, ":find_node1:", packet->payload_packet_len)
 	       || ndpi_strnstr((const char *)packet->payload, "d1:ad2:id20:", packet->payload_packet_len)
 	       || ndpi_strnstr((const char *)packet->payload, ":info_hash20:", packet->payload_packet_len)
 	       || ndpi_strnstr((const char *)packet->payload, ":filter64", packet->payload_packet_len)
 	       || ndpi_strnstr((const char *)packet->payload, "d1:rd2:id20:", packet->payload_packet_len)
 	       || (bt_proto = ndpi_strnstr((const char *)packet->payload, "BitTorrent protocol", packet->payload_packet_len))
 	       ) {
 	    bittorrent_found:
-	      if(bt_proto && (packet->payload_packet_len > 47))
-		memcpy(flow->protos.bittorrent.hash, &bt_proto[27], 20);
+	      if(bt_proto != NULL && ((u_int8_t *)&bt_proto[27] - packet->payload +
+	         sizeof(flow->protos.bittorrent.hash)) < packet->payload_packet_len)
+	      {
+	        memcpy(flow->protos.bittorrent.hash, &bt_proto[27], sizeof(flow->protos.bittorrent.hash));
+	      }
 
 	      NDPI_LOG_INFO(ndpi_struct, "found BT: plain\n");
 	      ndpi_add_connection_as_bittorrent(ndpi_struct, flow, -1, 0,
 				NDPI_PROTOCOL_SAFE_DETECTION, NDPI_PROTOCOL_PLAIN_DETECTION);
 	      return;
 	    }
 	  }
 
 	return;
       }
 
       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
     }
   }
 
   if(flow->packet_counter > 8) {
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
     return;
   }  
 }
diff --git a/src/lib/protocols/http.c b/src/lib/protocols/http.c
index e291bc90..bb5b38ee 100644
--- a/src/lib/protocols/http.c
+++ b/src/lib/protocols/http.c
@@ -405,81 +405,79 @@ static void ndpi_check_user_agent(struct ndpi_detection_module_struct *ndpi_stru
 int http_process_user_agent(struct ndpi_detection_module_struct *ndpi_struct,
 			    struct ndpi_flow_struct *flow,
 			    const u_int8_t *ua_ptr, u_int16_t ua_ptr_len)
 {
   /**
       Format examples:
       Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) ....
       Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0
    */
   if(ua_ptr_len > 7) {
     char ua[256];
     u_int mlen = ndpi_min(ua_ptr_len, sizeof(ua)-1);
 
     strncpy(ua, (const char *)ua_ptr, mlen);
     ua[mlen] = '\0';
 
     if(strncmp(ua, "Mozilla", 7) == 0) {
       char *parent = strchr(ua, '(');
 
       if(parent) {
 	char *token, *end;
 
 	parent++;
 	end = strchr(parent, ')');
 	if(end) end[0] = '\0';
 
 	token = strsep(&parent, ";");
 	if(token) {
 	  if((strcmp(token, "X11") == 0)
 	     || (strcmp(token, "compatible") == 0)
 	     || (strcmp(token, "Linux") == 0)
 	     || (strcmp(token, "Macintosh") == 0)
 	     ) {
 	    token = strsep(&parent, ";");
 	    if(token && (token[0] == ' ')) token++; /* Skip space */
 
 	    if(token
 	       && ((strcmp(token, "U") == 0)
 		   || (strncmp(token, "MSIE", 4) == 0))) {
 	      token = strsep(&parent, ";");
 	      if(token && (token[0] == ' ')) token++; /* Skip space */
 
               if(token && (strncmp(token, "Update", 6)  == 0)) {
                 token = strsep(&parent, ";");
 
                 if(token && (token[0] == ' ')) token++; /* Skip space */
 
                 if(token && (strncmp(token, "AOL", 3)  == 0)) {
 
                   token = strsep(&parent, ";");
                   if(token && (token[0] == ' ')) token++; /* Skip space */
                 }
               }
             }
           }
 
           if(token)
             setHttpUserAgent(ndpi_struct, flow, token);
 	}
       }
     }
   }
 
   if(flow->http.user_agent == NULL) {
-    int len = ua_ptr_len + 1;
-
-    flow->http.user_agent = ndpi_malloc(len);
+    flow->http.user_agent = ndpi_malloc(ua_ptr_len + 1);
     if(flow->http.user_agent) {
       memcpy(flow->http.user_agent, (char*)ua_ptr, ua_ptr_len);
       flow->http.user_agent[ua_ptr_len] = '\0';
 
       ndpi_check_user_agent(ndpi_struct, flow, flow->http.user_agent);
     }
   }
 
   NDPI_LOG_DBG2(ndpi_struct, "User Agent Type line found %.*s\n",
 		ua_ptr_len, ua_ptr);
   return 0;
 }
 
 /* ************************************************************* */
diff --git a/src/lib/protocols/irc.c b/src/lib/protocols/irc.c
index bb1b6592..92a1f57d 100644
--- a/src/lib/protocols/irc.c
+++ b/src/lib/protocols/irc.c
@@ -368,375 +368,381 @@ u_int8_t ndpi_search_irc_ssl_detect_ninety_percent_but_very_fast(struct ndpi_det
 void ndpi_search_irc_tcp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
 	
   struct ndpi_id_struct *src = flow->src;
   struct ndpi_id_struct *dst = flow->dst;
   int less;
   u_int16_t c = 0;
   u_int16_t port = 0;
   u_int16_t sport = 0;
   u_int16_t dport = 0;
   u_int16_t counter = 0;
   u_int16_t i = 0;
   u_int16_t j = 0;
   u_int16_t k = 0;
   u_int16_t h;
   u_int16_t http_content_ptr_len = 0;
   u_int8_t space = 0;
 
   NDPI_LOG_DBG(ndpi_struct, "search irc\n");
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC && (flow->packet_counter > 10)) {
     NDPI_LOG_DBG(ndpi_struct, "exclude irc, packet_counter > 70\n");
     NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, NDPI_PROTOCOL_IRC);
     return;
   }
 
   if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_IRC) {
     if (src != NULL && ((u_int32_t)
 			(packet->current_time_ms - src->irc_ts) < ndpi_struct->irc_timeout)) {
       NDPI_LOG_DBG2(ndpi_struct, "irc : save src connection packet detected\n");
       src->irc_ts = packet->current_time_ms;
     } else if (dst != NULL && ((u_int32_t)
 			       (packet->current_time_ms - dst->irc_ts) < ndpi_struct->irc_timeout)) {
       NDPI_LOG_DBG2(ndpi_struct, "irc : save dst connection packet detected\n");
       dst->irc_ts = packet->current_time_ms;
     }
   }
 
   if (((dst != NULL && NDPI_COMPARE_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, NDPI_PROTOCOL_IRC)
 	&& ((u_int32_t)
 	    (packet->current_time_ms - dst->irc_ts)) <
 	ndpi_struct->irc_timeout)) || (src != NULL
 				       &&
 				       NDPI_COMPARE_PROTOCOL_TO_BITMASK
 				       (src->detected_protocol_bitmask, NDPI_PROTOCOL_IRC)
 				       && ((u_int32_t)
 					   (packet->current_time_ms - src->irc_ts)) < ndpi_struct->irc_timeout)) {
     if (packet->tcp != NULL) {
       sport = packet->tcp->source;
       dport = packet->tcp->dest;
     }
     if (dst != NULL) {
       for (counter = 0; counter < dst->irc_number_of_port; counter++) {
 	if (dst->irc_port[counter] == sport || dst->irc_port[counter] == dport) {
 	  dst->last_time_port_used[counter] = packet->current_time_ms;
 	  NDPI_LOG_INFO(ndpi_struct, "found IRC: dest port matched with the DCC port");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  return;
 	}
       }
     }
     if (src != NULL) {
       for (counter = 0; counter < src->irc_number_of_port; counter++) {
 	if (src->irc_port[counter] == sport || src->irc_port[counter] == dport) {
 	  src->last_time_port_used[counter] = packet->current_time_ms;
 	  NDPI_LOG_INFO(ndpi_struct, "found  IRC: Source port matched with the DCC port");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  return;
 	}
       }
     }
   }
 
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC &&
       ndpi_search_irc_ssl_detect_ninety_percent_but_very_fast(ndpi_struct, flow) != 0) {
     return;
   }
 
   if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC && flow->packet_counter < 20
       && packet->payload_packet_len >= 8) {
     if (get_u_int8_t(packet->payload, packet->payload_packet_len - 1) == 0x0a
 	|| (ntohs(get_u_int16_t(packet->payload, packet->payload_packet_len - 2)) == 0x0a00)) {
       if (memcmp(packet->payload, ":", 1) == 0) {
 	if (packet->payload[packet->payload_packet_len - 2] != 0x0d
 	    && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info_any(ndpi_struct, flow);
 	} else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
 	  ndpi_parse_packet_line_info(ndpi_struct, flow);
 	} else {
 	  flow->l4.tcp.irc_3a_counter++;
 	  packet->parsed_lines = 0;
 	}
 	for (i = 0; i < packet->parsed_lines; i++) {
 	  if ((packet->line[i].len > 0) && packet->line[i].ptr[0] == ':') {
 	    flow->l4.tcp.irc_3a_counter++;
 	    if (flow->l4.tcp.irc_3a_counter == 7) {	/* ':' == 0x3a */
 	      NDPI_LOG_INFO(ndpi_struct, "found irc. 0x3a. seven times.");
 	      ndpi_int_irc_add_connection(ndpi_struct, flow);
 	      goto detected_irc;
 	    }
 	  }
 	}
 	if (flow->l4.tcp.irc_3a_counter == 7) {	/* ':' == 0x3a */
 	  NDPI_LOG_INFO(ndpi_struct, "found irc. 0x3a. seven times.");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  goto detected_irc;
 	}
       }
       if ((memcmp(packet->payload, "USER ", 5) == 0)
 	  || (memcmp(packet->payload, "NICK ", 5) == 0)
 	  || (memcmp(packet->payload, "PASS ", 5) == 0)
 	  || (memcmp(packet->payload, ":", 1) == 0 && ndpi_check_for_NOTICE_or_PRIVMSG(ndpi_struct, flow) != 0)
 	  || (memcmp(packet->payload, "PONG ", 5) == 0)
 	  || (memcmp(packet->payload, "PING ", 5) == 0)
 	  || (memcmp(packet->payload, "JOIN ", 5) == 0)
 	  || (memcmp(packet->payload, "MODE ", 5) == 0)
 	  || (memcmp(packet->payload, "NOTICE ", 7) == 0)
 	  || (memcmp(packet->payload, "PRIVMSG ", 8) == 0)
 	  || (memcmp(packet->payload, "VERSION ", 8) == 0)) {
 	NDPI_LOG_DBG2(ndpi_struct,
 		      "USER, NICK, PASS, NOTICE, PRIVMSG one time");
 	if (flow->l4.tcp.irc_stage == 2) {
 	  NDPI_LOG_INFO(ndpi_struct, "found irc");
 	  ndpi_int_irc_add_connection(ndpi_struct, flow);
 	  flow->l4.tcp.irc_stage = 3;
 	}
 	if (flow->l4.tcp.irc_stage == 1) {
 	  NDPI_LOG_DBG2(ndpi_struct, "second time, stage=2");
 	  flow->l4.tcp.irc_stage = 2;
 	}
 	if (flow->l4.tcp.irc_stage == 0) {
 	  NDPI_LOG_DBG2(ndpi_struct, "first time, stage=1");
 	  flow->l4.tcp.irc_stage = 1;
 	}
 	/* irc packets can have either windows line breaks (0d0a) or unix line breaks (0a) */
 	if (packet->payload[packet->payload_packet_len - 2] == 0x0d
 	    && packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info(ndpi_struct, flow);
 	  if (packet->parsed_lines > 1) {
 	    NDPI_LOG_DBG2(ndpi_struct, "packet contains more than one line");
 	    for (c = 1; c < packet->parsed_lines; c++) {
 	      if (packet->line[c].len > 4 && (memcmp(packet->line[c].ptr, "NICK ", 5) == 0
 					      || memcmp(packet->line[c].ptr, "USER ", 5) == 0)) {
 		NDPI_LOG_INFO(ndpi_struct, "found IRC: two icq signal words in the same packet");
 		ndpi_int_irc_add_connection(ndpi_struct, flow);
 		flow->l4.tcp.irc_stage = 3;
 		return;
 	      }
 	    }
 	  }
 
 	} else if (packet->payload[packet->payload_packet_len - 1] == 0x0a) {
 	  ndpi_parse_packet_line_info_any(ndpi_struct, flow);
 	  if (packet->parsed_lines > 1) {
 	    NDPI_LOG_DBG2(ndpi_struct, "packet contains more than one line");
 	    for (c = 1; c < packet->parsed_lines; c++) {
 	      if (packet->line[c].len > 4 && (memcmp(packet->line[c].ptr, "NICK ", 5) == 0
 					      || memcmp(packet->line[c].ptr, "USER ",
 							5) == 0)) {
 		NDPI_LOG_INFO(ndpi_struct, "found IRC: two icq signal words in the same packet");
 		ndpi_int_irc_add_connection(ndpi_struct, flow);
 		flow->l4.tcp.irc_stage = 3;
 		return;
 	      }
 	    }
 	  }
 	}
       }
     }
   }
 
   /**
    * Trying to primarily detect the HTTP Web based IRC chat patterns based on the HTTP headers
    * during the User login time.When the HTTP data gets posted using the POST method ,patterns
    * will be searched in the HTTP content.
    */
   if ((flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC) && (flow->l4.tcp.irc_stage == 0)
       && (packet->payload_packet_len > 5)) {
     //HTTP POST Method being employed
     if (memcmp(packet->payload, "POST ", 5) == 0) {
       ndpi_parse_packet_line_info(ndpi_struct, flow);
       if (packet->parsed_lines) {
 	u_int16_t http_header_len = (u_int16_t)((packet->line[packet->parsed_lines - 1].ptr - packet->payload) + 2);
 	if (packet->payload_packet_len > http_header_len) {
 	  http_content_ptr_len = packet->payload_packet_len - http_header_len;
 	}
 	if ((ndpi_check_for_IRC_traces(packet->line[0].ptr, packet->line[0].len))
 	    || ((packet->http_url_name.ptr)
 		&& (ndpi_check_for_IRC_traces(packet->http_url_name.ptr, packet->http_url_name.len)))
 	    || ((packet->referer_line.ptr)
 		&& (ndpi_check_for_IRC_traces(packet->referer_line.ptr, packet->referer_line.len)))) {
 	  NDPI_LOG_DBG2(ndpi_struct,
 			"IRC detected from the Http URL/ Referer header ");
 	  flow->l4.tcp.irc_stage = 1;
 	  // HTTP POST Request body is not in the same packet.
 	  if (!http_content_ptr_len) {
 	    return;
 	  }
 	}
       }
     }
   }
 
   if ((flow->detected_protocol_stack[0] != NDPI_PROTOCOL_IRC) && (flow->l4.tcp.irc_stage == 1)) {
     if ((((packet->payload_packet_len - http_content_ptr_len) > 10)
 	 && (memcmp(packet->payload + http_content_ptr_len, "interface=", 10) == 0)
 	 && (ndpi_check_for_Nickname(ndpi_struct, flow) != 0))
 	|| (((packet->payload_packet_len - http_content_ptr_len) > 5)
 	    && (memcmp(packet->payload + http_content_ptr_len, "item=", 5) == 0)
 	    && (ndpi_check_for_cmd(ndpi_struct, flow) != 0))) {
       NDPI_LOG_INFO(ndpi_struct, "found IRC: Nickname, cmd,  one time");
       ndpi_int_irc_add_connection(ndpi_struct, flow);
       return;
     }
   }
 
  detected_irc:
   NDPI_LOG_DBG2(ndpi_struct, "detected_irc:");
 
   if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_IRC) {
     /* maybe this can be deleted at the end */
 
     if (packet->payload[packet->payload_packet_len - 2] != 0x0d
 	&& packet->payload[packet->payload_packet_len - 1] == 0x0a) {
       NDPI_LOG_DBG2(ndpi_struct, "ndpi_parse_packet_line_info_any(ndpi_struct, flow);");
       ndpi_parse_packet_line_info_any(ndpi_struct, flow);
     } else if (packet->payload[packet->payload_packet_len - 2] == 0x0d) {
       ndpi_parse_packet_line_info(ndpi_struct, flow);
     } else {
       return;
     }
     for (i = 0; i < packet->parsed_lines; i++) {
       if (packet->line[i].len > 6 && memcmp(packet->line[i].ptr, "NOTICE ", 7) == 0) {
 	NDPI_LOG_DBG2(ndpi_struct, "NOTICE");
 	for (j = 7; j < packet->line[i].len - 8; j++) {
 	  if (packet->line[i].ptr[j] == ':') {
 	    if (memcmp(&packet->line[i].ptr[j + 1], "DCC SEND ", 9) == 0
 		|| memcmp(&packet->line[i].ptr[j + 1], "DCC CHAT ", 9) == 0) {
 	      NDPI_LOG_INFO(ndpi_struct,
 			    "found NOTICE and DCC CHAT or DCC SEND.");
 	    }
 	  }
 	}
       }
       if (packet->payload_packet_len > 0 && packet->payload[0] == 0x3a /* 0x3a = ':' */ ) {
 	NDPI_LOG_DBG2(ndpi_struct, "3a");
 	for (j = 1; j < packet->line[i].len - 9; j++) {
 	  if (packet->line[i].ptr[j] == ' ') {
 	    j++;
 	    if (packet->line[i].ptr[j] == 'P') {
 	      NDPI_LOG_DBG2(ndpi_struct, "P");
 	      j++;
 	      if (memcmp(&packet->line[i].ptr[j], "RIVMSG ", 7) == 0)
 		NDPI_LOG_DBG2(ndpi_struct, "RIVMSG");
 	      h = j + 7;
 	      goto read_privmsg;
 	    }
 	  }
 	}
       }
       if (packet->line[i].len > 7 && (memcmp(packet->line[i].ptr, "PRIVMSG ", 8) == 0)) {
 	NDPI_LOG_DBG2(ndpi_struct, "PRIVMSG	");
 	h = 7;
       read_privmsg:
 	for (j = h; j < packet->line[i].len - 9; j++) {
 	  if (packet->line[i].ptr[j] == ':') {
 	    if (memcmp(&packet->line[i].ptr[j + 1], "xdcc ", 5) == 0) {
 	      NDPI_LOG_DBG2(ndpi_struct, "xdcc should match.");
 	    }
 	    j += 2;
-	    if (memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
+	    if (j + 4 < packet->line[i].len &&
+            memcmp(&packet->line[i].ptr[j], "DCC ", 4) == 0) {
 	      j += 4;
 	      NDPI_LOG_DBG2(ndpi_struct, "found DCC.");
-	      if (memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0
-		  || (memcmp(&packet->line[i].ptr[j], "CHAT", 4) == 0)
-		  || (memcmp(&packet->line[i].ptr[j], "chat", 4) == 0)
-		  || (j+7 < packet->line[i].len && memcmp(&packet->line[i].ptr[j], "sslchat", 7) == 0)
-		  || (memcmp(&packet->line[i].ptr[j], "TSEND", 5) == 0)) {
+		  if ((j + 5 < packet->line[i].len &&
+		       memcmp(&packet->line[i].ptr[j], "SEND ", 5) == 0) ||
+		      (j + 4 < packet->line[i].len &&
+		       memcmp(&packet->line[i].ptr[j], "CHAT", 4) == 0) ||
+		      (j + 4 < packet->line[i].len &&
+		       memcmp(&packet->line[i].ptr[j], "chat", 4) == 0) ||
+		      (j + 7 < packet->line[i].len &&
+		       memcmp(&packet->line[i].ptr[j], "sslchat", 7) == 0) ||
+		      (j + 5 < packet->line[i].len &&
+		       memcmp(&packet->line[i].ptr[j], "TSEND", 5) == 0)) {
 		NDPI_LOG_DBG2(ndpi_struct, "found CHAT,chat,sslchat,TSEND.");
 		j += 4;
 
 		while (packet->line[i].len > j &&
 		       ((packet->line[i].ptr[j] >= 'a' && packet->line[i].ptr[j] <= 'z')
 			|| (packet->line[i].ptr[j] >= 'A' && packet->line[i].ptr[j] <= 'Z')
 			|| (packet->line[i].ptr[j] >= '0' && packet->line[i].ptr[j] <= '9')
 			|| (packet->line[i].ptr[j] >= ' ')
 			|| (packet->line[i].ptr[j] >= '.')
 			|| (packet->line[i].ptr[j] >= '-'))) {
 
 		  if (packet->line[i].ptr[j] == ' ') {
 		    space++;
 		    NDPI_LOG_DBG2(ndpi_struct, "space %u.", space);
 		  }
 		  if (space == 3) {
 		    j++;
 		    NDPI_LOG_DBG2(ndpi_struct, "read port.");
 		    if (src != NULL) {
 		      k = j;
 		      port =
 			ntohs_ndpi_bytestream_to_number
 			(&packet->line[i].ptr[j], packet->payload_packet_len - j, &j);
 		      NDPI_LOG_DBG2(ndpi_struct, "port %u.",
 				    port);
 		      j = k;
 		      // hier jetzt Ã¼berlegen, wie die ports abgespeichert werden sollen
 		      if (src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT)
 			NDPI_LOG_DBG2(ndpi_struct, "src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT.");
 		      if (src->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT && port != 0) {
 			if (!ndpi_is_duplicate(src, port)) {
 			  src->irc_port[src->irc_number_of_port]
 			    = port;
 			  src->irc_number_of_port++;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d jjeeeeeeeeeeeeeeeeeeeeeeeee",
 					ntohs(get_u_int16_t(src->irc_port, 0)));
 			}
 			src->irc_ts = packet->current_time_ms;
 		      } else if (port != 0 && src->irc_number_of_port == NDPI_PROTOCOL_IRC_MAXPORT) {
 			if (!ndpi_is_duplicate(src, port)) {
 			  less = 0;
 			  NDPI_IRC_FIND_LESS(src->last_time_port_used, less);
 			  src->irc_port[less] = port;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(src->irc_port, 0)));
 			}
 			src->irc_ts = packet->current_time_ms;
 		      }
 		      if (dst == NULL) {
 			break;
 		      }
 		    }
 		    if (dst != NULL) {
 		      port = ntohs_ndpi_bytestream_to_number
 			(&packet->line[i].ptr[j], packet->payload_packet_len - j, &j);
 		      NDPI_LOG_DBG2(ndpi_struct, "port %u.", port);
 		      // hier das gleiche wie oben.
 		      /* hier werden NDPI_PROTOCOL_IRC_MAXPORT ports pro irc flows mitgespeichert. kÃ¶nnte man denn nicht ein-
 		       * fach an die dst oder src einen flag setzten, dass dieser port fÃ¼r eine bestimmte
 		       * zeit ein irc-port bleibt?
 		       */
 		      if (dst->irc_number_of_port < NDPI_PROTOCOL_IRC_MAXPORT && port != 0) {
 			if (!ndpi_is_duplicate(dst, port)) {
 			  dst->irc_port[dst->irc_number_of_port]
 			    = port;
 			  dst->irc_number_of_port++;
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(dst->irc_port, 0)));
 			  NDPI_LOG_DBG2(ndpi_struct, "juuuuuuuuuuuuuuuu");
 			}
 			dst->irc_ts = packet->current_time_ms;
 		      } else if (port != 0 && dst->irc_number_of_port == NDPI_PROTOCOL_IRC_MAXPORT) {
 			if (!ndpi_is_duplicate(dst, port)) {
 			  less = 0;
 			  NDPI_IRC_FIND_LESS(dst->last_time_port_used, less);
 			  dst->irc_port[less] = port;
 
 			  NDPI_LOG_DBG2(ndpi_struct, "found port=%d", ntohs(get_u_int16_t(dst->irc_port, 0)));
 			}
 			dst->irc_ts = packet->current_time_ms;
 		      }
 
 		      break;
 		    }
 		  }
 
 
 		  j++;
 		}
 
 	      }
 	    }
 	  }
 	}
 
       }
     }
   }
 }
diff --git a/src/lib/protocols/kerberos.c b/src/lib/protocols/kerberos.c
index fe1aba68..1f242ac4 100644
--- a/src/lib/protocols/kerberos.c
+++ b/src/lib/protocols/kerberos.c
@@ -43,383 +43,396 @@ static void ndpi_int_kerberos_add_connection(struct ndpi_detection_module_struct
 void ndpi_search_kerberos(struct ndpi_detection_module_struct *ndpi_struct,
 			  struct ndpi_flow_struct *flow) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   u_int16_t sport = packet->tcp ? ntohs(packet->tcp->source) : ntohs(packet->udp->source);
   u_int16_t dport = packet->tcp ? ntohs(packet->tcp->dest) : ntohs(packet->udp->dest);
   const u_int8_t *original_packet_payload = NULL;
   u_int16_t original_payload_packet_len = 0;
 
   if((sport != KERBEROS_PORT) && (dport != KERBEROS_PORT)) {
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
     return;
   }
   
   NDPI_LOG_DBG(ndpi_struct, "search KERBEROS\n");
 
 #ifdef KERBEROS_DEBUG
   printf("\n[Kerberos] Process packet [len: %u]\n", packet->payload_packet_len);
 #endif
     
   if(flow->kerberos_buf.pktbuf != NULL) {
     u_int missing = flow->kerberos_buf.pktbuf_maxlen - flow->kerberos_buf.pktbuf_currlen;
 
     if(packet->payload_packet_len <= missing) {
       memcpy(&flow->kerberos_buf.pktbuf[flow->kerberos_buf.pktbuf_currlen], packet->payload, packet->payload_packet_len);
       flow->kerberos_buf.pktbuf_currlen += packet->payload_packet_len;
 
       if(flow->kerberos_buf.pktbuf_currlen == flow->kerberos_buf.pktbuf_maxlen) {
 	original_packet_payload = packet->payload;
 	original_payload_packet_len = packet->payload_packet_len;
 	packet->payload = (u_int8_t *)flow->kerberos_buf.pktbuf;
 	packet->payload_packet_len = flow->kerberos_buf.pktbuf_currlen;
 #ifdef KERBEROS_DEBUG
 	printf("[Kerberos] Packet is now full: processing\n");
 #endif
       } else {
 #ifdef KERBEROS_DEBUG
 	printf("[Kerberos] Missing %u bytes: skipping\n",
 	       flow->kerberos_buf.pktbuf_maxlen - flow->kerberos_buf.pktbuf_currlen);
 #endif
 
 	return;
       }
     }
   }
 
   /* I have observed 0a,0c,0d,0e at packet->payload[19/21], maybe there are other possibilities */
   if(packet->payload_packet_len >= 4) {
     u_int32_t kerberos_len, expected_len;
     u_int16_t base_offset = 0;
 
     if(packet->tcp) {
       kerberos_len = ntohl(get_u_int32_t(packet->payload, 0)),
 	expected_len = packet->payload_packet_len - 4;
       base_offset = 4;
     } else
       base_offset = 0, kerberos_len = expected_len = packet->payload_packet_len;
 
 #ifdef KERBEROS_DEBUG
     printf("[Kerberos] [Kerberos len: %u][expected_len: %u]\n", kerberos_len, expected_len);
 #endif
 
     if(kerberos_len < 12000) {
       /*
 	Kerberos packets might be too long for a TCP packet
 	so it could be split across two packets. Instead of
 	rebuilding the stream we use a heuristic approach
       */
       if(kerberos_len > expected_len) {
 	if(packet->tcp) {
 	  if(flow->kerberos_buf.pktbuf == NULL) {
 	    flow->kerberos_buf.pktbuf = (char*)ndpi_malloc(kerberos_len+4);
 
 	    if(flow->kerberos_buf.pktbuf != NULL) {
 	      flow->kerberos_buf.pktbuf_maxlen = kerberos_len+4;	      
 #ifdef KERBEROS_DEBUG
 	      printf("[Kerberos] Allocated %u bytes\n", flow->kerberos_buf.pktbuf_maxlen);
 #endif	      
 	    }
 	  }
 	  
 	  if(flow->kerberos_buf.pktbuf != NULL) {
 	    if(packet->payload_packet_len <= flow->kerberos_buf.pktbuf_maxlen) {
 	      memcpy(flow->kerberos_buf.pktbuf, packet->payload, packet->payload_packet_len);
 	      flow->kerberos_buf.pktbuf_currlen = packet->payload_packet_len;
 	    }
 	  }
 	}
 	
 	return;
       } else if(kerberos_len == expected_len) {
 	if(packet->payload_packet_len > 128) {
 	  u_int16_t koffset, i;
 
 	  for(i=8; i<16; i++)
 	    if((packet->payload[base_offset+i] == 0x03)
 	       && (packet->payload[base_offset+i+1] == 0x02)
 	       && (packet->payload[base_offset+i+2] == 0x01)
 	       && (packet->payload[base_offset+i+3] != 0x05)
 	       )
 	      break;
 
 	  koffset = base_offset + i + 3;
 
 #ifdef KERBEROS_DEBUG
 	  printf("[Kerberos] [msg-type: 0x%02X/%u][koffset: %u]\n",
 		 packet->payload[koffset], packet->payload[koffset], koffset);
 #endif
 
 	  if(((packet->payload[koffset] == 0x0A)
 	      || (packet->payload[koffset] == 0x0C)
 	      || (packet->payload[koffset] == 0x0D)
 	      || (packet->payload[koffset] == 0x0E))) {
 	    u_int16_t koffsetp, body_offset = 0, pad_len;
 	    u_int8_t msg_type = packet->payload[koffset];
 
 #ifdef KERBEROS_DEBUG
 	    printf("[Kerberos] Packet found 0x%02X/%u\n", msg_type, msg_type);
 #endif
 	    if(msg_type != 0x0d) /* TGS-REP */ {
 	      /* Process only on requests */
 	      if(packet->payload[koffset+1] == 0xA3) {
 		if(packet->payload[koffset+3] == 0x30)
 		  pad_len = packet->payload[koffset+4];
 		else {
 		  /* Long pad */
 		  pad_len = packet->payload[koffset+2];
 		  for(i=3; i<10; i++) if(packet->payload[koffset+i] == pad_len) break;
 
 		  pad_len = (packet->payload[koffset+i+1] << 8) + packet->payload[koffset+i+2];
 		  koffset += i-2;
 		}
 	      } else
 		pad_len = 0;
 
 #ifdef KERBEROS_DEBUG
 	      printf("pad_len=0x%02X/%u\n", pad_len, pad_len);
 #endif
 
 	      if(pad_len > 0) {
 		koffsetp = koffset + 2;
 		for(i=0; i<4; i++) if(packet->payload[koffsetp] != 0x30) koffsetp++; /* ASN.1 */
 #ifdef KERBEROS_DEBUG
 		printf("koffsetp=%u [%02X %02X] [byte 0 must be 0x30]\n", koffsetp, packet->payload[koffsetp], packet->payload[koffsetp+1]);
 #endif
 	      } else
 		koffsetp = koffset;
 
 	      body_offset = koffsetp + 1 + pad_len;
 
 	      for(i=0; i<10; i++) if(body_offset<packet->payload_packet_len && packet->payload[body_offset] != 0x05) body_offset++; /* ASN.1 */
 #ifdef KERBEROS_DEBUG
 	      printf("body_offset=%u [%02X %02X] [byte 0 must be 0x05]\n", body_offset, packet->payload[body_offset], packet->payload[body_offset+1]);
 #endif
 	    }
 	    
 	    if(msg_type == 0x0A) /* AS-REQ */ {
 #ifdef KERBEROS_DEBUG
 	      printf("[Kerberos] Processing AS-REQ\n");
 #endif
 
 
 	      if(body_offset < packet->payload_packet_len) {
 		u_int16_t name_offset = body_offset + 13;
 		
 		for(i=0; (i<20) && (name_offset < packet->payload_packet_len); i++) {
 		  if(packet->payload[name_offset] != 0x1b)
 		    name_offset++; /* ASN.1 */
 		}
 		
 #ifdef KERBEROS_DEBUG
 		printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
 #endif
 
-		if(name_offset < packet->payload_packet_len) {
+		if(name_offset < packet->payload_packet_len - 1) {
 		  u_int cname_len = 0;
 
 		  name_offset += 1;
-		  if(packet->payload[name_offset+1] < ' ') /* Isn't printable ? */
+		  if(name_offset < packet->payload_packet_len - 1 &&
+		     isprint(packet->payload[name_offset+1]) == 0) /* Isn't printable ? */
+		  {
 		    name_offset++;
+		  }
 
-		  if(packet->payload[name_offset+1] == 0x1b)
+		  if(name_offset < packet->payload_packet_len - 1 &&
+		     packet->payload[name_offset+1] == 0x1b)
+		  {
 		    name_offset += 2;
+		  }
 		  
 		  cname_len = packet->payload[name_offset];
 
 		  if((cname_len+name_offset) < packet->payload_packet_len) {
 		    u_int realm_len, realm_offset;
 		    char cname_str[48];
 		    u_int8_t num_cname = 0;
 
+			cname_str[0] = '\0'; // required, because cname_len
+
 		    while(++num_cname <= 2) {
 		      if(cname_len > sizeof(cname_str)-1)
-			cname_len = sizeof(cname_str)-1;
+		        cname_len = sizeof(cname_str)-1;
 
-		      strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
+		      if (name_offset + cname_len + 1 >= packet->payload_packet_len)
+		        cname_len = 0;
+		      else
+		        strncpy(cname_str, (char*)&packet->payload[name_offset+1], cname_len);
 		      cname_str[cname_len] = '\0';
 		      for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);
 
 #ifdef KERBEROS_DEBUG
 		      printf("[AS-REQ][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n", sport, dport, cname_len, cname_str);
 #endif
 
 		      if(((strcmp(cname_str, "host") == 0) || (strcmp(cname_str, "ldap") == 0)) && (packet->payload[name_offset+1+cname_len] == 0x1b)) {
-			name_offset += cname_len + 2;
-			cname_len = packet->payload[name_offset];
-		      } else
-			break;
+		        name_offset += cname_len + 2;
+		        if (name_offset < packet->payload_packet_len)
+		          cname_len = packet->payload[name_offset];
+		      } else{
+		        break;
+		      }
 		    }
 
 		    realm_offset = cname_len + name_offset + 3;
 
 		    /* if cname does not end with a $ then it's a username */
-		    if(cname_len
+		    if(cname_len > 0 && name_offset + cname_len + 1 < packet->payload_packet_len
 		       && (cname_len < sizeof(cname_str))
 		       && (cname_str[cname_len-1] == '$')) {
 		      cname_str[cname_len-1] = '\0';
 		      snprintf(flow->protos.kerberos.hostname, sizeof(flow->protos.kerberos.hostname), "%s", cname_str);
 		    } else
 		      snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", cname_str);
 
 		    for(i=0; (i < 14) && (realm_offset <  packet->payload_packet_len); i++) {
 		      if(packet->payload[realm_offset] != 0x1b)
 			realm_offset++; /* ASN.1 */
 		    }
 		    
 #ifdef KERBEROS_DEBUG
 		    printf("realm_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", realm_offset,
 			   packet->payload[realm_offset], packet->payload[realm_offset+1]);
 #endif
 		    
 		    realm_offset += 1;
 		    //if(num_cname == 2) realm_offset++;
 		    if(realm_offset  < packet->payload_packet_len) {
 		      realm_len = packet->payload[realm_offset];
 
 		      if((realm_offset+realm_len) < packet->payload_packet_len) {
 			char realm_str[48];
 
 			if(realm_len > sizeof(realm_str)-1)
 			  realm_len = sizeof(realm_str)-1;
 
 			realm_offset += 1;
 
 			strncpy(realm_str, (char*)&packet->payload[realm_offset], realm_len);
 			realm_str[realm_len] = '\0';
 			for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);
 
 #ifdef KERBEROS_DEBUG
 			printf("[AS-REQ][Kerberos Realm][len: %u][%s]\n", realm_len, realm_str);
 #endif
 			snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
 		      }
 		    }
 		  }
 		}
 	      } 
 	    } else if(msg_type == 0x0c) /* TGS-REQ */ {
 #ifdef KERBEROS_DEBUG
 	      printf("[Kerberos] Processing TGS-REQ\n");
 #endif
 
 	      if(body_offset < packet->payload_packet_len) {
 		u_int16_t name_offset, padding_offset = body_offset + 4;
 
 		name_offset = padding_offset;
-		for(i=0; i<14; i++) if(packet->payload[name_offset] != 0x1b) name_offset++; /* ASN.1 */
+		for(i=0; i<14 && name_offset < packet->payload_packet_len; i++) if(packet->payload[name_offset] != 0x1b) name_offset++; /* ASN.1 */
 
 #ifdef KERBEROS_DEBUG
 		printf("name_offset=%u [%02X %02X] [byte 0 must be 0x1b]\n", name_offset, packet->payload[name_offset], packet->payload[name_offset+1]);
 #endif
 
 		if(name_offset < (packet->payload_packet_len - 1)) {
 		  u_int realm_len;
 
 		  name_offset++;
 		  realm_len = packet->payload[name_offset];
 
 		  if((realm_len+name_offset) < packet->payload_packet_len) {
 		    char realm_str[48];
 
 		    if(realm_len > sizeof(realm_str)-1)
 		      realm_len = sizeof(realm_str)-1;
 
 		    name_offset += 1;
 
 		    strncpy(realm_str, (char*)&packet->payload[name_offset], realm_len);
 		    realm_str[realm_len] = '\0';
 		    for(i=0; i<realm_len; i++) realm_str[i] = tolower(realm_str[i]);
 
 #ifdef KERBEROS_DEBUG
 		    printf("[TGS-REQ][s/dport: %u/%u][Kerberos Realm][len: %u][%s]\n", sport, dport, realm_len, realm_str);
 #endif
 		    snprintf(flow->protos.kerberos.domain, sizeof(flow->protos.kerberos.domain), "%s", realm_str);
 
 		    /* If necessary we can decode sname */
 		    if(flow->kerberos_buf.pktbuf) {
 			    ndpi_free(flow->kerberos_buf.pktbuf);
 			    packet->payload = original_packet_payload;
 			    packet->payload_packet_len = original_payload_packet_len;
 		    }
 		    flow->kerberos_buf.pktbuf = NULL;
 		  }
 		}
 	      }
 
 	      if(packet->udp)
 		ndpi_int_kerberos_add_connection(ndpi_struct, flow);
 
 	      /* We set the protocol in the response */
 	      if(flow->kerberos_buf.pktbuf != NULL) {
 		ndpi_free(flow->kerberos_buf.pktbuf);
 		packet->payload = original_packet_payload;
 		packet->payload_packet_len = original_payload_packet_len;
 		flow->kerberos_buf.pktbuf = NULL;
 	      }
 	      
 	      return;
 	    } else if(msg_type == 0x0d) /* TGS-REP */ {
 	      u_int16_t pad_data_len, cname_offset;
 	      
 #ifdef KERBEROS_DEBUG
 	      printf("[Kerberos] Processing TGS-REP\n");
 #endif
 
 	      koffsetp = koffset + 4;
 	      pad_data_len = packet->payload[koffsetp];
 	      /* Skip realm already filled in request */
 	      cname_offset = pad_data_len + koffsetp + 15;
 
 	      if(cname_offset < packet->payload_packet_len) {
 		u_int8_t cname_len = packet->payload[cname_offset];
 
 		if((cname_offset+cname_offset) < packet->payload_packet_len) {
 		  char cname_str[48];
 		  
 		  if(cname_len > sizeof(cname_str)-1)
 		    cname_len = sizeof(cname_str)-1;
 
 		  strncpy(cname_str, (char*)&packet->payload[cname_offset+1], cname_len);
 		  cname_str[cname_len] = '\0';
 		  for(i=0; i<cname_len; i++) cname_str[i] = tolower(cname_str[i]);
 
 #ifdef KERBEROS_DEBUG
 		  printf("[TGS-REP][s/dport: %u/%u][Kerberos Cname][len: %u][%s]\n",
 			 sport, dport, cname_len, cname_str);
 #endif
 
 		  if(cname_len && cname_str[cname_len-1] == '$') {
 		    cname_str[cname_len-1] = '\0';
 		    snprintf(flow->protos.kerberos.hostname, sizeof(flow->protos.kerberos.hostname), "%s", cname_str);
 		  } else
 		    snprintf(flow->protos.kerberos.username, sizeof(flow->protos.kerberos.username), "%s", cname_str);
 
 		  ndpi_int_kerberos_add_connection(ndpi_struct, flow);
 		}
 	      }
 	    }
 
 	    return;
 	  }
 
 	  if(packet->payload_packet_len > 21 &&
 	     packet->payload[16] == 0x05 &&
 	     (packet->payload[21] == 0x0a ||
 	      packet->payload[21] == 0x0c || packet->payload[21] == 0x0d || packet->payload[21] == 0x0e)) {
 	    ndpi_int_kerberos_add_connection(ndpi_struct, flow);
 	    return;
 	  }
 	}
       }
     } else {
 #ifdef KERBEROS_DEBUG
       printf("[Kerberos][s/dport: %u/%u] Skipping packet: too long [kerberos_len: %u]\n",
 	     sport, dport, kerberos_len);
 #endif
 
       if(flow->protos.kerberos.domain[0] != '\0')
 	return;
     }
   }
 
   NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 }
diff --git a/src/lib/protocols/ntp.c b/src/lib/protocols/ntp.c
index db941612..1b56dc8a 100644
--- a/src/lib/protocols/ntp.c
+++ b/src/lib/protocols/ntp.c
@@ -37,27 +37,27 @@ static void ndpi_int_ntp_add_connection(struct ndpi_detection_module_struct
 void ndpi_search_ntp_udp(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   
   NDPI_LOG_DBG(ndpi_struct, "search NTP\n");
 
   if (packet->udp->dest == htons(123) || packet->udp->source == htons(123)) {
   
     NDPI_LOG_DBG2(ndpi_struct, "NTP port and length detected\n");
   
     if ((((packet->payload[0] & 0x38) >> 3) <= 4)) {
     
       // 38 in binary representation is 00111000 
       flow->protos.ntp.version = (packet->payload[0] & 0x38) >> 3;
     
-      if (flow->protos.ntp.version == 2) {
+      if (packet->payload_packet_len > 3 && flow->protos.ntp.version == 2) {
         flow->protos.ntp.request_code = packet->payload[3];
       }
     
       NDPI_LOG_INFO(ndpi_struct, "found NTP\n");
       ndpi_int_ntp_add_connection(ndpi_struct, flow);
       return;
     }
   }
 
   NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
 }
diff --git a/src/lib/protocols/ppstream.c b/src/lib/protocols/ppstream.c
index 44eb812d..91f66bee 100644
--- a/src/lib/protocols/ppstream.c
+++ b/src/lib/protocols/ppstream.c
@@ -41,183 +41,183 @@ static void ndpi_int_ppstream_add_connection(struct ndpi_detection_module_struct
 void ndpi_search_ppstream(struct ndpi_detection_module_struct
 			  *ndpi_struct, struct ndpi_flow_struct *flow)
 {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
 
   NDPI_LOG_DBG(ndpi_struct, "search PPStream\n");
   /**
      PPS over TCP is detected inside HTTP dissector 
   */
 	
   /* check PPS over UDP */
   if(packet->udp != NULL) {
     /*** on port 17788 ***/
-    if(packet->payload_packet_len > 12 && ((ntohs(packet->udp->source) == PPS_PORT) || (ntohs(packet->udp->dest) == PPS_PORT))) {
+    if(packet->payload_packet_len > 14 && ((ntohs(packet->udp->source) == PPS_PORT) || (ntohs(packet->udp->dest) == PPS_PORT))) {
       if(((packet->payload_packet_len - 4 == get_l16(packet->payload, 0))
 	  || (packet->payload_packet_len == get_l16(packet->payload, 0))
 	  || (packet->payload_packet_len >= 6 && packet->payload_packet_len - 6 == get_l16(packet->payload, 0)))) {
 	/* check 43 and */
 	if(packet->payload[2] == 0x43) {
 	  if(packet->payload[5] == 0xff &&
 	     packet->payload[6] == 0x00 &&
 	     packet->payload[7] == 0x01 &&
 	     packet->payload[8] == 0x00 &&
 	     packet->payload[9] == 0x00 &&
 	     packet->payload[10] == 0x00 &&
 	     packet->payload[11] == 0x00 &&
 	     packet->payload[12] == 0x00 &&
 	     packet->payload[13] == 0x00 &&
 	     packet->payload[14] == 0x00) {
 
 	    /* increase count pkt ppstream over udp */
 	    flow->l4.udp.ppstream_stage++;
 	    
 	    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 	    return;
 	  }       
 	  /* check 44 */
 	  else if(packet->payload[2] == 0x44) {
 	    /** b1 71 **/
 	    if(packet->payload[3] == 0xb1 && packet->payload[4] == 0x71) {
 	      if(packet->payload[13] == 0x00 &&
 		 packet->payload[14] == 0x00 &&
 		 packet->payload[15] == 0x01 &&
 		 packet->payload[16] == 0x00) {
 		/* 02 03 04 05 */
 		if(packet->payload[17] == 0x02 ||
 		   packet->payload[17] == 0x03 ||
 		   packet->payload[17] == 0x04 ||
 		   packet->payload[17] == 0x05) {
 		  if(packet->payload[18] == 0x00 &&
 		     packet->payload[19] == 0x00 &&
 		     packet->payload[20] == 0x00) {
 
 		    /* increase count pkt ppstream over udp */
 		    flow->l4.udp.ppstream_stage++;
 
 		    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 		    return;
 		  }
 		}
 		/* ff */
 		else if(packet->payload[17] == 0xff) {
 		  if(packet->payload[18] == 0xff &&
 		     packet->payload[19] == 0xff &&
 		     packet->payload[20] == 0xff) {
 
 		    /* increase count pkt ppstream over udp */
 		    flow->l4.udp.ppstream_stage++;
 		  
 		    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 		    return;
 		  }
 		}
 	      }
 	    }
 	    /** 73 17 **/
 	    else if(packet->payload[3] == 0x73 && packet->payload[4] == 0x17) {
 	      if(packet->payload[5] == 0x00 &&
 		 packet->payload[6] == 0x00 &&
 		 packet->payload[7] == 0x00 &&
 		 packet->payload[8] == 0x00 &&
 		 packet->payload[14] == 0x00 &&
 		 packet->payload[15] == 0x00 &&
 		 packet->payload[16] == 0x00 &&
 		 packet->payload[17] == 0x00 &&
 		 packet->payload[18] == 0x00 &&
 		 packet->payload[19] == 0x00 &&
 		 packet->payload[20] == 0x00) {
 
 		/* increase count pkt ppstream over udp */
 		flow->l4.udp.ppstream_stage++;
 
 		ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 		return;
 	      }
 	    }
 	    /** 74 71 **/
 	    else if(packet->payload[3] == 0x74 && packet->payload[4] == 0x71 && packet->payload_packet_len == 113) {
 	      /* check "PPStream" string in hex */
 	      if(packet->payload[94] == 0x50 &&
 		 packet->payload[95] == 0x50 &&
 		 packet->payload[96] == 0x53 &&
 		 packet->payload[97] == 0x74 &&
 		 packet->payload[98] == 0x72 &&
 		 packet->payload[99] == 0x65 &&
 		 packet->payload[100] == 0x61 &&
 		 packet->payload[101] == 0x6d) {
 
 		/* increase count pkt ppstream over udp */
 		flow->l4.udp.ppstream_stage++;
 	      
 		ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 		return;
 	      }
 	    }
 	  }
 	  /** check 55 (1) **/
 	  else if(packet->payload[2] == 0x55 && (packet->payload[13] == 0x1b &&
 						 packet->payload[14] == 0xa0 &&
 						 packet->payload[15] == 0x00 &&
 						 packet->payload[16] == 0x00 &&
 						 packet->payload[17] == 0x00 &&
 						 packet->payload[18] == 0x00 &&
 						 packet->payload[19] == 0x00 &&
 						 packet->payload[20] == 0x00 )) {
 
 	    /* increase count pkt ppstream over udp */
 	    flow->l4.udp.ppstream_stage++;
 
 	    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 	    return;
 	  }
 	  /** check 55 (2) **/
 	  else if(packet->payload[2] == 0x55 && packet->payload[1] == 0x00 &&
 		  (packet->payload[5] == 0x00 &&
 		   packet->payload[6] == 0x00 &&
 		   packet->payload[7] == 0x00 &&
 		   packet->payload[8] == 0x00 &&
 		   packet->payload[14] == 0x00 &&
 		   packet->payload[15] == 0x00 &&
 		   packet->payload[16] == 0x00 &&
 		   packet->payload[17] == 0x00 &&
 		   packet->payload[18] == 0x00 &&
 		   packet->payload[19] == 0x00 &&
 		   packet->payload[20] == 0x00 )) {
 
 	    /* increase count pkt ppstream over udp */
 	    flow->l4.udp.ppstream_stage++;
 	  
 	    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 	    return;
 	  }
 	}
       }
       /* No port detection */
       if(packet->payload_packet_len > 17) {
 	/* 80 */
 	if(packet->payload[1] == 0x80 || packet->payload[1] == 0x84 ) {
 	  if(packet->payload[3] == packet->payload[4]) {
 
 	    /* increase count pkt ppstream over udp */
 	    flow->l4.udp.ppstream_stage++;
 	  
 	    ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 	    return;
 	  }
 	}
 	/* 53 */
 	else if(packet->payload[1] == 0x53 && packet->payload[3] == 0x00 &&
 		(packet->payload[0] == 0x08 || packet->payload[0] == 0x0c)) {
 
 	  /* increase count pkt ppstream over udp */
 	  flow->l4.udp.ppstream_stage++;
 	
 	  ndpi_int_ppstream_add_connection(ndpi_struct, flow);
 	  return;
 	}
       }
     }
 
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
   }
 }
diff --git a/src/lib/protocols/tls.c b/src/lib/protocols/tls.c
index 799092af..1a849b2c 100644
--- a/src/lib/protocols/tls.c
+++ b/src/lib/protocols/tls.c
@@ -312,439 +312,440 @@ static void checkTLSSubprotocol(struct ndpi_detection_module_struct *ndpi_struct
 /* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */
 static void processCertificateElements(struct ndpi_detection_module_struct *ndpi_struct,
 				       struct ndpi_flow_struct *flow,
 				       u_int16_t p_offset, u_int16_t certificate_len) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   u_int16_t num_found = 0, i;
   char buffer[64] = { '\0' }, rdnSeqBuf[2048];
   u_int rdn_len = 0;
 
   rdnSeqBuf[0] = '\0';
 
 #ifdef DEBUG_TLS
   printf("[TLS] %s() [offset: %u][certificate_len: %u]\n", __FUNCTION__, p_offset, certificate_len);
 #endif
 
   /* Check after handshake protocol header (5 bytes) and message header (4 bytes) */
   for(i = p_offset; i < certificate_len; i++) {
     /*
        See https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.5.0/com.ibm.mq.sec.doc/q009860_.htm
        for X.509 certificate labels
     */
     if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03)) {
       /* Common Name */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "CN");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "Common Name", buffer);
 #endif
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x06)) {
       /* Country */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "C");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "Country", buffer);
 #endif
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x07)) {
       /* Locality */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "L");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "Locality", buffer);
 #endif
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x08)) {
       /* State or Province */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "ST");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "State or Province", buffer);
 #endif
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0a)) {
       /* Organization Name */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "O");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "Organization Name", buffer);
 #endif
 
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0b)) {
       /* Organization Unit */
       int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), "OU");
       if(rc == -1) break;
 
 #ifdef DEBUG_TLS
       printf("[TLS] %s() [%s][%s: %s]\n", __FUNCTION__, (num_found == 0) ? "Subject" : "Issuer", "Organization Unit", buffer);
 #endif
     } else if((packet->payload[i] == 0x30) && (packet->payload[i+1] == 0x1e) && (packet->payload[i+2] == 0x17)) {
       /* Certificate Validity */
       u_int8_t len = packet->payload[i+3];
       u_int offset = i+4;
 
       if(num_found == 0) {
 	num_found++;
 
 #ifdef DEBUG_TLS
 	printf("[TLS] %s() IssuerDN [%s]\n", __FUNCTION__, rdnSeqBuf);
 #endif
 
 	if(rdn_len && (flow->protos.tls_quic_stun.tls_quic.issuerDN == NULL))
 	  flow->protos.tls_quic_stun.tls_quic.issuerDN = ndpi_strdup(rdnSeqBuf);
 
 	rdn_len = 0; /* Reset buffer */
       }
 
       if((offset+len) < packet->payload_packet_len) {
 	char utcDate[32];
 
 #ifdef DEBUG_TLS
 	u_int j;
 
 	printf("[CERTIFICATE] notBefore [len: %u][", len);
 	for(j=0; j<len; j++) printf("%c", packet->payload[i+4+j]);
 	printf("]\n");
 #endif
 
 	if(len < (sizeof(utcDate)-1)) {
 	  struct tm utc;
 	  utc.tm_isdst = -1; /* Not set by strptime */
 
 	  strncpy(utcDate, (const char*)&packet->payload[i+4], len);
 	  utcDate[len] = '\0';
 
 	  /* 141021000000Z */
 	  if(strptime(utcDate, "%y%m%d%H%M%SZ", &utc) != NULL) {
 	    flow->protos.tls_quic_stun.tls_quic.notBefore = timegm(&utc);
 #ifdef DEBUG_TLS
 	    printf("[CERTIFICATE] notBefore %u [%s]\n",
 		   flow->protos.tls_quic_stun.tls_quic.notBefore, utcDate);
 #endif
 	  }
 	}
 
 	offset += len;
 
 	if((offset+1) < packet->payload_packet_len) {
 	  len = packet->payload[offset+1];
 
 	  offset += 2;
 
 	  if((offset+len) < packet->payload_packet_len) {
 	    u_int32_t time_sec = packet->current_time_ms / 1000;
 #ifdef DEBUG_TLS
 	    u_int j;
 
 	    printf("[CERTIFICATE] notAfter [len: %u][", len);
 	    for(j=0; j<len; j++) printf("%c", packet->payload[offset+j]);
 	    printf("]\n");
 #endif
 
 	    if(len < (sizeof(utcDate)-1)) {
 	      struct tm utc;
 	      utc.tm_isdst = -1; /* Not set by strptime */
 
 	      strncpy(utcDate, (const char*)&packet->payload[offset], len);
 	      utcDate[len] = '\0';
 
 	      /* 141021000000Z */
 	      if(strptime(utcDate, "%y%m%d%H%M%SZ", &utc) != NULL) {
 		flow->protos.tls_quic_stun.tls_quic.notAfter = timegm(&utc);
 #ifdef DEBUG_TLS
 		printf("[CERTIFICATE] notAfter %u [%s]\n",
 		       flow->protos.tls_quic_stun.tls_quic.notAfter, utcDate);
 #endif
 	      }
 	    }
 
 	    if (flow->protos.tls_quic_stun.tls_quic.notBefore > TLS_LIMIT_DATE)
 	      if((flow->protos.tls_quic_stun.tls_quic.notAfter-flow->protos.tls_quic_stun.tls_quic.notBefore) > TLS_THRESHOLD)
 		ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_CERT_VALIDITY_TOO_LONG); /* Certificate validity longer than 13 months*/
 
 	    if((time_sec < flow->protos.tls_quic_stun.tls_quic.notBefore)
 	       || (time_sec > flow->protos.tls_quic_stun.tls_quic.notAfter))
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_CERTIFICATE_EXPIRED); /* Certificate expired */
 	  }
 	}
       }
     } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x1d) && (packet->payload[i+2] == 0x11)) {
       /* Organization OID: 2.5.29.17 (subjectAltName) */
       u_int8_t matched_name = 0;
 
 #ifdef DEBUG_TLS
       printf("******* [TLS] Found subjectAltName\n");
 #endif
 
       i += 3 /* skip the initial patten 55 1D 11 */;
       i++; /* skip the first type, 0x04 == BIT STRING, and jump to it's length */
       if(i < packet->payload_packet_len) {
 	i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip BIT STRING length */
 	if(i < packet->payload_packet_len) {
 	  i += 2; /* skip the second type, 0x30 == SEQUENCE, and jump to it's length */
 	  if(i < packet->payload_packet_len) {
 	    i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip SEQUENCE length */
 	    i++;
 
 	    while(i < packet->payload_packet_len) {
 	      if(packet->payload[i] == 0x82) {
 		if((i < (packet->payload_packet_len - 1))
 		   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {
 		  u_int8_t len = packet->payload[i + 1];
 		  char dNSName[256];
 
 		  i += 2;
 
 		  /* The check "len > sizeof(dNSName) - 1" will be always false. If we add it,
 		     the compiler is smart enough to detect it and throws a warning */
 		  if((len == 0 /* Looks something went wrong */)
-		     || ((i+len) >  packet->payload_packet_len))
+		     || ((i+len) > packet->payload_packet_len))
 		    break;
 
 		  strncpy(dNSName, (const char*)&packet->payload[i], len);
 		  dNSName[len] = '\0';
 
 		  cleanupServerName(dNSName, len);
 
 #if DEBUG_TLS
 		  printf("[TLS] dNSName %s [%s][len: %u][leftover: %d]\n", dNSName,
 			 flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, len,
 			 packet->payload_packet_len-i-len);
 #endif
 		  if (ndpi_is_printable_string(dNSName, len) == 0) {
 		    ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION);
 		  }
 
 		  if(matched_name == 0) {
 		    if(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == '\0')
 		      matched_name = 1;	/* No SNI */
 		    else if (dNSName[0] == '*')
 		    {
 		      char * label = strstr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &dNSName[1]);
 
 		      if (label != NULL)
 		      {
 		        char * first_dot = strchr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, '.');
 
 		        if (first_dot == NULL || first_dot >= label)
 		        {
 		          matched_name = 1;
 		        }
 		      }
 		    }
 		    else if(strcmp(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, dNSName) == 0)
 		      matched_name = 1;
 		  }
 
 		  if(flow->protos.tls_quic_stun.tls_quic.server_names == NULL)
 		    flow->protos.tls_quic_stun.tls_quic.server_names = ndpi_strdup(dNSName),
 		      flow->protos.tls_quic_stun.tls_quic.server_names_len = strlen(dNSName);
 		  else {
 		    u_int16_t dNSName_len = strlen(dNSName);
 		    u_int16_t newstr_len = flow->protos.tls_quic_stun.tls_quic.server_names_len + dNSName_len + 1;
 		    char *newstr = (char*)ndpi_realloc(flow->protos.tls_quic_stun.tls_quic.server_names,
 						       flow->protos.tls_quic_stun.tls_quic.server_names_len+1, newstr_len+1);
 
 		    if(newstr) {
 		      flow->protos.tls_quic_stun.tls_quic.server_names = newstr;
 		      flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len] = ',';
 		      strncpy(&flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len+1],
 			      dNSName, dNSName_len+1);
 		      flow->protos.tls_quic_stun.tls_quic.server_names[newstr_len] = '\0';
 		      flow->protos.tls_quic_stun.tls_quic.server_names_len = newstr_len;
 		    }
 		  }
 
 		  if(!flow->protos.tls_quic_stun.tls_quic.subprotocol_detected)
 		    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))
 		      flow->protos.tls_quic_stun.tls_quic.subprotocol_detected = 1;
 
 		  i += len;
 		} else {
 #if DEBUG_TLS
 		  printf("[TLS] Leftover %u bytes", packet->payload_packet_len - i);
 #endif
 		  break;
 		}
 	      } else {
 		break;
 	      }
 	    } /* while */
 
 	    if(!matched_name)
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */
 	  }
 	}
       }
     }
   }
 
   if(rdn_len && (flow->protos.tls_quic_stun.tls_quic.subjectDN == NULL)) {
     flow->protos.tls_quic_stun.tls_quic.subjectDN = ndpi_strdup(rdnSeqBuf);
 
     if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {
       /* No idea what is happening behind the scenes: let's check the certificate */
       u_int32_t val;
       int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,
 				       rdnSeqBuf, strlen(rdnSeqBuf), &val);
 
       if(rc == 0) {
 	/* Match found */
 	u_int16_t proto_id = (u_int16_t)val;
 	ndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};
 
 	flow->detected_protocol_stack[0] = proto_id,
 	  flow->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;
 
 	flow->category = ndpi_get_proto_category(ndpi_struct, ret);
 	ndpi_check_subprotocol_risk(ndpi_struct, flow, proto_id);
 
 	if(ndpi_struct->tls_cert_cache == NULL)
 	  ndpi_struct->tls_cert_cache = ndpi_lru_cache_init(1024);
 
 	if(ndpi_struct->tls_cert_cache && packet->iph) {
 	  u_int32_t key = packet->iph->daddr + packet->tcp->dest;
 
 	  ndpi_lru_add_to_cache(ndpi_struct->tls_cert_cache, key, proto_id);
 	}
       }
     }
   }
 
   if(flow->protos.tls_quic_stun.tls_quic.subjectDN && flow->protos.tls_quic_stun.tls_quic.issuerDN
      && (!strcmp(flow->protos.tls_quic_stun.tls_quic.subjectDN, flow->protos.tls_quic_stun.tls_quic.issuerDN)))
     ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SELFSIGNED_CERTIFICATE);
 
 #if DEBUG_TLS
   printf("[TLS] %s() SubjectDN [%s]\n", __FUNCTION__, rdnSeqBuf);
 #endif
 }
 
 /* **************************************** */
 
 /* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */
 int processCertificate(struct ndpi_detection_module_struct *ndpi_struct,
 		       struct ndpi_flow_struct *flow) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   int is_dtls = packet->udp ? 1 : 0;
   u_int32_t certificates_length, length = (packet->payload[1] << 16) + (packet->payload[2] << 8) + packet->payload[3];
   u_int32_t certificates_offset = 7 + (is_dtls ? 8 : 0);
   u_int8_t num_certificates_found = 0;
   SHA1_CTX srv_cert_fingerprint_ctx ;
 
 #ifdef DEBUG_TLS
   printf("[TLS] %s() [payload_packet_len=%u][direction: %u][%02X %02X %02X %02X %02X %02X...]\n",
 	 __FUNCTION__, packet->payload_packet_len,
 	 packet->packet_direction,
 	 packet->payload[0], packet->payload[1], packet->payload[2],
 	 packet->payload[3], packet->payload[4], packet->payload[5]);
 #endif
 
-  if((packet->payload_packet_len != (length + 4 + (is_dtls ? 8 : 0))) || (packet->payload[1] != 0x0)) {
+  if((packet->payload_packet_len != (length + 4 + (is_dtls ? 8 : 0))) || (packet->payload[1] != 0x0) ||
+     certificates_offset >= packet->payload_packet_len) {
     ndpi_set_risk(ndpi_struct, flow, NDPI_MALFORMED_PACKET);
     return(-1); /* Invalid length */
   }
 
   certificates_length = (packet->payload[certificates_offset - 3] << 16) +
                         (packet->payload[certificates_offset - 2] << 8) +
                         packet->payload[certificates_offset - 1];
 
   if((packet->payload[certificates_offset - 3] != 0x0) || ((certificates_length+3) != length)) {
     ndpi_set_risk(ndpi_struct, flow, NDPI_MALFORMED_PACKET);
     return(-2); /* Invalid length */
   }
 
   /* Now let's process each individual certificates */
   while(certificates_offset < certificates_length) {
     u_int32_t certificate_len = (packet->payload[certificates_offset] << 16) + (packet->payload[certificates_offset+1] << 8) + packet->payload[certificates_offset+2];
 
     /* Invalid lenght */
     if((certificate_len == 0)
        || (packet->payload[certificates_offset] != 0x0)
        || ((certificates_offset+certificate_len) > (4+certificates_length+(is_dtls ? 8 : 0)))) {
 #ifdef DEBUG_TLS
       printf("[TLS] Invalid length [certificate_len: %u][certificates_offset: %u][%u vs %u]\n",
 	     certificate_len, certificates_offset,
 	     (certificates_offset+certificate_len),
 	     certificates_length);
 #endif
       break;
     }
 
     certificates_offset += 3;
 #ifdef DEBUG_TLS
     printf("[TLS] Processing %u bytes certificate [%02X %02X %02X]\n",
 	   certificate_len,
 	   packet->payload[certificates_offset],
 	   packet->payload[certificates_offset+1],
 	   packet->payload[certificates_offset+2]);
 #endif
 
     if(num_certificates_found++ == 0) /* Dissect only the first certificate that is the one we care */ {
       /* For SHA-1 we take into account only the first certificate and not all of them */
 
       SHA1Init(&srv_cert_fingerprint_ctx);
 
 #ifdef DEBUG_CERTIFICATE_HASH
       {
 	u_int32_t i;
 
 	for(i=0;i<certificate_len;i++)
 	  printf("%02X ", packet->payload[certificates_offset+i]);
 
 	printf("\n");
       }
 #endif
 
       SHA1Update(&srv_cert_fingerprint_ctx,
 		 &packet->payload[certificates_offset],
 		 certificate_len);
 
       SHA1Final(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint, &srv_cert_fingerprint_ctx);
 
       flow->l4.tcp.tls.fingerprint_set = 1;
 
       uint8_t * sha1 = flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint;
       const size_t sha1_siz = sizeof(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint);
       char sha1_str[20 /* sha1_siz */ * 2 + 1];
       static const char hexalnum[] = "0123456789ABCDEF";
       size_t i;
       for (i = 0; i < sha1_siz; ++i) {
         u_int8_t lower = (sha1[i] & 0x0F);
         u_int8_t upper = (sha1[i] & 0xF0) >> 4;
         sha1_str[i*2] = hexalnum[upper];
         sha1_str[i*2 + 1] = hexalnum[lower];
       }
       sha1_str[sha1_siz * 2] = '\0';
 
 #ifdef DEBUG_TLS
       printf("[TLS] SHA-1: %s\n", sha1_str);
 #endif
 
       if (ndpi_struct->malicious_sha1_automa.ac_automa != NULL) {
         u_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_sha1_automa.ac_automa, sha1_str);
 
         if(rc1 > 0)
           ndpi_set_risk(ndpi_struct, flow, NDPI_MALICIOUS_SHA1_CERTIFICATE);
       }
 
       processCertificateElements(ndpi_struct, flow, certificates_offset, certificate_len);
     }
 
     certificates_offset += certificate_len;
   }
 
   if((ndpi_struct->num_tls_blocks_to_follow != 0)
      && (flow->l4.tcp.tls.num_tls_blocks >= ndpi_struct->num_tls_blocks_to_follow)) {
 #ifdef DEBUG_TLS_BLOCKS
     printf("*** [TLS Block] Enough blocks dissected\n");
 #endif
 
     flow->extra_packets_func = NULL; /* We're good now */
   }
 
   return(1);
 }
 
 /* **************************************** */
@@ -974,97 +975,99 @@ static int ndpi_search_tls_tcp(struct ndpi_detection_module_struct *ndpi_struct,
 static int ndpi_search_tls_udp(struct ndpi_detection_module_struct *ndpi_struct,
 			       struct ndpi_flow_struct *flow) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   u_int32_t handshake_len;
   u_int16_t p_len, processed;
   const u_int8_t *p;
   u_int8_t no_dtls = 0, change_cipher_found = 0;
 
 #ifdef DEBUG_TLS
   printf("[TLS] %s()\n", __FUNCTION__);
 #endif
 
   /* Overwriting packet payload */
   p = packet->payload, p_len = packet->payload_packet_len; /* Backup */
 
   /* Split the element in blocks */
   processed = 0;
   while(processed + 13 < p_len) {
     u_int32_t block_len;
     const u_int8_t *block = (const u_int8_t *)&p[processed];
 
     if((block[0] != 0x16 && block[0] != 0x14) || /* Handshake, change-cipher-spec */
        (block[1] != 0xfe) || /* We ignore old DTLS versions */
        ((block[2] != 0xff) && (block[2] != 0xfd))) {
 #ifdef DEBUG_TLS
       printf("[TLS] DTLS invalid block 0x%x or old version 0x%x-0x%x-0x%x\n",
              block[0], block[1], block[2], block[3]);
 #endif
       no_dtls = 1;
       break;
     }
     block_len = ntohs(*((u_int16_t*)&block[11]));
 #ifdef DEBUG_TLS
     printf("[TLS] DTLS block len: %d\n", block_len);
 #endif
     if (block_len == 0 || (processed + block_len + 12 >= p_len)) {
 #ifdef DEBUG_TLS
       printf("[TLS] DTLS invalid block len %d (processed %d, p_len %d)\n",
              block_len, processed, p_len);
 #endif
       no_dtls = 1;
       break;
     }
     /* We process only handshake msgs */
     if(block[0] == 0x16) {
       if (processed + block_len + 13 > p_len) {
 #ifdef DEBUG_TLS
         printf("[TLS] DTLS invalid len %d %d %d\n", processed, block_len, p_len);
 #endif
         no_dtls = 1;
         break;
      }
       /* TODO: handle (certificate) fragments */
-      handshake_len = (block[14] << 16) + (block[15] << 8) + block[16];
-      if((handshake_len + 12) != block_len) {
-#ifdef DEBUG_TLS
-        printf("[TLS] DTLS invalid handshake_len %d, %d)\n",
-               handshake_len, block_len);
-#endif
-        no_dtls = 1;
-        break;
+      if (block_len > 16) {
+        handshake_len = (block[14] << 16) + (block[15] << 8) + block[16];
+        if((handshake_len + 12) != block_len) {
+#ifdef DEBUG_TLS
+          printf("[TLS] DTLS invalid handshake_len %d, %d)\n",
+                 handshake_len, block_len);
+#endif
+          no_dtls = 1;
+          break;
+        }
+        packet->payload = &block[13];
+        packet->payload_packet_len = block_len;
+        processTLSBlock(ndpi_struct, flow);
       }
-      packet->payload = &block[13];
-      packet->payload_packet_len = block_len;
-      processTLSBlock(ndpi_struct, flow);
     } else {
       /* Change-cipher-spec: any subsequent block might be encrypted */
 #ifdef DEBUG_TLS
       printf("[TLS] Change-cipher-spec\n");
 #endif
       change_cipher_found = 1;
       processed += block_len + 13;
       break;
     }
 
     processed += block_len + 13;
   }
   if(processed != p_len) {
 #ifdef DEBUG_TLS
     printf("[TLS] DTLS invalid processed len %d/%d (%d)\n", processed, p_len, change_cipher_found);
 #endif
     if(!change_cipher_found)
       no_dtls = 1;
   }
 
   packet->payload = p;
   packet->payload_packet_len = p_len; /* Restore */
 
   if(no_dtls || change_cipher_found) {
     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
     return(0); /* That's all */
   } else {
     return(1); /* Keep working */
   }
 }
 
 /* **************************************** */
@@ -1213,1059 +1216,1073 @@ static void checkExtensions(struct ndpi_detection_module_struct *ndpi_struct,
 int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,
 			     struct ndpi_flow_struct *flow, uint32_t quic_version) {
   struct ndpi_packet_struct *packet = &ndpi_struct->packet;
   union ja3_info ja3;
   u_int8_t invalid_ja3 = 0;
   u_int16_t tls_version, ja3_str_len;
   char ja3_str[JA3_STR_LEN];
   ndpi_MD5_CTX ctx;
   u_char md5_hash[16];
-  int i;
+  u_int32_t i;
   u_int16_t total_len;
   u_int8_t handshake_type;
   char buffer[64] = { '\0' };
   int is_quic = (quic_version != 0);
   int is_dtls = packet->udp && (!is_quic);
 
 #ifdef DEBUG_TLS
   printf("TLS %s() called\n", __FUNCTION__);
 #endif
 
 
   handshake_type = packet->payload[0];
   total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];
 
   if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))
     return(0); /* Not found */
 
   total_len = packet->payload_packet_len;
 
   /* At least "magic" 3 bytes, null for string end, otherwise no need to waste cpu cycles */
   if(total_len > 4) {
     u_int16_t base_offset    = (!is_dtls) ? 38 : 46;
     u_int16_t version_offset = (!is_dtls) ? 4 : 12;
-    u_int16_t offset = (!is_dtls) ? 38 : 46, extension_len, j;
+    u_int16_t offset = (!is_dtls) ? 38 : 46;
+    u_int16_t j;
+    u_int32_t tot_extension_len;
     u_int8_t  session_id_len =  0;
 
     if((base_offset >= total_len) ||
        (version_offset + 1) >= total_len)
       return 0; /* Not found */
 
     session_id_len = packet->payload[base_offset];
 
 #ifdef DEBUG_TLS
     printf("TLS [len: %u][handshake_type: %02X]\n", packet->payload_packet_len, handshake_type);
 #endif
 
     tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));
 
     if(handshake_type == 0x02 /* Server Hello */) {
-      int i, rc;
+      u_int32_t i;
+      int rc;
 
       ja3.server.num_cipher = 0;
       ja3.server.num_tls_extension = 0;
       ja3.server.num_elliptic_curve_point_format = 0;
       ja3.server.alpn[0] = '\0';
 
       ja3.server.tls_handshake_version = tls_version;
 
 #ifdef DEBUG_TLS
       printf("TLS Server Hello [version: 0x%04X]\n", tls_version);
 #endif
 
       /*
 	The server hello decides about the TLS version of this flow
 	https://networkengineering.stackexchange.com/questions/55752/why-does-wireshark-show-version-tls-1-2-here-instead-of-tls-1-3
       */
       if(packet->udp)
 	offset += session_id_len + 1;
       else {
 	if(tls_version < 0x7F15 /* TLS 1.3 lacks of session id */)
 	  offset += session_id_len+1;
       }
 
       if((offset+3) > packet->payload_packet_len)
 	return(0); /* Not found */
 
       ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));
       if((flow->protos.tls_quic_stun.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)
 	ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_WEAK_CIPHER);
 
       flow->protos.tls_quic_stun.tls_quic.server_cipher = ja3.server.cipher[0];
 
 #ifdef DEBUG_TLS
       printf("TLS [server][session_id_len: %u][cipher: %04X]\n", session_id_len, ja3.server.cipher[0]);
 #endif
 
       offset += 2 + 1;
 
       if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */
-	extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
+	tot_extension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
       else
-	extension_len = 0;
+	tot_extension_len = 0;
 
 #ifdef DEBUG_TLS
       printf("TLS [server][extension_len: %u]\n", extension_len);
 #endif
       offset += 2;
 
-      for(i=0; i<extension_len; ) {
-	u_int16_t extension_id, extension_len;
+      for(i=0; i<tot_extension_len; ) {
+        u_int16_t extension_id;
+        u_int32_t extension_len;
 
 	if((offset+4) > packet->payload_packet_len) break;
 
 	extension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));
 	extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));
+	if (offset+4+extension_len > packet->payload_packet_len) {
+	  break;
+	}
 
 	if(ja3.server.num_tls_extension < MAX_NUM_JA3)
 	  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;
 
 #ifdef DEBUG_TLS
 	printf("TLS [server][extension_id: %u/0x%04X][len: %u]\n",
 	       extension_id, extension_id, extension_len);
 #endif
 	checkExtensions(ndpi_struct, flow, is_dtls, extension_id, extension_len, offset + 4);
 
 	if(extension_id == 43 /* supported versions */) {
 	  if(extension_len >= 2) {
 	    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));
 
 #ifdef DEBUG_TLS
 	    printf("TLS [server] [TLS version: 0x%04X]\n", tls_version);
 #endif
 
 	    flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;
 	  }
-	} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */) {
+	} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */ &&
+	          offset + 6 < packet->payload_packet_len) {
 	  u_int16_t s_offset = offset+4;
 	  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 	  char alpn_str[256];
 	  u_int8_t alpn_str_len = 0, i;
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
 #endif
 	  s_offset += 2;
 	  tot_alpn_len += s_offset;
 
+	  if (tot_alpn_len > packet->payload_packet_len)
+	    return 0;
+
 	  while(s_offset < tot_alpn_len && s_offset < total_len) {
 	    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];
 
 	    if((s_offset + alpn_len) <= tot_alpn_len) {
 #ifdef DEBUG_TLS
 	      printf("Server TLS [ALPN: %u]\n", alpn_len);
 #endif
 
 	      if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
 	        if(alpn_str_len > 0) {
 	          alpn_str[alpn_str_len] = ',';
 	          alpn_str_len++;
 	        }
 
 	        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
 	        {
 	          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
 	        }
 
 	        s_offset += alpn_len, alpn_str_len += alpn_len;;
 	      } else {
 	        ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
 	        break;
 	      }
 	    } else {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_UNCOMMON_ALPN);
 	      break;
 	    }
 	  } /* while */
 
 	  alpn_str[alpn_str_len] = '\0';
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
 #endif
 	  if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)
 	    flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);
 
 	  if(flow->protos.tls_quic_stun.tls_quic.alpn != NULL)
 	    tlsCheckUncommonALPN(ndpi_struct, flow);
 
 	  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), "%s", alpn_str);
 
 	  /* Replace , with - as in JA3 */
 	  for(i=0; ja3.server.alpn[i] != '\0'; i++)
 	    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';
 	} else if(extension_id == 11 /* ec_point_formats groups */) {
 	  u_int16_t s_offset = offset+4 + 1;
 
 #ifdef DEBUG_TLS
 	  printf("Server TLS [EllipticCurveFormat: len=%u]\n", extension_len);
 #endif
 	  if((s_offset+extension_len-1) <= total_len) {
-	    for(i=0; i<extension_len-1; i++) {
+	    for(i=0; i<extension_len-1 && s_offset+i<packet->payload_packet_len; i++) {
 	      u_int8_t s_group = packet->payload[s_offset+i];
 
 #ifdef DEBUG_TLS
 	      printf("Server TLS [EllipticCurveFormat: %u]\n", s_group);
 #endif
 
 	      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)
 		ja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;
 	      else {
 		invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		printf("Server TLS Invalid num elliptic %u\n", ja3.server.num_elliptic_curve_point_format);
 #endif
 	      }
 	    }
 	  } else {
 	    invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	    printf("Server TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
 #endif
 	  }
 	}
 
 	i += 4 + extension_len, offset += 4 + extension_len;
       } /* for */
 
       ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.server.tls_handshake_version);
 
       for(i=0; (i<ja3.server.num_cipher) && (JA3_STR_LEN > ja3_str_len); i++) {
 	rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.server.cipher[i]);
 
 	if(rc <= 0) break; else ja3_str_len += rc;
       }
 
       if(JA3_STR_LEN > ja3_str_len) {
 	rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	if(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;
       }
 
       /* ********** */
 
       for(i=0; (i<ja3.server.num_tls_extension) && (JA3_STR_LEN > ja3_str_len); i++) {
 	int rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u", (i > 0) ? "-" : "", ja3.server.tls_extension[i]);
 
 	if(rc <= 0) break; else ja3_str_len += rc;
       }
 
       if(ndpi_struct->enable_ja3_plus) {
 	for(i=0; (i<ja3.server.num_elliptic_curve_point_format) && (JA3_STR_LEN > ja3_str_len); i++) {
 	  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			(i > 0) ? "-" : "", ja3.server.elliptic_curve_point_format[i]);
 	  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	}
 
 	if((ja3.server.alpn[0] != '\0') && (JA3_STR_LEN > ja3_str_len)) {
 	  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",%s", ja3.server.alpn);
 	  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 	}
 
 #ifdef DEBUG_TLS
 	printf("[JA3+] Server: %s \n", ja3_str);
 #endif
       } else {
 #ifdef DEBUG_TLS
 	printf("[JA3] Server: %s \n", ja3_str);
 #endif
       }
 
       ndpi_MD5Init(&ctx);
       ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));
       ndpi_MD5Final(md5_hash, &ctx);
 
       for(i=0, j=0; i<16; i++) {
 	int rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_server[j],
 			  sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_server)-j, "%02x", md5_hash[i]);
 	if(rc <= 0) break; else j += rc;
       }
 
 #ifdef DEBUG_TLS
       printf("[JA3] Server: %s \n", flow->protos.tls_quic_stun.tls_quic.ja3_server);
 #endif
     } else if(handshake_type == 0x01 /* Client Hello */) {
       u_int16_t cipher_len, cipher_offset;
       u_int8_t cookie_len = 0;
 
       ja3.client.num_cipher = 0;
       ja3.client.num_tls_extension = 0;
       ja3.client.num_elliptic_curve = 0;
       ja3.client.num_elliptic_curve_point_format = 0;
       ja3.client.signature_algorithms[0] = '\0';
       ja3.client.supported_versions[0] = '\0';
       ja3.client.alpn[0] = '\0';
 
       flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;
       if(flow->protos.tls_quic_stun.tls_quic.ssl_version < 0x0303) /* < TLSv1.2 */
 	ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_OBSOLETE_VERSION);
 
       if((session_id_len+base_offset+3) > packet->payload_packet_len)
 	return(0); /* Not found */
 
       if(!is_dtls) {
 	cipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);
 	cipher_offset = base_offset + session_id_len + 3;
       } else {
 	cookie_len = packet->payload[base_offset+session_id_len+1];
 #ifdef DEBUG_TLS
 	printf("[JA3] Client: DTLS cookie len %d\n", cookie_len);
 #endif
 	if((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)
 	  return(0); /* Not found */
 	cipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));
 	cipher_offset = base_offset + session_id_len + cookie_len + 4;
       }
 
 #ifdef DEBUG_TLS
       printf("Client TLS [client cipher_len: %u][tls_version: 0x%04X]\n", cipher_len, tls_version);
 #endif
 
       if((cipher_offset+cipher_len) <= total_len) {
 	u_int8_t safari_ciphers = 0, chrome_ciphers = 0, this_is_not_safari = 0, looks_like_safari_on_big_sur = 0;
 
 	for(i=0; i<cipher_len;) {
 	  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];
 	  u_int16_t cipher_id = ntohs(*id);
 
-	  if(packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1] /* Skip Grease */) {
+	  if(cipher_offset+i+1 < packet->payload_packet_len &&
+	     packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1] /* Skip Grease */) {
 	    /*
 	      Skip GREASE [https://tools.ietf.org/id/draft-ietf-tls-grease-01.html]
 	      https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967
 	    */
 
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [non-GREASE cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    if(ja3.client.num_cipher < MAX_NUM_JA3)
 	      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;
 	    else {
 	      invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	      printf("Client TLS Invalid cipher %u\n", ja3.client.num_cipher);
 #endif
 	    }
 
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    switch(cipher_id) {
 	    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
 	      safari_ciphers++;
 	      break;
 
 	    case TLS_AES_128_GCM_SHA256:
 	    case TLS_AES_256_GCM_SHA384:
 	    case TLS_CHACHA20_POLY1305_SHA256:
 	      chrome_ciphers++;
 	      break;
 
 	    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:
 	    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
 	    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:
 	    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
 	    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
 	    case TLS_RSA_WITH_AES_128_CBC_SHA:
 	    case TLS_RSA_WITH_AES_256_CBC_SHA:
 	    case TLS_RSA_WITH_AES_128_GCM_SHA256:
 	    case TLS_RSA_WITH_AES_256_GCM_SHA384:
 	      safari_ciphers++, chrome_ciphers++;
 	      break;
 
 	    case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
 	      looks_like_safari_on_big_sur = 1;
 	      break;
 	    }
 	  } else {
 #if defined(DEBUG_TLS) || defined(DEBUG_HEURISTIC)
 	    printf("Client TLS [GREASE cipher suite: %u/0x%04X] [%d/%u]\n", cipher_id, cipher_id, i, cipher_len);
 #endif
 
 	    this_is_not_safari = 1; /* NOTE: BugSur and up have grease support */
 	  }
 
 	  i += 2;
 	} /* for */
 
 	/* NOTE:
 	   we do not check for duplicates as with signatures because
 	   this is time consuming and we want to avoid overhead whem possible
 	*/
 	if(this_is_not_safari)
 	  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls = 0;
 	else if((safari_ciphers == 12) || (this_is_not_safari && looks_like_safari_on_big_sur))
 	  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls = 1;
 
 	if(chrome_ciphers == 13)
 	  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls = 1;
 
 	/* Note that both Safari and Chrome can overlap */
 #ifdef DEBUG_HEURISTIC
 	printf("[CIPHERS] [is_chrome_tls: %u (%u)][is_safari_tls: %u (%u)][this_is_not_safari: %u]\n",
 	       flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls,
 	       chrome_ciphers,
 	       flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls,
 	       safari_ciphers,
 	       this_is_not_safari);
 #endif
       } else {
 	invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 	printf("Client TLS Invalid len %u vs %u\n", (cipher_offset+cipher_len), total_len);
 #endif
       }
 
       offset = base_offset + session_id_len + cookie_len + cipher_len + 2;
       offset += (!is_dtls) ? 1 : 2;
 
       if(offset < total_len) {
 	u_int16_t compression_len;
 	u_int16_t extensions_len;
 
 	compression_len = packet->payload[offset];
 	offset++;
 
 #ifdef DEBUG_TLS
 	printf("Client TLS [compression_len: %u]\n", compression_len);
 #endif
 
 	// offset += compression_len + 3;
 	offset += compression_len;
 
 	if(offset+1 < total_len) {
 	  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));
 	  offset += 2;
 
 #ifdef DEBUG_TLS
 	  printf("Client TLS [extensions_len: %u]\n", extensions_len);
 #endif
 
 	  if((extensions_len+offset) <= total_len) {
 	    /* Move to the first extension
 	       Type is u_int to avoid possible overflow on extension_len addition */
 	    u_int extension_offset = 0;
 	    u_int32_t j;
 
 	    while(extension_offset < extensions_len &&
 		  offset+extension_offset+4 <= total_len) {
 	      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;
 
 
 	      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
 	      extension_offset += 2;
 
 	      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));
 	      extension_offset += 2;
 
 #ifdef DEBUG_TLS
 	      printf("Client TLS [extension_id: %u][extension_len: %u]\n", extension_id, extension_len);
 #endif
 	      checkExtensions(ndpi_struct, flow, is_dtls,
 			      extension_id, extension_len, offset + extension_offset);
 
 	      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {
 		/* Skip GREASE */
 
 		if(ja3.client.num_tls_extension < MAX_NUM_JA3)
 		  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;
 		else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid extensions %u\n", ja3.client.num_tls_extension);
 #endif
 		}
 	      }
 
 	      if(extension_id == 0 /* server name */) {
 		u_int16_t len;
 
 #ifdef DEBUG_TLS
 		printf("[TLS] Extensions: found server name\n");
 #endif
 		if((offset+extension_offset+4) < packet->payload_packet_len) {
 
 		  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];
 		  len = (u_int)ndpi_min(len, sizeof(buffer)-1);
 
 		  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {
 		    strncpy(buffer, (char*)&packet->payload[offset+extension_offset+5], len);
 		    buffer[len] = '\0';
 
 		    cleanupServerName(buffer, sizeof(buffer));
 
 		    snprintf(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,
 			     sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),
 			     "%s", buffer);
 #ifdef DEBUG_TLS
 		    printf("[TLS] SNI: [%s]\n", buffer);
 #endif
 		    if (ndpi_is_printable_string(buffer, len) == 0)
 		    {
 		       ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_EXTENSION);
 		    }
 
 		    if(!is_quic) {
 		      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, buffer, strlen(buffer)))
 		        flow->protos.tls_quic_stun.tls_quic.subprotocol_detected = 1;
 		    } else {
 		      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, buffer, strlen(buffer)))
 		        flow->protos.tls_quic_stun.tls_quic.subprotocol_detected = 1;
 		    }
 
 		    if(ndpi_check_dga_name(ndpi_struct, flow,
 					   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, 1)) {
 		      char *sni = flow->protos.tls_quic_stun.tls_quic.client_requested_server_name;
 		      int len = strlen(sni);
 
 #ifdef DEBUG_TLS
 		      printf("[TLS] SNI: (DGA) [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
 #endif
 
 		      if((len >= 4)
 		         /* Check if it ends in .com or .net */
 		         && ((strcmp(&sni[len-4], ".com") == 0) || (strcmp(&sni[len-4], ".net") == 0))
 		         && (strncmp(sni, "www.", 4) == 0)) /* Not starting with www.... */
 		        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);
 		    } else {
 #ifdef DEBUG_TLS
 		      printf("[TLS] SNI: (NO DGA) [%s]\n", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);
 #endif
 		    }
 		  } else {
 #ifdef DEBUG_TLS
 		    printf("[TLS] Extensions server len too short: %u vs %u\n",
 			   offset+extension_offset+5+len,
 			   packet->payload_packet_len);
 #endif
 		  }
 		}
 	      } else if(extension_id == 10 /* supported groups */) {
 		u_int16_t s_offset = offset+extension_offset + 2;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [EllipticCurveGroups: len=%u]\n", extension_len);
 #endif
 
 		if((s_offset+extension_len-2) <= total_len) {
-		  for(i=0; i<extension_len-2;) {
+		  for(int i=0; i<extension_len-2 && s_offset + i + 1 < total_len; i += 2) {
 		    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [EllipticCurve: %u/0x%04X]\n", s_group, s_group);
 #endif
 		    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {
 		      /* Skip GREASE */
 		      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)
 			ja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;
 		      else {
 			invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 			printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve);
 #endif
 		      }
 		    }
-
-		    i += 2;
 		  }
 		} else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid len %u vs %u\n", (s_offset+extension_len-1), total_len);
 #endif
 		}
 	      } else if(extension_id == 11 /* ec_point_formats groups */) {
 		u_int16_t s_offset = offset+extension_offset + 1;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [EllipticCurveFormat: len=%u]\n", extension_len);
 #endif
 		if((s_offset+extension_len-1) <= total_len) {
-		  for(i=0; i<extension_len-1; i++) {
+		  for(int i=0; i<extension_len-1 && s_offset+i < total_len; i++) {
 		    u_int8_t s_group = packet->payload[s_offset+i];
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [EllipticCurveFormat: %u]\n", s_group);
 #endif
 
 		    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)
 		      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;
 		    else {
 		      invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		      printf("Client TLS Invalid num elliptic %u\n", ja3.client.num_elliptic_curve_point_format);
 #endif
 		    }
 		  }
 		} else {
 		  invalid_ja3 = 1;
 #ifdef DEBUG_TLS
 		  printf("Client TLS Invalid len %u vs %u\n", s_offset+extension_len, total_len);
 #endif
 		}
 	      } else if(extension_id == 13 /* signature algorithms */) {
-		u_int16_t s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0,
+		int s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0,
 		  duplicate_found = 0, last_signature = 0;
 		u_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\n", extension_len, tot_signature_algorithms_len);
 #endif
 
 		s_offset += 2;
 		tot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);
 
 #ifdef TLS_HANDLE_SIGNATURE_ALGORITMS
 		flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);
 
 		memcpy(flow->protos.tls_quic_stun.tls_quic.client_signature_algorithms,
 		       &packet->payload[s_offset], 2 /* 16 bit */*flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms);
 #endif
 
-		for(i=0; i<tot_signature_algorithms_len; i++) {
+		for(i=0; i<tot_signature_algorithms_len && s_offset+i<total_len; i++) {
 		  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, "%02X", packet->payload[s_offset+i]);
 
 		  if(rc < 0) break;
 		}
 
-		for(i=0; i<tot_signature_algorithms_len; i+=2) {
+		for(i=0; i<tot_signature_algorithms_len && s_offset + (int)i + 2 < packet->payload_packet_len; i+=2) {
 		  u_int16_t signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));
 
 		  if(last_signature == signature_algo) {
 		    /* Consecutive duplication */
 		    duplicate_found = 1;
 		    continue;
 		  } else {
 		    /* Check for other duplications */
 		    u_int all_ok = 1;
-		    int j;
+		    u_int32_t j;
 
 		    for(j=0; j<tot_signature_algorithms_len; j+=2) {
-		      if(j != i) {
+		      if(j != i && s_offset + (int)j + 2 < packet->payload_packet_len) {
 			u_int16_t j_signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));
 
 			if((signature_algo == j_signature_algo)
 			   && (i < j) /* Don't skip both of them */) {
 #ifdef DEBUG_HEURISTIC
 			  printf("[SIGNATURE] [TLS Signature Algorithm] Skipping duplicate 0x%04X\n", signature_algo);
 #endif
 
 			  duplicate_found = 1, all_ok = 0;
 			  break;
 			}
 		      }
 		    }
 
 		    if(!all_ok)
 		      continue;
 		  }
 
 		  last_signature = signature_algo;
 
 #ifdef DEBUG_HEURISTIC
 		  printf("[SIGNATURE] [TLS Signature Algorithm] 0x%04X\n", signature_algo);
 #endif
 		  switch(signature_algo) {
 		  case ECDSA_SECP521R1_SHA512:
 		    flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_firefox_tls = 1;
 		    break;
 
 		  case ECDSA_SECP256R1_SHA256:
 		  case ECDSA_SECP384R1_SHA384:
 		  case RSA_PKCS1_SHA256:
 		  case RSA_PKCS1_SHA384:
 		  case RSA_PKCS1_SHA512:
 		  case RSA_PSS_RSAE_SHA256:
 		  case RSA_PSS_RSAE_SHA384:
 		  case RSA_PSS_RSAE_SHA512:
 		    chrome_signature_algorithms++, safari_signature_algorithms++;
 #ifdef DEBUG_HEURISTIC
 		    printf("[SIGNATURE] [Chrome/Safari] Found 0x%04X [chrome: %u][safari: %u]\n",
 			   signature_algo, chrome_signature_algorithms, safari_signature_algorithms);
 #endif
 
 		    break;
 		  }
 		}
 
 #ifdef DEBUG_HEURISTIC
 		printf("[SIGNATURE] [safari_signature_algorithms: %u][chrome_signature_algorithms: %u]\n",
 		       safari_signature_algorithms, chrome_signature_algorithms);
 #endif
 
 		if(flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_firefox_tls)
 		  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls = 0,
 		    flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		if(safari_signature_algorithms != 8)
 		   flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls = 0;
 
 		if((chrome_signature_algorithms != 8) || duplicate_found)
 		   flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		/* Avoid Chrome and Safari overlaps, thing that cannot happen with Firefox */
 		if(flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls)
 		  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls = 0;
 
 		if((flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls == 0)
 		   && duplicate_found)
 		  flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls = 1; /* Safari */
 
 #ifdef DEBUG_HEURISTIC
 		printf("[SIGNATURE] [is_firefox_tls: %u][is_chrome_tls: %u][is_safari_tls: %u][duplicate_found: %u]\n",
 		       flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_firefox_tls,
 		       flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_chrome_tls,
 		       flow->protos.tls_quic_stun.tls_quic.browser_heuristics.is_safari_tls,
 		       duplicate_found);
 #endif
 
-		if (i >= tot_signature_algorithms_len) {
+		if (i > 0 && i >= tot_signature_algorithms_len) {
 		  ja3.client.signature_algorithms[i*2 - 1] = '\0';
 		} else {
 		  ja3.client.signature_algorithms[i*2] = '\0';
 		}
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [SIGNATURE_ALGORITHMS: %s]\n", ja3.client.signature_algorithms);
 #endif
-	      } else if(extension_id == 16 /* application_layer_protocol_negotiation */) {
+	      } else if(extension_id == 16 /* application_layer_protocol_negotiation */ &&
+	                offset+extension_offset < total_len) {
 		u_int16_t s_offset = offset+extension_offset;
 		u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		char alpn_str[256];
 		u_int8_t alpn_str_len = 0, i;
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [ALPN: block_len=%u/len=%u]\n", extension_len, tot_alpn_len);
 #endif
 		s_offset += 2;
 		tot_alpn_len += s_offset;
 
 		while(s_offset < tot_alpn_len && s_offset < total_len) {
 		  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];
 
 		  if((s_offset + alpn_len) <= tot_alpn_len &&
 		     (s_offset + alpn_len) <= total_len) {
 #ifdef DEBUG_TLS
 		    printf("Client TLS [ALPN: %u]\n", alpn_len);
 #endif
 
 		    if(((uint32_t)alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {
 		      if(alpn_str_len > 0) {
 			alpn_str[alpn_str_len] = ',';
 			alpn_str_len++;
 		      }
 
 		      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)
 			alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];
 
 		      s_offset += alpn_len, alpn_str_len += alpn_len;;
 		    } else
 		      break;
 		  } else
 		    break;
 		} /* while */
 
 		alpn_str[alpn_str_len] = '\0';
 
 #ifdef DEBUG_TLS
 		printf("Client TLS [ALPN: %s][len: %u]\n", alpn_str, alpn_str_len);
 #endif
 		if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)
 		  flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);
 
 		snprintf(ja3.client.alpn, sizeof(ja3.client.alpn), "%s", alpn_str);
 
 		/* Replace , with - as in JA3 */
 		for(i=0; ja3.client.alpn[i] != '\0'; i++)
 		  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';
 
 	      } else if(extension_id == 43 /* supported versions */) {
 		u_int16_t s_offset = offset+extension_offset;
 		u_int8_t version_len = packet->payload[s_offset];
 		char version_str[256];
 		size_t version_str_len = 0;
 		version_str[0] = 0;
 #ifdef DEBUG_TLS
 		printf("Client TLS [TLS version len: %u]\n", version_len);
 #endif
 
 		if(version_len == (extension_len-1)) {
 		  u_int8_t j;
 		  u_int16_t supported_versions_offset = 0;
 
 		  s_offset++;
 
 		  // careful not to overflow and loop forever with u_int8_t
-		  for(j=0; j+1<version_len; j += 2) {
+		  for(j=0; j+1<version_len && s_offset + j + 1 < packet->payload_packet_len; j += 2) {
 		    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));
 		    u_int8_t unknown_tls_version;
 
 #ifdef DEBUG_TLS
 		    printf("Client TLS [TLS version: %s/0x%04X]\n",
 			   ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version), tls_version);
 #endif
 
 		    if((version_str_len+8) < sizeof(version_str)) {
 		      int rc = snprintf(&version_str[version_str_len],
 					sizeof(version_str) - version_str_len, "%s%s",
 					(version_str_len > 0) ? "," : "",
 					ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version));
 		      if(rc <= 0)
 			break;
 		      else
 			version_str_len += rc;
 
 		      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],
 				    sizeof(ja3.client.supported_versions)-supported_versions_offset,
 				    "%s%04X", (j > 0) ? "-" : "", tls_version);
 
 		      if(rc > 0)
 			supported_versions_offset += rc;
 		    }
 		  }
 
 #ifdef DEBUG_TLS
 		  printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
 #endif
 
 		  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions == NULL)
 		    flow->protos.tls_quic_stun.tls_quic.tls_supported_versions = ndpi_strdup(version_str);
 		}
 	      } else if(extension_id == 65486 /* encrypted server name */) {
 		/*
 		   - https://tools.ietf.org/html/draft-ietf-tls-esni-06
 		   - https://blog.cloudflare.com/encrypted-sni/
 		*/
-		u_int16_t e_offset = offset+extension_offset;
-		u_int16_t initial_offset = e_offset;
-		u_int16_t e_sni_len, cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));
+		int e_offset = offset+extension_offset;
+		int e_sni_len;
+		int initial_offset = e_offset;
+		u_int16_t cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));
 
 		flow->protos.tls_quic_stun.tls_quic.encrypted_sni.cipher_suite = cipher_suite;
 
 		e_offset += 2; /* Cipher suite len */
 
 		/* Key Share Entry */
 		e_offset += 2; /* Group */
-		e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */
+		if (e_offset + 2 < packet->payload_packet_len) {
+		e_offset += ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */
 
 		if((e_offset+4) < packet->payload_packet_len) {
 		  /* Record Digest */
 		  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */
 
 		  if((e_offset+4) < packet->payload_packet_len) {
 		    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));
 		    e_offset += 2;
 
-		    if((e_offset+e_sni_len-extension_len-initial_offset) >= 0 &&
+		    if((e_offset+e_sni_len-(int)extension_len-initial_offset) >= 0 &&
 		        e_offset+e_sni_len < packet->payload_packet_len) {
 #ifdef DEBUG_ENCRYPTED_SNI
 		      printf("Client TLS [Encrypted Server Name len: %u]\n", e_sni_len);
 #endif
 
 		      if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) {
 			flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);
 
 			if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni) {
 			  u_int16_t i, off;
 
 			  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {
 			    int rc = sprintf(&flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off], "%02X", packet->payload[i] & 0XFF);
 
 			    if(rc <= 0) {
 			      flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off] = '\0';
 			      break;
 			    } else
 			      off += rc;
 			  }
 			}
 		      }
 		    }
 		  }
 		}
+		}
 	      } else if(extension_id == 65445 || /* QUIC transport parameters (drafts version) */
 		        extension_id == 57) { /* QUIC transport parameters (final version) */
 		u_int16_t s_offset = offset+extension_offset;
 		uint16_t final_offset;
 		int using_var_int = is_version_with_var_int_transport_params(quic_version);
 
 		if(!using_var_int) {
 		  if(s_offset+1 >= total_len) {
 		    final_offset = 0; /* Force skipping extension */
 		  } else {
 		    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		    s_offset += 2;
 	            final_offset = MIN(total_len, s_offset + seq_len);
 		  }
 		} else {
 	          final_offset = MIN(total_len, s_offset + extension_len);
 		}
 
 		while(s_offset < final_offset) {
 		  u_int64_t param_type, param_len;
 
                   if(!using_var_int) {
 		    if(s_offset+3 >= final_offset)
 		      break;
 		    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));
 		    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));
 		    s_offset += 4;
 		  } else {
 		    if(s_offset >= final_offset ||
 		       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)
 		      break;
 		    s_offset += quic_len(&packet->payload[s_offset], &param_type);
 
 		    if(s_offset >= final_offset ||
 		       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)
 		      break;
 		    s_offset += quic_len(&packet->payload[s_offset], &param_len);
 		  }
 
 #ifdef DEBUG_TLS
 		  printf("Client TLS [QUIC TP: Param 0x%x Len %d]\n", (int)param_type, (int)param_len);
 #endif
 		  if(s_offset+param_len > final_offset)
 		    break;
 
 		  if(param_type==0x3129) {
 #ifdef DEBUG_TLS
 		      printf("UA [%.*s]\n", (int)param_len, &packet->payload[s_offset]);
 #endif
 		      http_process_user_agent(ndpi_struct, flow,
 					      &packet->payload[s_offset], param_len);
 		      break;
 		  }
 		  s_offset += param_len;
 		}
 	      }
 
 	      extension_offset += extension_len; /* Move to the next extension */
 
 #ifdef DEBUG_TLS
 	      printf("Client TLS [extension_offset/len: %u/%u]\n", extension_offset, extension_len);
 #endif
 	    } /* while */
 
 	    if(!invalid_ja3) {
 	      int rc;
 
 	    compute_ja3c:
 	      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, "%u,", ja3.client.tls_handshake_version);
 
 	      for(i=0; i<ja3.client.num_cipher; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.cipher[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      /* ********** */
 
 	      for(i=0; i<ja3.client.num_tls_extension; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.tls_extension[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      /* ********** */
 
 	      for(i=0; i<ja3.client.num_elliptic_curve; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.elliptic_curve[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, ",");
 	      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 
 	      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, "%s%u",
 			      (i > 0) ? "-" : "", ja3.client.elliptic_curve_point_format[i]);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;
 	      }
 
 	      if(ndpi_struct->enable_ja3_plus) {
 		rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len,
 			      ",%s,%s,%s", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);
 		if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;
 	      }
 
 #ifdef DEBUG_JA3C
 	      printf("[JA3+] Client: %s \n", ja3_str);
 #endif
 
 	      ndpi_MD5Init(&ctx);
 	      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));
 	      ndpi_MD5Final(md5_hash, &ctx);
 
 	      for(i=0, j=0; i<16; i++) {
 		rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_client[j],
 			      sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_client)-j, "%02x",
 			      md5_hash[i]);
 		if(rc > 0) j += rc; else break;
 	      }
 
 #ifdef DEBUG_JA3C
 	      printf("[JA3] Client: %s \n", flow->protos.tls_quic_stun.tls_quic.ja3_client);
 #endif
 
 	      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {
 		u_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,
 						  flow->protos.tls_quic_stun.tls_quic.ja3_client);
 
 		if(rc1 > 0)
 		  ndpi_set_risk(ndpi_struct, flow, NDPI_MALICIOUS_JA3);
 	      }
 	    }
 
 	    /* Before returning to the caller we need to make a final check */
 	    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */
 	       && (flow->protos.tls_quic_stun.tls_quic.alpn == NULL) /* No ALPN */) {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_NOT_CARRYING_HTTPS);
 	    }
 
 	    /* Suspicious Domain Fronting:
 	       https://github.com/SixGenInc/Noctilucent/blob/master/docs/ */
 	    if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni &&
 	       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\0') {
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);
 	    }
 
 	    /* Add check for missing SNI */
 	    if((flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == 0)
 	       && (flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */
 	       && (flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */
 	       ) {
 	      /* This is a bit suspicious */
 	      ndpi_set_risk(ndpi_struct, flow, NDPI_TLS_MISSING_SNI);
 	    }
 
 	    return(2 /* Client Certificate */);
 	  } else {
 #ifdef DEBUG_TLS
 	    printf("[TLS] Client: too short [%u vs %u]\n",
 		   (extensions_len+offset), total_len);
 #endif
 	  }
 	} else if(offset == total_len) {
 	  /* TLS does not have extensions etc */
 	  goto compute_ja3c;
 	}
       } else {
 #ifdef DEBUG_TLS
 	printf("[JA3] Client: invalid length detected\n");
 #endif
       }
     }
   }
 
   return(0); /* Not found */
 }
 
 /* **************************************** */
diff --git a/tests/do.sh.in b/tests/do.sh.in
index 36b83b12..d04b483b 100755
--- a/tests/do.sh.in
+++ b/tests/do.sh.in
@@ -3,6 +3,9 @@
 cd "$(dirname "${0}")"
 
 FUZZY_TESTING_ENABLED=@BUILD_FUZZTARGETS@
+if [ "$NDPI_DISABLE_FUZZY" = "1" ]; then
+   FUZZY_TESTING_ENABLED=0
+fi
 
 #Remember: valgrind and *SAN are incompatible!
 VALGRIND=""
diff --git a/tests/pcap/fuzz-2021-10-13.pcap b/tests/pcap/fuzz-2021-10-13.pcap
new file mode 100644
index 00000000..75177539
Binary files /dev/null and b/tests/pcap/fuzz-2021-10-13.pcap differ
diff --git a/tests/result/fuzz-2021-10-13.pcap.out b/tests/result/fuzz-2021-10-13.pcap.out
new file mode 100644
index 00000000..e0d6e4c9
--- /dev/null
+++ b/tests/result/fuzz-2021-10-13.pcap.out
@@ -0,0 +1,12 @@
+Guessed flow protos:	1
+
+DPI Packets (TCP):	1	(1.00 pkts/flow)
+
+TLS	1	197	1
+
+JA3 Host Stats: 
+		 IP Address                  	 # JA3C     
+	1	 3400:3a30:3035:2f75:706c:6f32:643f:6c3d 	 1      
+
+
+	1	TCP [3400:3a30:3035:2f75:706c:6f32:643f:6c3d]:44288 -> [302e::3d00::8001]:0 [proto: 91/TLS][Encrypted][cat: Web/5][1 pkts/197 bytes -> 0 pkts/0 bytes][Goodput ratio: 75/0][< 1 sec][Risk: ** Known protocol on non standard port **** Obsolete TLS version (older than 1.2) **** TLS suspicious extension **][Risk Score: 160][TLS (0030)][JA3C: 7fd749763364ca3fe45ec98917f981f6][PLAIN TEXT (005/uplo2)][Plen Bins: 0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
