commit 2a9a4de21ea7f5d15314da8ee5f27feebf239655
Author: Alex Tutubalin <lexa@lexa.ru>
Date:   Fri Oct 22 08:33:28 2021 +0300

    Snapshot 202110

diff --git a/Changelog.txt b/Changelog.txt
index 721ed030..ab247dea 100644
--- a/Changelog.txt
+++ b/Changelog.txt
@@ -1,202 +1,350 @@
+2021-10-22  Alex Tutubalin <lexa@lexa.ru>
+  
+   == LibRaw snapshot 202110 ==
+   * Camera Format support:
+    - Sony Lossless compressed support
+    - Panasonic v6/12 bit
+ 
+   * Camera support:
+    DJI Mavic Air 2S
+    Fujifilm GFX 50S II;  GFX 100S, X-E4
+    GoPro HERO9, HERO10 (if compiled w/ USE_GPR_SDK)
+    Nikon Z fc
+    Panasonic GH5 Mark II
+    Pentax K3 Mark III
+    Olympus E-P7
+    Ricoh GR IIIx
+    Sony A1, A7R-IIIA (ILCE-7RM3A), A7R-IVA (ILCE-7RM4A), ZV-E10
+    Canon EOS M50 Mark II was supported but not listed in camera list
+
+    Multiple phones tested and added to cameralist.cpp
+
+   * Support for RaspberryPi HQ camera (if compiled w/  USE_6BY9RPI)
+
+   * Improved support for RPi V1/V2 cameras:
+     - white balance data extraction
+     - color matrix extracted to imgdata.color.cmatrix to use with
+       use_camera_matrix.
+     - full-size thumbnail/preview support for JPEG+RAW files (raspistill -r)
+
+  == API-ABI changes ==
+
+  * (INCOMPATIBILITY WITH OLDER VERSIONS!!!) 
+    imgdata.params.shot_select moved to imgdata.rawparams.shot_select
+     (because this is decode-time option, not postprocessing option)
+
+  * libraw_open_bayer(...) added to C-API
+
+  * imgdata.makernotes.canon: separate SensorLeftBorder,SensorTopBorder....
+    (and many other datafields) are united in libraw_area_t (rectangle)
+    groups for crop areas and optical black areas.
+
+  * Additional fields in libraw_internal_data.unpacker_data:
+    - INT64: exif_offset: base offset of 1st EXIF IFD in file
+    - INT64: ifd0_offset: base offset of 1st TIFF IFD (IFD0) in file
+    - unsigned cr3_exif_length, cr3_ifd0_lenght : CR3-specific length of
+     exif and ifd0 sections.
+
+  *  imgdata.sizes.raw_inset_crop rearranged:
+     now it is imgdata.sizes.raw_inset_crops[2]:
+     - item at [0] is the same as imgdatra.sizes.raw_inset_crop in previous 
+      versions
+     - item at [1] is 'user crop', in particular:
+       -- set by DNG  DefaultUserCrop tag
+       -- or set via raw aspect ratio tags (e.g. 16:9 aspect on Fujifilm cameras)
+          raw_inset_crops[1] is filled only if aspect ratio tags provides different
+          aspect ratio compared to raw_inset_crops[0].
+
+   There are no flags to check if raw_inset_crops[Nth] is filled; to see if it is filled check 
+   the values of:
+     ctop/cleft < 0xffff (0xffff => standard values if not initialized)
+     ctop+cheight <= sizes.raw_height
+     cleft+cwidth <= sizes.raw_width
+
+   Note: raw_inset_crops may be fooled by metadata (makernotes), use some correctness check before use.
+
+  * LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP processing flag removed,
+    DNG DefaultCrop* tags are parsed into raw_inset_crops[0]
+
+  * new LibRaw call LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop = 0.55f)
+    Promotes imgdata.sizes.raw_inset_crops[] values to
+    imgdata.sizes.*margin and imgdata.sizes.width/height fields
+
+   mask: if bit 1 is set: prefer raw_inset_crops[1] 
+         if bit 0 is set: prefer raw_inset_crops[0] 
+
+   maxcrop: limits crop to not less than (original width/height)*maxcrop; if raw_inset_crops[i]
+   data results in tighter crop, than this item is ignored.
+
+   return value: index in raw_inset_crops[] used increased by one, so
+    0: no changes made
+    1: [0]th data used
+    2: [1]th data used
+   
+  Note: this call SHOULD be used after LibRaw::unpack(), otherwise black level
+  calculation from masked area may be fooled resulting in wrong black levels.
+
+ * Shared library version incremented to disallow automated upgrades (will not work because of ABI change)
+
+== Metadata parsing improvements ==
+
+  * Olympus makernotes parsing: LiveND mode, Panorama mode tags.
+
+  * Fuji GFX100/GFX100S: PixelShift metadata extraction.
+
+  * Fuji RAF files: XMP block extraction
+
+== Misc improvements, limits implemented, etc ==
+
+  * Canon/12-bit files: adjust color.linear_max and makernotes.canon values
+    to match data range.
+
+  * DNG/Floating point: additional metadata check to refuse ambiguous/corrupted files.
+
+  * DNG/Floating point: correct handling of striped files (never seen in wild)
+
+  * Rawspeed support: disallow Nikon D6/Compressed processing
+ 
+  * Compile-time raw size limits implemented:
+     LIBRAW_MAX_NONDNG_RAW_FILE_SIZE - max file size for non-DNG files (default: 2GB - 1 byte)
+     LIBRAW_MAX_DNG_RAW_FILE_SIZE - max DNG file size limit (4GB-1 if compiled w/ DNG SDK, 2GB-1 overwise)
+
+  * samples/raw-identify.cpp:  -v flag documented in usage print.
+
+  * src/libraw_cxx.cpp completely removed from source tree to not confuse users.
+    (also all mentions are removed from Makefiles)
+
+  * clang-cl compatibility:
+    - defines _MSC_VER, but _forceinline is not supported
+    - warnings eliminated in Windows buffered datastream
+
+  * XMP block size in CR3 files limited to 1MB
+  
+  * Preview block size in CR3 files limited to 100MB
+
+  * Improved Phase One Compressed defects masking, thanks to Alexey Danilchenko
+
+  * CRX (CR3) decoder: fixed typo in constant; this does not affect any
+    known still photo (CR3) sample(s), but allows to use the decoder with 
+    some video (CRM) files.
+
+  * Imported user-contributed improvements to OpenMP postprocessing
+    (AHD and X-Trans demosaic)
+
+  * Bugfix: overwrite (wrong) TIFF/Orientation tag value with Metadata/Camera Orientation
+    value for EOS 40D only.
+
+  * ACES output: color conversion changed to provide D65 white point
+
+  * Fix for Canon 5D Mark II/sRAW1 incorrect camera provided crop   
+
+  * RawSpeed (master): fixed bug in old Samsung/compressed decoder,
+    apply this patch to RawSpeed: RawSpeed/rawspeed.samsung-decoder.patch
+  
+  * DCI-P3 and Rec 2020 output colorspaces
+  
+  * Eliminated multiple signed/unsigned mismatch warnings (reported by gcc11)
+
+  * Fixed a typo in LIBRAW_OPTIONS_* flag names
+    (was LIBRAW_OPIONS, old flags names not removed due to compatibility)
+
+== Bugfixes ==
+  * fixed possible 1-byte stack underrun while handling text tags with zero lengh
+
+  * Fixed wrong handling of linear DNG files created from Pentax out-of-camera DNGs
+ 
+
 2021-01-21  Alex Tutubalin <lexa@lexa.ru>
 
  == LibRaw snapshot 202101 ==
 
  = Camera format support: =
    Lossy compressed CR3 files
    Lossy compressed RAF files
    Uncompressed floating point DNG files (16-24-32 bit)
    Deflate compressed striped DNG files
    XMP and HEIF-preview extraction from CR3 files
 
  =  Camera support =
    Apple iPhone 12 Max, iPhone 12 Max Pro
    Canon EOS R5, EOS R6, EOS 850D, EOS-1D X Mark III (lossy compressed files)
    FujiFilm X-S10
    Hasselblad CFV II 50C",
    Leica M10-R, Q2 Monochrom, S3, SL2-S
    Nikon Z 5, Z 6 II, Z 7 II
    Olympus E-M10 Mark IV
    Panasonic DC-G100 / G110, DC-S5
    Sony ILCE-7C (A7C), ILCE-7SM3 (A7S III)
    Zeiss ZX1
    Plus multiple DNG-recording cameraphones/drones/etc.
 
  = Almost dropped camera support: =
    Old/partially supported video/cinema cameras support is available only if
    LibRaw is compiled with USE_OLD_VIDEOCAMS defined (this #define is
    converted internally to LIBRAW_OLD_VIDEO_SUPPORT defined).
    This affects:
      Arri cameras
      Canon C500
      RED Cine cameras
    We plan to keep the support in LibRaw 0.21 (if compiled with define 
    mentioned above) and completely drop the support after 0.21.
    If you're using LibRaw to decode RED Cine files, see LibRaw*datastreams
    section below (in short: you'll need to use old fstream-based datastream 
    under Windows).
    Cinema DNG files are not affected by this.
 
- = Compile/build changes =
- * Old (0.19-compatibility) files (internal/dcraw_*.cpp  
-   internal/demosaic_packs.cpp src/libraw_cxx.cpp) are removed from LibRaw 
-   repository.
-   Please switch to 'modern' multiple source files build.
-
  = API/ABI changes =
 
   * Decoding parameters
     imgdata.params is split into
       imgdata.rawparams: parameters used for metadata/raw data decoding
       imgdata.params:  parameters used at postprocessing stage
 
     imgdata.params.raw_processing options are split into two sub-options sets
       imgdata.rawparams.options: raw processing flags, useful for normal 
       operations
       imgdata.rawparams.specials: special modes (e.g decoding only delta 
       pixels from Sony ARW)
 
    Old LIBRAW_PROCESSING_* flags are renamed to LIBRAW_RAWOPTIONS_* and 
     LIBRAW_RAWSPECIAL*
    LIBRAW_PROCESSING_DP2Q_INTERPOLATE... flags are renamed to 
    LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATE with inverted meaning (with the 
    goal to have zero imgdata.rawparams.specials in normal use).
 
  * New processing flag LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB
    If set (default is not), and when applicable, color.cam_mul[] and
    color.WB_Coeffs/WBCT_Coeffs will contain WB settings for a
    non-standard workflow.
    Right now only Sony DSC-F828 is affected: camera-recorded white balance
    can't be directly applied to raw data because WB is for RGB, while raw
    data is RGBE.
 
  * New processing flag: LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT
    If set (default is not), LibRaw::dcraw_process() will fallback to
    daylight WB (excluding some very specific cases like Canon D30).
    This is how LibRaw 0.19 (and older) works.
    If not set: LibRaw::dcraw_process() will fallback to calculated auto WB if
    camera WB is requested, but appropriate white balance was not found in
    metadata.
 
   * Removed LIBRAW_PROCESSING_SKIP_MAKERNOTES processing flag: with new
     Windows(-handle) datastreams metadata parsing performance is enough
     to not skip makernotes parsing.
 
   * new output parameter: imgdata.params.output_flags and new
     enum LibRaw_output_flags
     Right now the only flag is implemented: LIBRAW_OUTPUT_FLAGS_PPMMETA
     setting it will result into metadata written to PPM/PGM output file
 
   * LibRaw_*datastreams change and corresponding open_file() parameters change
    LibRaw_file_datastream (based on iostreams) is moved under
       #ifdef LIBRAW_USE_DEPRECATED_IOSTREAMS_DATASTREAM
     Standard datastreams are:
      LibRaw_bigfile_datastream (FILE* based) for POSIX systems
      LibRaw_bigfile_buffered_datastream - for use with Win32 syscalls
     API changes:
     if LIBRAW_USE_DEPRECATED_IOSTREAMS_DATASTREAM is NOT defined, than 
     LibRaw::open_file() and similar calls drops the last INT64 max_buffered_sz 
     parameter which defines automatic selection between iostreams and 
     FILE* based datasteams.
 
     Note: LibRaw_bigfile_buffered_datastream does NOT implements 
     make_jas_stream() call, so RED Cine file decoding is not possible with 
     this datastream. Use deprecaded iostreams implementation instead.
 
     We plan to keep LIBRAW_USE_DEPRECATED_IOSTREAMS_DATASTREAM up to 
     LibRaw 0.21 and drop in 0.22.
 
   * Fuji decoder:
     fuji_decode_loop/fuji_decode_strip parameters has changed; look into source
     code for details if you're implementing your own fuji_decode_loop() 
     call in subclass to provide parallel fuji decoding.
 
   * Canon CR3 H265 (HEIF) preview limited support:
     - new format value: LIBRAW_THUMBNAIL_H265
     - this thumbnail is NOT extracted by LibRaw::make_mem_thumb() yet;
 
   * LibRaw::capabilities
     Two bits added:
       LIBRAW_CAPS_ZLIB if compiled with USE_ZLIB
       LIBRAW_CAPS_JPEG if compiled with USE_JPEG
 
- * samples/raw-identify.cpp sample: removed lot of extra output
-   used only by development team
 
  * Windows datastreams: CreateFile2 is used if compiled for UWP.
 
  * API-datastruct: clarified behavior with use_camera_wb=1 setting.
 
  * identify(): restored the differentiation between fsize and flen.
 
  * New compile-time LIBRAW_FORCE_OPENMP to skip compiler version check
    (if LibRaw user is absolutely sure that OpenMP is supported by compiler)
 
 2020-10-14 Alex Tutubalin <lexa@lexa.ru>
 
  * LibRaw 0.20.2
  Reverted 0.20.1 change:
    - const buffer for open_buffer() and open_bayer() calls
  Because of 0.20.0 ABI break
 
 2020-10-14 Alex Tutubalin <lexa@lexa.ru>
 
  * LibRaw 0.20.1
  * Improvements:
    - exif callback is called on EXIF GPS and EXIF Interop IFDs
    - open_bayer call documented
    - Canon (ColorDatsSubver==32): parse Specular White instead of hardcoded value
  * Fixes for normal files processing:
    - Olympus XZ-1: do not provide linear_max (it is wrong in metadata)
    - Nikon Z cameras: added space in camera list
    - raw-identify: fixed wb-preset print
    - Pentax Optio 33WR: maker index was incorrect
    - dcraw_emu: corrected help line for -6 option.
    - raw-identify: corrected range check for color matrices print
    - use_camera_matrix option: fixed a bug introduced when making
      compiler more happy.
 
  * Fixes for damaged/special crafted files processing:
    - Fix for truncated CR3 files parsing
    - DNG metadata merger: all color loops are limited to MIN(4,colors)
    - Check for marings: should be less than raw image size
    - Check for xmpdata present in Samsung Lens ID assignment
    - Check for column range in leaf_hdr decoder
    - Additional checks in Hasselblad model parser
    - Fuji rotate: better limits check
    - DNG files: limit tiff_samples
 
  * Not fixes, but makes ASAN/compilers/etc happy:
    - corrected GPS EXIF output
    - const buffer for open_buffer() and open_bayer() calls
 
 
 2020-07-23 Alex Tutubalin <lexa@lexa.ru>
 
  * LibRaw 0.20
 
 == Camera Format support ==
   Canon CR3
   GoPro (via GPR SDK)
   Panasonic 14-bit
   Fujifilm compressed/16bit
   Rapsberry Pi RAW+JPEG format (if USE_6BY9RPI defined)
   Foveon X3F support changed: it is supported only if USE_X3FTOOLS defined
   at build (see below for 'Imported code policy changed')
 
 == Camera support (+59, 1131 total) ==
   Canon: PowerShot G5 X Mark II, G7 X Mark III, SX70 HS,
          EOS R, EOS RP, EOS 90D, EOS 250D,  EOS M6 Mark II, EOS M50, EOS M200
          EOS 1DX Mark III (lossless files only)
   DJI Mavic Air, Osmo Action
   FujiFilm GFX 100, X-A7, X-Pro3, X100V, X-T4 (uncompressed/lossless compressed only), X-T200
   GoPro Fusion, HERO5, HERO6, HERO7, HERO8
   Hasselblad L1D-20c, X1D II 50C
   Leica D-LUX7, Q-P, Q2, V-LUX5, C-Lux / CAM-DC25, SL2, M10 Monochrom
   Nikon D780, Z50, P950
   Olympus TG-6, E-M5 Mark III, E-PL10, E-M1 Mark III,
   Panasonic DC-FZ1000 II, DC-G90, DC-S1, DC-S1R, DC-S1H, DC-TZ95
   PhaseOne IQ4 150MP
   Ricoh GR III
   Sony A7R IV, A9 II, ILCE-6100, ILCE-6600, RX0 II, RX100 VII
   Zenit M
diff --git a/Makefile.devel b/Makefile.devel
index 0458d2b9..ec5800a5 100644
--- a/Makefile.devel
+++ b/Makefile.devel
@@ -192,10 +192,6 @@ object/libraw_c_api.o: src/libraw_c_api.cpp $(HEADERS)
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
 object/libraw_c_api.mt.o: src/libraw_c_api.cpp $(HEADERS)
 	${CXX} -c ${CFLAGS} -o object/libraw_c_api.mt.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
-object/libraw_cxx.mt.o: src/libraw_cxx.cpp $(HEADERS)
-	${CXX} -c ${CFLAGS} -o object/libraw_cxx.mt.o src/libraw_cxx.cpp
 
 object/libraw_datastream.o: src/libraw_datastream.cpp $(HEADERS)
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
diff --git a/Makefile.devel.nopp b/Makefile.devel.nopp
index 5364e77a..6ece7e9e 100644
--- a/Makefile.devel.nopp
+++ b/Makefile.devel.nopp
@@ -102,8 +102,6 @@ clean:
 ## script-created rules
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.devel.noppr2i b/Makefile.devel.noppr2i
index aa35b5c3..69372877 100644
--- a/Makefile.devel.noppr2i
+++ b/Makefile.devel.noppr2i
@@ -94,8 +94,6 @@ clean:
 ## script-created rules
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.dist b/Makefile.dist
index 001b745a..61194a07 100644
--- a/Makefile.dist
+++ b/Makefile.dist
@@ -199,10 +199,6 @@ object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
 object/libraw_c_api.mt.o: src/libraw_c_api.cpp
 	${CXX} -c ${CFLAGS} -o object/libraw_c_api.mt.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
-object/libraw_cxx.mt.o: src/libraw_cxx.cpp
-	${CXX} -c ${CFLAGS} -o object/libraw_cxx.mt.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/libraw_datastream.mt.o: src/libraw_datastream.cpp
diff --git a/Makefile.mingw b/Makefile.mingw
index 434d6470..f2c291e2 100644
--- a/Makefile.mingw
+++ b/Makefile.mingw
@@ -147,8 +147,6 @@ clean:
 ### generated
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.msvc b/Makefile.msvc
index 5594ca05..c06b35f0 100644
--- a/Makefile.msvc
+++ b/Makefile.msvc
@@ -42,37 +42,35 @@ $(LIBDLL): $(DLL)
 LIB_OBJECTS= object\libraw_datastream_st.obj object\libraw_c_api_st.obj \
   object\cameralist_st.obj object\fuji_compressed_st.obj \
   object\crx_st.obj object\fp_dng_st.obj object\decoders_libraw_st.obj \
   object\unpack_st.obj object\unpack_thumb_st.obj \
   object\rawspeed_glue_st.obj object\dngsdk_glue_st.obj \
   object\colorconst_st.obj object\utils_libraw_st.obj object\init_close_utils_st.obj \
   object\decoder_info_st.obj object\open_st.obj object\phaseone_processing_st.obj \
   object\thumb_utils_st.obj \
   object\tiff_writer_st.obj object\subtract_black_st.obj object\postprocessing_utils_st.obj \
   object\dcraw_process_st.obj object\raw2image_st.obj object\mem_image_st.obj \
   object\x3f_utils_patched_st.obj object\x3f_parse_process_st.obj \
   object\read_utils_st.obj object\curves_st.obj object\utils_dcraw_st.obj \
   object\colordata_st.obj \
   object\canon_600_st.obj  object\decoders_dcraw_st.obj \
   object\decoders_libraw_dcrdefs_st.obj  object\generic_st.obj \
   object\kodak_decoders_st.obj object\dng_st.obj object\smal_st.obj \
   object\load_mfbacks_st.obj \
   object\sony_st.obj object\nikon_st.obj object\samsung_st.obj object\cr3_parser_st.obj \
   object\canon_st.obj  object\epson_st.obj object\olympus_st.obj object\leica_st.obj \
   object\fuji_st.obj object\adobepano_st.obj object\pentax_st.obj object\p1_st.obj \
   object\makernotes_st.obj object\exif_gps_st.obj object\kodak_st.obj \
   object\tiff_st.obj object\ciff_st.obj object\mediumformat_st.obj object\minolta_st.obj \
   object\identify_tools_st.obj \
   object\hasselblad_model_st.obj object\normalize_model_st.obj object\identify_st.obj \
   object\misc_parsers_st.obj object\wblists_st.obj \
   object\postprocessing_aux_st.obj object\postprocessing_utils_dcrdefs_st.obj \
   object\aspect_ratio_st.obj \
   object\misc_demosaic_st.obj object\xtrans_demosaic_st.obj object\ahd_demosaic_st.obj \
   object\dht_demosaic_st.obj  object\aahd_demosaic_st.obj  object\dcb_demosaic_st.obj \
   object\file_write_st.obj \
   object\ext_preprocess_st.obj   object\apply_profile_st.obj
 
-#LIB_OBJECTS=object\dcraw_common_st.obj object\dcraw_fileio_st.obj  object\libraw_cxx_st.obj object\libraw_datastream_st.obj object\libraw_c_api_st.obj object\demosaic_packs_st.obj
-#DLL_OBJECTS=object\dcraw_common.obj object\dcraw_fileio.obj  object\libraw_cxx.obj object\libraw_datastream.obj object\libraw_c_api.obj  object\demosaic_packs.obj
 
 DLL_OBJECTS= object\libraw_datastream.obj object\libraw_c_api.obj \
   object\cameralist.obj object\fuji_compressed.obj \
@@ -622,12 +620,6 @@ object\libraw_c_api_st.obj: src\libraw_c_api.cpp
 object\libraw_c_api.obj: src\libraw_c_api.cpp
 	$(CC) $(COPT) /DLIBRAW_BUILDLIB /Fo"object\\libraw_c_api.obj" /c src\libraw_c_api.cpp
 
-object\libraw_cxx_st.obj: src\libraw_cxx.cpp
-	$(CC) $(COPT) /DLIBRAW_NODLL /DLIBRAW_BUILDLIB /Fo"object\\libraw_cxx_st.obj" /c src\libraw_cxx.cpp
-
-object\libraw_cxx.obj: src\libraw_cxx.cpp
-	$(CC) $(COPT) /DLIBRAW_BUILDLIB /Fo"object\\libraw_cxx.obj" /c src\libraw_cxx.cpp
-
 object\libraw_datastream_st.obj: src\libraw_datastream.cpp
 	$(CC) $(COPT) /DLIBRAW_NODLL /DLIBRAW_BUILDLIB /Fo"object\\libraw_datastream_st.obj" /c src\libraw_datastream.cpp
 
diff --git a/README.RawSpeed.txt b/README.RawSpeed.txt
index 336d04a2..fb4b94c9 100644
--- a/README.RawSpeed.txt
+++ b/README.RawSpeed.txt
@@ -12,48 +12,51 @@ To build RawSpeed you need libxml2, iconv, and JPEG library installed on your
 system.
 
 2) Build RawSpeed:
 
   -- consult http://rawstudio.org/blog/?p=800 for details
 
   -- Win32: you need POSIX Threads for Win32 installed on your system
      (http://sources.redhat.com/pthreads-win32/)
 
+  -- use provided RawSpeed/rawspeed.samsung-decoder.patch  to fix
+     old Samsung decoder bug
+
   -- you may use qmake .pro files supplied in LibRaw distribution
      (RawSpeed/rawspeed.qmake-pro-files.patch)
      Adjust path to libraries/includes according to your setup.
 
   -- Win32: you need to add __declspec(..) to external C++ classes.
      Use patch provided with LibRaw (RawSpeed/rawspeed.win32-dll.patch)
 
   -- Unix: you need to define rawspeed_get_number_of_processor_cores() call
      For most unix systems (Linux, MacOS X 10.4+, FreeBSD) patch provided
      with LibRaw (RawSpeed/rawspeed.cpucount-unix.patch) should work.
 
 3) Build LibRaw with RawSpeed support:
  
    Win32: 
      --Uncomment CFLAGS_RAWSPEED and LDFLAGS_RAWSPEED lines in
        Makefile.msvc. Adjust paths to libraries/includes if needed.
      -- run nmake -f Makefile.msvc
 
    Unix/MacOS:
      -- Uncomment CFLAGS/LDADD lines in RawSpeed section in Makefile.dist
      -- Uncomment RAWSPEED_DATA line if you wish to rebuild
 	internal copy of RawSpeed's cameras.xml
      -- run make -f Makefile.dist
 
    Compile options:
     -- You may specify -DNOSONY_RAWSPEED define if you do not want to use 
         RawSpeed's Sony formats decoder (because result of this decoder is 
         different from  LibRaw's built-in decoder)
 
 4) Build/run your Apps with LibRaw+RawSpeed
    
    -- Build as usual, no changes required in your apps unless you
       access LibRaw::imgdata.rawdata.raw_image[] directly
 
    -- you may turn off RawSpeed support on runtime by setting 
       imgdata.params.use_rawspeed to 0.
 
    -- You'll need all shared libraries you linked to at runtime (libxml2,
       iconv, LibJPEG, and posix threads on Win32).
diff --git a/README.md b/README.md
index b6157292..d7cedbe5 100644
--- a/README.md
+++ b/README.md
@@ -1,28 +1,106 @@
 # LibRaw
-### Library for reading and processing of RAW digicam images
-
-LibRaw is a library for reading RAW files from digital photo cameras 
-(CRW/CR2, NEF, RAF, DNG, MOS, KDC, DCR, etc, virtually all RAW formats are 
-supported). 
-
-It pays special attention to correct retrieval of data required for subsequent 
-RAW conversion.
-    
-The library is intended for embedding in RAW converters, data analyzers, and 
-other programs using RAW files as the initial data.
-
-LibRaw library, Copyright &copy; 2008-2021 LibRaw LLC (info@libraw.org)
-The library includes source code from
-      
-     dcraw.c, Dave Coffin's raw photo decoder
-     Copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net
-      
-LibRaw is distributed for free under two different licenses:
- *  GNU Lesser General Public License, version 2.1
- *  COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
-    
-You may use one of these licensing modes and switch between them.
-
-If you modify LibRaw source and made your changes public, you should accept
-both two licensing modes for your changes/additions.
+## Library for reading and processing of RAW digicam images
 
+ The LibRaw library provides a simple and unified interface for extracting out of RAW files generated by digital photo cameras the following:
+
+* RAW data (_pixel values)_
+* Metadata necessary for processing RAW (_geometry, CFA / Bayer pattern, black level, white balance, etc.)_
+* Embedded preview / thumbnail.
+
+The library is intended for use with programs that work with RAW files, such as:
+
+* RAW viewers
+* RAW converters
+* RAW data analyzers
+* Software for stitching and compositing multi-frame aggregates like panoramas and image stacks.
+
+Using the LibRaw library allows one to focus on the substantive part of processing the data contained in RAW files, without getting distracted by the wide variety of RAW file and metadata formats, compression algorithms, etc.
+
+The library’s development is focused on:
+
+* Support for new cameras and formats
+* Improving extraction of metadata necessary for RAW processing
+* Providing an interface for reading other types of metadata.
+
+Additionally, the LibRaw library offers some basic RAW conversion, intended for cases when such conversion is not the main function of the LibRaw-using application _(for example: a viewer for 500+ graphic file formats, including RAW)._ These methods are inherited from the Dave Coffin’s dcraw.c utility _(see below the “Project history” section);_ their further development is not currently planned, because we do not consider production-quality rendering to be in the scope of LibRaw’s functionality _(the methods are retained for compatibility with prior versions and for rapid-fire testing of RAW support and other aspects)._
+
+## Licensing
+
+
+The LibRaw library is distributed free of charge and with open-source code subject to two licenses:
+
+1\. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+
+2\. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+
+To use the LibRaw library in an application, you can choose the license that better suits your needs.
+
+If you modify/add/improve the LibRaw source code, then your patches can only be included into the library’s official source code if you agree to it being distributed under both of the above licenses.
+
+We do not guarantee that the licensing will not change in future versions of LibRaw.
+
+## Update policy
+
+
+### Major/minor releases
+
+* Major releases _(for example, 0.20)_ are published once every year and a half to two years.
+* When the first public beta version of a major release is published, the list of supported cameras and formats is frozen; we try (but do not guarantee) to freeze the API/ABI as well.
+* The public major release contains only that code which has been sufficiently tested on a wide user base (including in our commercial products). Something very new may not be included in it (but it will probably be included in a public snapshot, see below).
+* Minor updates _(0.20.1, 0.20.2…)_ do not change the API/ABI and new cameras are not added; generally they are just bugfixes.
+* Bugfixes are published as soon as possible in the [public GitHub repository](https://github.com/LibRaw/LibRaw).
+* Minor version increments: these are generally published if a serious error has been fixed, one that potentially affects many library users (for example, a possible stack overflow).
+
+### Public snapshots
+
+* Public snapshots are published every 7-9 months in the [public GitHub repository](https://github.com/LibRaw/LibRaw).
+* These versions contain support for new cameras that was added after the previous major release. The API/ABI of public snapshots is not frozen, and may change.
+* Public snapshots are always tested on a fairly large user base, and may be considered suitable for use in programs that work with files with known origins (that is, recorded directly by users’ digital cameras). However, public snapshots should not be considered sufficiently reliable for processing files that are specially constructed for vulnerability testing; that is, they should not be used in public services that allow for anonymous processing of files of unknown provenance
+
+## Support and feedback
+
+* You can submit a bug report in one of the following ways:
+    * [Issues](https://github.com/LibRaw/LibRaw/issues) on GitHub
+    * The libraw.org [forum](https://www.libraw.org/forum)
+    * [Feedback form](https://www.libraw.org/contact) on libraw.org
+    * E-mail us at [info@libraw.org](mailto:info@libraw.org)
+* Questions can be asked on the forum, through the feedback form, and via the email indicated above.  
+    Please do not use Issues on GitHub for questions; it is intended specifically for problem reports.
+* We prefer to process additions to the source code via the [Pull Requests](https://github.com/LibRaw/LibRaw/pulls) on GitHub.
+
+We cannot guarantee any response to requests submitted via the above methods. If you need a guaranteed response for a bug report and/or for extending technical support, please use the Extended Support option.
+
+## Project history
+
+
+The LibRaw project was launched in 2008, based on the [dcraw.c](https://www.dechifro.org/dcraw/) (Dave Coffin) utility, with its goals being to:
+
+* Convert dcraw.c into a library that could be used by other programs, while also somewhat improving the structure of dcraw.c (removing global variables, making it thread-safe, etc.)
+* Import changes made to dcraw.c
+* Improve/expand the extraction of metadata.
+
+Unfortunately, support for dcraw.c was reduced to a minimum in 2015, and completely ceased in 2018. Since then, support for new cameras (including support for new formats) has been done entirely by the LibRaw team.
+
+The code that implements rendering of RAW to RGB is inherited from dcraw.c, without major changes (though a set of changes was implemented to speed up and parallelize this code).
+
+In the early-to-mid 2010s, we gladly expanded post-processing implemented in LibRaw, and readily accepted the input of outside developers (new/improved methods for debayerization/demosaicing, systematic noise reduction etc.).
+
+Experience has shown that the LibRaw team cannot support this added code on their own, while contributors do not provide support and development of the code they suggest and it ends up abandoned. As such, the majority of the modifications that are implemented by people outside the LibRaw team was moved to the [LibRaw-demosaic-pack-….](https://github.com/LibRaw?tab=repositories), where they remain in their original form (but these projects are still present in our GitHub).
+
+Thus, we arrive at our current status, described in the first part of this text.
+
+## Copyrights and Acknowledgements
+
+Copyright (C) 2008-2021 LibRaw LLC
+
+LibRaw uses code from Dave Coffin’s dcraw.c utility (without RESTRICTED/GPL2 code):
+
+Copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net
+
+LibRaw uses DCB demosaic code by Jaceck Gozdz distributed under BSD license:
+
+Copyright (C) 2010, Jacek Gozdz (mailto:cuniek@kft.umcs.lublin.pl)
+
+LibRaw uses Roland Karlsson’s X3F tools source code, licensed under BSD license:
+
+Copyright (c) 2010, Roland Karlsson (roland@proxel.se)
\ No newline at end of file
diff --git a/RawSpeed/rawspeed.samsung-decoder.patch b/RawSpeed/rawspeed.samsung-decoder.patch
new file mode 100644
index 00000000..f62754a8
--- /dev/null
+++ b/RawSpeed/rawspeed.samsung-decoder.patch
@@ -0,0 +1,39 @@
+diff --git a/RawSpeed/SrwDecoder.cpp b/RawSpeed/SrwDecoder.cpp
+index fa46499..1aff689 100644
+--- a/RawSpeed/SrwDecoder.cpp
++++ b/RawSpeed/SrwDecoder.cpp
+@@ -141,7 +141,7 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         // First we decode even pixels
+         for (int c = 0; c < 16; c += 2) {
+           int b = len[(c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + img_up[c];
+         }
+         // Now we decode odd pixels
+@@ -149,7 +149,7 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         // is beyond me, it will hurt compression a deal.
+         for (int c = 1; c < 16; c += 2) {
+           int b = len[2 | (c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + img_up2[c];
+         }
+       } else {
+@@ -158,14 +158,14 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         int pred_left = x ? img[-2] : 128;
+         for (int c = 0; c < 16; c += 2) {
+           int b = len[(c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + pred_left;
+         }
+         // Now we decode odd pixels
+         pred_left = x ? img[-1] : 128;
+         for (int c = 1; c < 16; c += 2) {
+           int b = len[2 | (c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + pred_left;
+         }
+       }
diff --git a/doc/API-CXX.html b/doc/API-CXX.html
index b32c614f..4dc73bd1 100644
--- a/doc/API-CXX.html
+++ b/doc/API-CXX.html
@@ -1,881 +1,910 @@
 <html>
   <head>
     <meta http-equiv="content-type" content="text/html; charset=windows-1252">
   </head>
   <body>
     <p>LibRaw C++ API<a href="index.html">[back to Index]</a></p>
     <h1>LibRaw C++ API</h1>
     <p>Contents</p>
     <ol>
       <li><a href="#LibRaw">LibRaw Objects</a></li>
       <li><a href="#return">Returned values</a></li>
       <li><a href="#dataload">Methods Loading Data from a File</a>
         <ul>
           <li><a href="#open_datastream">int
               LibRaw::open_datastream(LibRaw_abstract_datastream *stream)</a></li>
           <li><a href="#open_file">int LibRaw::open_file(const char
               *rawfile[,INT64 bigfile_size])</a></li>
           <li><a href="#open_buffer">int LibRaw::open_buffer(void *buffer,
               size_t bufsize)</a></li>
-          <li><a href="#open_bayer">int
-              LibRaw::open_bayer(...)</a></li>
+          <li><a href="#open_bayer">int LibRaw::open_bayer(...)</a></li>
           <li><a href="#unpack">int LibRaw::unpack(void)</a></li>
           <li><a href="#unpack_thumb">int LibRaw::unpack_thumb(void)</a></li>
         </ul>
       </li>
       <li><a href="#utility">Auxiliary Functions</a>
         <ul>
           <li>Library version info
             <ul>
               <li><a href="#version">const char* LibRaw::version()</a></li>
               <li><a href="#versionNumber">int LibRaw::versionNumber()</a></li>
               <li><a href="#LIBRAW_CHECK_VERSION">bool
                   LIBRAW_CHECK_VERSION(major,minor,patch)</a></li>
             </ul>
           </li>
           <li>List of supported cameras
             <ul>
               <li><a href="#cameraCount">int LibRaw::cameraCount()</a></li>
               <li><a href="#cameraList">const char** LibRaw::cameraList()</a></li>
             </ul>
           </li>
           <li><a href="#set_rawspeed_camerafile">int
               LibRaw::set_rawspeed_camerafile(char *path_to_cameras_xml)</a></li>
           <li><a href="#get_decoder_info">int
               LibRaw::get_decoder_info(libraw_decoder_info_t *)</a></li>
           <li><a href="#unpack_function_name">const char*
               LibRaw::unpack_function_name()</a></li>
           <li><a href="#COLOR">int LibRaw::COLOR()</a></li>
           <li><a href="#error_count">int LibRaw::error_count()</a></li>
           <li><a href="#setCancelFlag">void LibRaw::setCancelFlag()</a></li>
           <li><a href="#clearCancelFlag">void LibRaw::clearCancelFlag()</a></li>
           <li><a href="#subtract_black">int LibRaw::subtract_black()</a></li>
+          <li><a href="#adjust_to_raw_inset_crop">int
+              LibRaw::adjust_to_raw_inset_crop()</a></li>
           <li><a href="#floatingpoint">Support for Floating Point data</a></li>
           <li><a href="#ycc">Support for YCC formats</a></li>
           <li><a href="#recycle">void LibRaw::recycle_datastream(void)</a></li>
           <li><a href="#recycle">void LibRaw::recycle(void)</a></li>
           <li><a href="#%7ELibRaw">LibRaw::~LibRaw()</a></li>
           <li><a href="#strprogress">const char* LibRaw::strprogress(enum
               LibRaw_progress code)</a></li>
           <li><a href="#libraw_strerror">const char* LibRaw::strerror(int
               errorcode)</a></li>
           <li><a href="#callbacks">Setting Error Notification Functions and
               other callbacks</a>
             <ul>
               <li><a href="#progress">User callback for progress
                   indication/interruption</a></li>
               <li><a href="#exif">User callback for exif/makernotes parser
                   routines</a></li>
               <li><a href="#memerror">Out-of-Memory Notifier</a></li>
               <li><a href="#dataerror">File Read Error Notifier</a></li>
             </ul>
           </li>
         </ul>
       </li>
       <li><a href="#dcrawemu">Data Postprocessing: Emulation of dcraw Behavior</a>
         <ul>
           <li><a href="#dcraw_params">Parameter Setting</a></li>
           <li><a href="#raw2image">int LibRaw::raw2image</a></li>
           <li><a href="#free_image">void LibRaw::free_image</a></li>
           <li><a href="#adjust_sizes_info_only">int
               LibRaw::adjust_sizes_info_only(void)</a></li>
           <li><a href="#dcraw_process">int LibRaw::dcraw_process(void)</a></li>
         </ul>
       </li>
       <li><a href="#dcrawrite">Data Output to Files: Emulation of dcraw Behavior</a>
         <ul>
           <li><a href="#dcraw_ppm_tiff_writer">int
               LibRaw::dcraw_ppm_tiff_writer(const char *outfile)</a></li>
           <li><a href="#dcraw_thumb_writer">int LibRaw::dcraw_thumb_writer(const
               char *thumbfile)</a></li>
         </ul>
       </li>
       <li><a href="#memwrite">Copying unpacked data into memory buffer</a>
         <ul>
           <li><a href="#get_mem_image_format">void get_mem_image_format(int
               *widthp, int *heightp, int *colorsp, int *bpp)</a></li>
           <li><a href="#copy_mem_image">int LibRaw::copy_mem_image(void* scan0,
               int stride, int bgr)</a></li>
           <li><a href="#dcraw_make_mem_image">libraw_processed_image_t
               *dcraw_make_mem_image(int *errorcode)</a></li>
           <li><a href="#dcraw_make_mem_thumb">libraw_processed_image_t
               *dcraw_make_mem_thumb(int *errorcode)</a></li>
           <li><a href="#dcraw_clear_mem">void
               LibRaw::dcraw_clear_mem(libraw_processed_image_t *)</a></li>
         </ul>
       </li>
       <li><a href="#datastream">Input layer abstraction</a>
         <ul>
           <li><a href="LibRaw_abstract_datastream">class
               LibRaw_abstract_datastream - abstract RAW read interface</a><a href="#datastream_methods">LibRaw_abstract_datastream
               class methods</a>
             <ul>
               <li><a href="#datastream_methods_utility">Object verification</a></li>
               <li><a href="#datastream_methods_read">Stream read and positioning</a></li>
               <li><a href="#datastream_methods_other">Other methods</a></li>
             </ul>
           </li>
           <li><a href="#datastream_derived">Derived input classes included in
               LibRaw</a>
             <ul>
               <li><a href="#file_datastream">class LibRaw_file_datastream - file
                   input interface</a></li>
               <li><a href="#bigfile_datastream">class LibRaw_file_datastream -
                   file input interface for large files</a></li>
               <li><a href="#buffer_datastream">class LibRaw_buffer_datastream -
                   input from memory buffer</a></li>
             </ul>
           </li>
           <li><a href="#own_datastreams">Own datastream derived classes</a>
             <ul>
               <li><a href="#substream">substream field: secondary input stream</a></li>
             </ul>
           </li>
         </ul>
       </li>
     </ol>
     <p><a name="LibRaw"></a></p>
     <h2>LibRaw Objects</h2>
     <p>The main LibRaw object (class) is created either without parameters or
       with flags determining the object behavior.</p>
     <pre>#include "libraw/libraw.h"<br>...<br><br>   LibRaw ImageProcessor(unsigned int flags=0);<br>...<br>    </pre>
     <p>Flags (several flags are combined via operator |, i.e., bitwise OR):</p>
     <ul>
       <li><strong>LIBRAW_OPTIONS_NO_MEMERR_CALLBACK</strong>: do not set the
         standard <a href="#callbacks">out-of-memory error handler</a> (standard
         handler outputs the error report in stderr);</li>
       <li><strong>LIBRAW_OPTIONS_NO_DATAERR_CALLBACK</strong>: do not set the
         standard <a href="#callbacks">file read error handler</a> (standard
         handler outputs the error report in stderr).</li>
     </ul>
     <p>Three groups of methods are used for image processing</p>
     <ul>
       <li><a href="#dataload">Data loading from the RAW file</a></li>
       <li><a href="#dcrawemu">Postprocessing functions emulating the dcraw
           behavior</a></li>
       <li><a href="#dcrawrite">File output functions emulating the dcraw
           behavior</a>.</li>
     </ul>
     <p>The results of processing are placed in the imgdata field of type <a href="API-datastruct.html">libraw_data_t</a>;
       the same data set contains fields that control the postprocessing and
       output.</p>
     <p><a name="return"></a></p>
     <h2>Returned Values</h2>
     <p>All LibRaw API functions return an integer number in accordance with the
       <a href="API-notes.html#errors">return code convention</a>. Please read
       the descriptions of <a href="API-notes.html#errors">this convention</a>
       and <a href="#callbacks">LibRaw behavior in cases of fatal errors</a>.</p>
     <p><a name="dataload"></a></p>
     <h2>Methods Loading Data from a File</h2>
     <p><a name="open_datastream"></a></p>
     <h3>int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)</h3>
     <p>Opens a datastream with RAW data, reads metadata (EXIF) from it, and
       fills the following structures:</p>
     <ul>
       <li>imgdata.idata (<a href="API-datastruct.html#libraw_iparams_t">libraw_iparams_t</a>),</li>
       <li>imgdata.sizes (<a href="API-datastruct.html#libraw_image_sizes_t">libraw_image_sizes_t</a>),</li>
       <li>imgdata.color (<a href="API-datastruct.html#libraw_colordata_t">libraw_colordata_t</a>),</li>
       <li>imgdata.other (<a href="API-datastruct.html#libraw_imgother_t">libraw_imgother_t</a>),
         and</li>
       <li>imgdata.thumbnail (<a href="API-datastruct.html#libraw_thumbnail_t">libraw_thumbnail_t</a>).</li>
     </ul>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p>Before file opening, <a href="#recycle">recycle()</a> is always called;
       hence, if several images are processed in the batch mode, there is no need
       to call recycle() at the end of each processing cycle.</p>
     <p><strong>Input data</strong>: pointer to object, derived from <a href="#datastream">LibRaw_abstract_datastream</a>
       class. This object should be initialized and ready to read. This object
       should be destroyed in calling application after use.</p>
     <p><a name="open_file"></a></p>
     <h3>int LibRaw::open_file(const char *filename[,INT64 bigfile_size])</h3>
     <h3>Win32 only: int LibRaw::open_file(const wchar_t *filename[,INT64
       bigfile_size])</h3>
     <p>Creates an <a href="#file_datastream">LibRaw_file_datastream</a> object,
       calls <a href="#open_datastream">open_datastream()</a>. If succeed, sets
       internal flag which signals to destroy internal datastream object on <a href="#recycle">recycle()</a>.
       On failure, just created file_datastream destroyed immediately.</p>
     <p>Second optional parameter <strong>bigfile_size</strong> controls
       background I/O interface used for file operations. For files smaller than
       bigfile_size the <a href="#file_datastream">LibRaw_file_datastream</a>
       will be used and the <a href="#bigfile_datastream">LibRaw_bigfile_datastream</a>
       otherwise.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="open_buffer"></a></p>
     <h3>int LibRaw::open_buffer(void *buffer, size_t bufsize)</h3>
     <p>Created an <a href="#buffer_datastream">LibRaw_buffer_datastream</a>
       object, calls <a href="#open_datastream">open_datastream()</a>. If
       succeed, sets internal flag which signals to destroy internal datastream
       object on <a href="#recycle">recycle()</a>. On failure, just created
       file_datastream destroyed immediately.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="open_bayer"></a></p>
-
-    <h3>int LibRaw::open_bayer(unsigned char *data, unsigned datalen,
-	  ushort _raw_width, ushort _raw_height, ushort _left_margin, ushort _top_margin,
-	  ushort _right_margin, ushort _bottom_margin,
-	  unsigned char procflags, unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,
-	  unsigned black_level)</h3>
-    <p>Parameters:
-<ul>
-<li>data, datalen - buffer passed
-<li>_raw_width/_raw_height/*margin - image size and margins
-<li> procflags:
- <ul>
- <li>for 10-bit format:
-  <ul>
-   <li>1: "4 pixels in 5 bytes" packing is used
-   <li>0: "6 pixels in 8 bytes" packing is used
-  </ul>
- <li>for 16-bit format:
-  <ul>
-   <li>1: Big-endian data
-  </ul>
- </ul>
- <li>bayer_pattern: one of LIBRAW_OPENBAYER_RGGB,LIBRAW_OPENBAYER_BGGR,
-                          LIBRAW_OPENBAYER_GRBG,LIBRAW_OPENBAYER_GBRG
- <li>unused_bits: count of upper zero bits
- <li>otherflags:
-  <ul>
-      <li>Bit 1 - filter (average neighbors) for pixels with values of zero
-      <li>Bits 2-4 - the orientation of the image (0=do not rotate, 3=180, 5=90CCW, 6=90CW)
-  </ul>
- <li>black_level: file black level (it also may be specified via imgdata.params)
-</ul>
-    See samples/openbayer_sample.cpp for usage sample (note, this sample is 'sample only', suited for
-    Kodak KAI-0340 sensor, you'll need change open_bayer() params for your data).
-
+    <h3>int LibRaw::open_bayer(unsigned char *data, unsigned datalen, ushort
+      _raw_width, ushort _raw_height, ushort _left_margin, ushort _top_margin,
+      ushort _right_margin, ushort _bottom_margin, unsigned char procflags,
+      unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,
+      unsigned black_level)</h3>
+    <p>Parameters: </p>
+    <ul>
+      <li>data, datalen - buffer passed </li>
+      <li>_raw_width/_raw_height/*margin - image size and margins </li>
+      <li> procflags:
+        <ul>
+          <li>for 10-bit format:
+            <ul>
+              <li>1: "4 pixels in 5 bytes" packing is used </li>
+              <li>0: "6 pixels in 8 bytes" packing is used </li>
+            </ul>
+          </li>
+          <li>for 16-bit format:
+            <ul>
+              <li>1: Big-endian data </li>
+            </ul>
+          </li>
+        </ul>
+      </li>
+      <li>bayer_pattern: one of LIBRAW_OPENBAYER_RGGB,LIBRAW_OPENBAYER_BGGR,
+        LIBRAW_OPENBAYER_GRBG,LIBRAW_OPENBAYER_GBRG </li>
+      <li>unused_bits: count of upper zero bits </li>
+      <li>otherflags:
+        <ul>
+          <li>Bit 1 - filter (average neighbors) for pixels with values of zero
+          </li>
+          <li>Bits 2-4 - the orientation of the image (0=do not rotate, 3=180,
+            5=90CCW, 6=90CW) </li>
+        </ul>
+      </li>
+      <li>black_level: file black level (it also may be specified via
+        imgdata.params) </li>
+    </ul>
+    See samples/openbayer_sample.cpp for usage sample (note, this sample is
+    'sample only', suited for Kodak KAI-0340 sensor, you'll need change
+    open_bayer() params for your data).
     <p><a name="unpack"></a></p>
     <h3>int LibRaw::unpack(void)</h3>
     <p>Unpacks the RAW files of the image, calculates the black level (not for
       all formats). The results are placed in imgdata.image.</p>
     <p>Data reading is sometimes (not frequently) affected by settings made in
       imgdata.params (<a href="API-datastruct.html#libraw_output_params_t">libraw_output_params_t</a>);
       see <a href="API-notes.html">API notes</a> for details.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="unpack_thumb"></a></p>
     <h3>int LibRaw::unpack_thumb(void)</h3>
     <p>Reads (or unpacks) the image preview (thumbnail), placing the result into
       the imgdata.thumbnail.thumb buffer.<br>
       JPEG previews are placed into this buffer without any changes (with the
       header etc.). Other preview formats are placed into the buffer in the form
       of the unpacked bitmap image (three components, 8 bits per component).<br>
       The thumbnail format is written to the imgdata.thumbnail.tformat field;
       for the possible values, see <a href="API-datastruct.html#LibRaw_thumbnail_formats">description
         of constants and data structures</a>.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="utility"></a></p>
     <h2>Auxiliary Functions</h2>
     <h3>Library version check</h3>
     <p><a name="version"></a></p>
     <h4>const char* LibRaw::version()</h4>
     <p>Returns string representation of LibRaw version in
       MAJOR.MINOR.PATCH-Status format (i.e. 0.6.0-Alpha2 or 0.6.1-Release).</p>
     <p><a name="versionNumber"></a></p>
     <h4>int LibRaw::versionNumber()</h4>
     <p>Returns integer representation of LibRaw version. During LibRaw
       development, the version number is always increase .</p>
     <p><a name="LIBRAW_CHECK_VERSION"></a></p>
     <h4>bool LIBRAW_CHECK_VERSION(major,minor,patch)</h4>
     <p>Macro for version check in caller applications. Returns 'true' if current
       library version is greater or equal to set in macro parameters. This macro
       executes at runtime (not at compile time) and may be used for checking
       version of dynamically loaded LibRaw (from DLL/shared library).</p>
     <h3>List of supported RAW formats (cameras)</h3>
     <p><a name="cameraCount"></a></p>
     <h4>int LibRaw::cameraCount()</h4>
     <p>Returns count of cameras supported.</p>
     <p><a name="cameraList"></a></p>
     <h4>const char** LibRaw::cameraList()</h4>
     <p>Returns list of supported cameras. Latest item of list is set to NULL
       (for easy printing).</p>
     <p><a name="#set_rawspeed_camerafile"></a></p>
     <h4>int LibRaw::set_rawspeed_camerafile(char *path_to_cameras_xml)</h4>
     <p>(Only if LibRaw was built with RawSpeed support).</p>
     <p>Loads XML file with RawSpeed camera description data (cameras.xml)
       specified by path_to_cameras_xml. Returns 0 on success, nonzero on error.
       <a name="get_decoder_info"></a></p>
     <h4>int LibRaw::get_decoder_info(libraw_decoder_info_t *)</h4>
     <p>The function fills <a href="API-datastruct.html#libraw_decoder_info_t">libraw_decoder_info_t</a>
       structure by passed pointer with current raw decoder data.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="unpack_function_name"></a></p>
     <h3>const char* LibRaw::unpack_function_name()</h3>
     <p>Returns function name of file unpacking function. Intended only for
       LibRaw test suite designers to use in test coverage evaluation.</p>
     <p><a name="setCancelFlag"></a></p>
     <h4>void LibRaw::setCancelFlag()</h4>
     <p>This call sets internal fast cancel flags. If set, current Raw decoder
       will be terminated ASAP. This call is useful if you need to cancel all
       LibRaw decoders in multithreaded program (e.g. for fast program
       termination or just for cancel current processing).</p>
     <p><a name="clearCancelFlag"></a></p>
     <h4>void LibRaw::clearCancelFlag()</h4>
     <p>This call clears internal fast cancel flags, so (early) terminated LibRaw
       decoder may work again.</p>
     <p><a name="COLOR"></a></p>
     <h4>int LibRaw::COLOR(int row, int col)</h4>
     <p>This call returns pixel color (color component number) in bayer patter at
       row,col. The returned value is in 0..3 range for 4-component Bayer (RGBG2,
       CMYG and so on) and in 0..2 range for 3-color data.</p>
     <p>Color indexes returned could be used as index in imgdata.idata.cdesc
       string to get color 'name'.</p>
     <p><a name="error_count"></a></p>
     <h4>int LibRaw::error_count()</h4>
     <p>This call returns count of non-fatal data errors (out of range, etc)
       occured in unpack() stage.</p>
     <p><a name="subtract_black"></a></p>
     <h4>int LibRaw::subtract_black()</h4>
     <p>This call will subtract black level values from RAW data (for suitable
       RAW data). <a href="API-datastruct.html#libraw_colordata_t">colordata.data_maximum</a>
       and <strong>colordata.maximum</strong> and black level data (<a href="API-datastruct.html#libraw_colordata_t">colordata.black</a>
       and colordata.cblack) will be adjusted too.</p>
     <p>This call should be used if you postprocess RAW data by your own code.
       LibRaw <a href="#dcrawemu">postprocessing functions</a> will call <strong>subtract_black()</strong>
       by oneself.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
+    <a name="adjust_to_raw_inset_crop"></a>
+    <h4>int LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop =
+      0.55f)</h4>
+    <p> Promotes imgdata.sizes.raw_inset_crops[] values to imgdata.sizes.*margin
+      and imgdata.sizes.width/height fields</p>
+    <p> Parameters<br>
+      mask: </p>
+    <ul>
+      <li>if bit 1 is set: prefer raw_inset_crops[1] </li>
+      <li>if bit 0 is set: prefer raw_inset_crops[0] </li>
+    </ul>
+    <p>maxcrop: limits crop to not less than (original width/height)*maxcrop; if
+      raw_inset_crops[i] data results in tighter crop, than this item is
+      ignored. </p>
+    <p>return value: index in raw_inset_crops[] used increased by one, so </p>
+    <ul>
+      <li>0: no changes made </li>
+      <li>1: [0]th data used </li>
+      <li>2: [1]th data used </li>
+    </ul>
+    <p>Note: this call SHOULD be used after LibRaw::unpack(), otherwise black
+      level calculation from masked area may be fooled resulting in wrong black
+      levels. </p>
     <p><a name="floatingpoint"></a></p>
     <h4>Support for floating point data</h4>
     <p>Libraw can read floating point DNG files (no other RAW formats may use
       floating point) with or without conversion to integer data. Floating point
       values are stored in imgdata.rawdata buffers:</p>
     <ul>
       <li><span style="font-family: monospace;">float * float_image</span> (if
         not NULL) points to floating point bayer data</li>
       <li><span style="font-family: monospace;">float (*float3_image)[3]</span>
         (if not NULL) points to floating point 3-channel buffer</li>
       <li><span style="font-family: monospace;">float (*float4_image)[4]</span>
         (if not NULL) points to floating point 4-channel buffer</li>
     </ul>
     <p>Function calls for floating point support:</p>
     <ul>
       <li><span style="font-family: monospace;">int LibRaw::is_floating_point();
         </span>function will return 1 if file contains floating point data</li>
       <li><span style="font-family: monospace;">int LibRaw::have_fpdata();</span>
         function will return 1 if FP data has read (decoded) into memory and not
         converted to integer data</li>
       <li>int LibRaw::convertFloatToInt(float dmin=4096.f, float dmax=32767.f,
         float dtarget = 16383.f) converts floating point data to integer. If
         data maximum is out of dmin..dmax range, than data scaled to set maximum
         to dtarget</li>
     </ul>
     <p><a name="ycc"></a></p>
     <h4>Support for YCC formats (Canon sRAW/mRAW and Nikon Small NEF)</h4>
     <pre>       int LibRaw::is_sraw();<br>       int LibRaw::is_nikon_sraw();<br>       int LibRaw::sraw_midpoint()</pre>
     <ul>
       <li>is_sraw() call returns nonzero if current image is YCC-based.</li>
       <li>is_nikon_sraw() call returns nonzero for Nikon Small NEF files</li>
       <li>sraw_midpoint() call returns neutral (gray) point for color channels</li>
     </ul>
     <p><a name="recycle_datastream"></a></p>
     <h4>void LibRaw::set_dng_host(void* p)</h4>
     <p>If LibRaw is compiled with Adobe DNG SDK support and you wish to use this
       support:</p>
     <ul>
       <li>you need to create own dng_host object</li>
       <li>and pass it to LibRaw object using this function</li>
     </ul>
     <h4>void LibRaw::recycle_datastream(void)</h4>
     <p>This call closes input datastream with associated data buffer and
       unblocks opened file. <a name="recycle"></a></p>
     <h3>void LibRaw::recycle(void)</h3>
     <p>Frees the allocated data of LibRaw instance, enabling one to process the
       next file using the same processor. Repeated calls of recycle() are quite
       possible and do not conflict with anything.</p>
     <p><a name="~LibRaw"></a></p>
     <h3>LibRaw::~LibRaw()</h3>
     <p>Destructor, which consists in calling recycle().</p>
     <p><a name="strprogress"></a></p>
     <h3>const char* LibRaw::strprogress(enum LibRaw_progress code)</h3>
     <p>Converts progress stage code to description string (in English).</p>
     <p><a name="libraw_strerror"></a></p>
     <h3>const char* LibRaw::strerror(int errorcode)</h3>
     <p>Analog of strerror(3) function: outputs the text descriptions of LibRaw
       error codes (in English).</p>
     <p><a name="callbacks"></a></p>
     <h3>Setting Error Notification Functions</h3>
     <p>In process of RAW conversion LibRaw can call user-setted callback. This
       callback can be used for:</p>
     <ul>
       <li>Dynamic status update (progress bar and so on).</li>
       <li>Cancel of processing (for example, user pressed Cancel button).</li>
     </ul>
     <p>Also, work of the library may cause two types of exceptional situations
       that require notification of the calling application:</p>
     <ul>
       <li>Memory shortage</li>
       <li>Data read error.</li>
     </ul>
     <p>An application may set its own callbacks that will be called in the cases
       mentioned above to notify the user (or the calling program).</p>
     <p><a name="progress"></a></p>
     <h4>Progress indication/processing termination</h4>
     <pre>        typedef int (*progress_callback)(void *callback_data,enum LibRaw_progress stage, int iteration, int expected);<br>        void LibRaw::set_progress_handler(progress_callback func,void *callback_data);<br>    </pre>
     <p>LibRaw user can set own callback which will be called 10-50 times during
       RAW postprocessing by dcraw_process().</p>
     <p>This callback may terminate current image processing by returning of
       non-zero value. In such case all processing will be cancelled immediately
       and all resources will be returned to system by recycle() call. Current
       call of dcraw_process() will return error code
       LIBRAW_CANCELLED_BY_CALLBACK.</p>
     <p>Callback parameters:</p>
     <dl>
       <dt>void *callback_data</dt>
       <dd>void*-pointer, passed as 2nd argument to set_progress_handler(). This
         pointer should be used to pass additional data to callback (i.e. thread
         local data and so on).</dd>
       <dt>enum LibRaw_progress stage</dt>
       <dd>Current processing stage. This number can be converted to string by
         call to <a href="#strprogress">LibRaw::strprogress</a>. Not all
         processing stages are covered by callback calls.</dd>
       <dt>int iteration</dt>
       <dd>Iteration number within current stage (from 0 to expected-1).</dd>
       <dt>int expected</dt>
       <dd>Expected number of iterations on current stage.</dd>
     </dl>
     <p>Callback should return value of: <strong>0</strong> for continue
       processing and <strong>non-zero</strong> for immediate cancel of
       processing.</p>
     <p>&nbsp;</p>
     <p>If LibRaw compiled with OpenMP support, iteration parameter may not
       always increase within one stage. Out of order callback calls are
       possible.</p>
     <p>Callback code sample:</p>
     <pre>int my_progress_callback(void *data,enum LibRaw_progress p,int iteration, int expected)<br>{<br>    char *passed_string = (char *data);<br>    printf("Callback: %s  pass %d of %d, data passed: %s\n",libraw_strprogress(p),iteration,expected,passed_string);<br>    if(timeout || key_pressed )<br>        return 1; // cancel processing immediately<br>    else<br>        return 0; // can continue<br>}</pre>
     <p><a name="exif"></a></p>
     <h4>User-specified exif tag parser callback</h4>
     <pre>       typedef void (*exif_parser_callback) (void *context, int tag, int type, int len,unsigned int ord, void *ifp);<br>       void    LibRaw::set_exifparser_handler( exif_parser_callback cb,void *context);<br>    </pre>
     <p>Callback to be called on each parsed EXIF/Makernotes tag with parameters:</p>
     <ul>
       <li>context - pointer to context passed to set_exifparser_handler();</li>
       <li>tag - EXIF/Makernotes tag value</li>
       <li>type - TIFF(EXIF) tag type</li>
       <li>len - tag length</li>
       <li>ord - byte order (II or MM)</li>
       <li>void *ifp - pointer to LibRaw_abstract_datastream, positioned to tag
         data</li>
     </ul>
-    <p>&nbsp;</p>
     <p><a name="memerror"></a></p>
     <h4>Out-of-Memory Notifier</h4>
     <pre>        typedef void (* memory_callback)(void *callback_data,const char *file, const char *where);<br>        void LibRaw::set_memerror_handler(memory_callback func,void *callback_data);<br>    </pre>
     <p>The user may set his or her own function called in the case of memory
       shortage. It is a void function receiving two string parameters:</p>
     <ul>
       <li><strong>void *callback_data</strong> - void*-pointer, passed as 2nd
         argument to set_progress_handler(). This pointer should be used to pass
         additional data to callback (i.e. thread local data and so on).</li>
       <li><strong>file</strong> is the name of the RAW file whose processing
         evoked the out-of-memory error. This name <strong>can be NULL</strong>
         if underlying data input layer does not know the name. So, if calling
         application sets own callback, this callback should work with NULL file
         name.</li>
       <li><strong>where</strong> is the name of the function where memory
         shortage occurred.</li>
     </ul>
     <p>The callback function is intended for information purposes: it notifies
       the user or the program code that processing is impossible.</p>
     <p>If the user does not set his or her own handler, the standard one (output
       of error message in stderr) will be used.</p>
     <p>One can set the null handler by passing NULL to set_memerror_handler;
       then no notifier function will be called. The same effect can be achieved
       by creating a LibRaw object with the LIBRAW_OPTIONS_NO_MEMERR_CALLBACK
       flag in the contructor.</p>
     <p>In the case of memory shortage, processing of the current file is
       terminated and a notifier is called; all allocated resources are freed,
       and <a href="#recycle">recycle()</a> is performed. The current call will
       return LIBRAW_UNSUFFICIENT_MEMORY. <br>
       At an attempt to continue data processing, all subsequent calls will
       return LIBRAW_OUT_OF_ORDER_CALL. Processing of a new file may be started
       in the usual way, by calling LibRaw::open_file().</p>
     <p><a name="dataerror"></a></p>
     <h4>File Read Error Notifier</h4>
     <pre>        typedef void (*data_callback)(void *callback_data,const char *file, const int offset);<br>        void LibRaw::set_dataerror_handler(data_callback func, void *callback_data); <br>    </pre>
     <p>The user can define his or her own function to be called in the case of
       error in the input data. It is a void function receiving two parameters:</p>
     <ul>
       <li><strong>void *callback_data</strong> - void*-pointer, passed as 2nd
         argument to set_progress_handler(). This pointer should be used to pass
         additional data to callback (i.e. thread local data and so on).</li>
       <li><strong>file</strong> is the name of the RAW file whose processing
         evoked the file read error. This name <strong>can be NULL</strong> if
         underlying data input layer does not know the name. So, if calling
         application sets own callback, this callback should work with NULL file
         name.</li>
       <li><strong>offset</strong> is -1 at end-of-file (if LibRaw expects more
         data) or a positive number equal to the file position (bytes from file
         beginning) where the unpacking error occurred.</li>
     </ul>
     <p>The callback function is intended for information purposes: it notifies
       the user or the program code that processing is impossible.</p>
     <p>If the user does not set his or her own handler, the standard one (output
       of error message in stderr) will be used.</p>
     <p>One can set the null handler by passing NULL to set_memerror_handler;
       then no notifier function will be called. The same effect can be achieved
       by creating a LibRaw object with the LIBRAW_OPTIONS_NO_DATAERR_CALLBACK
       flag in the contructor.</p>
     <p>In the case of error in the input data, processing of the current file is
       terminated and a notifier is called; all allocated resources are freed,
       and <a href="#recycle">recycle()</a> is performed. The current call will
       return LIBRAW_IO_ERROR. <br>
       At an attempt to continue data processing, all subsequent calls will
       return LIBRAW_OUT_OF_ORDER_CALL. Processing of a new file may be started
       in the usual way, by calling LibRaw::open_file().</p>
     <p><a name="dcrawemu"></a></p>
     <h2>Data Postprocessing: Emulation of dcraw Behavior</h2>
     <p>Instead of writing one's own Bayer pattern postprocessing, one can use
       the dcraw functions, which are called after the calls of open_file() +
       unpack() /+ unpack_thumb()/</p>
     <p><a name="dcraw_params"></a></p>
     <h3>Parameter Setting</h3>
     <p>Virtually all parameters that can be set through the dcraw command line
       are specified by assigning values to fields of the <strong>LibRaw::imgdata.params</strong>
       structure. The type of this structure is <strong>libraw_output_params_t</strong>;
       all fields are listed and described in sufficient detail in the <a href="API-datastruct.html#libraw_output_params_t">description
         of data structures</a>.</p>
     <p><a name="raw2image"></a></p>
     <h3>int LibRaw::raw2image</h3>
     <p>This function allocates buffer for postprocessing (imgdata.image) and
       fills it with data layout compatible with LibRaw 0.13/0.14 and below. If
       the buffer is already allocated, it will be free()ed and allocated again.</p>
     <p>This function should be called only if your code do postprocessing stage.
       If you use LibRaw's postprocessing calls (see below) you don't need to
       call raw2image().</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">return
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="free_image"></a></p>
     <h3>void LibRaw::free_image</h3>
     <p>This function releases the imgdata.image buffer allocated by raw2image();</p>
     <p>This method should be called if current postprocessing results are not
       needed by the program (e.g. already copied somewhere), but new
       postprocessing calls (with another settings) are possible, so it is to
       early to call <a href="#recycle">recycle()</a>.</p>
     <p><a name="adjust_sizes_info_only"></a></p>
     <h3>int LibRaw::adjust_sizes_info_only(void)</h3>
     <p>The function calculates the correct size of the output image
       (imgdata.sizes.iwidth and imgdata.sizes.iheight) for the following cases:</p>
     <ul>
       <li>Files from Fuji cameras (with a 45-degree rotation)</li>
       <li>Files from cameras with non-square pixels</li>
       <li>Images shot by a rotated camera.</li>
     </ul>
     <p>In the aforementioned cases, the function changes the fields of the image
       output size; note that this change cannot be repeated again.</p>
     <p><a name="dcraw_process"></a></p>
     <h3>int LibRaw::dcraw_process(void)</h3>
     <p>The function emulates the postprocessing capabilities available in <strong>dcraw</strong>.<br>
       Called after calling LibRaw::unpack();</p>
     <p>The entire functionality of dcraw (set via the field values in <a href="API-datastruct.html#libraw_output_params_t">imgdata.params</a>)
       is supported, except for</p>
     <ul>
       <li>Dark frame subtraction</li>
       <li>Work with bad pixels.</li>
     </ul>
     <p>The function is intended solely for demonstration and testing purposes;
       it is assumed that its source code will be used in most real applications
       as the reference material concerning the order of RAW data processing.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">error
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="dcrawrite"></a></p>
     <h2>Data Output to Files: Emulation of dcraw Behavior</h2>
     <p>In spite of the abundance of libraries for file output in any formats,
       LibRaw includes calls that emulate the file output provided by dcraw. This
       is done primarily for easier verification of library work: the resultant
       files must be binary identical.</p>
     <p><a name="dcraw_ppm_tiff_writer"></a></p>
     <h3>int LibRaw::dcraw_ppm_tiff_writer(const char *outfile)</h3>
     <p>The function outputs the postprocessing results to a file in the PPM/PGM
       or TIFF format (the format is set via imgdata.params.output_tiff). The
       results are binary identical to those provided by dcraw.</p>
     <p>If "-" is passed as outfile, the function will write to standard output
       (stdout).</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">error
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="dcraw_thumb_writer"></a></p>
     <h3>int LibRaw::dcraw_thumb_writer(const char *thumbfile)</h3>
     <p>Writes the thumbnail to a file in the PPM format for bitmap thumbnails
       and in the JPEG format for JPEG thumbnails, i.e., in the format completely
       identical to the results provided by dcraw.</p>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">error
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="memwrite"></a></p>
     <h2>Copying unpacked data into memory buffer</h2>
     <p>There is several function calls for store unpacked data into memory
       buffer (after using dcraw_process() and so on):</p>
     <ul>
       <li><strong>get_mem_image_format</strong> - get resulting bitmap size and
         bit depth.</li>
       <li><strong>copy_mem_image</strong> - copy postprocessed data into some
         memory buffer with different color order and line stride.</li>
       <li><strong>dcraw_make_mem_image</strong> - store processed image data
         into allocated buffer;</li>
       <li><strong>dcraw_make_mem_thumb</strong> - store extracted thumbnail into
         buffer as JPEG-file image (for most cameras) or as RGB-bitmap.</li>
     </ul>
     <p>For usage primer see samples/mem_image.c sample.</p>
     <p>&nbsp;</p>
     <p><a name="get_mem_image_format"></a></p>
     <h3>void get_mem_image_format(int *widthp, int *heightp, int *colorsp, int
       *bpp) const - return processing bitmap size</h3>
     <p>This function returns size of postprocessed image:</p>
     <ul>
       <li>Image width is returned in *widthp;</li>
       <li>Bitmap height is returned in *heightp;</li>
       <li>Image color count is returned in *colorsp;</li>
       <li>Bits per pixel (8 or 16) is returned in *bpp;</li>
     </ul>
     <p><a name="copy_mem_image"></a></p>
     <h3>int LibRaw::copy_mem_image(void* scan0, int stride, int bgr) - copies
       postprocessed bitmap data into buffer</h3>
     <p>Function parameters:</p>
     <ul>
       <li>void *scan0 - pointer to buffer to copy data to. The buffer should be
         at least stride*image_height bytes;</li>
       <li>int stride - stride of each other image line (row) in bytes. Usually
         image_width*(bit_per_pixel/8)*image_colors, but may be more if you wish
         to align image rows to, for example, 8 or 16 or 32 bytes to make CPU
         more happy.</li>
       <li>int bgr - pixel copy order. RGB if bgr==0 and BGR overwise.</li>
     </ul>
     <p>The function returns an integer number in accordance with the <a href="API-notes.html#errors">error
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="dcraw_make_mem_image"></a></p>
     <h3>libraw_processed_image_t *dcraw_make_mem_image(int *errorcode=NULL) -
       store unpacked and processed image into memory buffer as RGB-bitmap</h3>
     <p>This function allocates memory buffer and stores unpacked-preprocessed
       image into this buffer. Function returns allocated structure <a href="API-datastruct.html#libraw_processed_image_t">libraw_processed_image_t</a>
       with filled fields. Always returns data as RGB bitmap (i.e. <strong>type</strong>
       field is equal to LIBRAW_IMAGE_BITMAP).</p>
     <p>dcraw_process() should be called before dcraw_make_mem_image();</p>
     <p>Returns NULL in case of an error. If caller has passed not-NULL value as
       errorcode parameter, than *errorcode will be set to error code according
       to <a href="API-notes.html#errors">error code convention</a>.</p>
     <p><strong>NOTE!</strong> Memory, allocated for return value will not be
       fried at destructor or <strong>LibRaw::recycle</strong> calls. Caller of
       dcraw_make_mem_image should free this memory by call to <a href="#dcraw_clear_mem">LibRaw::dcraw_clear_mem()</a>.</p>
     <p><a name="dcraw_make_mem_thumb"></a></p>
     <h3>libraw_processed_image_t *dcraw_make_mem_thumb(int *errorcode=NULL) -
       store unpacked thumbnail into memory buffer</h3>
     <p>This function allocates memory buffer and stores thumbnail data in it.
       Function returns allocated structure <a href="API-datastruct.html#libraw_processed_image_t">libraw_processed_image_t</a>
       with filled fields. For most RAW images allocated structure will contains
       JPEG image (i.e. <strong>type</strong> field is equal to
       LIBRAW_IMAGE_JPEG). For some cameras with RGB-bitmap thumbnail (Kodak
       SLRs) returned structure contains RGB bitmap (<strong>type</strong> field
       is equal to LIBRAW_IMAGE_JPEG, see structure description for details).</p>
     <p>unpack_thumb() should be called before dcraw_make_mem_thumb();</p>
     <p>Returns NULL in case of an error. If caller has passed not-NULL value as
       errorcode parameter, than *errorcode will be set to error code according
       to ñ <a href="API-notes.html#errors">error code convention</a>.</p>
     <p><strong>NOTE!</strong> Memory, allocated for return value will not be
       fried at destructor or <strong>LibRaw::recycle</strong> calls. Caller of
       dcraw_make_mem_image should free this memory by call to <a href="#dcraw_clear_mem">LibRaw::dcraw_clear_mem()</a>.</p>
     <h3>void LibRaw::dcraw_clear_mem(libraw_processed_image_t *)</h3>
     <p>This function will free the memory allocated by <strong>dcraw_make_mem_image</strong>
       or <strong>dcraw_make_mem_thumb</strong>.</p>
     <p>This is static class member, so call syntax should be
       LibRaw::dcraw_clear_mem(...).</p>
     <p>This call translates directly to free() system function, but it is better
       to use dcraw_clear_mem because LibRaw (DLL) may be compiled with memory
       manager other than in calling application.</p>
     <p><a name="datastream"></a></p>
     <h2>Input layer abstraction</h2>
     <p><a name="LibRaw_abstract_datastream"></a></p>
     <h3>class LibRaw_abstract_datastream - abstract RAW read interface</h3>
     <p>LibRaw reads RAW-data by calling (virtual) methods of C++ object derived
       from <strong>LibRaw_abstract_datastream</strong>. This C++ class does not
       implement any read, but defines interface to be called. Call to base class
       methods always results in error.</p>
     <p><a name="datastream_methods"></a></p>
     <h4>LibRaw_abstract_datastream class methods</h4>
     <p><a name="datastream_methods_utility"></a></p>
     <h5>Object verification</h5>
     <dl>
       <dt><strong> virtual int valid()</strong></dt>
       <dd>Checks input datastream validity. Returns 1 on valid stream and 0 if
         datastream was created on non-valid input parameters (wrong filename for
         file stream and so on).</dd>
     </dl>
     <p><a name="datastream_methods_read"></a></p>
     <h5>Stream read and positioning</h5>
     <p>This group of methods implements file object (FILE*) semantics.</p>
     <dl>
       <dt><strong>virtual int read(void * ptr,size_t size, size_t nmemb)</strong></dt>
       <dd>Similar to fread(ptr,size,nmemb,file).</dd>
       <dt><strong>virtual int seek(off_t o, int whence)</strong></dt>
       <dd>Similar to fseek(file,o,whence).</dd>
       <dt><strong>virtual int tell(</strong></dt>
       <dd>Similar to ftell(file).</dd>
       <dt><strong>virtual int get_char()</strong></dt>
       <dd>Similar to getc(file)/fgetc(file).</dd>
       <dt><strong>virtual char* gets(char *s, int n)</strong></dt>
       <dd>Similar to fgets(s,n,file).</dd>
       <dt><strong>virtual int eof()</strong></dt>
       <dd>Similar to feof(file).</dd>
       <dt><strong>virtual int scanf_one(const char *fmt, void *val)</strong></dt>
       <dd>Simplified variant of fscanf(file,fmt,val): format string is always
         contains one argument to read. So, variable args call is not needed and
         only one pointer to data passed.</dd>
       <dt><strong> virtual int jpeg_src(void * p);</strong></dt>
       <dd>Initializes read structures in j_decompress_ptr object passed as *p.
         This object is used by libjpeg for JPEG data reading from datastream.
         <p>Returns -1 on error and 0 on success.</p>
       </dd>
       <dt><strong> virtual void * make_jas_stream();</strong></dt>
       <dd>Creates LibJasper input stream (for JPEG2000 decoding).
         <p>returns NULL on error or data pointer on success.</p>
       </dd>
     </dl>
     <p><a name="datastream_methods_other"></a></p>
     <h5>Other methods</h5>
     <p>This group of methods includes several supplementary calls. These calls
       are used to temporary switch to another data stream (file and/or memory
       buffer).</p>
     <dl>
       <dt><strong>virtual const char* fname()</strong></dt>
       <dd>Returns name of opened file if datastream object knows it (for
         example, <strong>LibRaw_file_datastream</strong> used). Filename used
         in:
         <ul>
           <li>error notification callbacks;</li>
           <li>generation of filename of JPEG-file with metadata when needed
             (i.e. cameras with 'Diag RAW hack').</li>
         </ul>
       </dd>
       <dt><strong>virtual int subfile_open(const char *fn)</strong></dt>
       <dd>This call temporary switches input to file <strong>fn</strong>.
         Returns 0 on success and error code on error.<br>
         The function used to read metadata from external JPEG file (on cameras
         with "Diag RAW hack"). <br>
         This call is not implemented for <a href="#buffer_datastream">LibRaw_buffer_datastream</a>,
         so external JPEG processing is not possible when buffer datastream used.
         <br>
         This functon should be implemented in real input class, base class call
         always return error. <br>
         Working implementation sample can be found in <a href="#file_datastream">LibRaw_file_datastream</a>
         implementation in <strong>libraw/libraw_datastream.h</strong> file.</dd>
       <dt><strong> virtual void subfile_close()</strong></dt>
       <dd>This call switches input stream from temporary open file back to main
         data stream.</dd>
       <dt><strong> virtual int tempbuffer_open(void *buf, size_t size)</strong></dt>
       <dd>This call temporary switches input to <a href="#buffer_datastream">LibRaw_buffer_datastream</a>
         object, created from <strong>buf</strong>.<br>
         This method is needed for Sony encrypted metadata parser.
         <p>This call implemented in base class (<strong>LibRaw_abstract_datastream</strong>),
           there is no need to reimplement in in derived classes.<br>
           Possible activity of temporary datastream requires very accurate
           programming when implementing datastreams derived from base <strong>LibRaw_abstract_datastream</strong>.
           See <a href="#substream">below</a> for more details.</p>
       </dd>
       <dt><strong> virtual void tempbuffer_close()</strong></dt>
       <dd>This call switch input back from temporary datastream to main stream.
         This call implemented in base <strong>LibRaw_abstract_datastream</strong>
         class.</dd>
     </dl>
     <p><a name="datastream_derived"></a></p>
     <h3>Derived input classes included in LibRaw</h3>
     <p>There is three "standard" input classes in LibRaw distribution:</p>
     <ul>
       <li><a href="#file_datastream">LibRaw_file_datastream</a> implements input
         from file (in filesystem).</li>
       <li><a href="#bigfile_datastream">LibRaw_bigfile_datastream</a> slower
         I/O, but files larger than 2Gb are supported.</li>
       <li><a href="#buffer_datastream">LibRaw_buffer_datastream</a> implements
         input from memory buffer.</li>
     </ul>
     <p>LibRaw C++ interface users can implement their own input classes and use
       them via <a href="#open_datastream">LibRaw::open_datastream</a> call.
       Requirements and implementation specifics are described below.</p>
     <p><a name="file_datastream"></a></p>
     <h4>class LibRaw_file_datastream - file input interface</h4>
     <p>This class implements input from file.</p>
     <p><strong>Class methods:</strong></p>
     <dl>
       <dt><strong> LibRaw_file_datastream(const char *fname) </strong></dt>
       <dd>This constructor creates <strong>LibRaw_file_datastream</strong>
         object from file <strong>fname</strong>.<br>
         Unfortunately, C++ constructor cannot return an error. So if bad
         filename passed (e.g. nonexistent file) object is created as non-valid
         (valid() call returns zero).</dd>
     </dl>
     <p>All other class methods are <a href="#datastream_methods">described
         above</a>.<br>
       This class implements all possble methods, including fname() and
       subfile_open().</p>
     <p><a name="bigfile_datastream"></a></p>
     <h4>class LibRaw_bigfile_datastream - file input interface</h4>
     <p>This class implements input from file.</p>
     <p><strong>Class methods:</strong></p>
     <dl>
       <dt><strong> LibRaw_bigfile_datastream(const char *fname) </strong></dt>
       <dd>This constructor creates <strong>LibRaw_bigfile_datastream</strong>
         object from file <strong>fname</strong>.<br>
         Unfortunately, C++ constructor cannot return an error. So if bad
         filename passed (e.g. nonexistent file) object is created as non-valid
         (valid() call returns zero).</dd>
     </dl>
     <p>The difference between <strong>file</strong> and <strong>bigfile</strong>
       datastreams are obvious from class name: bigfile one supports large files
       (more than 2Gb) on all supported systems. File one uses streambuf
       interface which is limited to 2Gb on many systems.</p>
     <p>All other class methods are <a href="#datastream_methods">described
         above</a>.<br>
       This class implements all possble methods, including fname() and
       subfile_open().</p>
     <p><a name="buffer_datastream"></a></p>
     <h4>class LibRaw_buffer_datastream - memory buffer input interface</h4>
     <p>This class implements input from memory buffer.</p>
     <p><strong>Class methods:</strong></p>
     <dl>
       <dt><strong> LibRaw_buffer_datastream(void *buffer, size_t bsize)</strong></dt>
       <dd>This constructor creates datastream object from <strong>buffer</strong>
         with size <strong>bsize</strong>.<br>
         It is not possibly to verify the pointer passed, so buffer address is
         checked against 0 and -1 only.</dd>
     </dl>
     <p>All other class methods are <a href="#datastream_methods">described
         above</a>.<br>
       This class does not implement fname() and subfile_open() calls, so
       external JPEG metadata parsing is not possible.</p>
     <p><a name="own_datastreams"></a></p>
     <h3>Own datastream derived classes</h3>
     <p>To create own read interface LibRaw user should implement C++ class
       derived from <strong>LibRaw_abstract_datastream</strong> with all read
       methods.<br>
       LibRaw standard implementations may be used as reference. See <strong>libraw/libraw_datastream.h</strong>
       file for details (all standard LibRaw input classes are implemented using
       inline functions only).</p>
     <p><a name="substream"></a></p>
     <p><a href="index.html">[back to Index]</a></p>
   </body>
 </html>
diff --git a/doc/API-datastruct.html b/doc/API-datastruct.html
index ed578710..c5389713 100644
--- a/doc/API-datastruct.html
+++ b/doc/API-datastruct.html
@@ -1,1285 +1,1303 @@
-<html>
-  <head>
-    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
-    <title>LibRaw: Data Structures and Constants</title>
-  </head>
-  <body>
-    <p>LibRaw: Data Structures and Constants <a href="index.html"> [back to
-        Index] </a></p>
-    <h1>LibRaw: Data Structures and Constants</h1>
-    <p>LibRaw data structures are defined in header file libraw/libraw_types.h <br>
-      Constants used in its work are defined in file libraw/libraw_const.h</p>
-    <h2>Contents:</h2>
-    <ol>
-      <li><a href="#datastruct"> Data structures </a>
-        <ol>
-          <li><a href="#libraw_data_t"> libraw_data_t: Main Data Structure in
-              LibRaw </a></li>
-          <li><a href="#libraw_iparams_t"> Structure libraw_iparams_t: Main
-              Parameters of the Image </a></li>
-          <li><a href="#libraw_image_sizes_t"> Structure libraw_image_sizes_t:
-              Image Dimensions </a></li>
-          <li><a href="#libraw_colordata_t"> Structure libraw_colordata_t: Color
-              Information </a></li>
-          <li><a href="#libraw_imgother_t"> Structure libraw_imgother_t: Other
-              Parameters of the Image </a></li>
-          <li><a href="#libraw_rawdata_t"> Structure libraw_rawdata_t: holds
-              unpacked RAW data </a></li>
-          <li><a href="#libraw_thumbnail_t"> Structure libraw_thumbnail_t:
-              Description of Thumbnail </a></li>
-          <li><a href="#libraw_lensinfo_t"> Structure libraw_lensinfo_t - lens
-              data, extracted from EXIF/Makernotes </a></li>
-          <li><a href="#libraw_raw_unpack_params_t"> Structure
-              libraw_raw_unpack_params_t: metadata and raw decoding options and
-              flags</a></li>
-          <li><a href="#libraw_output_params_t"> Structure
-              libraw_output_params_t: Management of dcraw-style postprocessing </a></li>
-          <li><a href="#libraw_callbacks_t">Structure libraw_callbacks_t:
-              user-settable callbacks</a> </li>
-          <li><a href="#libraw_processed_image_t"> Structure
-              libraw_processed_image_t - result set for
-              dcraw_make_mem_image()/dcraw_make_mem_thumb() functions </a></li>
-        </ol>
-      </li>
-      <li><a href="#datastream"> Input abstraction layer </a>
-        <ul>
-          <li><a href="#datastream_data"> Data fields </a></li>
-        </ul>
-      </li>
-      <li><a href="#const"> Constants </a>
-        <ol>
-          <li><a href="#LibRaw_errors"> enum LibRaw_errors: Error Codes </a></li>
-          <li><a href="#decoder_flags"> enum LibRaw_decoder_flags - RAW data
-              format description </a></li>
-          <li><a href="#progress"> enum LibRaw_progress: Current State of LibRaw
-              Object </a></li>
-          <li><a href="#LibRaw_thumbnail_formats"> enum
-              LibRaw_thumbnail_formats: Thumbnail Data Formats </a></li>
-          <li><a href="#warnings"> Nonstandard Situations (Warnings) during RAW
-              Data Processing </a></li>
-          <li><a href="#LibRaw_image_formats"> enum LibRaw_image_formats -
-              possible types of data, contains in libraw_processed_image_t
-              structure</a></li>
-          <li><a href="#LibRaw_processing_options">enum
-              LibRaw_processing_options - flags that affects extracted RAW data</a></li>
-          <li><a href="#LibRaw_rawspecial_t">enum LibRaw_rawspecial_t - special
-              raw extraction modes</a></li>
-        </ol>
-      </li>
-    </ol>
-    <p><a name="datastruct"></a></p>
-    <h2>Data Structures</h2>
-    <p><a name="libraw_data_t"></a></p>
-    <h3>libraw_data_t: Main Data Structure of LibRaw</h3>
-    <p>Structure libraw_data_t is a "wrapping" for data structures accessible to
-      the user of the library. <br>
-      When one uses C++ API, it is accessible as LibRaw::imgdata
-      (class_instance.imgdata). The data in this structure appear after a file
-      is opened through open_file (and other open_ calls), except for the image
-      itself (filled by unpack()) and data containing the preview information
-      (filled by calling unpack_thumb()). </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> unsigned int progress_flags; </strong></dt>
-      <dd>This field records the past <a href="#progress"> phases of image
-          processing </a> .</dd>
-      <dt><strong> unsigned int process_warnings; </strong></dt>
-      <dd>This field records <a href="#warnings"> suspicious situations
-          (warnings) </a> that have emerged during image processing.</dd>
-      <dt><strong> libraw_iparams_t idata; </strong></dt>
-      <dd>The structure describes the main image parameters retrieved from the
-        RAW file. Fields of this structure are described in detail <a href="#libraw_iparams_t">
-          below </a> .</dd>
-      <dt><strong> libraw_image_sizes_t sizes; </strong></dt>
-      <dd>The structure describes the geometrical parameters of the image.
-        Fields of this structure are described in detail <a href="#libraw_image_sizes_t">
-          below </a> .</dd>
-      <dt><strong> libraw_lensinfo_t lens; </strong></dt>
-      <dd>The structure describes lens used for the shot. Fields of this
-        structure are described in detail <a href="#libraw_lensinfo_t"> below </a>
-        .</dd>
-      <dt><strong> libraw_makernotes_t makernotes; </strong></dt>
-      <dd>The structure contains camera/vendor specific metadata extracted from
-        file. No description provided, sorry, if you're interested in particular
-        tag/camera/vendor - use Exiftool documentation as a reference</dd>
-      <dt><strong> libraw_colordata_t color; </strong></dt>
-      <dd>The structure contains color data retrieved from the file. Fields of
-        this structure are described in detail <a href="#libraw_colordata_t">
-          below </a> .</dd>
-      <dt><strong> libraw_imgother_t other; </strong></dt>
-      <dd>Data structure for information purposes: it contains the image
-        parameters that have been extracted from the file but are not needed in
-        further file processing. Fields of this structure are described in
-        detail <a href="#libraw_imgother_t"> below </a> .</dd>
-      <dt><strong> libraw_thumbnail_t thumbnail; </strong></dt>
-      <dd>Data structure containing information on the preview and the preview
-        data themselves. All fields of this structure but thumbnail itself are
-        filled when open_file() is called. Thumbnail readed by unpack_thumb()
-        call. The fields are described in detail <a href="#libraw_thumbnail_t">
-          below </a> .</dd>
-      <dt><strong> libraw_rawdata_t rawdata; </strong></dt>
-      <dd>Data structure with pointer to raw-data buffer. Details are described
-        <a href="#libraw_rawdata_t"> below </a> .</dd>
-      <dt><strong> ushort (*image)[4]; </strong></dt>
-      <dd>The memory area that contains the image pixels per se. It is filled
-        when raw2image() or dcraw_process() is called.</dd>
-      <dt><strong> libraw_output_params_t params; </strong></dt>
-      <dd>Data structure intended for management of image postprocessing (using
-        the dcraw emulator). Fields of this structure are described in detail <a
-          href="#libraw_iparams_t"> below </a> .</dd>
-      <dt>libraw_callbacks_t callbacks;</dt>
-      <dd><a href="#libraw_callbacks_t">user-settable callbacks</a> </dd>
-    </dl>
-    <p><a name="libraw_iparams_t"></a></p>
-    <h3>Structure libraw_iparams_t: Main Parameters of the Image</h3>
-    <dl>
-      <dt><strong> char make[64]; </strong></dt>
-      <dd>Camera manufacturer.</dd>
-      <dt><strong> char model[64]; </strong></dt>
-      <dd>Camera model.</dd>
-      <dt><b>normalized_make[64]</b></dt>
-      <dd> There is a huge number of identical cameras sold under different
-        names, depending on the market (e.g. multiple Panasonic or Canon models)
-        and even some identical cameras sold under different brands (Panasonic
-        -&gt; Leica, Sony -&gt; Hasselblad). normalized_make contains primary
-        vendor name (e.g. Panasonic for Leica re-branded cameras). </dd>
-      <dt><b>normalized_model[64]</b></dt>
-      <dd> Primary camera model name. </dd>
-      <dt><b>unsigned maker_index</b></dt>
-      <dd>Primary vendor name in indexed form (enum LibRaw_cameramaker_index,
-        LIBRAW_CAMERAMAKER_* constant) </dd>
-      <dt><strong> char software[64]; </strong></dt>
-      <dd>Softwary name/version (mostly for DNG files, to distinguish in-camera
-        DNGs from Adobe DNG Converter produced ones).</dd>
-      <dt><strong> unsigned raw_count; </strong></dt>
-      <dd>Number of RAW images in file (0 means that the file has not been
-        recognized).</dd>
-      <dt><strong> unsigned is_foveon; </strong></dt>
-      <dd>Nonzero for Sigma Foveon images</dd>
-      <dt><strong> unsigned dng_version; </strong></dt>
-      <dd>DNG version (for the DNG format).</dd>
-      <dt><strong> int colors; </strong></dt>
-      <dd>Number of colors in the file.</dd>
-      <dt><strong> unsigned filters; </strong></dt>
-      <dd>Bit mask describing the order of color pixels in the matrix (0 for
-        full-color images). 32 bits of this field describe 16 pixels (8 rows
-        with two pixels in each, from left to right and from top to bottom).
-        Each two bits have values 0 to 3, which correspond to four possible
-        colors. Convenient work with this field is ensured by the
-        COLOR(row,column) function, which returns the number of the active color
-        for a given pixel.<br>
-        Values less than 1000 are reserved as special cases:
-        <ul>
-          <li><strong> 1 </strong> - Leaf Catchlight with 16x16 bayer matrix;</li>
-          <li><strong> 9 </strong> - Fuji X-Trans (6x6 matrix)</li>
-          <li>3..8 and 10..999 - are unused.</li>
-        </ul>
-      </dd>
-      <dt><strong> char xtrans[6][6]; </strong></dt>
-      <dt><strong> char xtrans_abs[6][6]; </strong></dt>
-      <dd>These matrices contains Fuji X-Trans row/col to color mapping. First
-        one is relative to visible area, while second is positioned relative to
-        sensor edges.</dd>
-      <dt><strong> char cdesc[5]; </strong></dt>
-      <dd>Description of colors numbered from 0 to 3 (RGBG,RGBE,GMCY, or GBTG).</dd>
-      <dt><strong> unsigned xmplen; char *xmpdata; </strong></dt>
-      <dd>XMP packed data length and pointer to extracted XMP packet.</dd>
-    </dl>
-    <p><a name="libraw_image_sizes_t"></a></p>
-    <h3>Structure libraw_image_sizes_t: Image Dimensions</h3>
-    <p>Structure libraw_image_sizes_t is a collection of all file data that
-      describe the size of the image. </p>
-    <h4> Data fields:</h4>
-    <dl>
-      <dt><strong> ushort raw_height, raw_width; </strong></dt>
-      <dd>Full size of RAW image (including the frame) in pixels.</dd>
-      <dt><strong> ushort height, width; </strong></dt>
-      <dd>Size of visible ("meaningful") part of the image (without the frame).</dd>
-      <dt><strong> ushort top_margin, left_margin; </strong></dt>
-      <dd>Coordinates of the top left corner of the frame (the second corner is
-        calculated from the full size of the image and size of its visible
-        part).</dd>
-      <dt><strong> ushort iheight, iwidth; </strong></dt>
-      <dd>Size of the output image (may differ from height/width for cameras
-        that require image rotation or have non-square pixels).</dd>
-      <dt><strong> unsigned raw_pitch; </strong></dt>
-      <dd>Full size of raw data row <strong> in bytes </strong> .</dd>
-      <dt><strong> double pixel_aspect; </strong></dt>
-      <dd>Pixel width/height ratio. If it is not unity, scaling of the image
-        along one of the axes is required during output.</dd>
-      <dt><strong> int flip; </strong></dt>
-      <dd>Image orientation (0 if does not require rotation; 3 if requires
-        180-deg rotation; 5 if 90 deg counterclockwise, 6 if 90 deg clockwise).</dd>
-    </dl>
-    <p><a name="libraw_colordata_t"></a></p>
-    <h3>Structure libraw_colordata_t: Color Information</h3>
-    <p>Structure libraw_colordata_t unites all color data, both retrieved from
-      the RAW file and calculated on the basis of the image itself. For
-      different cameras, there are different ways of color handling. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> ushort curve[0x10000]; </strong></dt>
-      <dd>Camera tone curve. May be read from file as is, or calculated,
-        depending on file format;</dd>
-      <dt><strong> unsigned black; </strong></dt>
-      <dd>Black level. Depending on the camera, it may be zero (this means that
-        black has been subtracted at the unpacking stage or by the camera
-        itself), calculated at the unpacking stage, read from the RAW file, or
-        hardcoded.</dd>
-      <dt><strong> unsigned cblack[4102]; </strong></dt>
-      <dd>Per-channel black level correction. First 4 values are per-channel
-        correction, next two are black level pattern block size, than
-        cblack[4]*cblack[5] correction values (for indexes
-        [6....6+cblack[4]*cblack[5]).</dd>
-      <dt><strong> unsigned data_maximum; </strong></dt>
-      <dd>Maximum pixel value in current file. Calculated at raw2image or
-        dcraw_process() calls.</dd>
-      <dt><strong> unsigned maximum; </strong></dt>
-      <dd>Maximum pixel value. Calculated from the data for most cameras,
-        hardcoded for others. This value may be changed on postprocessing stage
-        (when black subtraction performed) and by automated maximum adjustment
-        (this adjustment performed if <strong> params.adjust_maximum_thr </strong>
-        is set to nonzero).</dd>
-      <dt><strong> unsigned linear_max[4]; </strong></dt>
-      <dd>Per-channel linear data maximum read from file metadata. If RAW file
-        does not contains this data, linear_max[] is set to zero. Black value is
-        not subtracted</dd>
-      <dt><strong> float fmaximum; </strong></dt>
-      <dd>Maximum pixel value in real image for floating data files.</dd>
-      <dt><strong> float fnorm; </strong></dt>
-      <dd>Normalization coefficient used while converting floating point raw
-        data to integer.</dd>
-      <dt><strong> ushort white[8][8]; </strong></dt>
-      <dd>Block of white pixels extracted from files CIFF/CRW. Not extracted for
-        other formats. Used to calculate white balance coefficients.</dd>
-      <dt><strong> float cam_xyz[4][3]; </strong></dt>
-      <dd>Camera RGB - XYZ conversion matrix. This matrix is constant (different
-        for different models). Last row is zero for RGB cameras and non-zero for
-        different color models (CMYG and so on).</dd>
-      <dt><strong> float cam_mul[4]; </strong></dt>
-      <dd>White balance coefficients (as shot). Either read from file or
-        calculated.</dd>
-      <dt><strong> float pre_mul[4]; </strong></dt>
-      <dd>White balance coefficients for daylight (daylight balance). Either
-        read from file, or calculated on the basis of file data, or taken from
-        hardcoded constants.</dd>
-      <dt><strong> float cmatrix[3][4]; </strong></dt>
-      <dd>Camera color data read from RAW file (if any)</dd>
-      <dt><strong> float rgb_cam[3][4]; </strong></dt>
-      <dd>Camera to sRGB conversion matrix</dd>
-      <dt><strong> float ccm[3][4]; </strong></dt>
-      <dd>Camera color correction matrix readed from file metadata (uniform
-        matrix if no such data in file)</dd>
-      <dt><strong> ph1_t phase_one_data; </strong></dt>
-      <dd>Color data block that is read for Phase One cameras.</dd>
-      <dt><strong> float flash_used; </strong></dt>
-      <dt><strong> float canon_ev; </strong></dt>
-      <dd>Fields used for white balance calculations (for some P&amp;S Canon
-        cameras).</dd>
-      <dt><strong> char model2[64]; </strong></dt>
-      <dd>Firmware revision (for some cameras).</dd>
-      <dt><strong> char UniqueCameraModel[64],LocalizedCameraModel[64]; </strong></dt>
-      <dd>Values from DNG tags with same names.</dd>
-      <dt><strong> void *profile; </strong></dt>
-      <dd>Pointer to the retrieved ICC profile (if it is present in the RAW
-        file).</dd>
-      <dt><strong> unsigned profile_length; </strong></dt>
-      <dd>Length of ICC profile in bytes.</dd>
-      <dt><strong> unsigned black_stat[8]; </strong></dt>
-      <dd>Black level statistics if calcluated from masked area: 4 sum of pixel
-        values, than 4 pixel counts (per channel).</dd>
-      <dt><strong> libraw_dng_color_t dng_color[2]; </strong></dt>
-      <dd>Color data read from DNG: illuminant, calbiration matrix and color
-        matrix for two light sources. (see DNG specs for details).</dd>
-      <dt>libraw_dng_levels_t dng_levels</dt>
-      <dd>DNG black/white levels, analog balance, WB for active IFD. See DNG
-        specs for details.</dd>
-      <dt>int WB_Coeffs[256][4]</dt>
-      <dd>Index: EXIF color source value, [i][0..3] WB Coeffs</dd>
-      <dt>float WBCT_Coeffs[64][5]</dt>
-      <dd>Color temperature in [i][0], WB coeffs in [i][1..4]</dd>
-      <dt>int as_shot_wb_applied</dt>
-      <dd>Set to 1 if WB already applied in camera (multishot modes; small raw)</dd>
-      <dt>libraw_P1_color_t P1_color[2]</dt>
-      <dd>Phase-one specific color data</dd>
-      <dt>unsigned raw_bps</dt>
-      <dd>RAW bits per pixel (PhaseOne: Raw format used)</dd>
-      <dt>int ExifColorSpace</dt>
-      <dd>EXIF color space parsed from EXIF tags: LIBRAW_COLORSPACE_Unknown,
-        LIBRAW_COLORSPACE_sRGB, or LIBRAW_COLORSPACE_Adobe</dd>
-    </dl>
-    <p><a name="libraw_imgother_t"></a></p>
-    <h3>Structure libraw_imgother_t: Other Parameters of the Image</h3>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> float iso_speed; </strong></dt>
-      <dd>ISO sensitivity.</dd>
-      <dt><strong> float shutter; </strong></dt>
-      <dd>Shutter speed.</dd>
-      <dt><strong> float aperture; </strong></dt>
-      <dd>Aperture.</dd>
-      <dt><strong> float focal_len; </strong></dt>
-      <dd>Focal length.</dd>
-      <dt><strong> time_t timestamp; </strong></dt>
-      <dd>Date of shooting.</dd>
-      <dt><strong> unsigned shot_order; </strong></dt>
-      <dd>Serial number of image.</dd>
-      <dt><strong> unsigned gpsdata[32]; </strong></dt>
-      <dd>GPS data (unparsed block, to write to output as is).</dd>
-      <dt><strong> libraw_gps_info_t parsed_gps; </strong></dt>
-      <dd>Parsed GPS-data: longitude/latitude/altitude and time stamp.</dd>
-      <dt><strong> char desc[512]; </strong></dt>
-      <dd>Image description.</dd>
-      <dt><strong> char artist[64]; </strong></dt>
-      <dd>Author of image.</dd>
-      <dt><strong> float FlashEC; </strong></dt>
-      <dd>Flash exposure compensation.</dd>
-    </dl>
-    <p><a name="libraw_rawdata_t"></a></p>
-    <h3>Structure libraw_rawdata_t: holds unpacked RAW data</h3>
-    <p>Structure libraw_rawdata_t holds:</p>
-    <ul>
-      <li>RAW-data from sensor, readed and unpacked by the <a href="API-CXX.html#unpack">
-          unpack() </a> call.</li>
-      <li>"backup" copy of color and over data modified during postprocessing.
-        When postprocessing calls repeats, the needed data is restored from this
-        backup.</li>
-    </ul>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt>void *raw_alloc;</dt>
-      <dd>Buffer allocated to hold RAW-data</dd>
-      <dt><strong> unsigned short *raw_image; </strong></dt>
-      <dd>Pointer to buffer with one-component (bayer) data.</dd>
-      <dt><strong> unsigned short (*color3_image)[3]; </strong></dt>
-      <dd>Pointer to 3-component pixel array.</dd>
-      <dt><strong> unsigned short (*color4_image)[4]; </strong></dt>
-      <dd>Pointer to buffer with 4-component pixel data data</dd>
-      <dt><strong> float *float_image; </strong></dt>
-      <dd>Pointer to buffer with one-component (bayer) data in FP-format.</dd>
-      <dt><strong> float (*float3_image)[3]; </strong></dt>
-      <dd>Pointer to 3-component FP pixel array.</dd>
-      <dt><strong> float (*float4_image)[4]; </strong></dt>
-      <dd>Pointer to buffer with 4-component pixel data data</dd>
-    </dl>
-    <p>After call to <a href="API-CXX.html#unpack"> unpack() </a> only one of
-      these fields is non-NULL.</p>
-    <p>All other fields of this structure are for internal use and should not be
-      touched by user code. <a name="libraw_thumbnail_t"></a></p>
-    <h3>Structure libraw_thumbnail_t: Description of Thumbnail</h3>
-    <p>Structure libraw_thumbnail_t describes all parameters associated with the
-      preview saved in the RAW file. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> LibRaw_thumbnail_formats tformat; </strong></dt>
-      <dd>Thumbnail data format. One of the values among enum <a href="#LibRaw_thumbnail_formats">
-          LibRaw_thumbnail_formats </a> .</dd>
-      <dt><strong> ushort twidth, theight; </strong></dt>
-      <dd>Dimensions of the preview image in pixels.</dd>
-      <dt><strong> unsigned tlength; </strong></dt>
-      <dd>Thumbnail length in bytes.</dd>
-      <dt><strong> int tcolors; </strong></dt>
-      <dd>Number of colors in the preview.</dd>
-      <dt><strong> char *thumb; </strong></dt>
-      <dd>Pointer to thumbmail, extracted from the data file.</dd>
-    </dl>
-    <p><a name="libraw_lensinfo_t"></a></p>
-    <h3>Structure libraw_lensinfo_t: parsed lens data</h3>
-    <p>The following parameters are extracted from Makernotes and EXIF, to help
-      identify which lens was mounted on the camera. If the value is missing in
-      Makernotes or EXIF, the parameter is set to zero with some exceptions
-      noted below. In some cases the values for the fields like CameraFormat and
-      CameraMount are set based on the camera model and/or camera ID.</p>
-    <h4>libraw_makernotes_lens_t structure:</h4>
-    <ul>
-      <li><strong>LensID</strong> (if not -1) and <strong>CamID</strong>
-        (camera id, if non-zero) values are compatible with those used in
-        exiftool, like |0x0010 CanonModelID| and |22 LensType| see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Canon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html</a>
-        or 0x0207/CameraType and 0x0201/LensType (see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.htmlhttp://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Olympus.html</a>
-        )</li>
-      <li><strong>Lens</strong> string, if not empty, contains the lens name
-        present in Makernotes.</li>
-      <li><strong>LensFormat </strong>and <strong>CameraFormat</strong>
-        currently provide one of value from <strong>enum LibRaw_camera_formats</strong>;</li>
-      <li>In a similar manner, values for <strong>LensMount</strong> and <strong>CameraMount</strong>
-        follow the <strong>enum LibRaw_camera_mounts</strong>;</li>
-      <li>In some cases, the Makernotes for MF cameras contain either an id for
-        the body, or a string containing the name of the body. The name is
-        copied to <strong>body</strong> field, while the id is converted to the
-        appropriate body name and also copied to 'body' field. In other cases
-        the 'body' field is empty.</li>
-      <li><strong>FocalType</strong> is set based on Makernotes tag, if present.
-        The values are: </li>
-      <ul>
-        <li>-1 Undefined</li>
-        <li>0 Unknown;</li>
-        <li>1 Fixed focal length lens</li>
-        <li>2 Zoom lens</li>
-      </ul>
-      <li><strong>LensFeatures_pre</strong> - lens name prefix and <strong>LensFeatures_suf</strong>
-        - lens name suffix: (if not empty) some cameras record alphabet soup
-        that characterizes the lens in separate Makernote tags (see, for
-        example, 0xb02a LensSpec at&nbsp;<a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Sony.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Sony.html</a>
-        ), and for some lenses those acronyms can be derived from the 'Lens'
-        field itself (see processCanonCameraInfo). Those can also help better
-        lens identification.</li>
-      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
-        non-zero, contain the minimum and maximum focal lengths for the lens
-        mounted on the camera.</li>
-      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong>, <strong>MinAp4MinFocal</strong>,
-        <strong>MinAp4MaxFocal</strong> - if non-zero, contain maximum aperture
-        available at minimal focal length, maximum aperture available at maximum
-        focal length, minimum aperture available at minimal focal length,
-        minimum aperture available at maximum focal length, respectively.</li>
-      <li><strong>MaxAp</strong> and <strong>MinAp</strong>, if non-zero,
-        contain the maximum aperture for the lens (usually it is the maximum
-        aperture for minimal focal length) and the minimum aperture across the
-        focal length range. For zooms with variable maximum aperture this is
-        usually the minimum aperture for the maximum focal length.</li>
-      <li><strong>CurFocal</strong>, if non-zero, is current focal length - that
-        is the focal length used to take the shot.</li>
-      <li><strong>CurAp</strong>, if non-zero, is current aperture.</li>
-      <li><strong>MaxAp4CurFocal</strong> and <strong>MinAp4CurFocal</strong>,
-        if non-zero, contain the minimum and maximum apertures for the current
-        focal length.</li>
-      <li><strong>LensFStops</strong> - if non-zero, contains the number of
-        aperture "clicks" or the number of f-stops, depending on the model of
-        the camera.</li>
-      <li><strong>TeleconverterID</strong>, <strong>AdapterID</strong>, <strong>AttachmentID</strong>,
-        if non-zero, are the numbers extracted from Makernotes to identify lens
-        accessories used to take the shot.</li>
-      <li><strong>Teleconverter</strong>, <strong>Adapter</strong>, <strong>Attachment</strong>,
-        if non-empty, are the strings containing the names of the accessories as
-        they appear in Makernotes, or for some cameras, decoded from a numeric
-        field in Makernotes.</li>
-      <li><strong>FocalUnits</strong> - an auxiliary field, should not be needed
-        most of the cases. See Canon.pm module in exiftool for more information
-        on this value.</li>
-      <li><strong>FocalLengthIn35mmFormat</strong>, if non-zero: for some reason
-        certain Samsung cameras record this value in Makernotes instead of the
-        EXIF proper. Also used for Sigma cameras.</li>
-    </ul>
-    <h4>libraw_nikonlens_t structure:</h4>
-    <p>Contains additional parameters needed to identify the lens on a Nikon
-      camera using a table - please see Nikon LensID Values at <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Nikon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Nikon.html</a></p>
-    <h4>libraw_dnglens_t structure:</h4>
-    <p>Contains minimum focal length, maximum focal length, maximum aperture
-      available at minimal focal length, and maximum aperture available at
-      maximum focal length, extracted from EXIF field of a DNG raw file.</p>
-    <h4>libraw_lensinfo_t structure:</h4>
-    <p>Contains all the structures described above, plus parameters extracted
-      directly from EXIF fields:</p>
-    <ul>
-      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
-        non-zero, contain the minimum and maximum focal lengths for the lens
-        mounted on the camera.</li>
-      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong> - if
-        non-zero, contain maximum aperture available at minimal focal length and
-        maximum aperture available at maximum focal length</li>
-      <li><strong>LensMake</strong>, if not empty, contains a string with the
-        lens manufacturer name.</li>
-      <li><strong>Lens</strong>, if not empty, contains the lens name as
-        recorded in EXIF</li>
-      <li><strong>FocalLengthIn35mmFormat</strong> - if non-zero, same as
-        FocalLengthIn35mmFilm in EXIF standard, tag 0xa405.</li>
-      <li><strong>EXIF_MaxAp</strong> - if non-zero, contains the value derived
-        from EXIF tag 0x9205.</li>
-    </ul>
-    <p><a name="libraw_raw_unpack_params_t"></a></p>
-    <h3>Structure libraw_raw_unpack_params_t: RAW decoding options and flags</h3>
-    <p>Structure libraw_raw_unpack_params_t contains fields/flags that affects
-      RAWdata and metadata decoding</p>
-    <dl>
-      <dt><strong> int options </strong></dt>
-      <dd>Processing options used on unpack() phase for specific image formats,
-        see below for possible values:<a href="#LibRaw_processing_options">
-          LibRaw_processing_options</a></dd>
-      <dt><strong> int specials </strong></dt>
-      <dd>Special processing mode (e.g. omit YCC to RGB conversion), see below
-        for possible values. <a href="#LibRaw_rawspecial_t">
-          LibRaw_rawspecial_t</a></dd>
-      <dt><strong>int max_raw_memory_mb</strong></dt>
-      <dd>Stop processing if raw buffer size grows larger than that value (in
-        megabytes). Default is LIBRAW_MAX_ALLOC_MB_DEFAULT (2048Mb)</dd>
-      <dt><strong> int sony_arw2_posterization_thr </strong></dt>
-      <dd>If LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE used for
-        raw_processing_options, sets the level to suppress posterization display
-        in shadows.</dd>
-      <dt><strong> float coolscan_nef_gamma; </strong></dt>
-      <dd>Gamma value for Coolscan NEF decoding (no way to get if from file, it
-        should be set by calling application).</dd>
-      <dt><strong> char p4shot_order[5]; </strong></dt>
-      <dd>Shot order for Pentax 4shot files. Default is "3102".</dd>
-    </dl>
-    <h3></h3>
-    <h3>Structure libraw_output_params_t: management of dcraw-style
-      postprocessing</h3>
-    <p>Structure libraw_output_params_t (imgdata.params) is used for management
-      of dcraw-compatible calls dcraw_process(), dcraw_ppm_tiff_writer(), and
-      dcraw_thumb_writer(). Fields of this structure correspond to command line
-      keys of dcraw. </p>
-    <h4> Data fields:</h4>
-    <dl>
-      <dt><strong> unsigned greybox[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -A x y w h <br>
-        4 numbers corresponding to the coordinates (in pixels) of the rectangle
-        that is used to calculate the white balance. X and Y are coordinates of
-        the left-top rectangle corner; w and h are the rectangle's width and
-        height, respectively.</dd>
-      <dt><strong> unsigned cropbox[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        This field sets the image cropping rectangle. Cropbox[0] and cropbox[1]
-        are the rectangle's top-left corner coordinates, remaining two values
-        are width and height respectively. All coordinates are applied before
-        any image rotation.</dd>
-      <dt><strong> double aber[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -C <br>
-        Correction of chromatic aberrations; the only specified values are <br>
-        aber[0], the red multiplier <br>
-        aber[2], the blue multiplier. For some formats, it affects <a href="API-notes.html">
-          RAW data reading </a> , since correction of aberrations changes the
-        output size.</dd>
-      <dt><strong> double gamm[6]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -g power toe_slope <br>
-        Sets user gamma-curve. Library user should set first two fields of gamm
-        array: <br>
-        gamm[0] - <strong> inverted </strong> gamma value) <br>
-        gamm[1] - slope for linear part (so called toe slope). Set to zero for
-        simple power curve. <br>
-        Remaining 4 values are filled automatically.<br>
-        By default settings for rec. BT.709 are used: power 2.222 (i.e.
-        gamm[0]=1/2.222) and slope 4.5. For sRGB curve use gamm[0]=1/2.4 and
-        gamm[1]=12.92, for linear curve set gamm[0]/gamm[1] to 1.0. </dd>
-      <dt><strong> float user_mul[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -r mul0 mul1 mul2 mul3 <br>
-        4 multipliers (r,g,b,g) of the user's white balance.</dd>
-      <dt><strong> unsigned shot_select; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -s <br>
-        Selection of image number for processing (for formats that contain
-        several RAW images in one file).</dd>
-      <dt><strong> float bright; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -b <br>
-        Brightness (default 1.0).</dd>
-      <dt><strong> float threshold; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -n <br>
-        Parameter for noise reduction through wavelet denoising.</dd>
-      <dt><strong> int half_size; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -h <br>
-        Outputs the image in 50% size. For some formats, it affects <a href="API-notes.html">
-          RAW data reading </a> .</dd>
-      <dt><strong> int four_color_rgb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -f <br>
-        Switches on separate interpolations for two green components.</dd>
-      <dt><strong> int highlight; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -H <br>
-        0-9: Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild).</dd>
-      <dt><strong> int use_auto_wb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -a <br>
-        Use automatic white balance obtained after averaging over the entire
-        image.</dd>
-      <dt><strong> int use_camera_wb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -w <br>
-        If possible, use the white balance from the camera.
-        <p> If camera-recorded WB is not available, dcraw_process() will
-          fallback to: </p>
-        <ul>
-          <li>Auto-WB if bit LIBRAW_PROCESSING_CAMERAWB_FALLBACK_TO_DAYLIGHT is
-            not set in params.raw_processing_options (or for the rare specific
-            case: no valid WB index was parsed from CRW file) </li>
-          <li>Daylight-WB if abovementioned bit is not set. </li>
-        </ul>
-      </dd>
-      <dt><strong> int use_camera_matrix; </strong></dt>
-      <dd><strong> dcraw keys: </strong> +M/-M <br>
-        <ul>
-          <li>0: do not use embedded color profile</li>
-          <li>1 (default): use embedded color profile (if present) for DNG files
-            (always); for other files only if use_camera_wb is set;</li>
-          <li>3: use embedded color data (if present) regardless of white
-            balance setting.</li>
-        </ul>
-      </dd>
-      <dt><strong> int output_color; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -o <br>
-        [0-8] Output colorspace (raw, sRGB, Adobe, Wide, ProPhoto, XYZ, ACES, DCI-P3, Rec. 2020).</dd>
-      <dt><strong> char* output_profile; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -o filename <br>
-        Path to output profile ICC file (used only if LibRaw compiled with LCMS
-        support)</dd>
-      <dt><strong> char* camera_profile; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -p file <br>
-        Path to input (camera) profile ICC file (or 'embed' for embedded
-        profile). Used only if LCMS support compiled in.</dd>
-      <dt><strong> char* bad_pixels; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -P file <br>
-        Path to file with bad pixels map (in dcraw format: "column row
-        date-of-pixel-death-in-UNIX-format", one pixel per row).</dd>
-      <dt><strong> char* dark_frame; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -K file <br>
-        Path to dark frame file (in 16-bit PGM format)</dd>
-      <dt><strong> int output_bps; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -4 <br>
-        8 bit (default)/16 bit (key -4).</dd>
-      <dt><strong> int output_tiff; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -T <br>
-        0/1: output PPM/TIFF.</dd>
-      <dt><strong> int output_flags; </strong></dt>
-      <dd><strong> dcraw keys:</strong> none<br>
-        Bitfield that allows to set output file options:
-        <ul>
-          <li><strong>LIBRAW_OUTPUT_FLAGS_PPMMETA</strong> - write additional
-            metadata into PPM/PGM output files</li>
-        </ul>
-      </dd>
-      <dt><strong> int user_flip; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -t <br>
-        [0-7] Flip image (0=none, 3=180, 5=90CCW, 6=90CW). Default -1, which
-        means taking the corresponding value from RAW. <br>
-        For some formats, <a href="API-notes.html"> affects RAW data reading </a>
-        , e.g., unpacking of thumbnails from Kodak cameras.</dd>
-      <dt><strong> int user_qual; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -q <br>
-        0-10: interpolation quality:
-        <ul>
-          <li>0 - linear interpolation</li>
-          <li>1 - VNG interpolation</li>
-          <li>2 - PPG interpolation</li>
-          <li>3 - AHD interpolation</li>
-          <li>4 - DCB interpolation</li>
-          <li>11 - DHT intepolation</li>
-          <li>12 - Modified AHD intepolation (by Anton Petrusevich)</li>
-        </ul>
-      </dd>
-      <dt><strong> int user_black; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -k <br>
-        User black level.</dd>
-      <dt><strong> int user_cblack[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Per-channel corrections to user_black.</dd>
-      <dt><strong> int user_sat; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -S <br>
-        Saturation adjustment.</dd>
-      <dt><strong> int med_passes; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -m <br>
-        Number of median filter passes.</dd>
-      <dt><strong> int no_auto_bright; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -W <br>
-        Don't use automatic increase of brightness by histogram.</dd>
-      <dt><strong> float auto_bright_thr; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Portion of clipped pixels when auto brighness increase is used. Default
-        value is 0.01 (1%) for dcraw compatibility. Recommended value for modern
-        low-noise multimegapixel cameras depends on shooting style. Values in
-        0.001-0.00003 range looks reasonable.</dd>
-      <dt><strong> float adjust_maximum_thr; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        This parameters controls auto-adjusting of maximum value based on
-        channel_maximum[] data, calculated from real frame data. If calculated
-        maximum is greater than adjust_maximum_thr*maximum, than maximum is set
-        to calculated_maximum. <br>
-        Default: 0.75. If you set this value above 0.99999, than default value
-        will be used. If you set this value below 0.00001, than no maximum
-        adjustment will be performed. <br>
-        Adjusting maximum should not damage any picture (esp. if you use default
-        value) and is very useful for correcting channel overflow problems
-        (magenta clouds on landscape shots, green-blue highlights for indoor
-        shots).</dd>
-      <dt><strong> int use_fuji_rotate; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -j <br>
-        Default -1 (use), 0 - don't use rotation for cameras on a Fuji sensor.</dd>
-      <dt><strong> int green_matching; </strong></dt>
-      <dd>Turns on fixing of green channels disbalance. <strong> dcraw keys: </strong>
-        none <br>
-        Default: 0 (not use), 1 - turns on this postprocessing stage.
-        green_matching requires additional memory for image data.</dd>
-      <dt><strong> int dcb_iterations </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Number of DCB correction passes. Default is -1 (no correction). Useful
-        only for DCB interpolation.</dd>
-      <dt><strong> int dcb_enhance_fl </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        nonzero: DCB interpolation with enhance interpolated colors.</dd>
-      <dt><strong> int fbdd_noiserd </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Controls FBDD noise reduction before demosaic.
-        <ul>
-          <li>0 - do not use FBDD noise reduction</li>
-          <li>1 - light FBDD reduction</li>
-          <li>2 (and more) - full FBDD reduction</li>
-        </ul>
-      </dd>
-      <dt><strong> int exp_correc; float exp_shift,exp_preser; </strong></dt>
-      <dd>Exposure correction before demosaic. <br>
-        <ul>
-          <li>exp_correc: positive value turns the feature on (default: off).</li>
-          <li>exp_shift: exposure shift in linear scale. Usable range from 0.25
-            (2-stop darken) to 8.0 (3-stop lighter). Default: 1.0 (no exposure
-            shift).</li>
-          <li>exp_preser: preserve highlights when lighten the image. Usable
-            range from 0.0 (no preservation) to 1.0 (full preservation). 0.0 is
-            the default value.</li>
-        </ul>
-      </dd>
-      <dt><strong> int use_rawspeed; </strong></dt>
-      <dd>Turns on using RawSpeed library for data unpacking (only if RawSpeed
-        support compiled in).</dd>
-      <dt><strong>int use_dng_sdk; </strong></dt>
-      <dd>Turns on using Adobe DNG SDK (if compiled with it and dng host is set:
-        <br>
-        <ul>
-          <li>0 - do not use</li>
-          <li>1 - use for speciality formats (Float, Linear DNG, deflate
-            compression, 8 bit)</li>
-          <li>2 - use for all DNG files</li>
-        </ul>
-      </dd>
-      <dt><strong> int no_auto_scale; </strong></dt>
-      <dd>Disables pixel values scaling (call to LibRaw::scale_colors()) in
-        LibRaw::dcraw_process().<br>
-        This is <strong>special use value</strong> because white balance is
-        performed in scale_colors(), so skipping it will result in non-balanced
-        image.<br>
-        This setting is targeted to use with no_interpolation, or with own
-        interpolation callback call.</dd>
-      <dt><strong> int no_interpolation; </strong></dt>
-      <dd>Disables call to demosaic code in LibRaw::dcraw_process()</dd>
-    </dl>
-    <p><a name="libraw_callbacks_t"></a></p>
-    <h3>Structure libraw_callbacks_t: user-settable callbacks</h3>
-    <dl>
-      <dt>memory_callback mem_cb</dt>
-      <dd>Called on memory allocation error. Settable via set_memerror_handler.
-        See <a href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
-      <dt>data_callback data_cb</dt>
+<html>
+  <head>
+    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
+    <title>LibRaw: Data Structures and Constants</title>
+  </head>
+  <body>
+    <p>LibRaw: Data Structures and Constants <a href="index.html"> [back to
+        Index] </a></p>
+    <h1>LibRaw: Data Structures and Constants</h1>
+    <p>LibRaw data structures are defined in header file libraw/libraw_types.h <br>
+      Constants used in its work are defined in file libraw/libraw_const.h</p>
+    <h2>Contents:</h2>
+    <ol>
+      <li><a href="#datastruct"> Data structures </a>
+        <ol>
+          <li><a href="#libraw_data_t"> libraw_data_t: Main Data Structure in
+              LibRaw </a></li>
+          <li><a href="#libraw_iparams_t"> Structure libraw_iparams_t: Main
+              Parameters of the Image </a></li>
+          <li><a href="#libraw_image_sizes_t"> Structure libraw_image_sizes_t:
+              Image Dimensions </a></li>
+          <li><a href="#libraw_colordata_t"> Structure libraw_colordata_t: Color
+              Information </a></li>
+          <li><a href="#libraw_imgother_t"> Structure libraw_imgother_t: Other
+              Parameters of the Image </a></li>
+          <li><a href="#libraw_rawdata_t"> Structure libraw_rawdata_t: holds
+              unpacked RAW data </a></li>
+          <li><a href="#libraw_thumbnail_t"> Structure libraw_thumbnail_t:
+              Description of Thumbnail </a></li>
+          <li><a href="#libraw_lensinfo_t"> Structure libraw_lensinfo_t - lens
+              data, extracted from EXIF/Makernotes </a></li>
+          <li><a href="#libraw_raw_unpack_params_t"> Structure
+              libraw_raw_unpack_params_t: metadata and raw decoding options and
+              flags</a></li>
+          <li><a href="#libraw_output_params_t"> Structure
+              libraw_output_params_t: Management of dcraw-style postprocessing </a></li>
+          <li><a href="#libraw_callbacks_t">Structure libraw_callbacks_t:
+              user-settable callbacks</a> </li>
+          <li><a href="#libraw_processed_image_t"> Structure
+              libraw_processed_image_t - result set for
+              dcraw_make_mem_image()/dcraw_make_mem_thumb() functions </a></li>
+        </ol>
+      </li>
+      <li><a href="#datastream"> Input abstraction layer </a>
+        <ul>
+          <li><a href="#datastream_data"> Data fields </a></li>
+        </ul>
+      </li>
+      <li><a href="#const"> Constants </a>
+        <ol>
+          <li><a href="#LibRaw_errors"> enum LibRaw_errors: Error Codes </a></li>
+          <li><a href="#decoder_flags"> enum LibRaw_decoder_flags - RAW data
+              format description </a></li>
+          <li><a href="#progress"> enum LibRaw_progress: Current State of LibRaw
+              Object </a></li>
+          <li><a href="#LibRaw_thumbnail_formats"> enum
+              LibRaw_thumbnail_formats: Thumbnail Data Formats </a></li>
+          <li><a href="#warnings"> Nonstandard Situations (Warnings) during RAW
+              Data Processing </a></li>
+          <li><a href="#LibRaw_image_formats"> enum LibRaw_image_formats -
+              possible types of data, contains in libraw_processed_image_t
+              structure</a></li>
+          <li><a href="#LibRaw_processing_options">enum
+              LibRaw_processing_options - flags that affects extracted RAW data</a></li>
+          <li><a href="#LibRaw_rawspecial_t">enum LibRaw_rawspecial_t - special
+              raw extraction modes</a></li>
+        </ol>
+      </li>
+    </ol>
+    <p><a name="datastruct"></a></p>
+    <h2>Data Structures</h2>
+    <p><a name="libraw_data_t"></a></p>
+    <h3>libraw_data_t: Main Data Structure of LibRaw</h3>
+    <p>Structure libraw_data_t is a "wrapping" for data structures accessible to
+      the user of the library. <br>
+      When one uses C++ API, it is accessible as LibRaw::imgdata
+      (class_instance.imgdata). The data in this structure appear after a file
+      is opened through open_file (and other open_ calls), except for the image
+      itself (filled by unpack()) and data containing the preview information
+      (filled by calling unpack_thumb()). </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> unsigned int progress_flags; </strong></dt>
+      <dd>This field records the past <a href="#progress"> phases of image
+          processing </a> .</dd>
+      <dt><strong> unsigned int process_warnings; </strong></dt>
+      <dd>This field records <a href="#warnings"> suspicious situations
+          (warnings) </a> that have emerged during image processing.</dd>
+      <dt><strong> libraw_iparams_t idata; </strong></dt>
+      <dd>The structure describes the main image parameters retrieved from the
+        RAW file. Fields of this structure are described in detail <a href="#libraw_iparams_t">
+          below </a> .</dd>
+      <dt><strong> libraw_image_sizes_t sizes; </strong></dt>
+      <dd>The structure describes the geometrical parameters of the image.
+        Fields of this structure are described in detail <a href="#libraw_image_sizes_t">
+          below </a> .</dd>
+      <dt><strong> libraw_lensinfo_t lens; </strong></dt>
+      <dd>The structure describes lens used for the shot. Fields of this
+        structure are described in detail <a href="#libraw_lensinfo_t"> below </a>
+        .</dd>
+      <dt><strong> libraw_makernotes_t makernotes; </strong></dt>
+      <dd>The structure contains camera/vendor specific metadata extracted from
+        file. No description provided, sorry, if you're interested in particular
+        tag/camera/vendor - use Exiftool documentation as a reference</dd>
+      <dt><strong> libraw_colordata_t color; </strong></dt>
+      <dd>The structure contains color data retrieved from the file. Fields of
+        this structure are described in detail <a href="#libraw_colordata_t">
+          below </a> .</dd>
+      <dt><strong> libraw_imgother_t other; </strong></dt>
+      <dd>Data structure for information purposes: it contains the image
+        parameters that have been extracted from the file but are not needed in
+        further file processing. Fields of this structure are described in
+        detail <a href="#libraw_imgother_t"> below </a> .</dd>
+      <dt><strong> libraw_thumbnail_t thumbnail; </strong></dt>
+      <dd>Data structure containing information on the preview and the preview
+        data themselves. All fields of this structure but thumbnail itself are
+        filled when open_file() is called. Thumbnail readed by unpack_thumb()
+        call. The fields are described in detail <a href="#libraw_thumbnail_t">
+          below </a> .</dd>
+      <dt><strong> libraw_rawdata_t rawdata; </strong></dt>
+      <dd>Data structure with pointer to raw-data buffer. Details are described
+        <a href="#libraw_rawdata_t"> below </a> .</dd>
+      <dt><strong> ushort (*image)[4]; </strong></dt>
+      <dd>The memory area that contains the image pixels per se. It is filled
+        when raw2image() or dcraw_process() is called.</dd>
+      <dt><strong> libraw_output_params_t params; </strong></dt>
+      <dd>Data structure intended for management of image postprocessing (using
+        the dcraw emulator). Fields of this structure are described in detail <a
+
+          href="#libraw_iparams_t"> below </a> .</dd>
+      <dt>libraw_callbacks_t callbacks;</dt>
+      <dd><a href="#libraw_callbacks_t">user-settable callbacks</a> </dd>
+    </dl>
+    <p><a name="libraw_iparams_t"></a></p>
+    <h3>Structure libraw_iparams_t: Main Parameters of the Image</h3>
+    <dl>
+      <dt><strong> char make[64]; </strong></dt>
+      <dd>Camera manufacturer.</dd>
+      <dt><strong> char model[64]; </strong></dt>
+      <dd>Camera model.</dd>
+      <dt><b>normalized_make[64]</b></dt>
+      <dd> There is a huge number of identical cameras sold under different
+        names, depending on the market (e.g. multiple Panasonic or Canon models)
+        and even some identical cameras sold under different brands (Panasonic
+        -&gt; Leica, Sony -&gt; Hasselblad). normalized_make contains primary
+        vendor name (e.g. Panasonic for Leica re-branded cameras). </dd>
+      <dt><b>normalized_model[64]</b></dt>
+      <dd> Primary camera model name. </dd>
+      <dt><b>unsigned maker_index</b></dt>
+      <dd>Primary vendor name in indexed form (enum LibRaw_cameramaker_index,
+        LIBRAW_CAMERAMAKER_* constant) </dd>
+      <dt><strong> char software[64]; </strong></dt>
+      <dd>Softwary name/version (mostly for DNG files, to distinguish in-camera
+        DNGs from Adobe DNG Converter produced ones).</dd>
+      <dt><strong> unsigned raw_count; </strong></dt>
+      <dd>Number of RAW images in file (0 means that the file has not been
+        recognized).</dd>
+      <dt><strong> unsigned is_foveon; </strong></dt>
+      <dd>Nonzero for Sigma Foveon images</dd>
+      <dt><strong> unsigned dng_version; </strong></dt>
+      <dd>DNG version (for the DNG format).</dd>
+      <dt><strong> int colors; </strong></dt>
+      <dd>Number of colors in the file.</dd>
+      <dt><strong> unsigned filters; </strong></dt>
+      <dd>Bit mask describing the order of color pixels in the matrix (0 for
+        full-color images). 32 bits of this field describe 16 pixels (8 rows
+        with two pixels in each, from left to right and from top to bottom).
+        Each two bits have values 0 to 3, which correspond to four possible
+        colors. Convenient work with this field is ensured by the
+        COLOR(row,column) function, which returns the number of the active color
+        for a given pixel.<br>
+        Values less than 1000 are reserved as special cases:
+        <ul>
+          <li><strong> 1 </strong> - Leaf Catchlight with 16x16 bayer matrix;</li>
+          <li><strong> 9 </strong> - Fuji X-Trans (6x6 matrix)</li>
+          <li>3..8 and 10..999 - are unused.</li>
+        </ul>
+      </dd>
+      <dt><strong> char xtrans[6][6]; </strong></dt>
+      <dt><strong> char xtrans_abs[6][6]; </strong></dt>
+      <dd>These matrices contains Fuji X-Trans row/col to color mapping. First
+        one is relative to visible area, while second is positioned relative to
+        sensor edges.</dd>
+      <dt><strong> char cdesc[5]; </strong></dt>
+      <dd>Description of colors numbered from 0 to 3 (RGBG,RGBE,GMCY, or GBTG).</dd>
+      <dt><strong> unsigned xmplen; char *xmpdata; </strong></dt>
+      <dd>XMP packed data length and pointer to extracted XMP packet.</dd>
+    </dl>
+    <p><a name="libraw_image_sizes_t"></a></p>
+    <h3>Structure libraw_image_sizes_t: Image Dimensions</h3>
+    <p>Structure libraw_image_sizes_t is a collection of all file data that
+      describe the size of the image. </p>
+    <h4> Data fields:</h4>
+    <dl>
+      <dt><strong> ushort raw_height, raw_width; </strong></dt>
+      <dd>Full size of RAW image (including the frame) in pixels.</dd>
+      <dt><strong> ushort height, width; </strong></dt>
+      <dd>Size of visible ("meaningful") part of the image (without the frame).</dd>
+      <dt><strong> ushort top_margin, left_margin; </strong></dt>
+      <dd>Coordinates of the top left corner of the frame (the second corner is
+        calculated from the full size of the image and size of its visible
+        part).</dd>
+      <dt><strong> ushort iheight, iwidth; </strong></dt>
+      <dd>Size of the output image (may differ from height/width for cameras
+        that require image rotation or have non-square pixels).</dd>
+      <dt><strong> unsigned raw_pitch; </strong></dt>
+      <dd>Full size of raw data row <strong> in bytes </strong> .</dd>
+      <dt><strong> double pixel_aspect; </strong></dt>
+      <dd>Pixel width/height ratio. If it is not unity, scaling of the image
+        along one of the axes is required during output.</dd>
+      <dt><strong> int flip; </strong></dt>
+      <dd>Image orientation (0 if does not require rotation; 3 if requires
+        180-deg rotation; 5 if 90 deg counterclockwise, 6 if 90 deg clockwise).</dd>
+      <dt><strong>libraw_raw_inset_crop_t raw_inset_crops[2];</strong></dt>
+      <dd>(<strong>libraw_raw_inset_crop_t: </strong>ushort cleft, ctop,
+        cwidth, cheight;)<ul>
+        <li>item at[0] contains standard crop data parsed from camera metadata (DNG:
+          DefaultCrop* tags, other formats: vendor specific tags)</li>
+        <li>item at [1] is 'user crop', in particular:
+       <br/>- set by DNG  DefaultUserCrop tag
+       <br/>- or set via raw aspect ratio tags (e.g. 16:9 aspect on Fujifilm cameras)
+          raw_inset_crops[1] is filled only if aspect ratio tags provides different
+          aspect ratio compared to raw_inset_crops[0].
+        </li></ul></dd>
+    </dl>
+    <p><a name="libraw_colordata_t"></a></p>
+    <h3>Structure libraw_colordata_t: Color Information</h3>
+    <p>Structure libraw_colordata_t unites all color data, both retrieved from
+      the RAW file and calculated on the basis of the image itself. For
+      different cameras, there are different ways of color handling. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> ushort curve[0x10000]; </strong></dt>
+      <dd>Camera tone curve. May be read from file as is, or calculated,
+        depending on file format;</dd>
+      <dt><strong> unsigned black; </strong></dt>
+      <dd>Black level. Depending on the camera, it may be zero (this means that
+        black has been subtracted at the unpacking stage or by the camera
+        itself), calculated at the unpacking stage, read from the RAW file, or
+        hardcoded.</dd>
+      <dt><strong> unsigned cblack[4102]; </strong></dt>
+      <dd>Per-channel black level correction. First 4 values are per-channel
+        correction, next two are black level pattern block size, than
+        cblack[4]*cblack[5] correction values (for indexes
+        [6....6+cblack[4]*cblack[5]).</dd>
+      <dt><strong> unsigned data_maximum; </strong></dt>
+      <dd>Maximum pixel value in current file. Calculated at raw2image or
+        dcraw_process() calls.</dd>
+      <dt><strong> unsigned maximum; </strong></dt>
+      <dd>Maximum pixel value. Calculated from the data for most cameras,
+        hardcoded for others. This value may be changed on postprocessing stage
+        (when black subtraction performed) and by automated maximum adjustment
+        (this adjustment performed if <strong> params.adjust_maximum_thr </strong>
+        is set to nonzero).</dd>
+      <dt><strong> unsigned linear_max[4]; </strong></dt>
+      <dd>Per-channel linear data maximum read from file metadata. If RAW file
+        does not contains this data, linear_max[] is set to zero. Black value is
+        not subtracted</dd>
+      <dt><strong> float fmaximum; </strong></dt>
+      <dd>Maximum pixel value in real image for floating data files.</dd>
+      <dt><strong> float fnorm; </strong></dt>
+      <dd>Normalization coefficient used while converting floating point raw
+        data to integer.</dd>
+      <dt><strong> ushort white[8][8]; </strong></dt>
+      <dd>Block of white pixels extracted from files CIFF/CRW. Not extracted for
+        other formats. Used to calculate white balance coefficients.</dd>
+      <dt><strong> float cam_xyz[4][3]; </strong></dt>
+      <dd>Camera RGB - XYZ conversion matrix. This matrix is constant (different
+        for different models). Last row is zero for RGB cameras and non-zero for
+        different color models (CMYG and so on).</dd>
+      <dt><strong> float cam_mul[4]; </strong></dt>
+      <dd>White balance coefficients (as shot). Either read from file or
+        calculated.</dd>
+      <dt><strong> float pre_mul[4]; </strong></dt>
+      <dd>White balance coefficients for daylight (daylight balance). Either
+        read from file, or calculated on the basis of file data, or taken from
+        hardcoded constants.</dd>
+      <dt><strong> float cmatrix[3][4]; </strong></dt>
+      <dd>Camera color data read from RAW file (if any)</dd>
+      <dt><strong> float rgb_cam[3][4]; </strong></dt>
+      <dd>Camera to sRGB conversion matrix</dd>
+      <dt><strong> float ccm[3][4]; </strong></dt>
+      <dd>Camera color correction matrix readed from file metadata (uniform
+        matrix if no such data in file)</dd>
+      <dt><strong> ph1_t phase_one_data; </strong></dt>
+      <dd>Color data block that is read for Phase One cameras.</dd>
+      <dt><strong> float flash_used; </strong></dt>
+      <dt><strong> float canon_ev; </strong></dt>
+      <dd>Fields used for white balance calculations (for some P&amp;S Canon
+        cameras).</dd>
+      <dt><strong> char model2[64]; </strong></dt>
+      <dd>Firmware revision (for some cameras).</dd>
+      <dt><strong> char UniqueCameraModel[64],LocalizedCameraModel[64]; </strong></dt>
+      <dd>Values from DNG tags with same names.</dd>
+      <dt><strong> void *profile; </strong></dt>
+      <dd>Pointer to the retrieved ICC profile (if it is present in the RAW
+        file).</dd>
+      <dt><strong> unsigned profile_length; </strong></dt>
+      <dd>Length of ICC profile in bytes.</dd>
+      <dt><strong> unsigned black_stat[8]; </strong></dt>
+      <dd>Black level statistics if calcluated from masked area: 4 sum of pixel
+        values, than 4 pixel counts (per channel).</dd>
+      <dt><strong> libraw_dng_color_t dng_color[2]; </strong></dt>
+      <dd>Color data read from DNG: illuminant, calbiration matrix and color
+        matrix for two light sources. (see DNG specs for details).</dd>
+      <dt><strong>libraw_dng_levels_t dng_levels</strong></dt>
+      <dd>DNG black/white levels, analog balance, WB for active IFD. See DNG
+        specs for details.</dd>
+      <dt><strong>int WB_Coeffs[256][4]</strong></dt>
+      <dd>Index: EXIF color source value, [i][0..3] WB Coeffs</dd>
+      <dt><strong>float WBCT_Coeffs[64][5]</strong></dt>
+      <dd>Color temperature in [i][0], WB coeffs in [i][1..4]</dd>
+      <dt><strong>int as_shot_wb_applied</strong></dt>
+      <dd>Set to 1 if WB already applied in camera (multishot modes; small raw)</dd>
+      <dt><strong>libraw_P1_color_t P1_color[2]</strong></dt>
+      <dd>Phase-one specific color data</dd>
+      <dt><strong>unsigned raw_bps</strong></dt>
+      <dd>RAW bits per pixel (PhaseOne: Raw format used)</dd>
+      <dt><strong>int ExifColorSpace</strong></dt>
+      <dd>EXIF color space parsed from EXIF tags: LIBRAW_COLORSPACE_Unknown,
+        LIBRAW_COLORSPACE_sRGB, or LIBRAW_COLORSPACE_Adobe</dd>
+    </dl>
+    <p><a name="libraw_imgother_t"></a></p>
+    <h3>Structure libraw_imgother_t: Other Parameters of the Image</h3>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> float iso_speed; </strong></dt>
+      <dd>ISO sensitivity.</dd>
+      <dt><strong> float shutter; </strong></dt>
+      <dd>Shutter speed.</dd>
+      <dt><strong> float aperture; </strong></dt>
+      <dd>Aperture.</dd>
+      <dt><strong> float focal_len; </strong></dt>
+      <dd>Focal length.</dd>
+      <dt><strong> time_t timestamp; </strong></dt>
+      <dd>Date of shooting.</dd>
+      <dt><strong> unsigned shot_order; </strong></dt>
+      <dd>Serial number of image.</dd>
+      <dt><strong> unsigned gpsdata[32]; </strong></dt>
+      <dd>GPS data (unparsed block, to write to output as is).</dd>
+      <dt><strong> libraw_gps_info_t parsed_gps; </strong></dt>
+      <dd>Parsed GPS-data: longitude/latitude/altitude and time stamp.</dd>
+      <dt><strong> char desc[512]; </strong></dt>
+      <dd>Image description.</dd>
+      <dt><strong> char artist[64]; </strong></dt>
+      <dd>Author of image.</dd>
+      <dt><strong> float FlashEC; </strong></dt>
+      <dd>Flash exposure compensation.</dd>
+    </dl>
+    <p><a name="libraw_rawdata_t"></a></p>
+    <h3>Structure libraw_rawdata_t: holds unpacked RAW data</h3>
+    <p>Structure libraw_rawdata_t holds:</p>
+    <ul>
+      <li>RAW-data from sensor, readed and unpacked by the <a href="API-CXX.html#unpack">
+          unpack() </a> call.</li>
+      <li>"backup" copy of color and over data modified during postprocessing.
+        When postprocessing calls repeats, the needed data is restored from this
+        backup.</li>
+    </ul>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt>void *raw_alloc;</dt>
+      <dd>Buffer allocated to hold RAW-data</dd>
+      <dt><strong> unsigned short *raw_image; </strong></dt>
+      <dd>Pointer to buffer with one-component (bayer) data.</dd>
+      <dt><strong> unsigned short (*color3_image)[3]; </strong></dt>
+      <dd>Pointer to 3-component pixel array.</dd>
+      <dt><strong> unsigned short (*color4_image)[4]; </strong></dt>
+      <dd>Pointer to buffer with 4-component pixel data data</dd>
+      <dt><strong> float *float_image; </strong></dt>
+      <dd>Pointer to buffer with one-component (bayer) data in FP-format.</dd>
+      <dt><strong> float (*float3_image)[3]; </strong></dt>
+      <dd>Pointer to 3-component FP pixel array.</dd>
+      <dt><strong> float (*float4_image)[4]; </strong></dt>
+      <dd>Pointer to buffer with 4-component pixel data data</dd>
+    </dl>
+    <p>After call to <a href="API-CXX.html#unpack"> unpack() </a> only one of
+      these fields is non-NULL.</p>
+    <p>All other fields of this structure are for internal use and should not be
+      touched by user code. <a name="libraw_thumbnail_t"></a></p>
+    <h3>Structure libraw_thumbnail_t: Description of Thumbnail</h3>
+    <p>Structure libraw_thumbnail_t describes all parameters associated with the
+      preview saved in the RAW file. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> LibRaw_thumbnail_formats tformat; </strong></dt>
+      <dd>Thumbnail data format. One of the values among enum <a href="#LibRaw_thumbnail_formats">
+          LibRaw_thumbnail_formats </a> .</dd>
+      <dt><strong> ushort twidth, theight; </strong></dt>
+      <dd>Dimensions of the preview image in pixels.</dd>
+      <dt><strong> unsigned tlength; </strong></dt>
+      <dd>Thumbnail length in bytes.</dd>
+      <dt><strong> int tcolors; </strong></dt>
+      <dd>Number of colors in the preview.</dd>
+      <dt><strong> char *thumb; </strong></dt>
+      <dd>Pointer to thumbmail, extracted from the data file.</dd>
+    </dl>
+    <p><a name="libraw_lensinfo_t"></a></p>
+    <h3>Structure libraw_lensinfo_t: parsed lens data</h3>
+    <p>The following parameters are extracted from Makernotes and EXIF, to help
+      identify which lens was mounted on the camera. If the value is missing in
+      Makernotes or EXIF, the parameter is set to zero with some exceptions
+      noted below. In some cases the values for the fields like CameraFormat and
+      CameraMount are set based on the camera model and/or camera ID.</p>
+    <h4>libraw_makernotes_lens_t structure:</h4>
+    <ul>
+      <li><strong>LensID</strong> (if not -1) and <strong>CamID</strong>
+        (camera id, if non-zero) values are compatible with those used in
+        exiftool, like |0x0010 CanonModelID| and |22 LensType| see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Canon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html</a>
+        or 0x0207/CameraType and 0x0201/LensType (see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.htmlhttp://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Olympus.html</a>
+        )</li>
+      <li><strong>Lens</strong> string, if not empty, contains the lens name
+        present in Makernotes.</li>
+      <li><strong>LensFormat </strong>and <strong>CameraFormat</strong>
+        currently provide one of value from <strong>enum LibRaw_camera_formats</strong>;</li>
+      <li>In a similar manner, values for <strong>LensMount</strong> and <strong>CameraMount</strong>
+        follow the <strong>enum LibRaw_camera_mounts</strong>;</li>
+      <li>In some cases, the Makernotes for MF cameras contain either an id for
+        the body, or a string containing the name of the body. The name is
+        copied to <strong>body</strong> field, while the id is converted to the
+        appropriate body name and also copied to 'body' field. In other cases
+        the 'body' field is empty.</li>
+      <li><strong>FocalType</strong> is set based on Makernotes tag, if present.
+        The values are: </li>
+      <ul>
+        <li>-1 Undefined</li>
+        <li>0 Unknown;</li>
+        <li>1 Fixed focal length lens</li>
+        <li>2 Zoom lens</li>
+      </ul>
+      <li><strong>LensFeatures_pre</strong> - lens name prefix and <strong>LensFeatures_suf</strong>
+        - lens name suffix: (if not empty) some cameras record alphabet soup
+        that characterizes the lens in separate Makernote tags (see, for
+        example, 0xb02a LensSpec at&nbsp;<a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Sony.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Sony.html</a>
+        ), and for some lenses those acronyms can be derived from the 'Lens'
+        field itself (see processCanonCameraInfo). Those can also help better
+        lens identification.</li>
+      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
+        non-zero, contain the minimum and maximum focal lengths for the lens
+        mounted on the camera.</li>
+      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong>, <strong>MinAp4MinFocal</strong>,
+        <strong>MinAp4MaxFocal</strong> - if non-zero, contain maximum aperture
+        available at minimal focal length, maximum aperture available at maximum
+        focal length, minimum aperture available at minimal focal length,
+        minimum aperture available at maximum focal length, respectively.</li>
+      <li><strong>MaxAp</strong> and <strong>MinAp</strong>, if non-zero,
+        contain the maximum aperture for the lens (usually it is the maximum
+        aperture for minimal focal length) and the minimum aperture across the
+        focal length range. For zooms with variable maximum aperture this is
+        usually the minimum aperture for the maximum focal length.</li>
+      <li><strong>CurFocal</strong>, if non-zero, is current focal length - that
+        is the focal length used to take the shot.</li>
+      <li><strong>CurAp</strong>, if non-zero, is current aperture.</li>
+      <li><strong>MaxAp4CurFocal</strong> and <strong>MinAp4CurFocal</strong>,
+        if non-zero, contain the minimum and maximum apertures for the current
+        focal length.</li>
+      <li><strong>LensFStops</strong> - if non-zero, contains the number of
+        aperture "clicks" or the number of f-stops, depending on the model of
+        the camera.</li>
+      <li><strong>TeleconverterID</strong>, <strong>AdapterID</strong>, <strong>AttachmentID</strong>,
+        if non-zero, are the numbers extracted from Makernotes to identify lens
+        accessories used to take the shot.</li>
+      <li><strong>Teleconverter</strong>, <strong>Adapter</strong>, <strong>Attachment</strong>,
+        if non-empty, are the strings containing the names of the accessories as
+        they appear in Makernotes, or for some cameras, decoded from a numeric
+        field in Makernotes.</li>
+      <li><strong>FocalUnits</strong> - an auxiliary field, should not be needed
+        most of the cases. See Canon.pm module in exiftool for more information
+        on this value.</li>
+      <li><strong>FocalLengthIn35mmFormat</strong>, if non-zero: for some reason
+        certain Samsung cameras record this value in Makernotes instead of the
+        EXIF proper. Also used for Sigma cameras.</li>
+    </ul>
+    <h4>libraw_nikonlens_t structure:</h4>
+    <p>Contains additional parameters needed to identify the lens on a Nikon
+      camera using a table - please see Nikon LensID Values at <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Nikon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Nikon.html</a></p>
+    <h4>libraw_dnglens_t structure:</h4>
+    <p>Contains minimum focal length, maximum focal length, maximum aperture
+      available at minimal focal length, and maximum aperture available at
+      maximum focal length, extracted from EXIF field of a DNG raw file.</p>
+    <h4>libraw_lensinfo_t structure:</h4>
+    <p>Contains all the structures described above, plus parameters extracted
+      directly from EXIF fields:</p>
+    <ul>
+      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
+        non-zero, contain the minimum and maximum focal lengths for the lens
+        mounted on the camera.</li>
+      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong> - if
+        non-zero, contain maximum aperture available at minimal focal length and
+        maximum aperture available at maximum focal length</li>
+      <li><strong>LensMake</strong>, if not empty, contains a string with the
+        lens manufacturer name.</li>
+      <li><strong>Lens</strong>, if not empty, contains the lens name as
+        recorded in EXIF</li>
+      <li><strong>FocalLengthIn35mmFormat</strong> - if non-zero, same as
+        FocalLengthIn35mmFilm in EXIF standard, tag 0xa405.</li>
+      <li><strong>EXIF_MaxAp</strong> - if non-zero, contains the value derived
+        from EXIF tag 0x9205.</li>
+    </ul>
+    <p><a name="libraw_raw_unpack_params_t"></a></p>
+    <h3>Structure libraw_raw_unpack_params_t: RAW decoding options and flags</h3>
+    <p>Structure libraw_raw_unpack_params_t contains fields/flags that affects
+      RAWdata and metadata decoding</p>
+    <dl>
+      <dt><strong> int options </strong></dt>
+      <dd>Processing options used on unpack() phase for specific image formats,
+        see below for possible values:<a href="#LibRaw_processing_options">
+          LibRaw_processing_options</a></dd>
+      <dt><strong> unsigned shot_select; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -s <br>
+        Selection of image number for processing (for formats that contain
+        several RAW images in one file).</dd>
+      <dt><strong> int specials </strong></dt>
+      <dd>Special processing mode (e.g. omit YCC to RGB conversion), see below
+        for possible values. <a href="#LibRaw_rawspecial_t">
+          LibRaw_rawspecial_t</a></dd>
+      <dt><strong>int max_raw_memory_mb</strong></dt>
+      <dd>Stop processing if raw buffer size grows larger than that value (in
+        megabytes). Default is LIBRAW_MAX_ALLOC_MB_DEFAULT (2048Mb)</dd>
+      <dt><strong> int sony_arw2_posterization_thr </strong></dt>
+      <dd>If LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE used for
+        raw_processing_options, sets the level to suppress posterization display
+        in shadows.</dd>
+      <dt><strong> float coolscan_nef_gamma; </strong></dt>
+      <dd>Gamma value for Coolscan NEF decoding (no way to get if from file, it
+        should be set by calling application).</dd>
+      <dt><strong> char p4shot_order[5]; </strong></dt>
+      <dd>Shot order for Pentax 4shot files. Default is "3102".</dd>
+    </dl>
+    <h3></h3>
+    <h3>Structure libraw_output_params_t: management of dcraw-style
+      postprocessing</h3>
+    <p>Structure libraw_output_params_t (imgdata.params) is used for management
+      of dcraw-compatible calls dcraw_process(), dcraw_ppm_tiff_writer(), and
+      dcraw_thumb_writer(). Fields of this structure correspond to command line
+      keys of dcraw. </p>
+    <h4> Data fields:</h4>
+    <dl>
+      <dt><strong> unsigned greybox[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -A x y w h <br>
+        4 numbers corresponding to the coordinates (in pixels) of the rectangle
+        that is used to calculate the white balance. X and Y are coordinates of
+        the left-top rectangle corner; w and h are the rectangle's width and
+        height, respectively.</dd>
+      <dt><strong> unsigned cropbox[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        This field sets the image cropping rectangle. Cropbox[0] and cropbox[1]
+        are the rectangle's top-left corner coordinates, remaining two values
+        are width and height respectively. All coordinates are applied before
+        any image rotation.</dd>
+      <dt><strong> double aber[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -C <br>
+        Correction of chromatic aberrations; the only specified values are <br>
+        aber[0], the red multiplier <br>
+        aber[2], the blue multiplier. For some formats, it affects <a href="API-notes.html">
+          RAW data reading </a> , since correction of aberrations changes the
+        output size.</dd>
+      <dt><strong> double gamm[6]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -g power toe_slope <br>
+        Sets user gamma-curve. Library user should set first two fields of gamm
+        array: <br>
+        gamm[0] - <strong> inverted </strong> gamma value) <br>
+        gamm[1] - slope for linear part (so called toe slope). Set to zero for
+        simple power curve. <br>
+        Remaining 4 values are filled automatically.<br>
+        By default settings for rec. BT.709 are used: power 2.222 (i.e.
+        gamm[0]=1/2.222) and slope 4.5. For sRGB curve use gamm[0]=1/2.4 and
+        gamm[1]=12.92, for linear curve set gamm[0]/gamm[1] to 1.0. </dd>
+      <dt><strong> float user_mul[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -r mul0 mul1 mul2 mul3 <br>
+        4 multipliers (r,g,b,g) of the user's white balance.</dd>
+      <dt><strong>float bright; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -b <br>
+        Brightness (default 1.0).</dd>
+      <dt><strong> float threshold; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -n <br>
+        Parameter for noise reduction through wavelet denoising.</dd>
+      <dt><strong> int half_size; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -h <br>
+        Outputs the image in 50% size. For some formats, it affects <a href="API-notes.html">
+          RAW data reading </a> .</dd>
+      <dt><strong> int four_color_rgb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -f <br>
+        Switches on separate interpolations for two green components.</dd>
+      <dt><strong> int highlight; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -H <br>
+        0-9: Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild).</dd>
+      <dt><strong> int use_auto_wb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -a <br>
+        Use automatic white balance obtained after averaging over the entire
+        image.</dd>
+      <dt><strong> int use_camera_wb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -w <br>
+        If possible, use the white balance from the camera.
+        <p> If camera-recorded WB is not available, dcraw_process() will
+          fallback to: </p>
+        <ul>
+          <li>Auto-WB if bit LIBRAW_PROCESSING_CAMERAWB_FALLBACK_TO_DAYLIGHT is
+            not set in params.raw_processing_options (or for the rare specific
+            case: no valid WB index was parsed from CRW file) </li>
+          <li>Daylight-WB if abovementioned bit is not set. </li>
+        </ul>
+      </dd>
+      <dt><strong> int use_camera_matrix; </strong></dt>
+      <dd><strong> dcraw keys: </strong> +M/-M <br>
+        <ul>
+          <li>0: do not use embedded color profile</li>
+          <li>1 (default): use embedded color profile (if present) for DNG files
+            (always); for other files only if use_camera_wb is set;</li>
+          <li>3: use embedded color data (if present) regardless of white
+            balance setting.</li>
+        </ul>
+      </dd>
+      <dt><strong> int output_color; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -o <br>
+        [0-8] Output colorspace (raw, sRGB, Adobe, Wide, ProPhoto, XYZ, ACES,
+        DCI-P3, Rec. 2020).</dd>
+      <dt><strong> char* output_profile; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -o filename <br>
+        Path to output profile ICC file (used only if LibRaw compiled with LCMS
+        support)</dd>
+      <dt><strong> char* camera_profile; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -p file <br>
+        Path to input (camera) profile ICC file (or 'embed' for embedded
+        profile). Used only if LCMS support compiled in.</dd>
+      <dt><strong> char* bad_pixels; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -P file <br>
+        Path to file with bad pixels map (in dcraw format: "column row
+        date-of-pixel-death-in-UNIX-format", one pixel per row).</dd>
+      <dt><strong> char* dark_frame; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -K file <br>
+        Path to dark frame file (in 16-bit PGM format)</dd>
+      <dt><strong> int output_bps; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -4 <br>
+        8 bit (default)/16 bit (key -4).</dd>
+      <dt><strong> int output_tiff; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -T <br>
+        0/1: output PPM/TIFF.</dd>
+      <dt><strong> int output_flags; </strong></dt>
+      <dd><strong> dcraw keys:</strong> none<br>
+        Bitfield that allows to set output file options:
+        <ul>
+          <li><strong>LIBRAW_OUTPUT_FLAGS_PPMMETA</strong> - write additional
+            metadata into PPM/PGM output files</li>
+        </ul>
+      </dd>
+      <dt><strong> int user_flip; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -t <br>
+        [0-7] Flip image (0=none, 3=180, 5=90CCW, 6=90CW). Default -1, which
+        means taking the corresponding value from RAW. <br>
+        For some formats, <a href="API-notes.html"> affects RAW data reading </a>
+        , e.g., unpacking of thumbnails from Kodak cameras.</dd>
+      <dt><strong> int user_qual; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -q <br>
+        0-10: interpolation quality:
+        <ul>
+          <li>0 - linear interpolation</li>
+          <li>1 - VNG interpolation</li>
+          <li>2 - PPG interpolation</li>
+          <li>3 - AHD interpolation</li>
+          <li>4 - DCB interpolation</li>
+          <li>11 - DHT intepolation</li>
+          <li>12 - Modified AHD intepolation (by Anton Petrusevich)</li>
+        </ul>
+      </dd>
+      <dt><strong> int user_black; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -k <br>
+        User black level.</dd>
+      <dt><strong> int user_cblack[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Per-channel corrections to user_black.</dd>
+      <dt><strong> int user_sat; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -S <br>
+        Saturation adjustment.</dd>
+      <dt><strong> int med_passes; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -m <br>
+        Number of median filter passes.</dd>
+      <dt><strong> int no_auto_bright; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -W <br>
+        Don't use automatic increase of brightness by histogram.</dd>
+      <dt><strong> float auto_bright_thr; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Portion of clipped pixels when auto brighness increase is used. Default
+        value is 0.01 (1%) for dcraw compatibility. Recommended value for modern
+        low-noise multimegapixel cameras depends on shooting style. Values in
+        0.001-0.00003 range looks reasonable.</dd>
+      <dt><strong> float adjust_maximum_thr; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        This parameters controls auto-adjusting of maximum value based on
+        channel_maximum[] data, calculated from real frame data. If calculated
+        maximum is greater than adjust_maximum_thr*maximum, than maximum is set
+        to calculated_maximum. <br>
+        Default: 0.75. If you set this value above 0.99999, than default value
+        will be used. If you set this value below 0.00001, than no maximum
+        adjustment will be performed. <br>
+        Adjusting maximum should not damage any picture (esp. if you use default
+        value) and is very useful for correcting channel overflow problems
+        (magenta clouds on landscape shots, green-blue highlights for indoor
+        shots).</dd>
+      <dt><strong> int use_fuji_rotate; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -j <br>
+        Default -1 (use), 0 - don't use rotation for cameras on a Fuji sensor.</dd>
+      <dt><strong> int green_matching; </strong></dt>
+      <dd>Turns on fixing of green channels disbalance. <strong> dcraw keys: </strong>
+        none <br>
+        Default: 0 (not use), 1 - turns on this postprocessing stage.
+        green_matching requires additional memory for image data.</dd>
+      <dt><strong> int dcb_iterations </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Number of DCB correction passes. Default is -1 (no correction). Useful
+        only for DCB interpolation.</dd>
+      <dt><strong> int dcb_enhance_fl </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        nonzero: DCB interpolation with enhance interpolated colors.</dd>
+      <dt><strong> int fbdd_noiserd </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Controls FBDD noise reduction before demosaic.
+        <ul>
+          <li>0 - do not use FBDD noise reduction</li>
+          <li>1 - light FBDD reduction</li>
+          <li>2 (and more) - full FBDD reduction</li>
+        </ul>
+      </dd>
+      <dt><strong> int exp_correc; float exp_shift,exp_preser; </strong></dt>
+      <dd>Exposure correction before demosaic. <br>
+        <ul>
+          <li>exp_correc: positive value turns the feature on (default: off).</li>
+          <li>exp_shift: exposure shift in linear scale. Usable range from 0.25
+            (2-stop darken) to 8.0 (3-stop lighter). Default: 1.0 (no exposure
+            shift).</li>
+          <li>exp_preser: preserve highlights when lighten the image. Usable
+            range from 0.0 (no preservation) to 1.0 (full preservation). 0.0 is
+            the default value.</li>
+        </ul>
+      </dd>
+      <dt><strong> int use_rawspeed; </strong></dt>
+      <dd>Turns on using RawSpeed library for data unpacking (only if RawSpeed
+        support compiled in).</dd>
+      <dt><strong>int use_dng_sdk; </strong></dt>
+      <dd>Turns on using Adobe DNG SDK (if compiled with it and dng host is set:
+        <br>
+        <ul>
+          <li>0 - do not use</li>
+          <li>1 - use for speciality formats (Float, Linear DNG, deflate
+            compression, 8 bit)</li>
+          <li>2 - use for all DNG files</li>
+        </ul>
+      </dd>
+      <dt><strong> int no_auto_scale; </strong></dt>
+      <dd>Disables pixel values scaling (call to LibRaw::scale_colors()) in
+        LibRaw::dcraw_process().<br>
+        This is <strong>special use value</strong> because white balance is
+        performed in scale_colors(), so skipping it will result in non-balanced
+        image.<br>
+        This setting is targeted to use with no_interpolation, or with own
+        interpolation callback call.</dd>
+      <dt><strong> int no_interpolation; </strong></dt>
+      <dd>Disables call to demosaic code in LibRaw::dcraw_process()</dd>
+    </dl>
+    <p><a name="libraw_callbacks_t"></a></p>
+    <h3>Structure libraw_callbacks_t: user-settable callbacks</h3>
+    <dl>
+      <dt>memory_callback mem_cb</dt>
+      <dd>Called on memory allocation error. Settable via set_memerror_handler.
+        See <a href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
+      <dt>data_callback data_cb</dt>
       <dd>Called on data error, settable via set_dataerror_handler. See <a href="API-CXX.html#callbacks">C++
-          API</a> for details.</dd>
-      <dt>progress_callback progress_cb</dt>
-      <dd>Called on process callback, settable via set_progress_handler. See <a
-          href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
-      <dt>exif_parser_callback exif_cb, params: (void *context, int tag, int
-        type, int len, unsigned int ord, void *ifp)</dt>
-      <dd> Called by EXIF/TIFF IFD parsers on each processed tag.<br>
-        Parameters:
-        <ul>
-          <li>context: user-specified context, set via set_exifparser_handler()</li>
-          <li>tag: 16-bit of TIFF/EXIF tag or'ed with
-            <ul>
-              <li>0 - for EXIF parsing</li>
-              <li>0x20000 - for Kodak makernotes parsing</li>
-              <li>0x30000 - for Panasonic makernotes parsing</li>
-              <li>0x40000 - for EXIF Interop IFD parsing</li>
-              <li>0x50000 - for EXIF GPS IFD parsing</li>
-              <li>(ifdN + 1) &lt;&lt; 20) - for TIFF ifdN</li>
-            </ul>
-          </li>
-          <li>type: tag type (see TIFF/EXIF specs)</li>
-          <li>len: tag length</li>
-          <li>ord: byte order: 0x4949 for intel, 0x4d4d for motorola</li>
-          <li>ifp: pointer to LibRaw_abstract_datastream input stream,
-            positioned to start of data. There is no need to restore data
-            position in callback.</li>
-        </ul>
-      </dd>
-      <dt>int pre_identify_cb(void *)</dt>
-      <dd>Called with this pointer as the only arg before calling to
-        LibRaw::identify. If this callback return non-zero value, that means
-        that identify() is not needed and all internal data fields are filled
-        with values.</dd>
-      <dt>void post_identify_cb(void *)</dt>
-      <dd>Called after identify() from open_datastream(). May be used to tune
-        internal variables after metadata parse.</dd>
-      <dt>dcraw_process() callbacks</dt>
-      <dd>These callbacks are called before/after dcraw_process phases, the only
-        passed parameter is this pointer
-        <ul>
-          <li>pre_subtractblack_cb - called before black subtraction</li>
-          <li>pre_scalecolors_cb - called before scale_colors() call</li>
-          <li>pre_preinterpolate_cb - called before interpolaton (demosaic)</li>
-          <li>interpolate_bayer_cb - if set, called for bayer demosaic
-            (regardless of params.user_qual value)</li>
-          <li>interpolate_xtrans_cb - if set, called for X-Trans demosaic</li>
-          <li>post_interpolate_cb - called after demosaic step. Note: if this
-            callback is set, standard median_filter() is not called. So, if you
-            need median filtering you should call it from callback function.</li>
-          <li>pre_converttorgb_cb - called after convert_to_rgb()</li>
-          <li>post_converttorgb_cb - called after convert_to_rgb(), so very last
-            processing step.</li>
-        </ul>
-      </dd>
-    </dl>
-    <p><a name="libraw_decoder_info_t"></a></p>
-    <h3>Structure libraw_decoder_info_t: RAW decoder name and data format</h3>
-    <p>This structure describes RAW format decoder name and data format:</p>
-    <dl>
-      <dt>const char *decoder_name</dt>
-      <dd>Decoder function name</dd>
-      <dt>unsigned decoder_flags</dt>
-      <dd>Decoder data format. See <a href="#decoder_flags"> list of
-          LibRaw_decoder_flags </a> for details.</dd>
-    </dl>
-    <p><a name="libraw_processed_image_t"></a></p>
-    <h3>Structure libraw_processed_image_t - result set for
-      dcraw_make_mem_image()/dcraw_make_mem_thumb() functions</h3>
-    <p>Structure libraw_processed_image_t is produced by call of
-      dcraw_make_mem_image()/dcraw_make_mem_thumb() and contains in-memory image
-      of interpolated data or thumbnail. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> LibRaw_image_formats type </strong></dt>
-      <dd>This field records type of data, containing in remaining fields of
-        structure.
-        <ul>
-          <li><strong> LIBRAW_IMAGE_BITMAP </strong> - structure contains RGB
-            bitmap. All metadata fields (see below) are valid and describes
-            image data.</li>
-          <li><strong> LIBRAW_IMAGE_JPEG </strong> - structure contain
-            in-memory image of JPEG file. Only type, data_size and data fields
-            are valid (and nonzero);</li>
-        </ul>
-      </dd>
-      <dt><strong> ushort height,width </strong></dt>
-      <dd>Image size (in pixels). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> ushort colors, bits </strong></dt>
-      <dd>Number of colors components (1 or 3) and color depth in bits (8 or
-        16). These fields are valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> ushort gamma_corrected </strong></dt>
-      <dd>Is bitmap data gamma-corrected (always 1 for 8-bit data, may be 0 or 1
-        for 16-bit). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> unsigned int data_size </strong></dt>
-      <dd>Size of <strong> data </strong> field (in bytes). For bitmap image
-        equal to (height*width*colors * (bits/8)). For JPEG image - exact JPEG
-        size (i.e. extracted thnumbnail size + JPEG header + EXIF header).</dd>
-      <dt><strong> unsigned char data[] </strong></dt>
-      <dd>Data array itself. Should be interpreted as RGB triplets for bitmap
-        type and as JPEG file for JPEG type.</dd>
-    </dl>
-    <p><a name="datastream"></a></p>
-    <h2>Input abstraction layer</h2>
-    <p>RAW data input (read) in LibRaw implemented by calling methods of object
-      derived from <strong> LibRaw_abstract_datastream </strong> abstract
-      class. Full list of methods is described in
-      href="API-CXX.html#datastream"&gt;C++ API reference.</p>
-    <p>There is two ready to use implementations of datastream objects:</p>
-    <ul>
-      <li><a href="API-CXX.html#file_datastream"> LibRaw_file_datastream </a> -
-        file input (filename provided to LibRaw).</li>
-      <li><a href="API-CXX.html#buffer_datastream"> LibRaw_buffer_datastream </a>
-        - input from memory buffer.</li>
-    </ul>
-    <p>LibRaw user can create own datastream object derived from <a href="API-CXX.html#datastream">
-        LibRaw_abstract_datastream </a> . For example, such object may
-      implement reading RAW data directly from camera (by remote interface).
-      LibRaw can use these objects via <a href="API-CXX.html#open_datastream">
-        LibRaw::open_datastream() </a> interface.</p>
-    <p>Datastreams can be used either via <a href="API-CXX.html#open_datastream">
-        LibRaw::open_datastream() </a> call (in this case datastream object
-      should be created an maintained by user) or via <a href="API-CXX.html#open_file">
-        LibRaw::open_file() </a> and <a href="API-CXX.html#open_buffer">
-        LibRaw::open_buffer() </a> shortcuts.</p>
-    <p>Only <a href="API-CXX.html"> C++ API </a> users may use object-oriented
-      interface and implement own input interfaces. For <a href="API-C.html"> C
-        API </a> users only built-on <strong>
-        libraw_open_file()/libraw_open_buffer() </strong> shortcuts are
-      available.</p>
-    <p><a name="datastream_data"></a></p>
-    <h4>Data fields</h4>
-    <p>Definition:</p>
-    <pre>	class LibRaw_abstract_datastream {...protected: LibRaw_abstract_datastream *substream;}
-</pre>
-    <p><strong> Description: </strong> Ojects derived from
-      LibRaw_abstract_datastream always contains pointer to secondary data
-      stream (substream). This substream initialized internally when needed
-      (really used only for Sony RAW data) and used for temporary switch input
-      stream to temporary memory buffer allocated internally in LibRaw.</p>
-    <p>Substream usage details described more precisely in <a href="API-CXX.html#own_datastreams">
-        own datastream objects creation guide </a> .</p>
-    <p><a name="const"></a></p>
-    <h2>Constants</h2>
-    <p><a name="LibRaw_errors"></a></p>
-    <h3>enum LibRaw_errors: Error Codes</h3>
-    <p>All functions returning integer numbers must return either errno or one
-      of the following error codes (see also <a href="API-notes.html#errors">
-        error code conventions </a> ).</p>
-    <p><strong> Fatal errors </strong> (return of such an error code implies
-      that file processing has to be terminated, since the state of data
-      structures is unknown).</p>
-    <dl>
-      <dt><strong> LIBRAW_UNSUFFICIENT_MEMORY </strong></dt>
-      <dd>Attempt to get memory from the system has failed. <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_DATA_ERROR </strong></dt>
-      <dd>A fatal error emerged during data unpacking. <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_IO_ERROR </strong></dt>
-      <dd>A fatal error emerged during file reading (premature end-of-file
-        encountered or file is corrupt). <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_CANCELLED_BY_CALLBACK </strong></dt>
-      <dd>Processing cancelled due to calling application demand (by returning
-        nonzero code from <a href="API-CXX.html#progress"> progress callback </a>
-        ). <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_BAD_CROP </strong></dt>
-      <dd>The incorrect cropping coordinates are set via params.cropbox[]: the
-        left-top corner of cropping rectangle is outside the image. The
-        processing will be cancelled, all allocated resources will be freed, <a
-          <dt=""><strong> LIBRAW_TOO_BIG</strong> </a></dd>
-      <dd><a <dt="">Raw data size exceeds data limit.</a></dd>
-      <a <dt=""> </a>
-    </dl>
-    <a <dt="">
-      <p><strong> Non-Fatal Errors </strong></p>
-    </a>
-    <dl>
-      <a <dt=""> <dt><strong> LIBRAW_SUCCESS=0 </strong></dt>
-        <dd>No error; function terminated successfully.</dd>
-        <dt><strong> LIBRAW_UNSPECIFIED_ERROR </strong></dt>
-        <dd>An unknown error has been encountered. This code should never be
-          generated.</dd>
-        <dt><strong> LIBRAW_FILE_UNSUPPORTED </strong></dt>
-        <dd>Unsupported file format (attempt to open a RAW file with a format
-          unknown to the program).</dd>
-        <dt><strong> LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE </strong></dt>
-        <dd>Attempt to retrieve a RAW image with a number absent in the data
-          file (only for formats supporting storage of several images in a
-          file).</dd>
-        <dt><strong> LIBRAW_OUT_OF_ORDER_CALL </strong></dt>
-      </a><dd><a <dt="">API functions have been called in wrong order (e.g., </a><a
-          href="API-CXX.html#unpack"> unpack() </a> before <a href="API-CXX.html#open_file">
-          open_file() </a> ) or the previous stage has ended with an error
-        (e.g., <a href="API-CXX.html#unpack"> unpack() </a> is called after <a
-          href="API-CXX.html#open_file"> open_file() </a> has returned an
-        error).</dd>
-      <dt><strong> LIBRAW_NO_THUMBNAIL </strong></dt>
-      <dd>Returned upon an attempt to retrieve a thumbnail from a file
-        containing no preview.</dd>
-      <dt><strong> LIBRAW_UNSUPPORTED_THUMBNAIL </strong></dt>
-      <dd>RAW file contains a preview of unsupported format.</dd>
-    </dl>
-    <p><a name="decoder_flags"></a></p>
-    <h3>enum LibRaw_decoder_flags - RAW data format description</h3>
-    <p>Depending of capabilities of given data format, the buffer with RAW data
-      may have different layouts:</p>
-    <dl>
-      <dt><strong> LIBRAW_DECODER_HASCURVE </strong></dt>
-      <dd>This flag is set if decoder uses RAW tone curve and curve data may be
-        modified before call to decoder (i.e. curve values are not read or
-        calculated within decoder).</dd>
-      <dt><strong> LIBRAW_DECODER_SONYARW2 </strong></dt>
-      <dd>This flag is set if file format is Sony ARW2.3, so sony_arw2_options
-        is applicable.</dd>
-      <dt><strong> LIBRAW_DECODER_TRYRAWSPEED </strong></dt>
-      <dd>This flag is set if file format is (possibly) supported by RawSpeed
-        library, so unpack() will try to use it.</dd>
-      <dt><strong> LIBRAW_DECODER_FIXEDMAXC </strong></dt>
-      <dd>Do not use automated maximum calculation for this data format.</dd>
-      <dt><strong> LIBRAW_DECODER_OWNALLOC </strong></dt>
-      <dd>Decoder allocates data, no need to pass allocated memory to decoder.</dd>
-      <dt><strong>LIBRAW_DECODER_ADOBECOPYPIXEL</strong></dt>
-      <dd>Internal flag, special to adobe DNG decoder.</dd>
-      <dt><strong>LIBRAW_DECODER_LEGACY_WITH_MARGINS</strong></dt>
-      <dd>Special flag uset for 4-channel (legacy) decoders with black/masked
-        areas</dd>
-      <dt><strong>LIBRAW_DECODER_3CHANNEL</strong></dt>
-      <dd>3-component full-color data (not usual 4-component)</dd>
-    </dl>
-    <p><a name="progress"></a></p>
-    <h3>enum LibRaw_progress: Current State of LibRaw Object</h3>
-    <p>LibRaw::imgdata.progress_flags contains a bit mask describing all stages
-      of file processing that have already been performed.</p>
-    <p><strong> File opening and RAW data extraction phase. </strong></p>
-    <dl>
-      <dt><strong> LIBRAW_PROGRESS_START=0 </strong></dt>
-      <dd>Object just created, no processing carried out.</dd>
-      <dt><strong> LIBRAW_PROGRESS_OPEN </strong></dt>
-      <dd>File to be processed has been opened.</dd>
-      <dt><strong> LIBRAW_PROGRESS_IDENTIFY </strong></dt>
-      <dd>Data identification performed, format recognized, metadata extracted.</dd>
-      <dt><strong> LIBRAW_PROGRESS_SIZE_ADJUST </strong></dt>
-      <dd>Data sizes adjusted (for files that require such adjustment, namely,
-        certain files from Kodak cameras).</dd>
-      <dt><strong> LIBRAW_PROGRESS_LOAD_RAW </strong></dt>
-      <dd>RAW data loaded.</dd>
-    </dl>
-    <p><strong> The following flags are set during usage of image processing
-        that has been taken from dcraw. </strong></p>
-    <dl>
-      <dt><strong> LIBRAW_PROGRESS_RAW2_IMAGE </strong></dt>
-      <dd>imgdata.image array allocated and filled with data.</dd>
-      <dt><strong> LIBRAW_PROGRESS_REMOVE_ZEROES </strong></dt>
-      <dd>Zero values removed for cameras that require such removal (Panasonic
-        cameras).</dd>
-      <dt><strong> LIBRAW_PROGRESS_BAD_PIXELS </strong></dt>
-      <dd>Bad (dead) pixels removed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_DARK_FRAME </strong></dt>
-      <dd>Dark frame subtracted from RAW data.</dd>
-      <dt><strong> LIBRAW_PROGRESS_FOVEON_INTERPOLATE </strong></dt>
-      <dd>Interpolation for cameras with a Foveon sensor performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_SCALE_COLORS </strong></dt>
-      <dd>White balance performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_PRE_INTERPOLATE </strong></dt>
-      <dd>Image size reduction (for the half_size mode) performed, as well as
-        copying of 2nd green channel to the 1st one in points where the second
-        channel is present and the first one is absent.</dd>
-      <dt><strong> LIBRAW_PROGRESS_INTERPOLATE </strong></dt>
-      <dd>Interpolation (debayer) performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_MIX_GREEN </strong></dt>
-      <dd>Averaging of green channels performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_MEDIAN_FILTER </strong></dt>
-      <dd>Median filtration performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_HIGHLIGHTS </strong></dt>
-      <dd>Work with highlights performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_FUJI_ROTATE </strong></dt>
-      <dd>For images from Fuji cameras, rotation performed (or
-        adjust_sizes_info_only() called).</dd>
-      <dt><strong> LIBRAW_PROGRESS_FLIP </strong></dt>
-      <dd>Dimensions recalculated for images shot with a rotated camera
-        (sizes.iwidth/sizes.iheight swapped).</dd>
-      <dt><strong> LIBRAW_PROGRESS_CONVERT_RGB </strong></dt>
-      <dd>Conversion into output RGB space performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_STRETCH </strong></dt>
-      <dd>Image dimensions changed for cameras with non-square pixels.</dd>
-      <dt><strong> LIBRAW_PROGRESS_STAGE17 - LIBRAW_PROGRESS_STAGE27 </strong></dt>
-      <dd>Reserved for possible appearance of other processing stages.</dd>
-    </dl>
-    <p><strong> The following flags are set during loading of thumbnails. </strong></p>
-    <p><strong> LIBRAW_PROGRESS_THUMB_LOAD </strong> Thumbnail data have been
-      loaded (for Kodak cameras, the necessary conversions have also been made).
-      <strong> LIBRAW_PROGRESS_TRESERVED1 - LIBRAW_PROGRESS_TRESERVED3 </strong>
-      Reserved for possible future processing stages.</p>
-    <p><a name="LibRaw_whitebalance_code"></a></p>
-    <h3>enum LibRaw_whitebalance_code - names for standard light sources</h3>
-    <p>LIBRAW_WBI_lightsource_name, where name and value are standard EXIF light
-      sources. <a name="LibRaw_runtime_capabilities"></a></p>
-    <h3>enum LibRaw_camera_mounts - codes for camera mounts</h3>
-    <p>Constant name (e.g. LIBRAW_MOUNT_Leica_SL) speaks for itself</p>
-    <h3>enum LibRaw_runtime_capabilities - libraw capabilities set at build</h3>
-    <ul>
-      <li><strong>LIBRAW_CAPS_RAWSPEED</strong> - compiled with RawSpeed</li>
-      <li><strong>LIBRAW_CAPS_DNGSDK </strong>- compiled with Adobe DNG SDK</li>
-      <li><strong>LIBRAW_CAPS_GPRSDK</strong> - compiled w/ GoPro GPR SDK</li>
-      <li><strong>LIBRAW_CAPS_UNICODEPATHS</strong> - compiled with Windows
-        unicode (wchar_t*) filenames support</li>
-    </ul>
-    <p><a name="LibRaw_thumbnail_formats"></a></p>
-    <h3>enum LibRaw_thumbnail_formats: Thumbnail Data Formats</h3>
-    <p>Thumbnail data format is written in the imgdata.thumbnail.tformat data
-      field. <br>
-      Presently LibRaw knows about four thumbnail formats, among which two are
-      unpacked:</p>
-    <dl>
-      <dt><strong> LIBRAW_THUMBNAIL_UNKNOWN </strong></dt>
-      <dd>Format unknown or thumbnail not yet read.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_JPEG </strong></dt>
-      <dd>The thumbnail buffer contains a JPEG file (read from the RAW file "as
-        is," without any manipulations performed on it).</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_BITMAP </strong></dt>
-      <dd>The thumbnail buffer contains the gamma-adjusted RGB bitmap (for Kodak
-        cameras, the gamma correction is performed with allowance for maximum
-        values and the white balance is set in accordance with the camera
-        settings). <br>
-        In this format, each pixel of the image is represented by a 8-bit RGB
-        triplet.</dd>
-      <dt><strong>LIBRAW_THUMBNAIL_BITMAP16</strong></dt>
-      <dd>The thumbnail buffer contains the gamma-adjusted 16-bit RGB bitmap. To
+          API</a> for details.</dd>
+      <dt>progress_callback progress_cb</dt>
+      <dd>Called on process callback, settable via set_progress_handler. See <a
+
+          href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
+      <dt>exif_parser_callback exif_cb, params: (void *context, int tag, int
+        type, int len, unsigned int ord, void *ifp)</dt>
+      <dd> Called by EXIF/TIFF IFD parsers on each processed tag.<br>
+        Parameters:
+        <ul>
+          <li>context: user-specified context, set via set_exifparser_handler()</li>
+          <li>tag: 16-bit of TIFF/EXIF tag or'ed with
+            <ul>
+              <li>0 - for EXIF parsing</li>
+              <li>0x20000 - for Kodak makernotes parsing</li>
+              <li>0x30000 - for Panasonic makernotes parsing</li>
+              <li>0x40000 - for EXIF Interop IFD parsing</li>
+              <li>0x50000 - for EXIF GPS IFD parsing</li>
+              <li>(ifdN + 1) &lt;&lt; 20) - for TIFF ifdN</li>
+            </ul>
+          </li>
+          <li>type: tag type (see TIFF/EXIF specs)</li>
+          <li>len: tag length</li>
+          <li>ord: byte order: 0x4949 for intel, 0x4d4d for motorola</li>
+          <li>ifp: pointer to LibRaw_abstract_datastream input stream,
+            positioned to start of data. There is no need to restore data
+            position in callback.</li>
+        </ul>
+      </dd>
+      <dt>int pre_identify_cb(void *)</dt>
+      <dd>Called with this pointer as the only arg before calling to
+        LibRaw::identify. If this callback return non-zero value, that means
+        that identify() is not needed and all internal data fields are filled
+        with values.</dd>
+      <dt>void post_identify_cb(void *)</dt>
+      <dd>Called after identify() from open_datastream(). May be used to tune
+        internal variables after metadata parse.</dd>
+      <dt>dcraw_process() callbacks</dt>
+      <dd>These callbacks are called before/after dcraw_process phases, the only
+        passed parameter is this pointer
+        <ul>
+          <li>pre_subtractblack_cb - called before black subtraction</li>
+          <li>pre_scalecolors_cb - called before scale_colors() call</li>
+          <li>pre_preinterpolate_cb - called before interpolaton (demosaic)</li>
+          <li>interpolate_bayer_cb - if set, called for bayer demosaic
+            (regardless of params.user_qual value)</li>
+          <li>interpolate_xtrans_cb - if set, called for X-Trans demosaic</li>
+          <li>post_interpolate_cb - called after demosaic step. Note: if this
+            callback is set, standard median_filter() is not called. So, if you
+            need median filtering you should call it from callback function.</li>
+          <li>pre_converttorgb_cb - called after convert_to_rgb()</li>
+          <li>post_converttorgb_cb - called after convert_to_rgb(), so very last
+            processing step.</li>
+        </ul>
+      </dd>
+    </dl>
+    <p><a name="libraw_decoder_info_t"></a></p>
+    <h3>Structure libraw_decoder_info_t: RAW decoder name and data format</h3>
+    <p>This structure describes RAW format decoder name and data format:</p>
+    <dl>
+      <dt>const char *decoder_name</dt>
+      <dd>Decoder function name</dd>
+      <dt>unsigned decoder_flags</dt>
+      <dd>Decoder data format. See <a href="#decoder_flags"> list of
+          LibRaw_decoder_flags </a> for details.</dd>
+    </dl>
+    <p><a name="libraw_processed_image_t"></a></p>
+    <h3>Structure libraw_processed_image_t - result set for
+      dcraw_make_mem_image()/dcraw_make_mem_thumb() functions</h3>
+    <p>Structure libraw_processed_image_t is produced by call of
+      dcraw_make_mem_image()/dcraw_make_mem_thumb() and contains in-memory image
+      of interpolated data or thumbnail. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> LibRaw_image_formats type </strong></dt>
+      <dd>This field records type of data, containing in remaining fields of
+        structure.
+        <ul>
+          <li><strong> LIBRAW_IMAGE_BITMAP </strong> - structure contains RGB
+            bitmap. All metadata fields (see below) are valid and describes
+            image data.</li>
+          <li><strong> LIBRAW_IMAGE_JPEG </strong> - structure contain
+            in-memory image of JPEG file. Only type, data_size and data fields
+            are valid (and nonzero);</li>
+        </ul>
+      </dd>
+      <dt><strong> ushort height,width </strong></dt>
+      <dd>Image size (in pixels). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> ushort colors, bits </strong></dt>
+      <dd>Number of colors components (1 or 3) and color depth in bits (8 or
+        16). These fields are valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> ushort gamma_corrected </strong></dt>
+      <dd>Is bitmap data gamma-corrected (always 1 for 8-bit data, may be 0 or 1
+        for 16-bit). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> unsigned int data_size </strong></dt>
+      <dd>Size of <strong> data </strong> field (in bytes). For bitmap image
+        equal to (height*width*colors * (bits/8)). For JPEG image - exact JPEG
+        size (i.e. extracted thnumbnail size + JPEG header + EXIF header).</dd>
+      <dt><strong> unsigned char data[] </strong></dt>
+      <dd>Data array itself. Should be interpreted as RGB triplets for bitmap
+        type and as JPEG file for JPEG type.</dd>
+    </dl>
+    <p><a name="datastream"></a></p>
+    <h2>Input abstraction layer</h2>
+    <p>RAW data input (read) in LibRaw implemented by calling methods of object
+      derived from <strong> LibRaw_abstract_datastream </strong> abstract
+      class. Full list of methods is described in
+      href="API-CXX.html#datastream"&gt;C++ API reference.</p>
+    <p>There is two ready to use implementations of datastream objects:</p>
+    <ul>
+      <li><a href="API-CXX.html#file_datastream"> LibRaw_file_datastream </a> -
+        file input (filename provided to LibRaw).</li>
+      <li><a href="API-CXX.html#buffer_datastream"> LibRaw_buffer_datastream </a>
+        - input from memory buffer.</li>
+    </ul>
+    <p>LibRaw user can create own datastream object derived from <a href="API-CXX.html#datastream">
+        LibRaw_abstract_datastream </a> . For example, such object may
+      implement reading RAW data directly from camera (by remote interface).
+      LibRaw can use these objects via <a href="API-CXX.html#open_datastream">
+        LibRaw::open_datastream() </a> interface.</p>
+    <p>Datastreams can be used either via <a href="API-CXX.html#open_datastream">
+        LibRaw::open_datastream() </a> call (in this case datastream object
+      should be created an maintained by user) or via <a href="API-CXX.html#open_file">
+        LibRaw::open_file() </a> and <a href="API-CXX.html#open_buffer">
+        LibRaw::open_buffer() </a> shortcuts.</p>
+    <p>Only <a href="API-CXX.html"> C++ API </a> users may use object-oriented
+      interface and implement own input interfaces. For <a href="API-C.html"> C
+        API </a> users only built-on <strong>
+        libraw_open_file()/libraw_open_buffer() </strong> shortcuts are
+      available.</p>
+    <p><a name="datastream_data"></a></p>
+    <h4>Data fields</h4>
+    <p>Definition:</p>
+    <pre>	class LibRaw_abstract_datastream {...protected: LibRaw_abstract_datastream *substream;}
+</pre>
+    <p><strong> Description: </strong> Ojects derived from
+      LibRaw_abstract_datastream always contains pointer to secondary data
+      stream (substream). This substream initialized internally when needed
+      (really used only for Sony RAW data) and used for temporary switch input
+      stream to temporary memory buffer allocated internally in LibRaw.</p>
+    <p>Substream usage details described more precisely in <a href="API-CXX.html#own_datastreams">
+        own datastream objects creation guide </a> .</p>
+    <p><a name="const"></a></p>
+    <h2>Constants</h2>
+    <p><a name="LibRaw_errors"></a></p>
+    <h3>enum LibRaw_errors: Error Codes</h3>
+    <p>All functions returning integer numbers must return either errno or one
+      of the following error codes (see also <a href="API-notes.html#errors">
+        error code conventions </a> ).</p>
+    <p><strong> Fatal errors </strong> (return of such an error code implies
+      that file processing has to be terminated, since the state of data
+      structures is unknown).</p>
+    <dl>
+      <dt><strong> LIBRAW_UNSUFFICIENT_MEMORY </strong></dt>
+      <dd>Attempt to get memory from the system has failed. <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_DATA_ERROR </strong></dt>
+      <dd>A fatal error emerged during data unpacking. <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_IO_ERROR </strong></dt>
+      <dd>A fatal error emerged during file reading (premature end-of-file
+        encountered or file is corrupt). <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_CANCELLED_BY_CALLBACK </strong></dt>
+      <dd>Processing cancelled due to calling application demand (by returning
+        nonzero code from <a href="API-CXX.html#progress"> progress callback </a>
+        ). <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_BAD_CROP </strong></dt>
+      <dd>The incorrect cropping coordinates are set via params.cropbox[]: the
+        left-top corner of cropping rectangle is outside the image. The
+        processing will be cancelled, all allocated resources will be freed, <a
+
+          <dt=""><strong> LIBRAW_TOO_BIG</strong> </a></dd>
+      <dd><a <dt="">Raw data size exceeds data limit.</a></dd>
+      <a <dt=""> </a>
+    </dl>
+    <a <dt="">
+      <p><strong> Non-Fatal Errors </strong></p>
+    </a>
+    <dl>
+      <a <dt=""> <dt><strong> LIBRAW_SUCCESS=0 </strong></dt>
+        <dd>No error; function terminated successfully.</dd>
+        <dt><strong> LIBRAW_UNSPECIFIED_ERROR </strong></dt>
+        <dd>An unknown error has been encountered. This code should never be
+          generated.</dd>
+        <dt><strong> LIBRAW_FILE_UNSUPPORTED </strong></dt>
+        <dd>Unsupported file format (attempt to open a RAW file with a format
+          unknown to the program).</dd>
+        <dt><strong> LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE </strong></dt>
+        <dd>Attempt to retrieve a RAW image with a number absent in the data
+          file (only for formats supporting storage of several images in a
+          file).</dd>
+        <dt><strong> LIBRAW_OUT_OF_ORDER_CALL </strong></dt>
+      </a><dd><a <dt="">API functions have been called in wrong order (e.g., </a><a
+
+          href="API-CXX.html#unpack"> unpack() </a> before <a href="API-CXX.html#open_file">
+          open_file() </a> ) or the previous stage has ended with an error
+        (e.g., <a href="API-CXX.html#unpack"> unpack() </a> is called after <a
+
+          href="API-CXX.html#open_file"> open_file() </a> has returned an
+        error).</dd>
+      <dt><strong> LIBRAW_NO_THUMBNAIL </strong></dt>
+      <dd>Returned upon an attempt to retrieve a thumbnail from a file
+        containing no preview.</dd>
+      <dt><strong> LIBRAW_UNSUPPORTED_THUMBNAIL </strong></dt>
+      <dd>RAW file contains a preview of unsupported format.</dd>
+    </dl>
+    <p><a name="decoder_flags"></a></p>
+    <h3>enum LibRaw_decoder_flags - RAW data format description</h3>
+    <p>Depending of capabilities of given data format, the buffer with RAW data
+      may have different layouts:</p>
+    <dl>
+      <dt><strong> LIBRAW_DECODER_HASCURVE </strong></dt>
+      <dd>This flag is set if decoder uses RAW tone curve and curve data may be
+        modified before call to decoder (i.e. curve values are not read or
+        calculated within decoder).</dd>
+      <dt><strong> LIBRAW_DECODER_SONYARW2 </strong></dt>
+      <dd>This flag is set if file format is Sony ARW2.3, so sony_arw2_options
+        is applicable.</dd>
+      <dt><strong> LIBRAW_DECODER_TRYRAWSPEED </strong></dt>
+      <dd>This flag is set if file format is (possibly) supported by RawSpeed
+        library, so unpack() will try to use it.</dd>
+      <dt><strong> LIBRAW_DECODER_FIXEDMAXC </strong></dt>
+      <dd>Do not use automated maximum calculation for this data format.</dd>
+      <dt><strong> LIBRAW_DECODER_OWNALLOC </strong></dt>
+      <dd>Decoder allocates data, no need to pass allocated memory to decoder.</dd>
+      <dt><strong>LIBRAW_DECODER_ADOBECOPYPIXEL</strong></dt>
+      <dd>Internal flag, special to adobe DNG decoder.</dd>
+      <dt><strong>LIBRAW_DECODER_LEGACY_WITH_MARGINS</strong></dt>
+      <dd>Special flag uset for 4-channel (legacy) decoders with black/masked
+        areas</dd>
+      <dt><strong>LIBRAW_DECODER_3CHANNEL</strong></dt>
+      <dd>3-component full-color data (not usual 4-component)</dd>
+    </dl>
+    <p><a name="progress"></a></p>
+    <h3>enum LibRaw_progress: Current State of LibRaw Object</h3>
+    <p>LibRaw::imgdata.progress_flags contains a bit mask describing all stages
+      of file processing that have already been performed.</p>
+    <p><strong> File opening and RAW data extraction phase. </strong></p>
+    <dl>
+      <dt><strong> LIBRAW_PROGRESS_START=0 </strong></dt>
+      <dd>Object just created, no processing carried out.</dd>
+      <dt><strong> LIBRAW_PROGRESS_OPEN </strong></dt>
+      <dd>File to be processed has been opened.</dd>
+      <dt><strong> LIBRAW_PROGRESS_IDENTIFY </strong></dt>
+      <dd>Data identification performed, format recognized, metadata extracted.</dd>
+      <dt><strong> LIBRAW_PROGRESS_SIZE_ADJUST </strong></dt>
+      <dd>Data sizes adjusted (for files that require such adjustment, namely,
+        certain files from Kodak cameras).</dd>
+      <dt><strong> LIBRAW_PROGRESS_LOAD_RAW </strong></dt>
+      <dd>RAW data loaded.</dd>
+    </dl>
+    <p><strong> The following flags are set during usage of image processing
+        that has been taken from dcraw. </strong></p>
+    <dl>
+      <dt><strong> LIBRAW_PROGRESS_RAW2_IMAGE </strong></dt>
+      <dd>imgdata.image array allocated and filled with data.</dd>
+      <dt><strong> LIBRAW_PROGRESS_REMOVE_ZEROES </strong></dt>
+      <dd>Zero values removed for cameras that require such removal (Panasonic
+        cameras).</dd>
+      <dt><strong> LIBRAW_PROGRESS_BAD_PIXELS </strong></dt>
+      <dd>Bad (dead) pixels removed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_DARK_FRAME </strong></dt>
+      <dd>Dark frame subtracted from RAW data.</dd>
+      <dt><strong> LIBRAW_PROGRESS_FOVEON_INTERPOLATE </strong></dt>
+      <dd>Interpolation for cameras with a Foveon sensor performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_SCALE_COLORS </strong></dt>
+      <dd>White balance performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_PRE_INTERPOLATE </strong></dt>
+      <dd>Image size reduction (for the half_size mode) performed, as well as
+        copying of 2nd green channel to the 1st one in points where the second
+        channel is present and the first one is absent.</dd>
+      <dt><strong> LIBRAW_PROGRESS_INTERPOLATE </strong></dt>
+      <dd>Interpolation (debayer) performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_MIX_GREEN </strong></dt>
+      <dd>Averaging of green channels performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_MEDIAN_FILTER </strong></dt>
+      <dd>Median filtration performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_HIGHLIGHTS </strong></dt>
+      <dd>Work with highlights performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_FUJI_ROTATE </strong></dt>
+      <dd>For images from Fuji cameras, rotation performed (or
+        adjust_sizes_info_only() called).</dd>
+      <dt><strong> LIBRAW_PROGRESS_FLIP </strong></dt>
+      <dd>Dimensions recalculated for images shot with a rotated camera
+        (sizes.iwidth/sizes.iheight swapped).</dd>
+      <dt><strong> LIBRAW_PROGRESS_CONVERT_RGB </strong></dt>
+      <dd>Conversion into output RGB space performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_STRETCH </strong></dt>
+      <dd>Image dimensions changed for cameras with non-square pixels.</dd>
+      <dt><strong> LIBRAW_PROGRESS_STAGE17 - LIBRAW_PROGRESS_STAGE27 </strong></dt>
+      <dd>Reserved for possible appearance of other processing stages.</dd>
+    </dl>
+    <p><strong> The following flags are set during loading of thumbnails. </strong></p>
+    <p><strong> LIBRAW_PROGRESS_THUMB_LOAD </strong> Thumbnail data have been
+      loaded (for Kodak cameras, the necessary conversions have also been made).
+      <strong> LIBRAW_PROGRESS_TRESERVED1 - LIBRAW_PROGRESS_TRESERVED3 </strong>
+      Reserved for possible future processing stages.</p>
+    <p><a name="LibRaw_whitebalance_code"></a></p>
+    <h3>enum LibRaw_whitebalance_code - names for standard light sources</h3>
+    <p>LIBRAW_WBI_lightsource_name, where name and value are standard EXIF light
+      sources. <a name="LibRaw_runtime_capabilities"></a></p>
+    <h3>enum LibRaw_camera_mounts - codes for camera mounts</h3>
+    <p>Constant name (e.g. LIBRAW_MOUNT_Leica_SL) speaks for itself</p>
+    <h3>enum LibRaw_runtime_capabilities - libraw capabilities set at build</h3>
+    <ul>
+      <li><strong>LIBRAW_CAPS_RAWSPEED</strong> - compiled with RawSpeed</li>
+      <li><strong>LIBRAW_CAPS_DNGSDK </strong>- compiled with Adobe DNG SDK</li>
+      <li><strong>LIBRAW_CAPS_GPRSDK</strong> - compiled w/ GoPro GPR SDK</li>
+      <li><strong>LIBRAW_CAPS_UNICODEPATHS</strong> - compiled with Windows
+        unicode (wchar_t*) filenames support</li>
+    </ul>
+    <p><a name="LibRaw_thumbnail_formats"></a></p>
+    <h3>enum LibRaw_thumbnail_formats: Thumbnail Data Formats</h3>
+    <p>Thumbnail data format is written in the imgdata.thumbnail.tformat data
+      field. <br>
+      Presently LibRaw knows about four thumbnail formats, among which two are
+      unpacked:</p>
+    <dl>
+      <dt><strong> LIBRAW_THUMBNAIL_UNKNOWN </strong></dt>
+      <dd>Format unknown or thumbnail not yet read.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_JPEG </strong></dt>
+      <dd>The thumbnail buffer contains a JPEG file (read from the RAW file "as
+        is," without any manipulations performed on it).</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_BITMAP </strong></dt>
+      <dd>The thumbnail buffer contains the gamma-adjusted RGB bitmap (for Kodak
+        cameras, the gamma correction is performed with allowance for maximum
+        values and the white balance is set in accordance with the camera
+        settings). <br>
+        In this format, each pixel of the image is represented by a 8-bit RGB
+        triplet.</dd>
+      <dt><strong>LIBRAW_THUMBNAIL_BITMAP16</strong></dt>
+      <dd>The thumbnail buffer contains the gamma-adjusted 16-bit RGB bitmap. To
         get this format instead of <strong> LIBRAW_THUMBNAIL_BITMAP </strong>you
-        need to set <strong>LIBRAW_PROCESSING_USE_PPM16_THUMBS</strong> in
-        processing options.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_LAYER </strong></dt>
-      <dd>Data format is presently recognized upon opening of RAW file but not
-        supported: not unpacked into LibRaw::unpack_thumb.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_ROLLEI </strong></dt>
-      <dd>Data format is presently recognized upon opening of RAW file but not
-        supported: not unpacked into LibRaw::unpack_thumb.</dd>
-    </dl>
-    <p><a name="warnings"></a></p>
-    <h3>Nonstandard Situations (Warnings) during RAW Data Processing</h3>
-    <p>Some suspicious situations emerging during image processing are not fatal
-      but may affect the result of data retrieval or postprocessing. Such states
-      are indicated by setting a bit in the imgdata.process_warnings field.</p>
-    <dl>
-      <dt><strong> LIBRAW_WARN_BAD_CAMERA_WB </strong></dt>
-      <dd>Postprocessing must use white balance of the camera but this balance
-        is not suitable for use.</dd>
-      <dt><strong> LIBRAW_WARN_NO_METADATA </strong></dt>
-      <dd>Only for cameras where the metadata are taken from an external JPEG
-        file: metadata extraction has failed.</dd>
-      <dt><strong> LIBRAW_WARN_NO_JPEGLIB </strong></dt>
-      <dd>Only for P&amp;S Kodak cameras: data in JPEG format. At the same time,
-        open_file() will return LIBRAW_FILE_UNSUPPORTED.</dd>
-      <dt><strong> LIBRAW_WARN_NO_EMBEDDED_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Caller set embedded input profile
-        use, but no such profile exists in RAW.</dd>
-      <dt><strong> LIBRAW_WARN_NO_INPUT_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Error when opening input profile
-        ICC file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_OUTPUT_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Error when opening output profile
-        ICC file.</dd>
-      <dt><strong> LIBRAW_WARN_NO_BADPIXELMAP </strong></dt>
-      <dd>Error when opening bad pixels map file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_FILE </strong></dt>
-      <dd>Error when opening dark frame file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_DIM </strong></dt>
-      <dd>Dark frame file either differs in dimensions from RAW-file processed,
-        or have wrong format. Dark frame should be in 16-bit PGM format (one can
-        generate it using simple_dcraw -4 -D).</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_PROBLEM </strong></dt>
-      <dd>Problems detected in RawSpeed decompressor. The image data processed
-        by LibRaw own decoder.</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_UNSUPPORTED </strong></dt>
-      <dd>This file not supported by RawSpeed (although compatible decoder
-        exists).</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_PROCESSED </strong></dt>
-      <dd>Not warning, but information. The file was decoded by RawSpeed.</dd>
-      <dt><strong> LIBRAW_WARN_FALLBACK_TO_AHD </strong></dt>
-      <dd>Incorrect/unsupported user_qual was set, AHD demosaic used instead.</dd>
-      <dt><strong> LIBRAW_WARN_PARSEFUJI_PROCESSED</strong></dt>
-      <dd>Not really a warning, but flag that fuji parser was used.</dd>
-      <dt><strong>LIBRAW_DNGSDK_PROCESSED</strong></dt>
-      <dd>Not really a warning: image was decoded by DNG SDK</dd>
-      <dt><strong> LIBRAW_DNG_IMAGES_REORDERED</strong></dt>
-      <dd>DNG sub0images was reordered </dd>
-      <dt><strong>LIBRAW_DNG_STAGE2_APPLIED</strong></dt>
-      <dd>DNG Stage2 conversion was performed</dd>
-      <dt><strong> LIBRAW_DNG_STAGE3_APPLIED</strong></dt>
-      <dd>DNG Stage3 conversion was performed</dd>
-    </dl>
-    <dl>
-    </dl>
-    <p><a name="LibRaw_image_formats"></a></p>
-    <h3>enum LibRaw_image_formats - possible types of data, contains in
-      libraw_processed_image_t structure</h3>
-    <p><strong> type </strong> field of libraw_processed_image_t structure may
-      have one of these values:</p>
-    <dl>
-      <dt><strong> LIBRAW_IMAGE_BITMAP </strong></dt>
-      <dd>The structure contains RGB-bitmap, metadata described in other fields
-        of libraw_processed_image_t.</dd>
-      <dt><strong> LIBRAW_IMAGE_JPEG </strong></dt>
-      <dd>libraw_processed_image_t structure contains JPEG image (in memory).
-        Only data_size field is meaningful.</dd>
-    </dl>
-    <p> <a name="LibRaw_processing_options"></a></p>
-    <h3> enum enum LibRaw_processing_options - bit that affects RAW data
-      extraction</h3>
-    These flags could be OR'ed with imgdata.params.raw_processing_options:
-    <p>Pentax 4-shot options:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES</b> - merge all frames for
-        Pentax 4-shot files</li>
-    </ul>
-    <p>Floating point DNG files:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT</b> - convert FP data to
-        16-bit integer</li>
-    </ul>
-    <p>Sony ARQ Files:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP</b> - do not perform Sony
-        ARQ channel swap to RGBG channel format, but use RGGB original channel
-        order</li>
-    </ul>
-    <p>DNG processing flags:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP</b> - use DNG DefaultCrop*
-        tags for cropping</li>
-      <li><b>LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT</b> - skip DNG
-        illuminant check when parsing DNG color data (use for compatibility w/
-        older LibRaw versions).</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY</b> - do not copy data extracted
-        by Adobe DNG SDK into separate buffer, but use DNG SDK buffer as is.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED</b> - if set, LibRaw will add
-        Enhanced DNG frame (NewSubfileType == 16) to the list of available
-        frames.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS</b> - if set, LibRaw will add
-        previews (NewSubfileType == 1) to the frames list.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE</b>- By default, DNG
-        frames are not reordered and are available in same order as in DNG&nbsp;
-        (LibRaw traverses IFD/Sub-IFD trees in deep-first order).This bit will
-        prioritize the largest image</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE2</strong> - request DNG Stage2
-        processing (by DNG SDK)</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE3</strong> - request DNG Stage3
-        processing</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_ALLOWSIZECHANGE</strong> - by default,
-        if image size parsed by DNG SDK does not match image dimensions parsed
-        by LibRaw, processing will stop with LIBRAW_DATA_ERROR code. This flags
-        allows size change in LibRaw::unpack() stage.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST</strong> - by default,
-        for DNG images with different per-channel maximums WB adjustment
-        procedure is performed. This flag disables such adjustment.</li>
-    </ul>
-    Other flags
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS</b> - disable
-        auto-rotation for Kodak PPM bitmaps</li>
-      <li><b>LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS</b> - enable 16-bit PPM
-        thumbnails</li>
-      <li><b>LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS</b> - by default,
-        LibRaw assigns bayer pattern for Monochrome TIFF files (e.g. images from
-        Kodak 760).This does not work as expected if input file is really
-        monochrome (e.g. scan from Imacon X1 in monochrome mode).This flag will
-        force monochrome mode for TIFF RAWs w/o bayer filter tags (so, it will
-        break old Kodak processing). It is better to make it settable via user
-        interaction.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB</strong> - If set and
-        when applicable, color.cam_mul[] and color.WB_Coeffs/WBCT_Coeffs will
-        contain WB settings for a non-standard workflow. Right now only Sony
-        DSC-F828 is affected: camera-recorded white balance can't be directly
-        applied to raw data because WB is for RGB, while raw data is RGBE.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT</strong> - if
-        use_camera_wb is set, but no camera-recorded white balance present in
-        metadata, then fallback to daylight WB (default: fallback to
-        auto-balance).</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS</strong> -
-        Some cameras (e.g.Ricoh) may record broken thumbnail in file:data offset
-        plus data size is beyond filecontents. This flag enforces size+offset
-        checks for files from known vendors (this will result into correct but
-        smaller thumbnail selected).</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS</strong> - same
-        is above, but check is performed regardless of vendor (Make tag).</li>
-    </ul>
-    <ul>
-    </ul>
-    <p> <a name="LibRaw_rawspecial_t"></a></p>
-    <h3>enum LibRaw_rawspecial_t - special/non standard RAW extraction modes</h3>
-    These flags are applied to imgdata.rawparams:
-    <p>Sony ARW2.3 processing options: (for more details see
-      http://www.rawdigger.com/howtouse/sony-craw-arw2-posterization-detection)</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_BASEONLY</b> - decode only base pixels,
-        leave delta pixels as zero;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAONLY</b> - decode only delta pixels
-        with base pixels zeroed;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAZEROBASE</b> - decode delta pixels,
-        do not add base value;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTATOVALUE</b> - show possible
-        posterization areas;</li>
-    </ul>
-    <p>Sigma Quattro decoding flags:</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATERG</b> - disable R/G channels
-        interpolation</li>
-      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATEAF</b> - disable data
-        interpolation of low-sensitivity (AF or overexposure control) points on
-        Quattro sensors.</li>
-    </ul>
-    <p>Canon/Nikon small RAW (YCC) decoding flags (do not use both at same
-      time):</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_RGB</b> - disable YCC to RGB conversion</li>
-      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE</b> - disable missing color
-        values interpolation</li>
-    </ul>
-    <a href="index.html">[back to Index] </a>
-  </body>
-</html>
+        need to set <strong>LIBRAW_PROCESSING_USE_PPM16_THUMBS</strong> in
+        processing options.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_LAYER </strong></dt>
+      <dd>Data format is presently recognized upon opening of RAW file but not
+        supported: not unpacked into LibRaw::unpack_thumb.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_ROLLEI </strong></dt>
+      <dd>Data format is presently recognized upon opening of RAW file but not
+        supported: not unpacked into LibRaw::unpack_thumb.</dd>
+      <dt><strong>LIBRAW_THUMBNAIL_H265</strong></dt>
+      <dd>The thumbnail buffer contains a H.265 data frame (read from RAW file
+        as is, no manipulations performed on it).</dd>
+    </dl>
+    <p><a name="warnings"></a></p>
+    <h3>Nonstandard Situations (Warnings) during RAW Data Processing</h3>
+    <p>Some suspicious situations emerging during image processing are not fatal
+      but may affect the result of data retrieval or postprocessing. Such states
+      are indicated by setting a bit in the imgdata.process_warnings field.</p>
+    <dl>
+      <dt><strong> LIBRAW_WARN_BAD_CAMERA_WB </strong></dt>
+      <dd>Postprocessing must use white balance of the camera but this balance
+        is not suitable for use.</dd>
+      <dt><strong> LIBRAW_WARN_NO_METADATA </strong></dt>
+      <dd>Only for cameras where the metadata are taken from an external JPEG
+        file: metadata extraction has failed.</dd>
+      <dt><strong> LIBRAW_WARN_NO_JPEGLIB </strong></dt>
+      <dd>Only for P&amp;S Kodak cameras: data in JPEG format. At the same time,
+        open_file() will return LIBRAW_FILE_UNSUPPORTED.</dd>
+      <dt><strong> LIBRAW_WARN_NO_EMBEDDED_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Caller set embedded input profile
+        use, but no such profile exists in RAW.</dd>
+      <dt><strong> LIBRAW_WARN_NO_INPUT_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Error when opening input profile
+        ICC file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_OUTPUT_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Error when opening output profile
+        ICC file.</dd>
+      <dt><strong> LIBRAW_WARN_NO_BADPIXELMAP </strong></dt>
+      <dd>Error when opening bad pixels map file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_FILE </strong></dt>
+      <dd>Error when opening dark frame file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_DIM </strong></dt>
+      <dd>Dark frame file either differs in dimensions from RAW-file processed,
+        or have wrong format. Dark frame should be in 16-bit PGM format (one can
+        generate it using simple_dcraw -4 -D).</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_PROBLEM </strong></dt>
+      <dd>Problems detected in RawSpeed decompressor. The image data processed
+        by LibRaw own decoder.</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_UNSUPPORTED </strong></dt>
+      <dd>This file not supported by RawSpeed (although compatible decoder
+        exists).</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_PROCESSED </strong></dt>
+      <dd>Not warning, but information. The file was decoded by RawSpeed.</dd>
+      <dt><strong> LIBRAW_WARN_FALLBACK_TO_AHD </strong></dt>
+      <dd>Incorrect/unsupported user_qual was set, AHD demosaic used instead.</dd>
+      <dt><strong> LIBRAW_WARN_PARSEFUJI_PROCESSED</strong></dt>
+      <dd>Not really a warning, but flag that fuji parser was used.</dd>
+      <dt><strong>LIBRAW_DNGSDK_PROCESSED</strong></dt>
+      <dd>Not really a warning: image was decoded by DNG SDK</dd>
+      <dt><strong> LIBRAW_DNG_IMAGES_REORDERED</strong></dt>
+      <dd>DNG sub0images was reordered </dd>
+      <dt><strong>LIBRAW_DNG_STAGE2_APPLIED</strong></dt>
+      <dd>DNG Stage2 conversion was performed</dd>
+      <dt><strong> LIBRAW_DNG_STAGE3_APPLIED</strong></dt>
+      <dd>DNG Stage3 conversion was performed</dd>
+    </dl>
+    <dl>
+    </dl>
+    <p><a name="LibRaw_image_formats"></a></p>
+    <h3>enum LibRaw_image_formats - possible types of data, contains in
+      libraw_processed_image_t structure</h3>
+    <p><strong> type </strong> field of libraw_processed_image_t structure may
+      have one of these values:</p>
+    <dl>
+      <dt><strong> LIBRAW_IMAGE_BITMAP </strong></dt>
+      <dd>The structure contains RGB-bitmap, metadata described in other fields
+        of libraw_processed_image_t.</dd>
+      <dt><strong> LIBRAW_IMAGE_JPEG </strong></dt>
+      <dd>libraw_processed_image_t structure contains JPEG image (in memory).
+        Only data_size field is meaningful.</dd>
+    </dl>
+    <p> <a name="LibRaw_processing_options"></a></p>
+    <h3> enum enum LibRaw_processing_options - bit that affects RAW data
+      extraction</h3>
+    These flags could be OR'ed with imgdata.params.raw_processing_options:
+    <p>Pentax 4-shot options:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES</b> - merge all frames for
+        Pentax 4-shot files</li>
+    </ul>
+    <p>Floating point DNG files:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT</b> - convert FP data to
+        16-bit integer</li>
+    </ul>
+    <p>Sony ARQ Files:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP</b> - do not perform Sony
+        ARQ channel swap to RGBG channel format, but use RGGB original channel
+        order</li>
+    </ul>
+    <p>DNG processing flags:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT</b> - skip DNG
+        illuminant check when parsing DNG color data (use for compatibility w/
+        older LibRaw versions).</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY</b> - do not copy data extracted
+        by Adobe DNG SDK into separate buffer, but use DNG SDK buffer as is.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED</b> - if set, LibRaw will add
+        Enhanced DNG frame (NewSubfileType == 16) to the list of available
+        frames.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS</b> - if set, LibRaw will add
+        previews (NewSubfileType == 1) to the frames list.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE</b>- By default, DNG
+        frames are not reordered and are available in same order as in DNG&nbsp;
+        (LibRaw traverses IFD/Sub-IFD trees in deep-first order).This bit will
+        prioritize the largest image</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE2</strong> - request DNG Stage2
+        processing (by DNG SDK)</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE3</strong> - request DNG Stage3
+        processing</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_ALLOWSIZECHANGE</strong> - by default,
+        if image size parsed by DNG SDK does not match image dimensions parsed
+        by LibRaw, processing will stop with LIBRAW_DATA_ERROR code. This flags
+        allows size change in LibRaw::unpack() stage.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST</strong> - by default,
+        for DNG images with different per-channel maximums WB adjustment
+        procedure is performed. This flag disables such adjustment.</li>
+    </ul>
+    Other flags
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS</b> - disable
+        auto-rotation for Kodak PPM bitmaps</li>
+      <li><b>LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS</b> - enable 16-bit PPM
+        thumbnails</li>
+      <li><b>LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS</b> - by default,
+        LibRaw assigns bayer pattern for Monochrome TIFF files (e.g. images from
+        Kodak 760).This does not work as expected if input file is really
+        monochrome (e.g. scan from Imacon X1 in monochrome mode).This flag will
+        force monochrome mode for TIFF RAWs w/o bayer filter tags (so, it will
+        break old Kodak processing). It is better to make it settable via user
+        interaction.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB</strong> - If set and
+        when applicable, color.cam_mul[] and color.WB_Coeffs/WBCT_Coeffs will
+        contain WB settings for a non-standard workflow. Right now only Sony
+        DSC-F828 is affected: camera-recorded white balance can't be directly
+        applied to raw data because WB is for RGB, while raw data is RGBE.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT</strong> - if
+        use_camera_wb is set, but no camera-recorded white balance present in
+        metadata, then fallback to daylight WB (default: fallback to
+        auto-balance).</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS</strong> -
+        Some cameras (e.g.Ricoh) may record broken thumbnail in file:data offset
+        plus data size is beyond filecontents. This flag enforces size+offset
+        checks for files from known vendors (this will result into correct but
+        smaller thumbnail selected).</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS</strong> - same
+        is above, but check is performed regardless of vendor (Make tag).</li>
+    </ul>
+    <ul>
+    </ul>
+    <p> <a name="LibRaw_rawspecial_t"></a></p>
+    <h3>enum LibRaw_rawspecial_t - special/non standard RAW extraction modes</h3>
+    These flags are applied to imgdata.rawparams:
+    <p>Sony ARW2.3 processing options: (for more details see
+      http://www.rawdigger.com/howtouse/sony-craw-arw2-posterization-detection)</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_BASEONLY</b> - decode only base pixels,
+        leave delta pixels as zero;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAONLY</b> - decode only delta pixels
+        with base pixels zeroed;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAZEROBASE</b> - decode delta pixels,
+        do not add base value;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTATOVALUE</b> - show possible
+        posterization areas;</li>
+    </ul>
+    <p>Sigma Quattro decoding flags:</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATERG</b> - disable R/G channels
+        interpolation</li>
+      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATEAF</b> - disable data
+        interpolation of low-sensitivity (AF or overexposure control) points on
+        Quattro sensors.</li>
+    </ul>
+    <p>Canon/Nikon small RAW (YCC) decoding flags (do not use both at same
+      time):</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_RGB</b> - disable YCC to RGB conversion</li>
+      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE</b> - disable missing color
+        values interpolation</li>
+    </ul>
+    <a href="index.html">[back to Index] </a>
+  </body>
+</html>
diff --git a/doc/Samples-LibRaw.html b/doc/Samples-LibRaw.html
index 37b41c08..c72a3f94 100644
--- a/doc/Samples-LibRaw.html
+++ b/doc/Samples-LibRaw.html
@@ -1,205 +1,205 @@
 <html>
   <head>
     <meta http-equiv="content-type" content="text/html; charset=windows-1252">
   </head>
   <body>
     <p>LibRaw: Usage Examples<a href="index.html">[back to Index]</a></p>
     <h1>LibRaw: Usage Examples</h1>
     <h2>Overview of Examples in the Distribution Package (samples/*)</h2>
     <p>The LibRaw package contains several examples illustrating the use of this
       library. Their source codes are located in the samples/ folder, and after
       library build they will be in the bin/ folder:</p>
     <ul>
       <li><strong>raw-identify</strong> The only LibRaw call it uses is <a href="API-CXX.html#open_file">open_file()</a>;
         further code prints the values of the fields of the imgdata structure. <strong><br>
         </strong><strong>raw-identify -v</strong> provides extensive dump of
         metadata/<br>
         Command line key <strong>-u</strong> shows unpacking function name,
         while <strong>-u -f</strong> prints function name and masked are sizes.<br>
         <strong>raw-identify -w </strong>will print white balance tables stored
         in RAW file.</li>
       <li><strong>simple_dcraw</strong> A simple "emulation" of dcraw
         reproducing the behavior of <strong>dcraw [-e] [-v] [-T]</strong>.&nbsp;
         A simplified version of this example is <a href="#code">considered
           below</a>. <br>
         <strong>-B</strong> command-line switch turns on use of <a href="API-CXX.html#open_buffer">open_buffer()
           API call</a> used via mmap() of input file (Unix only).</li>
       <li><strong>dcraw_half</strong> Demonstrates the use of <a href="API-C.html">C
           API</a>. The example emulates the behavior of <strong>dcraw -h</strong>
         (no other control parameters can be specified in this example). </li>
-      <li><strong>dcraw_emu</strong> Complete emulation of dcraw (except for
-        keys -D -d -P -K -i -e, which are considered in other usage examples).
+      <li><strong>dcraw_emu</strong> Almost complete emulation of dcraw (except for
+        keys -D -d -E -i -v -e, which are considered in other usage examples).
         Of most interest is processing of command line keys (copied from dcraw).
         <br>
         <p>This sample supports additional command-line parameters absent in
           original dcraw:</p>
         <dl>
           <dt><strong>-mmap</strong></dt>
           <dd>Use <a href="API-CXX.html#open_buffer">open_buffer()</a>
             interface. Buffer prepared by mmap() call. This option not supported
             under Win32.</dd>
           <dt><strong>-meme</strong></dt>
           <dd>Use <a href="API-CXX.html#open_buffer">open_buffer()</a>
             interface. Buffer prepared by malloc()+read() calls.</dd>
           <dt><strong>-c float-value</strong></dt>
           <dd>This key sets <strong>params.adjust_maximum_thr</strong>
             parameter.<br>
             Use -c 0 to completely disable automatic maximum calculation. <br>
             Default value: 0.75</dd>
           <dt><strong>-timing</strong></dt>
           <dd>Turns on detailed timing print.</dd>
           <dt><strong>-G</strong></dt>
           <dd>Turns on "green_matching" mode to suppress color mazes on cameras
             with different green channels.</dd>
           <dt><strong>-B x y w h</strong></dt>
           <dd>Crops output to rectangle with width w, height h and x,y
             coordinates of left upper corner. All coordinates applied before any
             image rotation.</dd>
           <dt><strong>-F</strong></dt>
           <dd>Will use FILE I/O (bigfile_datastream) instead on standard
             LibRaw_file_datastream.</dd>
           <dt><strong>-dcbi N</strong></dt>
           <dd>Sets number of additional DCB-demosaic iterations (option valid
             only for -q 4, i.e. for DCB demosaic).</dd>
           <dt><strong>-dcbe</strong></dt>
           <dd>Turns on DCB color enhance mode (only for DCB demosaic, -q 4).</dd>
           <dt><strong>-aexpo e p</strong></dt>
           <dd>Turns on exposure correction. e is exposure shift in linear scale
             from 0.25 (darken 2 stops) to 8.0 (lighten 3 stops). p is highlights
             preservation amount from 0.0 (no preservation, full clipping) to 1.0
             (full preservation, S-like curve in highlights).</dd>
           <dt><strong>-apentax4shot</strong></dt>
           <dd>Will merge 4 frames from Pentax 4-shot RAWs</dd>
           <dt><strong>-apentax4shotorder abce</strong></dt>
           <dd>Order of frames in pentax 4-shot files (default is 3102)</dd>
           <dt><strong>-mmap</strong></dt>
           <dd>Use mmap + memory IO instead of file IO (unix only)</dd>
           <dt><strong>-disars</strong></dt>
           <dd>Disable RawSpeed library (if compiled with this library)</dd>
           <dt><strong>-doutputflags N</strong></dt>
           <dd>set imgdata.params.output_flags to N</dd>
           <dt><strong>-disinterp</strong></dt>
           <dd>Do not run interpolation step</dd>
           <dt><strong>-dsrawrgb1</strong></dt>
           <dd>Disable YCbCr to RGB conversion for sRAW (Cb/Cr interpolation
             enabled)</dd>
           <dt><strong>-dsrawrgb2</strong></dt>
           <dd>Disable YCbCr to RGB conversion for sRAW (Cb/Cr interpolation
             disabled)</dd>
         </dl>
       </li>
       <li><strong>half_mt</strong> Emulation of <strong>dcraw -h</strong>. It
         "understands" the following keys: -a (automatic white balance over the
         entire image), -w (white balance of the camera), -T (output in the tiff
         format), and -J n (number of parallel threads launched for image
         processing).<br>
         On multiprocessor/multicore computers, the speed gain is notable in the
         case of mass processing. On a Win32 machine, the example is assembled
         from the initial file half_mt_win32.c, since work with threads under
         Windows is fundamentally different and it it easier to copy simple
         source codes than write one complex code.</li>
       <li><strong>mem_image</strong> This sample uses <a href="API-CXX.html#dcraw_make_mem_image">dcraw_make_mem_image</a>
         and <a href="API-CXX.html#dcraw_make_mem_thumb">dcraw_make_mem_thumb</a>
         calls, than writes data in PPM format. </li>
       <li><strong>unprocessed_raw</strong> This sample extracts (mostly)
         unaltered RAW data including masked pixels data (on supported cameras).
         If black frame exists and black frame extraction is supported for given
         format, masked pixels data is added to resulting .TIFF file. Command
         line options: <strong>-q</strong> - be quiet, <strong>-A</strong> -
         autoscale data (integer multiplier), <strong>-g</strong>
         gamma-correction (gamma 2.2) for data (instead of precise linear one), <strong>-B</strong>
         turns on black level subtraction</li>
       <li><strong>4channnels</strong> - splits RAW-file into four separate
         16-bit grayscale TIFFs (per RAW channel).<br>
         Command line switches:
         <ul>
           <li><strong>-s N</strong> selects N-th image from RAW with multiple
             images</li>
           <li><strong>-g</strong> gamma correction (gamma 2.2)</li>
           <li><strong>-A</strong> values autoscale by auto-calculated integer
             factor</li>
           <li><strong>-B</strong> turn off black subtraction</li>
           <li><strong>-N</strong> no RAW curve</li>
         </ul>
       </li>
       <li><strong>multirender_test</strong> - very simple example of multiple
         rendering on one file without reopen.</li>
       <li><strong>postprocessing_benchmark</strong> - will print timings of RAW
         processing steps</li>
     </ul>
     <h2>Example of docmode</h2>
     <p>Below we consider the samples/simple_dcraw.cpp example, which emulates
       the behavior of <strong>dcraw [-e][-v][-t]</strong>. To save space, let
       us assume that keys -t -v are always specified (to avoid comments on
       command line parsing) and there is always one parameter (name of file),
       which is the only one and always passed to the program.</p>
     <pre>int main(int ac, char *av[])
 {
  int i, ret, verbose=0, output_thumbs=0;
  char outfn[1024],thumbfn[1024];
  // Creation of image processing object
  LibRaw RawProcessor;
  // The date in TIFF is written in the local format; let us specify the timezone for compatibility with dcraw
  putenv ((char*)"TZ=UTC");
 // Let us define variables for convenient access to fields of RawProcessor
 #define P1 RawProcessor.imgdata.idata
 #define S RawProcessor.imgdata.sizes
 #define C RawProcessor.imgdata.color
 #define T RawProcessor.imgdata.thumbnail
 #define P2 RawProcessor.imgdata.other
 #define OUT RawProcessor.imgdata.params
  OUT.output_tiff = 1; // Let us output TIFF
  // Let us open the file
  if( (ret = RawProcessor.open_file(av[1])) != LIBRAW_SUCCESS)
  {
  fprintf(stderr,"Cannot open %s: %s\n",av[i],libraw_strerror(ret));
  // recycle() is needed only if we want to free the resources right now.
  // If we process files in a cycle, the next open_file()
  // will also call recycle(). If a fatal error has happened, it means that recycle()
  // has already been called (repeated call will not cause any harm either).
  RawProcessor.recycle();
  goto end;
  }
  // Let us unpack the image
  if( (ret = RawProcessor.unpack() ) != LIBRAW_SUCCESS)
  {
  fprintf(stderr,"Cannot unpack_thumb %s: %s\n",av[i],libraw_strerror(ret));
  if(LIBRAW_FATAL_ERROR(ret))
  goto end;
  // if there has been a non-fatal error, we will try to continue
  }
  // Let us unpack the thumbnail
  if( (ret = RawProcessor.unpack_thumb() ) != LIBRAW_SUCCESS)
  {
  // error processing is completely similar to the previous case
  fprintf(stderr,"Cannot unpack_thumb %s: %s\n",av[i],libraw_strerror(ret));
  if(LIBRAW_FATAL_ERROR(ret))
  goto end;
  }
  else // We have successfully unpacked the thumbnail, now let us write it to a file
  {
  snprintf(thumbfn,sizeof(thumbfn),"%s.%s",av[i],T.tformat == LIBRAW_THUMBNAIL_JPEG ? "thumb.jpg" : "thumb.ppm");
  if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_thumb_writer(thumbfn)))
  {
  fprintf(stderr,"Cannot write %s: %s\n",thumbfn,libraw_strerror(ret));
  // in the case of fatal error, we should terminate processing of the current file
  if(LIBRAW_FATAL_ERROR(ret))
  goto end;
  }
  }
  // Data unpacking
  ret = RawProcessor.dcraw_process();
  if(LIBRAW_SUCCESS != ret ) // error at the previous step
  {
  fprintf(stderr,"Cannot do postprocessing on %s: %s\n",av[i],libraw_strerror(ret));
  if(LIBRAW_FATAL_ERROR(ret))
  goto end;
  }
  else // Successful document processing
  {
  snprintf(outfn,sizeof(outfn),"%s.%s", av[i], "tiff");
  if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
  fprintf(stderr,"Cannot write %s: error %d\n",outfn,ret);
  }
  // we don't evoke recycle() or call the destructor; C++ will do everything for us
  return 0;
diff --git a/internal/libraw_cameraids.h b/internal/libraw_cameraids.h
index c88ed037..538d1057 100644
--- a/internal/libraw_cameraids.h
+++ b/internal/libraw_cameraids.h
@@ -7,300 +7,310 @@ LibRaw is free software; you can redistribute it and/or modify
 it under the terms of the one of two licenses as you choose:
 
 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
  */
 
 #ifndef LIBRAW_CONST_H
 #define LIBRAW_CONST_H
 
 #define CanonID_EOS_M50            0x00000412ULL
 #define CanonID_EOS_M6_Mark_II     0x00000811ULL
 #define CanonID_EOS_M200           0x00000812ULL
 #define CanonID_EOS_D30            0x01140000ULL
 #define CanonID_EOS_D60            0x01668000ULL
 #define CanonID_EOS_M3             0x03740000ULL
 #define CanonID_EOS_M10            0x03840000ULL
 #define CanonID_EOS_M5             0x03940000ULL
 #define CanonID_EOS_M100           0x03980000ULL
 #define CanonID_EOS_M6             0x04070000ULL
 #define CanonID_EOS_1D            (0x80000000ULL + 0x001ULL)
 #define CanonID_EOS_1Ds           (0x80000000ULL + 0x167ULL)
 #define CanonID_EOS_10D           (0x80000000ULL + 0x168ULL)
 #define CanonID_EOS_1D_Mark_III   (0x80000000ULL + 0x169ULL)
 #define CanonID_EOS_300D          (0x80000000ULL + 0x170ULL)
 #define CanonID_EOS_1D_Mark_II    (0x80000000ULL + 0x174ULL)
 #define CanonID_EOS_20D           (0x80000000ULL + 0x175ULL)
 #define CanonID_EOS_450D          (0x80000000ULL + 0x176ULL)
 #define CanonID_EOS_1Ds_Mark_II   (0x80000000ULL + 0x188ULL)
 #define CanonID_EOS_350D          (0x80000000ULL + 0x189ULL)
 #define CanonID_EOS_40D           (0x80000000ULL + 0x190ULL)
 #define CanonID_EOS_5D            (0x80000000ULL + 0x213ULL)
 #define CanonID_EOS_1Ds_Mark_III  (0x80000000ULL + 0x215ULL)
 #define CanonID_EOS_5D_Mark_II    (0x80000000ULL + 0x218ULL)
 #define CanonID_EOS_1D_Mark_II_N  (0x80000000ULL + 0x232ULL)
 #define CanonID_EOS_30D           (0x80000000ULL + 0x234ULL)
 #define CanonID_EOS_400D          (0x80000000ULL + 0x236ULL)
 #define CanonID_EOS_7D            (0x80000000ULL + 0x250ULL)
 #define CanonID_EOS_500D          (0x80000000ULL + 0x252ULL)
 #define CanonID_EOS_1000D         (0x80000000ULL + 0x254ULL)
 #define CanonID_EOS_50D           (0x80000000ULL + 0x261ULL)
 #define CanonID_EOS_1D_X          (0x80000000ULL + 0x269ULL)
 #define CanonID_EOS_550D          (0x80000000ULL + 0x270ULL)
 #define CanonID_EOS_1D_Mark_IV    (0x80000000ULL + 0x281ULL)
 #define CanonID_EOS_5D_Mark_III   (0x80000000ULL + 0x285ULL)
 #define CanonID_EOS_600D          (0x80000000ULL + 0x286ULL)
 #define CanonID_EOS_60D           (0x80000000ULL + 0x287ULL)
 #define CanonID_EOS_1100D         (0x80000000ULL + 0x288ULL)
 #define CanonID_EOS_7D_Mark_II    (0x80000000ULL + 0x289ULL)
 #define CanonID_EOS_650D          (0x80000000ULL + 0x301ULL)
 #define CanonID_EOS_6D            (0x80000000ULL + 0x302ULL)
 #define CanonID_EOS_1D_C          (0x80000000ULL + 0x324ULL)
 #define CanonID_EOS_70D           (0x80000000ULL + 0x325ULL)
 #define CanonID_EOS_700D          (0x80000000ULL + 0x326ULL)
 #define CanonID_EOS_1200D         (0x80000000ULL + 0x327ULL)
 #define CanonID_EOS_1D_X_Mark_II  (0x80000000ULL + 0x328ULL)
 #define CanonID_EOS_M             (0x80000000ULL + 0x331ULL)
 #define CanonID_EOS_100D          (0x80000000ULL + 0x346ULL)
 #define CanonID_EOS_760D          (0x80000000ULL + 0x347ULL)
 #define CanonID_EOS_5D_Mark_IV    (0x80000000ULL + 0x349ULL)
 #define CanonID_EOS_80D           (0x80000000ULL + 0x350ULL)
 #define CanonID_EOS_M2            (0x80000000ULL + 0x355ULL)
 #define CanonID_EOS_5DS           (0x80000000ULL + 0x382ULL)
 #define CanonID_EOS_750D          (0x80000000ULL + 0x393ULL)
 #define CanonID_EOS_5DS_R         (0x80000000ULL + 0x401ULL)
 #define CanonID_EOS_1300D         (0x80000000ULL + 0x404ULL)
 #define CanonID_EOS_800D          (0x80000000ULL + 0x405ULL)
 #define CanonID_EOS_6D_Mark_II    (0x80000000ULL + 0x406ULL)
 #define CanonID_EOS_77D           (0x80000000ULL + 0x408ULL)
 #define CanonID_EOS_200D          (0x80000000ULL + 0x417ULL)
 #define CanonID_EOS_R5            (0x80000000ULL + 0x421ULL)
 #define CanonID_EOS_3000D         (0x80000000ULL + 0x422ULL)
 #define CanonID_EOS_R             (0x80000000ULL + 0x424ULL)
 #define CanonID_EOS_1D_X_Mark_III (0x80000000ULL + 0x428ULL)
 #define CanonID_EOS_1500D         (0x80000000ULL + 0x432ULL)
 #define CanonID_EOS_RP            (0x80000000ULL + 0x433ULL)
 #define CanonID_EOS_850D          (0x80000000ULL + 0x435ULL)
 #define CanonID_EOS_250D          (0x80000000ULL + 0x436ULL)
 #define CanonID_EOS_90D           (0x80000000ULL + 0x437ULL)
+#define CanonID_EOS_R3            (0x80000000ULL + 0x450ULL)
 #define CanonID_EOS_R6            (0x80000000ULL + 0x453ULL)
+#define CanonID_EOS_M50_Mark_II   (0x80000000ULL + 0x468ULL)
 
 // CanonID_EOS_D2000C after Canon's TIFF2CR2 convertor:
 #define CanonID_EOS_D2000C        (0x80000000ULL + 0x520ULL)
 // CanonID_EOS_D6000C id after Canon's TIFF2CR2 convertor:
 #define CanonID_EOS_D6000C        (0x80000000ULL + 0x560ULL)
 
 #define OlyID_str2hex(str) ((unsigned long long)str[0]<<32 | str[1]<<24 | str[2]<<16 | str[3]<<8 | str[4])
 #define OlyID_E_20            OlyID_str2hex("D4029")
 #define OlyID_E_1             OlyID_str2hex("D4040")
 #define OlyID_E_300           OlyID_str2hex("D4041")
 #define OlyID_SP_550UZ        OlyID_str2hex("D4321")
 #define OlyID_SP_510UZ        OlyID_str2hex("D4322")
 #define OlyID_SP_560UZ        OlyID_str2hex("D4355")
 #define OlyID_SP_570UZ        OlyID_str2hex("D4364")
 #define OlyID_SP_565UZ        OlyID_str2hex("D4374")
 #define OlyID_XZ_1            OlyID_str2hex("D4401")
 #define OlyID_XZ_2            OlyID_str2hex("D4531")
 #define OlyID_XZ_10           OlyID_str2hex("D4546")
 #define OlyID_STYLUS_1        OlyID_str2hex("D4572")
 #define OlyID_SH_2            OlyID_str2hex("D4585")
 #define OlyID_TG_4            OlyID_str2hex("D4586")
 #define OlyID_TG_5            OlyID_str2hex("D4593")
 #define OlyID_TG_6            OlyID_str2hex("D4603")
 #define OlyID_E_10            OlyID_str2hex("D4842")
 #define OlyID_AIR_A01         OlyID_str2hex("K0055")
 #define OlyID_NORMA           OlyID_str2hex("NORMA")
 #define OlyID_E_330           OlyID_str2hex("S0003")
 #define OlyID_E_500           OlyID_str2hex("S0004")
 #define OlyID_E_400           OlyID_str2hex("S0009")
 #define OlyID_E_510           OlyID_str2hex("S0010")
 #define OlyID_E_3             OlyID_str2hex("S0011")
 #define OlyID_E_410           OlyID_str2hex("S0013")
 #define OlyID_E_420           OlyID_str2hex("S0016")
 #define OlyID_E_30            OlyID_str2hex("S0017")
 #define OlyID_E_520           OlyID_str2hex("S0018")
 #define OlyID_E_P1            OlyID_str2hex("S0019")
 #define OlyID_E_620           OlyID_str2hex("S0023")
 #define OlyID_E_P2            OlyID_str2hex("S0026")
 #define OlyID_E_PL1           OlyID_str2hex("S0027")
 #define OlyID_E_450           OlyID_str2hex("S0029")
 #define OlyID_E_600           OlyID_str2hex("S0030")
 #define OlyID_E_P3            OlyID_str2hex("S0032")
 #define OlyID_E_5             OlyID_str2hex("S0033")
 #define OlyID_E_PL2           OlyID_str2hex("S0034")
 #define OlyID_E_M5            OlyID_str2hex("S0036")
 #define OlyID_E_PL3           OlyID_str2hex("S0038")
 #define OlyID_E_PM1           OlyID_str2hex("S0039")
 #define OlyID_E_PL1s          OlyID_str2hex("S0040")
 #define OlyID_E_PL5           OlyID_str2hex("S0042")
 #define OlyID_E_PM2           OlyID_str2hex("S0043")
 #define OlyID_E_P5            OlyID_str2hex("S0044")
 #define OlyID_E_PL6           OlyID_str2hex("S0045")
 #define OlyID_E_PL7           OlyID_str2hex("S0046")
 #define OlyID_E_M1            OlyID_str2hex("S0047")
 #define OlyID_E_M10           OlyID_str2hex("S0051")
 #define OlyID_E_M5_Mark_II    OlyID_str2hex("S0052")
 #define OlyID_E_M10_Mark_II   OlyID_str2hex("S0059")
 #define OlyID_PEN_F           OlyID_str2hex("S0061")
 #define OlyID_E_PL8           OlyID_str2hex("S0065")
 #define OlyID_E_M1_Mark_II    OlyID_str2hex("S0067")
 #define OlyID_E_M10_Mark_III  OlyID_str2hex("S0068")
 #define OlyID_E_PL9           OlyID_str2hex("S0076")
 #define OlyID_E_M1X           OlyID_str2hex("S0080")
 #define OlyID_E_PL10          OlyID_str2hex("S0085")
 #define OlyID_E_M10_Mark_IV   OlyID_str2hex("S0088")
 #define OlyID_E_M5_Mark_III   OlyID_str2hex("S0089")
 #define OlyID_E_M1_Mark_III   OlyID_str2hex("S0092")
+#define OlyID_E_P7            OlyID_str2hex("S0093")
 #define OlyID_C_3030Z         OlyID_str2hex("SX351")
 #define OlyID_C_5050Z         OlyID_str2hex("SX558")
 #define OlyID_C_350Z          OlyID_str2hex("SX751")
 #define OlyID_C_740UZ         OlyID_str2hex("SX754")
 #define OlyID_C_5060WZ        OlyID_str2hex("SX756")
 #define OlyID_C_8080WZ        OlyID_str2hex("SX757")
 #define OlyID_C_770UZ         OlyID_str2hex("SX772")
 #define OlyID_C_7070WZ        OlyID_str2hex("SX851")
 #define OlyID_C_7000Z         OlyID_str2hex("SX852")
 #define OlyID_SP_500UZ        OlyID_str2hex("SX853")
 #define OlyID_SP_310          OlyID_str2hex("SX854")
 #define OlyID_SP_350          OlyID_str2hex("SX855")
 #define OlyID_SP_320          OlyID_str2hex("SX873")
 
 #define PentaxID_Optio_S      0x1296cULL
 #define PentaxID_Optio_S_V101 0x12971ULL
 #define PentaxID_staristD     0x12994ULL
 #define PentaxID_Optio_33WR   0x129c6ULL
 #define PentaxID_Optio_S4     0x129d5ULL
 #define PentaxID_Optio_750Z   0x12a66ULL
 #define PentaxID_staristDS    0x12aa2ULL
 #define PentaxID_staristDL    0x12b1aULL
 #define PentaxID_staristDS2   0x12b60ULL
 #define PentaxID_GX_1S        0x12b62ULL
 #define PentaxID_staristDL2   0x12b7eULL
 #define PentaxID_GX_1L        0x12b80ULL
 #define PentaxID_K100D        0x12b9cULL
 #define PentaxID_K110D        0x12b9dULL
 #define PentaxID_K100D_Super  0x12ba2ULL
 #define PentaxID_K10D         0x12c1eULL
 #define PentaxID_GX10         0x12c20ULL
 #define PentaxID_K20D         0x12cd2ULL
 #define PentaxID_GX20         0x12cd4ULL
 #define PentaxID_K200D        0x12cfaULL
 #define PentaxID_K2000        0x12d72ULL
 #define PentaxID_K_m          0x12d73ULL
 #define PentaxID_K_7          0x12db8ULL
 #define PentaxID_K_x          0x12dfeULL
 #define PentaxID_645D         0x12e08ULL
 #define PentaxID_K_r          0x12e6cULL
 #define PentaxID_K_5          0x12e76ULL
 #define PentaxID_Q            0x12ee4ULL
 #define PentaxID_K_01         0x12ef8ULL
 #define PentaxID_K_30         0x12f52ULL
 #define PentaxID_Q10          0x12f66ULL
 #define PentaxID_K_5_II       0x12f70ULL
 #define PentaxID_K_5_II_s     0x12f71ULL
 #define PentaxID_Q7           0x12f7aULL
 #define PentaxID_MX_1         0x12f84ULL
 #define PentaxID_K_50         0x12fb6ULL
 #define PentaxID_K_3          0x12fc0ULL
 #define PentaxID_K_500        0x12fcaULL
 #define PentaxID_645Z         0x13010ULL
 #define PentaxID_K_S1         0x1301aULL
 #define PentaxID_K_S2         0x13024ULL
 #define PentaxID_Q_S1         0x1302eULL
 #define PentaxID_K_1          0x13092ULL
 #define PentaxID_K_3_II       0x1309cULL
 #define PentaxID_GR_III       0x1320eULL
 #define PentaxID_K_70         0x13222ULL
 #define PentaxID_KP           0x1322cULL
 #define PentaxID_K_1_Mark_II  0x13240ULL
+#define PentaxID_K_3_III      0x13254ULL
+#define PentaxID_GR_IIIx      0x1329aULL
 
 #define SonyID_DSC_R1           0x002ULL
 #define SonyID_DSLR_A100        0x100ULL
 #define SonyID_DSLR_A900        0x101ULL
 #define SonyID_DSLR_A700        0x102ULL
 #define SonyID_DSLR_A200        0x103ULL
 #define SonyID_DSLR_A350        0x104ULL
 #define SonyID_DSLR_A300        0x105ULL
 #define SonyID_DSLR_A900_APSC   0x106ULL
 #define SonyID_DSLR_A380        0x107ULL
 #define SonyID_DSLR_A330        0x108ULL
 #define SonyID_DSLR_A230        0x109ULL
 #define SonyID_DSLR_A290        0x10aULL
 #define SonyID_DSLR_A850        0x10dULL
 #define SonyID_DSLR_A850_APSC   0x10eULL
 #define SonyID_DSLR_A550        0x111ULL
 #define SonyID_DSLR_A500        0x112ULL
 #define SonyID_DSLR_A450        0x113ULL
 #define SonyID_NEX_5            0x116ULL
 #define SonyID_NEX_3            0x117ULL
 #define SonyID_SLT_A33          0x118ULL
 #define SonyID_SLT_A55          0x119ULL
 #define SonyID_DSLR_A560        0x11aULL
 #define SonyID_DSLR_A580        0x11bULL
 #define SonyID_NEX_C3           0x11cULL
 #define SonyID_SLT_A35          0x11dULL
 #define SonyID_SLT_A65          0x11eULL
 #define SonyID_SLT_A77          0x11fULL
 #define SonyID_NEX_5N           0x120ULL
 #define SonyID_NEX_7            0x121ULL
 #define SonyID_NEX_VG20         0x122ULL
 #define SonyID_SLT_A37          0x123ULL
 #define SonyID_SLT_A57          0x124ULL
 #define SonyID_NEX_F3           0x125ULL
 #define SonyID_SLT_A99          0x126ULL
 #define SonyID_NEX_6            0x127ULL
 #define SonyID_NEX_5R           0x128ULL
 #define SonyID_DSC_RX100        0x129ULL
 #define SonyID_DSC_RX1          0x12aULL
 #define SonyID_NEX_VG900        0x12bULL
 #define SonyID_NEX_VG30         0x12cULL
 #define SonyID_ILCE_3000        0x12eULL
 #define SonyID_SLT_A58          0x12fULL
 #define SonyID_NEX_3N           0x131ULL
 #define SonyID_ILCE_7           0x132ULL
 #define SonyID_NEX_5T           0x133ULL
 #define SonyID_DSC_RX100M2      0x134ULL
 #define SonyID_DSC_RX10         0x135ULL
 #define SonyID_DSC_RX1R         0x136ULL
 #define SonyID_ILCE_7R          0x137ULL
 #define SonyID_ILCE_6000        0x138ULL
 #define SonyID_ILCE_5000        0x139ULL
 #define SonyID_DSC_RX100M3      0x13dULL
 #define SonyID_ILCE_7S          0x13eULL
 #define SonyID_ILCA_77M2        0x13fULL
 #define SonyID_ILCE_5100        0x153ULL
 #define SonyID_ILCE_7M2         0x154ULL
 #define SonyID_DSC_RX100M4      0x155ULL
 #define SonyID_DSC_RX10M2       0x156ULL
 #define SonyID_DSC_RX1RM2       0x158ULL
 #define SonyID_ILCE_QX1         0x15aULL
 #define SonyID_ILCE_7RM2        0x15bULL
 #define SonyID_ILCE_7SM2        0x15eULL
 #define SonyID_ILCA_68          0x161ULL
 #define SonyID_ILCA_99M2        0x162ULL
 #define SonyID_DSC_RX10M3       0x163ULL
 #define SonyID_DSC_RX100M5      0x164ULL
 #define SonyID_ILCE_6300        0x165ULL
 #define SonyID_ILCE_9           0x166ULL
 #define SonyID_ILCE_6500        0x168ULL
 #define SonyID_ILCE_7RM3        0x16aULL
 #define SonyID_ILCE_7M3         0x16bULL
 #define SonyID_DSC_RX0          0x16cULL
 #define SonyID_DSC_RX10M4       0x16dULL
 #define SonyID_DSC_RX100M6      0x16eULL
 #define SonyID_DSC_HX99         0x16fULL
 #define SonyID_DSC_RX100M5A     0x171ULL
 #define SonyID_ILCE_6400        0x173ULL
 #define SonyID_DSC_RX0M2        0x174ULL
 #define SonyID_DSC_RX100M7      0x176ULL
 #define SonyID_ILCE_7RM4        0x177ULL
 #define SonyID_ILCE_9M2         0x178ULL
 #define SonyID_ILCE_6600        0x17aULL
 #define SonyID_ILCE_6100        0x17bULL
 #define SonyID_ZV_1             0x17cULL
 #define SonyID_ILCE_7C          0x17dULL
+#define SonyID_ZV_E10           0x17eULL
 #define SonyID_ILCE_7SM3        0x17fULL
+#define SonyID_ILCE_1           0x180ULL
+#define SonyID_ILME_FX3         0x181ULL
+#define SonyID_ILCE_7RM3A       0x182ULL
+#define SonyID_ILCE_7RM4A       0x183ULL
 #endif
diff --git a/internal/libraw_internal_funcs.h b/internal/libraw_internal_funcs.h
index 4eee0a09..d86dccc1 100644
--- a/internal/libraw_internal_funcs.h
+++ b/internal/libraw_internal_funcs.h
@@ -7,393 +7,399 @@ LibRaw is free software; you can redistribute it and/or modify
 it under the terms of the one of two licenses as you choose:
 
 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
  */
 
 #ifndef _LIBRAW_INTERNAL_FUNCS_H
 #define _LIBRAW_INTERNAL_FUNCS_H
 
 #ifndef LIBRAW_LIBRARY_BUILD
 #error "This file should be used only for libraw library build"
 #else
 
 /* inline functions */
 	static int stread(char *buf, size_t len, LibRaw_abstract_datastream *fp);
 	static int getwords(char *line, char *words[], int maxwords, int maxlen);
 	static void remove_trailing_spaces(char *string, size_t len);
 	static void remove_caseSubstr(char *string, char *remove);
 	static void removeExcessiveSpaces(char *string);
 	static void trimSpaces(char *s);
 /* static tables/variables */
 	static libraw_static_table_t tagtype_dataunit_bytes;
 	static libraw_static_table_t Canon_wbi2std;
 	static libraw_static_table_t Canon_KeyIsZero_Len2048_linenums_2_StdWBi;
 	static libraw_static_table_t Canon_KeyIs0x0410_Len3072_linenums_2_StdWBi;
 	static libraw_static_table_t Canon_KeyIs0x0410_Len2048_linenums_2_StdWBi;
 	static libraw_static_table_t Canon_D30_linenums_2_StdWBi;
 	static libraw_static_table_t Canon_G9_linenums_2_StdWBi;
 
 	static libraw_static_table_t Fuji_wb_list1;
 	static libraw_static_table_t FujiCCT_K;
 	static libraw_static_table_t Fuji_wb_list2;
 
 	static libraw_static_table_t Pentax_wb_list1;
 	static libraw_static_table_t Pentax_wb_list2;
 
 	static libraw_static_table_t Oly_wb_list1;
 	static libraw_static_table_t Oly_wb_list2;
 
 	static libraw_static_table_t Sony_SRF_wb_list;
 	static libraw_static_table_t Sony_SR2_wb_list;
 	static libraw_static_table_t Sony_SR2_wb_list1;
 /*  */
-	int     find_ifd_by_offset(int );
+	int	find_ifd_by_offset(int );
 	ushort	sget2 (uchar *s);
 	ushort	sget2Rev(uchar *s);
-	int 	parseCR3(unsigned long long oAtomList, unsigned long long szAtomList, short &nesting, char *AtomNameStack, short& nTrack, short &TrackType);
+	libraw_area_t	get_CanonArea();
+	int	parseCR3(INT64 oAtomList, INT64 szAtomList, short &nesting, char *AtomNameStack, short& nTrack, short &TrackType);
 	void	selectCRXTrack(short maxTrack);
 	void	setCanonBodyFeatures (unsigned long long id);
 	void	processCanonCameraInfo (unsigned long long id, uchar *CameraInfo, unsigned maxlen, unsigned type, unsigned dng_writer);
 	static float _CanonConvertAperture(ushort in);
 	void	Canon_CameraSettings(unsigned len);
 	void	Canon_WBpresets (int skip1, int skip2);
 	void	Canon_WBCTpresets (short WBCTversion);
 	void	parseCanonMakernotes (unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	processNikonLensData (uchar *LensData, unsigned len);
 	void	Nikon_NRW_WBtag (int wb, int skip);
 	void	parseNikonMakernote (int base, int uptag, unsigned dng_writer);
 	void	parseEpsonMakernote (int base, int uptag, unsigned dng_writer);
 	void	parseSigmaMakernote (int base, int uptag, unsigned dng_writer);
 	void	setOlympusBodyFeatures (unsigned long long id);
 	void	getOlympus_CameraType2 ();
 	void	getOlympus_SensorTemperature (unsigned len);
 	void	parseOlympus_Equipment (unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	parseOlympus_CameraSettings (int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	parseOlympus_ImageProcessing (unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	parseOlympus_RawInfo (unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void parseOlympusMakernotes (int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	setPhaseOneFeatures (unsigned long long id);
 	void	setPentaxBodyFeatures (unsigned long long id);
 	void	PentaxISO (ushort c);
 	void	PentaxLensInfo (unsigned long long id, unsigned len);
 	void	parsePentaxMakernotes(int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	parseRicohMakernotes(int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	void	parseSamsungMakernotes(int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 	void	fixupArri();
 #endif
 	void	setSonyBodyFeatures (unsigned long long id);
 	void	parseSonyLensType2 (uchar a, uchar b);
 	void	parseSonyLensFeatures (uchar a, uchar b);
 	void	process_Sony_0x0116 (uchar * buf, ushort, unsigned long long id);
 	void	process_Sony_0x2010 (uchar * buf, ushort);
 	void	process_Sony_0x9050 (uchar * buf, ushort, unsigned long long id);
 	void	process_Sony_0x9400 (uchar * buf, ushort, unsigned long long id);
 	void	process_Sony_0x9402 (uchar * buf, ushort);
 	void	process_Sony_0x9403 (uchar * buf, ushort);
 	void	process_Sony_0x9406 (uchar * buf, ushort);
 	void	process_Sony_0x940c (uchar * buf, ushort);
 	void	process_Sony_0x940e (uchar * buf, ushort, unsigned long long id);
 	void	parseSonyMakernotes (int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer,
                                uchar *&table_buf_0x0116, ushort &table_buf_0x0116_len,
                                uchar *&table_buf_0x2010, ushort &table_buf_0x2010_len,
                                uchar *&table_buf_0x9050, ushort &table_buf_0x9050_len,
                                uchar *&table_buf_0x9400, ushort &table_buf_0x9400_len,
                                uchar *&table_buf_0x9402, ushort &table_buf_0x9402_len,
                                uchar *&table_buf_0x9403, ushort &table_buf_0x9403_len,
                                uchar *&table_buf_0x9406, ushort &table_buf_0x9406_len,
                                uchar *&table_buf_0x940c, ushort &table_buf_0x940c_len,
                                uchar *&table_buf_0x940e, ushort &table_buf_0x940e_len);
 	void	parseSonySR2 (uchar *cbuf_SR2, unsigned SR2SubIFDOffset, unsigned SR2SubIFDLength, unsigned dng_writer);
 	void	parseSonySRF (unsigned len);
 	void	parseFujiMakernotes (unsigned tag, unsigned type, unsigned len, unsigned dng_writer);
 	const char* HassyRawFormat_idx2HR(unsigned idx);
 	void	process_Hassy_Lens (int LensMount);
 	void parseHassyModel ();
 
 	void	setLeicaBodyFeatures(int LeicaMakernoteSignature);
 	void	parseLeicaLensID();
 	int 	parseLeicaLensName(unsigned len);
 	int 	parseLeicaInternalBodySerial(unsigned len);
 	void	parseLeicaMakernote(int base, int uptag, unsigned MakernoteTagType);
 	void	parseAdobePanoMakernote ();
 	void	parseAdobeRAFMakernote ();
 	void	GetNormalizedModel ();
 	void	SetStandardIlluminants (unsigned, const char* );
 
 	ushort      get2();
 	unsigned    sget4 (uchar *s);
-    unsigned    getint(int type);
+	unsigned    getint(int type);
 	float       int_to_float (int i);
 	double      getreal (int type);
 	double      sgetreal(int type, uchar *s);
 	void        read_shorts (ushort *pixel, unsigned count);
 
 /* Canon P&S cameras */
 	void        canon_600_fixed_wb (int temp);
 	int         canon_600_color (int ratio[2], int mar);
 	void        canon_600_auto_wb();
 	void        canon_600_coeff();
 	void        canon_600_load_raw();
 	void        canon_600_correct();
 	int         canon_s2is();
 	void        parse_ciff (int offset, int length, int);
 	void        ciff_block_1030();
 
 
 // LJPEG decoder
 	unsigned    getbithuff (int nbits, ushort *huff);
 	ushort*     make_decoder_ref (const uchar **source);
 	ushort*     make_decoder (const uchar *source);
 	int         ljpeg_start (struct jhead *jh, int info_only);
 	void        ljpeg_end(struct jhead *jh);
 	int         ljpeg_diff (ushort *huff);
 	ushort *    ljpeg_row (int jrow, struct jhead *jh);
 	ushort *    ljpeg_row_unrolled (int jrow, struct jhead *jh);
 	void	    ljpeg_idct (struct jhead *jh);
 	unsigned    ph1_bithuff (int nbits, ushort *huff);
 
 // Canon DSLRs
 	void        crw_init_tables (unsigned table, ushort *huff[2]);
 	int         canon_has_lowbits();
 	void        canon_load_raw();
 	void        lossless_jpeg_load_raw();
 	void        canon_sraw_load_raw();
 // Adobe DNG
 	void        adobe_copy_pixel (unsigned int row, unsigned int col, ushort **rp);
 	void        lossless_dng_load_raw();
 	void        deflate_dng_load_raw();
 	void        packed_dng_load_raw();
     void        uncompressed_fp_dng_load_raw();
 	void        lossy_dng_load_raw();
 //void        adobe_dng_load_raw_nc();
 
 // Pentax
 	void        pentax_load_raw();
 	void	pentax_4shot_load_raw();
 
 	void        pentax_tree();
 
 // Nikon (and Minolta Z2)
 	void        nikon_load_raw();
 	void        nikon_read_curve();
 	void        nikon_load_striped_packed_raw();
 	void        nikon_load_padded_packed_raw();
 	void        nikon_load_sraw();
 	void        nikon_yuv_load_raw();
 	void        nikon_coolscan_load_raw();
 	int         nikon_e995();
 	int         nikon_e2100();
 	void        nikon_3700();
 	int         minolta_z2();
 //	void        nikon_e2100_load_raw();
 
 // Fuji
 //	void        fuji_load_raw();
 	int         guess_RAFDataGeneration (uchar *RAFData_start);
 	void        parse_fuji (int offset);
+    void        parse_fuji_thumbnail(int offset);
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 // RedCine
 	void        parse_redcine();
 	void        redcine_load_raw();
 #endif
 
 // Rollei
 	void        rollei_load_raw();
 	void        parse_rollei();
 
 // Contax
 	void        parse_kyocera ();
 
 // MF backs
 //int         bayer (unsigned row, unsigned col);
 	int         p1raw(unsigned,unsigned);
 	void        phase_one_flat_field (int is_float, int nc);
+	int 	    p1rawc(unsigned row, unsigned col, unsigned& count);
+	void 	    phase_one_fix_col_pixel_avg(unsigned row, unsigned col);
+	void 	    phase_one_fix_pixel_grad(unsigned row, unsigned col);
 	void        phase_one_load_raw();
 	unsigned    ph1_bits (int nbits);
 	void        phase_one_load_raw_c();
 	void        hasselblad_load_raw();
 	void        leaf_hdr_load_raw();
 	void        sinar_4shot_load_raw();
 	void        imacon_full_load_raw();
 	void        hasselblad_full_load_raw();
 	void        packed_load_raw();
 	float       find_green(int,int,int,int);
 	void        unpacked_load_raw();
 	void        unpacked_load_raw_FujiDBP();
 	void        unpacked_load_raw_reversed();
 	void        unpacked_load_raw_fuji_f700s20();
 	void        parse_sinar_ia();
 	void        parse_phase_one (int base);
 
 // Misc P&S cameras
 	void        parse_broadcom();
 	void        broadcom_load_raw();
 	void        nokia_load_raw();
 	void        android_loose_load_raw();
 	void        android_tight_load_raw();
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
     void        canon_rmf_load_raw();
 #endif
 	unsigned    pana_data (int nb, unsigned *bytes);
 	void        panasonic_load_raw();
 //	void        panasonic_16x10_load_raw();
 	void        olympus_load_raw();
 //	void        olympus_cseries_load_raw();
 	void        minolta_rd175_load_raw();
 	void        quicktake_100_load_raw();
 	const int*  make_decoder_int (const int *source, int level);
 	int         radc_token (int tree);
 	void        kodak_radc_load_raw();
 	void        kodak_jpeg_load_raw();
 	void        kodak_dc120_load_raw();
 	void        eight_bit_load_raw();
 	void        smal_decode_segment (unsigned seg[2][2], int holes);
 	void        smal_v6_load_raw();
 	int         median4 (int *p);
 	void        fill_holes (int holes);
 	void        smal_v9_load_raw();
 	void        parse_riff();
 	void        parse_cine();
 	void        parse_smal (int offset, int fsize);
 	int         parse_jpeg (int offset);
 
 // Kodak
 	void        kodak_262_load_raw();
 	int         kodak_65000_decode (short *out, int bsize);
 	void        kodak_65000_load_raw();
 	void        kodak_rgb_load_raw();
 	void        kodak_ycbcr_load_raw();
 //	void        kodak_yrgb_load_raw();
 	void        kodak_c330_load_raw();
 	void        kodak_c603_load_raw();
 	void        kodak_rgb_load_thumb();
 	void        kodak_ycbcr_load_thumb();
 	void        vc5_dng_load_raw_placeholder();
 // It's a Sony (and K&M)
 	void        sony_decrypt (unsigned *data, int len, int start, int key);
 	void        sony_load_raw();
 	void        sony_arw_load_raw();
 	void        sony_arw2_load_raw();
 	void        sony_arq_load_raw();
+	void        sony_ljpeg_load_raw();
 	void        samsung_load_raw();
 	void        samsung2_load_raw();
 	void        samsung3_load_raw();
 	void        parse_minolta (int base);
 
 #ifdef USE_X3FTOOLS
 // Foveon/Sigma
 // We always have x3f code compiled in!
 	void        parse_x3f();
 	void        x3f_load_raw();
 	void        x3f_dpq_interpolate_rg();
 	void        x3f_dpq_interpolate_af(int xstep, int ystep, int scale); // 1x1 af pixels
 	void        x3f_dpq_interpolate_af_sd(int xstart,int ystart, int xend, int yend, int xstep, int ystep, int scale); // sd Quattro interpolation
 #else
 	void        parse_x3f() {}
 	void        x3f_load_raw(){}
 #endif
 #ifdef USE_6BY9RPI
 	void		rpi_load_raw8();
 	void		rpi_load_raw12();
 	void		rpi_load_raw14();
 	void		rpi_load_raw16();
 	void		parse_raspberrypi();
 #endif
 
 // CAM/RGB
 	void        pseudoinverse (double (*in)[3], double (*out)[3], int size);
 	void        simple_coeff (int index);
 
 // Openp
 	char** malloc_omp_buffers(int buffer_count, size_t buffer_size, const char* where);
 	void free_omp_buffers(char** buffers, int buffer_count);
 
 
 // Tiff/Exif parsers
 	void        tiff_get (unsigned base,unsigned *tag, unsigned *type, unsigned *len, unsigned *save);
 	short       tiff_sget(unsigned save, uchar *buf, unsigned buf_len, INT64 *tag_offset,
                           unsigned *tag_id, unsigned *tag_type, INT64 *tag_dataoffset,
                           unsigned *tag_datalen, int *tag_dataunit_len);
 	void        parse_thumb_note (int base, unsigned toff, unsigned tlen);
 	void        parse_makernote (int base, int uptag);
 	void        parse_makernote_0xc634(int base, int uptag, unsigned dng_writer);
 	void        parse_exif (int base);
 	void        parse_exif_interop(int base);
 	void        linear_table(unsigned len);
 	void        Kodak_DCR_WBtags(int wb, unsigned type, int wbi);
 	void        Kodak_KDC_WBtags(int wb, int wbi);
 	short       KodakIllumMatrix (unsigned type, float *romm_camIllum);
 	void        parse_kodak_ifd (int base);
 	int         parse_tiff_ifd (int base);
 	int         parse_tiff (int base);
 	void        apply_tiff(void);
 	void        parse_gps (int base);
 	void        parse_gps_libraw(int base);
 	void        aRGB_coeff(double aRGB_cam[3][3]);
 	void        romm_coeff(float romm_cam[3][3]);
-	void        parse_mos (int offset);
+	void        parse_mos (INT64 offset);
 	void        parse_qt (int end);
 	void        get_timestamp (int reversed);
 
 // The identify
     short       guess_byte_order (int words);
 	void		identify_process_dng_fields();
 	void		identify_finetune_pentax();
 	void		identify_finetune_by_filesize(int);
 	void		identify_finetune_dcr(char head[64],int,int);
 // Tiff writer
 	void        tiff_set(struct tiff_hdr *th, ushort *ntag,ushort tag, ushort type, int count, int val);
 	void        tiff_head (struct tiff_hdr *th, int full);
 
 // split AHD code
 	void ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3]);
 	void ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[LIBRAW_AHD_TILE][3], short (*out_lab)[LIBRAW_AHD_TILE][3]);
 	void ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], short (*out_lab)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3]);
 	void ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], char (*out_homogeneity_map)[LIBRAW_AHD_TILE][2]);
 	void ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], char (*homogeneity_map)[LIBRAW_AHD_TILE][2]);
 
 	void init_fuji_compr(struct fuji_compressed_params* info);
 	void init_fuji_block(struct fuji_compressed_block* info, const struct fuji_compressed_params *params, INT64 raw_offset, unsigned dsize);
 	void copy_line_to_xtrans(struct fuji_compressed_block* info, int cur_line, int cur_block, int cur_block_width);
 	void copy_line_to_bayer(struct fuji_compressed_block* info, int cur_line, int cur_block, int cur_block_width);
 	void xtrans_decode_block(struct fuji_compressed_block* info, const struct fuji_compressed_params *params, int cur_line);
 	void fuji_bayer_decode_block(struct fuji_compressed_block* info, const struct fuji_compressed_params *params, int cur_line);
 	void fuji_compressed_load_raw();
 	void fuji_14bit_load_raw();
 	void parse_fuji_compressed_header();
 	void crxLoadRaw();
 	int  crxParseImageHeader(uchar *cmp1TagData, int nTrack);
 	void panasonicC6_load_raw();
 	void panasonicC7_load_raw();
 
 	void nikon_14bit_load_raw();
 
 // DCB
 	void  	dcb_pp();
 	void  	dcb_copy_to_buffer(float (*image2)[3]);
 	void  	dcb_restore_from_buffer(float (*image2)[3]);
 	void  	dcb_color();
 	void  	dcb_color_full();
 	void  	dcb_map();
 	void  	dcb_correction();
 	void  	dcb_correction2();
 	void  	dcb_refinement();
 	void  	rgb_to_lch(double (*image3)[3]);
 	void  	lch_to_rgb(double (*image3)[3]);
 	void  	fbdd_correction();
 	void  	fbdd_correction2(double (*image3)[3]);
 	void  	fbdd_green();
 	void  	dcb_ver(float (*image3)[3]);
 	void 	dcb_hor(float (*image2)[3]);
 	void 	dcb_color2(float (*image2)[3]);
 	void 	dcb_color3(float (*image3)[3]);
 	void 	dcb_decide(float (*image2)[3], float (*image3)[3]);
 	void 	dcb_nyquist();
 #endif
 
 #endif
diff --git a/internal/var_defines.h b/internal/var_defines.h
index 234257ea..36c6adb9 100644
--- a/internal/var_defines.h
+++ b/internal/var_defines.h
@@ -9,207 +9,207 @@ LibRaw is free software; you can redistribute it and/or modify
 it under the terms of the one of two licenses as you choose:
 
 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
  */
 
 #ifndef VAR_DEFINES_H
 #define VAR_DEFINES_H
 
 
 // imgdata.idata
 #define make              (imgdata.idata.make)
 #define model             (imgdata.idata.model)
 #define software          (imgdata.idata.software)
 #define is_raw            (imgdata.idata.raw_count)
 #define dng_version       (imgdata.idata.dng_version)
 #define is_foveon         (imgdata.idata.is_foveon)
 #define colors            (imgdata.idata.colors)
 #define cdesc             (imgdata.idata.cdesc)
 #define filters           (imgdata.idata.filters)
 #define xtrans            (imgdata.idata.xtrans)
 #define xtrans_abs        (imgdata.idata.xtrans_abs)
 #define xmpdata           (imgdata.idata.xmpdata)
 #define xmplen            (imgdata.idata.xmplen)
 //imgdata image
 #define image             (imgdata.image)
 #define raw_image         (imgdata.rawdata.raw_image)
 #define color_image       (imgdata.rawdata.color_image)
 #define normalized_make   (imgdata.idata.normalized_make)
 #define normalized_model  (imgdata.idata.normalized_model)
 #define maker_index       (imgdata.idata.maker_index)
 
 // imgdata.sizes
 #define raw_height        (imgdata.sizes.raw_height)
 #define raw_width         (imgdata.sizes.raw_width)
 #define raw_pitch         (imgdata.sizes.raw_pitch)
 #define height            (imgdata.sizes.height)
 #define width             (imgdata.sizes.width)
 #define top_margin        (imgdata.sizes.top_margin)
 #define left_margin       (imgdata.sizes.left_margin)
 #define bottom_margin     (imgdata.sizes.bottom_margin)
 #define right_margin      (imgdata.sizes.right_margin)
 #define iheight           (imgdata.sizes.iheight)
 #define iwidth            (imgdata.sizes.iwidth)
 #define pixel_aspect      (imgdata.sizes.pixel_aspect)
 #define flip              (imgdata.sizes.flip)
 #define mask              (imgdata.sizes.mask)
 #define raw_stride        (libraw_internal_data.unpacker_data.raw_stride)
 
 //imgdata.color
 #define white             (imgdata.color.white)
 #define cam_mul           (imgdata.color.cam_mul)
 #define pre_mul           (imgdata.color.pre_mul)
 #define cmatrix           (imgdata.color.cmatrix)
 #define rgb_cam           (imgdata.color.rgb_cam)
 #ifndef SRC_USES_CURVE
 #define curve             (imgdata.color.curve)
 #endif
 #ifndef SRC_USES_BLACK
 #define black             (imgdata.color.black)
 #define cblack            (imgdata.color.cblack)
 #endif
 #define maximum           (imgdata.color.maximum)
 #define channel_maximum   (imgdata.color.channel_maximum)
 #define profile_length    (imgdata.color.profile_length)
 #define color_flags       (imgdata.color.color_flags)
 #define ph1               (imgdata.color.phase_one_data)
 #define flash_used        (imgdata.color.flash_used)
 #define canon_ev          (imgdata.color.canon_ev)
 #define model2            (imgdata.color.model2)
 
 //imgdata.thumbnail
 #define thumb_width       (imgdata.thumbnail.twidth)
 #define thumb_height      (imgdata.thumbnail.theight)
 #define thumb_length      (imgdata.thumbnail.tlength)
 
 
 //imgdata.others
 #define iso_speed         (imgdata.other.iso_speed)
 #define shutter           (imgdata.other.shutter)
 #define aperture          (imgdata.other.aperture)
 #define focal_len         (imgdata.other.focal_len)
 #define timestamp         (imgdata.other.timestamp)
 #define shot_order        (imgdata.other.shot_order)
 #define gpsdata           (imgdata.other.gpsdata)
 #define desc              (imgdata.other.desc)
 #define artist            (imgdata.other.artist)
 
 #define FujiCropMode      (imgdata.makernotes.fuji.CropMode)
 
 //imgdata.output
 #define greybox           (imgdata.params.greybox)
 #define cropbox           (imgdata.params.cropbox)
 #define aber              (imgdata.params.aber)
 #define gamm              (imgdata.params.gamm)
 #define user_mul          (imgdata.params.user_mul)
-#define shot_select       (imgdata.params.shot_select)
+#define shot_select       (imgdata.rawparams.shot_select)
 #define bright            (imgdata.params.bright)
 #define threshold         (imgdata.params.threshold)
 #define half_size         (imgdata.params.half_size)
 #define four_color_rgb    (imgdata.params.four_color_rgb)
 #define highlight         (imgdata.params.highlight)
 #define use_auto_wb       (imgdata.params.use_auto_wb)
 #define use_camera_wb     (imgdata.params.use_camera_wb)
 #define use_camera_matrix (imgdata.params.use_camera_matrix)
 #define output_color      (imgdata.params.output_color)
 #define output_bps        (imgdata.params.output_bps)
 #define gamma_16bit       (imgdata.params.gamma_16bit)
 #define output_tiff       (imgdata.params.output_tiff)
 #define med_passes        (imgdata.params.med_passes)
 #define no_auto_bright    (imgdata.params.no_auto_bright)
 #define auto_bright_thr   (imgdata.params.auto_bright_thr)
 #define use_fuji_rotate   (imgdata.params.use_fuji_rotate)
 #define filtering_mode    (imgdata.params.filtering_mode)
 
 // DCB
 #define dcb_iterations    (imgdata.params.iterations)
 #define dcb_enhance_fl    (imgdata.params.dcb_enhance)
 #define fbdd_noiserd      (imgdata.params.fbdd_noiserd)
 
 //libraw_internal_data.internal_data
 #define meta_data         (libraw_internal_data.internal_data.meta_data)
 #define ifp               libraw_internal_data.internal_data.input
 #define ifname            ((char*)libraw_internal_data.internal_data.input->fname())
 #define ofp               libraw_internal_data.internal_data.output
 #define profile_offset    (libraw_internal_data.internal_data.profile_offset)
 #define thumb_offset      (libraw_internal_data.internal_data.toffset)
 #define pana_black        (libraw_internal_data.internal_data.pana_black)
 
 //libraw_internal_data.internal_output_params
 #define mix_green         (libraw_internal_data.internal_output_params.mix_green)
 #define raw_color         (libraw_internal_data.internal_output_params.raw_color)
 #define use_gamma         (libraw_internal_data.internal_output_params.use_gamma)
 #define zero_is_bad       (libraw_internal_data.internal_output_params.zero_is_bad)
 #ifndef SRC_USES_SHRINK
 #define shrink            (libraw_internal_data.internal_output_params.shrink)
 #endif
 #define fuji_width        (libraw_internal_data.internal_output_params.fuji_width)
 
 
 //libraw_internal_data.output_data
 #define histogram         (libraw_internal_data.output_data.histogram)
 #define oprof             (libraw_internal_data.output_data.oprof)
 
 //libraw_internal_data.identify_data
 #define exif_cfa          (libraw_internal_data.identify_data.olympus_exif_cfa)
 #define unique_id         (libraw_internal_data.identify_data.unique_id)
 #define OlyID             (libraw_internal_data.identify_data.OlyID)
 #define tiff_nifds        (libraw_internal_data.identify_data.tiff_nifds)
 #define tiff_flip         (libraw_internal_data.identify_data.tiff_flip)
 #define metadata_blocks   (libraw_internal_data.identify_data.metadata_blocks)
 
 //libraw_internal_data.unpacker_data
 #define order             (libraw_internal_data.unpacker_data.order)
 #define data_error        (libraw_internal_data.unpacker_data.data_error)
 #define cr2_slice         (libraw_internal_data.unpacker_data.cr2_slice)
 #define sraw_mul          (libraw_internal_data.unpacker_data.sraw_mul)
 #define kodak_cbpp        (libraw_internal_data.unpacker_data.kodak_cbpp)
 #define strip_offset      (libraw_internal_data.unpacker_data.strip_offset)
 #define data_offset       (libraw_internal_data.unpacker_data.data_offset)
 #define data_size         (libraw_internal_data.unpacker_data.data_size)
 #define meta_offset       (libraw_internal_data.unpacker_data.meta_offset)
 #define meta_length       (libraw_internal_data.unpacker_data.meta_length)
 #define thumb_misc        (libraw_internal_data.unpacker_data.thumb_misc)
 #define fuji_layout       (libraw_internal_data.unpacker_data.fuji_layout)
 #define tiff_samples      (libraw_internal_data.unpacker_data.tiff_samples)
 #define tiff_bps          (libraw_internal_data.unpacker_data.tiff_bps)
 #define tiff_compress     (libraw_internal_data.unpacker_data.tiff_compress)
 #define tiff_sampleformat (libraw_internal_data.unpacker_data.tiff_sampleformat)
 #define zero_after_ff     (libraw_internal_data.unpacker_data.zero_after_ff)
 #define tile_width        (libraw_internal_data.unpacker_data.tile_width)
 #define tile_length       (libraw_internal_data.unpacker_data.tile_length)
 #define load_flags        (libraw_internal_data.unpacker_data.load_flags)
 #define pana_encoding     (libraw_internal_data.unpacker_data.pana_encoding)
 #define pana_bpp          (libraw_internal_data.unpacker_data.pana_bpp)
 #define CM_found          (libraw_internal_data.unpacker_data.CM_found)
 
 #define is_NikonTransfer  (libraw_internal_data.unpacker_data.is_NikonTransfer)
 #define is_Olympus        (libraw_internal_data.unpacker_data.is_Olympus)
 #define OlympusDNG_SubDirOffsetValid (libraw_internal_data.unpacker_data.OlympusDNG_SubDirOffsetValid)
 #define is_Sony           (libraw_internal_data.unpacker_data.is_Sony)
 #define is_PentaxRicohMakernotes    (libraw_internal_data.unpacker_data.is_PentaxRicohMakernotes)
 #define is_pana_raw       (libraw_internal_data.unpacker_data.is_pana_raw)
 
 
 #ifdef LIBRAW_IO_REDEFINED
 #define fread(ptr,size,n,stream)   stream->read(ptr,size,n)
 #define fseek(stream,o,w)          stream->seek(o,w)
 #define fseeko(stream,o,w)         stream->seek(o,w)
 #define ftell(stream)              stream->tell()
 #define ftello(stream)             stream->tell()
 #define feof(stream)               stream->eof()
 #ifdef getc
 #undef getc
 #endif
 #define getc(stream)               stream->get_char()
 #define fgetc(stream)              stream->get_char()
 #define fgetcb(stream)             stream->get_char_buf()
 #define fgets(str,n,stream)        stream->gets(str,n)
 #define fscanf(stream,fmt,ptr)     stream->scanf_one(fmt,ptr)
 #endif
 
 #endif
diff --git a/libraw/libraw.h b/libraw/libraw.h
index 2a8a07c4..585bda0c 100644
--- a/libraw/libraw.h
+++ b/libraw/libraw.h
@@ -186,156 +186,157 @@ class DllDef LibRaw
 {
 public:
   libraw_data_t imgdata;
 
   LibRaw(unsigned int flags = LIBRAW_OPTIONS_NONE);
   libraw_output_params_t *output_params_ptr() { return &imgdata.params; }
 #ifndef LIBRAW_NO_IOSTREAMS_DATASTREAM
   int open_file(const char *fname,
                 INT64 max_buffered_sz = LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);
 #if defined(_WIN32) || defined(WIN32)
   int open_file(const wchar_t *fname,
                 INT64 max_buffered_sz = LIBRAW_USE_STREAMS_DATASTREAM_MAXSIZE);
 #endif
 #else
   int open_file(const char *fname);
 #if defined(_WIN32) || defined(WIN32)
   int open_file(const wchar_t *fname);
 #endif
 
 #endif
   int open_buffer(const void *buffer, size_t size);
   virtual int open_datastream(LibRaw_abstract_datastream *);
   virtual int open_bayer(const unsigned char *data, unsigned datalen,
                          ushort _raw_width, ushort _raw_height,
                          ushort _left_margin, ushort _top_margin,
                          ushort _right_margin, ushort _bottom_margin,
                          unsigned char procflags, unsigned char bayer_pattern,
                          unsigned unused_bits, unsigned otherflags,
                          unsigned black_level);
   int error_count() { return libraw_internal_data.unpacker_data.data_error; }
   void recycle_datastream();
   int unpack(void);
   int unpack_thumb(void);
   int thumbOK(INT64 maxsz = -1);
   int adjust_sizes_info_only(void);
   int subtract_black();
   int subtract_black_internal();
   int raw2image();
   int raw2image_ex(int do_subtract_black);
   void raw2image_start();
   void free_image();
   int adjust_maximum();
+  int adjust_to_raw_inset_crop(unsigned mask, float maxcrop = 0.55f); 
   void set_exifparser_handler(exif_parser_callback cb, void *data)
   {
     callbacks.exifparser_data = data;
     callbacks.exif_cb = cb;
   }
   void set_memerror_handler(memory_callback cb, void *data)
   {
     callbacks.memcb_data = data;
     callbacks.mem_cb = cb;
   }
   void set_dataerror_handler(data_callback func, void *data)
   {
     callbacks.datacb_data = data;
     callbacks.data_cb = func;
   }
   void set_progress_handler(progress_callback pcb, void *data)
   {
     callbacks.progresscb_data = data;
     callbacks.progress_cb = pcb;
   }
 
   static const char* cameramakeridx2maker(unsigned maker);
   int setMakeFromIndex(unsigned index);
 
   void convertFloatToInt(float dmin = 4096.f, float dmax = 32767.f,
                          float dtarget = 16383.f);
   /* helpers */
   static unsigned capabilities();
   static const char *version();
   static int versionNumber();
   static const char **cameraList();
   static int cameraCount();
   static const char *strprogress(enum LibRaw_progress);
   static const char *strerror(int p);
   /* dcraw emulation */
   int dcraw_ppm_tiff_writer(const char *filename);
   int dcraw_thumb_writer(const char *fname);
   int dcraw_process(void);
   /* information calls */
   int is_fuji_rotated()
   {
     return libraw_internal_data.internal_output_params.fuji_width;
   }
   int is_sraw();
   int sraw_midpoint();
   int is_nikon_sraw();
   int is_coolscan_nef();
   int is_jpeg_thumb();
   int is_floating_point();
   int have_fpdata();
   /* memory writers */
   virtual libraw_processed_image_t *dcraw_make_mem_image(int *errcode = NULL);
   virtual libraw_processed_image_t *dcraw_make_mem_thumb(int *errcode = NULL);
   static void dcraw_clear_mem(libraw_processed_image_t *);
 
   /* Additional calls for make_mem_image */
   void get_mem_image_format(int *width, int *height, int *colors,
                             int *bps) const;
   int copy_mem_image(void *scan0, int stride, int bgr);
 
   /* free all internal data structures */
   void recycle();
   virtual ~LibRaw(void);
 
   int COLOR(int row, int col)
   {
     if (!imgdata.idata.filters)
       return 6; /* Special value 0+1+2+3 */
     if (imgdata.idata.filters < 1000)
       return fcol(row, col);
     return libraw_internal_data.internal_output_params.fuji_width
                ? FCF(row, col)
                : FC(row, col);
   }
 
   int FC(int row, int col)
   {
     return (imgdata.idata.filters >> (((row << 1 & 14) | (col & 1)) << 1) & 3);
   }
   int fcol(int row, int col);
 
   const char *unpack_function_name();
   virtual int get_decoder_info(libraw_decoder_info_t *d_info);
   libraw_internal_data_t *get_internal_data_pointer()
   {
     return &libraw_internal_data;
   }
 
   static float powf_lim(float a, float b, float limup)
   {
     return (b > limup || b < -limup) ? 0.f : powf(a, b);
   }
   static float libraw_powf64l(float a, float b) { return powf_lim(a, b, 64.f); }
 
   static unsigned sgetn(int n, uchar *s)
   {
     unsigned result = 0;
     while (n-- > 0)
       result = (result << 8) | (*s++);
     return result;
   }
 
   /* Phase one correction/subtractBL calls */
   /* Returns libraw error code */
 
   int phase_one_subtract_black(ushort *src, ushort *dest);
   int phase_one_correct();
 
   int set_rawspeed_camerafile(char *filename);
   virtual void setCancelFlag();
   virtual void clearCancelFlag();
   virtual int adobe_coeff(unsigned, const char *, int internal_only = 0);
 
   void set_dng_host(void *);
diff --git a/libraw/libraw_const.h b/libraw/libraw_const.h
index 5fe08170..fd6ba741 100644
--- a/libraw/libraw_const.h
+++ b/libraw/libraw_const.h
@@ -7,36 +7,49 @@ LibRaw is free software; you can redistribute it and/or modify
 it under the terms of the one of two licenses as you choose:
 
 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
    (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
    (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
  */
 
 #ifndef _LIBRAW_ERRORS_H
 #define _LIBRAW_ERRORS_H
 
 #define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75
 #define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01
 /* limit allocation size, default is 2Gb */
 #ifndef LIBRAW_MAX_ALLOC_MB_DEFAULT
 #define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L
 #endif
 
+#ifndef LIBRAW_MAX_NONDNG_RAW_FILE_SIZE
+#define LIBRAW_MAX_NONDNG_RAW_FILE_SIZE 2147483647ULL
+#endif
+
+#ifndef LIBRAW_MAX_DNG_RAW_FILE_SIZE
+#ifdef USE_DNGSDK
+#define LIBRAW_MAX_DNG_RAW_FILE_SIZE 4294967295ULL
+#else
+#define LIBRAW_MAX_DNG_RAW_FILE_SIZE 2147483647ULL
+#endif
+#endif
+
+
 /* limit thumbnail size, default is 512Mb*/
 #ifndef LIBRAW_MAX_THUMBNAIL_MB
 #define LIBRAW_MAX_THUMBNAIL_MB 512L
 #endif
 
 /* Check if enough file space exists before tag read */
 #ifndef LIBRAW_NO_IOSPACE_CHECK
 #define LIBRAW_IOSPACE_CHECK
 #endif
 #ifndef LIBRAW_NO_CR3_MEMPOOL
 #define LIBRAW_CR3_MEMPOOL
 #endif
 
 
 
 /* LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)
@@ -76,20 +89,21 @@ enum LibRaw_openbayer_patterns
 enum LibRaw_dngfields_marks
 {
   LIBRAW_DNGFM_FORWARDMATRIX = 1,
   LIBRAW_DNGFM_ILLUMINANT = 1 << 1,
   LIBRAW_DNGFM_COLORMATRIX = 1 << 2,
   LIBRAW_DNGFM_CALIBRATION = 1 << 3,
   LIBRAW_DNGFM_ANALOGBALANCE = 1 << 4,
   LIBRAW_DNGFM_BLACK = 1 << 5,
   LIBRAW_DNGFM_WHITE = 1 << 6,
   LIBRAW_DNGFM_OPCODE2 = 1 << 7,
   LIBRAW_DNGFM_LINTABLE = 1 << 8,
   LIBRAW_DNGFM_CROPORIGIN = 1 << 9,
   LIBRAW_DNGFM_CROPSIZE = 1 << 10,
   LIBRAW_DNGFM_PREVIEWCS = 1 << 11,
   LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,
   LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,
-  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14
+  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14,
+  LIBRAW_DNGFM_USERCROP = 1 << 15,
 };
 
 enum LibRaw_As_Shot_WB_Applied_codes
@@ -271,82 +285,83 @@ enum LibRaw_colorspace {
 enum LibRaw_cameramaker_index
 {
   LIBRAW_CAMERAMAKER_Unknown = 0,
   LIBRAW_CAMERAMAKER_Agfa,
   LIBRAW_CAMERAMAKER_Alcatel,
   LIBRAW_CAMERAMAKER_Apple,
   LIBRAW_CAMERAMAKER_Aptina,
   LIBRAW_CAMERAMAKER_AVT,
   LIBRAW_CAMERAMAKER_Baumer,
   LIBRAW_CAMERAMAKER_Broadcom,
   LIBRAW_CAMERAMAKER_Canon,
   LIBRAW_CAMERAMAKER_Casio,
   LIBRAW_CAMERAMAKER_CINE,
   LIBRAW_CAMERAMAKER_Clauss,
   LIBRAW_CAMERAMAKER_Contax,
   LIBRAW_CAMERAMAKER_Creative,
   LIBRAW_CAMERAMAKER_DJI,
   LIBRAW_CAMERAMAKER_DXO,
   LIBRAW_CAMERAMAKER_Epson,
   LIBRAW_CAMERAMAKER_Foculus,
   LIBRAW_CAMERAMAKER_Fujifilm,
   LIBRAW_CAMERAMAKER_Generic,
   LIBRAW_CAMERAMAKER_Gione,
   LIBRAW_CAMERAMAKER_GITUP,
   LIBRAW_CAMERAMAKER_Google,
   LIBRAW_CAMERAMAKER_GoPro,
   LIBRAW_CAMERAMAKER_Hasselblad,
   LIBRAW_CAMERAMAKER_HTC,
   LIBRAW_CAMERAMAKER_I_Mobile,
   LIBRAW_CAMERAMAKER_Imacon,
   LIBRAW_CAMERAMAKER_JK_Imaging,
   LIBRAW_CAMERAMAKER_Kodak,
   LIBRAW_CAMERAMAKER_Konica,
   LIBRAW_CAMERAMAKER_Leaf,
   LIBRAW_CAMERAMAKER_Leica,
   LIBRAW_CAMERAMAKER_Lenovo,
   LIBRAW_CAMERAMAKER_LG,
   LIBRAW_CAMERAMAKER_Logitech,
   LIBRAW_CAMERAMAKER_Mamiya,
   LIBRAW_CAMERAMAKER_Matrix,
   LIBRAW_CAMERAMAKER_Meizu,
   LIBRAW_CAMERAMAKER_Micron,
   LIBRAW_CAMERAMAKER_Minolta,
   LIBRAW_CAMERAMAKER_Motorola,
   LIBRAW_CAMERAMAKER_NGM,
   LIBRAW_CAMERAMAKER_Nikon,
   LIBRAW_CAMERAMAKER_Nokia,
   LIBRAW_CAMERAMAKER_Olympus,
   LIBRAW_CAMERAMAKER_OmniVison,
   LIBRAW_CAMERAMAKER_Panasonic,
   LIBRAW_CAMERAMAKER_Parrot,
   LIBRAW_CAMERAMAKER_Pentax,
   LIBRAW_CAMERAMAKER_PhaseOne,
   LIBRAW_CAMERAMAKER_PhotoControl,
   LIBRAW_CAMERAMAKER_Photron,
   LIBRAW_CAMERAMAKER_Pixelink,
   LIBRAW_CAMERAMAKER_Polaroid,
   LIBRAW_CAMERAMAKER_RED,
   LIBRAW_CAMERAMAKER_Ricoh,
   LIBRAW_CAMERAMAKER_Rollei,
   LIBRAW_CAMERAMAKER_RoverShot,
   LIBRAW_CAMERAMAKER_Samsung,
   LIBRAW_CAMERAMAKER_Sigma,
   LIBRAW_CAMERAMAKER_Sinar,
   LIBRAW_CAMERAMAKER_SMaL,
   LIBRAW_CAMERAMAKER_Sony,
   LIBRAW_CAMERAMAKER_ST_Micro,
   LIBRAW_CAMERAMAKER_THL,
   LIBRAW_CAMERAMAKER_VLUU,
   LIBRAW_CAMERAMAKER_Xiaomi,
   LIBRAW_CAMERAMAKER_XIAOYI,
   LIBRAW_CAMERAMAKER_YI,
   LIBRAW_CAMERAMAKER_Yuneec,
   LIBRAW_CAMERAMAKER_Zeiss,
   LIBRAW_CAMERAMAKER_OnePlus,
   LIBRAW_CAMERAMAKER_ISG,
   LIBRAW_CAMERAMAKER_VIVO,
   LIBRAW_CAMERAMAKER_HMD_Global,
   LIBRAW_CAMERAMAKER_HUAWEI,
+  LIBRAW_CAMERAMAKER_RaspberryPi,
   // Insert additional indexes here
   LIBRAW_CAMERAMAKER_TheLastOne
 };
@@ -431,16 +446,19 @@ enum LibRaw_camera_formats
 enum LibRawImageAspects
 {
   LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,
-  LIBRAW_IMAGE_ASPECT_3to2,
-  LIBRAW_IMAGE_ASPECT_1to1,
-  LIBRAW_IMAGE_ASPECT_4to3,
-  LIBRAW_IMAGE_ASPECT_16to9,
-  LIBRAW_IMAGE_ASPECT_6to6,
-  LIBRAW_IMAGE_ASPECT_5to4,
-  LIBRAW_IMAGE_ASPECT_7to6,
-  LIBRAW_IMAGE_ASPECT_6to5,
-  LIBRAW_IMAGE_ASPECT_7to5,
-  LIBRAW_IMAGE_ASPECT_OTHER
+  LIBRAW_IMAGE_ASPECT_OTHER = 1,
+  LIBRAW_IMAGE_ASPECT_MINIMAL_REAL_ASPECT_VALUE = 99, /* 1:10*/
+  LIBRAW_IMAGE_ASPECT_MAXIMAL_REAL_ASPECT_VALUE = 10000, /* 10: 1*/
+  // Value:  width / height * 1000
+  LIBRAW_IMAGE_ASPECT_3to2 =  (1000 * 3)/2,
+  LIBRAW_IMAGE_ASPECT_1to1 =  1000,
+  LIBRAW_IMAGE_ASPECT_4to3 =  (1000 * 4)/ 3,
+  LIBRAW_IMAGE_ASPECT_16to9 = (1000 * 16) / 9,
+  //LIBRAW_IMAGE_ASPECT_6to6, // what is the difference with 1:1 ?
+  LIBRAW_IMAGE_ASPECT_5to4 = (1000 * 5) / 4,
+  LIBRAW_IMAGE_ASPECT_7to6 = (1000 * 7) / 6,
+  LIBRAW_IMAGE_ASPECT_6to5 = (1000 * 6) / 5,
+  LIBRAW_IMAGE_ASPECT_7to5 = (1000 * 7) / 5
 };
 
 enum LibRaw_lens_focal_types
@@ -495,6 +513,25 @@ enum LibRaw_sony_cameratypes
   LIBRAW_SONY_CameraType_UNKNOWN = 0xffff
 };
 
+enum LibRaw_Sony_0x2010_Type {
+  LIBRAW_SONY_Tag2010None = 0,
+  LIBRAW_SONY_Tag2010a,
+  LIBRAW_SONY_Tag2010b,
+  LIBRAW_SONY_Tag2010c,
+  LIBRAW_SONY_Tag2010d,
+  LIBRAW_SONY_Tag2010e,
+  LIBRAW_SONY_Tag2010f,
+  LIBRAW_SONY_Tag2010g,
+  LIBRAW_SONY_Tag2010h,
+  LIBRAW_SONY_Tag2010i
+};
+enum LibRaw_Sony_0x9050_Type {
+  LIBRAW_SONY_Tag9050None = 0,
+  LIBRAW_SONY_Tag9050a,
+  LIBRAW_SONY_Tag9050b,
+  LIBRAW_SONY_Tag9050c
+};
+
 enum LIBRAW_SONY_FOCUSMODEmodes
 {
   LIBRAW_SONY_FOCUSMODE_MF     = 0,
@@ -558,23 +595,23 @@ enum LibRaw_rawspecial_t
 enum LibRaw_processing_options
 {
   LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES = 1,
   LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT = 1 << 1,
   LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP = 1 << 2,
   LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 3,
-  LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP = 1 << 4,
+//  LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP = 1 << 4,
   LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS = 1 << 5,
   LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT = 1 << 6,
   LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY = 1 << 7,
   LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS = 1 << 8,
   LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED = 1 << 9,
   LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS = 1 << 10,
   LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE = 1 << 11,
   LIBRAW_RAWOPTIONS_DNG_STAGE2 = 1 << 12,
   LIBRAW_RAWOPTIONS_DNG_STAGE3 = 1 << 13,
   LIBRAW_RAWOPTIONS_DNG_ALLOWSIZECHANGE = 1 << 14,
   LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST = 1 << 15,
   LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB = 1 << 16,
   LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT = 1 << 17,
   LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS = 1 << 18,
   LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS = 1 << 19
 };
diff --git a/libraw/libraw_internal.h b/libraw/libraw_internal.h
index fbda7818..0a530a84 100644
--- a/libraw/libraw_internal.h
+++ b/libraw/libraw_internal.h
@@ -138,39 +138,41 @@ typedef struct
 typedef struct
 {
   short order;
   ushort sraw_mul[4], cr2_slice[3];
   unsigned kodak_cbpp;
   INT64 strip_offset, data_offset;
   INT64 meta_offset;
+  INT64 exif_offset, ifd0_offset;
   unsigned data_size;
   unsigned meta_length;
+  unsigned cr3_exif_length, cr3_ifd0_length;
   unsigned thumb_misc;
   unsigned fuji_layout;
   unsigned tiff_samples;
   unsigned tiff_bps;
   unsigned tiff_compress;
   unsigned tiff_sampleformat;
   unsigned zero_after_ff;
   unsigned tile_width, tile_length, load_flags;
   unsigned data_error;
   int hasselblad_parser_flag;
   long long posRAFData;
   unsigned lenRAFData;
   int fuji_total_lines, fuji_total_blocks, fuji_block_width, fuji_bits,
       fuji_raw_type, fuji_lossless;
   int pana_encoding, pana_bpp;
   crx_data_header_t crx_header[LIBRAW_CRXTRACKS_MAXCOUNT];
   int crx_track_selected;
   short CR3_CTMDtag;
   short CR3_Version;
   int CM_found;
   unsigned is_NikonTransfer;
   unsigned is_Olympus;
   int OlympusDNG_SubDirOffsetValid;
   unsigned is_Sony;
   unsigned is_pana_raw;
   unsigned is_PentaxRicohMakernotes; /* =1 for Ricoh software by Pentax, Camera DNG */
 
   unsigned dng_frames[LIBRAW_IFD_MAXCOUNT*2]; /* bits: 0-7: shot_select, 8-15: IFD#, 16-31: low 16 bit of newsubfile type */
   unsigned short raw_stride;
 } unpacker_data_t;
diff --git a/libraw/libraw_types.h b/libraw/libraw_types.h
index 1492f06c..662fe796 100644
--- a/libraw/libraw_types.h
+++ b/libraw/libraw_types.h
@@ -100,965 +100,988 @@ typedef long long INT64;
 typedef unsigned long long UINT64;
 #endif
 
   typedef unsigned char uchar;
   typedef unsigned short ushort;
 
 #ifdef LIBRAW_WIN32_DLLDEFS
 #ifdef LIBRAW_NODLL
 #define DllDef
 #else
 #ifdef LIBRAW_BUILDLIB
 #define DllDef __declspec(dllexport)
 #else
 #define DllDef __declspec(dllimport)
 #endif
 #endif
 #else
 #define DllDef
 #endif
 
   typedef struct
   {
     const char *decoder_name;
     unsigned decoder_flags;
   } libraw_decoder_info_t;
 
   typedef struct
   {
     unsigned mix_green;
     unsigned raw_color;
     unsigned zero_is_bad;
     ushort shrink;
     ushort fuji_width;
   } libraw_internal_output_params_t;
 
   typedef void (*memory_callback)(void *data, const char *file,
                                   const char *where);
   typedef void (*exif_parser_callback)(void *context, int tag, int type,
                                        int len, unsigned int ord, void *ifp,
                                        INT64 base);
 
   DllDef void default_memory_callback(void *data, const char *file,
                                       const char *where);
 
   typedef void (*data_callback)(void *data, const char *file, const int offset);
 
   DllDef void default_data_callback(void *data, const char *file,
                                     const int offset);
 
   typedef int (*progress_callback)(void *data, enum LibRaw_progress stage,
                                    int iteration, int expected);
   typedef int (*pre_identify_callback)(void *ctx);
   typedef void (*post_identify_callback)(void *ctx);
   typedef void (*process_step_callback)(void *ctx);
 
   typedef struct
   {
     memory_callback mem_cb;
     void *memcb_data;
 
     data_callback data_cb;
     void *datacb_data;
 
     progress_callback progress_cb;
     void *progresscb_data;
 
     exif_parser_callback exif_cb;
     void *exifparser_data;
     pre_identify_callback pre_identify_cb;
     post_identify_callback post_identify_cb;
     process_step_callback pre_subtractblack_cb, pre_scalecolors_cb,
         pre_preinterpolate_cb, pre_interpolate_cb, interpolate_bayer_cb,
         interpolate_xtrans_cb, post_interpolate_cb, pre_converttorgb_cb,
         post_converttorgb_cb;
   } libraw_callbacks_t;
 
   typedef struct
   {
     enum LibRaw_image_formats type;
     ushort height, width, colors, bits;
     unsigned int data_size;
     unsigned char data[1];
   } libraw_processed_image_t;
 
   typedef struct
   {
     char guard[4];
     char make[64];
     char model[64];
     char software[64];
     char normalized_make[64];
     char normalized_model[64];
     unsigned maker_index;
     unsigned raw_count;
     unsigned dng_version;
     unsigned is_foveon;
     int colors;
     unsigned filters;
     char xtrans[6][6];
     char xtrans_abs[6][6];
     char cdesc[5];
     unsigned xmplen;
     char *xmpdata;
 
   } libraw_iparams_t;
 
   typedef struct
   {
-    ushort cleft, ctop, cwidth, cheight, aspect;
+    ushort cleft, ctop, cwidth, cheight;
   } libraw_raw_inset_crop_t;
 
   typedef struct
   {
     ushort raw_height, raw_width, height, width, top_margin, left_margin;
     ushort iheight, iwidth;
     unsigned raw_pitch;
     double pixel_aspect;
     int flip;
     int mask[8][4];
-    libraw_raw_inset_crop_t raw_inset_crop;
+    ushort raw_aspect;
+    libraw_raw_inset_crop_t raw_inset_crops[2];
   } libraw_image_sizes_t;
 
+ typedef struct
+  {
+    short t,l,b,r; // top, left, bottom, right pixel coordinates, (0,0) is top left pixel;
+  } libraw_area_t; 
+
   struct ph1_t
   {
     int format, key_off, tag_21a;
     int t_black, split_col, black_col, split_row, black_row;
     float tag_210;
   };
 
   typedef struct
   {
     unsigned parsedfields;
     ushort illuminant;
     float calibration[4][4];
     float colormatrix[4][3];
     float forwardmatrix[3][4];
   } libraw_dng_color_t;
 
   typedef struct
   {
     unsigned parsedfields;
     unsigned dng_cblack[LIBRAW_CBLACK_SIZE];
     unsigned dng_black;
     float dng_fcblack[LIBRAW_CBLACK_SIZE];
     float dng_fblack;
     unsigned dng_whitelevel[4];
-    unsigned default_crop[4]; /* Origin and size */
+    ushort default_crop[4]; /* Origin and size */
+    float    user_crop[4]; // top-left-bottom-right relative to default_crop
     unsigned preview_colorspace;
     float analogbalance[4];
     float asshotneutral[4];
     float baseline_exposure;
     float LinearResponseLimit;
   } libraw_dng_levels_t;
 
   typedef struct
   {
     float romm_cam[9];
   } libraw_P1_color_t;
 
   typedef struct
   {
     int ColorDataVer;
     int ColorDataSubVer;
     int SpecularWhiteLevel;
     int NormalWhiteLevel;
     int ChannelBlackLevel[4];
     int AverageBlackLevel;
     /* multishot */
     unsigned int multishot[4];
     /* metering */
     short MeteringMode;
     short SpotMeteringMode;
     uchar FlashMeteringMode;
     short FlashExposureLock;
     short ExposureMode;
     short AESetting;
     /* stabilization */
     short ImageStabilization;
     /* flash */
     short FlashMode;
     short FlashActivity;
     short FlashBits;
     short ManualFlashOutput;
     short FlashOutput;
     short FlashGuideNumber;
     /* drive */
     short ContinuousDrive;
     /* sensor */
     short SensorWidth;
     short SensorHeight;
-    short SensorLeftBorder;
-    short SensorTopBorder;
-    short SensorRightBorder;
-    short SensorBottomBorder;
-    short BlackMaskLeftBorder;
-    short BlackMaskTopBorder;
-    short BlackMaskRightBorder;
-    short BlackMaskBottomBorder;
+
     int   AFMicroAdjMode;
     float AFMicroAdjValue;
     short MakernotesFlip;
     short RecordMode;
     short SRAWQuality;
     unsigned wbi;
     short RF_lensID;
     int AutoLightingOptimizer;
     int HighlightTonePriority;
-    short LeftOpticalBlack[4]; // use this, when present, to estimate black levels?
-    short UpperOpticalBlack[4];
-    short ActiveArea[4];
+
+   libraw_area_t DefaultCropAbsolute;
+   libraw_area_t RecommendedImageArea;   // contains the image in proper aspect ratio?
+   libraw_area_t LeftOpticalBlack;       // use this, when present, to estimate black levels?
+   libraw_area_t UpperOpticalBlack;
+   libraw_area_t ActiveArea;
+    
     short ISOgain[2]; // AutoISO & BaseISO per ExifTool
   } libraw_canon_makernotes_t;
 
   typedef struct
   {
     int    BaseISO;
     double Gain;
     char   Sensor[8];
     char   SensorUnit[64]; // SU
     char   HostBody[64];   // HB
     int    SensorCode;
     int    SensorSubCode;
     int    CoatingCode;
     int    uncropped;
 
 /* CaptureSequenceInitiator is based on the content of the 'model' tag
   - values like 'Pinhole', 'Flash Sync', '500 Mech.' etc in .3FR 'model' tag
     come from MAIN MENU > SETTINGS > Camera;
   - otherwise 'model' contains:
     1. if CF/CFV/CFH, SU enclosure, can be with SU type if '-' is present
     2. else if '-' is present, HB + SU type;
     3. HB;
 */
     char CaptureSequenceInitiator[32];
 
 /* SensorUnitConnector, makernotes 0x0015 tag:
  - in .3FR - SU side
  - in .FFF - HB side
 */
     char SensorUnitConnector[64];
 
     int format; // 3FR, FFF, Imacon (H3D-39 and maybe others), Hasselblad/Phocus DNG, Adobe DNG
     int nIFD_CM[2]; // number of IFD containing CM
     int RecommendedCrop[2];
 
 /* mnColorMatrix is in makernotes tag 0x002a;
   not present in .3FR files and Imacon/H3D-39 .FFF files;
   when present in .FFF and Phocus .DNG files, it is a copy of CM1 from .3FR;
   available samples contain all '1's in the first 3 elements
 */
     double mnColorMatrix[4][3];
 
   } libraw_hasselblad_makernotes_t;
 
   typedef struct
   {
     float  ExpoMidPointShift;
     ushort DynamicRange;
     ushort FilmMode;
     ushort DynamicRangeSetting;
     ushort DevelopmentDynamicRange;
     ushort AutoDynamicRange;
     ushort DRangePriority;
     ushort DRangePriorityAuto;
     ushort DRangePriorityFixed;
 
     /*
     tag 0x9200, converted to BrightnessCompensation
     F700, S3Pro, S5Pro, S20Pro, S200EXR
     E550, E900, F810, S5600, S6500fd, S9000, S9500, S100FS
     */
     float BrightnessCompensation; /* in EV, if =4, raw data * 2^4 */
 
     ushort FocusMode;
     ushort AFMode;
     ushort FocusPixel[2];
     ushort PrioritySettings;
     unsigned FocusSettings;
     unsigned AF_C_Settings;
     ushort FocusWarning;
     ushort ImageStabilization[3];
     ushort FlashMode;
     ushort WB_Preset;
 
     /* ShutterType:
        0 - mechanical
        1 = electronic
        2 = electronic, long shutter speed
        3 = electronic, front curtain
     */
     ushort ShutterType;
     ushort ExrMode;
     ushort Macro;
     unsigned Rating;
 
     /* CropMode:
        1 - FF on GFX,
        2 - sports finder (mechanical shutter),
        4 - 1.25x crop (electronic shutter, continuous high)
     */
     ushort CropMode;
     char   SerialSignature[0x0c + 1];
     char   SensorID[4 + 1];
     char   RAFVersion[4 + 1];
     int    RAFDataGeneration; // 0 (none), 1..4, 4096
     ushort RAFDataVersion;
     int    isTSNERDTS;
 
     /* DriveMode:
        0 - single frame
        1 - continuous low
        2 - continuous high
     */
     short DriveMode;
 
     /*
     tag 0x4000 BlackLevel:
     S9100, S9000, S7000, S6000fd, S5200, S5100, S5000,
     S5Pro, S3Pro, S2Pro, S20Pro,
     S200EXR, S100FS,
     F810, F700,
     E900, E550,
     DBP, and aliases for all of the above
     */
     ushort BlackLevel[9];
     unsigned RAFData_ImageSizeTable[32];
+    int AutoBracketing;
+    int SequenceNumber;
+    int SeriesLength;
+    float PixelShiftOffset[2];
+    int ImageCount;
   } libraw_fuji_info_t;
 
   typedef struct
   {
     ushort cleft, ctop, cwidth, cheight;
   } libraw_sensor_highspeed_crop_t;
 
   typedef struct
   {
     double ExposureBracketValue;
     ushort ActiveDLighting;
     ushort ShootingMode;
     /* stabilization */
     uchar ImageStabilization[7];
     uchar VibrationReduction;
     uchar VRMode;
     /* flash */
     char  FlashSetting[13];
     char  FlashType[20];
     uchar FlashExposureCompensation[4];
     uchar ExternalFlashExposureComp[4];
     uchar FlashExposureBracketValue[4];
     uchar FlashMode;
     signed char FlashExposureCompensation2;
     signed char FlashExposureCompensation3;
     signed char FlashExposureCompensation4;
     uchar  FlashSource;
     uchar  FlashFirmware[2];
     uchar  ExternalFlashFlags;
     uchar  FlashControlCommanderMode;
     uchar  FlashOutputAndCompensation;
     uchar  FlashFocalLength;
     uchar  FlashGNDistance;
     uchar  FlashGroupControlMode[4];
     uchar  FlashGroupOutputAndCompensation[4];
     uchar  FlashColorFilter;
 
 /* NEF compression, comments follow those for ExifTool tag 0x0093:
 	 1: Lossy (type 1)
 	 2: Uncompressed
 	 3: Lossless
 	 4: Lossy (type 2)
 	 5: Striped packed 12-bit
 	 6: Uncompressed (14-bit reduced to 12-bit)
 	 7: Unpacked 12-bit
 	 8: Small raw
 	 9: Packed 12-bit
 	10: Packed 14-bit
 */
     ushort NEFCompression;
 
     int    ExposureMode;
     int    ExposureProgram;
     int    nMEshots;
     int    MEgainOn;
     double ME_WB[4];
     uchar  AFFineTune;
     uchar  AFFineTuneIndex;
     int8_t AFFineTuneAdj;
     unsigned LensDataVersion;
     unsigned FlashInfoVersion;
     unsigned ColorBalanceVersion;
     uchar key;
     ushort NEFBitDepth[4];
     ushort HighSpeedCropFormat; /* 1 -> 1.3x; 2 -> DX; 3 -> 5:4; 4 -> 3:2; 6 ->
                                    16:9; 11 -> FX uncropped; 12 -> DX uncropped;
                                    17 -> 1:1 */
     libraw_sensor_highspeed_crop_t SensorHighSpeedCrop;
     ushort SensorWidth;
     ushort SensorHeight;
     ushort Active_D_Lighting;
+    unsigned ShotInfoVersion;
+    short MakernotesFlip;
+    double RollAngle;  // positive is clockwise, CW
+    double PitchAngle; // positive is upwords
+    double YawAngle;   // positive is to the right
   } libraw_nikon_makernotes_t;
 
   typedef struct
   {
     char     CameraType2[6];
     ushort   ValidBits;
     int      SensorCalibration[2];
     ushort   DriveMode[5];
     ushort   ColorSpace;
     ushort   FocusMode[2];
     ushort   AutoFocus;
     ushort   AFPoint;
     unsigned AFAreas[64];
     double   AFPointSelected[5];
     ushort   AFResult;
     uchar    AFFineTune;
     short    AFFineTuneAdj[3];
     unsigned SpecialMode[3];
     ushort   ZoomStepCount;
     ushort   FocusStepCount;
     ushort   FocusStepInfinity;
     ushort   FocusStepNear;
     double   FocusDistance;
     ushort   AspectFrame[4]; // left, top, width, height
+    unsigned StackedImage[2];
+    uchar    isLiveND;
+    unsigned LiveNDfactor;
+    ushort   Panorama_mode;
+    ushort   Panorama_frameNum;
   } libraw_olympus_makernotes_t;
 
   typedef struct
   {
     /* Compression:
      34826 (Panasonic RAW 2): LEICA DIGILUX 2;
      34828 (Panasonic RAW 3): LEICA D-LUX 3; LEICA V-LUX 1; Panasonic DMC-LX1;
      Panasonic DMC-LX2; Panasonic DMC-FZ30; Panasonic DMC-FZ50; 34830 (not in
      exiftool): LEICA DIGILUX 3; Panasonic DMC-L1; 34316 (Panasonic RAW 1):
      others (LEICA, Panasonic, YUNEEC);
     */
     ushort   Compression;
     ushort   BlackLevelDim;
     float    BlackLevel[8];
     unsigned Multishot; /* 0 is Off, 65536 is Pixel Shift */
     float    gamma;
     int      HighISOMultiplier[3]; /* 0->R, 1->G, 2->B */
     short    FocusStepNear;
     short    FocusStepCount;
     unsigned ZoomPosition;
     unsigned LensManufacturer;
   } libraw_panasonic_makernotes_t;
 
   typedef struct
   {
     uchar    DriveMode[4];
     ushort   FocusMode[2];
     ushort   AFPointSelected[2];
     ushort   AFPointSelected_Area;
     int      AFPointsInFocus_version;
     unsigned AFPointsInFocus;
     ushort   FocusPosition;
     short    AFAdjustment;
     uchar    AFPointMode;
     uchar    MultiExposure; /* last bit is not "1" if ME is not used */
     ushort   Quality; /* 4 is raw, 7 is raw w/ pixel shift, 8 is raw w/ dynamic
                        pixel shift */
   } libraw_pentax_makernotes_t;
 
   typedef struct
   {
     ushort   AFStatus;
     unsigned AFAreaXPosition[2];
     unsigned AFAreaYPosition[2];
     ushort   AFAreaMode;
     unsigned SensorWidth;
     unsigned SensorHeight;
     unsigned CroppedImageWidth;
     unsigned CroppedImageHeight;
     ushort   WideAdapter;
     ushort   CropMode;
     ushort   NDFilter;
     ushort   AutoBracketing;
     ushort   MacroMode;
     ushort   FlashMode;
     double   FlashExposureComp;
     double   ManualFlashOutput;
   } libraw_ricoh_makernotes_t;
 
   typedef struct
   {
     unsigned ImageSizeFull[4];
     unsigned ImageSizeCrop[4];
     int      ColorSpace[2];
     unsigned key[11];
     double   DigitalGain; /* PostAEGain, digital stretch */
     int      DeviceType;
     char     LensFirmware[32];
   } libraw_samsung_makernotes_t;
 
   typedef struct
   {
     ushort BlackLevelTop;
     ushort BlackLevelBottom;
     short offset_left, offset_top; /* KDC files, negative values or zeros */
     ushort clipBlack, clipWhite;   /* valid for P712, P850, P880 */
     float romm_camDaylight[3][3];
     float romm_camTungsten[3][3];
     float romm_camFluorescent[3][3];
     float romm_camFlash[3][3];
     float romm_camCustom[3][3];
     float romm_camAuto[3][3];
     ushort val018percent, val100percent, val170percent;
     short MakerNoteKodak8a;
     float ISOCalibrationGain;
     float AnalogISO;
   } libraw_kodak_makernotes_t;
 
   typedef struct {
     char Software[64];        // tag 0x0203
     char SystemType[64];      // tag 0x0204
     char FirmwareString[256]; // tag 0x0301
     char SystemModel[64];
   } libraw_p1_makernotes_t;
 
   typedef struct
   {
 /* afdata:
   0x0010 CameraInfo
   0x2020 AFPointsUsed
   0x2022 FocalPlaneAFPointsUsed
   0x202a Tag202a
   0x940e AFInfo
 */
     ushort   CameraType;                      // init in 0xffff
     uchar    Sony0x9400_version; /* 0 if not found/deciphered,
                                     0xa, 0xb, 0xc following exiftool convention */
     uchar    Sony0x9400_ReleaseMode2;
     unsigned Sony0x9400_SequenceImageNumber;
     uchar    Sony0x9400_SequenceLength1;
     unsigned Sony0x9400_SequenceFileNumber;
     uchar    Sony0x9400_SequenceLength2;
     uint8_t  AFAreaModeSetting;               // init in 0xff; +
     uint16_t AFAreaMode;                      // init in 0xffff; +
     ushort   FlexibleSpotPosition[2];         // init in (0xffff, 0xffff)
     uint8_t  AFPointSelected;                 // init in 0xff
     uint8_t  AFPointSelected_0x201e;          // init in 0xff
     short    nAFPointsUsed;
     uint8_t  AFPointsUsed[10];
     uint8_t  AFTracking;                      // init in 0xff
     uint8_t  AFType;
     ushort   FocusLocation[4];
     ushort   FocusPosition;                    // init in 0xffff
     int8_t   AFMicroAdjValue;                  // init in 0x7f
     int8_t   AFMicroAdjOn;                     // init in -1
     uchar    AFMicroAdjRegisteredLenses;       // init in 0xff
     ushort   VariableLowPassFilter;
     unsigned LongExposureNoiseReduction;      // init in 0xffffffff
     ushort   HighISONoiseReduction;           // init in 0xffff
     ushort   HDR[2];
     ushort   group2010;
+    ushort   group9050;
     ushort   real_iso_offset;                 // init in 0xffff
     ushort   MeteringMode_offset;
     ushort   ExposureProgram_offset;
     ushort   ReleaseMode2_offset;
     unsigned MinoltaCamID;                    // init in 0xffffffff
     float    firmware;
     ushort   ImageCount3_offset;              // init in 0xffff
     unsigned ImageCount3;
     unsigned ElectronicFrontCurtainShutter;   // init in 0xffffffff
     ushort   MeteringMode2;
     char     SonyDateTime[20];
     unsigned ShotNumberSincePowerUp;
     ushort   PixelShiftGroupPrefix;
     unsigned PixelShiftGroupID;
     char     nShotsInPixelShiftGroup;
     char     numInPixelShiftGroup; /* '0' if ARQ, first shot in the group has '1'
                                   here */
     ushort   prd_ImageHeight, prd_ImageWidth;
     ushort   prd_Total_bps;
     ushort   prd_Active_bps;
     ushort   prd_StorageMethod; /* 82 -> Padded; 89 -> Linear */
     ushort   prd_BayerPattern;  /* 0 -> not valid; 1 -> RGGB; 4 -> GBRG */
 
     ushort   SonyRawFileType; /* init in 0xffff
+                               valid for ARW 2.0 and up (FileFormat >= 3000)
                                takes precedence over RAWFileType and Quality:
                                0  for uncompressed 14-bit raw
                                1  for uncompressed 12-bit raw
-                               2  for compressed raw
+                               2  for compressed raw (lossy)
                                3  for lossless compressed raw
+                               4  for lossless compressed raw v.2 (ILCE-1)
                             */
     ushort RAWFileType;     /* init in 0xffff
                                takes precedence over Quality
                                0 for compressed raw,
                                1 for uncompressed;
+                               2 lossless compressed raw v.2
                             */
     unsigned Quality;       /* init in 0xffffffff
                                0 or 6 for raw, 7 or 8 for compressed raw */
     ushort FileFormat;      /*  1000 SR2
                                 2000 ARW 1.0
                                 3000 ARW 2.0
                                 3100 ARW 2.1
                                 3200 ARW 2.2
                                 3300 ARW 2.3
                                 3310 ARW 2.3.1
                                 3320 ARW 2.3.2
                                 3330 ARW 2.3.3
                                 3350 ARW 2.3.5
                                 4000 ARW 4.0
                              */
     char MetaVersion [16];
   } libraw_sony_info_t;
 
   typedef struct
   {
     ushort curve[0x10000];
     unsigned cblack[LIBRAW_CBLACK_SIZE];
     unsigned black;
     unsigned data_maximum;
     unsigned maximum;
 
 // Canon (SpecularWhiteLevel)
 // Kodak (14N, 14nx, SLR/c/n, DCS720X, DCS760C, DCS760M, ProBack, ProBack645, P712, P880, P850)
 // Olympus, except:
 //	C5050Z, C5060WZ, C7070WZ, C8080WZ
 //	SP350, SP500UZ, SP510UZ, SP565UZ
 //	E-10, E-20
 //	E-300, E-330, E-400, E-410, E-420, E-450, E-500, E-510, E-520
 //	E-1, E-3
 //	XZ-1
 // Panasonic
 // Pentax
 // Sony
 // and aliases of the above
 // DNG
     long linear_max[4];
 
     float fmaximum;
     float fnorm;
     ushort white[8][8];
     float cam_mul[4];
     float pre_mul[4];
     float cmatrix[3][4];
     float ccm[3][4];
     float rgb_cam[3][4];
     float cam_xyz[4][3];
     struct ph1_t phase_one_data;
     float flash_used;
     float canon_ev;
     char model2[64];
     char UniqueCameraModel[64];
     char LocalizedCameraModel[64];
     char ImageUniqueID[64];
     char RawDataUniqueID[17];
     char OriginalRawFileName[64];
     void *profile;
     unsigned profile_length;
     unsigned black_stat[8];
     libraw_dng_color_t dng_color[2];
     libraw_dng_levels_t dng_levels;
     int WB_Coeffs[256][4];    /* R, G1, B, G2 coeffs */
     float WBCT_Coeffs[64][5]; /* CCT, than R, G1, B, G2 coeffs */
     int as_shot_wb_applied;
     libraw_P1_color_t P1_color[2];
     unsigned raw_bps; /* for Phase One, raw format */
                       /* Phase One raw format values, makernotes tag 0x010e:
                       0    Name unknown
                       1    "RAW 1"
                       2    "RAW 2"
-                      3    "IIQ L"
+                      3    "IIQ L" (IIQ L14)
                       4    Never seen
                       5    "IIQ S"
-                      6    "IIQ S v.2"
+                      6    "IIQ Sv2" (S14 / S14+)
                       7    Never seen
-                      8    Name unknown
+                      8    "IIQ L16" (IIQ L16EX / IIQ L16)
                       */
 	int ExifColorSpace;
   } libraw_colordata_t;
 
   typedef struct
   {
     enum LibRaw_thumbnail_formats tformat;
     ushort twidth, theight;
     unsigned tlength;
     int tcolors;
     char *thumb;
   } libraw_thumbnail_t;
 
   typedef struct
   {
     float latitude[3];     /* Deg,min,sec */
     float longitude[3];    /* Deg,min,sec */
     float gpstimestamp[3]; /* Deg,min,sec */
     float altitude;
     char  altref, latref, longref, gpsstatus;
     char  gpsparsed;
   } libraw_gps_info_t;
 
   typedef struct
   {
     float iso_speed;
     float shutter;
     float aperture;
     float focal_len;
     time_t timestamp;
     unsigned shot_order;
     unsigned gpsdata[32];
     libraw_gps_info_t parsed_gps;
     char desc[512], artist[64];
     float analogbalance[4];
   } libraw_imgother_t;
 
   typedef struct
   {
       unsigned AFInfoData_tag;
       short    AFInfoData_order;
       unsigned AFInfoData_version;
       unsigned AFInfoData_length;
       uchar   *AFInfoData;
   } libraw_afinfo_item_t;
 
   typedef struct {
     float FlashEC;
     float FlashGN;
     float CameraTemperature;
     float SensorTemperature;
     float SensorTemperature2;
     float LensTemperature;
     float AmbientTemperature;
     float BatteryTemperature;
     float exifAmbientTemperature;
     float exifHumidity;
     float exifPressure;
     float exifWaterDepth;
     float exifAcceleration;
     float exifCameraElevationAngle;
     float real_ISO;
     float exifExposureIndex;
     ushort ColorSpace;
     char firmware[128];
     float ExposureCalibrationShift;
     libraw_afinfo_item_t afdata[LIBRAW_AFDATA_MAXCOUNT];
     int afcount;
   } libraw_metadata_common_t;
 
   typedef struct
   {
     unsigned greybox[4];   /* -A  x1 y1 x2 y2 */
     unsigned cropbox[4];   /* -B x1 y1 x2 y2 */
     double aber[4];        /* -C */
     double gamm[6];        /* -g */
     float user_mul[4];     /* -r mul0 mul1 mul2 mul3 */
-    unsigned shot_select;  /* -s */
     float bright;          /* -b */
     float threshold;       /* -n */
     int half_size;         /* -h */
     int four_color_rgb;    /* -f */
     int highlight;         /* -H */
     int use_auto_wb;       /* -a */
     int use_camera_wb;     /* -w */
     int use_camera_matrix; /* +M/-M */
     int output_color;      /* -o */
     char *output_profile;  /* -o */
     char *camera_profile;  /* -p */
     char *bad_pixels;      /* -P */
     char *dark_frame;      /* -K */
     int output_bps;        /* -4 */
     int output_tiff;       /* -T */
     int output_flags;
     int user_flip;         /* -t */
     int user_qual;         /* -q */
     int user_black;        /* -k */
     int user_cblack[4];
     int user_sat;          /* -S */
     int med_passes;        /* -m */
     float auto_bright_thr;
     float adjust_maximum_thr;
     int no_auto_bright;    /* -W */
     int use_fuji_rotate;   /* -j */
     int green_matching;
     /* DCB parameters */
     int dcb_iterations;
     int dcb_enhance_fl;
     int fbdd_noiserd;
     int exp_correc;
     float exp_shift;
     float exp_preser;
     /* Disable Auto-scale */
     int no_auto_scale;
     /* Disable intepolation */
     int no_interpolation;
   } libraw_output_params_t;
 
   typedef struct  
   {
       /* Raw speed */
       int use_rawspeed;
       /* DNG SDK */
       int use_dngsdk;
       unsigned options;
+      unsigned shot_select;  /* -s */
       unsigned specials;
       unsigned max_raw_memory_mb;
       int sony_arw2_posterization_thr;
       /* Nikon Coolscan */
       float coolscan_nef_gamma;
       char p4shot_order[5];
       /* Custom camera list */
       char **custom_camera_strings;
   }libraw_raw_unpack_params_t;
 
   typedef struct
   {
     /* really allocated bitmap */
     void *raw_alloc;
     /* alias to single_channel variant */
     ushort *raw_image;
     /* alias to 4-channel variant */
     ushort (*color4_image)[4];
     /* alias to 3-color variand decoded by RawSpeed */
     ushort (*color3_image)[3];
     /* float bayer */
     float *float_image;
     /* float 3-component */
     float (*float3_image)[3];
     /* float 4-component */
     float (*float4_image)[4];
 
     /* Phase One black level data; */
     short (*ph1_cblack)[2];
     short (*ph1_rblack)[2];
     /* save color and sizes here, too.... */
     libraw_iparams_t iparams;
     libraw_image_sizes_t sizes;
     libraw_internal_output_params_t ioparams;
     libraw_colordata_t color;
   } libraw_rawdata_t;
 
   typedef struct
   {
     unsigned long long LensID;
     char Lens[128];
     ushort LensFormat; /* to characterize the image circle the lens covers */
     ushort LensMount;  /* 'male', lens itself */
     unsigned long long CamID;
     ushort CameraFormat; /* some of the sensor formats */
     ushort CameraMount;  /* 'female', body throat */
     char   body[64];
     short  FocalType; /* -1/0 is unknown; 1 is fixed focal; 2 is zoom */
     char   LensFeatures_pre[16], LensFeatures_suf[16];
     float  MinFocal, MaxFocal;
     float  MaxAp4MinFocal, MaxAp4MaxFocal, MinAp4MinFocal, MinAp4MaxFocal;
     float  MaxAp, MinAp;
     float  CurFocal, CurAp;
     float  MaxAp4CurFocal, MinAp4CurFocal;
     float  MinFocusDistance;
     float  FocusRangeIndex;
     float  LensFStops;
     unsigned long long TeleconverterID;
     char Teleconverter[128];
     unsigned long long AdapterID;
     char Adapter[128];
     unsigned long long AttachmentID;
     char   Attachment[128];
     ushort FocalUnits;
     float  FocalLengthIn35mmFormat;
   } libraw_makernotes_lens_t;
 
   typedef struct
   {
     float EffectiveMaxAp;
     uchar LensIDNumber, LensFStops, MCUVersion, LensType;
   } libraw_nikonlens_t;
 
   typedef struct
   {
     float MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal;
   } libraw_dnglens_t;
 
   typedef struct
   {
     float MinFocal, MaxFocal, MaxAp4MinFocal, MaxAp4MaxFocal, EXIF_MaxAp;
     char LensMake[128], Lens[128], LensSerial[128], InternalLensSerial[128];
     ushort FocalLengthIn35mmFormat;
     libraw_nikonlens_t nikon;
     libraw_dnglens_t dng;
     libraw_makernotes_lens_t makernotes;
   } libraw_lensinfo_t;
 
   typedef struct
   {
     libraw_canon_makernotes_t canon;
     libraw_nikon_makernotes_t nikon;
     libraw_hasselblad_makernotes_t hasselblad;
     libraw_fuji_info_t fuji;
     libraw_olympus_makernotes_t olympus;
     libraw_sony_info_t sony;
     libraw_kodak_makernotes_t kodak;
     libraw_panasonic_makernotes_t panasonic;
     libraw_pentax_makernotes_t pentax;
     libraw_p1_makernotes_t phaseone;
     libraw_ricoh_makernotes_t ricoh;
     libraw_samsung_makernotes_t samsung;
     libraw_metadata_common_t common;
   } libraw_makernotes_t;
 
   typedef struct
   {
     short DriveMode;
     short FocusMode;
     short MeteringMode;
     short AFPoint;
     short ExposureMode;
     short ExposureProgram;
     short ImageStabilization;
     char BodySerial[64];
     char InternalBodySerial[64]; /* this may be PCB or sensor serial, depends on
                                     make/model */
   } libraw_shootinginfo_t;
 
   typedef struct
   {
     unsigned fsize;
     ushort rw, rh;
     uchar lm, tm, rm, bm;
     ushort lf;
     uchar cf, max, flags;
     char t_make[10], t_model[20];
     ushort offset;
   } libraw_custom_camera_t;
 
   typedef struct
   {
     ushort (*image)[4];
     libraw_image_sizes_t sizes;
     libraw_iparams_t idata;
     libraw_lensinfo_t lens;
     libraw_makernotes_t makernotes;
     libraw_shootinginfo_t shootinginfo;
     libraw_output_params_t params;
     libraw_raw_unpack_params_t rawparams;
     unsigned int progress_flags;
     unsigned int process_warnings;
     libraw_colordata_t color;
     libraw_imgother_t other;
     libraw_thumbnail_t thumbnail;
     libraw_rawdata_t rawdata;
     void *parent_class;
   } libraw_data_t;
 
   struct fuji_q_table
   {
     int8_t *q_table; /* quantization table */
     int raw_bits;
     int total_values;
     int max_grad;    // sdp val
     int q_grad_mult; // quant_gradient multiplier
     int q_base;
   };
 
   struct fuji_compressed_params
   {
     struct fuji_q_table qt[4];
     void *buf;
     int max_bits;
     int min_value;
     int max_value;   // q_point[4]
     ushort line_width;
   };
 
 #ifdef __cplusplus
 }
 #endif
 
 #if defined (LIBRAW_LIBRARY_BUILD) && defined(__cplusplus)
diff --git a/libraw/libraw_version.h b/libraw/libraw_version.h
index a72e9d2d..4d5a0321 100644
--- a/libraw/libraw_version.h
+++ b/libraw/libraw_version.h
@@ -10,54 +10,54 @@ LibRaw is free software; you can redistribute it and/or modify
 it under the terms of the one of two licenses as you choose:
 
 1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
 (See the file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
 2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
 (See the file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
  */
 
 #ifndef __VERSION_H
 #define __VERSION_H
 
 #define LIBRAW_MAJOR_VERSION 0
 #define LIBRAW_MINOR_VERSION 21
 #define LIBRAW_PATCH_VERSION 0
 #define LIBRAW_VERSION_TAIL Snapshot202101
 
-#define LIBRAW_SHLIB_CURRENT 21
+#define LIBRAW_SHLIB_CURRENT 22
 #define LIBRAW_SHLIB_REVISION 0
 #define LIBRAW_SHLIB_AGE 0
 
 #define _LIBRAW_VERSION_MAKE(a, b, c, d) #a "." #b "." #c "-" #d
 #define LIBRAW_VERSION_MAKE(a, b, c, d) _LIBRAW_VERSION_MAKE(a, b, c, d)
 
 #define LIBRAW_VERSION_STR                                                     \
   LIBRAW_VERSION_MAKE(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION,              \
                       LIBRAW_PATCH_VERSION, LIBRAW_VERSION_TAIL)
 
 #define LIBRAW_MAKE_VERSION(major, minor, patch)                               \
   (((major) << 16) | ((minor) << 8) | (patch))
 
 #define LIBRAW_VERSION                                                         \
   LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION,              \
                       LIBRAW_PATCH_VERSION)
 
 #define LIBRAW_CHECK_VERSION(major, minor, patch)                              \
   (LibRaw::versionNumber() >= LIBRAW_MAKE_VERSION(major, minor, patch))
 
 #define LIBRAW_RUNTIME_CHECK_VERSION_EXACT()                                   \
   ((LibRaw::versionNumber() & 0xffff00) ==                                     \
    LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, 0))
 
 #define LIBRAW_RUNTIME_CHECK_VERSION_NOTLESS()                                 \
   ((LibRaw::versionNumber() & 0xffff00) >=                                     \
    LIBRAW_MAKE_VERSION(LIBRAW_MAJOR_VERSION, LIBRAW_MINOR_VERSION, 0))
 
 #define LIBRAW_COMPILE_CHECK_VERSION(major, minor)                             \
   (LIBRAW_MAKE_VERSION(major, minor, 0) == (LIBRAW_VERSION & 0xffff00))
 
 #define LIBRAW_COMPILE_CHECK_VERSION_NOTLESS(major, minor)                     \
   (LIBRAW_MAKE_VERSION(major, minor, 0) <= (LIBRAW_VERSION & 0xffff00))
 
 #endif
diff --git a/samples/4channels.cpp b/samples/4channels.cpp
index 9040a2d9..82d40f4e 100644
--- a/samples/4channels.cpp
+++ b/samples/4channels.cpp
@@ -36,138 +36,139 @@ it under the terms of the one of two licenses as you choose:
 int main(int ac, char *av[])
 {
   int i, ret;
   int autoscale = 0, black_subtraction = 1, use_gamma = 0;
   char outfn[1024];
 
   LibRaw RawProcessor;
   if (ac < 2)
   {
   usage:
     printf("4channels - LibRaw %s sample. %d cameras supported\n"
            "Usage: %s [-s N] [-g] [-A] [-B] [-N] raw-files....\n"
            "\t-s N - select Nth image in file (default=0)\n"
            "\t-g - use gamma correction with gamma 2.2 (not precise,use for "
            "visual inspection only)\n"
            "\t-A - autoscaling (by integer factor)\n"
            "\t-B - no black subtraction\n",
            LibRaw::version(), LibRaw::cameraCount(), av[0]);
     return 0;
   }
 
 #define P1 RawProcessor.imgdata.idata
 #define S RawProcessor.imgdata.sizes
 #define C RawProcessor.imgdata.color
 #define T RawProcessor.imgdata.thumbnail
 #define P2 RawProcessor.imgdata.other
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 
   OUT.output_bps = 16;
   OUT.output_tiff = 1;
   OUT.user_flip = 0;
   OUT.no_auto_bright = 1;
   OUT.half_size = 1;
 
   for (i = 1; i < ac; i++)
   {
     if (av[i][0] == '-')
     {
       if (av[i][1] == 's' && av[i][2] == 0)
       {
         i++;
-        OUT.shot_select = av[i] ? atoi(av[i]) : 0;
+        OUTR.shot_select = av[i] ? atoi(av[i]) : 0;
       }
       else if (av[i][1] == 'g' && av[i][2] == 0)
         use_gamma = 1;
       else if (av[i][1] == 'A' && av[i][2] == 0)
         autoscale = 1;
       else if (av[i][1] == 'B' && av[i][2] == 0)
       {
         black_subtraction = 0;
       }
       else
         goto usage;
       continue;
     }
     if (!use_gamma)
       OUT.gamm[0] = OUT.gamm[1] = 1;
 
     int c;
     printf("Processing file %s\n", av[i]);
     if ((ret = RawProcessor.open_file(av[i])) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot open %s: %s\n", av[i], libraw_strerror(ret));
       continue; // no recycle b/c open file will recycle itself
     }
     if (P1.is_foveon)
     {
       printf("Cannot process Foveon image %s\n", av[i]);
       continue;
     }
     if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot unpack %s: %s\n", av[i], libraw_strerror(ret));
       continue;
     }
     RawProcessor.raw2image();
     if (black_subtraction)
     {
       RawProcessor.subtract_black();
     }
 
     if (autoscale)
     {
       unsigned max = 0, scale = 1;
       for (int j = 0; j < S.iheight * S.iwidth; j++)
         for (int c = 0; c < 4; c++)
           if (max < RawProcessor.imgdata.image[j][c])
             max = RawProcessor.imgdata.image[j][c];
       if (max > 0 && max < 1 << 15)
       {
         scale = (1 << 16) / max;
         printf("Scaling with multiplier=%d (max=%d)\n", scale, max);
         for (int j = 0; j < S.iheight * S.iwidth; j++)
           for (c = 0; c < 4; c++)
             RawProcessor.imgdata.image[j][c] *= scale;
       }
       printf("Black level (scaled)=%d\n", C.black * scale);
     }
     else
       printf("Black level (unscaled)=%d\n", C.black);
 
     // hack to make dcraw tiff writer happy
     int isrgb = (P1.colors == 4 ? 0 : 1);
     P1.colors = 1;
     S.width = S.iwidth;
     S.height = S.iheight;
 
     for (int layer = 0; layer < 4; layer++)
     {
       if (layer > 0)
       {
         for (int rc = 0; rc < S.iheight * S.iwidth; rc++)
           RawProcessor.imgdata.image[rc][0] =
               RawProcessor.imgdata.image[rc][layer];
       }
       char lname[8];
       if (isrgb)
       {
         snprintf(lname, 7, "%c", ((char *)("RGBG"))[layer]);
         if (layer == 3)
           strcat(lname, "2");
       }
       else
         snprintf(lname, 7, "%c", ((char *)("GCMY"))[layer]);
 
-      if (OUT.shot_select)
-        snprintf(outfn, sizeof(outfn), "%s-%d.%s.tiff", av[i], OUT.shot_select,
+      if (OUTR.shot_select)
+        snprintf(outfn, sizeof(outfn), "%s-%d.%s.tiff", av[i], OUTR.shot_select,
                  lname);
       else
         snprintf(outfn, sizeof(outfn), "%s.%s.tiff", av[i], lname);
 
       printf("Writing file %s\n", outfn);
       if (LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
         fprintf(stderr, "Cannot write %s: %s\n", outfn, libraw_strerror(ret));
     }
   }
   return 0;
 }
diff --git a/samples/dcraw_emu.cpp b/samples/dcraw_emu.cpp
index c4498b91..2d21016b 100644
--- a/samples/dcraw_emu.cpp
+++ b/samples/dcraw_emu.cpp
@@ -238,424 +238,424 @@ void close_mapping(struct file_mapping& data)
 int main(int argc, char *argv[])
 {
   if (argc == 1)
     usage(argv[0]);
 
   LibRaw RawProcessor;
   int i, arg, c, ret;
   char opm, opt, *cp, *sp;
   int use_timing = 0, use_mem = 0, use_mmap = 0;
   char *outext = NULL;
 #ifdef USE_DNGSDK
   dng_host *dnghost = NULL;
 #endif
   struct file_mapping mapping;
   void *iobuffer = 0;
 #ifdef OUT
 #undef OUT
 #endif
 #define OUT RawProcessor.imgdata.params
 #define OUTR RawProcessor.imgdata.rawparams
 
   argv[argc] = (char *)"";
   for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)
   {
     char *optstr = argv[arg];
     opt = argv[arg++][1];
     if ((cp = strchr(sp = (char *)"cnbrkStqmHABCgU", opt)) != 0)
       for (i = 0; i < "111411111144221"[cp - sp] - '0'; i++)
         if (!isdigit(argv[arg + i][0]) && !optstr[2])
         {
           fprintf(stderr, "Non-numeric argument to \"-%c\"\n", opt);
           return 1;
         }
     if (!strchr("ftdeam", opt) && argv[arg - 1][2]) {
       fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       continue;
     }
     switch (opt)
     {
     case 'v':
       verbosity++;
       break;
     case 'G':
       OUT.green_matching = 1;
       break;
     case 'c':
       OUT.adjust_maximum_thr = (float)atof(argv[arg++]);
       break;
     case 'U':
       OUT.auto_bright_thr = (float)atof(argv[arg++]);
       break;
     case 'n':
       OUT.threshold = (float)atof(argv[arg++]);
       break;
     case 'b':
       OUT.bright = (float)atof(argv[arg++]);
       break;
     case 'P':
       OUT.bad_pixels = argv[arg++];
       break;
     case 'K':
       OUT.dark_frame = argv[arg++];
       break;
     case 'r':
       for (c = 0; c < 4; c++)
         OUT.user_mul[c] = (float)atof(argv[arg++]);
       break;
     case 'C':
       OUT.aber[0] = 1 / atof(argv[arg++]);
       OUT.aber[2] = 1 / atof(argv[arg++]);
       break;
     case 'g':
       OUT.gamm[0] = 1 / atof(argv[arg++]);
       OUT.gamm[1] = atof(argv[arg++]);
       break;
     case 'k':
       OUT.user_black = atoi(argv[arg++]);
       break;
     case 'S':
       OUT.user_sat = atoi(argv[arg++]);
       break;
     case 'R':
       OUTR.options = atoi(argv[arg++]);
       break;
     case 't':
       if (!strcmp(optstr, "-timing"))
         use_timing = 1;
       else if (!argv[arg - 1][2])
         OUT.user_flip = atoi(argv[arg++]);
       else
         fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       break;
     case 'q':
       OUT.user_qual = atoi(argv[arg++]);
       break;
     case 'm':
       if (!strcmp(optstr, "-mmap"))
         use_mmap = 1;
       else
           if (!strcmp(optstr, "-mem"))
         use_mem = 1;
       else
       {
         if (!argv[arg - 1][2])
           OUT.med_passes = atoi(argv[arg++]);
         else
           fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       }
       break;
     case 'H':
       OUT.highlight = atoi(argv[arg++]);
       break;
     case 's':
-      OUT.shot_select = abs(atoi(argv[arg++]));
+      OUTR.shot_select = abs(atoi(argv[arg++]));
       break;
     case 'o':
       if (isdigit(argv[arg][0]) && !isdigit(argv[arg][1]))
         OUT.output_color = atoi(argv[arg++]);
 #ifndef NO_LCMS
       else
         OUT.output_profile = argv[arg++];
       break;
     case 'p':
       OUT.camera_profile = argv[arg++];
 #endif
       break;
     case 'h':
       OUT.half_size = 1;
       break;
     case 'f':
       if (!strcmp(optstr, "-fbdd"))
         OUT.fbdd_noiserd = atoi(argv[arg++]);
       else
       {
         if (!argv[arg - 1][2])
           OUT.four_color_rgb = 1;
         else
           fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       }
       break;
     case 'A':
       for (c = 0; c < 4; c++)
         OUT.greybox[c] = atoi(argv[arg++]);
       break;
     case 'B':
       for (c = 0; c < 4; c++)
         OUT.cropbox[c] = atoi(argv[arg++]);
       break;
     case 'a':
       if (!strcmp(optstr, "-aexpo"))
       {
         OUT.exp_correc = 1;
         OUT.exp_shift = (float)atof(argv[arg++]);
         OUT.exp_preser = (float)atof(argv[arg++]);
       }
       else if (!strcmp(optstr, "-apentax4shot"))
       {
         OUTR.options |= LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES;
       }
       else if (!strcmp(optstr, "-apentax4shotorder"))
       {
         strncpy(OUTR.p4shot_order, argv[arg++], 5);
       }
       else if (!argv[arg - 1][2])
         OUT.use_auto_wb = 1;
       else
         fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       break;
     case 'w':
       OUT.use_camera_wb = 1;
       break;
     case 'M':
       OUT.use_camera_matrix = (opm == '+')?3:0;
       break;
     case 'j':
       OUT.use_fuji_rotate = 0;
       break;
     case 'W':
       OUT.no_auto_bright = 1;
       break;
     case 'T':
       OUT.output_tiff = 1;
       break;
     case '4':
       OUT.gamm[0] = OUT.gamm[1] = OUT.no_auto_bright = 1; /* no break here! */
     case '6':
       OUT.output_bps = 16;
       break;
     case 'Z':
       outext = strdup(argv[arg++]);
       break;
     case 'd':
       if (!strcmp(optstr, "-dcbi"))
         OUT.dcb_iterations = atoi(argv[arg++]);
       else if (!strcmp(optstr, "-doutputflags"))
         OUT.output_flags = atoi(argv[arg++]);
       else if (!strcmp(optstr, "-disars"))
         OUTR.use_rawspeed = 0;
       else if (!strcmp(optstr, "-disinterp"))
         OUT.no_interpolation = 1;
       else if (!strcmp(optstr, "-dcbe"))
         OUT.dcb_enhance_fl = 1;
       else if (!strcmp(optstr, "-dsrawrgb1"))
       {
         OUTR.specials |= LIBRAW_RAWSPECIAL_SRAW_NO_RGB;
         OUTR.specials &= ~LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE;
       }
       else if (!strcmp(optstr, "-dsrawrgb2"))
       {
         OUTR.specials &= ~LIBRAW_RAWSPECIAL_SRAW_NO_RGB;
         OUTR.specials |= LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE;
       }
 #ifdef USE_DNGSDK
       else if (!strcmp(optstr, "-dngsdk"))
       {
         dnghost = new dng_host;
         RawProcessor.set_dng_host(dnghost);
       }
       else if (!strcmp(optstr, "-dngflags"))
       {
         OUTR.use_dngsdk = atoi(argv[arg++]);
       }
 #endif
       else
         fprintf(stderr, "Unknown option \"%s\".\n", argv[arg - 1]);
       break;
     default:
       fprintf(stderr, "Unknown option \"-%c\".\n", opt);
       break;
     }
   }
 #ifndef LIBRAW_WIN32_CALLS
   putenv((char *)"TZ=UTC"); // dcraw compatibility, affects TIFF datestamp field
 #else
   _putenv(
       (char *)"TZ=UTC"); // dcraw compatibility, affects TIFF datestamp field
 #endif
 #define P1 RawProcessor.imgdata.idata
 #define S RawProcessor.imgdata.sizes
 #define C RawProcessor.imgdata.color
 #define T RawProcessor.imgdata.thumbnail
 #define P2 RawProcessor.imgdata.other
 
   if (outext && !strcmp(outext, "-"))
     use_timing = verbosity = 0;
 
   if (verbosity > 1)
     RawProcessor.set_progress_handler(my_progress_callback,
                                       (void *)"Sample data passed");
 #ifdef LIBRAW_USE_OPENMP
   if (verbosity)
     printf("Using %d threads\n", omp_get_max_threads());
 #endif
 
   int done = 0;
   int total = argc - arg;
   for (; arg < argc; arg++)
   {
     char outfn[1024];
 
     if (verbosity)
       printf("Processing file %s\n", argv[arg]);
 
     timerstart();
 
 	if (use_mmap)
 	{
 		create_mapping(mapping, argv[arg]);
 		if (!mapping.map)
 		{
 			fprintf(stderr, "Cannot map %s\n", argv[arg]);
 			close_mapping(mapping);
 			continue;
 		}
       if ((ret = RawProcessor.open_buffer(mapping.map,mapping.fsize) !=
                  LIBRAW_SUCCESS))
       {
         fprintf(stderr, "Cannot open_buffer %s: %s\n", argv[arg], libraw_strerror(ret));
 		close_mapping(mapping);
         continue; // no recycle b/c open file will recycle itself
       }
     }
     else  if (use_mem)
     {
       int file = open(argv[arg], O_RDONLY | O_BINARY);
       struct stat st;
       if (file < 0)
       {
         fprintf(stderr, "Cannot open %s: %s\n", argv[arg], strerror(errno));
         continue;
       }
       if (fstat(file, &st))
       {
         fprintf(stderr, "Cannot stat %s: %s\n", argv[arg], strerror(errno));
         close(file);
         continue;
       }
       if (!(iobuffer = malloc(st.st_size)))
       {
         fprintf(stderr, "Cannot allocate %d kbytes for memory buffer\n",
                 (int)(st.st_size / 1024));
         close(file);
         continue;
       }
       int rd;
       if (st.st_size != (rd = read(file, iobuffer, st.st_size)))
       {
         fprintf(stderr,
                 "Cannot read %d bytes instead of  %d to memory buffer\n",
                 (int)rd, (int)st.st_size);
         close(file);
         free(iobuffer);
         continue;
       }
       close(file);
       if ((ret = RawProcessor.open_buffer(iobuffer, st.st_size)) !=
           LIBRAW_SUCCESS)
       {
         fprintf(stderr, "Cannot open_buffer %s: %s\n", argv[arg],
                 libraw_strerror(ret));
         free(iobuffer);
         continue; // no recycle b/c open file will recycle itself
       }
     }
     else
     {
         ret = RawProcessor.open_file(argv[arg]);
 
       if (ret != LIBRAW_SUCCESS)
       {
         fprintf(stderr, "Cannot open %s: %s\n", argv[arg],
                 libraw_strerror(ret));
         continue; // no recycle b/c open_file will recycle itself
       }
     }
 
     if (use_timing)
       timerprint("LibRaw::open_file()", argv[arg]);
 
     timerstart();
     if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot unpack %s: %s\n", argv[arg],
               libraw_strerror(ret));
       continue;
     }
 
     if (use_timing)
       timerprint("LibRaw::unpack()", argv[arg]);
 
     timerstart();
     if (LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_process()))
     {
       fprintf(stderr, "Cannot do postpocessing on %s: %s\n", argv[arg],
               libraw_strerror(ret));
       if (LIBRAW_FATAL_ERROR(ret))
         continue;
     }
     if (use_timing)
       timerprint("LibRaw::dcraw_process()", argv[arg]);
 
     if (!outext)
       snprintf(outfn, sizeof(outfn), "%s.%s", argv[arg],
                OUT.output_tiff ? "tiff" : (P1.colors > 1 ? "ppm" : "pgm"));
     else if (!strcmp(outext, "-"))
       snprintf(outfn, sizeof(outfn), "-");
     else
     {
       if (*outext == '.') // append
         snprintf(outfn, sizeof(outfn), "%s%s", argv[arg], outext);
       else if (strchr(outext, '.') && *outext != '.') // dot is not 1st char
         strncpy(outfn, outext, sizeof(outfn));
       else
       {
         strncpy(outfn, argv[arg], sizeof(outfn));
         if (strlen(outfn) > 0)
         {
           char *lastchar = outfn + strlen(outfn); // points to term 0
           while (--lastchar > outfn)
           {
             if (*lastchar == '/' || *lastchar == '\\')
               break;
             if (*lastchar == '.')
             {
               *lastchar = 0;
               break;
             };
           }
         }
         strncat(outfn, ".", sizeof(outfn) - strlen(outfn) - 1);
         strncat(outfn, outext, sizeof(outfn) - strlen(outfn) - 1);
       }
     }
 
     if (verbosity)
     {
       printf("Writing file %s\n", outfn);
     }
 
     if (LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
       fprintf(stderr, "Cannot write %s: %s\n", outfn, libraw_strerror(ret));
     else
       done++;
 
 	RawProcessor.recycle(); // just for show this call
 
 	if (use_mmap && mapping.map)
 		close_mapping(mapping);
     else if (use_mem && iobuffer)
     {
       free(iobuffer);
       iobuffer = 0;
     }
   }
 #ifdef USE_DNGSDK
   if (dnghost)
     delete dnghost;
 #endif
   if (total == 0)
     return 1;
   if (done < total)
     return 2;
   return 0;
 }
diff --git a/samples/postprocessing_benchmark.cpp b/samples/postprocessing_benchmark.cpp
index 151e2848..703a7a37 100644
--- a/samples/postprocessing_benchmark.cpp
+++ b/samples/postprocessing_benchmark.cpp
@@ -38,162 +38,163 @@ float timerend(void);
 int main(int argc, char *argv[])
 {
   int i, ret, rep = 1;
   LibRaw RawProcessor;
 #ifdef OUT
 #undef OUT
 #endif
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 #define S RawProcessor.imgdata.sizes
 
   if (argc < 2)
   {
     printf(
         "postprocessing benchmark: LibRaw %s sample, %d cameras supported\n"
         "Measures postprocessing speed with different options\n"
         "Usage: %s [-a] [-H N] [-q N] [-h] [-m N] [-n N] [-s N] [-B x y w h] "
         "[-R N]\n"
         "-a             average image for white balance\n"
         "-H <num>       Highlight mode (0=clip, 1=unclip, 2=blend, "
         "3+=rebuild)\n"
         "-q <num>       Set the interpolation quality\n"
         "-h             Half-size color image\n"
         "-m <num>       Apply a num-passes 3x3 median filter to R-G and B-G\n"
         "-n <num>       Set threshold for wavelet denoising\n"
         "-s <num>       Select one raw image from input file\n"
         "-B <x y w h>   Crop output image\n"
         "-R <num>       Number of repetitions\n"
         "-c             Do not use rawspeed\n",
         LibRaw::version(), LibRaw::cameraCount(), argv[0]);
     return 0;
   }
   char opm, opt, *cp, *sp;
   int arg, c;
   int shrink = 0;
 
   argv[argc] = (char *)"";
   for (arg = 1; (((opm = argv[arg][0]) - 2) | 2) == '+';)
   {
     char *optstr = argv[arg];
     opt = argv[arg++][1];
     if ((cp = strchr(sp = (char *)"HqmnsBR", opt)) != 0)
       for (i = 0; i < "1111141"[cp - sp] - '0'; i++)
         if (!isdigit(argv[arg + i][0]) && !optstr[2])
         {
           fprintf(stderr, "Non-numeric argument to \"-%c\"\n", opt);
           return 1;
         }
     switch (opt)
     {
     case 'a':
       OUT.use_auto_wb = 1;
       break;
     case 'H':
       OUT.highlight = atoi(argv[arg++]);
       break;
     case 'q':
       OUT.user_qual = atoi(argv[arg++]);
       break;
     case 'h':
       OUT.half_size = 1;
       OUT.four_color_rgb = 1;
       shrink = 1;
       break;
     case 'm':
       OUT.med_passes = atoi(argv[arg++]);
       break;
     case 'n':
       OUT.threshold = (float)atof(argv[arg++]);
       break;
     case 's':
-      OUT.shot_select = abs(atoi(argv[arg++]));
+      OUTR.shot_select = abs(atoi(argv[arg++]));
       break;
     case 'B':
       for (c = 0; c < 4; c++)
         OUT.cropbox[c] = atoi(argv[arg++]);
       break;
     case 'R':
       rep = abs(atoi(argv[arg++]));
       if (rep < 1)
         rep = 1;
       break;
     case 'c':
       RawProcessor.imgdata.rawparams.use_rawspeed = 0;
       break;
     default:
       fprintf(stderr, "Unknown option \"-%c\".\n", opt);
       return 1;
     }
   }
   for (; arg < argc; arg++)
   {
     printf("Processing file %s\n", argv[arg]);
     timerstart();
     if ((ret = RawProcessor.open_file(argv[arg])) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot open_file %s: %s\n", argv[arg],
               libraw_strerror(ret));
       continue; // no recycle b/c open file will recycle itself
     }
 
     if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot unpack %s: %s\n", argv[arg],
               libraw_strerror(ret));
       continue;
     }
     float qsec = timerend();
     printf("\n%.1f msec for unpack\n", qsec);
     float mpix, rmpix;
     timerstart();
     for (c = 0; c < rep; c++)
     {
       if ((ret = RawProcessor.dcraw_process()) != LIBRAW_SUCCESS)
       {
         fprintf(stderr, "Cannot postprocess %s: %s\n", argv[arg],
                 libraw_strerror(ret));
         break;
       }
       libraw_processed_image_t *p = RawProcessor.dcraw_make_mem_image();
       if (p)
         RawProcessor.dcraw_clear_mem(p);
       RawProcessor.free_image();
     }
     float msec = timerend() / (float)rep;
 
     if ((ret = RawProcessor.adjust_sizes_info_only()) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot adjust sizes for %s: %s\n", argv[arg],
               libraw_strerror(ret));
       break;
     }
     rmpix = (S.iwidth * S.iheight) / 1000000.0f;
 
     if (c == rep) // no failure
     {
       unsigned int crop[4];
       for (int i = 0; i < 4; i++)
         crop[i] = (OUT.cropbox[i]) >> shrink;
       if (crop[0] + crop[2] > S.iwidth)
         crop[2] = S.iwidth - crop[0];
       if (crop[1] + crop[3] > S.iheight)
         crop[3] = S.iheight - crop[1];
 
       mpix = float(crop[2] * crop[3]) / 1000000.0f;
       float mpixsec = mpix * 1000.0f / msec;
 
       printf("Performance: %.2f Mpix/sec\n"
              "File: %s, Frame: %d %.1f total Mpix, %.1f msec\n"
              "Params:      WB=%s Highlight=%d Qual=%d HalfSize=%s Median=%d "
              "Wavelet=%.0f\n"
              "Crop:        %u-%u:%ux%u, active Mpix: %.2f, %.1f frames/sec\n",
-             mpixsec, argv[arg], OUT.shot_select, rmpix, msec,
+             mpixsec, argv[arg], OUTR.shot_select, rmpix, msec,
              OUT.use_auto_wb ? "auto" : "default", OUT.highlight, OUT.user_qual,
              OUT.half_size ? "YES" : "No", OUT.med_passes, OUT.threshold,
              crop[0], crop[1], crop[2], crop[3], mpix, 1000.0f / msec);
     }
   }
 
   return 0;
 }
 
 #ifndef LIBRAW_WIN32_CALLS
diff --git a/samples/raw-identify.cpp b/samples/raw-identify.cpp
index f47b7b9b..49cf9a7e 100644
--- a/samples/raw-identify.cpp
+++ b/samples/raw-identify.cpp
@@ -301,378 +301,379 @@ int main(int ac, char *av[])
 void print_verbose(FILE *outfile, LibRaw &MyCoolRawProcessor, std::string &fn)
 {
   int WBi;
   float denom;
   int ret;
 
   if ((ret = MyCoolRawProcessor.adjust_sizes_info_only()))
   {
     fprintf(outfile, "Cannot decode %s: %s\n", fn.c_str(), libraw_strerror(ret));
     return; // no recycle, open_file will recycle
   }
 
   fprintf(outfile, "\nFilename: %s\n", fn.c_str());
   if (C.OriginalRawFileName[0])
     fprintf(outfile, "OriginalRawFileName: =%s=\n", C.OriginalRawFileName);
   fprintf(outfile, "Timestamp: %s", ctime(&(P2.timestamp)));
   fprintf(outfile, "Camera: %s %s ID: 0x%llx\n", P1.make, P1.model, mnLens.CamID);
   fprintf(outfile, "Normalized Make/Model: =%s/%s= ", P1.normalized_make, P1.normalized_model);
   fprintf(outfile, "CamMaker ID: %d\n", P1.maker_index);
 
   {
     int i = 0;
     char sep[] = ", ";
     if (C.UniqueCameraModel[0])
     {
       i++;
       fprintf(outfile, "UniqueCameraModel: =%s=", C.UniqueCameraModel);
     }
     if (C.LocalizedCameraModel[0])
     {
       if (i)
       {
         fprintf(outfile, "%s", sep);
         i++;
       }
       fprintf(outfile, "LocalizedCameraModel: =%s=", C.LocalizedCameraModel);
     }
     if (i)
     {
       fprintf(outfile, "\n");
       i = 0;
     }
     if (C.ImageUniqueID[0])
     {
       if (i)
         fprintf(outfile, "%s", sep);
       i++;
       fprintf(outfile, "ImageUniqueID: =%s=", C.ImageUniqueID);
     }
     if (C.RawDataUniqueID[0])
     {
       if (i)
         fprintf(outfile, "%s", sep);
       i++;
       fprintf(outfile, "RawDataUniqueID: =%s=", C.RawDataUniqueID);
     }
     if (i)
       fprintf(outfile, "\n");
   }
 
   if (ShootingInfo.BodySerial[0] && strcmp(ShootingInfo.BodySerial, "0"))
   {
     trimSpaces(ShootingInfo.BodySerial);
     fprintf(outfile, "Body#: %s", ShootingInfo.BodySerial);
   }
   else if (C.model2[0] && (!strncasecmp(P1.normalized_make, "Kodak", 5)))
   {
     trimSpaces(C.model2);
     fprintf(outfile, "Body#: %s", C.model2);
   }
   if (ShootingInfo.InternalBodySerial[0])
   {
     trimSpaces(ShootingInfo.InternalBodySerial);
     fprintf(outfile, " BodyAssy#: %s", ShootingInfo.InternalBodySerial);
   }
   if (exifLens.LensSerial[0])
   {
     trimSpaces(exifLens.LensSerial);
     fprintf(outfile, " Lens#: %s", exifLens.LensSerial);
   }
   if (exifLens.InternalLensSerial[0])
   {
     trimSpaces(exifLens.InternalLensSerial);
     fprintf(outfile, " LensAssy#: %s", exifLens.InternalLensSerial);
   }
   if (P2.artist[0])
     fprintf(outfile, " Owner: %s\n", P2.artist);
   if (P1.dng_version)
   {
     fprintf(outfile, " DNG Version: ");
     for (int i = 24; i >= 0; i -= 8)
       fprintf(outfile, "%d%c", P1.dng_version >> i & 255, i ? '.' : '\n');
   }
   fprintf(outfile, "\nEXIF:\n");
   fprintf(outfile, "\tMinFocal: %0.1f mm\n", exifLens.MinFocal);
   fprintf(outfile, "\tMaxFocal: %0.1f mm\n", exifLens.MaxFocal);
   fprintf(outfile, "\tMaxAp @MinFocal: f/%0.1f\n", exifLens.MaxAp4MinFocal);
   fprintf(outfile, "\tMaxAp @MaxFocal: f/%0.1f\n", exifLens.MaxAp4MaxFocal);
   fprintf(outfile, "\tCurFocal: %0.1f mm\n", P2.focal_len);
   fprintf(outfile, "\tMaxAperture @CurFocal: f/%0.1f\n", exifLens.EXIF_MaxAp);
   fprintf(outfile, "\tFocalLengthIn35mmFormat: %d mm\n", exifLens.FocalLengthIn35mmFormat);
   fprintf(outfile, "\tLensMake: %s\n", exifLens.LensMake);
   fprintf(outfile, "\tLens: %s\n", exifLens.Lens);
   fprintf(outfile, "\n");
 
   fprintf(outfile, "\nMakernotes:\n");
   fprintf(outfile, "\tDriveMode: %d\n", ShootingInfo.DriveMode);
   fprintf(outfile, "\tFocusMode: %d\n", ShootingInfo.FocusMode);
   fprintf(outfile, "\tMeteringMode: %d\n", ShootingInfo.MeteringMode);
   fprintf(outfile, "\tAFPoint: %d\n", ShootingInfo.AFPoint);
   fprintf(outfile, "\tExposureMode: %d\n", ShootingInfo.ExposureMode);
   fprintf(outfile, "\tExposureProgram: %d\n", ShootingInfo.ExposureProgram);
   fprintf(outfile, "\tImageStabilization: %d\n", ShootingInfo.ImageStabilization);
 
   fprintf(outfile, "\tLens: %s\n", mnLens.Lens);
   fprintf(outfile, "\tLensFormat: %d, ", mnLens.LensFormat);
 
   fprintf(outfile, "\tLensMount: %d, ", mnLens.LensMount);
   fprintf(outfile, "\tFocalType: %d, ", mnLens.FocalType);
   switch (mnLens.FocalType)
   {
   case LIBRAW_FT_UNDEFINED:
     fprintf(outfile, "Undefined\n");
     break;
   case LIBRAW_FT_PRIME_LENS:
     fprintf(outfile, "Prime lens\n");
     break;
   case LIBRAW_FT_ZOOM_LENS:
     fprintf(outfile, "Zoom lens\n");
     break;
   default:
     fprintf(outfile, "Unknown\n");
     break;
   }
   fprintf(outfile, "\tLensFeatures_pre: %s\n", mnLens.LensFeatures_pre);
   fprintf(outfile, "\tLensFeatures_suf: %s\n", mnLens.LensFeatures_suf);
   fprintf(outfile, "\tMinFocal: %0.1f mm\n", mnLens.MinFocal);
   fprintf(outfile, "\tMaxFocal: %0.1f mm\n", mnLens.MaxFocal);
   fprintf(outfile, "\tMaxAp @MinFocal: f/%0.1f\n", mnLens.MaxAp4MinFocal);
   fprintf(outfile, "\tMaxAp @MaxFocal: f/%0.1f\n", mnLens.MaxAp4MaxFocal);
   fprintf(outfile, "\tMinAp @MinFocal: f/%0.1f\n", mnLens.MinAp4MinFocal);
   fprintf(outfile, "\tMinAp @MaxFocal: f/%0.1f\n", mnLens.MinAp4MaxFocal);
   fprintf(outfile, "\tMaxAp: f/%0.1f\n", mnLens.MaxAp);
   fprintf(outfile, "\tMinAp: f/%0.1f\n", mnLens.MinAp);
   fprintf(outfile, "\tCurFocal: %0.1f mm\n", mnLens.CurFocal);
   fprintf(outfile, "\tCurAp: f/%0.1f\n", mnLens.CurAp);
   fprintf(outfile, "\tMaxAp @CurFocal: f/%0.1f\n", mnLens.MaxAp4CurFocal);
   fprintf(outfile, "\tMinAp @CurFocal: f/%0.1f\n", mnLens.MinAp4CurFocal);
 
   if (exifLens.makernotes.FocalLengthIn35mmFormat > 1.0f)
     fprintf(outfile, "\tFocalLengthIn35mmFormat: %0.1f mm\n", exifLens.makernotes.FocalLengthIn35mmFormat);
 
   if (exifLens.nikon.EffectiveMaxAp > 0.1f)
     fprintf(outfile, "\tEffectiveMaxAp: f/%0.1f\n", exifLens.nikon.EffectiveMaxAp);
 
   if (exifLens.makernotes.LensFStops > 0.1f)
     fprintf(outfile, "\tLensFStops @CurFocal: %0.2f\n", exifLens.makernotes.LensFStops);
 
   fprintf(outfile, "\tTeleconverterID: %lld\n", mnLens.TeleconverterID);
   fprintf(outfile, "\tTeleconverter: %s\n", mnLens.Teleconverter);
   fprintf(outfile, "\tAdapterID: %lld\n", mnLens.AdapterID);
   fprintf(outfile, "\tAdapter: %s\n", mnLens.Adapter);
   fprintf(outfile, "\tAttachmentID: %lld\n", mnLens.AttachmentID);
   fprintf(outfile, "\tAttachment: %s\n", mnLens.Attachment);
   fprintf(outfile, "\n");
 
   fprintf(outfile, "ISO speed: %d\n", (int)P2.iso_speed);
   if (P3.real_ISO > 0.1f)
     fprintf(outfile, "real ISO speed: %d\n", (int)P3.real_ISO);
   fprintf(outfile, "Shutter: ");
   if (P2.shutter > 0 && P2.shutter < 1)
     P2.shutter = fprintf(outfile, "1/%0.1f\n", 1.0f / P2.shutter);
   else if (P2.shutter >= 1)
     fprintf(outfile, "%0.1f sec\n", P2.shutter);
   else /* negative*/
     fprintf(outfile, " negative value\n");
   fprintf(outfile, "Aperture: f/%0.1f\n", P2.aperture);
   fprintf(outfile, "Focal length: %0.1f mm\n", P2.focal_len);
   if (P3.exifAmbientTemperature > -273.15f)
     fprintf(outfile, "Ambient temperature (exif data): %6.2fÂ° C\n", P3.exifAmbientTemperature);
   if (P3.CameraTemperature > -273.15f)
     fprintf(outfile, "Camera temperature: %6.2fÂ° C\n", P3.CameraTemperature);
   if (P3.SensorTemperature > -273.15f)
     fprintf(outfile, "Sensor temperature: %6.2fÂ° C\n", P3.SensorTemperature);
   if (P3.SensorTemperature2 > -273.15f)
     fprintf(outfile, "Sensor temperature2: %6.2fÂ° C\n", P3.SensorTemperature2);
   if (P3.LensTemperature > -273.15f)
     fprintf(outfile, "Lens temperature: %6.2fÂ° C\n", P3.LensTemperature);
   if (P3.AmbientTemperature > -273.15f)
     fprintf(outfile, "Ambient temperature: %6.2fÂ° C\n", P3.AmbientTemperature);
   if (P3.BatteryTemperature > -273.15f)
     fprintf(outfile, "Battery temperature: %6.2fÂ° C\n", P3.BatteryTemperature);
   if (P3.FlashGN > 1.0f)
     fprintf(outfile, "Flash Guide Number: %6.2f\n", P3.FlashGN);
   fprintf(outfile, "Flash exposure compensation: %0.2f EV\n", P3.FlashEC);
   if (C.profile)
     fprintf(outfile, "Embedded ICC profile: yes, %d bytes\n", C.profile_length);
   else
     fprintf(outfile, "Embedded ICC profile: no\n");
 
   if (C.dng_levels.baseline_exposure > -999.f)
     fprintf(outfile, "Baseline exposure: %04.3f\n", C.dng_levels.baseline_exposure);
 
   fprintf(outfile, "Number of raw images: %d\n", P1.raw_count);
 
   if (S.pixel_aspect != 1)
     fprintf(outfile, "Pixel Aspect Ratio: %0.6f\n", S.pixel_aspect);
   if (T.tlength)
     fprintf(outfile, "Thumb size:  %4d x %d\n", T.twidth, T.theight);
   fprintf(outfile, "Full size:   %4d x %d\n", S.raw_width, S.raw_height);
 
-  if (S.raw_inset_crop.cwidth)
+  if (S.raw_inset_crops[0].cwidth)
   {
-    fprintf(outfile, "Raw inset, width x height: %4d x %d ", S.raw_inset_crop.cwidth, S.raw_inset_crop.cheight);
-    if (S.raw_inset_crop.cleft != 0xffff)
-      fprintf(outfile, "left: %d ", S.raw_inset_crop.cleft);
-    if (S.raw_inset_crop.ctop != 0xffff)
-      fprintf(outfile, "top: %d", S.raw_inset_crop.ctop);
+    fprintf(outfile, "Raw inset, width x height: %4d x %d ", S.raw_inset_crops[0].cwidth, S.raw_inset_crops[0].cheight);
+    if (S.raw_inset_crops[0].cleft != 0xffff)
+      fprintf(outfile, "left: %d ", S.raw_inset_crops[0].cleft);
+    if (S.raw_inset_crops[0].ctop != 0xffff)
+      fprintf(outfile, "top: %d", S.raw_inset_crops[0].ctop);
     fprintf(outfile, "\n");
   }
 
   fprintf(outfile, "Image size:  %4d x %d\n", S.width, S.height);
   fprintf(outfile, "Output size: %4d x %d\n", S.iwidth, S.iheight);
   fprintf(outfile, "Image flip: %d\n", S.flip);
 
   fprintf(outfile, "Raw colors: %d", P1.colors);
   if (P1.filters)
   {
     fprintf(outfile, "\nFilter pattern: ");
     if (!P1.cdesc[3])
       P1.cdesc[3] = 'G';
     for (int i = 0; i < 16; i++)
       putchar(P1.cdesc[MyCoolRawProcessor.fcol(i >> 1, i & 1)]);
   }
 
   if (C.black)
   {
     fprintf(outfile, "\nblack: %d", C.black);
   }
   if (C.cblack[0] != 0)
   {
     fprintf(outfile, "\ncblack[0 .. 3]:");
     for (int c = 0; c < 4; c++)
       fprintf(outfile, " %d", C.cblack[c]);
   }
   if ((C.cblack[4] * C.cblack[5]) > 0)
   {
     fprintf(outfile, "\nBlackLevelRepeatDim: %d x %d\n", C.cblack[4], C.cblack[5]);
     int n = C.cblack[4] * C.cblack[5];
     fprintf(outfile, "cblack[6 .. %d]:", 6 + n - 1);
     for (int c = 6; c < 6 + n; c++)
       fprintf(outfile, " %d", C.cblack[c]);
   }
 
   if (C.linear_max[0] != 0)
   {
     fprintf(outfile, "\nHighlight linearity limits:");
     for (int c = 0; c < 4; c++)
       fprintf(outfile, " %ld", C.linear_max[c]);
   }
 
   if (P1.colors > 1)
   {
     fprintf(outfile, "\nMakernotes WB data:               coeffs                  EVs");
     if ((C.cam_mul[0] > 0) && (C.cam_mul[1] > 0))
     {
       fprintf(outfile, "\n  %-23s   %g %g %g %g   %5.2f %5.2f %5.2f %5.2f", "As shot", C.cam_mul[0], C.cam_mul[1],
               C.cam_mul[2], C.cam_mul[3], roundf(log2(C.cam_mul[0] / C.cam_mul[1]) * 100.0f) / 100.0f, 0.0f,
               roundf(log2(C.cam_mul[2] / C.cam_mul[1]) * 100.0f) / 100.0f,
               C.cam_mul[3] ? roundf(log2(C.cam_mul[3] / C.cam_mul[1]) * 100.0f) / 100.0f : 0.0f);
     }
 
     for (int cnt = 0; cnt < int(sizeof WBToStr / sizeof *WBToStr); cnt++)
     {
       WBi = WBToStr[cnt].NumId;
       if ((C.WB_Coeffs[WBi][0] > 0) && (C.WB_Coeffs[WBi][1] > 0))
       {
         denom = (float)C.WB_Coeffs[WBi][1];
         fprintf(outfile, "\n  %-23s   %4d %4d %4d %4d   %5.2f %5.2f %5.2f %5.2f", WBToStr[cnt].hrStrId,
                 C.WB_Coeffs[WBi][0], C.WB_Coeffs[WBi][1], C.WB_Coeffs[WBi][2], C.WB_Coeffs[WBi][3],
                 roundf(log2((float)C.WB_Coeffs[WBi][0] / denom) * 100.0f) / 100.0f, 0.0f,
                 roundf(log2((float)C.WB_Coeffs[WBi][2] / denom) * 100.0f) / 100.0f,
                 C.WB_Coeffs[3] ? roundf(log2((float)C.WB_Coeffs[WBi][3] / denom) * 100.0f) / 100.0f : 0.0f);
       }
     }
 
     if (C.rgb_cam[0][0] > 0.0001)
     {
       fprintf(outfile, "\n\nCamera2RGB matrix (mode: %d):\n", MyCoolRawProcessor.imgdata.params.use_camera_matrix);
       PRINTMATRIX3x4(outfile, C.rgb_cam, P1.colors);
     }
 
     fprintf(outfile, "\nXYZ->CamRGB matrix:\n");
     PRINTMATRIX4x3(outfile, C.cam_xyz, P1.colors);
 
     for (int cnt = 0; cnt < 2; cnt++)
     {
       if (fabsf(C.P1_color[cnt].romm_cam[0]) > 0)
       {
         fprintf(outfile, "\nPhaseOne Matrix %d:\n", cnt + 1);
         for (int i = 0; i < 3; i++)
           fprintf(outfile, "%6.4f\t%6.4f\t%6.4f\n", C.P1_color[cnt].romm_cam[i * 3],
                   C.P1_color[cnt].romm_cam[i * 3 + 1], C.P1_color[cnt].romm_cam[i * 3 + 2]);
       }
     }
 
     if (fabsf(C.cmatrix[0][0]) > 0)
     {
       fprintf(outfile, "\ncamRGB -> sRGB Matrix:\n");
       PRINTMATRIX3x4(outfile, C.cmatrix, P1.colors);
     }
 
     if (fabsf(C.ccm[0][0]) > 0)
     {
       fprintf(outfile, "\nColor Correction Matrix:\n");
       PRINTMATRIX3x4(outfile, C.ccm, P1.colors);
     }
 
     for (int cnt = 0; cnt < 2; cnt++)
     {
       if (C.dng_color[cnt].illuminant != LIBRAW_WBI_None)
       {
         if (C.dng_color[cnt].illuminant <= LIBRAW_WBI_StudioTungsten)
         {
           fprintf(outfile, "\nDNG Illuminant %d: %s", cnt + 1, WB_idx2hrstr(C.dng_color[cnt].illuminant));
         }
         else if (C.dng_color[cnt].illuminant == LIBRAW_WBI_Other)
         {
           fprintf(outfile, "\nDNG Illuminant %d: Other", cnt + 1);
         }
         else
         {
           fprintf(outfile,
                   "\nDNG Illuminant %d is out of EXIF LightSources range "
                   "[0:24, 255]: %d",
                   cnt + 1, C.dng_color[cnt].illuminant);
         }
       }
     }
 
     for (int n = 0; n < 2; n++)
     {
       if (fabsf(C.dng_color[n].colormatrix[0][0]) > 0)
       {
         fprintf(outfile, "\nDNG color matrix %d:\n", n + 1);
         PRINTMATRIX4x3(outfile, C.dng_color[n].colormatrix, P1.colors);
       }
     }
 
     for (int n = 0; n < 2; n++)
     {
       if (fabsf(C.dng_color[n].calibration[0][0]) > 0)
       {
         fprintf(outfile, "\nDNG calibration matrix %d:\n", n + 1);
         for (int i = 0; i < P1.colors && i < 4; i++)
         {
           for (int j = 0; j < P1.colors && j < 4; j++)
             fprintf(outfile, "%6.4f\t", C.dng_color[n].calibration[j][i]);
           fprintf(outfile, "\n");
         }
       }
     }
 
     for (int n = 0; n < 2; n++)
     {
       if (fabsf(C.dng_color[n].forwardmatrix[0][0]) > 0)
       {
         fprintf(outfile, "\nDNG forward matrix %d:\n", n + 1);
         PRINTMATRIX3x4(outfile, C.dng_color[n].forwardmatrix, P1.colors);
       }
     }
 
     fprintf(outfile, "\nDerived D65 multipliers:");
     for (int c = 0; c < P1.colors; c++)
       fprintf(outfile, " %f", C.pre_mul[c]);
+    fprintf(outfile, "\n");
   }
 }
 
diff --git a/samples/unprocessed_raw.cpp b/samples/unprocessed_raw.cpp
index ff35497b..2f30ce4c 100644
--- a/samples/unprocessed_raw.cpp
+++ b/samples/unprocessed_raw.cpp
@@ -49,122 +49,123 @@ void write_tiff(int width, int height, unsigned short *bitmap,
 int main(int ac, char *av[])
 {
   int i, ret;
   int verbose = 1, autoscale = 0, use_gamma = 0, out_tiff = 0;
   char outfn[1024];
 
   LibRaw RawProcessor;
   if (ac < 2)
   {
   usage:
     printf("unprocessed_raw - LibRaw %s sample. %d cameras supported\n"
            "Usage: %s [-q] [-A] [-g] [-s N] raw-files....\n"
            "\t-q - be quiet\n"
            "\t-s N - select Nth image in file (default=0)\n"
            "\t-g - use gamma correction with gamma 2.2 (not precise,use for "
            "visual inspection only)\n"
            "\t-A - autoscaling (by integer factor)\n"
            "\t-T - write tiff instead of pgm\n",
            LibRaw::version(), LibRaw::cameraCount(), av[0]);
     return 0;
   }
 
 #define S RawProcessor.imgdata.sizes
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 
   for (i = 1; i < ac; i++)
   {
     if (av[i][0] == '-')
     {
       if (av[i][1] == 'q' && av[i][2] == 0)
         verbose = 0;
       else if (av[i][1] == 'A' && av[i][2] == 0)
         autoscale = 1;
       else if (av[i][1] == 'g' && av[i][2] == 0)
         use_gamma = 1;
       else if (av[i][1] == 'T' && av[i][2] == 0)
         out_tiff = 1;
       else if (av[i][1] == 's' && av[i][2] == 0)
       {
         i++;
-        OUT.shot_select = av[i] ? atoi(av[i]) : 0;
+        OUTR.shot_select = av[i] ? atoi(av[i]) : 0;
       }
       else
         goto usage;
       continue;
     }
 
     if (verbose)
       printf("Processing file %s\n", av[i]);
     if ((ret = RawProcessor.open_file(av[i])) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot open %s: %s\n", av[i], libraw_strerror(ret));
       continue; // no recycle b/c open file will recycle itself
     }
     if (verbose)
     {
       printf("Image size: %dx%d\nRaw size: %dx%d\n", S.width, S.height,
              S.raw_width, S.raw_height);
       printf("Margins: top=%d, left=%d\n", S.top_margin, S.left_margin);
     }
 
     if ((ret = RawProcessor.unpack()) != LIBRAW_SUCCESS)
     {
       fprintf(stderr, "Cannot unpack %s: %s\n", av[i], libraw_strerror(ret));
       continue;
     }
 
     if (verbose)
       printf("Unpacked....\n");
 
     if (!(RawProcessor.imgdata.idata.filters ||
           RawProcessor.imgdata.idata.colors == 1))
     {
       printf("Only Bayer-pattern RAW files supported, sorry....\n");
       continue;
     }
 
     if (autoscale)
     {
       unsigned max = 0, scale;
       for (int j = 0; j < S.raw_height * S.raw_width; j++)
         if (max < RawProcessor.imgdata.rawdata.raw_image[j])
           max = RawProcessor.imgdata.rawdata.raw_image[j];
       if (max > 0 && max < 1 << 15)
       {
         scale = (1 << 16) / max;
         if (verbose)
           printf("Scaling with multiplier=%d (max=%d)\n", scale, max);
 
         for (int j = 0; j < S.raw_height * S.raw_width; j++)
           RawProcessor.imgdata.rawdata.raw_image[j] *= scale;
       }
     }
     if (use_gamma)
     {
       unsigned short curve[0x10000];
       gamma_curve(curve);
       for (int j = 0; j < S.raw_height * S.raw_width; j++)
         RawProcessor.imgdata.rawdata.raw_image[j] =
             curve[RawProcessor.imgdata.rawdata.raw_image[j]];
       if (verbose)
         printf("Gamma-corrected....\n");
     }
 
-    if (OUT.shot_select)
-      snprintf(outfn, sizeof(outfn), "%s-%d.%s", av[i], OUT.shot_select,
+    if (OUTR.shot_select)
+      snprintf(outfn, sizeof(outfn), "%s-%d.%s", av[i], OUTR.shot_select,
                out_tiff ? "tiff" : "pgm");
     else
       snprintf(outfn, sizeof(outfn), "%s.%s", av[i], out_tiff ? "tiff" : "pgm");
 
     if (out_tiff)
       write_tiff(S.raw_width, S.raw_height,
                  RawProcessor.imgdata.rawdata.raw_image, outfn);
     else
       write_ppm(S.raw_width, S.raw_height,
                 RawProcessor.imgdata.rawdata.raw_image, outfn);
 
     if (verbose)
       printf("Stored to file %s\n", outfn);
   }
   return 0;
 }
diff --git a/src/decoders/canon_600.cpp b/src/decoders/canon_600.cpp
index 8508da85..59576f1f 100644
--- a/src/decoders/canon_600.cpp
+++ b/src/decoders/canon_600.cpp
@@ -90,85 +90,86 @@ int LibRaw::canon_600_color(int ratio[2], int mar)
 void LibRaw::canon_600_auto_wb()
 {
   int mar, row, col, i, j, st, count[] = {0, 0};
   int test[8], total[2][8], ratio[2][2], stat[2];
 
   memset(&total, 0, sizeof total);
-  i = canon_ev + 0.5;
+  i = int(canon_ev + 0.5);
   if (i < 10)
     mar = 150;
   else if (i > 12)
     mar = 20;
   else
     mar = 280 - 20 * i;
   if (flash_used)
     mar = 80;
   for (row = 14; row < height - 14; row += 4)
     for (col = 10; col < width; col += 2)
     {
       for (i = 0; i < 8; i++)
         test[(i & 4) + FC(row + (i >> 1), col + (i & 1))] =
             BAYER(row + (i >> 1), col + (i & 1));
       for (i = 0; i < 8; i++)
         if (test[i] < 150 || test[i] > 1500)
           goto next;
       for (i = 0; i < 4; i++)
         if (abs(test[i] - test[i + 4]) > 50)
           goto next;
       for (i = 0; i < 2; i++)
       {
         for (j = 0; j < 4; j += 2)
           ratio[i][j >> 1] =
               ((test[i * 4 + j + 1] - test[i * 4 + j]) << 10) / test[i * 4 + j];
         stat[i] = canon_600_color(ratio[i], mar);
       }
       if ((st = stat[0] | stat[1]) > 1)
         goto next;
       for (i = 0; i < 2; i++)
         if (stat[i])
           for (j = 0; j < 2; j++)
             test[i * 4 + j * 2 + 1] =
                 test[i * 4 + j * 2] * (0x400 + ratio[i][j]) >> 10;
       for (i = 0; i < 8; i++)
         total[st][i] += test[i];
       count[st]++;
     next:;
     }
   if (count[0] | count[1])
   {
     st = count[0] * 200 < count[1];
     for (i = 0; i < 4; i++)
-      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);
+		if (total[st][i] + total[st][i + 4])
+			pre_mul[i] = 1.0f / (total[st][i] + total[st][i + 4]);
   }
 }
 
 void LibRaw::canon_600_coeff()
 {
   static const short table[6][12] = {
       {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},
       {-1203, 1715, -1136, 1648, 1388, -876, 267, 245, -1641, 2153, 3921,
        -3409},
       {-615, 1127, -1563, 2075, 1437, -925, 509, 3, -756, 1268, 2519, -2007},
       {-190, 702, -1886, 2398, 2153, -1641, 763, -251, -452, 964, 3040, -2528},
       {-190, 702, -1878, 2390, 1861, -1349, 905, -393, -432, 944, 2617, -2105},
       {-807, 1319, -1785, 2297, 1388, -876, 769, -257, -230, 742, 2067, -1555}};
   int t = 0, i, c;
   float mc, yc;
 
   mc = pre_mul[1] / pre_mul[2];
   yc = pre_mul[3] / pre_mul[2];
   if (mc > 1 && mc <= 1.28 && yc < 0.8789)
     t = 1;
   if (mc > 1.28 && mc <= 2)
   {
     if (yc < 0.8789)
       t = 3;
     else if (yc <= 2)
       t = 4;
   }
   if (flash_used)
     t = 5;
   for (raw_color = i = 0; i < 3; i++)
-    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;
+    FORCC rgb_cam[i][c] = float(table[t][i * 4 + c]) / 1024.f;
 }
 
 void LibRaw::canon_600_load_raw()
diff --git a/src/decoders/decoders_dcraw.cpp b/src/decoders/decoders_dcraw.cpp
index 6f1ea5a8..c81ad6b5 100644
--- a/src/decoders/decoders_dcraw.cpp
+++ b/src/decoders/decoders_dcraw.cpp
@@ -203,76 +203,77 @@ int LibRaw::canon_has_lowbits()
 void LibRaw::canon_load_raw()
 {
   ushort *pixel, *prow, *huff[2];
-  int nblocks, lowbits, i, c, row, r, save, val;
+  int nblocks, lowbits, i, c, row, r, val;
+  INT64 save;
   int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];
 
   crw_init_tables(tiff_compress, huff);
   lowbits = canon_has_lowbits();
   if (!lowbits)
     maximum = 0x3ff;
   fseek(ifp, 540 + lowbits * raw_height * raw_width / 4, SEEK_SET);
   zero_after_ff = 1;
   getbits(-1);
   try
   {
     for (row = 0; row < raw_height; row += 8)
     {
       checkCancel();
       pixel = raw_image + row * raw_width;
       nblocks = MIN(8, raw_height - row) * raw_width >> 6;
       for (block = 0; block < nblocks; block++)
       {
         memset(diffbuf, 0, sizeof diffbuf);
         for (i = 0; i < 64; i++)
         {
           leaf = gethuff(huff[i > 0]);
           if (leaf == 0 && i)
             break;
           if (leaf == 0xff)
             continue;
           i += leaf >> 4;
           len = leaf & 15;
           if (len == 0)
             continue;
           diff = getbits(len);
           if ((diff & (1 << (len - 1))) == 0)
             diff -= (1 << len) - 1;
           if (i < 64)
             diffbuf[i] = diff;
         }
         diffbuf[0] += carry;
         carry = diffbuf[0];
         for (i = 0; i < 64; i++)
         {
           if (pnum++ % raw_width == 0)
             base[0] = base[1] = 512;
           if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)
             derror();
         }
       }
       if (lowbits)
       {
         save = ftell(ifp);
         fseek(ifp, 26 + row * raw_width / 4, SEEK_SET);
         for (prow = pixel, i = 0; i < raw_width * 2; i++)
         {
           c = fgetc(ifp);
           for (r = 0; r < 8; r += 2, prow++)
           {
             val = (*prow << 2) + ((c >> r) & 3);
             if (raw_width == 2672 && val < 512)
               val += 2;
             *prow = val;
           }
         }
         fseek(ifp, save, SEEK_SET);
       }
     }
   }
   catch (...)
   {
     FORC(2) free(huff[c]);
     throw;
   }
   FORC(2) free(huff[c]);
 }
@@ -799,58 +800,58 @@ void LibRaw::pentax_load_raw()
   fseek(ifp, meta_offset, SEEK_SET);
   dep = (get2() + 12) & 15;
   fseek(ifp, 12, SEEK_CUR);
   FORC(dep) bit[0][c] = get2();
   FORC(dep) bit[1][c] = fgetc(ifp);
   FORC(dep)
   for (i = bit[0][c]; i <= ((bit[0][c] + (4096 >> bit[1][c]) - 1) & 4095);)
     huff[++i] = bit[1][c] << 8 | c;
   huff[0] = 12;
   fseek(ifp, data_offset, SEEK_SET);
   getbits(-1);
   for (row = 0; row < raw_height; row++)
   {
     checkCancel();
     for (col = 0; col < raw_width; col++)
     {
       diff = ljpeg_diff(huff);
       if (col < 2)
         hpred[col] = vpred[row & 1][col] += diff;
       else
         hpred[col & 1] += diff;
       RAW(row, col) = hpred[col & 1];
       if (hpred[col & 1] >> tiff_bps)
         derror();
     }
   }
 }
 void LibRaw::nikon_read_curve()
 {
   ushort ver0, ver1, vpred[2][2], csize;
   int i, step, max;
 
   fseek(ifp, meta_offset, SEEK_SET);
   ver0 = fgetc(ifp);
   ver1 = fgetc(ifp);
   if (ver0 == 0x49 || ver1 == 0x58)
     fseek(ifp, 2110, SEEK_CUR);
   read_shorts(vpred[0], 4);
-  max = 1 << tiff_bps & 0x7fff;
+  step = max = 1 << tiff_bps & 0x7fff;
   if ((csize = get2()) > 1)
     step = max / (csize - 1);
   if (ver0 == 0x44 && (ver1 == 0x20 || (ver1 == 0x40 && step > 3)) && step > 0)
   {
     if (ver1 == 0x40)
     {
       step /= 4;
       max /= 4;
     }
     for (i = 0; i < csize; i++)
       curve[i * step] = get2();
     for (i = 0; i < max; i++)
       curve[i] = (curve[i - i % step] * (step - i % step) +
                   curve[i - i % step + step] * (i % step)) /
                  step;
   }
   else if (ver0 != 0x46 && csize <= 0x4001)
     read_shorts(curve, max = csize);
 }
@@ -940,28 +941,28 @@ void LibRaw::nikon_load_raw()
 void LibRaw::nikon_yuv_load_raw()
 {
   if (!image)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
-  int row, col, yuv[4], rgb[3], b, c;
+  int row, col, yuv[4]={0,0,0,0}, rgb[3], b, c;
   UINT64 bitbuf = 0;
   float cmul[4];
   FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }
   for (row = 0; row < raw_height; row++)
   {
     checkCancel();
 
     for (col = 0; col < raw_width; col++)
     {
       if (!(b = col & 1))
       {
         bitbuf = 0;
         FORC(6) bitbuf |= (UINT64)fgetc(ifp) << c * 8;
         FORC(4) yuv[c] = (bitbuf >> c * 12 & 0xfff) - (c >> 1 << 11);
       }
       rgb[0] = yuv[b] + 1.370705 * yuv[3];
       rgb[1] = yuv[b] - 0.337633 * yuv[2] - 0.698001 * yuv[3];
       rgb[2] = yuv[b] + 1.732446 * yuv[2];
       FORC3 image[row * width + col][c] =
           curve[LIM(rgb[c], 0, 0xfff)] / cmul[c];
     }
   }
 }
@@ -1116,81 +1117,82 @@ unsigned LibRaw::pana_data(int nb, unsigned *bytes)
 void LibRaw::panasonic_load_raw()
 {
   int row, col, i, j, sh = 0, pred[2], nonz[2];
   unsigned bytes[16];
+  memset(bytes,0,sizeof(bytes)); // make gcc11 happy
   ushort *raw_block_data;
 
   pana_data(0, 0);
 
   int enc_blck_size = pana_bpp == 12 ? 10 : 9;
   if (pana_encoding == 5)
   {
     for (row = 0; row < raw_height; row++)
     {
       raw_block_data = raw_image + row * raw_width;
       checkCancel();
       for (col = 0; col < raw_width; col += enc_blck_size)
       {
         pana_data(0, bytes);
 
         if (pana_bpp == 12)
         {
           raw_block_data[col] = ((bytes[1] & 0xF) << 8) + bytes[0];
           raw_block_data[col + 1] = 16 * bytes[2] + (bytes[1] >> 4);
           raw_block_data[col + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];
           raw_block_data[col + 3] = 16 * bytes[5] + (bytes[4] >> 4);
           raw_block_data[col + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];
           raw_block_data[col + 5] = 16 * bytes[8] + (bytes[7] >> 4);
           raw_block_data[col + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];
           raw_block_data[col + 7] = 16 * bytes[11] + (bytes[10] >> 4);
           raw_block_data[col + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];
           raw_block_data[col + 9] = 16 * bytes[14] + (bytes[13] >> 4);
         }
         else if (pana_bpp == 14)
         {
           raw_block_data[col] = bytes[0] + ((bytes[1] & 0x3F) << 8);
           raw_block_data[col + 1] =
               (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);
           raw_block_data[col + 2] =
               (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);
           raw_block_data[col + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);
           raw_block_data[col + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);
           raw_block_data[col + 5] =
               (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);
           raw_block_data[col + 6] =
               (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
           raw_block_data[col + 7] =
               ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);
           raw_block_data[col + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);
         }
       }
     }
   }
   else
   {
     for (row = 0; row < raw_height; row++)
     {
       checkCancel();
       for (col = 0; col < raw_width; col++)
       {
         if ((i = col % 14) == 0)
           pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
         if (i % 3 == 2)
           sh = 4 >> (3 - pana_data(2, 0));
         if (nonz[i & 1])
         {
           if ((j = pana_data(8, 0)))
           {
             if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
               pred[i & 1] &= ~((~0u) << sh);
             pred[i & 1] += j << sh;
           }
         }
         else if ((nonz[i & 1] = pana_data(8, 0)) || i > 11)
           pred[i & 1] = nonz[i & 1] << 4 | pana_data(4, 0);
         if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width &&
             row < height)
           derror();
       }
     }
   }
 }
@@ -1569,53 +1571,53 @@ void LibRaw::sony_arw2_load_raw()
 void LibRaw::samsung_load_raw()
 {
   int row, col, c, i, dir, op[4], len[4];
   if (raw_width > 32768 ||
       raw_height > 32768) // definitely too much for old samsung
     throw LIBRAW_EXCEPTION_IO_BADFILE;
   unsigned maxpixels = raw_width * (raw_height + 7);
 
   order = 0x4949;
   for (row = 0; row < raw_height; row++)
   {
     checkCancel();
     fseek(ifp, strip_offset + row * 4, SEEK_SET);
     fseek(ifp, data_offset + get4(), SEEK_SET);
     ph1_bits(-1);
     FORC4 len[c] = row < 2 ? 7 : 4;
     for (col = 0; col < raw_width; col += 16)
     {
       dir = ph1_bits(1);
       FORC4 op[c] = ph1_bits(2);
       FORC4 switch (op[c])
       {
       case 3:
         len[c] = ph1_bits(4);
         break;
       case 2:
         len[c]--;
         break;
       case 1:
         len[c]++;
       }
       for (c = 0; c < 16; c += 2)
       {
         i = len[((c & 1) << 1) | (c >> 3)];
         unsigned idest = RAWINDEX(row, col + c);
         unsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c)
                              : col ? RAWINDEX(row, col + (c | -2)) : 0);
         if (idest < maxpixels &&
             isrc <
                 maxpixels) // less than zero is handled by unsigned conversion
-          RAW(row, col + c) = (i > 0 ? ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) : 0) + 			                
+          RAW(row, col + c) = (i > 0 ? ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) : 0) +
             (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);
         else
           derror();
         if (c == 14)
           c = -1;
       }
     }
   }
   for (row = 0; row < raw_height - 1; row += 2)
     for (col = 0; col < raw_width - 1; col += 2)
       SWAP(RAW(row, col + 1), RAW(row + 1, col));
 }
diff --git a/src/decoders/decoders_libraw.cpp b/src/decoders/decoders_libraw.cpp
index f7c473f0..701b19b5 100644
--- a/src/decoders/decoders_libraw.cpp
+++ b/src/decoders/decoders_libraw.cpp
@@ -313,112 +313,163 @@ void LibRaw::nikon_load_striped_packed_raw()
 
 struct pana_cs6_page_decoder
 {
-  unsigned int pixelbuffer[14], lastoffset, maxoffset;
+  unsigned int pixelbuffer[18], lastoffset, maxoffset;
   unsigned char current, *buffer;
   pana_cs6_page_decoder(unsigned char *_buffer, unsigned int bsize)
       : lastoffset(0), maxoffset(bsize), current(0), buffer(_buffer)
   {
   }
   void read_page(); // will throw IO error if not enough space in buffer
+  void read_page12(); // 12-bit variant
   unsigned int nextpixel() { return current < 14 ? pixelbuffer[current++] : 0; }
+  unsigned int nextpixel12() { return current < 18 ? pixelbuffer[current++] : 0; }
 };
 
 void pana_cs6_page_decoder::read_page()
 {
   if (!buffer || (maxoffset - lastoffset < 16))
     throw LIBRAW_EXCEPTION_IO_EOF;
 #define wbuffer(i) ((unsigned short)buffer[lastoffset + 15 - i])
-  pixelbuffer[0] = (wbuffer(0) << 6) | (wbuffer(1) >> 2); // 14 bit
-  pixelbuffer[1] =
-      (((wbuffer(1) & 0x3) << 12) | (wbuffer(2) << 4) | (wbuffer(3) >> 4)) &
-      0x3fff;
-  pixelbuffer[2] = (wbuffer(3) >> 2) & 0x3;
-  pixelbuffer[3] = ((wbuffer(3) & 0x3) << 8) | wbuffer(4);
-  pixelbuffer[4] = (wbuffer(5) << 2) | (wbuffer(6) >> 6);
-  pixelbuffer[5] = ((wbuffer(6) & 0x3f) << 4) | (wbuffer(7) >> 4);
+  pixelbuffer[0] = (wbuffer(0) << 6) | (wbuffer(1) >> 2);                                         // 14 bit
+  pixelbuffer[1] = (((wbuffer(1) & 0x3) << 12) | (wbuffer(2) << 4) | (wbuffer(3) >> 4)) & 0x3fff; // 14 bit
+  pixelbuffer[2] = (wbuffer(3) >> 2) & 0x3;                                                       // 2
+  pixelbuffer[3] = ((wbuffer(3) & 0x3) << 8) | wbuffer(4);                                        // 10
+  pixelbuffer[4] = (wbuffer(5) << 2) | (wbuffer(6) >> 6);                                         // 10
+  pixelbuffer[5] = ((wbuffer(6) & 0x3f) << 4) | (wbuffer(7) >> 4);                                // 10
   pixelbuffer[6] = (wbuffer(7) >> 2) & 0x3;
   pixelbuffer[7] = ((wbuffer(7) & 0x3) << 8) | wbuffer(8);
   pixelbuffer[8] = ((wbuffer(9) << 2) & 0x3fc) | (wbuffer(10) >> 6);
   pixelbuffer[9] = ((wbuffer(10) << 4) | (wbuffer(11) >> 4)) & 0x3ff;
   pixelbuffer[10] = (wbuffer(11) >> 2) & 0x3;
   pixelbuffer[11] = ((wbuffer(11) & 0x3) << 8) | wbuffer(12);
   pixelbuffer[12] = (((wbuffer(13) << 2) & 0x3fc) | wbuffer(14) >> 6) & 0x3ff;
   pixelbuffer[13] = ((wbuffer(14) << 4) | (wbuffer(15) >> 4)) & 0x3ff;
 #undef wbuffer
   current = 0;
   lastoffset += 16;
 }
 
+void pana_cs6_page_decoder::read_page12()
+{
+  if (!buffer || (maxoffset - lastoffset < 16))
+    throw LIBRAW_EXCEPTION_IO_EOF;
+#define wb(i) ((unsigned short)buffer[lastoffset + 15 - i])
+  pixelbuffer[0] = (wb(0) << 4) | (wb(1) >> 4);              // 12 bit: 8/0 + 4 upper bits of /1
+  pixelbuffer[1] = (((wb(1) & 0xf) << 8) | (wb(2))) & 0xfff; // 12 bit: 4l/1 + 8/2
+  
+  pixelbuffer[2] = (wb(3) >> 6) & 0x3;                       // 2; 2u/3, 6 low bits remains in wb(3) 
+  pixelbuffer[3] = ((wb(3) & 0x3f) << 2) | (wb(4) >> 6);     // 8; 6l/3 + 2u/4; 6 low bits remains in wb(4)
+  pixelbuffer[4] = ((wb(4) & 0x3f) << 2) | (wb(5) >> 6);     // 8: 6l/4 + 2u/5; 6 low bits remains in wb(5)
+  pixelbuffer[5] = ((wb(5) & 0x3f) << 2) | (wb(6) >> 6);     // 8: 6l/5 + 2u/6, 6 low bits remains in wb(6)
+
+  pixelbuffer[6] = (wb(6) >> 4) & 0x3;                       // 2, 4 low bits remains in wb(6)
+  pixelbuffer[7] = ((wb(6) & 0xf) << 4) | (wb(7) >> 4);      // 8: 4 low bits from wb(6), 4 upper bits from wb(7)
+  pixelbuffer[8] = ((wb(7) & 0xf) << 4) | (wb(8) >> 4);      // 8: 4 low bits from wb7, 4 upper bits from wb8
+  pixelbuffer[9] = ((wb(8) & 0xf) << 4) | (wb(9) >> 4);      // 8: 4 low bits from wb8, 4 upper bits from wb9
+
+  pixelbuffer[10] = (wb(9) >> 2) & 0x3;                      // 2: bits 2-3 from wb9, two low bits remain in wb9
+  pixelbuffer[11] = ((wb(9) & 0x3) << 6) | (wb(10) >> 2);    // 8: 2 bits from wb9, 6 bits from wb10
+  pixelbuffer[12] = ((wb(10) & 0x3) << 6) | (wb(11) >> 2);   // 8: 2 bits from wb10, 6 bits from wb11
+  pixelbuffer[13] = ((wb(11) & 0x3) << 6) | (wb(12) >> 2);   // 8: 2 bits from wb11, 6 bits from wb12
+
+  pixelbuffer[14] = wb(12) & 0x3;                            // 2: low bits from wb12
+  pixelbuffer[15] = wb(13);
+  pixelbuffer[16] = wb(14);
+  pixelbuffer[17] = wb(15);
+#undef wb
+  current = 0;
+  lastoffset += 16;
+}
+
+
+
 void LibRaw::panasonicC6_load_raw()
 {
   const int rowstep = 16;
-  const int blocksperrow = imgdata.sizes.raw_width / 11;
+  const bool _12bit = libraw_internal_data.unpacker_data.pana_bpp == 12;
+  const int pixperblock =  _12bit ? 14 : 11;
+  const int blocksperrow = imgdata.sizes.raw_width / pixperblock;
   const int rowbytes = blocksperrow * 16;
-  unsigned char *iobuf = (unsigned char *)malloc(rowbytes * rowstep);
-  merror(iobuf, "panasonicC6_load_raw()");
+  const unsigned pixelbase0 = _12bit ? 0x80 : 0x200;
+  const unsigned pixelbase_compare = _12bit ? 0x800 : 0x2000;
+  const unsigned spix_compare = _12bit ? 0x3fff : 0xffff;
+  const unsigned pixel_mask = _12bit ? 0xfff : 0x3fff;
+  std::vector<unsigned char> iobuf;
+  try
+  {
+      iobuf.resize(rowbytes * rowstep);
+  }
+  catch (...)
+  {
+    merror(NULL, "panasonicC6_load_raw()");
+    throw LIBRAW_EXCEPTION_ALLOC;
+  }
 
   for (int row = 0; row < imgdata.sizes.raw_height - rowstep + 1;
        row += rowstep)
   {
     int rowstoread = MIN(rowstep, imgdata.sizes.raw_height - row);
     if (libraw_internal_data.internal_data.input->read(
-            iobuf, rowbytes, rowstoread) != rowstoread)
+            iobuf.data(), rowbytes, rowstoread) != rowstoread)
       throw LIBRAW_EXCEPTION_IO_EOF;
-    pana_cs6_page_decoder page(iobuf, rowbytes * rowstoread);
+    pana_cs6_page_decoder page(iobuf.data(), rowbytes * rowstoread);
     for (int crow = 0, col = 0; crow < rowstoread; crow++, col = 0)
     {
       unsigned short *rowptr =
           &imgdata.rawdata
                .raw_image[(row + crow) * imgdata.sizes.raw_pitch / 2];
       for (int rblock = 0; rblock < blocksperrow; rblock++)
       {
-        page.read_page();
+          if (_12bit)
+              page.read_page12();
+          else
+              page.read_page();
         unsigned oddeven[2] = {0, 0}, nonzero[2] = {0, 0};
         unsigned pmul = 0, pixel_base = 0;
-        for (int pix = 0; pix < 11; pix++)
+        for (int pix = 0; pix < pixperblock; pix++)
         {
           if (pix % 3 == 2)
           {
-            unsigned base = page.nextpixel();
+            unsigned base = _12bit ? page.nextpixel12(): page.nextpixel();
             if (base > 3)
               throw LIBRAW_EXCEPTION_IO_CORRUPT; // not possible b/c of 2-bit
                                                  // field, but....
             if (base == 3)
               base = 4;
-            pixel_base = 0x200 << base;
+            pixel_base = pixelbase0 << base;
             pmul = 1 << base;
           }
-          unsigned epixel = page.nextpixel();
+          unsigned epixel = _12bit ? page.nextpixel12() : page.nextpixel();
           if (oddeven[pix % 2])
           {
             epixel *= pmul;
-            if (pixel_base < 0x2000 && nonzero[pix % 2] > pixel_base)
+            if (pixel_base < pixelbase_compare && nonzero[pix % 2] > pixel_base)
               epixel += nonzero[pix % 2] - pixel_base;
             nonzero[pix % 2] = epixel;
           }
           else
           {
             oddeven[pix % 2] = epixel;
             if (epixel)
               nonzero[pix % 2] = epixel;
             else
               epixel = nonzero[pix % 2];
           }
           unsigned spix = epixel - 0xf;
-          if (spix <= 0xffff)
-            rowptr[col++] = spix & 0xffff;
+          if (spix <= spix_compare)
+            rowptr[col++] = spix & spix_compare;
           else
           {
             epixel = (((signed int)(epixel + 0x7ffffff1)) >> 0x1f);
-            rowptr[col++] = epixel & 0x3fff;
+            rowptr[col++] = epixel & pixel_mask;
           }
         }
       }
     }
   }
-  free(iobuf);
 }
 
+
 void LibRaw::panasonicC7_load_raw()
 {
   const int rowstep = 16;
@@ -481,18 +532,18 @@ void LibRaw::panasonicC7_load_raw()
 void LibRaw::unpacked_load_raw_fuji_f700s20()
 {
   int base_offset = 0;
   int row_size = imgdata.sizes.raw_width * 2; // in bytes
-  if (imgdata.idata.raw_count == 2 && imgdata.params.shot_select)
+  if (imgdata.idata.raw_count == 2 && imgdata.rawparams.shot_select)
   {
     libraw_internal_data.internal_data.input->seek(-row_size, SEEK_CUR);
     base_offset = row_size; // in bytes
   }
   unsigned char *buffer = (unsigned char *)malloc(row_size * 2);
   for (int row = 0; row < imgdata.sizes.raw_height; row++)
   {
     read_shorts((ushort *)buffer, imgdata.sizes.raw_width * 2);
     memmove(&imgdata.rawdata.raw_image[row * imgdata.sizes.raw_pitch / 2],
             buffer + base_offset, row_size);
   }
   free(buffer);
 }
diff --git a/src/decoders/decoders_libraw_dcrdefs.cpp b/src/decoders/decoders_libraw_dcrdefs.cpp
index 78f16068..d36c0e3c 100644
--- a/src/decoders/decoders_libraw_dcrdefs.cpp
+++ b/src/decoders/decoders_libraw_dcrdefs.cpp
@@ -14,6 +14,48 @@
 
 #include "../../internal/dcraw_defs.h"
 
+void LibRaw::sony_ljpeg_load_raw()
+{
+  unsigned trow = 0, tcol = 0, jrow, jcol, row, col;
+  INT64 save;
+  struct jhead jh;
+
+  while (trow < raw_height)
+  {
+    checkCancel();
+    save = ftell(ifp); // We're at
+    if (tile_length < INT_MAX)
+      fseek(ifp, get4(), SEEK_SET);
+    if (!ljpeg_start(&jh, 0))
+      break;
+    try
+    {
+      for (row = jrow = 0; jrow < (unsigned)jh.high; jrow++, row += 2)
+      {
+        checkCancel();
+        ushort(*rowp)[4] = (ushort(*)[4])ljpeg_row(jrow, &jh);
+        for (col = jcol = 0; jcol < (unsigned)jh.wide; jcol++, col += 2)
+        {
+          RAW(trow + row, tcol + col) = rowp[jcol][0];
+          RAW(trow + row, tcol + col + 1) = rowp[jcol][1];
+          RAW(trow + row + 1, tcol + col) = rowp[jcol][2];
+          RAW(trow + row + 1, tcol + col + 1) = rowp[jcol][3];
+        }
+      }
+    }
+    catch (...)
+    {
+      ljpeg_end(&jh);
+      throw;
+    }
+    fseek(ifp, save + 4, SEEK_SET);
+    if ((tcol += tile_width) >= raw_width)
+      trow += tile_length + (tcol = 0);
+    ljpeg_end(&jh);
+  }
+}
+
+
 void LibRaw::nikon_coolscan_load_raw()
 {
   if (!image)
diff --git a/src/decoders/dng.cpp b/src/decoders/dng.cpp
index 7ecbf399..4393ada9 100644
--- a/src/decoders/dng.cpp
+++ b/src/decoders/dng.cpp
@@ -31,98 +31,99 @@ void LibRaw::adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)
   if (tiff_samples == 2 && shot_select)
     (*rp)++;
   if (raw_image)
   {
     if (row < raw_height && col < raw_width)
       RAW(row, col) = curve[**rp];
     *rp += tiff_samples;
   }
   else
   {
     if (row < raw_height && col < raw_width)
       FORC(int(tiff_samples))
     image[row * raw_width + col][c] = curve[(*rp)[c]];
     *rp += tiff_samples;
   }
   if (tiff_samples == 2 && shot_select)
     (*rp)--;
 }
 void LibRaw::lossless_dng_load_raw()
 {
-  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;
+  unsigned trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;
+  INT64 save;
   struct jhead jh;
   ushort *rp;
 
   int ss = shot_select;
   shot_select = libraw_internal_data.unpacker_data.dng_frames[LIM(ss,0,(LIBRAW_IFD_MAXCOUNT*2-1))] & 0xff;
 
   while (trow < raw_height)
   {
     checkCancel();
     save = ftell(ifp);
     if (tile_length < INT_MAX)
       fseek(ifp, get4(), SEEK_SET);
     if (!ljpeg_start(&jh, 0))
       break;
     jwide = jh.wide;
     if (filters)
       jwide *= jh.clrs;
 
     if(filters && (tiff_samples == 2)) // Fuji Super CCD
         jwide /= 2;
     try
     {
       switch (jh.algo)
       {
       case 0xc1:
         jh.vpred[0] = 16384;
         getbits(-1);
         for (jrow = 0; jrow + 7 < (unsigned)jh.high; jrow += 8)
         {
           checkCancel();
           for (jcol = 0; jcol + 7 < (unsigned)jh.wide; jcol += 8)
           {
             ljpeg_idct(&jh);
             rp = jh.idct;
             row = trow + jcol / tile_width + jrow * 2;
             col = tcol + jcol % tile_width;
             for (i = 0; i < 16; i += 2)
               for (j = 0; j < 8; j++)
                 adobe_copy_pixel(row + i, col + j, &rp);
           }
         }
         break;
       case 0xc3:
         for (row = col = jrow = 0; jrow < (unsigned)jh.high; jrow++)
         {
           checkCancel();
           rp = ljpeg_row(jrow, &jh);
           if (tiff_samples == 1 && jh.clrs > 1 && jh.clrs * jwide == raw_width)
             for (jcol = 0; jcol < jwide * jh.clrs; jcol++)
             {
               adobe_copy_pixel(trow + row, tcol + col, &rp);
               if (++col >= tile_width || col >= raw_width)
                 row += 1 + (col = 0);
             }
           else
             for (jcol = 0; jcol < jwide; jcol++)
             {
               adobe_copy_pixel(trow + row, tcol + col, &rp);
               if (++col >= tile_width || col >= raw_width)
                 row += 1 + (col = 0);
             }
         }
       }
     }
     catch (...)
     {
       ljpeg_end(&jh);
       shot_select = ss;
       throw;
     }
     fseek(ifp, save + 4, SEEK_SET);
     if ((tcol += tile_width) >= raw_width)
       trow += tile_length + (tcol = 0);
     ljpeg_end(&jh);
   }
   shot_select = ss;
 }
@@ -175,97 +176,98 @@ static void jpegErrorExit_d(j_common_ptr cinfo)
 void LibRaw::lossy_dng_load_raw()
 {
   if (!image)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
   struct jpeg_decompress_struct cinfo;
   JSAMPARRAY buf;
   JSAMPLE(*pixel)[3];
   unsigned sorder = order, ntags, opcode, deg, i, j, c;
-  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;
+  unsigned trow = 0, tcol = 0, row, col;
+  INT64 save = data_offset - 4;
   ushort cur[3][256];
   double coeff[9], tot;
 
   if (meta_offset)
   {
     fseek(ifp, meta_offset, SEEK_SET);
     order = 0x4d4d;
     ntags = get4();
     while (ntags--)
     {
       opcode = get4();
       get4();
       get4();
       if (opcode != 8)
       {
         fseek(ifp, get4(), SEEK_CUR);
         continue;
       }
       fseek(ifp, 20, SEEK_CUR);
       if ((c = get4()) > 2)
         break;
       fseek(ifp, 12, SEEK_CUR);
       if ((deg = get4()) > 8)
         break;
       for (i = 0; i <= deg && i < 9; i++)
         coeff[i] = getreal(LIBRAW_EXIFTAG_TYPE_DOUBLE);
       for (i = 0; i < 256; i++)
       {
         for (tot = j = 0; j <= deg; j++)
           tot += coeff[j] * pow(i / 255.0, (int)j);
-        cur[c][i] = tot * 0xffff;
+        cur[c][i] = (ushort)(tot * 0xffff);
       }
     }
     order = sorder;
   }
   else
   {
     gamma_curve(1 / 2.4, 12.92, 1, 255);
     FORC3 memcpy(cur[c], curve, sizeof cur[0]);
   }
 
   struct jpeg_error_mgr pub;
   cinfo.err = jpeg_std_error(&pub);
   pub.error_exit = jpegErrorExit_d;
 
   jpeg_create_decompress(&cinfo);
 
   while (trow < raw_height)
   {
     fseek(ifp, save += 4, SEEK_SET);
     if (tile_length < INT_MAX)
       fseek(ifp, get4(), SEEK_SET);
     if (libraw_internal_data.internal_data.input->jpeg_src(&cinfo) == -1)
     {
       jpeg_destroy_decompress(&cinfo);
       throw LIBRAW_EXCEPTION_DECODE_JPEG;
     }
     jpeg_read_header(&cinfo, TRUE);
     jpeg_start_decompress(&cinfo);
     buf = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE,
                                      cinfo.output_width * 3, 1);
     try
     {
       while (cinfo.output_scanline < cinfo.output_height &&
              (row = trow + cinfo.output_scanline) < height)
       {
         checkCancel();
         jpeg_read_scanlines(&cinfo, buf, 1);
         pixel = (JSAMPLE(*)[3])buf[0];
         for (col = 0; col < cinfo.output_width && tcol + col < width; col++)
         {
           FORC3 image[row * width + tcol + col][c] = cur[c][pixel[col][c]];
         }
       }
     }
     catch (...)
     {
       jpeg_destroy_decompress(&cinfo);
       throw;
     }
     jpeg_abort_decompress(&cinfo);
     if ((tcol += tile_width) >= raw_width)
       trow += tile_length + (tcol = 0);
   }
   jpeg_destroy_decompress(&cinfo);
   maximum = 0xffff;
 }
 #endif
diff --git a/src/decoders/fp_dng.cpp b/src/decoders/fp_dng.cpp
index b5534282..dd34565a 100644
--- a/src/decoders/fp_dng.cpp
+++ b/src/decoders/fp_dng.cpp
@@ -96,64 +96,64 @@ inline unsigned int __DNG_FP24ToFloat(const unsigned char *input)
 inline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)
 {
   if (channels == 1)
   {
     unsigned char b0 = bytePtr[0];
     bytePtr += 1;
-    for (uint32_t col = 1; col < cols; ++col)
+    for (int col = 1; col < cols; ++col)
     {
       b0 += bytePtr[0];
       bytePtr[0] = b0;
       bytePtr += 1;
     }
   }
   else if (channels == 3)
   {
     unsigned char b0 = bytePtr[0];
     unsigned char b1 = bytePtr[1];
     unsigned char b2 = bytePtr[2];
     bytePtr += 3;
     for (int col = 1; col < cols; ++col)
     {
       b0 += bytePtr[0];
       b1 += bytePtr[1];
       b2 += bytePtr[2];
       bytePtr[0] = b0;
       bytePtr[1] = b1;
       bytePtr[2] = b2;
       bytePtr += 3;
     }
   }
   else if (channels == 4)
   {
     unsigned char b0 = bytePtr[0];
     unsigned char b1 = bytePtr[1];
     unsigned char b2 = bytePtr[2];
     unsigned char b3 = bytePtr[3];
     bytePtr += 4;
-    for (uint32_t col = 1; col < cols; ++col)
+    for (int col = 1; col < cols; ++col)
     {
       b0 += bytePtr[0];
       b1 += bytePtr[1];
       b2 += bytePtr[2];
       b3 += bytePtr[3];
       bytePtr[0] = b0;
       bytePtr[1] = b1;
       bytePtr[2] = b2;
       bytePtr[3] = b3;
       bytePtr += 4;
     }
   }
   else
   {
     for (int col = 1; col < cols; ++col)
     {
       for (int chan = 0; chan < channels; ++chan)
       {
         bytePtr[chan + channels] += bytePtr[chan];
       }
       bytePtr += channels;
     }
   }
 }
 
 #ifdef USE_ZLIB
@@ -278,51 +278,51 @@ static unsigned static_get4(LibRaw_abstract_datastream *stream, short _order)
 void tile_stripe_data_t::init(tiff_ifd_t *ifd, const libraw_image_sizes_t& sizes, 
     const unpacker_data_t& unpacker_data, short _order, LibRaw_abstract_datastream *stream)
 {
     tiled = (unpacker_data.tile_width <= sizes.raw_width) && (unpacker_data.tile_length <= sizes.raw_height);
     striped = (ifd->rows_per_strip > 0 && ifd->rows_per_strip < sizes.raw_height) && ifd->strip_byte_counts_count > 0;
 
     tileWidth = tiled ? unpacker_data.tile_width : sizes.raw_width;
     tileHeight = tiled ? unpacker_data.tile_length :(striped ? ifd->rows_per_strip : sizes.raw_height);
     tilesH = tiled ? (sizes.raw_width + tileWidth - 1) / tileWidth : 1;
     tilesV = tiled ? (sizes.raw_height + tileHeight - 1) / tileHeight :
         (striped ? ((sizes.raw_height + ifd->rows_per_strip - 1) / ifd->rows_per_strip) : 1);
     tileCnt = tilesH * tilesV;
 
     if (tileCnt < 1 || tileCnt > 1000000)
         throw LIBRAW_EXCEPTION_DECODE_RAW;
 
     tOffsets = std::vector<size_t>(tileCnt);
     tBytes = std::vector <size_t>(tileCnt);
 
     if (tiled)
         for (int t = 0; t < tileCnt; ++t)
             tOffsets[t] = static_get4(stream, _order);
     else if (striped)
         for (int t = 0; t < tileCnt && t < ifd->strip_offsets_count; ++t)
             tOffsets[t] = ifd->strip_offsets[t];
     else
         tOffsets[0] = ifd->offset;
 
     maxBytesInTile = 0;
 
     if (tileCnt == 1 || (!tiled && !striped))
         tBytes[0] = maxBytesInTile = ifd->bytes;
     else if (tiled)
     {
         // ifd->bytes points to tile size table if more than 1 tile exists
         stream->seek(ifd->bytes, SEEK_SET);
-        for (size_t t = 0; t < tileCnt; ++t)
+        for (int t = 0; t < tileCnt; ++t)
         {
             tBytes[t] = static_get4(stream, _order); ;
             maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);
         }
     }
     else if (striped)
-        for (size_t t = 0; t < tileCnt && t < ifd->strip_byte_counts_count; ++t)
+        for (int t = 0; t < tileCnt && t < ifd->strip_byte_counts_count; ++t)
         {
             tBytes[t] = ifd->strip_byte_counts[t];
             maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);
         }
 }
 
 #ifdef USE_ZLIB
@@ -587,97 +587,96 @@ void swap32(uchar *data, int len)
 void LibRaw::uncompressed_fp_dng_load_raw()
 {
     int iifd = find_ifd_by_offset(libraw_internal_data.unpacker_data.data_offset);
-    if (iifd < 0 || iifd > libraw_internal_data.identify_data.tiff_nifds)
+    if (iifd < 0 || iifd > (int)libraw_internal_data.identify_data.tiff_nifds)
         throw LIBRAW_EXCEPTION_DECODE_RAW;
     struct tiff_ifd_t *ifd = &tiff_ifd[iifd];
 
     float *float_raw_image = 0;
 
     if (ifd->samples != 1 && ifd->samples != 3 && ifd->samples != 4)
         throw LIBRAW_EXCEPTION_DECODE_RAW; 
 
     if(imgdata.idata.filters && ifd->samples > 1)
       throw LIBRAW_EXCEPTION_DECODE_RAW;
 
     if ((int)libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)
         throw LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD
 
     int bytesps = (ifd->bps + 7) >> 3; // round to upper value
 
     tile_stripe_data_t tiles;
     tiles.init(ifd, imgdata.sizes, libraw_internal_data.unpacker_data, libraw_internal_data.unpacker_data.order,
         libraw_internal_data.internal_data.input);
 
     if (ifd->sample_format == 3)
         float_raw_image = (float *)calloc(tiles.tileCnt * tiles.tileWidth * tiles.tileHeight *ifd->samples, sizeof(float));
     else
         throw LIBRAW_EXCEPTION_DECODE_RAW; // Only float supported
 
     bool difford = (libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234);
     float max = 0.f;
 
     std::vector<uchar> rowbuf(tiles.tileWidth *sizeof(float) * ifd->samples); // line buffer for last tile in tile row
 
     for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += tiles.tileHeight)
     {
-        for (size_t x = 0; x < imgdata.sizes.raw_width  && t < tiles.tileCnt; x += tiles.tileWidth, ++t)
+        for (unsigned x = 0; x < imgdata.sizes.raw_width  && t < (unsigned)tiles.tileCnt; x += tiles.tileWidth, ++t)
         {
             libraw_internal_data.internal_data.input->seek(tiles.tOffsets[t], SEEK_SET);
             size_t rowsInTile = y + tiles.tileHeight > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : tiles.tileHeight;
             size_t colsInTile = x + tiles.tileWidth > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : tiles.tileWidth;
 
             int inrowbytes = colsInTile * bytesps * ifd->samples;
             int fullrowbytes = tiles.tileWidth *bytesps * ifd->samples;
             int outrowbytes = colsInTile * sizeof(float) * ifd->samples;
-            std::vector<uchar> vec(fullrowbytes > inrowbytes ? fullrowbytes : 0);
 
             for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed
             {
                 unsigned char *dst = fullrowbytes > inrowbytes ? rowbuf.data(): // last tile in row, use buffer
                     (unsigned char *)&float_raw_image
                     [((y + row) * imgdata.sizes.raw_width + x) * ifd->samples];
                 libraw_internal_data.internal_data.input->read(dst, 1, fullrowbytes);
                 if (bytesps == 2 && difford)
                     swab((char *)dst, (char *)dst, fullrowbytes);
                 else if (bytesps == 3 && (libraw_internal_data.unpacker_data.order == 0x4949)) // II-16bit
                     swap24(dst, fullrowbytes);
                 if (bytesps == 4 && difford)
                     swap32(dst, fullrowbytes);
 
                 float lmax = expandFloats(
                     dst,
                     tiles.tileWidth * ifd->samples,
                     bytesps);
                 if (fullrowbytes > inrowbytes) // last tile in row: copy buffer to destination
                     memmove(&float_raw_image[((y + row) * imgdata.sizes.raw_width + x) * ifd->samples], dst, outrowbytes);
                 max = MAX(max, lmax);
             }
         }
     }
 
     imgdata.color.fmaximum = max;
 
     // setup outpuf fields
     imgdata.rawdata.raw_alloc = float_raw_image;
     if (ifd->samples == 1)
     {
         imgdata.rawdata.float_image = float_raw_image;
         imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =
             imgdata.sizes.raw_width * 4;
     }
     else if (ifd->samples == 3)
     {
         imgdata.rawdata.float3_image = (float(*)[3])float_raw_image;
         imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =
             imgdata.sizes.raw_width * 12;
     }
     else if (ifd->samples == 4)
     {
         imgdata.rawdata.float4_image = (float(*)[4])float_raw_image;
         imgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch =
             imgdata.sizes.raw_width * 16;
     }
 
     if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT)
         convertFloatToInt();  
 }
diff --git a/src/decoders/load_mfbacks.cpp b/src/decoders/load_mfbacks.cpp
index e621f06b..0c11eaf6 100644
--- a/src/decoders/load_mfbacks.cpp
+++ b/src/decoders/load_mfbacks.cpp
@@ -18,11 +18,122 @@
 
 #include "../../internal/dcraw_defs.h"
 
+inline uint32_t abs32(int32_t x)
+{
+  // Branchless version.
+  uint32_t sm = x >> 31;
+  return (uint32_t) ((x + sm) ^ sm);
+}
+
+inline uint32_t min32(uint32_t x, uint32_t y)
+{
+  return x < y ? x : y;
+}
+
+inline uint32_t max32(uint32_t x, uint32_t y)
+{
+  return x > y ? x : y;
+}
+
+inline uint32_t constain32(uint32_t x, uint32_t l, uint32_t u)
+{
+  return x < l ? l : (x > u ? u : x);
+}
+
+int unsigned_cmp(const void *a, const void *b)
+{
+  if (!a || !b)
+    return 0;
+
+  return *(unsigned *)a > *(unsigned *)b ? 1 : (*(unsigned *)a < *(unsigned *)b ? -1 : 0);
+}
+
+int LibRaw::p1rawc(unsigned row, unsigned col, unsigned& count)
+{
+  return (row < raw_height && col < raw_width) ? (++count, RAW(row, col)) : 0;
+}
+
 int LibRaw::p1raw(unsigned row, unsigned col)
 {
   return (row < raw_height && col < raw_width) ? RAW(row, col) : 0;
 }
 
+
+// DNG SDK version of fixing pixels in bad column using averages sets
+// corrected not to use pixels in the same column
+void LibRaw::phase_one_fix_col_pixel_avg(unsigned row, unsigned col)
+{
+  static const int8_t dir[3][8][2] = {
+  { {-2,-2}, {-2, 2}, {2,-2}, {2, 2}, { 0, 0}, { 0, 0}, {0, 0}, {0, 0} },
+  { {-2,-4}, {-4,-2}, {2,-4}, {4,-2}, {-2, 4}, {-4, 2}, {2, 4}, {4, 2} },
+  { {-4,-4}, {-4, 4}, {4,-4}, {4, 4}, { 0, 0}, { 0, 0}, {0, 0}, {0, 0} } };
+
+  for (int set=0; set < 3; ++set)
+  {
+    uint32_t total = 0;
+    uint32_t count = 0;
+    for (int i = 0; i < 8; ++i)
+    {
+      if (!dir[set][i][0] && !dir[set][i][1])
+        break;
+
+      total += p1rawc(row+dir[set][i][0], col+dir[set][i][1], count);
+    }
+
+    if (count)
+    {
+      RAW(row,col) = (uint16_t)((total + (count >> 1)) / count);
+      break;
+    }
+  }
+}
+
+// DNG SDK version of fixing pixels in bad column using gradient prediction
+void LibRaw::phase_one_fix_pixel_grad(unsigned row, unsigned col)
+{
+  static const int8_t grad_sets[7][12][2] = {
+    { {-4,-2}, { 4, 2}, {-3,-1}, { 1, 1}, {-1,-1}, { 3, 1}, 
+      {-4,-1}, { 0, 1}, {-2,-1}, { 2, 1}, { 0,-1}, { 4, 1} },
+    { {-2,-2}, { 2, 2}, {-3,-1}, {-1, 1}, {-1,-1}, { 1, 1}, 
+      { 1,-1}, { 3, 1}, {-2,-1}, { 0, 1}, { 0,-1}, { 2, 1} },
+    { {-2,-4}, { 2, 4}, {-1,-3}, { 1, 1}, {-1,-1}, { 1, 3}, 
+      {-2,-1}, { 0, 3}, {-1,-2}, { 1, 2}, { 0,-3}, { 2, 1} },
+    { { 0,-2}, { 0, 2}, {-1,-1}, {-1, 1}, { 1,-1}, { 1, 1}, 
+      {-1,-2}, {-1, 2}, { 0,-1}, { 0,-1}, { 1,-2}, { 1, 2} },
+    { {-2, 4}, { 2,-4}, {-1, 3}, { 1,-1}, {-1, 1}, { 1,-3}, 
+      {-2, 1}, { 0,-3}, {-1, 2}, { 1,-2}, { 0, 3}, { 2,-1} },
+    { {-2, 2}, { 2,-2}, {-3, 1}, {-1,-1}, {-1, 1}, { 1,-1}, 
+      { 1, 1}, { 3,-1}, {-2, 1}, { 0,-1}, { 0, 1}, { 2,-1} },
+    { {-4, 2}, { 4,-2}, {-3, 1}, { 1,-1}, {-1, 1}, { 3,-1}, 
+      {-4, 1}, { 0,-1}, {-2, 1}, { 2,-1}, { 0, 1}, { 4,-1} } };
+
+  uint32_t est[7], grad[7];
+  uint32_t lower = min32(p1raw(row,col-2), p1raw(row, col+2));
+  uint32_t upper = max32(p1raw(row,col-2), p1raw(row, col+2));
+  uint32_t minGrad = 0xFFFFFFFF;
+  for (int i = 0; i<7; ++i)
+  {
+    est[i] = p1raw(row+grad_sets[i][0][0], col+grad_sets[i][0][1]) +
+             p1raw(row+grad_sets[i][1][0], col+grad_sets[i][1][1]);
+    grad[i] = 0;
+    for (int j=0; j<12; j+=2)
+      grad[i] += abs32(p1raw(row+grad_sets[i][j][0], col+grad_sets[i][j][1]) -
+                       p1raw(row+grad_sets[i][j+1][0], col+grad_sets[i][j+1][1]));
+    minGrad = min32(minGrad, grad[i]);
+  }
+
+  uint32_t limit = (minGrad * 3) >> 1;
+  uint32_t total = 0;
+  uint32_t count = 0;
+  for (int i = 0; i<7; ++i)
+    if (grad[i] <= limit)
+    {
+      total += est[i];
+      count += 2;
+    }
+  RAW(row, col) = constain32((total + (count >> 1)) / count, lower, upper);
+}
+
 void LibRaw::phase_one_flat_field(int is_float, int nc)
 {
   ushort head[8];
@@ -88,291 +199,325 @@ void LibRaw::phase_one_flat_field(int is_float, int nc)
 int LibRaw::phase_one_correct()
 {
   unsigned entries, tag, data, save, col, row, type;
-  int len, i, j, k, cip, val[4], dev[4], sum, max;
+  int len, i, j, k, cip, sum;
+#if 0
+  int val[4], dev[4], max;
+#endif
   int head[9], diff, mindiff = INT_MAX, off_412 = 0;
   /* static */ const signed char dir[12][2] = {
       {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},
       {0, 2},   {2, 0},  {-2, -2}, {-2, 2}, {2, -2}, {2, 2}};
   float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};
   ushort *xval[2];
   int qmult_applied = 0, qlin_applied = 0;
+  std::vector<unsigned> badCols;
 
   if (!meta_length)
     return 0;
   fseek(ifp, meta_offset, SEEK_SET);
   order = get2();
   fseek(ifp, 6, SEEK_CUR);
   fseek(ifp, meta_offset + get4(), SEEK_SET);
   entries = get4();
   get4();
 
   try
   {
     while (entries--)
     {
       checkCancel();
       tag = get4();
       len = get4();
       data = get4();
       save = ftell(ifp);
       fseek(ifp, meta_offset + data, SEEK_SET);
-      if (tag == 0x0419)
-      { /* Polynomial curve */
-        for (get4(), i = 0; i < 8; i++)
-          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
-        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
-        for (i = 0; i < 0x10000; i++)
-        {
-          num = (poly[5] * i + poly[3]) * i + poly[1];
-          curve[i] = LIM(num, 0, 65535);
-        }
-        goto apply; /* apply to right half */
-      }
-      else if (tag == 0x041a)
-      { /* Polynomial curve */
-        for (i = 0; i < 4; i++)
-          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
-        for (i = 0; i < 0x10000; i++)
-        {
-          for (num = 0, j = 4; j--;)
-            num = num * i + poly[j];
-          curve[i] = LIM(num + i, 0, 65535);
-        }
-      apply: /* apply to whole image */
-        for (row = 0; row < raw_height; row++)
-        {
-          checkCancel();
-          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)
-            RAW(row, col) = curve[RAW(row, col)];
-        }
-      }
-      else if (tag == 0x0400)
+      if (tag == 0x0400)
       { /* Sensor defects */
         while ((len -= 8) >= 0)
         {
           col = get2();
           row = get2();
           type = get2();
           get2();
           if (col >= raw_width)
             continue;
           if (type == 131 || type == 137) /* Bad column */
+#if 0
+            // Original code by Dave Coffin - it works better by
+            // not employing special logic for G1 channel below.
+            // Alternatively this column remap (including G1 channel
+            // logic) should be called prior to black subtraction
+            // unlike other corrections
             for (row = 0; row < raw_height; row++)
-              if (FC(row - top_margin, col - left_margin) == 1)
+            {
+              if (FC(row - top_margin, col - left_margin)==1)
               {
                 for (sum = i = 0; i < 4; i++)
                   sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);
                 for (max = i = 0; i < 4; i++)
                 {
                   dev[i] = abs((val[i] << 2) - sum);
                   if (dev[max] < dev[i])
                     max = i;
                 }
                 RAW(row, col) = (sum - val[max]) / 3.0 + 0.5;
               }
               else
               {
                 for (sum = 0, i = 8; i < 12; i++)
                   sum += p1raw(row + dir[i][0], col + dir[i][1]);
                 RAW(row, col) =
-                    0.5 + sum * 0.0732233 +
-                    (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;
+                  0.5 + sum * 0.0732233 +
+                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;
               }
+            }
+#else
+            // accumulae bad columns to be sorted later
+            badCols.push_back(col);
+#endif
           else if (type == 129)
           { /* Bad pixel */
             if (row >= raw_height)
               continue;
             j = (FC(row - top_margin, col - left_margin) != 1) * 4;
+            unsigned count = 0;
             for (sum = 0, i = j; i < j + 8; i++)
-              sum += p1raw(row + dir[i][0], col + dir[i][1]);
-            RAW(row, col) = (sum + 4) >> 3;
+              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);
+            if (count)
+              RAW(row, col) = (sum + (count >> 1)) / count;
           }
         }
       }
+      else if (tag == 0x0419)
+      { /* Polynomial curve - output calibraion */
+        for (get4(), i = 0; i < 8; i++)
+          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
+        for (i = 0; i < 0x10000; i++)
+        {
+          num = (poly[5] * i + poly[3]) * i + poly[1];
+          curve[i] = LIM(num, 0, 65535);
+        }
+        goto apply; /* apply to right half */
+      }
+      else if (tag == 0x041a)
+      { /* Polynomial curve */
+        for (i = 0; i < 4; i++)
+          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        for (i = 0; i < 0x10000; i++)
+        {
+          for (num = 0, j = 4; j--;)
+            num = num * i + poly[j];
+          curve[i] = LIM(num + i, 0, 65535);
+        }
+      apply: /* apply to whole image */
+        for (row = 0; row < raw_height; row++)
+        {
+          checkCancel();
+          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)
+            RAW(row, col) = curve[RAW(row, col)];
+        }
+      }
       else if (tag == 0x0401)
-      { /* All-color flat fields */
+      { /* All-color flat fields - luma calibration*/
         phase_one_flat_field(1, 2);
       }
       else if (tag == 0x0416 || tag == 0x0410)
       {
+        // 0x410 - luma calibration
         phase_one_flat_field(0, 2);
       }
       else if (tag == 0x040b)
-      { /* Red+blue flat field */
+      { /* Red+blue flat field - croma calibration */
         phase_one_flat_field(0, 4);
       }
       else if (tag == 0x0412)
       {
         fseek(ifp, 36, SEEK_CUR);
         diff = abs(get2() - ph1.tag_21a);
         if (mindiff > diff)
         {
           mindiff = diff;
           off_412 = ftell(ifp) - 38;
         }
       }
       else if (tag == 0x041f && !qlin_applied)
       { /* Quadrant linearization */
         ushort lc[2][2][16], ref[16];
         int qr, qc;
         for (qr = 0; qr < 2; qr++)
           for (qc = 0; qc < 2; qc++)
             for (i = 0; i < 16; i++)
               lc[qr][qc][i] = get4();
         for (i = 0; i < 16; i++)
         {
           int v = 0;
           for (qr = 0; qr < 2; qr++)
             for (qc = 0; qc < 2; qc++)
               v += lc[qr][qc][i];
           ref[i] = (v + 2) >> 2;
         }
         for (qr = 0; qr < 2; qr++)
         {
           for (qc = 0; qc < 2; qc++)
           {
             int cx[19], cf[19];
             for (i = 0; i < 16; i++)
             {
               cx[1 + i] = lc[qr][qc][i];
               cf[1 + i] = ref[i];
             }
             cx[0] = cf[0] = 0;
             cx[17] = cf[17] = ((unsigned int)ref[15] * 65535) / lc[qr][qc][15];
             cf[18] = cx[18] = 65535;
             cubic_spline(cx, cf, 19);
 
             for (row = (qr ? ph1.split_row : 0);
                  row < unsigned(qr ? raw_height : ph1.split_row); row++)
             {
               checkCancel();
               for (col = (qc ? ph1.split_col : 0);
                    col < unsigned(qc ? raw_width : ph1.split_col); col++)
                 RAW(row, col) = curve[RAW(row, col)];
             }
           }
         }
         qlin_applied = 1;
       }
       else if (tag == 0x041e && !qmult_applied)
-      { /* Quadrant multipliers */
+      { /* Quadrant multipliers - output calibraion */
         float qmult[2][2] = {{1, 1}, {1, 1}};
         get4();
         get4();
         get4();
         get4();
         qmult[0][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
         get4();
         get4();
         get4();
         get4();
         get4();
         qmult[0][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
         get4();
         get4();
         get4();
         qmult[1][0] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
         get4();
         get4();
         get4();
         qmult[1][1] = 1.0 + getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
         for (row = 0; row < raw_height; row++)
         {
           checkCancel();
           for (col = 0; col < raw_width; col++)
           {
             i = qmult[row >= (unsigned)ph1.split_row][col >= (unsigned)ph1.split_col] *
                 RAW(row, col);
             RAW(row, col) = LIM(i, 0, 65535);
           }
         }
         qmult_applied = 1;
       }
       else if (tag == 0x0431 && !qmult_applied)
-      { /* Quadrant combined */
+      { /* Quadrant combined - four tile gain calibration */
         ushort lc[2][2][7], ref[7];
         int qr, qc;
         for (i = 0; i < 7; i++)
           ref[i] = get4();
         for (qr = 0; qr < 2; qr++)
           for (qc = 0; qc < 2; qc++)
             for (i = 0; i < 7; i++)
               lc[qr][qc][i] = get4();
         for (qr = 0; qr < 2; qr++)
         {
           for (qc = 0; qc < 2; qc++)
           {
             int cx[9], cf[9];
             for (i = 0; i < 7; i++)
             {
               cx[1 + i] = ref[i];
               cf[1 + i] = ((unsigned)ref[i] * lc[qr][qc][i]) / 10000;
             }
             cx[0] = cf[0] = 0;
             cx[8] = cf[8] = 65535;
             cubic_spline(cx, cf, 9);
             for (row = (qr ? ph1.split_row : 0);
                  row < unsigned(qr ? raw_height : ph1.split_row); row++)
             {
               checkCancel();
               for (col = (qc ? ph1.split_col : 0);
                    col < unsigned(qc ? raw_width : ph1.split_col); col++)
                 RAW(row, col) = curve[RAW(row, col)];
             }
           }
         }
         qmult_applied = 1;
         qlin_applied = 1;
       }
       fseek(ifp, save, SEEK_SET);
     }
+    if (!badCols.empty())
+    {
+      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);
+      bool prevIsolated = true;
+      for (i = 0; i < (int)badCols.size(); ++i)
+      {
+        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;
+        for (row = 0; row < raw_height; ++row)
+          if (prevIsolated && nextIsolated)
+            phase_one_fix_pixel_grad(row,badCols[i]);
+          else
+            phase_one_fix_col_pixel_avg(row,badCols[i]);
+        prevIsolated = nextIsolated;
+      }
+    }
     if (off_412)
     {
       fseek(ifp, off_412, SEEK_SET);
       for (i = 0; i < 9; i++)
         head[i] = get4() & 0x7fff;
       yval[0] = (float *)calloc(head[1] * head[3] + head[2] * head[4], 6);
       merror(yval[0], "phase_one_correct()");
       yval[1] = (float *)(yval[0] + head[1] * head[3]);
       xval[0] = (ushort *)(yval[1] + head[2] * head[4]);
       xval[1] = (ushort *)(xval[0] + head[1] * head[3]);
       get2();
       for (i = 0; i < 2; i++)
         for (j = 0; j < head[i + 1] * head[i + 3]; j++)
           yval[i][j] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       for (i = 0; i < 2; i++)
         for (j = 0; j < head[i + 1] * head[i + 3]; j++)
           xval[i][j] = get2();
       for (row = 0; row < raw_height; row++)
       {
         checkCancel();
         for (col = 0; col < raw_width; col++)
         {
           cfrac = (float)col * head[3] / raw_width;
           cfrac -= cip = cfrac;
           num = RAW(row, col) * 0.5;
           for (i = cip; i < cip + 2; i++)
           {
             for (k = j = 0; j < head[1]; j++)
               if (num < xval[0][k = head[1] * i + j])
                 break;
             frac = (j == 0 || j == head[1])
                        ? 0
                        : (xval[0][k] - num) / (xval[0][k] - xval[0][k - 1]);
             mult[i - cip] = yval[0][k - 1] * frac + yval[0][k] * (1 - frac);
           }
           i = ((mult[0] * (1 - cfrac) + mult[1] * cfrac) * row + num) * 2;
           RAW(row, col) = LIM(i, 0, 65535);
         }
       }
       free(yval[0]);
     }
   }
   catch (...)
   {
     if (yval[0])
       free(yval[0]);
     return LIBRAW_CANCELLED_BY_CALLBACK;
   }
   return 0;
 }
@@ -540,81 +685,84 @@ void LibRaw::phase_one_load_raw_c()
 void LibRaw::hasselblad_load_raw()
 {
   struct jhead jh;
-  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, c;
+  int shot, row, col, *back[5]={0,0,0,0,0},
+ 	 len[2], diff[12], pred, sh, f, c;
   unsigned s;
   unsigned upix, urow, ucol;
   ushort *ip;
 
   if (!ljpeg_start(&jh, 0))
     return;
   order = 0x4949;
   ph1_bits(-1);
   try
   {
     back[4] = (int *)calloc(raw_width, 3 * sizeof **back);
     merror(back[4], "hasselblad_load_raw()");
     FORC3 back[c] = back[4] + c * raw_width;
     cblack[6] >>= sh = tiff_samples > 1;
     shot = LIM(shot_select, 1, tiff_samples) - 1;
     for (row = 0; row < raw_height; row++)
     {
       checkCancel();
       FORC4 back[(c + 3) & 3] = back[c];
       for (col = 0; col < raw_width; col += 2)
       {
         for (s = 0; s < tiff_samples * 2; s += 2)
         {
           FORC(2) len[c] = ph1_huff(jh.huff[0]);
           FORC(2)
           {
             diff[s + c] = ph1_bits(len[c]);
             if (len[c] > 0 && (diff[s + c] & (1 << (len[c] - 1))) == 0)
               diff[s + c] -= (1 << len[c]) - 1;
             if (diff[s + c] == 65535)
               diff[s + c] = -32768;
           }
         }
         for (s = col; s < unsigned(col + 2); s++)
         {
           pred = 0x8000 + load_flags;
           if (col)
             pred = back[2][s - 2];
           if (col && row > 1)
             switch (jh.psv)
             {
             case 11:
               pred += back[0][s] / 2 - back[0][s - 2] / 2;
               break;
             }
           f = (row & 1) * 3 ^ ((col + s) & 1);
           FORC(int(tiff_samples))
           {
             pred += diff[(s & 1) * tiff_samples + c];
             upix = pred >> sh & 0xffff;
             if (raw_image && c == shot)
               RAW(row, s) = upix;
             if (image)
             {
               urow = row - top_margin + (c & 1);
               ucol = col - left_margin - ((c >> 1) & 1);
               ip = &image[urow * width + ucol][f];
               if (urow < height && ucol < width)
                 *ip = c < 4 ? upix : (*ip + upix) >> 1;
             }
           }
           back[2][s] = pred;
         }
       }
     }
   }
   catch (...)
   {
-    free(back[4]);
+    if(back[4])
+    	free(back[4]);
     ljpeg_end(&jh);
     throw;
   }
-  free(back[4]);
+  if(back[4])
+    free(back[4]);
   ljpeg_end(&jh);
   if (image)
     mix_green = 1;
 }
diff --git a/src/decoders/unpack.cpp b/src/decoders/unpack.cpp
index fcdbbfec..acc6a584 100644
--- a/src/decoders/unpack.cpp
+++ b/src/decoders/unpack.cpp
@@ -17,353 +17,357 @@
 int LibRaw::unpack(void)
 {
   CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);
   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);
   try
   {
 
     if (!libraw_internal_data.internal_data.input)
       return LIBRAW_INPUT_CLOSED;
 
     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);
-    if (O.shot_select >= P1.raw_count)
+    if (imgdata.rawparams.shot_select >= P1.raw_count)
       return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;
 
     if (!load_raw)
       return LIBRAW_UNSPECIFIED_ERROR;
 
     // already allocated ?
     if (imgdata.image)
     {
       free(imgdata.image);
       imgdata.image = 0;
     }
     if (imgdata.rawdata.raw_alloc)
     {
       free(imgdata.rawdata.raw_alloc);
       imgdata.rawdata.raw_alloc = 0;
     }
     if (libraw_internal_data.unpacker_data.meta_length)
     {
       libraw_internal_data.internal_data.meta_data =
           (char *)malloc(libraw_internal_data.unpacker_data.meta_length);
       merror(libraw_internal_data.internal_data.meta_data, "LibRaw::unpack()");
     }
 
     libraw_decoder_info_t decoder_info;
     get_decoder_info(&decoder_info);
 
     int save_iwidth = S.iwidth, save_iheight = S.iheight,
         save_shrink = IO.shrink;
 
     int rwidth = S.raw_width, rheight = S.raw_height;
     if (!IO.fuji_width)
     {
       // adjust non-Fuji allocation
       if (rwidth < S.width + S.left_margin)
         rwidth = S.width + S.left_margin;
       if (rheight < S.height + S.top_margin)
         rheight = S.height + S.top_margin;
     }
     if (rwidth > 65535 ||
         rheight > 65535) // No way to make image larger than 64k pix
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
     imgdata.rawdata.raw_image = 0;
     imgdata.rawdata.color4_image = 0;
     imgdata.rawdata.color3_image = 0;
     imgdata.rawdata.float_image = 0;
     imgdata.rawdata.float3_image = 0;
 
 #ifdef USE_DNGSDK
     if (imgdata.idata.dng_version && dnghost
         && libraw_internal_data.unpacker_data.tiff_samples != 2  // Fuji SuperCCD; it is better to detect is more rigid way
         && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)
     {
       // Data size check
       INT64 pixcount =
           INT64(MAX(S.width, S.raw_width)) * INT64(MAX(S.height, S.raw_height));
       INT64 planecount =
           (imgdata.idata.filters || P1.colors == 1) ? 1 : LIM(P1.colors, 3, 4);
       INT64 samplesize = is_floating_point() ? 4 : 2;
       INT64 bytes = pixcount * planecount * samplesize;
       if (bytes > INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
         throw LIBRAW_EXCEPTION_TOOBIG;
 
       // find ifd to check sample
       int rr = try_dngsdk();
       if (raw_was_read())
         imgdata.process_warnings |= LIBRAW_WARN_DNGSDK_PROCESSED;
     }
 #endif
 
 #ifdef USE_RAWSPEED
     if (!raw_was_read())
     {
       int rawspeed_enabled = 1;
 
       if (imgdata.idata.dng_version && (libraw_internal_data.unpacker_data.tiff_samples == 2 || imgdata.idata.raw_count > 1))
         rawspeed_enabled = 0;
 
       if (libraw_internal_data.unpacker_data.is_NikonTransfer)
         rawspeed_enabled = 0;
 
       if (libraw_internal_data.unpacker_data.pana_encoding == 5)
         rawspeed_enabled = 0;
 
       if (imgdata.idata.raw_count > 1)
         rawspeed_enabled = 0;
       if (!strncasecmp(imgdata.idata.software, "Magic", 5))
         rawspeed_enabled = 0;
       // Disable rawspeed for double-sized Oly files
       if (makeIs(LIBRAW_CAMERAMAKER_Olympus) &&
           ((imgdata.sizes.raw_width > 6000) ||
            !strncasecmp(imgdata.idata.model, "SH-", 3) ||
            !strncasecmp(imgdata.idata.model, "TG-", 3) ))
         rawspeed_enabled = 0;
 
       if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
           (libraw_internal_data.identify_data.unique_id == CanonID_EOS_6D_Mark_II))
         rawspeed_enabled = 0;
 
       if (imgdata.idata.dng_version && imgdata.idata.filters == 0 &&
           libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit
         rawspeed_enabled = 0;
 
       if (load_raw == &LibRaw::packed_load_raw &&
         makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
           (!strncasecmp(imgdata.idata.model, "E", 1) ||
            !strncasecmp(imgdata.idata.model, "COOLPIX B", 9) ||
 		   !strncasecmp(imgdata.idata.model, "COOLPIX P9", 10) ||
            !strncasecmp(imgdata.idata.model, "COOLPIX P1000", 13)))
         rawspeed_enabled = 0;
 
+      if (load_raw == &LibRaw::nikon_load_raw && makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
+          !strcasecmp(imgdata.idata.model, "D6"))
+        rawspeed_enabled = 0;
+
 	if (load_raw == &LibRaw::lossless_jpeg_load_raw &&
 		MN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&
 		/* Not normalized models here, it is intentional */
 		(!strncasecmp(imgdata.idata.model, "EOS D2000", 9) ||
 		 !strncasecmp(imgdata.idata.model, "EOS D6000", 9)))
 	  rawspeed_enabled = 0;
 
       if (load_raw == &LibRaw::nikon_load_raw &&
         makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
           (!strncasecmp(imgdata.idata.model, "Z", 1) || !strncasecmp(imgdata.idata.model,"D780",4)))
         rawspeed_enabled = 0;
 
       if (load_raw == &LibRaw::panasonic_load_raw &&
           libraw_internal_data.unpacker_data.pana_encoding > 4)
         rawspeed_enabled = 0;
 
       // RawSpeed Supported,
       if (imgdata.rawparams.use_rawspeed && rawspeed_enabled &&
           !(is_sraw() && (imgdata.rawparams.specials &
                           (LIBRAW_RAWSPECIAL_SRAW_NO_RGB |
                            LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE))) &&
           (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) &&
           _rawspeed_camerameta)
       {
         INT64 pixcount = INT64(MAX(S.width, S.raw_width)) *
                          INT64(MAX(S.height, S.raw_height));
         INT64 planecount = (imgdata.idata.filters || P1.colors == 1)
                                ? 1
                                : LIM(P1.colors, 3, 4);
         INT64 bytes =
             pixcount * planecount * 2; // sample size is always 2 for rawspeed
         if (bytes >
             INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
           throw LIBRAW_EXCEPTION_TOOBIG;
 
         int rr = try_rawspeed();
       }
     }
 #endif
     if (!raw_was_read()) // RawSpeed failed or not run
     {
       // Not allocated on RawSpeed call, try call LibRaow
       int zero_rawimage = 0;
       if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)
       {
         // x3f foveon decoder and DNG float
         // Do nothing! Decoder will allocate data internally
       }
       if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT)
       {
-        if (imgdata.params.shot_select) // single image extract
+        if (imgdata.rawparams.shot_select) // single image extract
         {
           if (INT64(rwidth) * INT64(rheight + 8) *
                   sizeof(imgdata.rawdata.raw_image[0]) >
               INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
             throw LIBRAW_EXCEPTION_TOOBIG;
           imgdata.rawdata.raw_alloc = malloc(
               rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));
           imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;
           if (!S.raw_pitch)
             S.raw_pitch = S.raw_width * 2; // Bayer case, not set before
         }
         else // Full image extract
         {
           if (INT64(rwidth) * INT64(rheight + 8) *
                   sizeof(imgdata.rawdata.raw_image[0]) * 4 >
               INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
             throw LIBRAW_EXCEPTION_TOOBIG;
           S.raw_pitch = S.raw_width * 8;
           imgdata.rawdata.raw_alloc = 0;
           imgdata.image = (ushort(*)[4])calloc(
               unsigned(MAX(S.width, S.raw_width)) *
                   unsigned(MAX(S.height, S.raw_height) + 8),
               sizeof(*imgdata.image));
         }
       }
       else if (decoder_info.decoder_flags & LIBRAW_DECODER_3CHANNEL)
       {
         if (INT64(rwidth) * INT64(rheight + 8) *
                 sizeof(imgdata.rawdata.raw_image[0]) * 3 >
             INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
           throw LIBRAW_EXCEPTION_TOOBIG;
 
         imgdata.rawdata.raw_alloc = malloc(
             rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]) * 3);
         imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;
         if (!S.raw_pitch)
           S.raw_pitch = S.raw_width * 6;
       }
       else if (imgdata.idata.filters ||
                P1.colors ==
                    1) // Bayer image or single color -> decode to raw_image
       {
         if (INT64(rwidth) * INT64(rheight + 8) *
                 sizeof(imgdata.rawdata.raw_image[0]) >
             INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
           throw LIBRAW_EXCEPTION_TOOBIG;
         imgdata.rawdata.raw_alloc = malloc(
             rwidth * (rheight + 8) * sizeof(imgdata.rawdata.raw_image[0]));
         imgdata.rawdata.raw_image = (ushort *)imgdata.rawdata.raw_alloc;
         if (!S.raw_pitch)
           S.raw_pitch = S.raw_width * 2; // Bayer case, not set before
       }
       else // NO LEGACY FLAG if (decoder_info.decoder_flags &
            // LIBRAW_DECODER_LEGACY)
       {
         if (decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL)
         {
           S.raw_pitch = S.raw_width * 8;
         }
         else
         {
           S.iwidth = S.width;
           S.iheight = S.height;
           IO.shrink = 0;
           if (!S.raw_pitch)
             S.raw_pitch = (decoder_info.decoder_flags &
                            LIBRAW_DECODER_LEGACY_WITH_MARGINS)
                               ? S.raw_width * 8
                               : S.width * 8;
         }
         // sRAW and old Foveon decoders only, so extra buffer size is just 1/4
         // allocate image as temporary buffer, size
         if (INT64(MAX(S.width, S.raw_width)) *
                 INT64(MAX(S.height, S.raw_height) + 8) *
                 sizeof(*imgdata.image) >
             INT64(imgdata.rawparams.max_raw_memory_mb) * INT64(1024 * 1024))
           throw LIBRAW_EXCEPTION_TOOBIG;
 
         imgdata.rawdata.raw_alloc = 0;
         imgdata.image =
             (ushort(*)[4])calloc(unsigned(MAX(S.width, S.raw_width)) *
                                      unsigned(MAX(S.height, S.raw_height) + 8),
                                  sizeof(*imgdata.image));
         if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))
         {
           imgdata.rawdata.raw_image = (ushort *)imgdata.image;
           zero_rawimage = 1;
         }
       }
       ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);
 
       unsigned m_save = C.maximum;
       if (load_raw == &LibRaw::unpacked_load_raw &&
           (!strcasecmp(imgdata.idata.make, "Nikon") || !strcasecmp(imgdata.idata.make, "Hasselblad"))
           )
         C.maximum = 65535;
       (this->*load_raw)();
       if (zero_rawimage)
         imgdata.rawdata.raw_image = 0;
       if (load_raw == &LibRaw::unpacked_load_raw &&
           (!strcasecmp(imgdata.idata.make, "Nikon") || !strcasecmp(imgdata.idata.make, "Hasselblad"))
           )
         C.maximum = m_save;
       if (decoder_info.decoder_flags & LIBRAW_DECODER_OWNALLOC)
       {
         // x3f foveon decoder only: do nothing
       }
       else if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT &&
-               imgdata.params.shot_select == 0)
+               imgdata.rawparams.shot_select == 0)
       {
         imgdata.rawdata.raw_alloc = imgdata.image;
         imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;
         imgdata.image = 0;
       }
       else if (!(imgdata.idata.filters ||
                  P1.colors == 1)) // legacy decoder, ownalloc handled above
       {
         // successfully decoded legacy image, attach image to raw_alloc
         imgdata.rawdata.raw_alloc = imgdata.image;
         imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;
         imgdata.image = 0;
         // Restore saved values. Note: Foveon have masked frame
         // Other 4-color legacy data: no borders
         if (!(libraw_internal_data.unpacker_data.load_flags & 256) &&
             !(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL) &&
             !(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS))
         {
           S.raw_width = S.width;
           S.left_margin = 0;
           S.raw_height = S.height;
           S.top_margin = 0;
         }
       }
     }
 
     if (imgdata.rawdata.raw_image)
       crop_masked_pixels(); // calculate black levels
 
     // recover image sizes
     S.iwidth = save_iwidth;
     S.iheight = save_iheight;
     IO.shrink = save_shrink;
 
     // adjust black to possible maximum
     unsigned int i = C.cblack[3];
     unsigned int c;
     for (c = 0; c < 3; c++)
       if (i > C.cblack[c])
         i = C.cblack[c];
     for (c = 0; c < 4; c++)
       C.cblack[c] -= i;
     C.black += i;
 
     // Save color,sizes and internal data into raw_image fields
     memmove(&imgdata.rawdata.color, &imgdata.color, sizeof(imgdata.color));
     memmove(&imgdata.rawdata.sizes, &imgdata.sizes, sizeof(imgdata.sizes));
     memmove(&imgdata.rawdata.iparams, &imgdata.idata, sizeof(imgdata.idata));
     memmove(&imgdata.rawdata.ioparams,
             &libraw_internal_data.internal_output_params,
             sizeof(libraw_internal_data.internal_output_params));
 
     SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);
     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 1, 2);
 
     return 0;
   }
   catch (const std::bad_alloc&)
   {
       EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);
   }
   catch (const LibRaw_exceptions& err)
   {
     EXCEPTION_HANDLER(err);
   }
   catch (const std::exception& ee)
   {
     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);
   }
 }
diff --git a/src/decoders/unpack_thumb.cpp b/src/decoders/unpack_thumb.cpp
index 2b7ed328..4626ee17 100644
--- a/src/decoders/unpack_thumb.cpp
+++ b/src/decoders/unpack_thumb.cpp
@@ -31,336 +31,341 @@ static void jpegErrorExit(j_common_ptr cinfo)
 int LibRaw::unpack_thumb(void)
 {
   CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);
   CHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);
 
 #define THUMB_SIZE_CHECKT(A) \
   do { \
-    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
-    if (INT64(A) > 0 &&  INT64(A) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \
+    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
+    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \
   } while (0)
 
 #define THUMB_SIZE_CHECKTNZ(A) \
   do { \
-    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
-    if (INT64(A) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \
+    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
+    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \
   } while (0)
 
 
 #define THUMB_SIZE_CHECKWH(W,H) \
   do { \
     if (INT64(W)*INT64(H) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
     if (INT64(W)*INT64(H) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \
   } while (0)
 
   try
   {
     if (!libraw_internal_data.internal_data.input)
       return LIBRAW_INPUT_CLOSED;
 
     int t_colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;
     int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;
 
     if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&
-                         load_raw == &LibRaw::broadcom_load_raw) // RPi
+                         load_raw == &LibRaw::broadcom_load_raw)  // RPi
+#ifdef USE_6BY9RPI
+        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000
+            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||
+           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))
+#endif
     )
     {
       return LIBRAW_NO_THUMBNAIL;
     }
     else if (thumb_load_raw)
     {
       kodak_thumb_loader();
       T.tformat = LIBRAW_THUMBNAIL_BITMAP;
       SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
       return 0;
     }
     else
     {
 #ifdef USE_X3FTOOLS
 	if (write_thumb == &LibRaw::x3f_thumb_loader)
       {
         INT64 tsize = x3f_thumb_size();
         if (tsize < 2048 || INT64(ID.toffset) + tsize < 1)
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
         if (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)
           throw LIBRAW_EXCEPTION_IO_EOF;
         THUMB_SIZE_CHECKT(tsize);
       }
 #else
 	if (0) {}
 #endif
       else
       {
         if (INT64(ID.toffset) + INT64(T.tlength) < 1)
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
         if (INT64(ID.toffset) + INT64(T.tlength) >
             ID.input->size() + THUMB_READ_BEYOND)
           throw LIBRAW_EXCEPTION_IO_EOF;
       }
 
       ID.input->seek(ID.toffset, SEEK_SET);
       if (write_thumb == &LibRaw::jpeg_thumb)
       {
         THUMB_SIZE_CHECKTNZ(T.tlength);
         if (T.thumb)
           free(T.thumb);
         T.thumb = (char *)malloc(T.tlength);
         merror(T.thumb, "jpeg_thumb()");
         ID.input->read(T.thumb, 1, T.tlength);
 		unsigned char *tthumb = (unsigned char *)T.thumb;
 		if (load_raw == &LibRaw::crxLoadRaw && T.tlength > 0xE0)
 		{
 			// Check if it is canon H.265 preview:  CISZ at bytes 4-6, CISZ prefix is 000n
 			if (tthumb[0] == 0 && tthumb[1] == 0 && tthumb[2] == 0 && !memcmp(tthumb + 4, "CISZ", 4))
 			{
 				T.tformat = LIBRAW_THUMBNAIL_H265;
 				SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
 				return 0;
 			}
 		}
         tthumb[0] = 0xff;
         tthumb[1] = 0xd8;
 #ifdef NO_JPEG
         T.tcolors = 3;
 #else
         {
           jpegErrorManager jerr;
           struct jpeg_decompress_struct cinfo;
           cinfo.err = jpeg_std_error(&jerr.pub);
           jerr.pub.error_exit = jpegErrorExit;
           if (setjmp(jerr.setjmp_buffer))
           {
           err2:
             // Error in original JPEG thumb, read it again because
             // original bytes 0-1 was damaged above
             jpeg_destroy_decompress(&cinfo);
             T.tcolors = 3;
             T.tformat = LIBRAW_THUMBNAIL_UNKNOWN;
             ID.input->seek(ID.toffset, SEEK_SET);
             ID.input->read(T.thumb, 1, T.tlength);
             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
             return 0;
           }
           jpeg_create_decompress(&cinfo);
           jpeg_mem_src(&cinfo, (unsigned char *)T.thumb, T.tlength);
           int rc = jpeg_read_header(&cinfo, TRUE);
           if (rc != 1)
             goto err2;
           T.tcolors = (cinfo.num_components > 0 && cinfo.num_components <= 3)
                           ? cinfo.num_components
                           : 3;
           jpeg_destroy_decompress(&cinfo);
         }
 #endif
         T.tformat = LIBRAW_THUMBNAIL_JPEG;
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
       else if (write_thumb == &LibRaw::layer_thumb)
       {
         int colors = libraw_internal_data.unpacker_data.thumb_misc >> 5 & 7;
         if (colors != 1 && colors != 3)
           return LIBRAW_UNSUPPORTED_THUMBNAIL;
 
         THUMB_SIZE_CHECKWH(T.twidth, T.theight);
 
         int tlength = T.twidth * T.theight;
         if (T.thumb)
           free(T.thumb);
         T.thumb = (char *)calloc(colors, tlength);
         merror(T.thumb, "layer_thumb()");
         unsigned char *tbuf = (unsigned char *)calloc(colors, tlength);
         merror(tbuf, "layer_thumb()");
         // Avoid OOB of tbuf, should use tlength
         ID.input->read(tbuf, colors, tlength);
         if (libraw_internal_data.unpacker_data.thumb_misc >> 8 &&
             colors == 3) // GRB order
           for (int i = 0; i < tlength; i++)
           {
             T.thumb[i * 3] = tbuf[i + tlength];
             T.thumb[i * 3 + 1] = tbuf[i];
             T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];
           }
         else if (colors == 3) // RGB or 1-channel
           for (int i = 0; i < tlength; i++)
           {
             T.thumb[i * 3] = tbuf[i];
             T.thumb[i * 3 + 1] = tbuf[i + tlength];
             T.thumb[i * 3 + 2] = tbuf[i + 2 * tlength];
           }
         else if (colors == 1)
         {
           free(T.thumb);
           T.thumb = (char *)tbuf;
           tbuf = 0;
         }
         if (tbuf)
           free(tbuf);
         T.tcolors = colors;
         T.tlength = colors * tlength;
         T.tformat = LIBRAW_THUMBNAIL_BITMAP;
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
       else if (write_thumb == &LibRaw::rollei_thumb)
       {
         int i;
         THUMB_SIZE_CHECKWH(T.twidth, T.theight);
         int tlength = T.twidth * T.theight;
         if (T.thumb)
           free(T.thumb);
         T.tcolors = 3;
         T.thumb = (char *)calloc(T.tcolors, tlength);
         merror(T.thumb, "layer_thumb()");
         unsigned short *tbuf = (unsigned short *)calloc(2, tlength);
         merror(tbuf, "layer_thumb()");
         read_shorts(tbuf, tlength);
         for (i = 0; i < tlength; i++)
         {
           T.thumb[i * 3] = (tbuf[i] << 3) & 0xff;
           T.thumb[i * 3 + 1] = (tbuf[i] >> 5 << 2) & 0xff;
           T.thumb[i * 3 + 2] = (tbuf[i] >> 11 << 3) & 0xff;
         }
         free(tbuf);
         T.tlength = T.tcolors * tlength;
         T.tformat = LIBRAW_THUMBNAIL_BITMAP;
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
       else if (write_thumb == &LibRaw::ppm_thumb)
       {
         if (t_bytesps > 1)
           throw LIBRAW_EXCEPTION_IO_CORRUPT; // 8-bit thumb, but parsed for more
                                              // bits
         THUMB_SIZE_CHECKWH(T.twidth, T.theight);
         int t_length = T.twidth * T.theight * t_colors;
 
         if (T.tlength &&
             (int)T.tlength < t_length) // try to find tiff ifd with needed offset
         {
           int pifd = find_ifd_by_offset(libraw_internal_data.internal_data.toffset);
           if (pifd >= 0 && tiff_ifd[pifd].strip_offsets_count &&
               tiff_ifd[pifd].strip_byte_counts_count)
           {
             // We found it, calculate final size
             unsigned total_size = 0;
             for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count; i++)
               total_size += tiff_ifd[pifd].strip_byte_counts[i];
             if (total_size != (unsigned)t_length) // recalculate colors
             {
               if (total_size == T.twidth * T.tlength * 3)
                 T.tcolors = 3;
               else if (total_size == T.twidth * T.tlength)
                 T.tcolors = 1;
             }
             T.tlength = total_size;
             THUMB_SIZE_CHECKTNZ(T.tlength);
             if (T.thumb)
               free(T.thumb);
             T.thumb = (char *)malloc(T.tlength);
             merror(T.thumb, "ppm_thumb()");
 
             char *dest = T.thumb;
             INT64 pos = ID.input->tell();
 
             for (int i = 0; i < tiff_ifd[pifd].strip_byte_counts_count &&
                             i < tiff_ifd[pifd].strip_offsets_count;
                  i++)
             {
               int remain = T.tlength;
               int sz = tiff_ifd[pifd].strip_byte_counts[i];
               int off = tiff_ifd[pifd].strip_offsets[i];
               if (off >= 0 && off + sz <= ID.input->size() && sz <= remain)
               {
                 ID.input->seek(off, SEEK_SET);
                 ID.input->read(dest, sz, 1);
                 remain -= sz;
                 dest += sz;
               }
             }
             ID.input->seek(pos, SEEK_SET);
             T.tformat = LIBRAW_THUMBNAIL_BITMAP;
             SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
             return 0;
           }
         }
 
         if (!T.tlength)
           T.tlength = t_length;
         if (T.thumb)
           free(T.thumb);
 
         THUMB_SIZE_CHECKTNZ(T.tlength);
 
         T.thumb = (char *)malloc(T.tlength);
         if (!T.tcolors)
           T.tcolors = t_colors;
         merror(T.thumb, "ppm_thumb()");
 
         ID.input->read(T.thumb, 1, T.tlength);
 
         T.tformat = LIBRAW_THUMBNAIL_BITMAP;
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
       else if (write_thumb == &LibRaw::ppm16_thumb)
       {
         if (t_bytesps > 2)
           throw LIBRAW_EXCEPTION_IO_CORRUPT; // 16-bit thumb, but parsed for
                                              // more bits
         int o_bps = (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1;
         int o_length = T.twidth * T.theight * t_colors * o_bps;
         int i_length = T.twidth * T.theight * t_colors * 2;
         if (!T.tlength)
           T.tlength = o_length;
         THUMB_SIZE_CHECKTNZ(o_length);
         THUMB_SIZE_CHECKTNZ(i_length);
         THUMB_SIZE_CHECKTNZ(T.tlength);
 
         ushort *t_thumb = (ushort *)calloc(i_length, 1);
         ID.input->read(t_thumb, 1, i_length);
         if ((libraw_internal_data.unpacker_data.order == 0x4949) ==
             (ntohs(0x1234) == 0x1234))
           swab((char *)t_thumb, (char *)t_thumb, i_length);
 
         if (T.thumb)
           free(T.thumb);
         if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS))
         {
           T.thumb = (char *)t_thumb;
           T.tformat = LIBRAW_THUMBNAIL_BITMAP16;
         }
         else
         {
           T.thumb = (char *)malloc(o_length);
           merror(T.thumb, "ppm_thumb()");
           for (int i = 0; i < o_length; i++)
             T.thumb[i] = t_thumb[i] >> 8;
           free(t_thumb);
           T.tformat = LIBRAW_THUMBNAIL_BITMAP;
         }
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
 #ifdef USE_X3FTOOLS
 	  else if (write_thumb == &LibRaw::x3f_thumb_loader)
       {
         x3f_thumb_loader();
         SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
         return 0;
       }
 #endif
       else
       {
         return LIBRAW_UNSUPPORTED_THUMBNAIL;
       }
     }
     // last resort
     return LIBRAW_UNSUPPORTED_THUMBNAIL;
   }
   catch (const LibRaw_exceptions& err)
   {
     EXCEPTION_HANDLER(err);
   }
 }
diff --git a/src/demosaic/xtrans_demosaic.cpp b/src/demosaic/xtrans_demosaic.cpp
index f0a2eb73..6e17364c 100644
--- a/src/demosaic/xtrans_demosaic.cpp
+++ b/src/demosaic/xtrans_demosaic.cpp
@@ -21,410 +21,410 @@
 #define fcol(row, col) xtrans[(row + 6) % 6][(col + 6) % 6]
 /*
    Frank Markesteijn's algorithm for Fuji X-Trans sensors
  */
 void LibRaw::xtrans_interpolate(int passes)
 {
   int cstat[4] = {0, 0, 0, 0};
   int ndir;
   static const short orth[12] = {1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1},
                      patt[2][16] = {{0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0,
                                      0, 0, 0},
                                     {0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1,
                                      -1, -1, 1}},
                      dir[4] = {1, LIBRAW_AHD_TILE, LIBRAW_AHD_TILE + 1,
                                LIBRAW_AHD_TILE - 1};
   short allhex[3][3][2][8];
-  ushort sgrow, sgcol;
+  ushort sgrow = 0, sgcol = 0;
 
   if (width < LIBRAW_AHD_TILE || height < LIBRAW_AHD_TILE)
     throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image
                                        /* Check against right pattern */
   for (int row = 0; row < 6; row++)
     for (int col = 0; col < 6; col++)
       cstat[(unsigned)fcol(row, col)]++;
 
   if (cstat[0] < 6 || cstat[0] > 10 || cstat[1] < 16 || cstat[1] > 24 ||
       cstat[2] < 6 || cstat[2] > 10 || cstat[3])
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
   // Init allhex table to unreasonable values
   for (int i = 0; i < 3; i++)
     for (int j = 0; j < 3; j++)
       for (int k = 0; k < 2; k++)
         for (int l = 0; l < 8; l++)
           allhex[i][j][k][l] = 32700;
 
   cielab(0, 0);
   ndir = 4 << (passes > 1);
 
   int minv = 0, maxv = 0, minh = 0, maxh = 0;
   /* Map a green hexagon around each non-green pixel and vice versa:	*/
   for (int row = 0; row < 3; row++)
     for (int col = 0; col < 3; col++)
       for (int ng = 0, d = 0; d < 10; d += 2)
       {
         int g = fcol(row, col) == 1;
         if (fcol(row + orth[d], col + orth[d + 2]) == 1)
           ng = 0;
         else
           ng++;
         if (ng == 4)
         {
           sgrow = row;
           sgcol = col;
         }
         if (ng == g + 1)
         {
             int c;
             FORC(8)
             {
                 int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];
                 int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];
                 minv = MIN(v, minv);
                 maxv = MAX(v, maxv);
                 minh = MIN(v, minh);
                 maxh = MAX(v, maxh);
                 allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;
                 allhex[row][col][1][c ^ (g * 2 & d)] = h + v * LIBRAW_AHD_TILE;
             }
         }
       }
 
   // Check allhex table initialization
   for (int i = 0; i < 3; i++)
     for (int j = 0; j < 3; j++)
       for (int k = 0; k < 2; k++)
         for (int l = 0; l < 8; l++)
           if (allhex[i][j][k][l] > maxh + maxv * width + 1 ||
               allhex[i][j][k][l] < minh + minv * width - 1)
             throw LIBRAW_EXCEPTION_IO_CORRUPT;
   int retrycount = 0;
 
   /* Set green1 and green3 to the minimum and maximum allowed values:	*/
   for (int row = 2; row < height - 2; row++)
   {
       int col;
       ushort min, max;
       for (col = 2, max = 0, min = ~0; col < width - 2; col++)
       {
           if (fcol(row, col) == 1 && (min = ~(max = 0)))
               continue;
           ushort(*pix)[4];
           pix = image + row * width + col;
           short* hex = allhex[row % 3][col % 3][0];
           if (!max)
           {
               int c;
               FORC(6)
               {
                   int val = pix[hex[c]][1];
                   if (min > val)
                       min = val;
                   if (max < val)
                       max = val;
               }
           }
           pix[0][1] = min;
           pix[0][3] = max;
           switch ((row - sgrow) % 3)
           {
           case 1:
               if (row < height - 3)
               {
                   row++;
                   col--;
               }
               break;
           case 2:
               if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)
               {
                   row--;
                   if (retrycount++ > width * height)
                       throw LIBRAW_EXCEPTION_IO_CORRUPT;
               }
           }
       }
   }
 
   for (int row = 3; row < 9 && row < height - 3; row++)
 	  for (int col = 3; col < 9 && col < width - 3; col++)
 	  {
 		  if ((fcol(row, col)) == 1)
 			  continue;
           short* hex = allhex[row % 3][col % 3][0];
           int c;
 		  FORC(2)
 		  {
 			  int idx3 = 3 * hex[4 + c] + row * width + col;
 			  int idx4 = -3 * hex[4 + c] + row * width + col;
 			  int maxidx = width * height;
 			  if (idx3 < 0 || idx3 >= maxidx)
 				  throw LIBRAW_EXCEPTION_IO_CORRUPT;
 			  if (idx4 < 0 || idx4 >= maxidx)
 				  throw LIBRAW_EXCEPTION_IO_CORRUPT;
 		  }
 	  }
 
 #if defined(LIBRAW_USE_OPENMP)
   int buffer_count = omp_get_max_threads();
 #else
   int buffer_count = 1;
 #endif
 
   size_t buffer_size = LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 11 + 6);
   char** buffers = malloc_omp_buffers(buffer_count, buffer_size, "xtrans_interpolate()");
 
 #if defined(LIBRAW_USE_OPENMP)
 # pragma omp parallel for schedule(dynamic) default(none) firstprivate(buffers, allhex, passes, sgrow, sgcol, ndir) shared(dir) 
 #endif
     for (int top = 3; top < height - 19; top += LIBRAW_AHD_TILE - 16)
     {
 #if defined(LIBRAW_USE_OPENMP)
         char* buffer = buffers[omp_get_thread_num()];
 #else
         char* buffer = buffers[0];
 #endif
 
         ushort(*rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3], (*rix)[3];
         short(*lab)[LIBRAW_AHD_TILE][3], (*lix)[3];
         float(*drv)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];
         char(*homo)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE];
 
         rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;
         lab = (short(*)[LIBRAW_AHD_TILE][3])(
             buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6));
         drv = (float(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(
             buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 6 + 6));
         homo = (char(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE])(
             buffer + LIBRAW_AHD_TILE * LIBRAW_AHD_TILE * (ndir * 10 + 6));
 
         for (int left = 3; left < width - 19; left += LIBRAW_AHD_TILE - 16)
         {
             int mrow = MIN(top + LIBRAW_AHD_TILE, height - 3);
             int mcol = MIN(left + LIBRAW_AHD_TILE, width - 3);
             for (int row = top; row < mrow; row++)
                 for (int col = left; col < mcol; col++)
                     memcpy(rgb[0][row - top][col - left], image[row * width + col], 6);
             int c;
             FORC3 memcpy(rgb[c + 1], rgb[0], sizeof * rgb);
 
             /* Interpolate green horizontally, vertically, and along both diagonals:
              */
             int color[3][8];
             for (int row = top; row < mrow; row++)
                 for (int col = left; col < mcol; col++)
                 {
                     int f;
                     if ((f = fcol(row, col)) == 1)
                         continue;
                     ushort (*pix)[4] = image + row * width + col;
                     short* hex = allhex[row % 3][col % 3][0];
                     color[1][0] = 174 * (pix[hex[1]][1] + pix[hex[0]][1]) -
                         46 * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);
                     color[1][1] = 223 * pix[hex[3]][1] + pix[hex[2]][1] * 33 +
                         92 * (pix[0][f] - pix[-hex[2]][f]);
                     FORC(2)
                         color[1][2 + c] = 164 * pix[hex[4 + c]][1] +
                         92 * pix[-2 * hex[4 + c]][1] +
                         33 * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] -
                             pix[-3 * hex[4 + c]][f]);
                     FORC4 rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1] =
                         LIM(color[1][c] >> 8, pix[0][1], pix[0][3]);
                 }
 
             for (int pass = 0; pass < passes; pass++)
             {
                 if (pass == 1)
                     memcpy(rgb += 4, buffer, 4 * sizeof * rgb);
 
                 /* Recalculate green from interpolated values of closer pixels:	*/
                 if (pass)
                 {
                     for (int row = top + 2; row < mrow - 2; row++)
                         for (int col = left + 2; col < mcol - 2; col++)
                         {
                             int f;
                             if ((f = fcol(row, col)) == 1)
                                 continue;
                             ushort(*pix)[4] = image + row * width + col;
                             short* hex = allhex[row % 3][col % 3][1];
                             for (int d = 3; d < 6; d++)
                             {
                                 rix =
                                     &rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];
                                 int val = rix[-2 * hex[d]][1] + 2 * rix[hex[d]][1] -
                                     rix[-2 * hex[d]][f] - 2 * rix[hex[d]][f] + 3 * rix[0][f];
                                 rix[0][1] = LIM(val / 3, pix[0][1], pix[0][3]);
                             }
                         }
                 }
 
                 /* Interpolate red and blue values for solitary green pixels:	*/
                 for (int row = (top - sgrow + 4) / 3 * 3 + sgrow; row < mrow - 2; row += 3)
                     for (int col = (left - sgcol + 4) / 3 * 3 + sgcol; col < mcol - 2; col += 3)
                 {
                     rix = &rgb[0][row - top][col - left];
                     int h = fcol(row, col + 1);
                     float diff[6];
                     memset(diff, 0, sizeof diff);
                     for (int i = 1, d = 0; d < 6; d++, i ^= LIBRAW_AHD_TILE ^ 1, h ^= 2)
                     {
                         for (c = 0; c < 2; c++, h ^= 2)
                         {
                             int g = 2 * rix[0][1] - rix[i << c][1] - rix[-i << c][1];
                             color[h][d] = g + rix[i << c][h] + rix[-i << c][h];
                             if (d > 1)
                                 diff[d] += SQR((float)rix[i << c][1] - (float)rix[-i << c][1] -
                                     (float)rix[i << c][h] + (float)rix[-i << c][h]) + SQR((float)g);
                         }
                         if (d > 1 && (d & 1))
                             if (diff[d - 1] < diff[d])
                                 FORC(2) color[c * 2][d] = color[c * 2][d - 1];
                         if (d < 2 || (d & 1))
                         {
                             FORC(2) rix[0][c * 2] = CLIP(color[c * 2][d] / 2);
                             rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE;
                         }
                     }
                 }
 
                 /* Interpolate red for blue pixels and vice versa:		*/
                 for (int row = top + 3; row < mrow - 3; row++)
                     for (int col = left + 3; col < mcol - 3; col++)
                     {
                         int f;
                         if ((f = 2 - fcol(row, col)) == 1)
                             continue;
                         rix = &rgb[0][row - top][col - left];
                         c = (row - sgrow) % 3 ? LIBRAW_AHD_TILE : 1;
                         int h = 3 * (c ^ LIBRAW_AHD_TILE ^ 1);
                         for (int d = 0; d < 4; d++, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)
                         {
                             int i = d > 1 || ((d ^ c) & 1) ||
                                 ((ABS(rix[0][1] - rix[c][1]) +
                                     ABS(rix[0][1] - rix[-c][1])) <
                                     2 * (ABS(rix[0][1] - rix[h][1]) +
                                         ABS(rix[0][1] - rix[-h][1])))
                                 ? c
                                 : h;
                             rix[0][f] = CLIP((rix[i][f] + rix[-i][f] + 2 * rix[0][1] -
                                 rix[i][1] - rix[-i][1]) /
                                 2);
                         }
                     }
 
                 /* Fill in red and blue for 2x2 blocks of green:		*/
                 for (int row = top + 2; row < mrow - 2; row++)
                     if ((row - sgrow) % 3)
                         for (int col = left + 2; col < mcol - 2; col++)
                             if ((col - sgcol) % 3)
                             {
                                 rix = &rgb[0][row - top][col - left];
                                 short* hex = allhex[row % 3][col % 3][1];
                                 for (int d = 0; d < ndir;
                                     d += 2, rix += LIBRAW_AHD_TILE * LIBRAW_AHD_TILE)
                                     if (hex[d] + hex[d + 1])
                                     {
                                         int g = 3 * rix[0][1] - 2 * rix[hex[d]][1] - rix[hex[d + 1]][1];
                                         for (c = 0; c < 4; c += 2)
                                             rix[0][c] = CLIP(
                                                 (g + 2 * rix[hex[d]][c] + rix[hex[d + 1]][c]) / 3);
                                     }
                                     else
                                     {
                                         int g = 2 * rix[0][1] - rix[hex[d]][1] - rix[hex[d + 1]][1];
                                         for (c = 0; c < 4; c += 2)
                                             rix[0][c] =
                                             CLIP((g + rix[hex[d]][c] + rix[hex[d + 1]][c]) / 2);
                                     }
                             }
             }
             rgb = (ushort(*)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])buffer;
             mrow -= top;
             mcol -= left;
 
             /* Convert to CIELab and differentiate in all directions:	*/
             // no effect
             for (int d = 0; d < ndir; d++)
             {
                 for (int row = 2; row < mrow - 2; row++)
                     for (int col = 2; col < mcol - 2; col++)
                         cielab(rgb[d][row][col], lab[row][col]);
                 for (int f = dir[d & 3], row = 3; row < mrow - 3; row++)
                     for (int col = 3; col < mcol - 3; col++)
                     {
                         lix = &lab[row][col];
                         int g = 2 * lix[0][0] - lix[f][0] - lix[-f][0];
                         drv[d][row][col] =
                             SQR(g) +
                             SQR((2 * lix[0][1] - lix[f][1] - lix[-f][1] + g * 500 / 232)) +
                             SQR((2 * lix[0][2] - lix[f][2] - lix[-f][2] - g * 500 / 580));
                     }
             }
 
             /* Build homogeneity maps from the derivatives:			*/
             memset(homo, 0, ndir * LIBRAW_AHD_TILE * LIBRAW_AHD_TILE);
             for (int row = 4; row < mrow - 4; row++)
                 for (int col = 4; col < mcol - 4; col++)
                 {
                     int d;
                     float tr;
                     for (tr = FLT_MAX, d = 0; d < ndir; d++)
                         if (tr > drv[d][row][col])
                             tr = drv[d][row][col];
                     tr *= 8;
                     for (int d = 0; d < ndir; d++)
                         for (int v = -1; v <= 1; v++)
                             for (int h = -1; h <= 1; h++)
                                 if (drv[d][row + v][col + h] <= tr)
                                     homo[d][row][col]++;
                 }
 
             /* Average the most homogenous pixels for the final result:	*/
             if (height - top < LIBRAW_AHD_TILE + 4)
                 mrow = height - top + 2;
             if (width - left < LIBRAW_AHD_TILE + 4)
                 mcol = width - left + 2;
             for (int row = MIN(top, 8); row < mrow - 8; row++)
                 for (int col = MIN(left, 8); col < mcol - 8; col++)
                 {
                     int v;
                     int hm[8];
                     for (int d = 0; d < ndir; d++)
                         for (v = -2, hm[d] = 0; v <= 2; v++)
                             for (int h = -2; h <= 2; h++)
                                 hm[d] += homo[d][row + v][col + h];
                     for (int d = 0; d < ndir - 4; d++)
                         if (hm[d] < hm[d + 4])
                             hm[d] = 0;
                         else if (hm[d] > hm[d + 4])
                             hm[d + 4] = 0;
                     ushort max;
                     int d;
                     for (d = 1, max = hm[0]; d < ndir; d++)
                         if (max < hm[d])
                             max = hm[d];
                     max -= max >> 3;
 
                     int avg[4];
                     memset(avg, 0, sizeof avg);
                     for (int d = 0; d < ndir; d++)
                         if (hm[d] >= max)
                         {
                             FORC3 avg[c] += rgb[d][row][col][c];
                             avg[3]++;
                         }
                     FORC3 image[(row + top) * width + col + left][c] = avg[c] / avg[3];
                 }
         }
     }
   
 #ifdef LIBRAW_USE_OPENMP
 #pragma omp barrier
 #endif
 
     free_omp_buffers(buffers, buffer_count);
 
     border_interpolate(8);
 }
 #undef fcol
diff --git a/src/integration/dngsdk_glue.cpp b/src/integration/dngsdk_glue.cpp
index 10c05551..ed9aab69 100644
--- a/src/integration/dngsdk_glue.cpp
+++ b/src/integration/dngsdk_glue.cpp
@@ -78,70 +78,74 @@ static dng_ifd* search_for_ifd(const dng_info& info, uint64 offset, ushort w, us
 int LibRaw::valid_for_dngsdk()
 {
 #ifndef USE_DNGSDK
   return 0;
 #else
   if (!imgdata.idata.dng_version)
     return 0;
 
+  // All DNG larger than 2GB - to DNG SDK
+  if (libraw_internal_data.internal_data.input->size() > 2147483647ULL)
+      return 1;
+
   if (!strcasecmp(imgdata.idata.make, "Blackmagic") 
       && (libraw_internal_data.unpacker_data.tiff_compress == 7)
       && (libraw_internal_data.unpacker_data.tiff_bps > 8)
       )
       return 0;
 
   if (libraw_internal_data.unpacker_data.tiff_compress == 34892
 	  && libraw_internal_data.unpacker_data.tiff_bps == 8
 	  && libraw_internal_data.unpacker_data.tiff_samples == 3
 	  && load_raw == &LibRaw::lossy_dng_load_raw
 	  )
   {
       if (!dnghost)
           return 0;
       dng_host *host = static_cast<dng_host *>(dnghost);
       libraw_dng_stream stream(libraw_internal_data.internal_data.input);
       AutoPtr<dng_negative> negative;
       negative.Reset(host->Make_dng_negative());
       dng_info info;
       info.Parse(*host, stream);
       info.PostParse(*host);
       if (!info.IsValidDNG())
           return 0;
       negative->Parse(*host, stream, info);
       negative->PostParse(*host, stream, info);
       int ifdindex = -1;
       dng_ifd *rawIFD = search_for_ifd(info, libraw_internal_data.unpacker_data.data_offset, imgdata.sizes.raw_width, imgdata.sizes.raw_height, ifdindex,stream);
       if (rawIFD && ifdindex >= 0 && ifdindex == info.fMainIndex)
           return 1;
 	  return 0;
   }
 
 #ifdef USE_GPRSDK
   if (load_raw == &LibRaw::vc5_dng_load_raw_placeholder) // regardless of flags or use_dngsdk value!
       return 1;
 #endif
   if (!imgdata.rawparams.use_dngsdk)
     return 0;
   if (load_raw == &LibRaw::lossy_dng_load_raw) // WHY??
     return 0;
   if (is_floating_point() && (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_FLOAT))
     return 1;
   if (!imgdata.idata.filters && (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_LINEAR))
     return 1;
   if (libraw_internal_data.unpacker_data.tiff_bps == 8 &&
       (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_8BIT))
     return 1;
   if (libraw_internal_data.unpacker_data.tiff_compress == 8 &&
       (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_DEFLATE))
     return 1;
   if (libraw_internal_data.unpacker_data.tiff_samples == 2)
     return 0; // Always deny 2-samples (old fuji superccd)
   if (imgdata.idata.filters == 9 &&
       (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_XTRANS))
     return 1;
   if (is_fuji_rotated())
     return 0; // refuse
   if (imgdata.rawparams.use_dngsdk & LIBRAW_DNG_OTHER)
     return 1;
   return 0;
 #endif
 }
diff --git a/src/metadata/canon.cpp b/src/metadata/canon.cpp
index df6a4678..a8c86696 100644
--- a/src/metadata/canon.cpp
+++ b/src/metadata/canon.cpp
@@ -15,11 +15,20 @@
 #include "../../internal/dcraw_defs.h"
 #include "../../internal/libraw_cameraids.h"
 
+libraw_area_t LibRaw::get_CanonArea() {
+  libraw_area_t la = {};
+  la.l = get2();
+  la.t = get2();
+  la.r = get2();
+  la.b = get2();
+  return la;
+}
+
 float LibRaw::_CanonConvertAperture(ushort in)
 {
   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))
     return 0.0f;
-  return LibRaw::libraw_powf64l(2.0, in / 64.0);
+  return LibRaw::libraw_powf64l(2.f, float(in) / 64.f);
 }
 
 static float _CanonConvertEV(short in)
@@ -56,368 +65,522 @@ static float _CanonConvertEV(short in)
 void LibRaw::setCanonBodyFeatures(unsigned long long id)
 {
 
   ilm.CamID = id;
   if ((id == CanonID_EOS_1D)           ||
       (id == CanonID_EOS_1D_Mark_II)   ||
       (id == CanonID_EOS_1D_Mark_II_N) ||
       (id == CanonID_EOS_1D_Mark_III)  ||
       (id == CanonID_EOS_1D_Mark_IV))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_APSH;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF;
   }
   else if ((id == CanonID_EOS_1Ds)           ||
            (id == CanonID_EOS_1Ds_Mark_II)   ||
            (id == CanonID_EOS_1Ds_Mark_III)  ||
            (id == CanonID_EOS_1D_X)          ||
            (id == CanonID_EOS_1D_X_Mark_II)  ||
            (id == CanonID_EOS_1D_X_Mark_III) ||
            (id == CanonID_EOS_1D_C)          ||
            (id == CanonID_EOS_5D)            ||
            (id == CanonID_EOS_5D_Mark_II)    ||
            (id == CanonID_EOS_5D_Mark_III)   ||
            (id == CanonID_EOS_5D_Mark_IV)    ||
            (id == CanonID_EOS_5DS)           ||
            (id == CanonID_EOS_5DS_R)         ||
            (id == CanonID_EOS_6D)            ||
            (id == CanonID_EOS_6D_Mark_II))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_FF;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF;
   }
-  else if ((id == CanonID_EOS_M)         ||
-           (id == CanonID_EOS_M2)        ||
-           (id == CanonID_EOS_M3)        ||
-           (id == CanonID_EOS_M10)       ||
-           (id == CanonID_EOS_M5)        ||
-           (id == CanonID_EOS_M50)       ||
-           (id == CanonID_EOS_M6)        ||
-           (id == CanonID_EOS_M100)      ||
-           (id == CanonID_EOS_M6_Mark_II))
+  else if ((id == CanonID_EOS_M)             ||
+           (id == CanonID_EOS_M2)            ||
+           (id == CanonID_EOS_M3)            ||
+           (id == CanonID_EOS_M5)            ||
+           (id == CanonID_EOS_M10)           ||
+           (id == CanonID_EOS_M50)           ||
+           (id == CanonID_EOS_M50_Mark_II)   ||
+           (id == CanonID_EOS_M6)            ||
+           (id == CanonID_EOS_M6_Mark_II)    ||
+           (id == CanonID_EOS_M100))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF_M;
   }
   else if ((id == CanonID_EOS_R)  ||
            (id == CanonID_EOS_RP) ||
+           (id == CanonID_EOS_R3) ||
            (id == CanonID_EOS_R6) ||
            (id == CanonID_EOS_R5))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_FF;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_RF;
   }
   else if ((id == CanonID_EOS_D30) ||
            (id == CanonID_EOS_D60) ||
            (id > 0x80000000ULL))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF;
   }
 }
 
+int CanonCameraInfo_checkFirmwareRecordLocation (uchar *offset) {
+// firmware record location allows
+// to determine the subversion of the CameraInfo table
+// and to adjust offsets accordingly 
+  if (isdigit(*offset)   && 
+      isdigit(*offset+2) &&
+      isdigit(*offset+4) &&
+      (*(offset+1) == '.') &&
+      (*(offset+3) == '.') &&
+      (*(offset+5) == 0)) return 1;
+  else return 0; // error
+}
+
 void LibRaw::processCanonCameraInfo(unsigned long long id, uchar *CameraInfo,
                                     unsigned maxlen, unsigned type, unsigned dng_writer)
 {
   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0,
          iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0,
+         iMakernotesFlip = 0,
          iHTP = 0, iALO = 0;
+  short SubVersion_offset = 0;
+  ushort SubVersion = 0, mgck = 0;
 
   if (maxlen < 16)
     return; // too short
 
- if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
-     (sget2(CameraInfo) == 0xaaaa) && (dng_writer == nonDNG)) { // CameraOrientation
-    int c, i;
-    for (c = i = 2; (ushort)c != 0xbbbb && i < (int)maxlen; i++)
-      c = c << 8 | CameraInfo[i];
-    while (i < int(maxlen - 5))
-      if ((sget4(CameraInfo+i) == 257) && ((c = CameraInfo[i+8]) < 3)) {
-        imCanon.MakernotesFlip = "065"[c] - '0';
-        break;
-      } else i+=4;
-  }
-
+  mgck = sget2(CameraInfo);
   CameraInfo[0] = 0;
   CameraInfo[1] = 0;
   if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG)) {
     if ((maxlen == 94)  || (maxlen == 138) || (maxlen == 148) ||
         (maxlen == 156) || (maxlen == 162) || (maxlen == 167) ||
         (maxlen == 171) || (maxlen == 264) || (maxlen > 400))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 3) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 3) << 2)));
     else if (maxlen == 72)
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 1) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 1) << 2)));
     else if ((maxlen == 85) || (maxlen == 93))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 2) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 2) << 2)));
     else if ((maxlen == 96) || (maxlen == 104))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 4) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 4) << 2)));
   }
 
   switch (id)
   {
   case CanonID_EOS_1D:
   case CanonID_EOS_1Ds:
-    iCanonCurFocal = 10;
-    iCanonLensID = 13;
-    iCanonMinFocal = 14;
-    iCanonMaxFocal = 16;
+    iCanonCurFocal  =  0x0a;
+    iCanonLensID    =  0x0d;
+    iCanonMinFocal  =  0x0e;
+    iCanonMaxFocal  =  0x10;
     if (!ilm.CurFocal)
       ilm.CurFocal = sget2(CameraInfo + iCanonCurFocal);
     if (!ilm.MinFocal)
       ilm.MinFocal = sget2(CameraInfo + iCanonMinFocal);
     if (!ilm.MaxFocal)
       ilm.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);
     imCommon.CameraTemperature = 0.0f;
     break;
+
   case CanonID_EOS_1D_Mark_II:
   case CanonID_EOS_1Ds_Mark_II:
-    iCanonCurFocal = 9;
-    iCanonLensID = 12;
-    iCanonMinFocal = 17;
-    iCanonMaxFocal = 19;
-    iCanonFocalType = 45;
+    iCanonCurFocal  =  0x09;
+    iCanonLensID    =  0x0c;
+    iCanonMinFocal  =  0x11;
+    iCanonMaxFocal  =  0x13;
+    iCanonFocalType =  0x2d;
     break;
+
   case CanonID_EOS_1D_Mark_II_N:
-    iCanonCurFocal = 9;
-    iCanonLensID = 12;
-    iCanonMinFocal = 17;
-    iCanonMaxFocal = 19;
+    iCanonCurFocal  =  0x09;
+    iCanonLensID    =  0x0c;
+    iCanonMinFocal  =  0x11;
+    iCanonMaxFocal  =  0x13;
     break;
+
   case CanonID_EOS_1D_Mark_III:
   case CanonID_EOS_1Ds_Mark_III:
-    iCanonCurFocal = 29;
-    iCanonLensID = 273;
-    iCanonMinFocal = 275;
-    iCanonMaxFocal = 277;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    = 0x111;
+    iCanonMinFocal  = 0x113;
+    iCanonMaxFocal  = 0x115;
     break;
+
   case CanonID_EOS_1D_Mark_IV:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 335;
-    iCanonMinFocal = 337;
-    iCanonMaxFocal = 339;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1e8))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1ed))
+      SubVersion = 2;
+// printf ("==>> CanonID_EOS_1D_Mark_IV, SubVersion: %d\n", SubVersion);
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x35;
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 2)
+      SubVersion_offset += -1;
+
+    iCanonLensID    = 0x14f+SubVersion_offset;
+    iCanonMinFocal  = 0x151+SubVersion_offset;
+    iCanonMaxFocal  = 0x153+SubVersion_offset;
     break;
+
   case CanonID_EOS_1D_X:
-    iCanonCurFocal = 35;
-    iCanonLensID = 423;
-    iCanonMinFocal = 425;
-    iCanonMaxFocal = 427;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x271))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x279))
+      SubVersion = 2;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x280))
+      SubVersion = 3;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x285))
+      SubVersion = 4;
+// printf ("==>> CanonID_EOS_1D_X, SubVersion: %d\n", SubVersion);
+
+    if (SubVersion < 3)
+      SubVersion_offset += -3;
+
+    iCanonCurFocal  =  0x23+SubVersion_offset;
+    iMakernotesFlip =  0x7d+SubVersion_offset;
+
+    if (SubVersion < 3)
+      SubVersion_offset += -4;
+    else if (SubVersion == 4)
+      SubVersion_offset += 5;
+
+    iCanonLensID    = 0x1a7+SubVersion_offset;
+    iCanonMinFocal  = 0x1a9+SubVersion_offset;
+    iCanonMaxFocal  = 0x1ab+SubVersion_offset;
     break;
+
   case CanonID_EOS_5D:
-    iCanonCurFocal = 40;
-    if (!sget2Rev(CameraInfo + 12))
-      iCanonLensID = 151;
-    else
-      iCanonLensID = 12;
-    iCanonMinFocal = 147;
-    iCanonMaxFocal = 149;
+    iMakernotesFlip =  0x27;
+    iCanonCurFocal  =  0x28;
+    iCanonLensID    =  0x0c;
+    if (!sget2Rev(CameraInfo + iCanonLensID))
+      iCanonLensID  =  0x97;
+    iCanonMinFocal  =  0x93;
+    iCanonMaxFocal  =  0x95;
     break;
+
   case CanonID_EOS_5D_Mark_II:
-    iHTP = 7;
-    iALO = 191;
-    iCanonCurFocal = 30;
-    iCanonLensID = 230;
-    iCanonMinFocal = 232;
-    iCanonMaxFocal = 234;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbf;
+    iCanonLensID    =  0xe6;
+    iCanonMinFocal  =  0xe8;
+    iCanonMaxFocal  =  0xea;
     break;
+
   case CanonID_EOS_5D_Mark_III:
-    iCanonCurFocal = 35;
-    iCanonLensID = 339;
-    iCanonMinFocal = 341;
-    iCanonMaxFocal = 343;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x22c))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x22d))
+      SubVersion = 2;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x23c))
+      SubVersion = 3;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x242))
+      SubVersion = 4;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x247))
+      SubVersion = 5;
+// printf ("==>> CanonID_EOS_5D_Mark_III, SubVersion: %d\n", SubVersion);
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 3)
+      SubVersion_offset += -1;
+
+    iCanonCurFocal  =  0x23+SubVersion_offset;
+
+    if (SubVersion == 1)
+      SubVersion_offset += -3;
+    else if (SubVersion == 2)
+      SubVersion_offset += -2;
+    else if (SubVersion >= 4)
+      SubVersion_offset += 6;
+
+    iMakernotesFlip =  0x7d+SubVersion_offset;
+
+    if (SubVersion < 3)
+      SubVersion_offset += -4;
+    else if (SubVersion > 4)
+      SubVersion_offset += 5;
+
+    iCanonLensID    = 0x153+SubVersion_offset;
+    iCanonMinFocal  = 0x155+SubVersion_offset;
+    iCanonMaxFocal  = 0x157+SubVersion_offset;
     break;
+
   case CanonID_EOS_6D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 353;
-    iCanonMinFocal = 355;
-    iCanonMaxFocal = 357;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x83;
+    iCanonLensID    = 0x161;
+    iCanonMinFocal  = 0x163;
+    iCanonMaxFocal  = 0x165;
     break;
+
   case CanonID_EOS_7D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 274;
-    iCanonMinFocal = 276;
-    iCanonMaxFocal = 278;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1a8))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1ac))
+      SubVersion = 2;
+// printf ("==>> CanonID_EOS_7D, SubVersion: %d\n", SubVersion);
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 2)
+      SubVersion_offset += -4;
+
+    iMakernotesFlip =  0x35+SubVersion_offset;
+    iCanonLensID    = 0x112+SubVersion_offset;
+    iCanonMinFocal  = 0x114+SubVersion_offset;
+    iCanonMaxFocal  = 0x116+SubVersion_offset;
     break;
+
   case CanonID_EOS_40D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 214;
-    iCanonMinFocal = 216;
-    iCanonMaxFocal = 218;
-    iCanonLens = 2347;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xd6;
+    iCanonMinFocal  =  0xd8;
+    iCanonMaxFocal  =  0xda;
+    iCanonLens      = 0x92b;
     break;
+
   case CanonID_EOS_50D:
-    iHTP = 7;
-    iALO = 191;
-    iCanonCurFocal = 30;
-    iCanonLensID = 234;
-    iCanonMinFocal = 236;
-    iCanonMaxFocal = 238;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbf;
+    iCanonLensID    =  0xea;
+    iCanonMinFocal  =  0xec;
+    iCanonMaxFocal  =  0xee;
     break;
+
   case CanonID_EOS_60D:
-    iCanonCurFocal = 30;
-    iCanonLensID = 232;
-    iCanonMinFocal = 234;
-    iCanonMaxFocal = 236;
+  case CanonID_EOS_1200D:
+    iCanonCurFocal  =  0x1e;
+    if (id == CanonID_EOS_60D)
+      iMakernotesFlip =  0x36;
+    else
+      iMakernotesFlip =  0x3a;
+    iCanonLensID    =  0xe8;
+    iCanonMinFocal  =  0xea;
+    iCanonMaxFocal  =  0xec;
     break;
+
   case CanonID_EOS_70D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 358;
-    iCanonMinFocal = 360;
-    iCanonMaxFocal = 362;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x84;
+    iCanonLensID    = 0x166;
+    iCanonMinFocal  = 0x168;
+    iCanonMaxFocal  = 0x16a;
     break;
+
+  case CanonID_EOS_80D:
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x96;
+    iCanonLensID    = 0x189;
+    iCanonMinFocal  = 0x18b;
+    iCanonMaxFocal  = 0x18d;
+    break;
+
   case CanonID_EOS_450D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 222;
-    iCanonLens = 2355;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xde;
+    iCanonLens      = 0x933;
     break;
+
   case CanonID_EOS_500D:
-    iHTP = 7;
-    iALO = 190;
-    iCanonCurFocal = 30;
-    iCanonLensID = 246;
-    iCanonMinFocal = 248;
-    iCanonMaxFocal = 250;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbe;
+    iCanonLensID    =  0xf6;
+    iCanonMinFocal  =  0xf8;
+    iCanonMaxFocal  =  0xfa;
     break;
+
   case CanonID_EOS_550D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 255;
-    iCanonMinFocal = 257;
-    iCanonMaxFocal = 259;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x35;
+    iCanonLensID    =  0xff;
+    iCanonMinFocal  = 0x101;
+    iCanonMaxFocal  = 0x103;
     break;
+
   case CanonID_EOS_600D:
   case CanonID_EOS_1100D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 234;
-    iCanonMinFocal = 236;
-    iCanonMaxFocal = 238;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x38;
+    iCanonLensID    =  0xea;
+    iCanonMinFocal  =  0xec;
+    iCanonMaxFocal  =  0xee;
     break;
+
   case CanonID_EOS_650D:
   case CanonID_EOS_700D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 295;
-    iCanonMinFocal = 297;
-    iCanonMaxFocal = 299;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x7d;
+    iCanonLensID    = 0x127;
+    iCanonMinFocal  = 0x129;
+    iCanonMaxFocal  = 0x12b;
+    break;
+
+  case CanonID_EOS_750D:
+  case CanonID_EOS_760D:
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x96;
+    iCanonLensID    = 0x184;
+    iCanonMinFocal  = 0x186;
+    iCanonMaxFocal  = 0x188;
     break;
+
   case CanonID_EOS_1000D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 226;
-    iCanonMinFocal = 228;
-    iCanonMaxFocal = 230;
-    iCanonLens = 2359;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xe2;
+    iCanonMinFocal  =  0xe4;
+    iCanonMaxFocal  =  0xe6;
+    iCanonLens      = 0x937;
     break;
   }
+
+  if (iMakernotesFlip && (CameraInfo[iMakernotesFlip] < 3)) {
+    imCanon.MakernotesFlip = "065"[CameraInfo[iMakernotesFlip]] - '0';
+// printf ("==>> iMakernotesFlip: 0x%x, flip: %d\n", iMakernotesFlip, imCanon.MakernotesFlip);
+  } else if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
+     (mgck == 0xaaaa) && (dng_writer == nonDNG)) { // CameraOrientation
+    int c, i;
+    for (i = 2; (sget2(CameraInfo+i) != 0xbbbb) && i < (int)maxlen; i++);
+    i+=2;
+    while (i < int(maxlen - 5))
+      if ((sget4(CameraInfo+i) == 257) && ((c = CameraInfo[i+8]) < 3)) {
+        imCanon.MakernotesFlip = "065"[c] - '0';
+// printf ("==>> MakernotesFlip offset: 0x%x, flip: %d\n", i+8, imCanon.MakernotesFlip);
+        break;
+      } else i+=4;
+  }
+
   if (iHTP)
   {
     imCanon.HighlightTonePriority = CameraInfo[iHTP];
     if ((imCanon.HighlightTonePriority > 5) ||
         (imCanon.HighlightTonePriority < 0))
       imCanon.HighlightTonePriority = 0;
     if (imCanon.HighlightTonePriority) {
       imCommon.ExposureCalibrationShift -= float(imCanon.HighlightTonePriority);
     }
   }
   if (iALO)
   {
     imCanon.AutoLightingOptimizer = CameraInfo[iALO];
     if ((imCanon.AutoLightingOptimizer > 3) ||
         (imCanon.AutoLightingOptimizer < 0))
       imCanon.AutoLightingOptimizer = 3;
   }
   if (iCanonFocalType)
   {
     if (iCanonFocalType >= maxlen)
       return; // broken;
     ilm.FocalType = CameraInfo[iCanonFocalType];
     if (!ilm.FocalType) // zero means 'prime' here, replacing with standard '1'
       ilm.FocalType = LIBRAW_FT_PRIME_LENS;
   }
-  if (!ilm.CurFocal)
+  if (!ilm.CurFocal && iCanonCurFocal)
   {
     if (iCanonCurFocal >= maxlen)
       return; // broken;
     ilm.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);
   }
-  if (!ilm.LensID)
+  if (!ilm.LensID && iCanonLensID)
   {
     if (iCanonLensID >= maxlen)
       return; // broken;
     ilm.LensID = sget2Rev(CameraInfo + iCanonLensID);
   }
-  if (!ilm.MinFocal)
+  if (!ilm.MinFocal && iCanonMinFocal)
   {
     if (iCanonMinFocal >= maxlen)
       return; // broken;
     ilm.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);
   }
-  if (!ilm.MaxFocal)
+  if (!ilm.MaxFocal && iCanonMaxFocal)
   {
     if (iCanonMaxFocal >= maxlen)
       return; // broken;
     ilm.MaxFocal = sget2Rev(CameraInfo + iCanonMaxFocal);
   }
   if (!ilm.Lens[0] && iCanonLens)
   {
     if (iCanonLens + 64 >= (int)maxlen) // broken;
       return;
 
     char *pl = (char *)CameraInfo + iCanonLens;
     if (!strncmp(pl, "EF-S", 4))
     {
       memcpy(ilm.Lens, pl, 4);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, pl, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF_S;
       ilm.LensFormat = LIBRAW_FORMAT_APSC;
       memcpy(ilm.Lens + 5, pl + 4, 60);
     }
     else if (!strncmp(pl, "EF-M", 4))
     {
       memcpy(ilm.Lens, pl, 4);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, pl, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF_M;
       ilm.LensFormat = LIBRAW_FORMAT_APSC;
       memcpy(ilm.Lens + 5, pl + 4, 60);
     }
     else if (!strncmp(pl, "EF", 2))
     {
       memcpy(ilm.Lens, pl, 2);
       ilm.Lens[2] = ' ';
       memcpy(ilm.LensFeatures_pre, pl, 2);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
       memcpy(ilm.Lens + 3, pl + 2, 62);
     }
     else if (!strncmp(ilm.Lens, "CN-E", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
     else if (!strncmp(pl, "TS-E", 4))
     {
       memcpy(ilm.Lens, pl, 4);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, pl, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
       memcpy(ilm.Lens + 5, pl + 4, 60);
     }
     else if (!strncmp(pl, "MP-E", 4))
     {
       memcpy(ilm.Lens, pl, 4);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, pl, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
       memcpy(ilm.Lens + 5, pl + 4, 60);
     }
     else // non-Canon lens
       memcpy(ilm.Lens, pl, 64);
   }
   return;
 }
@@ -557,572 +720,572 @@ void LibRaw::Canon_WBCTpresets(short WBCTversion)
 void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, unsigned dng_writer)
 {
 
 #define AsShot_Auto_MeasuredWB(offset)                       \
   imCanon.ColorDataSubVer = get2();                          \
   fseek(ifp, save1 + (offset << 1), SEEK_SET);               \
   FORC4 cam_mul[RGGB_2_RGBG(c)] = (float)get2();             \
   get2();                                                    \
   FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();     \
   get2();                                                    \
   FORC4 icWBC[LIBRAW_WBI_Measured][RGGB_2_RGBG(c)] = get2();
 
+#define sRAW_WB(offset)                                      \
+  fseek(ifp, save1 + (offset << 1), SEEK_SET);               \
+  FORC4 {                                                    \
+    sraw_mul[RGGB_2_RGBG(c)] = get2();                       \
+    if ((float)sraw_mul[RGGB_2_RGBG(c)] > sraw_mul_max) {    \
+      sraw_mul_max = (float)sraw_mul[RGGB_2_RGBG(c)];        \
+    }                                                        \
+  }                                                          \
+  sraw_mul_max /= 1024.f;                                    \
+  FORC4 sraw_mul[c] = (ushort)((float)sraw_mul[c] * sraw_mul_max);
+
 #define CR3_ColorData(offset)                                \
   fseek(ifp, save1 + ((offset+0x0041) << 1), SEEK_SET);      \
   Canon_WBpresets(2, 12);                                    \
   fseek(ifp, save1 + ((offset+0x00c3) << 1), SEEK_SET);      \
   Canon_WBCTpresets(0);                                      \
   offsetChannelBlackLevel2 = save1 + ((offset+0x0102) << 1); \
   offsetChannelBlackLevel  = save1 + ((offset+0x02d1) << 1); \
   offsetWhiteLevels        = save1 + ((offset+0x02d5) << 1);
 
   int c;
   unsigned i;
 
   if (tag == 0x0001) {
     Canon_CameraSettings(len);
 
   } else if (tag == 0x0002) { // focal length
     ilm.FocalType = get2();
     ilm.CurFocal = get2();
     if (ilm.FocalUnits > 1) {
       ilm.CurFocal /= (float)ilm.FocalUnits;
     }
 
   } else if (tag == 0x0004) { // subdir, ShotInfo
     short tempAp;
     if (dng_writer == nonDNG) {
       get2();
       imCanon.ISOgain[0] = get2();
       imCanon.ISOgain[1] = get2();
       if (imCanon.ISOgain[1] != 0x7fff) {
-        imCommon.real_ISO = int(100.0 * libraw_powf64l(2.0, double(imCanon.ISOgain[0]+imCanon.ISOgain[1]) / 32.0 - 5.0));
+        imCommon.real_ISO = floorf(100.f * libraw_powf64l(2.f, float(imCanon.ISOgain[0]+imCanon.ISOgain[1]) / 32.f - 5.f));
         if (!iso_speed || (iso_speed == 65535))
           iso_speed = imCommon.real_ISO;
       }
       get4();
       if (((i = get2()) != 0xffff) && !shutter) {
-        shutter = libraw_powf64l(2.0, (short)i / -32.0);
+        shutter = libraw_powf64l(2.f, float((short)i) / -32.0f);
       }
       imCanon.wbi = (get2(), get2());
       shot_order = (get2(), get2());
       fseek(ifp, 4, SEEK_CUR);
     } else
       fseek(ifp, 24, SEEK_CUR);
     tempAp = get2();
     if (tempAp != 0)
       imCommon.CameraTemperature = (float)(tempAp - 128);
     tempAp = get2();
     if (tempAp != -1)
       imCommon.FlashGN = ((float)tempAp) / 32;
     get2();
 
     imCommon.FlashEC = _CanonConvertEV((signed short)get2());
     fseek(ifp, 8 - 32, SEEK_CUR);
     if ((tempAp = get2()) != 0x7fff)
       ilm.CurAp = _CanonConvertAperture(tempAp);
     if (ilm.CurAp < 0.7f) {
       fseek(ifp, 32, SEEK_CUR);
       ilm.CurAp = _CanonConvertAperture(get2());
     }
     if (!aperture)
       aperture = ilm.CurAp;
 
   } else if ((tag == 0x0007) && (dng_writer == nonDNG)) {
     fgets(model2, 64, ifp);
 
   } else if ((tag == 0x0008) && (dng_writer == nonDNG)) {
     shot_order = get4();
 
   } else if ((tag == 0x0009)  && (dng_writer == nonDNG)) {
     fread(artist, 64, 1, ifp);
 
   } else if (tag == 0x000c) {
     unsigned tS = get4();
     sprintf(imgdata.shootinginfo.BodySerial, "%d", tS);
 
   } else if ((tag == 0x0012) ||
              (tag == 0x0026) ||
              (tag == 0x003c)) {
     if (!imCommon.afcount) {
       imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
       imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
       imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
       imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
       fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
       imCommon.afcount = 1;
     }
 
   } else if ((tag == 0x0029) && (dng_writer == nonDNG)) { // PowerShot G9
     int Got_AsShotWB = 0;
     fseek(ifp, 8, SEEK_CUR);
-    for (int linenum = 0; linenum < Canon_G9_linenums_2_StdWBi.size(); linenum++) {
+    for (unsigned linenum = 0; linenum < Canon_G9_linenums_2_StdWBi.size(); linenum++) {
       if (Canon_G9_linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown ) {
         FORC4 icWBC[Canon_G9_linenums_2_StdWBi[linenum]][GRBG_2_RGBG(c)] = get4();
         if (Canon_wbi2std[imCanon.wbi] == Canon_G9_linenums_2_StdWBi[linenum]) {
-          FORC4 cam_mul[c] = icWBC[Canon_G9_linenums_2_StdWBi[linenum]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_G9_linenums_2_StdWBi[linenum]][c]);
           Got_AsShotWB = 1;
         }
       }
       fseek(ifp, 16, SEEK_CUR);
     }
     if (!Got_AsShotWB)
-      FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+      FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
 
   } else if ((tag == 0x0081) && (dng_writer == nonDNG)) { // -1D, -1Ds
     data_offset = get4();
     fseek(ifp, data_offset + 41, SEEK_SET);
     raw_height = get2() * 2;
     raw_width = get2();
     filters = 0x61616161;
 
   } else if (tag == 0x0093) {
     if (!imCanon.RF_lensID) {
       fseek(ifp, 0x03d<<1, SEEK_CUR);
       imCanon.RF_lensID = get2();
     }
 
   } else if (tag == 0x0095 && !ilm.Lens[0])
   { // lens model tag
     fread(ilm.Lens, 64, 1, ifp);
     if (!strncmp(ilm.Lens, "EF-S", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF_S;
       ilm.LensFormat = LIBRAW_FORMAT_APSC;
     }
     else if (!strncmp(ilm.Lens, "EF-M", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF_M;
       ilm.LensFormat = LIBRAW_FORMAT_APSC;
     }
     else if (!strncmp(ilm.Lens, "EF", 2))
     {
       memmove(ilm.Lens + 3, ilm.Lens + 2, 62);
       ilm.Lens[2] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 2);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
     else if (!strncmp(ilm.Lens, "CN-E", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
     else if (!strncmp(ilm.Lens, "TS-E", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
     else if (!strncmp(ilm.Lens, "MP-E", 4))
     {
       memmove(ilm.Lens + 5, ilm.Lens + 4, 60);
       ilm.Lens[4] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 4);
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
     else if (!strncmp(ilm.Lens, "RF", 2))
     {
       memmove(ilm.Lens + 3, ilm.Lens + 2, 62);
       ilm.Lens[2] = ' ';
       memcpy(ilm.LensFeatures_pre, ilm.Lens, 2);
       ilm.LensMount = LIBRAW_MOUNT_Canon_RF;
       ilm.LensFormat = LIBRAW_FORMAT_FF;
     }
   }
   else if (tag == 0x009a)
   { // AspectInfo
     i = get4();
     switch (i)
     {
     case 0:
     case 12: /* APS-H crop */
     case 13: /* APS-C crop */
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 1:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 2:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 7:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 8:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
       break;
     default:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
       break;
     }
-    imgdata.sizes.raw_inset_crop.cwidth = get4();
-    imgdata.sizes.raw_inset_crop.cheight = get4();
-    imgdata.sizes.raw_inset_crop.cleft = get4();
-    imgdata.sizes.raw_inset_crop.ctop = get4();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get4();
+    imgdata.sizes.raw_inset_crops[0].cheight = get4();
+    imgdata.sizes.raw_inset_crops[0].cleft = get4();
+    imgdata.sizes.raw_inset_crops[0].ctop = get4();
 
   } else if ((tag == 0x00a4) && (dng_writer == nonDNG)) { // -1D, -1Ds
     fseek(ifp, imCanon.wbi * 48, SEEK_CUR);
     FORC3 cam_mul[c] = get2();
 
   } else if (tag == 0x00a9) {
-    long int save1 = ftell(ifp);
+    INT64 save1 = ftell(ifp);
     fseek(ifp, (0x1 << 1), SEEK_CUR);
     FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
     Canon_WBpresets(0, 0);
     fseek(ifp, save1, SEEK_SET);
   }
   else if (tag == 0x00b4)
   {
     switch (get2()) {
     case 1:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
       break;
     case 2:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
       break;
     default:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
       break;
     }
   }
-  else if (tag == 0x00e0)
-  { // SensorInfo
-    imCanon.SensorWidth = (get2(), get2());
+  else if (tag == 0x00e0) // SensorInfo
+  {
+    imCanon.SensorWidth  = (get2(), get2());
     imCanon.SensorHeight = get2();
-    imCanon.SensorLeftBorder = (get2(), get2(), get2());
-    imCanon.SensorTopBorder = get2();
-    imCanon.SensorRightBorder = get2();
-    imCanon.SensorBottomBorder = get2();
-    imCanon.BlackMaskLeftBorder = get2();
-    imCanon.BlackMaskTopBorder = get2();
-    imCanon.BlackMaskRightBorder = get2();
-    imCanon.BlackMaskBottomBorder = get2();
+    fseek(ifp, 4, SEEK_CUR);
+    imCanon.DefaultCropAbsolute = get_CanonArea();
+    imCanon.LeftOpticalBlack    = get_CanonArea();
   }
   else if (tag == 0x4001 && len > 500)
   {
+    float sraw_mul_max = 0.f;
     int bls = 0;
-    long int offsetChannelBlackLevel = 0L;
-    long int offsetChannelBlackLevel2 = 0L;
-    long int offsetWhiteLevels = 0L;
-    long int save1 = ftell(ifp);
+    INT64 offsetChannelBlackLevel = 0L;
+    INT64 offsetChannelBlackLevel2 = 0L;
+    INT64 offsetWhiteLevels = 0L;
+    INT64 save1 = ftell(ifp);
 
     switch (len)
     {
 
     case 582:
       imCanon.ColorDataVer = 1; // 20D, 350D
 
       fseek(ifp, save1 + (0x0019 << 1), SEEK_SET);
       FORC4 cam_mul[RGGB_2_RGBG(c)] = (float)get2();
       fseek(ifp, save1 + (0x001e << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0041 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom1][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0046 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom2][RGGB_2_RGBG(c)] = get2();
 
       fseek(ifp, save1 + (0x0023 << 1), SEEK_SET);
       Canon_WBpresets(2, 2);
       fseek(ifp, save1 + (0x004b << 1), SEEK_SET);
       Canon_WBCTpresets(1); // ABCT
       offsetChannelBlackLevel = save1 + (0x00a6 << 1);
       break;
 
     case 653:
       imCanon.ColorDataVer = 2; // -1D Mark II, -1Ds Mark II
 
       fseek(ifp, save1 + (0x0018 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0022 << 1), SEEK_SET);
       FORC4 cam_mul[RGGB_2_RGBG(c)] = (float)get2();
       fseek(ifp, save1 + (0x0090 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom1][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0095 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom2][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x009a << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom3][RGGB_2_RGBG(c)] = get2();
 
       fseek(ifp, save1 + (0x0027 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00a4 << 1), SEEK_SET);
       Canon_WBCTpresets(1); // ABCT
       offsetChannelBlackLevel = save1 + (0x011e << 1);
       break;
 
     case 796:
       imCanon.ColorDataVer = 3; // -1D Mark II N, 5D, 30D, 400D; ColorDataSubVer: 1
       AsShot_Auto_MeasuredWB(0x003f);
 
       fseek(ifp, save1 + (0x0071 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom1][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0076 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom2][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x007b << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom3][RGGB_2_RGBG(c)] = get2();
       fseek(ifp, save1 + (0x0080 << 1), SEEK_SET);
       FORC4 icWBC[LIBRAW_WBI_Custom][RGGB_2_RGBG(c)] = get2();
 
       fseek(ifp, save1 + (0x004e << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x0085 << 1), SEEK_SET);
       Canon_WBCTpresets(0); // BCAT
       offsetChannelBlackLevel = save1 + (0x00c4 << 1);
       break;
 
     case 674:  // -1D Mark III; ColorDataSubVer: 2
     case 692:  // 40D; ColorDataSubVer: 3
     case 702:  // -1Ds Mark III; ColorDataSubVer: 4
     case 1227: // 450D, 1000D; ColorDataSubVer: 5
     case 1250: // 5D Mark II, 50D; ColorDataSubVer: 6
     case 1251: // 500D; ColorDataSubVer: 7
     case 1337: // -1D Mark IV, 7D; ColorDataSubVer: 7
     case 1338: // 550D; ColorDataSubVer: 7
     case 1346: // 1100D, 60D; ColorDataSubVer: 9
       imCanon.ColorDataVer = 4;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x004e << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x004e);
       fseek(ifp, save1 + (0x0053 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00a8 << 1), SEEK_SET);
       Canon_WBCTpresets(0); // BCAT
 
       if ((imCanon.ColorDataSubVer == 4) ||
           (imCanon.ColorDataSubVer == 5))
       {
         offsetChannelBlackLevel = save1 + (0x02b4 << 1);
         offsetWhiteLevels = save1 + (0x02b8 << 1);
       }
       else if ((imCanon.ColorDataSubVer == 6) ||
                (imCanon.ColorDataSubVer == 7))
       {
         offsetChannelBlackLevel = save1 + (0x02cb << 1);
         offsetWhiteLevels = save1 + (0x02cf << 1);
       }
       else if (imCanon.ColorDataSubVer == 9)
       {
         offsetChannelBlackLevel = save1 + (0x02cf << 1);
         offsetWhiteLevels = save1 + (0x02d3 << 1);
       }
       else
         offsetChannelBlackLevel = save1 + (0x00e7 << 1);
       break;
 
     case 5120: // G10, G11, G12, G15, G16
                // G1 X, G1 X Mark II, G1 X Mark III
                // G3 X, G5 X
                // G7 X, G7 X Mark II
                // G9 X, G9 X Mark II
                // S90, S95, S100, S100V, S110, S120
                // SX1 IS, SX50 HS, SX60 HS
                // M3, M5, M6, M10, M100
       imCanon.ColorDataVer = 5;
       imCanon.ColorDataSubVer = get2();
 
       fseek(ifp, save1 + (0x0047 << 1), SEEK_SET);
       FORC4 cam_mul[RGGB_2_RGBG(c)] = (float)get2();
 
       if (imCanon.ColorDataSubVer == 0xfffc) // ColorDataSubVer: 65532 (-4)
                                              // G7 X Mark II, G9 X Mark II, G1 X Mark III
                                              // M5, M100, M6
       {
         fseek(ifp, save1 + (0x004f << 1), SEEK_SET);
         FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
         fseek(ifp, 8, SEEK_CUR);
         FORC4 icWBC[LIBRAW_WBI_Measured][RGGB_2_RGBG(c)] =
             get2();
         fseek(ifp, 8, SEEK_CUR);
         FORC4 icWBC[LIBRAW_WBI_Other][RGGB_2_RGBG(c)] = get2();
         fseek(ifp, 8, SEEK_CUR);
         Canon_WBpresets(8, 24);
         fseek(ifp, 168, SEEK_CUR);
         FORC4 icWBC[LIBRAW_WBI_FL_WW][RGGB_2_RGBG(c)] = get2();
         fseek(ifp, 24, SEEK_CUR);
         Canon_WBCTpresets(2); // BCADT
         offsetChannelBlackLevel = save1 + (0x014d << 1);
         offsetWhiteLevels = save1 + (0x0569 << 1);
       }
       else if (imCanon.ColorDataSubVer == 0xfffd) // ColorDataSubVer: 65533 (-3)
                                                   // M10, M3
                                                   // G1 X, G1 X Mark II
                                                   // G3 X, G5 X, G7 X, G9 X
                                                   // G10, G11, G12, G15, G16
                                                   // S90, S95, S100, S100V, S110, S120
                                                   // SX1 IS, SX50 HS, SX60 HS
       {
         fseek(ifp, save1 + (0x004c << 1), SEEK_SET);
         FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
         get2();
         FORC4 icWBC[LIBRAW_WBI_Measured][RGGB_2_RGBG(c)] =
             get2();
         get2();
         FORC4 icWBC[LIBRAW_WBI_Other][RGGB_2_RGBG(c)] = get2();
         get2();
         Canon_WBpresets(2, 12);
         fseek(ifp, save1 + (0x00ba << 1), SEEK_SET);
         Canon_WBCTpresets(2); // BCADT
         offsetChannelBlackLevel = save1 + (0x0108 << 1);
       }
       break;
 
     case 1273: // 600D; ColorDataSubVer: 10
     case 1275: // 1200D; ColorDataSubVer: 10
       imCanon.ColorDataVer = 6;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x0062 << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x0062);
       fseek(ifp, save1 + (0x0067 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00bc << 1), SEEK_SET);
       Canon_WBCTpresets(0); // BCAT
       offsetChannelBlackLevel = save1 + (0x01df << 1);
       offsetWhiteLevels = save1 + (0x01e3 << 1);
       break;
 
     case 1312: // 5D Mark III, 650D, 700D, M; ColorDataSubVer: 10
     case 1313: // 100D, 6D, 70D, EOS M2; ColorDataSubVer: 10
     case 1316: // -1D C, -1D X; ColorDataSubVer: 10
     case 1506: // 750D, 760D, 7D Mark II; ColorDataSubVer: 11
       imCanon.ColorDataVer = 7;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x007b << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x007b);
       fseek(ifp, save1 + (0x0080 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00d5 << 1), SEEK_SET);
       Canon_WBCTpresets(0); // BCAT
 
       if (imCanon.ColorDataSubVer == 10)
       {
         offsetChannelBlackLevel = save1 + (0x01f8 << 1);
         offsetWhiteLevels = save1 + (0x01fc << 1);
       }
       else if (imCanon.ColorDataSubVer == 11)
       {
         offsetChannelBlackLevel = save1 + (0x02d8 << 1);
         offsetWhiteLevels = save1 + (0x02dc << 1);
       }
       break;
 
     case 1560: // 5DS, 5DS R; ColorDataSubVer: 12
     case 1592: // 5D Mark IV, 80D, -1D X Mark II; ColorDataSubVer: 13
     case 1353: // 1300D, 1500D, 3000D; ColorDataSubVer: 14
     case 1602: // 200D, 6D Mark II, 77D, 800D; ColorDataSubVer: 15
       imCanon.ColorDataVer = 8;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x0080 << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x0080);
       fseek(ifp, save1 + (0x0085 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x0107 << 1), SEEK_SET);
       Canon_WBCTpresets(0); // BCAT
 
       if (imCanon.ColorDataSubVer == 14) // 1300D, 1500D, 3000D
       {
         offsetChannelBlackLevel = save1 + (0x022c << 1);
         offsetWhiteLevels = save1 + (0x0230 << 1);
       }
       else
       {
         offsetChannelBlackLevel = save1 + (0x030a << 1);
         offsetWhiteLevels = save1 + (0x030e << 1);
       }
       break;
 
     case 1820: // M50; ColorDataSubVer: 16
     case 1824: // R; ColorDataSubVer: 17
     case 1816: // RP, 250D, SX70 HS; ColorDataSubVer: 18
                // M6 Mark II, M200, 90D, G5 X Mark II, G7 X Mark III, 850D; ColorDataSubVer: 19
       imCanon.ColorDataVer = 9;
       AsShot_Auto_MeasuredWB(0x0047);
       CR3_ColorData(0x0047);
       break;
 
     case 2024: // -1D X Mark III; ColorDataSubVer: 32
     case 3656: // R5, R6; ColorDataSubVer: 33
       imCanon.ColorDataVer = 10;
       AsShot_Auto_MeasuredWB(0x0055);
       CR3_ColorData(0x0055);
       break;
 
    default:
       imCanon.ColorDataSubVer = get2();
       break;
     }
 
     if (offsetChannelBlackLevel)
     {
       fseek(ifp, offsetChannelBlackLevel, SEEK_SET);
       FORC4
         bls += (imCanon.ChannelBlackLevel[RGGB_2_RGBG(c)] = get2());
       imCanon.AverageBlackLevel = bls / 4;
     }
     if (offsetWhiteLevels)
     {
       if ((offsetWhiteLevels - offsetChannelBlackLevel) != 8L)
         fseek(ifp, offsetWhiteLevels, SEEK_SET);
       imCanon.NormalWhiteLevel = get2();
       imCanon.SpecularWhiteLevel = get2();
       FORC4
         imgdata.color.linear_max[c] = imCanon.SpecularWhiteLevel;
     }
 
     if(!imCanon.AverageBlackLevel && offsetChannelBlackLevel2)
     {
         fseek(ifp, offsetChannelBlackLevel2, SEEK_SET);
         FORC4
             bls += (imCanon.ChannelBlackLevel[RGGB_2_RGBG(c)] = get2());
         imCanon.AverageBlackLevel = bls / 4;
     }
     fseek(ifp, save1, SEEK_SET);
 
   } else if (tag == 0x4013) {
     get4();
     imCanon.AFMicroAdjMode = get4();
-    float a = get4();
-    float b = get4();
+    float a = float(get4());
+    float b = float(get4());
     if (fabsf(b) > 0.001f)
       imCanon.AFMicroAdjValue = a / b;
 
   } else if (tag == 0x4018) {
     fseek(ifp, 8, SEEK_CUR);
     imCanon.AutoLightingOptimizer = get4();
     if ((imCanon.AutoLightingOptimizer > 3) ||
         (imCanon.AutoLightingOptimizer < 0))
       imCanon.AutoLightingOptimizer = 3;
     imCanon.HighlightTonePriority = get4();
     if ((imCanon.HighlightTonePriority > 5) ||
         (imCanon.HighlightTonePriority < 0))
       imCanon.HighlightTonePriority = 0;
     if (imCanon.HighlightTonePriority) {
       imCommon.ExposureCalibrationShift -= float(imCanon.HighlightTonePriority);
     }
 
   } else if ((tag == 0x4021) && (dng_writer == nonDNG) &&
              (imCanon.multishot[0] = get4()) &&
              (imCanon.multishot[1] = get4())) {
     if (len >= 4) {
       imCanon.multishot[2] = get4();
       imCanon.multishot[3] = get4();
     }
     FORC4 cam_mul[c] = 1024;
   }
 #undef CR3_ColorData
+#undef sRAW_WB
 #undef AsShot_Auto_MeasuredWB
 }
diff --git a/src/metadata/ciff.cpp b/src/metadata/ciff.cpp
index 3f3322da..2c59b11e 100644
--- a/src/metadata/ciff.cpp
+++ b/src/metadata/ciff.cpp
@@ -57,350 +57,346 @@ void LibRaw::ciff_block_1030()
 /*
    Parse a CIFF file, better known as Canon CRW format.
  */
 void LibRaw::parse_ciff(int offset, int length, int depth)
 {
-  int tboff, nrecs, c, type, len, save, wbi = -1;
+  int nrecs, c, type, len, wbi = -1;
+  INT64 save, tboff;
   ushort key[] = {0x410, 0x45f3};
   ushort CanonColorInfo1_key;
   ushort Appendix_A = 0;
   INT64 WB_table_offset = 0;
   int UseWBfromTable_as_AsShot = 1;
   int Got_AsShotWB = 0;
   INT64 fsize = ifp->size();
   if (metadata_blocks++ > LIBRAW_MAX_METADATA_BLOCKS)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
   fseek(ifp, offset + length - 4, SEEK_SET);
-  tboff = get4() + offset;
+  tboff = INT64(get4()) + offset;
   fseek(ifp, tboff, SEEK_SET);
   nrecs = get2();
   if (nrecs < 1)
     return;
   if ((nrecs | depth) > 127)
     return;
 
   if (nrecs * 10 + offset > fsize)
     return;
 
   while (nrecs--)
   {
     type = get2();
     len = get4();
     INT64 see = offset + get4();
     save = ftell(ifp);
 
     /* the following tags are not sub-tables
      * they contain the value in the "len" field
      * for such tags skip the check against filesize
      */
     if ((type != 0x2007) && (type != 0x580b) && (type != 0x501c) &&
         (type != 0x5029) && (type != 0x5813) && (type != 0x5814) &&
         (type != 0x5817) && (type != 0x5834) && (type != 0x580e))
     {
 
       if (see >= fsize)
       { // At least one byte
         fseek(ifp, save, SEEK_SET);
         continue;
       }
       fseek(ifp, see, SEEK_SET);
       if ((((type >> 8) + 8) | 8) == 0x38)
       {
         parse_ciff(ftell(ifp), len, depth + 1); /* Parse a sub-table */
       }
     }
 
     if (type == 0x3004)
     {
       parse_ciff(ftell(ifp), len, depth + 1);
     }
     else if (type == 0x0810)
     {
       fread(artist, 64, 1, ifp);
     }
     else if (type == 0x080a)
     {
       fread(make, 64, 1, ifp);
       fseek(ifp, strbuflen(make) - 63, SEEK_CUR);
       fread(model, 64, 1, ifp);
 
     } else if (type == 0x080b) {
       stmread(imCommon.firmware, (unsigned)len, ifp);
       if (!strncasecmp(imCommon.firmware, "Firmware Version", 16))
         memmove(imCommon.firmware, imCommon.firmware + 16, strlen(imCommon.firmware) - 15);
       trimSpaces(imCommon.firmware);
 
     } else if (type == 0x1810)
     {
       width = get4();
       height = get4();
       pixel_aspect = int_to_float(get4());
       flip = get4();
     }
     else if (type == 0x1835)
     { /* Get the decoder table */
       tiff_compress = get4();
     }
     else if (type == 0x2007)
     {
       thumb_offset = see;
       thumb_length = len;
     }
     else if (type == 0x1818)
     {
       shutter = libraw_powf64l(2.0f, -int_to_float((get4(), get4())));
       ilm.CurAp = aperture = libraw_powf64l(2.0f, int_to_float(get4()) / 2);
     }
     else if (type == 0x102a) // CanonShotInfo
     {
       //      iso_speed = pow (2.0, (get4(),get2())/32.0 - 4) * 50;
       get2(); // skip one
       iso_speed =
           libraw_powf64l(2.0f, (get2() + get2()) / 32.0f - 5.0f) * 100.0f;
       ilm.CurAp = aperture = _CanonConvertAperture((get2(), get2()));
-      shutter = libraw_powf64l(2.0, -((short)get2()) / 32.0);
+      shutter = libraw_powf64l(2.0f, -float((short)get2()) / 32.f);
       imCanon.wbi = wbi = (get2(), get2());
-      if (wbi >= Canon_wbi2std.size())
+      if (wbi >= (int)Canon_wbi2std.size())
         wbi = 0;
       fseek(ifp, 32, SEEK_CUR);
       if (shutter > 1e6)
-        shutter = get2() / 10.0;
+        shutter = float(get2()) / 10.f;
     }
     else if (type == 0x102c) // CanonColorInfo2 / Appendix A: Pro90IS, G1, G2, S30, S40
     {
       int CanonColorInfo2_type = get2(); // G1 1028, G2 272, Pro90 IS 769, S30 274, S40 273, EOS D30 276
       if (CanonColorInfo2_type > 512) { /* Pro90 IS, G1 */
         fseek(ifp, 118, SEEK_CUR);
         FORC4 cam_mul[BG2RG1_2_RGBG(c)] = get2();
       }
       else if (CanonColorInfo2_type != 276) { /* G2, S30, S40 */
         Appendix_A = 1;
         WB_table_offset = -14;
         fseek(ifp, 98, SEEK_CUR);
         FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();
         if (cam_mul[0] > 0.001f) Got_AsShotWB = 1;
       }
     }
     else if (type == 0x10a9) // ColorBalance: Canon D60, 10D, 300D, and clones
     {
       int bls = 0;
 /*
       int table[] = {
           LIBRAW_WBI_Auto,     // 0
           LIBRAW_WBI_Daylight, // 1
           LIBRAW_WBI_Cloudy,   // 2
           LIBRAW_WBI_Tungsten, // 3
           LIBRAW_WBI_FL_W,     // 4
           LIBRAW_WBI_Flash,    // 5
           LIBRAW_WBI_Custom,   // 6, absent in Canon D60
           LIBRAW_WBI_Auto,     // 7, use this if camera is set to b/w JPEG
           LIBRAW_WBI_Shade,    // 8
           LIBRAW_WBI_Kelvin    // 9, absent in Canon D60
       };
 */
       int nWB =
           ((get2() - 2) / 8) -
           1; // 2 bytes this, N recs 4*2bytes each, last rec is black level
       if (nWB)
         FORC4 icWBC[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
       if (nWB >= 7)
         Canon_WBpresets(0, 0);
       else
-        FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+        FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
       if (nWB == 7) // mostly Canon EOS D60 + some fw#s for 300D;
                     // check for 0x1668000 is unreliable
       {
         if ((wbi >= 0) && (wbi < 9) && (wbi != 6))
         {
-          FORC4 cam_mul[c] = icWBC[Canon_wbi2std[wbi]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_wbi2std[wbi]][c]);
         }
         else
         {
-          FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+          FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
         }
       }
       else if (nWB == 9) // Canon 10D, 300D
       {
         FORC4 icWBC[LIBRAW_WBI_Custom][RGGB_2_RGBG(c)] = get2();
         FORC4 icWBC[LIBRAW_WBI_Kelvin][RGGB_2_RGBG(c)] = get2();
         if ((wbi >= 0) && (wbi < 10))
         {
-          FORC4 cam_mul[c] = icWBC[Canon_wbi2std[wbi]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_wbi2std[wbi]][c]);
         }
         else
         {
-          FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+          FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
         }
       }
       FORC4
       bls += (imCanon.ChannelBlackLevel[RGGB_2_RGBG(c)] = get2());
       imCanon.AverageBlackLevel = bls / 4;
     }
     else if (type == 0x102d)
     {
       Canon_CameraSettings(len >> 1);
     }
 
     else if (type == 0x10b4) {
       switch (get2()) {
       case 1:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 2:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
 
     } else if (type == 0x580b)
     {
       if (strcmp(model, "Canon EOS D30"))
         sprintf(imgdata.shootinginfo.BodySerial, "%d", len);
       else
         sprintf(imgdata.shootinginfo.BodySerial, "%0x-%05d", len >> 16,
                 len & 0xffff);
     }
     else if (type == 0x0032) // CanonColorInfo1
     {
       if (len == 768) { // EOS D30
 
         ushort q;
         fseek(ifp, 4, SEEK_CUR);
-        for (int linenum = 0; linenum < Canon_D30_linenums_2_StdWBi.size(); linenum++) {
+        for (unsigned linenum = 0; linenum < Canon_D30_linenums_2_StdWBi.size(); linenum++) {
           if (Canon_D30_linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown) {
             FORC4 {
               q = get2();
               icWBC[Canon_D30_linenums_2_StdWBi[linenum]][RGGB_2_RGBG(c)] =
                 (int)(roundf(1024000.0f / (float)MAX(1, q)));
             }
 //         if (Canon_wbi2std[imCanon.wbi] == *(Canon_D30_linenums_2_StdWBi + linenum)) {
 //           FORC4 cam_mul[c] = icWBC[*(Canon_D30_linenums_2_StdWBi + linenum)][c];
 //           Got_AsShotWB = 1;
 //           }
           }
         }
         fseek (ifp, 68-int(Canon_D30_linenums_2_StdWBi.size())*8, SEEK_CUR);
 
         FORC4 {
           q = get2();
-          cam_mul[RGGB_2_RGBG(c)] = 1024.0 / MAX(1, q);
+          cam_mul[RGGB_2_RGBG(c)] = 1024.f / float(MAX(1, q));
         }
         if (!wbi)
           cam_mul[0] = -1; // use my auto white balance
 
       }
       else if ((cam_mul[0] <= 0.001f) || // Pro1, G3, G5, G6, S45, S50, S60, S70
                Appendix_A)               // G2, S30, S40
       {
         libraw_static_table_t linenums_2_StdWBi;
-        int AsShotWB_linenum = Canon_wbi2std.size();
+        unsigned AsShotWB_linenum = Canon_wbi2std.size();
 
         CanonColorInfo1_key = get2();
         if ((CanonColorInfo1_key == key[0]) && (len == 2048)) { // Pro1
           linenums_2_StdWBi = Canon_KeyIs0x0410_Len2048_linenums_2_StdWBi;
           WB_table_offset = 8;
 
         } else if ((CanonColorInfo1_key == key[0]) && (len == 3072)) { // S60, S70, G6
           linenums_2_StdWBi = Canon_KeyIs0x0410_Len3072_linenums_2_StdWBi;
           WB_table_offset = 16;
 
         } else if (!CanonColorInfo1_key && (len == 2048)) { // G2, S30, S40; S45, S50, G3, G5
           key[0] = key[1] = 0;
           linenums_2_StdWBi = Canon_KeyIsZero_Len2048_linenums_2_StdWBi;
           if (atof(imCommon.firmware) < 1.02f)
             UseWBfromTable_as_AsShot = 0;
 
         } else goto next_tag;
 
         if ((Canon_wbi2std[wbi] == LIBRAW_WBI_Auto)    ||
             (Canon_wbi2std[wbi] == LIBRAW_WBI_Unknown) ||
             Got_AsShotWB)
           UseWBfromTable_as_AsShot = 0;
 
         if (UseWBfromTable_as_AsShot) {
           int temp_wbi;
           if (Canon_wbi2std[wbi] == LIBRAW_WBI_Custom) temp_wbi = LIBRAW_WBI_Daylight;
           else temp_wbi = wbi;
           for (AsShotWB_linenum = 0; AsShotWB_linenum < linenums_2_StdWBi.size(); AsShotWB_linenum++) {
             if (Canon_wbi2std[temp_wbi] == linenums_2_StdWBi[AsShotWB_linenum]) {
               break;
             }
           }
         }
 
         fseek (ifp, 78LL+WB_table_offset, SEEK_CUR);
-        for (int linenum = 0; linenum < linenums_2_StdWBi.size(); linenum++) {
+        for (unsigned linenum = 0; linenum < linenums_2_StdWBi.size(); linenum++) {
           if (linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown) {
             FORC4 icWBC[linenums_2_StdWBi[linenum]][GRBG_2_RGBG(c)] = get2() ^ key[c & 1];
             if (UseWBfromTable_as_AsShot && (AsShotWB_linenum == linenum)) {
-              FORC4 cam_mul[c] = icWBC[linenums_2_StdWBi[linenum]][c];
+              FORC4 cam_mul[c] = float(icWBC[linenums_2_StdWBi[linenum]][c]);
               Got_AsShotWB = 1;
             }
           } else {
             fseek(ifp, 8, SEEK_CUR);
           }
         }
         if (!Got_AsShotWB)
           cam_mul[0] = -1;
       }
     }
     else if (type == 0x1030 && wbi >= 0 && (0x18040 >> wbi & 1))
     {
       ciff_block_1030(); // all that don't have 0x10a9
     }
     else if (type == 0x1031)
     {
-			raw_width = imCanon.SensorWidth = (get2(), get2());
+			raw_width  = imCanon.SensorWidth = (get2(), get2());
 			raw_height = imCanon.SensorHeight = get2();
-			imCanon.SensorLeftBorder = (get2(), get2(), get2());
-			imCanon.SensorTopBorder = get2();
-			imCanon.SensorRightBorder = get2();
-			imCanon.SensorBottomBorder = get2();
-			imCanon.BlackMaskLeftBorder = get2();
-			imCanon.BlackMaskTopBorder = get2();
-			imCanon.BlackMaskRightBorder = get2();
-			imCanon.BlackMaskBottomBorder = get2();
+			fseek(ifp, 4, SEEK_CUR);
+			imCanon.DefaultCropAbsolute = get_CanonArea();
+			imCanon.LeftOpticalBlack    = get_CanonArea();
     }
     else if (type == 0x501c)
     {
-      iso_speed = len & 0xffff;
+      iso_speed = float(len & 0xffff);
     }
     else if (type == 0x5029)
     {
-      ilm.CurFocal = len >> 16;
+      ilm.CurFocal = float( len >> 16);
       ilm.FocalType = len & 0xffff;
       if (ilm.FocalType == LIBRAW_FT_ZOOM_LENS)
       {
         ilm.FocalUnits = 32;
         if (ilm.FocalUnits > 1)
           ilm.CurFocal /= (float)ilm.FocalUnits;
       }
       focal_len = ilm.CurFocal;
     }
     else if (type == 0x5813)
     {
       flash_used = int_to_float(len);
     }
     else if (type == 0x5814)
     {
       canon_ev = int_to_float(len);
     }
     else if (type == 0x5817)
     {
       shot_order = len;
     }
     else if (type == 0x5834)
     {
       unique_id = ((unsigned long long)len << 32) >> 32;
       setCanonBodyFeatures(unique_id);
     }
     else if (type == 0x580e)
     {
       timestamp = len;
     }
     else if (type == 0x180e)
     {
       timestamp = get4();
     }
diff --git a/src/metadata/cr3_parser.cpp b/src/metadata/cr3_parser.cpp
index def45b02..bcf21908 100644
--- a/src/metadata/cr3_parser.cpp
+++ b/src/metadata/cr3_parser.cpp
@@ -15,559 +15,575 @@
 
 #include "../../internal/dcraw_defs.h"
 
+
+static libraw_area_t sget_CanonArea(uchar *s) {
+  libraw_area_t la = {};
+  la.l = s[0] << 8 | s[1];
+  la.t = s[2] << 8 | s[3];
+  la.r = s[4] << 8 | s[5];
+  la.b = s[6] << 8 | s[7];
+  return la;
+}
+
 void LibRaw::selectCRXTrack(short maxTrack)
 {
   if (maxTrack < 0)
     return;
   INT64 bitcounts[LIBRAW_CRXTRACKS_MAXCOUNT], maxbitcount = 0;
   uint32_t maxjpegbytes = 0;
   memset(bitcounts, 0, sizeof(bitcounts));
   for (int i = 0; i <= maxTrack && i < LIBRAW_CRXTRACKS_MAXCOUNT; i++)
   {
     crx_data_header_t *d = &libraw_internal_data.unpacker_data.crx_header[i];
     if (d->MediaType == 1) // RAW
     {
       bitcounts[i] = INT64(d->nBits) * INT64(d->f_width) * INT64(d->f_height);
       if (bitcounts[i] > maxbitcount)
         maxbitcount = bitcounts[i];
     }
     else if (d->MediaType == 2) // JPEG
     {
       if (d->MediaSize > maxjpegbytes)
       {
         maxjpegbytes = d->MediaSize;
         thumb_offset = d->MediaOffset;
         thumb_length = d->MediaSize;
       }
     }
   }
   if (maxbitcount < 8)
     return;
   int framei = -1, framecnt = 0;
   for (int i = 0; i <= maxTrack && i < LIBRAW_CRXTRACKS_MAXCOUNT; i++)
   {
     if (bitcounts[i] == maxbitcount)
     {
       if (framecnt <= (int)shot_select)
         framei = i;
       framecnt++;
     }
   }
   is_raw = framecnt;
   if (framei >= 0 && framei < LIBRAW_CRXTRACKS_MAXCOUNT)
   {
     crx_data_header_t *d =
         &libraw_internal_data.unpacker_data.crx_header[framei];
     data_offset = d->MediaOffset;
     data_size = d->MediaSize;
     raw_width = d->f_width;
     raw_height = d->f_height;
     load_raw = &LibRaw::crxLoadRaw;
+    tiff_bps = d->nBits;
     switch (d->cfaLayout)
     {
     case 0:
       filters = 0x94949494;
       break;
     case 1:
       filters = 0x61616161;
       break;
     case 2:
       filters = 0x49494949;
       break;
     case 3:
       filters = 0x16161616;
       break;
     }
 
     libraw_internal_data.unpacker_data.crx_track_selected = framei;
 
     int tiff_idx = -1;
     INT64 tpixels = 0;
     for (unsigned i = 0; i < tiff_nifds && i < LIBRAW_IFD_MAXCOUNT; i++)
       if (INT64(tiff_ifd[i].t_height) * INT64(tiff_ifd[i].t_height) > tpixels)
       {
         tpixels = INT64(tiff_ifd[i].t_height) * INT64(tiff_ifd[i].t_height);
         tiff_idx = i;
       }
     if (tiff_idx >= 0)
       flip = tiff_ifd[tiff_idx].t_flip;
   }
 }
 
-#define bad_hdr                                                                \
+#define bad_hdr()                                                              \
   (((order != 0x4d4d) && (order != 0x4949)) || (get2() != 0x002a) ||           \
    (get4() != 0x00000008))
-int LibRaw::parseCR3(unsigned long long oAtomList,
-                     unsigned long long szAtomList, short &nesting,
+
+int LibRaw::parseCR3(INT64 oAtomList,
+                     INT64 szAtomList, short &nesting,
                      char *AtomNameStack, short &nTrack, short &TrackType)
 {
   /*
   Atom starts with 4 bytes for Atom size and 4 bytes containing Atom name
   Atom size includes the length of the header and the size of all "contained"
   Atoms if Atom size == 1, Atom has the extended size stored in 8 bytes located
   after the Atom name if Atom size == 0, it is the last top-level Atom extending
   to the end of the file Atom name is often a 4 symbol mnemonic, but can be a
   4-byte integer
   */
   const char UIID_Canon[17] =
       "\x85\xc0\xb6\x87\x82\x0f\x11\xe0\x81\x11\xf4\xce\x46\x2b\x6a\x48";
   const unsigned char UIID_CanonPreview[17] = "\xea\xf4\x2b\x5e\x1c\x98\x4b\x88\xb9\xfb\xb7\xdc\x40\x6e\x4d\x16";
   const unsigned char UUID_XMP[17] = "\xbe\x7a\xcf\xcb\x97\xa9\x42\xe8\x9c\x71\x99\x94\x91\xe3\xaf\xac";
   
   /*
   AtomType = 0 - unknown: "unk."
   AtomType = 1 - container atom: "cont"
   AtomType = 2 - leaf atom: "leaf"
   AtomType = 3 - can be container, can be leaf: "both"
   */
   short AtomType;
   static const struct
   {
     char AtomName[5];
     short AtomType;
   } AtomNamesList[] = {
       {"dinf", 1},
       {"edts", 1},
       {"fiin", 1},
       {"ipro", 1},
       {"iprp", 1},
       {"mdia", 1},
       {"meco", 1},
       {"mere", 1},
       {"mfra", 1},
       {"minf", 1},
       {"moof", 1},
       {"moov", 1},
       {"mvex", 1},
       {"paen", 1},
       {"schi", 1},
       {"sinf", 1},
       {"skip", 1},
       {"stbl", 1},
       {"stsd", 1},
       {"strk", 1},
       {"tapt", 1},
       {"traf", 1},
       {"trak", 1},
 
       {"cdsc", 2},
       {"colr", 2},
       {"dimg", 2},
       // {"dref", 2},
       {"free", 2},
       {"frma", 2},
       {"ftyp", 2},
       {"hdlr", 2},
       {"hvcC", 2},
       {"iinf", 2},
       {"iloc", 2},
       {"infe", 2},
       {"ipco", 2},
       {"ipma", 2},
       {"iref", 2},
       {"irot", 2},
       {"ispe", 2},
       {"meta", 2},
       {"mvhd", 2},
       {"pitm", 2},
       {"pixi", 2},
       {"schm", 2},
       {"thmb", 2},
       {"tkhd", 2},
       {"url ", 2},
       {"urn ", 2},
 
       {"CCTP", 1},
       {"CRAW", 1},
 
       {"JPEG", 2},
       {"CDI1", 2},
       {"CMP1", 2},
 
       {"CNCV", 2},
       {"CCDT", 2},
       {"CTBO", 2},
       {"CMT1", 2},
       {"CMT2", 2},
       {"CMT3", 2},
       {"CMT4", 2},
       {"THMB", 2},
       {"co64", 2},
       {"mdat", 2},
       {"mdhd", 2},
       {"nmhd", 2},
       {"stsc", 2},
       {"stsz", 2},
       {"stts", 2},
       {"vmhd", 2},
 
       {"dref", 3},
       {"uuid", 3},
   };
 
   const char sHandlerType[5][5] = {"unk.", "soun", "vide", "hint", "meta"};
 
-  int c, err;
+  int c, err=0;
 
   ushort tL;                        // Atom length represented in 4 or 8 bytes
   char nmAtom[5];                   // Atom name
-  unsigned long long oAtom, szAtom; // Atom offset and Atom size
-  unsigned long long oAtomContent,
+  INT64 oAtom, szAtom; // Atom offset and Atom size
+  INT64 oAtomContent,
       szAtomContent; // offset and size of Atom content
-  unsigned long long lHdr;
+  INT64 lHdr;
 
   char UIID[16];
   uchar CMP1[36];
   uchar CDI1[60];
   char HandlerType[5], MediaFormatID[5];
   uint32_t relpos_inDir, relpos_inBox;
   unsigned szItem, Tag, lTag;
   ushort tItem;
 
   nmAtom[0] = MediaFormatID[0] = nmAtom[4] = MediaFormatID[4] = '\0';
   strcpy(HandlerType, sHandlerType[0]);
   oAtom = oAtomList;
   nesting++;
   if (nesting > 31)
     return -14; // too deep nesting
   short s_order = order;
 
-  while ((oAtom + 8ULL) <= (oAtomList + szAtomList))
+  while ((oAtom + 8LL) <= (oAtomList + szAtomList))
   {
     lHdr = 0ULL;
     err = 0;
     order = 0x4d4d;
     fseek(ifp, oAtom, SEEK_SET);
     szAtom = get4();
     FORC4 nmAtom[c] = AtomNameStack[nesting * 4 + c] = fgetc(ifp);
     AtomNameStack[(nesting + 1) * 4] = '\0';
     tL = 4;
     AtomType = 0;
 
     for (c = 0; c < int(sizeof AtomNamesList / sizeof *AtomNamesList); c++)
       if (!strcmp(nmAtom, AtomNamesList[c].AtomName))
       {
         AtomType = AtomNamesList[c].AtomType;
         break;
       }
 
     if (!AtomType)
     {
       err = 1;
     }
 
     if (szAtom == 0ULL)
     {
       if (nesting != 0)
       {
         err = -2;
         goto fin;
       }
       szAtom = szAtomList - oAtom;
       oAtomContent = oAtom + 8ULL;
       szAtomContent = szAtom - 8ULL;
     }
-    else if (szAtom == 1ULL)
+    else if (szAtom == 1LL)
     {
-      if ((oAtom + 16ULL) > (oAtomList + szAtomList))
+      if ((oAtom + 16LL) > (oAtomList + szAtomList))
       {
         err = -3;
         goto fin;
       }
       tL = 8;
       szAtom = (((unsigned long long)get4()) << 32) | get4();
       oAtomContent = oAtom + 16ULL;
       szAtomContent = szAtom - 16ULL;
     }
     else
     {
       oAtomContent = oAtom + 8ULL;
       szAtomContent = szAtom - 8ULL;
     }
 
 	if (!strcmp(AtomNameStack, "uuid")) // Top level uuid
 	{
 		INT64 tt = ftell(ifp);
 		lHdr = 16ULL;
 		fread(UIID, 1, lHdr, ifp);
-		if (!memcmp(UIID, UUID_XMP, 16) && szAtom > 24 && szAtom < 1024000ULL)
+		if (!memcmp(UIID, UUID_XMP, 16) && szAtom > 24LL && szAtom < 1024000LL)
 		{
-			xmpdata = (char *)malloc(xmplen = szAtom - 23);
+			xmpdata = (char *)malloc(xmplen = unsigned(szAtom - 23));
 			fread(xmpdata, szAtom - 24, 1, ifp);
 			xmpdata[szAtom - 24] = 0;
 		}
-		else if (!memcmp(UIID, UIID_CanonPreview, 16) && szAtom > 48 && szAtom < 100ULL * 1024000ULL)
+		else if (!memcmp(UIID, UIID_CanonPreview, 16) && szAtom > 48LL && szAtom < 100LL * 1024000LL)
 		{
 			// read next 48 bytes, check for 'PRVW'
 			unsigned char xdata[32];
 			fread(xdata, 32, 1, ifp);	
 			if (!memcmp(xdata + 12, "PRVW", 4))
 			{
-				thumb_length = szAtom - 56;
+				thumb_length = unsigned(szAtom - 56);
 				thumb_offset = ftell(ifp);
 			}
 		}
 		fseek(ifp, tt, SEEK_SET);
 	}
 
     if (!strcmp(nmAtom, "trak"))
     {
       nTrack++;
       TrackType = 0;
       if (nTrack >= LIBRAW_CRXTRACKS_MAXCOUNT)
         break;
     }
     if (!strcmp(AtomNameStack, "moovuuid"))
     {
       lHdr = 16ULL;
       fread(UIID, 1, lHdr, ifp);
       if (!strncmp(UIID, UIID_Canon, lHdr))
       {
         AtomType = 1;
       }
       else
         fseek(ifp, -lHdr, SEEK_CUR);
     }
     else if (!strcmp(AtomNameStack, "moovuuidCCTP"))
     {
       lHdr = 12ULL;
     }
     else if (!strcmp(AtomNameStack, "moovuuidCMT1"))
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -4;
         goto fin;
       }
+      if (!libraw_internal_data.unpacker_data.cr3_ifd0_length)
+        libraw_internal_data.unpacker_data.cr3_ifd0_length = unsigned(szAtomContent);
       parse_tiff_ifd(oAtomContent);
       order = q_order;
     }
-    else if (!strcmp(AtomNameStack, "moovuuidCMT2"))
-    {
-      short q_order = order;
-      order = get2();
-      if ((tL != 4) || bad_hdr)
-      {
-        err = -5;
-        goto fin;
-      }
+	else if (!strcmp(AtomNameStack, "moovuuidCMT2"))
+	{
+		short q_order = order;
+		order = get2();
+		if ((tL != 4) || bad_hdr())
+		{
+			err = -5;
+			goto fin;
+		}
+		if (!libraw_internal_data.unpacker_data.cr3_exif_length)
+			libraw_internal_data.unpacker_data.cr3_exif_length = unsigned(szAtomContent); 
       parse_exif(oAtomContent);
       order = q_order;
     }
     else if (!strcmp(AtomNameStack, "moovuuidCMT3"))
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -6;
         goto fin;
       }
       fseek(ifp, -12L, SEEK_CUR);
       parse_makernote(oAtomContent, 0);
       order = q_order;
     }
     else if (!strcmp(AtomNameStack, "moovuuidCMT4"))
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -6;
         goto fin;
       }
       INT64 off = ftell(ifp);
       parse_gps(oAtomContent);
       fseek(ifp, off, SEEK_SET);
       parse_gps_libraw(oAtomContent);
       order = q_order;
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiahdlr"))
     {
       fseek(ifp, 8L, SEEK_CUR);
       FORC4 HandlerType[c] = fgetc(ifp);
       for (c = 1; c < int(sizeof sHandlerType / sizeof *sHandlerType); c++)
         if (!strcmp(HandlerType, sHandlerType[c]))
         {
           TrackType = c;
           break;
         }
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsd"))
     {
       if (szAtomContent >= 16)
       {
         fseek(ifp, 12L, SEEK_CUR);
         lHdr = 8;
       }
       else
       {
         err = -7;
         goto fin;
       }
       FORC4 MediaFormatID[c] = fgetc(ifp);
       if ((TrackType == 2) && (!strcmp(MediaFormatID, "CRAW")))
       {
         if (szAtomContent >= 44)
           fseek(ifp, 24L, SEEK_CUR);
         else
         {
           err = -8;
           goto fin;
         }
       }
       else
       {
         AtomType = 2; // only continue for CRAW
         lHdr = 0;
       }
 #define current_track libraw_internal_data.unpacker_data.crx_header[nTrack]
 
       /*ImageWidth =*/ get2();
       /*ImageHeight =*/ get2();
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsdCRAW"))
     {
       lHdr = 82;
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsdCRAWCMP1"))
     {
       if (szAtomContent >= 40)
         fread(CMP1, 1, 36, ifp);
       else
       {
         err = -7;
         goto fin;
       }
       if (!crxParseImageHeader(CMP1, nTrack))
         current_track.MediaType = 1;
     }
 
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsdCRAWCDI1")) {
       if (szAtomContent >= 60) {
         fread(CDI1, 1, 60, ifp);
         if (!strncmp((char *)CDI1+8, "IAD1", 4) && (sgetn(8, CDI1) == 0x38)) {
           // sensor area at CDI1+12, 4 16-bit values
           // Bayer pattern? - next 4 16-bit values
-          // image area, next 4 16-bit values
-          FORC4 imCanon.LeftOpticalBlack[c]  = sgetn(2, CDI1+12 + 3*4*2 +2*c);
-          FORC4 imCanon.UpperOpticalBlack[c] = sgetn(2, CDI1+12 + 4*4*2 +2*c);
-          FORC4 imCanon.ActiveArea[c]        = sgetn(2, CDI1+12 + 5*4*2 +2*c);
+          imCanon.RecommendedImageArea = sget_CanonArea(CDI1+12 + 2*4*2);
+          imCanon.LeftOpticalBlack     = sget_CanonArea(CDI1+12 + 3*4*2);
+          imCanon.UpperOpticalBlack    = sget_CanonArea(CDI1+12 + 4*4*2);
+          imCanon.ActiveArea           = sget_CanonArea(CDI1+12 + 5*4*2);
         }
       }
     }
 
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsdCRAWJPEG"))
     {
       current_track.MediaType = 2;
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblstsz"))
     {
       if (szAtomContent == 12)
         fseek(ifp, 4L, SEEK_CUR);
       else if (szAtomContent == 16)
         fseek(ifp, 12L, SEEK_CUR);
       else
       {
         err = -9;
         goto fin;
       }
       current_track.MediaSize = get4();
     }
     else if (!strcmp(AtomNameStack, "moovtrakmdiaminfstblco64"))
     {
       if (szAtomContent == 16)
         fseek(ifp, 8L, SEEK_CUR);
       else
       {
         err = -10;
         goto fin;
       }
       current_track.MediaOffset = (((unsigned long long)get4()) << 32) | get4();
     }
 
     if (nTrack >= 0 && nTrack < LIBRAW_CRXTRACKS_MAXCOUNT &&
         current_track.MediaSize && current_track.MediaOffset &&
         ((oAtom + szAtom) >= (oAtomList + szAtomList)) &&
         !strncmp(AtomNameStack, "moovtrakmdiaminfstbl", 20))
     {
       if ((TrackType == 4) && (!strcmp(MediaFormatID, "CTMD")))
       {
         order = 0x4949;
         relpos_inDir = 0L;
         while (relpos_inDir + 6 < current_track.MediaSize)
         {
           if (current_track.MediaOffset + relpos_inDir > ifp->size() - 6) // need at least 6 bytes
           {
               err = -11;
               goto fin;
           }
           fseek(ifp, current_track.MediaOffset + relpos_inDir, SEEK_SET);
           szItem = get4();
           tItem = get2();
           if (szItem < 1 || (  (relpos_inDir + szItem) > current_track.MediaSize))
           {
             err = -11;
             goto fin;
           }
           if ((tItem == 7) || (tItem == 8) || (tItem == 9))
           {
             relpos_inBox = relpos_inDir + 12L;
             while (relpos_inBox + 8 < relpos_inDir + szItem)
             {
               if (current_track.MediaOffset + relpos_inBox > ifp->size() - 8) // need at least 8 bytes
               {
                   err = -11;
                   goto fin;
               }
               fseek(ifp, current_track.MediaOffset + relpos_inBox, SEEK_SET);
               lTag = get4();
               Tag = get4();
               if (lTag < 8)
               {
                 err = -12;
                 goto fin;
               }
               else if ((relpos_inBox + lTag) > (relpos_inDir + szItem))
               {
                 err = -11;
                 goto fin;
               }
               if ((Tag == 0x927c) && ((tItem == 7) || (tItem == 8)))
               {
                 fseek(ifp, current_track.MediaOffset + relpos_inBox + 8L,
                       SEEK_SET);
                 short q_order = order;
                 order = get2();
-                if (bad_hdr)
+                if (bad_hdr())
                 {
                   err = -13;
                   goto fin;
                 }
                 fseek(ifp, -8L, SEEK_CUR);
                 libraw_internal_data.unpacker_data.CR3_CTMDtag = 1;
                 parse_makernote(current_track.MediaOffset + relpos_inBox + 8,
                                 0);
                 libraw_internal_data.unpacker_data.CR3_CTMDtag = 0;
                 order = q_order;
               }
               relpos_inBox += lTag;
             }
           }
           relpos_inDir += szItem;
         }
         order = 0x4d4d;
       }
     }
 #undef current_track
     if (AtomType == 1)
     {
       err = parseCR3(oAtomContent + lHdr, szAtomContent - lHdr, nesting,
                      AtomNameStack, nTrack, TrackType);
       if (err)
         goto fin;
     }
     oAtom += szAtom;
   }
diff --git a/src/metadata/epson.cpp b/src/metadata/epson.cpp
index 74e12d7f..427d98e9 100644
--- a/src/metadata/epson.cpp
+++ b/src/metadata/epson.cpp
@@ -17,80 +17,80 @@
 void LibRaw::parseEpsonMakernote(int base, int uptag, unsigned dng_writer)
 {
 
-#define isRIC imgdata.sizes.raw_inset_crop
+#define isRIC imgdata.sizes.raw_inset_crops[0]
 
   unsigned entries, tag, type, len, save;
   short morder, sorder = order;
   ushort c;
   INT64 fsize = ifp->size();
 
   fseek(ifp, -2, SEEK_CUR);
 
   entries = get2();
   if (entries > 1000)
     return;
   morder = order;
 
   while (entries--)
   {
     order = morder;
     tiff_get(base, &tag, &type, &len, &save);
     INT64 pos = ifp->tell();
     if (len > 8 && pos + len > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
 
     tag |= uptag << 16;
     if (len > 100 * 1024 * 1024)
       goto next; // 100Mb tag? No!
 
     if (tag == 0x020b)
     {
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         isRIC.cwidth = get4();
       else if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
         isRIC.cwidth = get2();
     }
     else if (tag == 0x020c)
     {
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         isRIC.cheight = get4();
       else if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
         isRIC.cheight = get2();
     }
     else if (tag == 0x0400)
     {                                 // sensor area
       ushort sdims[4] = {0, 0, 0, 0}; // left margin, top margin, width, height
       FORC4 sdims[c] = get2();
       isRIC.cleft = (sdims[2] - sdims[0] - isRIC.cwidth) / 2;
       isRIC.ctop = (sdims[3] - sdims[1] - isRIC.cheight) / 2;
     }
 
     if (dng_writer == nonDNG)
     {
 
       if (tag == 0x0280)
       {
         thumb_offset = ftell(ifp);
         thumb_length = len;
       }
       else if (tag == 0x0401)
       {
         FORC4 cblack[RGGB_2_RGBG(c)] = get4();
       }
       else if (tag == 0x0e80)
       {
         fseek(ifp, 48, SEEK_CUR);
         cam_mul[0] = get2() * 567.0 / 0x10000;
         cam_mul[2] = get2() * 431.0 / 0x10000;
       }
     }
 
   next:
     fseek(ifp, save, SEEK_SET);
   }
   order = sorder;
 #undef isRIC
 }
diff --git a/src/metadata/exif_gps.cpp b/src/metadata/exif_gps.cpp
index 56f19fdd..6ff514c6 100644
--- a/src/metadata/exif_gps.cpp
+++ b/src/metadata/exif_gps.cpp
@@ -62,250 +62,263 @@ void LibRaw::parse_exif_interop(int base)
 void LibRaw::parse_exif(int base)
 {
   unsigned entries, tag, type, len, save, c;
   double expo, ape;
 
   unsigned kodak = !strncmp(make, "EASTMAN", 7) && tiff_nifds < 3;
 
+  if (!libraw_internal_data.unpacker_data.exif_offset)
+	  libraw_internal_data.unpacker_data.exif_offset = base;
+
   entries = get2();
   if (!strncmp(make, "Hasselblad", 10) && (tiff_nifds > 3) && (entries > 512))
     return;
   INT64 fsize = ifp->size();
   while (entries--)
   {
     tiff_get(base, &tag, &type, &len, &save);
 
     INT64 savepos = ftell(ifp);
     if (len > 8 && savepos + len > fsize * 2)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     if (callbacks.exif_cb)
     {
       callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp,
                         base);
       fseek(ifp, savepos, SEEK_SET);
     }
 
     switch (tag)
     {
 	case 0xA005: // Interoperability IFD
 		fseek(ifp, get4() + base, SEEK_SET);
 		parse_exif_interop(base);
 		break;
 	case 0xA001: // ExifIFD.ColorSpace
 		c = get2();
 		if (c == 1 && imgdata.color.ExifColorSpace == LIBRAW_COLORSPACE_Unknown)
 			imgdata.color.ExifColorSpace = LIBRAW_COLORSPACE_sRGB;
 		else if (c == 2)
 			imgdata.color.ExifColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
 		break;
     case 0x9400:
       imCommon.exifAmbientTemperature = getreal(type);
       if ((imCommon.CameraTemperature > -273.15f) &&
           ((OlyID == OlyID_TG_5) ||
            (OlyID == OlyID_TG_6))
       )
         imCommon.CameraTemperature += imCommon.exifAmbientTemperature;
       break;
     case 0x9401:
       imCommon.exifHumidity = getreal(type);
       break;
     case 0x9402:
       imCommon.exifPressure = getreal(type);
       break;
     case 0x9403:
       imCommon.exifWaterDepth = getreal(type);
       break;
     case 0x9404:
       imCommon.exifAcceleration = getreal(type);
       break;
     case 0x9405:
       imCommon.exifCameraElevationAngle = getreal(type);
       break;
 
     case 0xa405: // FocalLengthIn35mmFormat
       imgdata.lens.FocalLengthIn35mmFormat = get2();
       break;
     case 0xa431: // BodySerialNumber
       stmread(imgdata.shootinginfo.BodySerial, len, ifp);
       break;
     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard
       imgdata.lens.MinFocal = getreal(type);
       imgdata.lens.MaxFocal = getreal(type);
       imgdata.lens.MaxAp4MinFocal = getreal(type);
       imgdata.lens.MaxAp4MaxFocal = getreal(type);
       break;
     case 0xa435: // LensSerialNumber
       stmread(imgdata.lens.LensSerial, len, ifp);
       if (!strncmp(imgdata.lens.LensSerial, "----", 4))
         imgdata.lens.LensSerial[0] = '\0';
       break;
     case 0xa420: /* 42016, ImageUniqueID */
       stmread(imgdata.color.ImageUniqueID, len, ifp);
       break;
     case 0xc65d: /* 50781, RawDataUniqueID */
       imgdata.color.RawDataUniqueID[16] = 0;
       fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);
       break;
     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard
       imgdata.lens.dng.MinFocal = getreal(type);
       imgdata.lens.dng.MaxFocal = getreal(type);
       imgdata.lens.dng.MaxAp4MinFocal = getreal(type);
       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);
       break;
     case 0xc68b: /* 50827, OriginalRawFileName */
       stmread(imgdata.color.OriginalRawFileName, len, ifp);
       break;
     case 0xa433: // LensMake
       stmread(imgdata.lens.LensMake, len, ifp);
       break;
     case 0xa434: // LensModel
       stmread(imgdata.lens.Lens, len, ifp);
       if (!strncmp(imgdata.lens.Lens, "----", 4))
         imgdata.lens.Lens[0] = '\0';
       break;
     case 0x9205:
       imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
       break;
     case 0x829a: // 33434
       shutter = getreal(type);
       if (tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT)
           tiff_ifd[tiff_nifds - 1].t_shutter = shutter;
       break;
     case 0x829d: // 33437, FNumber
       aperture = getreal(type);
       break;
     case 0x8827: // 34855
       iso_speed = get2();
       break;
     case 0x8831: // 34865
       if (iso_speed == 0xffff && !strncasecmp(make, "FUJI", 4))
         iso_speed = getreal(type);
       break;
     case 0x8832: // 34866
       if (iso_speed == 0xffff &&
           (!strncasecmp(make, "SONY", 4) || !strncasecmp(make, "CANON", 5)))
         iso_speed = getreal(type);
       break;
     case 0x9003: // 36867
     case 0x9004: // 36868
       get_timestamp(0);
       break;
     case 0x9201: // 37377
        if ((expo = -getreal(type)) < 128 && shutter == 0.)
        {
             shutter = libraw_powf64l(2.0, expo);
             if (tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT)
               tiff_ifd[tiff_nifds - 1].t_shutter = shutter;
        }
       break;
     case 0x9202: // 37378 ApertureValue
       if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))
         aperture = libraw_powf64l(2.0, ape / 2);
       break;
     case 0x9209: // 37385
       flash_used = getreal(type);
       break;
     case 0x920a: // 37386
       focal_len = getreal(type);
       break;
     case 0x927c: // 37500
+#ifndef USE_6BY9RPI
       if (((make[0] == '\0') && !strncmp(model, "ov5647", 6)) ||
           (!strncmp(make, "RaspberryPi", 11) &&
            (!strncmp(model, "RP_OV5647", 9) ||
             !strncmp(model, "RP_imx219", 9))))
+#else
+      if (((make[0] == '\0') && !strncmp(model, "ov5647", 6)) ||
+          (!strncmp(make, "RaspberryPi", 11) &&
+              (!strncmp(model, "RP_", 3) || !strncmp(model,"imx477",6))))
+#endif
       {
         char mn_text[512];
         char *pos;
         char ccms[512];
         ushort l;
         float num;
 
         fgets(mn_text, MIN(len, 511), ifp);
         mn_text[511] = 0;
 
+        pos = strstr(mn_text, "ev=");
+        if (pos)
+          imCommon.ExposureCalibrationShift = atof(pos + 3);
+
         pos = strstr(mn_text, "gain_r=");
         if (pos)
           cam_mul[0] = atof(pos + 7);
         pos = strstr(mn_text, "gain_b=");
         if (pos)
           cam_mul[2] = atof(pos + 7);
         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))
           cam_mul[1] = cam_mul[3] = 1.0f;
         else
           cam_mul[0] = cam_mul[2] = 0.0f;
 
         pos = strstr(mn_text, "ccm=");
         if (pos)
         {
           pos += 4;
           char *pos2 = strstr(pos, " ");
           if (pos2)
           {
             l = pos2 - pos;
             memcpy(ccms, pos, l);
             ccms[l] = '\0';
 #ifdef LIBRAW_WIN32_CALLS
             // Win32 strtok is already thread-safe
             pos = strtok(ccms, ",");
 #else
             char *last = 0;
             pos = strtok_r(ccms, ",", &last);
 #endif
             if (pos)
             {
-              for (l = 0; l < 4; l++)
+              for (l = 0; l < 3; l++) // skip last row
               {
                 num = 0.0;
                 for (c = 0; c < 3; c++)
                 {
-                  imgdata.color.ccm[l][c] = (float)atoi(pos);
-                  num += imgdata.color.ccm[l][c];
+                  cmatrix[l][c] = (float)atoi(pos);
+                  num += cmatrix[c][l];
 #ifdef LIBRAW_WIN32_CALLS
                   pos = strtok(NULL, ",");
 #else
                   pos = strtok_r(NULL, ",", &last);
 #endif
                   if (!pos)
                     goto end; // broken
                 }
                 if (num > 0.01)
-                  FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;
+                    FORC3 cmatrix[l][c] = cmatrix[l][c] / num;
               }
             }
           }
         }
       end:;
       }
       else if (!strncmp(make, "SONY", 4) &&
                (!strncmp(model, "DSC-V3", 6) || !strncmp(model, "DSC-F828", 8)))
       {
         parseSonySRF(len);
         break;
       }
       else if ((len == 1) && !strncmp(make, "NIKON", 5))
       {
         c = get4();
         if (c)
           fseek(ifp, c, SEEK_SET);
         is_NikonTransfer = 1;
       }
       parse_makernote(base, 0);
       break;
     case 0xa002: // 40962
       if (kodak)
         raw_width = get4();
       break;
     case 0xa003: // 40963
       if (kodak)
         raw_height = get4();
       break;
     case 0xa302: // 41730
       if (get4() == 0x20002)
         for (exif_cfa = c = 0; c < 8; c += 2)
           exif_cfa |= fgetc(ifp) * 0x01010101U << c;
     }
     fseek(ifp, save, SEEK_SET);
   }
 }
diff --git a/src/metadata/fuji.cpp b/src/metadata/fuji.cpp
index 1feadcf4..45255add 100644
--- a/src/metadata/fuji.cpp
+++ b/src/metadata/fuji.cpp
@@ -21,712 +21,757 @@
 int LibRaw::guess_RAFDataGeneration (uchar *RAFData_start) // returns offset to first valid width/height pair
 {
 
 /* RAFDataGeneration codes, values are 4 bytes, little endian
 
    RAFData gen. 0: no RAFData
      DBP for GX680 / DX-2000
      E550, E900, (F500 / F505?) F550, F600 / F605, F700, F770 / F775, F800, F810, F900
      HS10 HS11, HS20 / HS22, HS30 / HS33 / HS35, HS50
      S1, SL1000, S100, S200 / S205, S20Pro, S2Pro, S3Pro, S5Pro
      S5000, S5100 / S5500, S5200 / S5600, S6000 / S6500, S7000, S9000 / S9500, S9100 / S9600
 
    RAFData gen. 1, offset to WH pair (offsetWH_inRAFData) = 0:
    - number in bytes 0..1 is less than 10000
    - contains WH pair, recommended image size WH pair, 16 bytes unknown, 2*13 values (for crops, scales?)
      X100, X-Pro1, X-S1, X10, XF1
 
    RAFData gen. 2, offset to WH pair = 4:
    - bytes 0..1 contain a number greater than 10000; bytes 2..3 contain zero;
      version is in bytes 0..1, possibly big endian
      - contains WH pair, recommended image size WH pair, 16 bytes unknown, 2*13 values
      X-E1
 
    RAFData gen. 3, offset to WH pair = 4:
    - bytes 0..1 contain zero; bytes 2..3 contain version;
    - contains a table of 3+2*13 values; first 3 values look like WHW
      X-A1, X-A2, X-E2, X-M1
      X-T1, X-T10
      X100S, X100T
      X20, X30, X70, XQ1, XQ2
 
    RAFData gen. 4, offset to WH pair = 8:
    - same conditions as for RAFData gen. 3, but also adds WRTS in bytes 4..7
    - contains a table of 3+2*13 values; first 3 values look like WHW
    - H in WHW group has a different meaning if the shot is taken in crop 2 mode
-     GFX 100, GFX 50R, GFX 50S
+     GFX 100, GFX 100S, GFX 50R, GFX 50S, GFX 50S II
      X-E2S, X-E3, X-H1, X-S10
      X-T2, X-T3, X-T4, X-T20, X-T30
      X-Pro2, X-Pro3
      X100F, X100V
 
    RAFData gen. set to 4096:
    - RAFData length is exactly 4096
      X-A3, X-A5, X-A7, X-A10, X-A20
      X-T100, X-T200,
      XF10
 */
 
   int offsetWH_inRAFData=0; /* clang warns about not initialized value */
   ushort b01  = sget2(RAFData_start);   // bytes 0..1
   ushort b23  = sget2(RAFData_start+2); // bytes 2..3
   int is_WRTS = (sget4(RAFData_start + 4) == 0x53545257); // STRW
   if (b01 && !b23 && (b01<10000))
   {
     imFuji.RAFDataGeneration = 1;
     offsetWH_inRAFData = 0;
   }
   else if ((b01>10000) && !b23)
   {
     imFuji.RAFDataGeneration = 2;
     imFuji.RAFDataVersion = b01;
     offsetWH_inRAFData = 4;
   }
   else if (!b01)
   {
     if (!is_WRTS)
     {
       imFuji.RAFDataGeneration = 3;
       offsetWH_inRAFData = 4;
     }
     else
     {
       imFuji.RAFDataGeneration = 4;
       offsetWH_inRAFData = 8;
     }
     imFuji.RAFDataVersion = b23;
   }
+
   return offsetWH_inRAFData;
 }
 
 void LibRaw::parseAdobeRAFMakernote()
 {
 
   uchar *PrivateMknBuf;
   unsigned posPrivateMknBuf=0; /* clang warns about not inited value */
   unsigned PrivateMknLength;
   unsigned PrivateOrder;
   unsigned ifd_start, ifd_len;
   unsigned PrivateEntries, PrivateTagID;
   unsigned PrivateTagBytes;
   int FujiShotSelect;
   unsigned wb_section_offset = 0;
   int posWB;
   int c;
 
 #define CHECKSPACE(s)                                                          \
   if (posPrivateMknBuf + (s) > PrivateMknLength)                               \
   {                                                                            \
     free(PrivateMknBuf);                                                       \
     return;                                                                    \
   }
 #define isWB(posWB)                                                            \
   sget2(posWB) != 0 && sget2(posWB + 2) != 0 && sget2(posWB + 4) != 0 &&       \
       sget2(posWB + 6) != 0 && sget2(posWB + 8) != 0 &&                        \
       sget2(posWB + 10) != 0 && sget2(posWB) != 0xff &&                        \
       sget2(posWB + 2) != 0xff && sget2(posWB + 4) != 0xff &&                  \
       sget2(posWB + 6) != 0xff && sget2(posWB + 8) != 0xff &&                  \
       sget2(posWB + 10) != 0xff && sget2(posWB) == sget2(posWB + 6) &&         \
       sget2(posWB) < sget2(posWB + 2) && sget2(posWB) < sget2(posWB + 4) &&    \
       sget2(posWB) < sget2(posWB + 8) && sget2(posWB) < sget2(posWB + 10)
 
 #define get_average_WB(wb_index)                                               \
   FORC4 icWBC[wb_index][GRGB_2_RGBG(c)] =                                      \
       sget2(PrivateMknBuf + posPrivateMknBuf + (c << 1));                      \
   if ((PrivateTagBytes == 16) && average_WBData) {                             \
     FORC4 icWBC[wb_index][GRGB_2_RGBG(c)] =                                    \
              (icWBC[wb_index][GRGB_2_RGBG(c)] +                                \
               sget2(PrivateMknBuf + posPrivateMknBuf + (c << 1)+8)) /2;        \
   }                                                                            \
   if (use_WBcorr_coeffs) {                                                     \
     icWBC[wb_index][0] *= wbR_corr;                                            \
     icWBC[wb_index][2] *= wbB_corr;                                            \
   }
 
   ushort use_WBcorr_coeffs = 0;
   double wbR_corr = 1.0;
   double wbB_corr = 1.0;
 
   if (strstr(model, "S2Pro")
       || strstr(model, "S20Pro")
       || strstr(model, "F700")
       || strstr(model, "S5000")
       || strstr(model, "S7000")
       ) {
     use_WBcorr_coeffs = 1;
     wbR_corr = 10.0 / 17.0 / 0.652941;
     wbB_corr = 2.0 /3.0 / (3.0 / 4.0 + 1.0 / 300.0);
   } else if (strstr(model, "DBP") || strstr(model, "DX-2000")) {
     use_WBcorr_coeffs = 1;
     wbR_corr = 0.7632653061;
     wbB_corr = 0.8591549296;
   }
 
   FujiShotSelect = LIM(shot_select, 0, 1);
   int average_WBData = 1;
 
   order = 0x4d4d;
   PrivateMknLength = get4();
 
   if ((PrivateMknLength > 4) && (PrivateMknLength < 10240000) &&
       (PrivateMknBuf = (uchar *)malloc(PrivateMknLength + 1024))) // 1024b for safety
   {
     fread(PrivateMknBuf, PrivateMknLength, 1, ifp);
     memcpy(imFuji.SerialSignature, PrivateMknBuf + 6, 0x0c);
     imFuji.SerialSignature[0x0c] = 0;
     memcpy(imFuji.SensorID, imFuji.SerialSignature + 0x06, 0x04);
     imFuji.SensorID[0x04] = 0;
     c = 11;
     while (isdigit(imFuji.SerialSignature[c]) && (c>0))
       c--;
     ilm.CamID = unique_id = (unsigned long long)atoi(imFuji.SerialSignature+c+1);
     memcpy(model, PrivateMknBuf + 0x12, 0x20);
     model[0x20] = 0;
     memcpy(imFuji.RAFVersion, PrivateMknBuf + 0x32, 4);
     imFuji.RAFVersion[4] = 0;
 
     PrivateOrder = sget2(PrivateMknBuf);
     unsigned s, l;
     s = ifd_start = sget4(PrivateMknBuf +2)+6;
     CHECKSPACE(ifd_start+4);
     l = ifd_len = sget4(PrivateMknBuf +ifd_start);
     if ((s+l) > PrivateMknLength) {
       free(PrivateMknBuf);
       return;
     }
     if (!sget4(PrivateMknBuf+ifd_start+ifd_len+4))
       FujiShotSelect = 0;
 
     if ((FujiShotSelect == 1) && (PrivateMknLength > ifd_len*2)) {
       ifd_start += (ifd_len+4);
       ifd_len = sget4(PrivateMknBuf +ifd_start);
       if ((ifd_start+ifd_len) > PrivateMknLength) {
         ifd_start = s;
         ifd_len = l;
         FujiShotSelect = 0;
       }
     } else FujiShotSelect = 0;
 
     PrivateEntries = sget4(PrivateMknBuf +ifd_start+4);
     if ((PrivateEntries > 1000) ||
         ((PrivateOrder != 0x4d4d) && (PrivateOrder != 0x4949)))
     {
       free(PrivateMknBuf);
       return;
     }
     posPrivateMknBuf = (ifd_start+8);
 
     /*
      * because Adobe DNG converter strips or misplaces 0xfnnn tags,
      * for now, Auto WB is missing for the following cameras:
      * - F550EXR / F600EXR / F770EXR / F800EXR / F900EXR
      * - HS10 / HS11 / HS20EXR / HS30EXR / HS33EXR / HS35EXR / HS50EXR
      * - S1 / SL1000
      **/
     while (PrivateEntries--)
     {
       order = 0x4d4d;
       CHECKSPACE(4);
       PrivateTagID = sget2(PrivateMknBuf + posPrivateMknBuf);
       PrivateTagBytes = sget2(PrivateMknBuf + posPrivateMknBuf + 2);
       posPrivateMknBuf += 4;
       order = PrivateOrder;
 
       if (PrivateTagID == 0x2000)
       {
         get_average_WB(LIBRAW_WBI_Auto);
       }
       else if (PrivateTagID == 0x2100)
       {
         get_average_WB(LIBRAW_WBI_FineWeather);
       }
       else if (PrivateTagID == 0x2200)
       {
         get_average_WB(LIBRAW_WBI_Shade);
       }
       else if (PrivateTagID == 0x2300)
       {
         get_average_WB(LIBRAW_WBI_FL_D);
       }
       else if (PrivateTagID == 0x2301)
       {
         get_average_WB(LIBRAW_WBI_FL_N);
       }
       else if (PrivateTagID == 0x2302)
       {
         get_average_WB(LIBRAW_WBI_FL_W);
       }
       else if (PrivateTagID == 0x2310)
       {
         get_average_WB(LIBRAW_WBI_FL_WW);
       }
       else if (PrivateTagID == 0x2311)
       {
         get_average_WB(LIBRAW_WBI_FL_L);
       }
       else if (PrivateTagID == 0x2400)
       {
         get_average_WB(LIBRAW_WBI_Tungsten);
       }
       else if (PrivateTagID == 0x2410)
       {
         get_average_WB(LIBRAW_WBI_Flash);
       }
       else if (PrivateTagID == 0x2f00)
       {
         int nWBs = MIN(sget4(PrivateMknBuf + posPrivateMknBuf), 6);
         posWB = posPrivateMknBuf + 4;
         for (int wb_ind = LIBRAW_WBI_Custom1; wb_ind < LIBRAW_WBI_Custom1+nWBs; wb_ind++) {
           FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                   sget2(PrivateMknBuf + posWB + (c << 1));
-          if ((PrivateTagBytes >= (4+16*nWBs)) && average_WBData) {
+          if ((PrivateTagBytes >= unsigned(4+16*nWBs)) && average_WBData) {
             posWB += 8;
             FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                     (icWBC[wb_ind][GRGB_2_RGBG(c)] +
                      sget2(PrivateMknBuf + posWB + (c << 1))) /2;
           }
           if (use_WBcorr_coeffs) {
              icWBC[wb_ind][0] *= wbR_corr;
              icWBC[wb_ind][2] *= wbB_corr;
           }
           posWB += 8;
         }
       }
       else if (PrivateTagID == 0x2ff0)
       {
         get_average_WB(LIBRAW_WBI_AsShot);
         FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_AsShot][c];
       }
       else if ((PrivateTagID == 0x4000) &&
                ((PrivateTagBytes == 8) || (PrivateTagBytes == 16)))
       {
         imFuji.BlackLevel[0] = PrivateTagBytes / 2;
         FORC4 imFuji.BlackLevel[GRGB_2_RGBG(c)+1] =
             sget2(PrivateMknBuf + posPrivateMknBuf + (c << 1));
         if (imFuji.BlackLevel[0] == 8) {
           FORC4 imFuji.BlackLevel[GRGB_2_RGBG(c)+5] =
               sget2(PrivateMknBuf + posPrivateMknBuf + (c << 1) + 8);
         }
       }
       else if (PrivateTagID == 0x9650)
       {
         CHECKSPACE(4);
         short a = (short)sget2(PrivateMknBuf + posPrivateMknBuf);
         float b = fMAX(1.0f, sget2(PrivateMknBuf + posPrivateMknBuf + 2));
         imFuji.ExpoMidPointShift = a / b;
         imCommon.ExposureCalibrationShift += imFuji.ExpoMidPointShift;
       }
       else if ((PrivateTagID == 0xc000) && (PrivateTagBytes > 3) &&
                (PrivateTagBytes < 10240000))
       {
         order = 0x4949;
         if (PrivateTagBytes != 4096) // not one of Fuji X-A3, X-A5, X-A7, X-A10, X-A20, X-T100, X-T200, XF10
         {
+          int is34 = 0;
           guess_RAFDataGeneration (PrivateMknBuf + posPrivateMknBuf);
+// printf ("RAFDataVersion: 0x%04x, RAFDataGeneration: %d\n",
+// imFuji.RAFDataVersion, imFuji.RAFDataGeneration);
+
           for (posWB = 0; posWB < (int)PrivateTagBytes - 16; posWB++)
           {
             if ((!memcmp(PrivateMknBuf + posWB, "TSNERDTS", 8) &&
                  (sget2(PrivateMknBuf + posWB + 10) > 125)))
             {
               posWB += 10;
               icWBC[LIBRAW_WBI_Auto][1] =
                   icWBC[LIBRAW_WBI_Auto][3] =
                       sget2(PrivateMknBuf + posWB);
               icWBC[LIBRAW_WBI_Auto][0] =
                   sget2(PrivateMknBuf + posWB + 2);
               icWBC[LIBRAW_WBI_Auto][2] =
                   sget2(PrivateMknBuf + posWB + 4);
               break;
             }
           }
+
+          if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S
+              (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II
+              (imFuji.RAFDataVersion == 0x0262) || // X-T4
+              (imFuji.RAFDataVersion == 0x0264) || // X-S10
+              (imFuji.RAFDataVersion == 0x0265) || // X-E4
+                !strcmp(model, "X-Pro3")     ||
+                !strcmp(model, "GFX 100S")   ||
+                !strcmp(model, "GFX100S")    ||
+                !strcmp(model, "GFX 50S II") ||
+                !strcmp(model, "GFX50S II")  ||
+                !strcmp(model, "X100V")      ||
+                !strcmp(model, "X-T4")       ||
+                !strcmp(model, "X-E4")       ||
+                !strcmp(model, "X-S10"))
+            is34 = 1;
+
           if (imFuji.RAFDataVersion == 0x4500) // X-E1, RAFData gen. 3
           {
-            wb_section_offset = 0x13ac;        // (fj<<1) - 0x3c
+            wb_section_offset = 0x13ac;
           }
           else if (imFuji.RAFDataVersion == 0x0146 || // X20
                    imFuji.RAFDataVersion == 0x0149 || // X100S
                    imFuji.RAFDataVersion == 0x0249)   // X100S
           {
             wb_section_offset = 0x1410;
           }
           else if (imFuji.RAFDataVersion == 0x014d || // X-M1
                    imFuji.RAFDataVersion == 0x014e)   // X-A1, X-A2
           {
             wb_section_offset = 0x1474;
           }
           else if (imFuji.RAFDataVersion == 0x014f || // X-E2
                    imFuji.RAFDataVersion == 0x024f || // X-E2
                    imFuji.RAFDataVersion == 0x025d || // X-H1
                    imFuji.RAFDataVersion == 0x035d)   // X-H1
           {
             wb_section_offset = 0x1480;
           }
           else if (imFuji.RAFDataVersion == 0x0150) // XQ1, XQ2
           {
             wb_section_offset = 0x1414;
           }
           else if (imFuji.RAFDataVersion == 0x0151 || // X-T1 w/diff. fws
                    imFuji.RAFDataVersion == 0x0251 || imFuji.RAFDataVersion == 0x0351 ||
                    imFuji.RAFDataVersion == 0x0451 || imFuji.RAFDataVersion == 0x0551)
           {
             wb_section_offset = 0x14b0;
           }
           else if (imFuji.RAFDataVersion == 0x0152 || // X30
                    imFuji.RAFDataVersion == 0x0153)   // X100T
           {
             wb_section_offset = 0x1444;
           }
           else if (imFuji.RAFDataVersion == 0x0154) // X-T10
           {
             wb_section_offset = 0x1824;
           }
           else if (imFuji.RAFDataVersion == 0x0155) // X70
           {
             wb_section_offset = 0x17b4;
           }
           else if (imFuji.RAFDataVersion == 0x0255 || // X-Pro2
                    imFuji.RAFDataVersion == 0x0455)
           {
             wb_section_offset = 0x135c;
           }
           else if (imFuji.RAFDataVersion == 0x0258 || // X-T2
                    imFuji.RAFDataVersion == 0x025b)   // X-T20
           {
             wb_section_offset = 0x13dc;
           }
           else if (imFuji.RAFDataVersion == 0x0259) // X100F
           {
             wb_section_offset = 0x1370;
           }
           else if (imFuji.RAFDataVersion == 0x025a || // GFX 50S
                    imFuji.RAFDataVersion == 0x045a)
           {
             wb_section_offset = 0x1424;
          }
           else if (imFuji.RAFDataVersion == 0x025c) // X-E3
           {
             wb_section_offset = 0x141c;
           }
           else if (imFuji.RAFDataVersion == 0x025e) // X-T3
           {
             wb_section_offset = 0x2014;
           }
-          else if (imFuji.RAFDataVersion == 0x025f) // X-T30, GFX 50R, GFX 100
+          else if (imFuji.RAFDataVersion == 0x025f) // X-T30, GFX 50R, GFX 100 (? RAFDataVersion 0x045f)
           {
             if (!strcmp(model, "X-T30")) {
               if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20b8))
                 wb_section_offset = 0x20b8;
               else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20c8))
                 wb_section_offset = 0x20c8;
             }
             else if (!strcmp(model, "GFX 50R"))
               wb_section_offset = 0x1424;
             else if (!strcmp(model, "GFX 100"))
               wb_section_offset = 0x20e4;
           }
-          else if (imFuji.RAFDataVersion == 0x0260) // X-Pro3
+          else if (imFuji.RAFDataVersion == 0x0260) // X-Pro3, GFX 100S
           {
-            wb_section_offset = 0x20e8;
+           if (!strcmp(model, "X-Pro3"))
+              wb_section_offset = 0x20e8;
+            else if (!strcmp(model, "GFX 100S") || !strcmp(model, "GFX100S"))
+              wb_section_offset = 0x2108;
           }
-          else if (imFuji.RAFDataVersion == 0x0261) // X100V
+          else if (imFuji.RAFDataVersion == 0x0261) // X100V, GFX 50S II
           {
-            wb_section_offset = 0x2078;
+            if (!strcmp(model, "X100V"))
+              wb_section_offset = 0x2078;
+            else if (!strcmp(model, "GFX 50S II") || !strcmp(model, "GFX50S II"))
+              wb_section_offset = 0x214c;
           }
           else if (imFuji.RAFDataVersion == 0x0262) // X-T4
           {
             wb_section_offset = 0x21c8;
           }
           else if (imFuji.RAFDataVersion == 0x0264) // X-S10
           {
             wb_section_offset = 0x21de;
           }
+          else if (imFuji.RAFDataVersion == 0x0265) // X-E4
+          {
+            wb_section_offset = 0x21cc;
+          }
           else if (imFuji.RAFDataVersion == 0x0355) // X-E2S
           {
             wb_section_offset = 0x1840;
           }
-            /* try for unknown RAF Data versions */
+
+/* try for unknown RAF Data versions */
           else if (!strcmp(model, "X-Pro2"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x135c))
               wb_section_offset = 0x135c;
           }
           else if (!strcmp(model, "X100F"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1370))
               wb_section_offset = 0x1370;
           }
           else if (!strcmp(model, "X-E1"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x13ac))
               wb_section_offset = 0x13ac;
           }
           else if (!strcmp(model, "X-T2") ||
                    !strcmp(model, "X-T20"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x13dc))
               wb_section_offset = 0x13dc;
           }
           else if (!strcmp(model, "X20") ||
                    !strcmp(model, "X100S"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1410))
               wb_section_offset = 0x1410;
           }
           else if (!strcmp(model, "XQ1") ||
                    !strcmp(model, "XQ2"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1414))
               wb_section_offset = 0x1414;
           }
           else if (!strcmp(model, "X-E3"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x141c))
               wb_section_offset = 0x141c;
           }
           else if (!strcmp(model, "GFX 50S") ||
                    !strcmp(model, "GFX 50R"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1424))
               wb_section_offset = 0x1424;
           }
+          else if (!strcmp(model, "GFX 50S II") || !strcmp(model, "GFX50S II")) {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x214c))
+              wb_section_offset = 0x214c;
+          }
           else if (!strcmp(model, "X30") ||
                    !strcmp(model, "X100T"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1444))
               wb_section_offset = 0x1444;
           }
           else if (!strcmp(model, "X-M1") ||
                    !strcmp(model, "X-A1") ||
                    !strcmp(model, "X-A2"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1474))
               wb_section_offset = 0x1474;
           }
           else if (!strcmp(model, "X-E2") ||
                    !strcmp(model, "X-H1"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1480))
               wb_section_offset = 0x1480;
           }
           else if (!strcmp(model, "X-T1"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x14b0))
               wb_section_offset = 0x14b0;
           }
           else if (!strcmp(model, "X70"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x17b4))
               wb_section_offset = 0x17b4;
           }
           else if (!strcmp(model, "X-T10"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1824))
               wb_section_offset = 0x1824;
           }
           else if (!strcmp(model, "X-E2S"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1840))
               wb_section_offset = 0x1840;
           }
           else if (!strcmp(model, "X-T3"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x2014))
               wb_section_offset = 0x2014;
           }
           else if (!strcmp(model, "X100V"))
           {
-            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20e8))
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x2078))
               wb_section_offset = 0x2078;
           }
           else if (!strcmp(model, "X-T30"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20b8))
               wb_section_offset = 0x20b8;
+            else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20c8))
+              wb_section_offset = 0x20c8;
           }
           else if (!strcmp(model, "GFX 100"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20e4))
               wb_section_offset = 0x20e4;
           }
           else if (!strcmp(model, "X-Pro3"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20e8))
               wb_section_offset = 0x20e8;
           }
+          else if (!strcmp(model, "GFX100S") || !strcmp(model, "GFX 100S"))
+          {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x2108))
+              wb_section_offset = 0x2108;
+          }
           else if (!strcmp(model, "X-T4"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21c8))
               wb_section_offset = 0x21c8;
           }
+          else if (!strcmp(model, "X-E4"))
+          {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21cc)) 
+              wb_section_offset = 0x21cc;
+          }
           else if (!strcmp(model, "X-S10"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21de))
               wb_section_offset = 0x21de;
           }
-            /* no RAF Data version for the models below */
+
+/* no RAF Data version for the models below */
           else if (!strcmp(model, "FinePix X100")) // X100 0 0x19f0 0x19e8
           {
             if (!strcmp(imFuji.RAFVersion, "0069"))
               wb_section_offset = 0x19e8;
             else if (!strcmp(imFuji.RAFVersion, "0100") ||
                      !strcmp(imFuji.RAFVersion, "0110"))
               wb_section_offset = 0x19f0;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x19e8))
               wb_section_offset = 0x19e8;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x19f0))
               wb_section_offset = 0x19f0;
           }
           else if (!strcmp(model, "X-Pro1")) // X-Pro1 0 0x13a4
           {
             if (!strcmp(imFuji.RAFVersion, "0100") ||
                 !strcmp(imFuji.RAFVersion, "0101") ||
                 !strcmp(imFuji.RAFVersion, "0204"))
               wb_section_offset = 0x13a4;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x13a4))
               wb_section_offset = 0x13a4;
           }
           else if (!strcmp(model, "XF1")) // XF1 0 0x138c
           {
             if (!strcmp(imFuji.RAFVersion, "0100"))
               wb_section_offset = 0x138c;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x138c))
               wb_section_offset = 0x138c;
           }
           else if (!strcmp(model, "X-S1")) // X-S1 0 0x1284
           {
             if (!strcmp(imFuji.RAFVersion, "0100"))
               wb_section_offset = 0x1284;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1284))
               wb_section_offset = 0x1284;
           }
           else if (!strcmp(model, "X10")) // X10 0 0x1280 0x12d4
           {
             if (!strcmp(imFuji.RAFVersion, "0100") ||
                 !strcmp(imFuji.RAFVersion, "0102"))
               wb_section_offset = 0x1280;
             else if (!strcmp(imFuji.RAFVersion, "0103"))
               wb_section_offset = 0x12d4;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1280))
               wb_section_offset = 0x1280;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x12d4))
               wb_section_offset = 0x12d4;
           }
           else if (!strcmp(model, "XF1")) // XF1 0 0x138c
           {
             if (!strcmp(imFuji.RAFVersion, "0100"))
               wb_section_offset = 0x138c;
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x138c))
               wb_section_offset = 0x138c;
           }
+
           if (wb_section_offset &&
               isWB(PrivateMknBuf + posPrivateMknBuf + wb_section_offset))
           {
 
             if (!imFuji.RAFDataVersion)
             {
               posWB = posPrivateMknBuf + wb_section_offset - 6;
               icWBC[LIBRAW_WBI_Auto][1] =
                   icWBC[LIBRAW_WBI_Auto][3] =
                       sget2(PrivateMknBuf + posWB);
               icWBC[LIBRAW_WBI_Auto][0] =
                   sget2(PrivateMknBuf + posWB + 2);
               icWBC[LIBRAW_WBI_Auto][2] =
                   sget2(PrivateMknBuf + posWB + 4);
             }
 
             posWB = posPrivateMknBuf + wb_section_offset;
-            for (int wb_ind = 0; wb_ind < Fuji_wb_list1.size(); posWB += 6, wb_ind++)
+            for (int wb_ind = 0; wb_ind < (int)Fuji_wb_list1.size(); posWB += 6, wb_ind++)
             {
               icWBC[Fuji_wb_list1[wb_ind]][1] =
                   icWBC[Fuji_wb_list1[wb_ind]][3] =
                       sget2(PrivateMknBuf + posWB);
               icWBC[Fuji_wb_list1[wb_ind]][0] =
                   sget2(PrivateMknBuf + posWB + 2);
               icWBC[Fuji_wb_list1[wb_ind]][2] =
                   sget2(PrivateMknBuf + posWB + 4);
             }
             int found = 0;
-            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                (imFuji.RAFDataVersion == 0x0261) || // X100V
-                (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                (imFuji.RAFDataVersion == 0x0264))   // X-S10
+            if (is34)
               posWB += 0x30;
             posWB += 0xc0;
             ushort Gval = sget2(PrivateMknBuf + posWB);
             for (int posEndCCTsection = posWB; posEndCCTsection < (posWB + 30);
                  posEndCCTsection += 6)
             {
               if (sget2(PrivateMknBuf + posEndCCTsection) != Gval)
               {
-                if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                    (imFuji.RAFDataVersion == 0x0261) || // X100V
-                    (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                    (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                if (is34)
                   wb_section_offset = posEndCCTsection - 34*3*2; // 34 records, 3 2-byte values in a record
                 else
                   wb_section_offset = posEndCCTsection - 31*3*2; // 31 records, 3 2-byte values in a record
                 found = 1;
                 break;
               }
             }
 
             if (found)
             {
               for (int iCCT = 0; iCCT < 31; iCCT++)
               {
                 icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];
                 icWBCCTC[iCCT][1] = sget2(PrivateMknBuf + wb_section_offset + iCCT * 6 + 2);
                 icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = sget2(PrivateMknBuf + wb_section_offset + iCCT * 6);
                 icWBCCTC[iCCT][3] = sget2(PrivateMknBuf + wb_section_offset + iCCT * 6 + 4);
               }
             }
           }
         }
         else // process 4K raf data
         {
           int wb[4];
           int nWB, tWB, pWB;
           int iCCT = 0;
           imFuji.RAFDataGeneration = 4096; // X-A3, X-A5, X-A7, X-A10, X-A20, X-T100, X-T200, XF10
           posWB = posPrivateMknBuf + 0x200;
           for (int wb_ind = 0; wb_ind < 42; wb_ind++)
           {
             nWB = sget4(PrivateMknBuf + posWB);
             posWB += 4;
             tWB = sget4(PrivateMknBuf + posWB);
             posWB += 4;
             wb[0] = sget4(PrivateMknBuf + posWB) << 1;
             posWB += 4;
             wb[1] = sget4(PrivateMknBuf + posWB);
             posWB += 4;
             wb[3] = sget4(PrivateMknBuf + posWB);
             posWB += 4;
             wb[2] = sget4(PrivateMknBuf + posWB) << 1;
             posWB += 4;
 
             if (tWB && (iCCT < 255))
             {
               icWBCCTC[iCCT][0] = tWB;
               FORC4 icWBCCTC[iCCT][c + 1] = wb[c];
               iCCT++;
             }
             if (nWB != 0x46)
             {
-              for (pWB = 1; pWB < Fuji_wb_list2.size(); pWB += 2)
+              for (pWB = 1; pWB < (int)Fuji_wb_list2.size(); pWB += 2)
               {
                 if (Fuji_wb_list2[pWB] == nWB)
                 {
                   FORC4 icWBC[Fuji_wb_list2[pWB - 1]][c] = wb[c];
                   break;
                 }
               }
             }
           }
         }
       }
       posPrivateMknBuf += PrivateTagBytes;
     }
     free(PrivateMknBuf);
   }
 #undef get_average_WB
 #undef CHECKSPACE
 }
@@ -734,483 +779,538 @@ void LibRaw::parseAdobeRAFMakernote()
 void LibRaw::parseFujiMakernotes(unsigned tag, unsigned type, unsigned len,
                                  unsigned dng_writer)
 {
   if (tag == 0x0010)
   {
     char FujiSerial[sizeof(imgdata.shootinginfo.InternalBodySerial)];
     char *words[4];
     char yy[2], mm[3], dd[3], ystr[16], ynum[16];
     int year, nwords, ynum_len;
     unsigned c;
     memset(FujiSerial, 0, sizeof(imgdata.shootinginfo.InternalBodySerial));
     ifp->read(FujiSerial, MIN(len,sizeof(FujiSerial)), 1);
     nwords = getwords(FujiSerial, words, 4,
                       sizeof(imgdata.shootinginfo.InternalBodySerial));
     for (int i = 0; i < nwords; i++)
     {
       mm[2] = dd[2] = 0;
       if (strnlen(words[i],
                   sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) < 18)
       {
         if (i == 0)
         {
           strncpy(imgdata.shootinginfo.InternalBodySerial, words[0],
                   sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);
         }
         else
         {
           char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];
           snprintf(tbuf, sizeof(tbuf)-1, "%s %s",
                    imgdata.shootinginfo.InternalBodySerial, words[i]);
           strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,
                   sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);
         }
       }
       else
       {
         strncpy(
             dd,
             words[i] +
                 strnlen(words[i],
                         sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) -
                 14,
             2);
         strncpy(
             mm,
             words[i] +
                 strnlen(words[i],
                         sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) -
                 16,
             2);
         strncpy(
             yy,
             words[i] +
                 strnlen(words[i],
                         sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) -
                 18,
             2);
         year = (yy[0] - '0') * 10 + (yy[1] - '0');
         if (year < 70)
           year += 2000;
         else
           year += 1900;
 
         ynum_len = MIN(
             int(sizeof(ynum) - 1),
             (int)strnlen(words[i],
                          sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) -
                 18);
         strncpy(ynum, words[i], ynum_len);
         ynum[ynum_len] = 0;
         for (int j = 0; ynum[j] && ynum[j + 1] && sscanf(ynum + j, "%2x", &c);
              j += 2)
           ystr[j / 2] = c;
         ynum_len /= 2;
         ystr[ynum_len + 1] = 0;
         strcpy(model2, ystr);
 
         if (i == 0)
         {
           char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];
 
           if (nwords == 1)
           {
             snprintf(
               tbuf, sizeof(tbuf), "%s %d:%s:%s %s",
               ystr, year, mm, dd,
               words[0] +
                 strnlen(words[0], sizeof(imgdata.shootinginfo.InternalBodySerial)-1)-12);
           }
           else
           {
             snprintf(
                 tbuf, sizeof(tbuf), "%s %d:%s:%s %s", ystr, year, mm, dd,
                 words[0] +
                     strnlen(words[0],
                             sizeof(imgdata.shootinginfo.InternalBodySerial) -
                                 1) -
                     12);
           }
           strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,
                   sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);
         }
         else
         {
           char tbuf[sizeof(imgdata.shootinginfo.InternalBodySerial)];
           snprintf(
               tbuf, sizeof(tbuf), "%s %s %d:%s:%s %s",
               imgdata.shootinginfo.InternalBodySerial, ystr, year, mm, dd,
               words[i] +
                   strnlen(words[i],
                           sizeof(imgdata.shootinginfo.InternalBodySerial) - 1) -
                   12);
           strncpy(imgdata.shootinginfo.InternalBodySerial, tbuf,
                   sizeof(imgdata.shootinginfo.InternalBodySerial) - 1);
         }
       }
     }
   }
   else
     switch (tag)
     {
     case 0x1002:
       imFuji.WB_Preset = get2();
       break;
     case 0x1011:
       imCommon.FlashEC = getreal(type);
       break;
     case 0x1020:
       imFuji.Macro = get2();
       break;
     case 0x1021:
       imFuji.FocusMode = imgdata.shootinginfo.FocusMode = get2();
       break;
     case 0x1022:
       imFuji.AFMode = get2();
       break;
     case 0x1023:
       imFuji.FocusPixel[0] = get2();
       imFuji.FocusPixel[1] = get2();
       break;
     case 0x102b:
       imFuji.PrioritySettings = get2();
       break;
     case 0x102d:
       imFuji.FocusSettings = get4();
       break;
     case 0x102e:
       imFuji.AF_C_Settings = get4();
       break;
     case 0x1034:
       imFuji.ExrMode = get2();
       break;
     case 0x104d:
       FujiCropMode = get2(); // odd: one of raw dimensions here can be lost
       break;
     case 0x1050:
       imFuji.ShutterType = get2();
       break;
+    case 0x1100:
+      imFuji.AutoBracketing = get2(); // AutoBracketing = 6 for pixel shift mode 
+      break;
+    case 0x1101:
+      imFuji.SequenceNumber = get2();
+      break;
     case 0x1103:
       imgdata.shootinginfo.DriveMode = get2();
       imFuji.DriveMode = imgdata.shootinginfo.DriveMode & 0xff;
       break;
+    case 0x1105:
+      imFuji.SeriesLength = get2();
+      break;
+    case 0x1106:
+      imFuji.PixelShiftOffset[0] = getreal(type);
+      imFuji.PixelShiftOffset[1] = getreal(type);
+      break;
     case 0x1301:
       imFuji.FocusWarning = get2();
       break;
     case 0x1400:
       imFuji.DynamicRange = get2();
       break;
     case 0x1401:
       imFuji.FilmMode = get2();
       break;
     case 0x1402:
       imFuji.DynamicRangeSetting = get2();
       break;
     case 0x1403:
       imFuji.DevelopmentDynamicRange = get2();
       break;
     case 0x1404:
       ilm.MinFocal = getreal(type);
       break;
     case 0x1405:
       ilm.MaxFocal = getreal(type);
       break;
     case 0x1406:
       ilm.MaxAp4MinFocal = getreal(type);
       break;
     case 0x1407:
       ilm.MaxAp4MaxFocal = getreal(type);
       break;
     case 0x140b:
       imFuji.AutoDynamicRange = get2();
       break;
     case 0x1422:
       imFuji.ImageStabilization[0] = get2();
       imFuji.ImageStabilization[1] = get2();
       imFuji.ImageStabilization[2] = get2();
       imgdata.shootinginfo.ImageStabilization =
           (imFuji.ImageStabilization[0] << 9) + imFuji.ImageStabilization[1];
       break;
+    case 0x1438:
+      imFuji.ImageCount = get2();
+      break;
     case 0x1431:
       imFuji.Rating = get4();
       break;
     case 0x1443:
       imFuji.DRangePriority = get2();
       break;
     case 0x1444:
       imFuji.DRangePriorityAuto = get2();
       break;
     case 0x1445:
       imFuji.DRangePriorityFixed = get2();
       break;
     }
   return;
 }
 
+void LibRaw::parse_fuji_thumbnail(int offset)
+{
+    uchar xmpmarker[] = "http://ns.adobe.com/xap/1.0/";
+    uchar buf[sizeof(xmpmarker)+1];
+    int xmpsz = sizeof(xmpmarker); // we do not
+
+    INT64 pos = ftell(ifp);
+    fseek(ifp, offset, SEEK_SET);
+    ushort s_order = order;
+    order = 0x4a4a; // JPEG is always in MM order
+
+    if (get2() == 0xFFD8)
+    {
+        while (1)
+        {
+          ushort tag = get2();
+          if (tag != 0xFFE1 && tag != 0xFFE2) // allow APP1/APP2 only
+            break;
+          INT64 tpos = ftell(ifp);
+          int len = get2();
+          if (len > xmpsz + 2)
+          {
+              if ((fread(buf, 1, xmpsz, ifp) == xmpsz) && !memcmp(buf, xmpmarker, xmpsz)) // got it
+              {
+                  xmplen = len - xmpsz - 2;
+                  xmpdata = (char*) malloc(xmplen+1);
+                  fread(xmpdata, 1, xmplen, ifp);
+                  xmpdata[xmplen] = 0;
+                  break;
+              }
+          }
+          fseek(ifp, tpos + len, SEEK_SET);
+        }
+    }
+
+    order = s_order;
+    fseek(ifp, pos, SEEK_SET);
+}
+
 void LibRaw::parse_fuji(int offset)
 {
   unsigned entries, tag, len, save, c;
 
 #define get_average_WB(wb_index)                                               \
   FORC4 icWBC[wb_index][GRGB_2_RGBG(c)] = get2();                              \
   if ((len == 16) && average_WBData) {                                         \
     FORC4 icWBC[wb_index][GRGB_2_RGBG(c)] =                                    \
              (icWBC[wb_index][GRGB_2_RGBG(c)] + get2())/2;                     \
   }                                                                            \
   if (use_WBcorr_coeffs) {                                                     \
     icWBC[wb_index][0] *= wbR_corr;                                            \
     icWBC[wb_index][2] *= wbB_corr;                                            \
   }
 
   ushort raw_inset_present = 0;
   ushort use_WBcorr_coeffs = 0;
   double wbR_corr = 1.0;
   double wbB_corr = 1.0;
   ilm.CamID = unique_id;
   int average_WBData = 1;
 
   fseek(ifp, offset, SEEK_SET);
   entries = get4();
   if (entries > 255)
     return;
   imgdata.process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED;
 
   if (strstr(model, "S2Pro")
       || strstr(model, "S20Pro")
       || strstr(model, "F700")
       || strstr(model, "S5000")
       || strstr(model, "S7000")
       ) {
     use_WBcorr_coeffs = 1;
     wbR_corr = 10.0 / 17.0 / 0.652941;
     wbB_corr = 2.0 /3.0 / (3.0 / 4.0 + 1.0 / 300.0);
   } else if (strstr(model, "DBP") || strstr(model, "DX-2000")) {
     use_WBcorr_coeffs = 1;
     wbR_corr = 0.7632653061;
     wbB_corr = 0.8591549296;
   }
 
   while (entries--)
   {
     tag = get2();
     len = get2();
     save = ftell(ifp);
     if (tag == 0x0100) // RawImageFullSize
     {
       raw_height = get2();
       raw_width = get2();
       raw_inset_present = 1;
     }
     else if ((tag == 0x0110) && raw_inset_present) // RawImageCropTopLeft
     {
-      imgdata.sizes.raw_inset_crop.ctop = get2();
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     }
     else if ((tag == 0x0111) && raw_inset_present) // RawImageCroppedSize
     {
-      imgdata.sizes.raw_inset_crop.cheight = get2();
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     }
     else if ((tag == 0x0115) && raw_inset_present) // RawImageAspectRatio
     {
       int a = get2();
       int b = get2();
       if (a * b == 6)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       else if (a * b == 12)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       else if (a * b == 144)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       else if (a * b == 1)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
     }
     else if (tag == 0x0121) // RawImageSize
     {
       height = get2();
       if ((width = get2()) == 4284)
         width += 3;
     }
     else if (tag == 0x0130) // FujiLayout,
     {
       fuji_layout = fgetc(ifp) >> 7;
       fuji_width  = !(fgetc(ifp) & 8);
     }
     else if (tag == 0x0131) // XTransLayout
     {
       filters = 9;
       char *xtrans_abs_alias = &xtrans_abs[0][0];
       FORC(36)
       {
         int q = fgetc(ifp);
         xtrans_abs_alias[35 - c] = MAX(0, MIN(q, 2)); /* & 3;*/
       }
     }
     else if (tag == 0x2ff0) // WB_GRGBLevels
     {
       get_average_WB(LIBRAW_WBI_AsShot);
       FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_AsShot][c];
     }
     else if ((tag == 0x4000) &&
              ((len == 8) || (len == 16)))
     {
       imFuji.BlackLevel[0] = len / 2;
       FORC4 imFuji.BlackLevel[GRGB_2_RGBG(c)+1] = get2();
       if (imFuji.BlackLevel[0] == 8)
         FORC4 imFuji.BlackLevel[GRGB_2_RGBG(c)+5] = get2();
       if (imFuji.BlackLevel[0] == 4)
         FORC4 cblack[c] = imFuji.BlackLevel[c+1];
       else if (imFuji.BlackLevel[0] == 8)
         FORC4 cblack[c] = (imFuji.BlackLevel[c+1]+imFuji.BlackLevel[c+5]) /2;
     }
     else if (tag == 0x9200) // RelativeExposure
     {
       int s1 = get2();
       int s2 = get2();
       if ((s1 == s2) || !s1)
         imFuji.BrightnessCompensation = 0.0f;
       else if ((s1*4) == s2)
         imFuji.BrightnessCompensation = 2.0f;
       else if ((s1*16) == s2)
         imFuji.BrightnessCompensation = 4.0f;
       else
         imFuji.BrightnessCompensation = log(double(s2)/double(s1))/log(2.0);
     }
     else if (tag == 0x9650) // RawExposureBias
     {
       short a = (short)get2();
       float b = fMAX(1.0f, get2());
       imFuji.ExpoMidPointShift = a / b;
       imCommon.ExposureCalibrationShift += imFuji.ExpoMidPointShift;
     }
     else if (tag == 0x2000) // WB_GRGBLevelsAuto
     {
       get_average_WB(LIBRAW_WBI_Auto);
     }
     else if (tag == 0x2100) // WB_GRGBLevelsDaylight
     {
       get_average_WB(LIBRAW_WBI_FineWeather);
     }
     else if (tag == 0x2200) // WB_GRGBLevelsCloudy
     {
       get_average_WB(LIBRAW_WBI_Shade);
     }
     else if (tag == 0x2300) // WB_GRGBLevelsDaylightFluor
     {
       get_average_WB(LIBRAW_WBI_FL_D);
     }
     else if (tag == 0x2301) // WB_GRGBLevelsDayWhiteFluor
     {
       get_average_WB(LIBRAW_WBI_FL_N);
     }
     else if (tag == 0x2302) // WB_GRGBLevelsWhiteFluorescent
     {
       get_average_WB(LIBRAW_WBI_FL_W);
     }
     else if (tag == 0x2310) // WB_GRGBLevelsWarmWhiteFluor
     {
       get_average_WB(LIBRAW_WBI_FL_WW);
     }
     else if (tag == 0x2311) // WB_GRGBLevelsLivingRoomWarmWhiteFluor
     {
       get_average_WB(LIBRAW_WBI_FL_L);
     }
     else if (tag == 0x2400) // WB_GRGBLevelsTungsten
     {
       get_average_WB(LIBRAW_WBI_Tungsten);
     }
     else if (tag == 0x2410)
     {
       get_average_WB(LIBRAW_WBI_Flash);
     }
     else if (tag == 0x2f00) // WB_GRGBLevels
     {
       int nWBs = get4();
       nWBs = MIN(nWBs, 6);
       for (int wb_ind = LIBRAW_WBI_Custom1; wb_ind < LIBRAW_WBI_Custom1+nWBs; wb_ind++) {
         FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] = get2();
-        if ((len >= (4+16*nWBs)) && average_WBData) {
+        if ((len >= unsigned(4+16*nWBs)) && average_WBData) {
           FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                   (icWBC[wb_ind][GRGB_2_RGBG(c)] +get2()) /2;
         }
         if (use_WBcorr_coeffs) {
           icWBC[LIBRAW_WBI_Custom1 + wb_ind][0] *= wbR_corr;
           icWBC[LIBRAW_WBI_Custom1 + wb_ind][2] *= wbB_corr;
         }
       }
     }
 
     else if (tag == 0xc000) // RAFData
     {
       int offsetWH_inRAFData;
       unsigned save_order = order;
       order = 0x4949;
       if (len > 20000)
       {
         uchar RAFDataHeader[16];
         libraw_internal_data.unpacker_data.posRAFData = save;
         libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);
         fread(RAFDataHeader, sizeof RAFDataHeader, 1, ifp);
         offsetWH_inRAFData = guess_RAFDataGeneration(RAFDataHeader);
         fseek(ifp, offsetWH_inRAFData-int(sizeof RAFDataHeader), SEEK_CUR);
         for (int i=0;
-             i<((sizeof imFuji.RAFData_ImageSizeTable) / (sizeof imFuji.RAFData_ImageSizeTable[0]));
+             i< (int)((sizeof imFuji.RAFData_ImageSizeTable) / (sizeof imFuji.RAFData_ImageSizeTable[0]));
              i++) {
           imFuji.RAFData_ImageSizeTable[i] = get4();
         }
 
 //         if ((width > raw_width)
-//             || (raw_inset_present && (width < imgdata.sizes.raw_inset_crop.cwidth))
+//             || (raw_inset_present && (width < imgdata.sizes.raw_inset_crops[0].cwidth))
 //         )
 //           width = raw_width;
 //         if ((height > raw_height)
-//             || (raw_inset_present && (height < imgdata.sizes.raw_inset_crop.cheight))
+//             || (raw_inset_present && (height < imgdata.sizes.raw_inset_crops[0].cheight))
 //         )
 //           height = raw_height;
 //
 
       }
       else if (len == 4096) // X-A3, X-A5, X-A7, X-A10, X-A20, X-T100, X-T200, XF10
       {                     // Ill.A aligned to CCT 2850
         int wb[4];
         int nWB, tWB;
         int iCCT = 0;
         imFuji.RAFDataGeneration = 4096;
         fseek(ifp, save + 0x200, SEEK_SET);
         for (int wb_ind = 0; wb_ind < 42; wb_ind++)
         {
           nWB = get4();
           tWB = get4();
           wb[0] = get4() << 1;
           wb[1] = get4();
           wb[3] = get4();
           wb[2] = get4() << 1;
           if (tWB && (iCCT < 255))
           {
             icWBCCTC[iCCT][0] = tWB;
             FORC4 icWBCCTC[iCCT][c + 1] = wb[c];
             iCCT++;
           }
           if (nWB != 70)
           {
-            for (int pWB = 1; pWB < Fuji_wb_list2.size(); pWB += 2)
+            for (int pWB = 1; pWB < (int)Fuji_wb_list2.size(); pWB += 2)
             {
               if (Fuji_wb_list2[pWB] == nWB)
               {
                 FORC4 icWBC[Fuji_wb_list2[pWB - 1]][c] = wb[c];
                 break;
               }
             }
           }
         }
       }
       order = save_order;
     }
     fseek(ifp, save + len, SEEK_SET);
   }
 
   if (!imFuji.RAFDataGeneration) {
     height <<= fuji_layout;
     width >>= fuji_layout;
   }
 #undef get_average_WB
 }
 
diff --git a/src/metadata/hasselblad_model.cpp b/src/metadata/hasselblad_model.cpp
index f2055024..d61e23a6 100644
--- a/src/metadata/hasselblad_model.cpp
+++ b/src/metadata/hasselblad_model.cpp
@@ -84,451 +84,452 @@ static const char *Hasselblad_Ctrl[] = { // manually selectable options only
 static const char *Hasselblad_SensorEnclosures[] = {
   "CFH", "CFV", "CFV", "CFII", "CF", "Ixpress",
 };
 
   char tmp_model[64];
   const char *ps;
   char *eos;
   int c;
   int nPix = raw_width*raw_height;
   int add_MP_toName = 1;
   int norm_model_isSet = 0;
 
   if (model[0] == ' ')
     memmove(model, model+1, MIN(sizeof(model)-1,strlen(model)));
 
   imHassy.HostBody[0] = 0;
   if ((ps = strrchr(model, '/')))
     strcpy(imHassy.HostBody, ps+1);
   else if ((ps = strrchr(imgdata.color.LocalizedCameraModel, '/')))
     strcpy(imHassy.HostBody, ps+1);
   else if ((ps = strrchr(imgdata.color.UniqueCameraModel, '/')))
     strcpy(imHassy.HostBody, ps+1);
   else if ((ps = strrchr(imHassy.SensorUnitConnector, '/')))
     strcpy(imHassy.HostBody, ps+1);
   if (imHassy.HostBody[0]) {
   	if ((eos = strrchr(imHassy.HostBody, '-')))
   	  *eos = 0;
   }
 
   if (!imHassy.format) {
     if (dng_version) {
       if (!strncmp(software, "Adobe", 5)) {
         if (!imgdata.color.OriginalRawFileName[0] ||
             !imgdata.color.LocalizedCameraModel[0] ||
             !strcasestr(imgdata.color.UniqueCameraModel, "coated"))
           imHassy.format = LIBRAW_HF_AdobeDNG_fromPhocusDNG;
         else
           imHassy.format = LIBRAW_HF_AdobeDNG;
       } else imHassy.format = LIBRAW_HF_HasselbladDNG;
     } else if ((imHassy.nIFD_CM[0] != -1) &&
                (imHassy.nIFD_CM[1] == -1) &&
                !imHassy.mnColorMatrix[0][0]) {
       imHassy.format = LIBRAW_HF_3FR;
     } else imHassy.format = LIBRAW_HF_FFF;
   }
 
   if (imHassy.SensorUnitConnector[0]) {
     char buf[64];
     if (!strncmp(imHassy.SensorUnitConnector, "Hasselblad ", 11))
       memmove(imHassy.SensorUnitConnector, imHassy.SensorUnitConnector+11, 64-11);
     strcpy(buf, imHassy.SensorUnitConnector);
     if ((eos = strrchr(buf, '/'))) {
       *eos = 0;
       if ((eos = strrchr(buf, ' '))) {
         *eos = 0;
         strcpy (imHassy.SensorUnitConnector, buf);
       }
     }
   }
 
   if (imHassy.format == LIBRAW_HF_AdobeDNG) { // Adobe DNG, use LocalizedCameraModel
       imgdata.color.LocalizedCameraModel[63] = 0; // make sure it's 0-terminated
     if ((ps = strrchr(imgdata.color.LocalizedCameraModel, '-')))
       c = ps-imgdata.color.LocalizedCameraModel;
     else c = strlen(imgdata.color.LocalizedCameraModel);
-    int cc = MIN(c, sizeof(tmp_model)-1);
+    int cc = MIN(c, (int)sizeof(tmp_model)-1);
     memcpy(tmp_model, imgdata.color.LocalizedCameraModel,cc);
     tmp_model[cc] = 0;
     if (strcasestr(imgdata.color.UniqueCameraModel, "coated")) {
       strncpy(normalized_model, imgdata.color.UniqueCameraModel,sizeof(imgdata.color.UniqueCameraModel)-1);
       normalized_model[sizeof(imgdata.color.UniqueCameraModel) - 1] = 0;
       norm_model_isSet = 1;
     }
       if (!strncmp(normalized_model, "Hasselblad ", 11))
         memmove(normalized_model, normalized_model+11, 64-11);
   } else {
     if ((ps = strrchr(imgdata.color.UniqueCameraModel, '/'))) {
       c = ps-imgdata.color.UniqueCameraModel;
     }
     else c = strlen(imgdata.color.UniqueCameraModel);
-    int cc = MIN(c, sizeof(tmp_model)-1);
+    int cc = MIN(c, (int)sizeof(tmp_model)-1);
     memcpy(tmp_model, imgdata.color.UniqueCameraModel,cc);
     tmp_model[cc] = 0;
   }
   if (!strncasecmp(tmp_model, "Hasselblad ", 11))
     memmove(tmp_model, tmp_model+11, 64-11);
 
   strncpy(imHassy.CaptureSequenceInitiator, model,31);
   imHassy.CaptureSequenceInitiator[31] = 0;
   if ((eos = strrchr(imHassy.CaptureSequenceInitiator, '/'))) {
     *eos = 0;
   }
 // check if model tag contains manual CaptureSequenceInitiator info:
   FORC(int(sizeof Hasselblad_Ctrl / sizeof *Hasselblad_Ctrl)) {
     if (strcasestr(model, Hasselblad_Ctrl[c])) {
 // yes, fill 'model' with sensor unit data
       strncpy(model, tmp_model,63);
       model[63] = 0;
       break;
     }
   }
 
   if (!imHassy.HostBody[0]) {
     ps = strchr(model, '-');
     if (ps) {                  // check if model contains both host body and sensor version, resolution, MS info
       strncpy(imHassy.SensorUnit, model,63);
       memcpy(imHassy.HostBody, model, ps-model);
       imHassy.HostBody[ps-model] = 0;
       if (!strncmp(ps-2, "II-", 3))
         ps -=2;
       strncpy(imHassy.Sensor, ps,7);
       imHassy.Sensor[7] = 0;
       add_MP_toName = 0;
     } else { // model contains host body only
       strncpy(imHassy.HostBody, model,63);
       imHassy.HostBody[63] = 0;
   // fill 'model' with sensor unit data
       strncpy(model, tmp_model,63);
       model[63] = 0;
     }
   }
 
   if (strstr(model, "503CWD")) {
     strncpy(imHassy.HostBody, model,63);
     imHassy.HostBody[63] = 0;
     ilm.CameraFormat = LIBRAW_FORMAT_66;
     ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_V;
     if (model[6] == 'I' && model[7] == 'I')
       strcpy(model, "CFVII");
     else strcpy(model, "CFV");
   } else if (strstr(model, "Hasselblad") &&
              (model[10] != ' ')) {
     strcpy(model, "CFV");
     ilm.CameraMount = LIBRAW_MOUNT_DigitalBack;
   } else {
     FORC(int(sizeof Hasselblad_SensorEnclosures / sizeof *Hasselblad_SensorEnclosures)) {
       if (strcasestr(model, Hasselblad_SensorEnclosures[c])) {
         if (add_MP_toName) strcpy(model, Hasselblad_SensorEnclosures[c]);
         ilm.CameraMount = LIBRAW_MOUNT_DigitalBack;
         break;
       }
     }
   }
 
 #define cpynorm(str)                \
   if (!norm_model_isSet) {          \
     strcpy(normalized_model, str);  \
     norm_model_isSet = 1;           \
   }
 
   if ((imHassy.SensorCode == 4) &&
       (imHassy.CoatingCode < 2)) {
     strcpy(imHassy.Sensor, "-16");
     cpynorm("16-Uncoated");
 
   } else if ((imHassy.SensorCode == 6) &&
              (imHassy.CoatingCode < 2)) {
     strcpy(imHassy.Sensor, "-22");
     cpynorm("22-Uncoated");
 
   } else if ((imHassy.SensorCode == 8) &&
              (imHassy.CoatingCode == 1)) {
     strcpy(imHassy.Sensor, "-31");
     cpynorm("31-Uncoated");
 
   } else if ((imHassy.SensorCode == 9) &&
              (imHassy.CoatingCode < 2)) {
     strcpy(imHassy.Sensor, "-39");
     cpynorm("39-Uncoated");
 
   } else if ((imHassy.SensorCode == 9) &&
              (imHassy.CoatingCode == 4)) {
     strcpy(imHassy.Sensor, "-39");
     strcpy(model, "H3DII");
     add_MP_toName = 1;
     cpynorm("39-Coated");
 
   } else if ((imHassy.SensorCode == 13) &&
              (imHassy.CoatingCode == 4)) {
     strcpy(imHassy.Sensor, "-40");
     cpynorm("40-Coated");
 
   } else if ((imHassy.SensorCode == 13) &&
              (imHassy.CoatingCode == 5)) {
     strcpy(imHassy.Sensor, "-40");
     cpynorm("40-Coated5");
 
   } else if ((imHassy.SensorCode == 11) &&
              (imHassy.CoatingCode == 4)) {
     if (!strncmp(model, "H3D", 3))
       strcpy(model, "H3DII-50");
     else strcpy(imHassy.Sensor, "-50");
     cpynorm("50-Coated");
 
   } else if ((imHassy.SensorCode == 11) &&
              (imHassy.CoatingCode == 5)) {
     strcpy(imHassy.Sensor, "-50");
     cpynorm("50-Coated5");
 
   } else if ((imHassy.SensorCode == 15) &&
              (imHassy.CoatingCode == 5)) {
     strcpy(imHassy.Sensor, "-50c");
     cpynorm("50-15-Coated5");
     if (!strncmp(imHassy.CaptureSequenceInitiator, "CFV II 50C", 10)) {
       imHassy.SensorSubCode = 2;
       add_MP_toName = 0;
       strcat(imHassy.Sensor, " II");
       strcpy(model, "CFV II 50C");
       strcat(normalized_model, "-II");
     } else if (!strncmp(imHassy.CaptureSequenceInitiator, "X1D", 3)) {
       imHassy.SensorSubCode = 2;
       add_MP_toName = 0;
       strcat(imHassy.Sensor, " II");
       if (!strncasecmp(imHassy.CaptureSequenceInitiator, "X1D II 50C", 10)) {
         strcpy(model, "X1D II 50C");
         strcat(normalized_model, "-II");
       } else {
         strcpy(model, "X1D-50c");
       }
     }
 
   } else if ((imHassy.SensorCode == 12) &&
              (imHassy.CoatingCode == 4)) {
     strcpy(imHassy.Sensor, "-60");
     cpynorm("60-Coated");
 
   } else if ((imHassy.SensorCode == 17) &&
              (imHassy.CoatingCode == 5)) {
     strcpy(imHassy.Sensor, "-100c");
     cpynorm("100-17-Coated5");
 
   } else if ((raw_width == 4090) || // V96C
              ((raw_width == 4096) && (raw_height == 4096)) ||
              ((raw_width == 4088) && (raw_height == 4088)) || // Adobe crop
              ((raw_width == 4080) && (raw_height == 4080))) { // Phocus crop
     strcpy(imHassy.Sensor, "-16");
     cpynorm("16-Uncoated");
     if (!imHassy.SensorCode) imHassy.SensorCode = 4;
 
   } else if ((raw_width == 5568) && (raw_height == 3648)) {
     strcpy(imHassy.Sensor, "-20c");
 
   } else if (((raw_width == 4096) && (raw_height == 5456)) ||
              ((raw_width == 4088) && (raw_height == 5448)) ||  // Adobe crop
              ((raw_width == 4080) && (raw_height == 5440))) {  // Phocus crop
     strcpy(imHassy.Sensor, "-22");
     cpynorm("22-Uncoated");
     if (!imHassy.SensorCode) imHassy.SensorCode = 6;
 
   } else if (((raw_width == 6542) && (raw_height == 4916)) ||
              ((raw_width == 6504) && (raw_height == 4880)) || // Adobe crop
              ((raw_width == 6496) && (raw_height == 4872))) { // Phocus crop
     strcpy(imHassy.Sensor, "-31");
     cpynorm("31-Uncoated");
     if (!imHassy.SensorCode) imHassy.SensorCode = 8;
 
   } else if (((raw_width == 7262) && (raw_height == 5456)) || //
              ((raw_width == 7224) && (raw_height == 5420)) || // Adobe crop
              ((raw_width == 7216) && (raw_height == 5412)) || // Phocus crop
              ((raw_width == 7212) && (raw_height == 5412)) || // CF-39, CFV-39, possibly v.II; Phocus crop
 // uncropped, when the exact size is unknown, should be:
 // - greater or equal to the smallest Phocus crop for the current size
 // - smaller than the smallest Phocus crop for the next size
            ((nPix >= 7212*5412) && (nPix < 7304*5478))) {
     strcpy(imHassy.Sensor, "-39");
     if (!imHassy.SensorCode) imHassy.SensorCode = 9;
     if (!strncmp(model, "H3D", 3)) {
       if (((imHassy.format == LIBRAW_HF_Imacon) ||
           strstr(imgdata.color.UniqueCameraModel, "H3D-39") ||
           strstr(imgdata.color.LocalizedCameraModel, "H3D-39") ||
           strstr(model, "H3D-39")) &&
           !strstr(imgdata.color.UniqueCameraModel, "II") &&
           !strstr(imgdata.color.LocalizedCameraModel, "II") &&
           !strstr(model, "II")) {
         strcpy(model, "H3D-39");
         add_MP_toName = 0;
         cpynorm("39-Uncoated");
 
       } else {
         strcpy(model, "H3DII-39");
         add_MP_toName = 0;
         cpynorm("39-Coated");
         if (!imHassy.CoatingCode) imHassy.CoatingCode = 4;
       }
 
     } else
       cpynorm("39-Uncoated");
 
   } else if (((raw_width == 7410) && (raw_height == 5586)) || // (H4D-40, H5D-40)
              ((raw_width == 7312) && (raw_height == 5486)) || // Adobe crop
              ((raw_width == 7304) && (raw_height == 5478))) { // Phocus crop
     strcpy(imHassy.Sensor, "-40");
     if (!strncmp(model, "H4D", 3)) {
       cpynorm("40-Coated");
       if (!imHassy.SensorCode) imHassy.SensorCode = 13;
       if (!imHassy.CoatingCode) imHassy.CoatingCode = 4;
     } else {
       cpynorm("40-Coated5");
       if (!imHassy.SensorCode) imHassy.SensorCode = 13;
       if (!imHassy.CoatingCode) imHassy.CoatingCode = 5;
     }
 
   } else if (((raw_width == 8282) && (raw_height == 6240)) || // (CFV-50, H3DII-50, H5D-50)
              ((raw_width == 8184) && (raw_height == 6140)) || // Adobe crop
              ((raw_width == 8176) && (raw_height == 6132))) { // Phocus crop
     strcpy(imHassy.Sensor, "-50");
     if (!strncmp(model, "H5D", 3)) {
       cpynorm("50-Coated5");
       if (!imHassy.SensorCode) imHassy.SensorCode = 11;
       if (!imHassy.CoatingCode) imHassy.CoatingCode = 5;
     } else {
       cpynorm("50-Coated"); // CFV-50, H3DII-50,
       if (!strncmp(model, "H3D", 3)) {
         strcpy(model, "H3DII-50");
       if (!imHassy.SensorCode) imHassy.SensorCode = 11;
       if (!imHassy.CoatingCode) imHassy.CoatingCode = 4;
         add_MP_toName = 0;
       }
     }
 
   } else if (((raw_width == 8374) && (raw_height == 6304)) ||  // (H5D-50c)
              ((raw_width == 8384) && (raw_height == 6304)) ||  // (X1D-50c, "X1D II 50C", "CFV II 50C")
              ((raw_width == 8280) && (raw_height == 6208)) ||  // Adobe crop
              ((raw_width == 8272) && (raw_height == 6200))) {  // Phocus crop
     cpynorm("50-15-Coated5");
     if (!imHassy.SensorCode) imHassy.SensorCode = 15;
     if (!imHassy.CoatingCode) imHassy.CoatingCode = 5;
     strcpy(imHassy.Sensor, "-50c");
     if ((raw_width == 8384) ||
         !strncmp(imHassy.CaptureSequenceInitiator, "X1D", 3) ||
         !strncmp(imHassy.CaptureSequenceInitiator, "CFV II", 6)) {
       imHassy.SensorSubCode = 2;
       add_MP_toName = 0;
       strcat(imHassy.Sensor, " II");
       if (strstr(imHassy.CaptureSequenceInitiator, " II ")) {
           strcat(normalized_model, "-II");
         if (!strncasecmp(imHassy.CaptureSequenceInitiator, "X1D II 50C", 10)) {
           strcpy(model, "X1D II 50C");
         } else if (!strncasecmp(imHassy.CaptureSequenceInitiator, "CFV II 50C", 10)) {
           strcpy(model, "CFV II 50C");
         }
       } else {
         strcpy(model, "X1D-50c");
       }
     }
 
   } else if (((raw_width == 9044) && (raw_height == 6732)) ||
              ((raw_width == 8964) && (raw_height == 6716)) || // Adobe crop
              ((raw_width == 8956) && (raw_height == 6708))) { // Phocus crop
     strcpy(imHassy.Sensor, "-60");
     cpynorm("60-Coated");
     if (!imHassy.SensorCode) imHassy.SensorCode = 12;
     if (!imHassy.CoatingCode) imHassy.CoatingCode = 4;
 
 
   } else if (((raw_width == 10320) && (raw_height == 7752)) || // Phocus crop, A5D-80
              ((nPix >= 10320*7752) && (nPix < 10520*8000))) {
     strcpy(imHassy.Sensor, "-80");
     cpynorm("80-Coated");
 
   } else if (((raw_width == 12000) && (raw_height == 8816)) ||
              ((raw_width == 11608) && (raw_height == 8708)) || // Adobe crop
              ((raw_width == 11600) && (raw_height == 8700))) {  // Phocus crop
     strcpy(imHassy.Sensor, "-100c");
     cpynorm("100-17-Coated5");
     if (!imHassy.SensorCode) imHassy.SensorCode = 17;
     if (!imHassy.CoatingCode) imHassy.CoatingCode = 5;
 
   }
 
   if (raw_width == 4090)
     strcpy(model, "V96C");
 
   if (
     (raw_width == 4090) ||
 		((raw_width ==  4096) && (raw_height ==  4096)) ||
 		((raw_width ==  5568) && (raw_height ==  3648)) ||
 		((raw_width ==  4096) && (raw_height ==  5456)) ||
 		((raw_width ==  6542) && (raw_height ==  4916)) ||
 		((raw_width ==  7262) && (raw_height ==  5456)) ||
 		((raw_width ==  7410) && (raw_height ==  5586)) ||
 		((raw_width ==  8282) && (raw_height ==  6240)) ||
 		((raw_width ==  8374) && (raw_height ==  6304)) ||
 		((raw_width ==  8384) && (raw_height ==  6304)) ||
 		((raw_width ==  9044) && (raw_height ==  6732)) ||
 		((raw_width == 10320) && (raw_height ==  7752)) ||
 		((raw_width == 12000) && (raw_height ==  8816))
 	)
 	imHassy.uncropped = 1;
 
 
   if (model[0] && add_MP_toName)
     strcat(model, imHassy.Sensor);
   if (imHassy.Sensor[0] == '-')
     memmove(imHassy.Sensor, imHassy.Sensor+1, strlen(imHassy.Sensor));
 
   if (dng_version &&
       (imHassy.SensorCode == 13) &&
       (imHassy.CoatingCode == 4)) {
     c = LIBRAW_HF_AdobeDNG;
   } else if ((imHassy.format == LIBRAW_HF_HasselbladDNG) ||
              (imHassy.format == LIBRAW_HF_AdobeDNG_fromPhocusDNG)) {
     c = LIBRAW_HF_FFF;
   } else if (imHassy.format == LIBRAW_HF_Imacon) {
     c = LIBRAW_HF_3FR;
   } else {
     c = imHassy.format;
   }
   ps = HassyRawFormat_idx2HR(c);
   if ((c == LIBRAW_HF_3FR) ||
       (c == LIBRAW_HF_FFF))
     strcat(normalized_model, ps);
 
   if (((imHassy.CaptureSequenceInitiator[0] == 'H') &&
        (imHassy.CaptureSequenceInitiator[1] != 'a')) ||
       ((imHassy.CaptureSequenceInitiator[0] == 'A') &&
        isdigit(imHassy.CaptureSequenceInitiator[1]))) {
     ilm.CameraFormat = LIBRAW_FORMAT_645;
     ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_H;
     if (imgdata.lens.Lens[0] == 'H')
       process_Hassy_Lens(LIBRAW_MOUNT_Hasselblad_H);
   } else if (((imHassy.CaptureSequenceInitiator[0] == 'X') &&
               isdigit(imHassy.CaptureSequenceInitiator[1])) ||
              !strncmp(imHassy.HostBody, "907", 3)) {
     ilm.CameraFormat = LIBRAW_FORMAT_CROP645;
     ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_XCD;
     if (imgdata.lens.Lens[0] == 'H') {
       process_Hassy_Lens(LIBRAW_MOUNT_Hasselblad_H);
       strcpy(ilm.Adapter, "XH");
     } else {
       if (imgdata.lens.Lens[0] == 'X') {
         process_Hassy_Lens(LIBRAW_MOUNT_Hasselblad_XCD);
       } else if (!imgdata.lens.Lens[0] &&
                  (aperture > 1.0f)   &&
                  (focal_len > 10.0f)) {
         ilm.LensID = focal_len;
         if (ilm.LensID == 35) {
           ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
           ilm.LensID = LIBRAW_MOUNT_Hasselblad_XCD*100000000ULL +
                        35*10000ULL + 75*10;
         }
-        else
+        else {
           ilm.FocalType = LIBRAW_FT_PRIME_LENS;
           ilm.LensID = LIBRAW_MOUNT_Hasselblad_XCD*100000000ULL +
                        ilm.LensID*10000ULL + ilm.LensID*10;
+        }
       }
     }
   }
   if (normalized_model[0]  && !CM_found)
     CM_found = adobe_coeff(maker_index, normalized_model);
 }
diff --git a/src/metadata/identify.cpp b/src/metadata/identify.cpp
index e3bc3d97..68ad488e 100644
--- a/src/metadata/identify.cpp
+++ b/src/metadata/identify.cpp
@@ -22,86 +22,87 @@
 // clang-format on
 static const struct
 {
     const int CorpId;
     const char *CorpName;
 } CorpTable[] = {
     {LIBRAW_CAMERAMAKER_Agfa,           "AgfaPhoto"},
     {LIBRAW_CAMERAMAKER_Apple,          "Apple"},
     {LIBRAW_CAMERAMAKER_Broadcom,       "Broadcom"},
     {LIBRAW_CAMERAMAKER_Canon,          "Canon"},
     {LIBRAW_CAMERAMAKER_Casio,          "Casio"},
     {LIBRAW_CAMERAMAKER_CINE,           "CINE"},
     {LIBRAW_CAMERAMAKER_Epson,          "Epson"},
     {LIBRAW_CAMERAMAKER_Fujifilm,       "Fujifilm"},
     {LIBRAW_CAMERAMAKER_Mamiya,         "Mamiya"},
     {LIBRAW_CAMERAMAKER_Motorola,       "Motorola"},
     {LIBRAW_CAMERAMAKER_Kodak,          "Kodak"},
     {LIBRAW_CAMERAMAKER_Konica,         "Konica"},
     {LIBRAW_CAMERAMAKER_Minolta,        "Minolta"},
     {LIBRAW_CAMERAMAKER_Leica,          "Leica"},
     {LIBRAW_CAMERAMAKER_Nikon,          "Nikon"},
     {LIBRAW_CAMERAMAKER_Nokia,          "Nokia"},
     {LIBRAW_CAMERAMAKER_Olympus,        "Olympus"},
     {LIBRAW_CAMERAMAKER_Ricoh,          "Ricoh"},
     {LIBRAW_CAMERAMAKER_Pentax,         "Pentax"},
     {LIBRAW_CAMERAMAKER_PhaseOne,       "Phase One"},
     {LIBRAW_CAMERAMAKER_PhaseOne,       "PhaseOne"},
     {LIBRAW_CAMERAMAKER_Samsung,        "Samsung"},
     {LIBRAW_CAMERAMAKER_Sigma,          "Sigma"},
     {LIBRAW_CAMERAMAKER_Sinar,          "Sinar"},
     {LIBRAW_CAMERAMAKER_Sony,           "Sony"},
     {LIBRAW_CAMERAMAKER_YI,             "YI"},
     // add corp. names below
     {LIBRAW_CAMERAMAKER_Alcatel,        "Alcatel"},
     {LIBRAW_CAMERAMAKER_Aptina,         "Aptina"},
     {LIBRAW_CAMERAMAKER_AVT,            "AVT"},
     {LIBRAW_CAMERAMAKER_Baumer,         "Baumer"},
     {LIBRAW_CAMERAMAKER_Clauss,         "Clauss"},
     {LIBRAW_CAMERAMAKER_Contax,         "Contax"},
     {LIBRAW_CAMERAMAKER_Creative,       "Creative"},
     {LIBRAW_CAMERAMAKER_DJI,            "DJI"},
     {LIBRAW_CAMERAMAKER_Foculus,        "Foculus"},
     {LIBRAW_CAMERAMAKER_Generic,        "Generic"},
     {LIBRAW_CAMERAMAKER_Gione,          "Gione"},
     {LIBRAW_CAMERAMAKER_GITUP,          "GITUP"},
     {LIBRAW_CAMERAMAKER_Hasselblad,     "Hasselblad"},
     {LIBRAW_CAMERAMAKER_HTC,            "HTC"},
     {LIBRAW_CAMERAMAKER_I_Mobile,       "I_Mobile"},
     {LIBRAW_CAMERAMAKER_Imacon,         "Imacon"},
     {LIBRAW_CAMERAMAKER_ISG,            "ISG"},
     {LIBRAW_CAMERAMAKER_JK_Imaging,     "JK Imaging"}, // Kodak
     {LIBRAW_CAMERAMAKER_Leaf,           "Leaf"},
     {LIBRAW_CAMERAMAKER_Lenovo,         "Lenovo"},
     {LIBRAW_CAMERAMAKER_LG,             "LG"},
     {LIBRAW_CAMERAMAKER_Logitech,       "Logitech"},
     {LIBRAW_CAMERAMAKER_Matrix,         "Matrix"},
     {LIBRAW_CAMERAMAKER_Meizu,          "Meizu"},
     {LIBRAW_CAMERAMAKER_Micron,         "Micron"},
     {LIBRAW_CAMERAMAKER_NGM,            "NGM"},
     {LIBRAW_CAMERAMAKER_OmniVison,      "OmniVison"},
     {LIBRAW_CAMERAMAKER_Panasonic,      "Panasonic"},
     {LIBRAW_CAMERAMAKER_Photron,        "Photron"},
     {LIBRAW_CAMERAMAKER_Pixelink,       "Pixelink"},
     {LIBRAW_CAMERAMAKER_Polaroid,       "Polaroid"},
     {LIBRAW_CAMERAMAKER_Rollei,         "Rollei"},
     {LIBRAW_CAMERAMAKER_RoverShot,      "RoverShot"},
     {LIBRAW_CAMERAMAKER_SMaL,           "SMaL"},
     {LIBRAW_CAMERAMAKER_ST_Micro,       "ST Micro"},
     {LIBRAW_CAMERAMAKER_THL,            "THL"},
     {LIBRAW_CAMERAMAKER_Xiaomi,         "Xiaomi"},
     {LIBRAW_CAMERAMAKER_XIAOYI,         "Xiayi"},
     {LIBRAW_CAMERAMAKER_Yuneec,         "Yuneec"},
     {LIBRAW_CAMERAMAKER_DXO,            "DxO"},
     {LIBRAW_CAMERAMAKER_RED,            "Red"},
     {LIBRAW_CAMERAMAKER_PhotoControl,   "Photo Control"},
     {LIBRAW_CAMERAMAKER_Google,         "Google"},
     {LIBRAW_CAMERAMAKER_GoPro,          "GoPro"},
     {LIBRAW_CAMERAMAKER_Parrot,         "Parrot"},
     {LIBRAW_CAMERAMAKER_Zeiss,          "Zeiss"},
     {LIBRAW_CAMERAMAKER_OnePlus,        "OnePlus"},
     {LIBRAW_CAMERAMAKER_VIVO,           "Vivo"},
     {LIBRAW_CAMERAMAKER_HMD_Global,     "HMD Global"},
     {LIBRAW_CAMERAMAKER_HUAWEI,         "Huawei"},
+    {LIBRAW_CAMERAMAKER_RaspberryPi,    "RaspberryPi"},
 };
 // clang-format on
 
@@ -156,946 +157,971 @@ void LibRaw::fixupArri()
         {"ALEXA", "Alexa Plus 4:3 XT", 2592 ,2160, 256,0x61616161,1.12f},
         {"ALEXA", "Alexa Plus 4:3 XT", 2880 ,2160, 256,0x61616161,1.f},
         {"ALEXA", "Alexa Plus 4:3 XT", 2880 ,1620, 256,0x61616161,0.75f},
         {"ALEXA", "Alexa Plus 4:3 XT", 3424 ,2202, 256,0x61616161,1.f},
     };
     for(int i = 0; i < int(sizeof(alist)/sizeof(alist[0])); i++)
         if(!strncasecmp(model,alist[i].a_model,strlen(alist[i].a_model)) && software
             && !strncasecmp(software,alist[i].a_software,strlen(alist[i].a_software))
             && width == alist[i].a_width && height == alist[i].a_height)
         {
             filters = alist[i].a_filters;
             black = alist[i].a_black;
             pixel_aspect = alist[i].a_aspect;
             strcpy(model,software);
             software[0]=0;
             return;
         }
 }
 #endif
 /*
    Identify which camera created this file, and set global variables
    accordingly.
  */
 void LibRaw::identify()
 {
   // clang-format off
   static const ushort canon[][11] = {
-      // raw_width, raw_height, left_margin, top_margin, width_decrement,
-      // height_decrement, mask01, mask03, mask11,
-	  // mask13, CFA_filters.
+      // raw_width, raw_height, left_margin, top_margin,
+      // width_decrement, height_decrement,
+      // mask01, mask03, mask11, mask13,
+      // CFA_filters.
 	  { 1944, 1416, 0, 0, 48, 0 }, // 00 "PowerShot Pro90 IS"
 	  { 2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25 }, // 01 "PowerShot S30", "PowerShot G1"
 	  { 2224, 1456, 48, 6, 0, 2 }, // 02 "EOS D30"
 	  { 2376, 1728, 12, 6, 52, 2 }, // 03 "PowerShot G2", "PowerShot S40", "PowerShot G3", "PowerShot S45"
 	  { 2672, 1968, 12, 6, 44, 2 }, // 04 "PowerShot G5", "PowerShot S50", "PowerShot S60"
 	  { 3152, 2068, 64, 12, 0, 0, 16 }, // 05 "EOS D60", "EOS 10D", "EOS 300D"
 	  { 3160, 2344, 44, 12, 4, 4 }, // 06 "PowerShot G6", "PowerShot S70"
 	  { 3344, 2484, 4, 6, 52, 6 }, // 07 "PowerShot Pro1"
 	  { 3516, 2328, 42, 14, 0, 0 }, // 08 "EOS 350D"
 	  { 3596, 2360, 74, 12, 0, 0 }, // 09 "EOS-1D Mark II", "EOS 20D", "EOS-1D Mark II N", "EOS 30D"
 	  { 3744, 2784, 52, 12, 8, 12 }, // 10 "PowerShot G11", "PowerShot S90", "PowerShot G12", "PowerShot S95"
 	  { 3944, 2622, 30, 18, 6, 2 }, // 11 "EOS 40D"
 	  { 3948, 2622, 42, 18, 0, 2 }, // 12 "EOS 400D", "EOS 1000D"
 	  { 3984, 2622, 76, 20, 0, 2, 14 }, // 13 "EOS-1D Mark III"
 	  { 4032, 2656, 112, 44, 10, 0 }, // 14 APS-C crop mode: "EOS 6D Mark II"??, "EOS RP"
 	  { 4104, 3048, 48, 12, 24, 12 }, // 15 "PowerShot G9"
 	  { 4116, 2178, 4, 2, 0, 0 },  // 16 ??
 	  { 4152, 2772, 192, 12, 0, 0 }, // 17 "PowerShot SX1 IS"
 	  { 4160, 3124, 104, 11, 8, 65 }, // 18 "PowerShot S100 (new)", "PowerShot S100V", "PowerShot G15", "PowerShot S110 (new)"
 	  { 4176, 3062, 96, 17, 8, 0, 0, 16, 0, 7, 0x49 }, // 19 "PowerShot SX50 HS"
 	  { 4192, 3062, 96, 17, 24, 0, 0, 16, 0, 0, 0x49 }, // 20 "PowerShot G16", "PowerShot S120"
 	  { 4312, 2876, 22, 18, 0, 2 }, // 21 "EOS 450D"
 	  { 4352, 2850, 144, 46, 0, 0 }, // 22 APS-C crop mode: "EOS R"
 	  { 4352, 2874, 62, 18, 0, 0 }, // 23 "EOS 1100D"
 	  { 4476, 2954, 90, 34, 0, 0 }, // 24 "EOS 5D"
 	  { 4480, 3348, 12, 10, 36, 12, 0, 0, 0, 18, 0x49 }, // 25 "PowerShot G10"
 	  { 4480, 3366, 80, 50, 0, 0 }, // 26 "PowerShot G1 X Mark II"
 	  { 4496, 3366, 80, 50, 12, 0 }, // 27 "PowerShot G1 X"
 	  { 4768, 3516, 96, 16, 0, 0, 0, 16 }, // 28 "PowerShot SX60 HS"
 	  { 4832, 3204, 62, 26, 0, 0 }, // 29 "EOS 500D"
 	  { 4832, 3228, 62, 51, 0, 0 }, // 30 "EOS 50D"
 	  { 5108, 3349, 98, 13, 0, 0 }, // 31 "EOS-1Ds Mark II"
 	  { 5120, 3318, 142, 45, 62, 0 }, // 32  "EOS-1D Mark IV"
 	  { 5280, 3528, 72, 52, 0, 0 }, // 33 "EOS M10", "EOS 650D", "EOS 700D", "EOS M", "EOS 100D", "EOS M2"
 	  { 5344, 3516, 142, 51, 0, 0 }, // 34 "EOS 550D", "EOS 600D", "EOS 60D", "EOS 1200D", "EOS 1300D", "EOS 3000D"
 	  { 5344, 3584, 126, 100, 0, 2 }, // 35 "EOS-1D X", "EOS-1D C"
 	  { 5344, 3950, 98, 18, 0, 0, 0, 24, 0, 0 }, // 36 "PowerShot SX70 HS"
 	  { 5360, 3516, 158, 51, 0, 0 }, // 37 "EOS 7D"
 	  { 5568, 3708, 72, 38, 0, 0 }, // 38; "EOS 7D Mark II", "EOS 6D", "EOS 70D", "EOS-1D X MARK II"
 	  { 5632, 3710, 96, 17, 0, 0, 0, 16, 0, 0, 0x49 }, // 39 "PowerShot G7 X", "PowerShot G3 X", "PowerShot G9 X", "PowerShot G5 X", "PowerShot G7 X Mark II", "PowerShot G9 X Mark II"
 	  { 5712, 3774, 62, 20, 10, 2 }, // 40 "EOS-1Ds Mark III"
 	  { 5792, 3804, 158, 51, 0, 0 }, // 41 "EOS 5D Mark II"
 	  { 5920, 3950, 122, 80, 2, 0 }, // 42 "EOS 5D Mark III"
 	  { 6096, 4051, 76, 35, 0, 0 }, // 43 "EOS 1500D"
 	  { 6096, 4056, 72, 34, 0, 0 }, // 44 "EOS M3", "EOS 760D", "EOS 750D"
 	  { 6288, 4056, 264, 36, 0, 0 }, // 45 "EOS M5", "EOS M100", "EOS M6", "PowerShot G1 X Mark III", "EOS 80D", "EOS 800D", "EOS 77D", "EOS 200D", "EOS 250D", "EOS M50"
 	  { 6384, 4224, 120, 44, 0, 0 }, // 46 "EOS 6D Mark II", "EOS RP"
 	  { 6880, 4544, 136, 42, 0, 0 }, // 47 "EOS 5D Mark IV"
 	  { 6888, 4546, 146, 48, 0, 0 }, // 48 "EOS R"
 	  { 7128, 4732, 144, 72, 0, 0 }, // 49 "EOS M6 II", "EOS 90D"
 	  { 8896, 5920, 160, 64, 0, 0 }, // 50 "EOS 5DS", "EOS 5DS R"
   };
 
   static const libraw_custom_camera_t const_table[] = {
 	  { 786432, 1024, 768, 0, 0, 0, 0, 0, 0x94, 0, 0, "AVT", "F-080C" },
 	  { 1447680, 1392, 1040, 0, 0, 0, 0, 0, 0x94, 0, 0, "AVT", "F-145C" },
 	  { 1920000, 1600, 1200, 0, 0, 0, 0, 0, 0x94, 0, 0, "AVT", "F-201C" },
 	  { 5067304, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, "AVT", "F-510C" },
 	  { 5067316, 2588, 1958, 0, 0, 0, 0, 0, 0x94, 0, 0, "AVT", "F-510C", 12 },
 	  { 10134608, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, "AVT", "F-510C" },
 	  { 10134620, 2588, 1958, 0, 0, 0, 0, 9, 0x94, 0, 0, "AVT", "F-510C", 12 },
 	  { 16157136, 3272, 2469, 0, 0, 0, 0, 9, 0x94, 0, 0, "AVT", "F-810C" },
 	  { 15980544, 3264, 2448, 0, 0, 0, 0, 8, 0x61, 0, 1, "AgfaPhoto", "DC-833m" },
 	  { 9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, "Alcatel", "5035D" },
 	  { 31850496, 4608, 3456, 0, 0, 0, 0, 0, 0x94, 0, 0, "GITUP", "GIT2 4:3" },
 	  { 23887872, 4608, 2592, 0, 0, 0, 0, 0, 0x94, 0, 0, "GITUP", "GIT2 16:9" },
 	  { 32257024, 4624, 3488, 8, 2, 16, 2, 0, 0x94, 0, 0, "GITUP", "GIT2P 4:3" },
 	  { 24192768, 4624, 2616, 8, 2, 16, 2, 0, 0x94, 0, 0, "GITUP", "GIT2P 16:9" },
 	  { 18016000, 4000, 2252, 0, 0, 0, 0, 0, 0x94, 0, 0, "GITUP", "G3DUO 16:9" },
 	  //          {24000000, 4000, 3000, 0, 0, 0, 0, 0, 0x94, 0, 0, "GITUP",
       //          "G3DUO 4:3"}, // Conflict w/ Samsung WB550
 
       //   Android Raw dumps id start
       //   File Size in bytes Horizontal Res Vertical Flag then bayer order eg
       //   0x16 bbgr 0x94 rggb
 	  { 1540857, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "Samsung", "S3" },
 	  { 2658304, 1212, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, "LG", "G3FrontMipi" },
 	  { 2842624, 1296, 1096, 0, 0, 0, 0, 1, 0x16, 0, 0, "LG", "G3FrontQCOM" },
 	  { 2969600, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, "Xiaomi", "MI3wMipi" },
 	  { 3170304, 1976, 1200, 0, 0, 0, 0, 1, 0x16, 0, 0, "Xiaomi", "MI3wQCOM" },
 	  { 3763584, 1584, 1184, 0, 0, 0, 0, 96, 0x61, 0, 0, "I_Mobile", "I_StyleQ6" },
 	  { 5107712, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "OmniVisi", "UltraPixel1" },
 	  { 5382640, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "OmniVisi", "UltraPixel2" },
 	  { 5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "OmniVisi", "4688" },
 	  { 5664912, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "OmniVisi", "4688" },
 	  { 5364240, 2688, 1520, 0, 0, 0, 0, 1, 0x61, 0, 0, "OmniVisi", "4688" },
 	  { 6299648, 2592, 1944, 0, 0, 0, 0, 1, 0x16, 0, 0, "OmniVisi", "OV5648" },
 	  { 6721536, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, "OmniVisi", "OV56482" },
 	  { 6746112, 2592, 1944, 0, 0, 0, 0, 0, 0x16, 0, 0, "HTC", "OneSV" },
 	  { 9631728, 2532, 1902, 0, 0, 0, 0, 96, 0x61, 0, 0, "Sony", "5mp" },
 	  { 9830400, 2560, 1920, 0, 0, 0, 0, 96, 0x61, 0, 0, "NGM", "ForwardArt" },
 	  { 10186752, 3264, 2448, 0, 0, 0, 0, 1, 0x94, 0, 0, "Sony", "IMX219-mipi 8mp" },
 	  { 10223360, 2608, 1944, 0, 0, 0, 0, 96, 0x16, 0, 0, "Sony", "IMX" },
 	  { 10782464, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, "HTC", "MyTouch4GSlide" },
 	  { 10788864, 3282, 2448, 0, 0, 0, 0, 0, 0x16, 0, 0, "Xperia", "L" },
 	  { 15967488, 3264, 2446, 0, 0, 0, 0, 96, 0x16, 0, 0, "OmniVison", "OV8850" },
 	  { 16224256, 4208, 3082, 0, 0, 0, 0, 1, 0x16, 0, 0, "LG", "G3MipiL" },
 	  { 16424960, 4208, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, "IMX135", "MipiL" },
 	  { 17326080, 4164, 3120, 0, 0, 0, 0, 1, 0x16, 0, 0, "LG", "G3LQCom" },
 	  { 17522688, 4212, 3120, 0, 0, 0, 0, 0, 0x16, 0, 0, "Sony", "IMX135-QCOM" },
 	  { 19906560, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, "Gione", "E7mipi" },
 	  { 19976192, 5312, 2988, 0, 0, 0, 0, 1, 0x16, 0, 0, "LG", "G4" },
 	  { 20389888, 4632, 3480, 0, 0, 0, 0, 1, 0x16, 0, 0, "Xiaomi", "RedmiNote3Pro" },
 	  { 20500480, 4656, 3496, 0, 0, 0, 0, 1, 0x94, 0, 0, "Sony", "IMX298-mipi 16mp" },
 	  { 21233664, 4608, 3456, 0, 0, 0, 0, 1, 0x16, 0, 0, "Gione", "E7qcom" },
 	  { 26023936, 4192, 3104, 0, 0, 0, 0, 96, 0x94, 0, 0, "THL", "5000" },
 	  { 26257920, 4208, 3120, 0, 0, 0, 0, 96, 0x94, 0, 0, "Sony", "IMX214" },
 	  { 26357760, 4224, 3120, 0, 0, 0, 0, 96, 0x61, 0, 0, "OV", "13860" },
 	  { 41312256, 5248, 3936, 0, 0, 0, 0, 96, 0x61, 0, 0, "Meizu", "MX4" },
 	  { 42923008, 5344, 4016, 0, 0, 0, 0, 96, 0x61, 0, 0, "Sony", "IMX230" },
       //   Android Raw dumps id end
 	  { 20137344, 3664, 2748, 0, 0, 0, 0, 0x40, 0x49, 0, 0, "Aptina", "MT9J003", 0xffff },
 	  { 2868726, 1384, 1036, 0, 0, 0, 0, 64, 0x49, 0, 8, "Baumer", "TXG14", 1078 },
 	  { 6553440, 2664, 1968, 4, 4, 44, 4, 40, 0x94, 0, 2, "Canon", "PowerShot A460" }, // chdk hack
 	  { 9243240, 3152, 2346, 12, 7, 44, 13, 40, 0x49, 0, 2, "Canon", "PowerShot A470" }, // chdk hack
 	  { 6653280, 2672, 1992, 10, 6, 42, 2, 40, 0x94, 0, 2, "Canon", "PowerShot A530" }, // chdk hack
 	  { 6573120, 2672, 1968, 12, 8, 44, 0, 40, 0x94, 0, 2, "Canon", "PowerShot A610" }, // chdk hack
 	  { 9219600, 3152, 2340, 36, 12, 4, 0, 40, 0x94, 0, 2, "Canon", "PowerShot A620" }, // chdk hack
 	  { 10383120, 3344, 2484, 12, 6, 44, 6, 40, 0x94, 0, 2, "Canon", "PowerShot A630" }, // chdk hack
 	  { 12945240, 3736, 2772, 12, 6, 52, 6, 40, 0x94, 0, 2, "Canon", "PowerShot A640" }, // chdk hack
 	  { 15636240, 4104, 3048, 48, 12, 24, 12, 40, 0x94, 0, 2, "Canon", "PowerShot A650 IS" }, // chdk hack
 	  { 10341600, 3336, 2480, 6, 5, 32, 3, 40, 0x94, 0, 2, "Canon", "PowerShot A720 IS" }, // chdk hack
 	  { 24724224, 4704, 3504, 8, 16, 56, 8, 40, 0x49, 0, 2, "Canon", "PowerShot A3300 IS" }, // chdk hack
 	  { 18763488, 4104, 3048, 10, 22, 82, 22, 8, 0x49, 0, 0, "Canon", "PowerShot D10" }, // ? chdk hack ?
 	  { 19493760, 4160, 3124, 104, 12, 8, 66, 40, 0x49, 0, 2,  "Canon", "PowerShot S100" }, // chdk hack CRW
 	  { 7710960, 2888, 2136, 44, 8, 4, 0, 40, 0x94, 0, 2, "Canon", "PowerShot S3 IS" }, // chdk hack
 	  { 5298000, 2400, 1766, 12, 12, 44, 2, 40, 0x94, 0, 2, "Canon", "PowerShot SD300" }, // chdk hack
 	  { 18653760, 4080, 3048, 24, 12, 24, 12, 40, 0x94, 0, 2, "Canon", "PowerShot SX20 IS" }, // chdk hack
 	  { 21936096, 4464, 3276, 25, 10, 73, 12, 40, 0x16, 0, 2, "Canon", "PowerShot SX30 IS" }, // chdk hack
 	  { 19167840, 4176, 3060, 96, 16, 8, 0,  40, 0x94, 0, 2, "Canon", "PowerShot SX40 HS" }, // chdk hack CR2
 	  { 15467760, 3720, 2772, 6, 12, 30, 0, 40, 0x94, 0, 2, "Canon", "PowerShot SX110 IS" }, // chdk hack
 	  { 15534576, 3728, 2778, 12, 9, 44, 9, 40, 0x94, 0, 2, "Canon", "PowerShot SX120 IS" }, // chdk hack
 	  { 19131120, 4168, 3060, 92, 16, 4, 1, 40, 0x94, 0, 2, "Canon", "PowerShot SX220 HS" }, // chdk hack
 	  { 31663200, 5344, 3950, 96, 18, 0, 0, 40, 0x94, 0, 2, "Canon", "PowerShot SX710 HS" }, // chdk hack
 	  { 30858240, 5248, 3920, 8, 16, 56, 16, 40, 0x94, 0, 2, "Canon", "IXUS 160" }, // chdk hack
 	  { 1976352, 1632, 1211, 0, 2, 0, 1, 0, 0x94, 0, 1, "Casio", "QV-2000UX" },
 	  { 3217760, 2080, 1547, 0, 0, 10, 1, 0, 0x94, 0, 1, "Casio", "QV-3*00EX" },
 	  { 6218368, 2585, 1924, 0, 0, 9, 0, 0, 0x94, 0, 1, "Casio", "QV-5700" },
 	  { 7816704, 2867, 2181, 0, 0, 34, 36, 0, 0x16, 0, 1, "Casio", "EX-Z60" },
 	  { 2937856, 1621, 1208, 0, 0, 1, 0, 0, 0x94, 7, 13, "Casio", "EX-S20" },
 	  { 4948608, 2090, 1578, 0, 0, 32, 34, 0, 0x94, 7, 1, "Casio", "EX-S100" },
 	  { 6054400, 2346, 1720, 2, 0, 32, 0, 0, 0x94, 7, 1, "Casio", "QV-R41" },
 	  { 7426656, 2568, 1928, 0, 0, 0, 0, 0, 0x94, 0, 1, "Casio", "EX-P505" },
 	  { 7530816, 2602, 1929, 0, 0, 22, 0, 0, 0x94, 7, 1, "Casio", "QV-R51" },
 	  { 7542528, 2602, 1932, 0, 0, 32, 0, 0, 0x94, 7, 1, "Casio", "EX-Z50" },
 	  { 7562048, 2602, 1937, 0, 0, 25, 0, 0, 0x16, 7, 1, "Casio", "EX-Z500" },
 	  { 7753344, 2602, 1986, 0, 0, 32, 26, 0, 0x94, 7, 1, "Casio", "EX-Z55" },
 	  { 9313536, 2858, 2172, 0, 0, 14, 30, 0, 0x94, 7, 1, "Casio", "EX-P600" },
 	  { 10834368, 3114, 2319, 0, 0, 27, 0, 0, 0x94, 0, 1, "Casio", "EX-Z750" },
 	  { 10843712, 3114, 2321, 0, 0, 25, 0, 0, 0x94, 0, 1, "Casio", "EX-Z75" },
 	  { 10979200, 3114, 2350, 0, 0, 32, 32, 0, 0x94, 7, 1, "Casio", "EX-P700" },
 	  { 12310144, 3285, 2498, 0, 0, 6, 30, 0, 0x94, 0, 1, "Casio", "EX-Z850" },
 	  { 12489984, 3328, 2502, 0, 0, 47, 35, 0, 0x94, 0, 1, "Casio", "EX-Z8" },
 	  { 15499264, 3754, 2752, 0, 0, 82, 0, 0, 0x94, 0, 1, "Casio", "EX-Z1050" },
 	  { 18702336, 4096, 3044, 0, 0, 24, 0, 80, 0x94, 7, 1, "Casio", "EX-ZR100" },
 	  { 7684000, 2260, 1700, 0, 0, 0, 0, 13, 0x94, 0, 1, "Casio", "QV-4000" },
 	  { 787456, 1024, 769, 0, 1, 0, 0, 0, 0x49, 0, 0, "Creative", "PC-CAM 600" },
 	  { 28829184, 4384, 3288, 0, 0, 0, 0, 36, 0x61, 0, 0, "DJI" },
 	  { 15151104, 4608, 3288, 0, 0, 0, 0, 0, 0x94, 0, 0, "Matrix" },
 	  { 3840000, 1600, 1200, 0, 0, 0, 0, 65, 0x49, 0, 0, "Foculus", "531C" },
 	  { 307200, 640, 480, 0, 0, 0, 0, 0, 0x94, 0, 0, "Generic" },
 	  { 62464, 256, 244, 1, 1, 6, 1, 0, 0x8d, 0, 0, "Kodak", "DC20" },
 	  { 124928, 512, 244, 1, 1, 10, 1, 0, 0x8d, 0, 0, "Kodak", "DC20" },
 	  { 1652736, 1536, 1076, 0, 52, 0, 0, 0, 0x61, 0, 0, "Kodak", "DCS200" },
 	  { 4159302, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, "Kodak", "C330" },
 	  { 4162462, 2338, 1779, 1, 33, 1, 2, 0, 0x94, 0, 0, "Kodak", "C330", 3160 },
 	  { 2247168, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, "Kodak", "C330" },
 	  { 3370752, 1232, 912, 0, 0, 16, 0, 0, 0x00, 0, 0, "Kodak", "C330" },
 	  { 6163328, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, "Kodak", "C603" },
 	  { 6166488, 2864, 2152, 0, 0, 0, 0, 0, 0x94, 0, 0, "Kodak", "C603", 3160 },
 	  { 460800, 640, 480, 0, 0, 0, 0, 0, 0x00, 0, 0, "Kodak", "C603" },
 	  { 9116448, 2848, 2134, 0, 0, 0, 0, 0, 0x00, 0, 0, "Kodak", "C603" },
 	  { 12241200, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, "Kodak", "12MP" },
 	  { 12272756, 4040, 3030, 2, 0, 0, 13, 0, 0x49, 0, 0, "Kodak", "12MP", 31556 },
 	  { 18000000, 4000, 3000, 0, 0, 0, 0, 0, 0x00, 0, 0, "Kodak", "12MP" },
 	  { 614400, 640, 480, 0, 3, 0, 0, 64, 0x94, 0, 0, "Kodak", "KAI-0340" },
 	  { 15360000, 3200, 2400, 0, 0, 0, 0, 96, 0x16, 0, 0, "Lenovo", "A820" },
 	  { 3884928, 1608, 1207, 0, 0, 0, 0, 96, 0x16, 0, 0, "Micron", "2010", 3212 },
 	  { 1138688, 1534, 986, 0, 0, 0, 0, 0, 0x61, 0, 0, "Minolta", "RD175", 513 },
 	  { 1581060, 1305, 969, 0, 0, 18, 6, 6, 0x1e, 4, 1, "Nikon", "E900" }, // "diag raw" hack
 	  { 2465792, 1638, 1204, 0, 0, 22, 1, 6, 0x4b, 5, 1, "Nikon", "E950" }, // "diag raw" hack; possibly also Nikon E700, E800, E775;
 	                                                                        // Olympus C-2020Z
 	  { 2940928, 1616, 1213, 0, 0, 0, 7, 30, 0x94, 0, 1, "Nikon", "E2100" }, // "diag raw" hack; also Nikon E2500
 	  { 4771840, 2064, 1541, 0, 0, 0, 1, 6, 0xe1, 0, 1, "Nikon", "E990" }, // "diag raw" hack; possibly also Nikon E880, E885, E995;
 	                                                                       // Olympus C-3030Z
 	  { 4775936, 2064, 1542, 0, 0, 0, 0, 30, 0x94, 0, 1, "Nikon", "E3700" }, // "diag raw" hack; Nikon E3100, E3200, E3500;
 	                                                                         // Pentax "Optio 33WR"; possibly also Olympus C-740UZ
 	  { 5865472, 2288, 1709, 0, 0, 0, 1, 6, 0xb4, 0, 1, "Nikon", "E4500" }, // "diag raw" hack; possibly also Olympus C-4040Z
 	  { 5869568, 2288, 1710, 0, 0, 0, 0, 6, 0x16, 0, 1, "Nikon", "E4300" }, // "diag raw" hack; also Minolta "DiMAGE Z2"
 	  { 7438336, 2576, 1925, 0, 0, 0, 1, 6, 0xb4, 0, 1, "Nikon", "E5000" }, // also Nikon E5700
 	  { 8998912, 2832, 2118, 0, 0, 0, 0, 30, 0x94, 7, 1, "Nikon", "COOLPIX S6" }, // "diag raw" hack
 	  { 5939200, 2304, 1718, 0, 0, 0, 0, 30, 0x16, 0, 0, "Olympus", "C-770UZ" }, // possibly also Olympus C-4100Z, C-765UZ
 	  { 3178560, 2064, 1540, 0, 0, 0, 0, 0, 0x94, 0, 1, "Pentax", "Optio S V1.01" },
 	  { 4841984, 2090, 1544, 0, 0, 22, 0, 0, 0x94, 7, 1, "Pentax", "Optio S" },
 	  { 6114240, 2346, 1737, 0, 0, 22, 0, 0, 0x94, 7, 1, "Pentax", "Optio S4" },
 	  { 10702848, 3072, 2322, 0, 0, 0, 21, 30, 0x94, 0, 1, "Pentax", "Optio 750Z" },
 	  { 4147200, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, "Photron", "BC2-HD" },
 	  { 4151666, 1920, 1080, 0, 0, 0, 0, 0, 0x49, 0, 0, "Photron", "BC2-HD", 8 },
 	  { 13248000, 2208, 3000, 0, 0, 0, 0, 13, 0x61, 0, 0, "Pixelink", "A782" },
 	  { 6291456, 2048, 1536, 0, 0, 0, 0, 96, 0x61, 0, 0, "RoverShot", "3320AF" },
 	  { 311696, 644, 484, 0, 0, 0, 0, 0, 0x16, 0, 8, "ST Micro", "STV680 VGA" },
 	  { 16098048, 3288, 2448, 0, 0, 24, 0, 9, 0x94, 0, 1, "Samsung", "S85" }, // hack
 	  { 16215552, 3312, 2448, 0, 0, 48, 0, 9, 0x94, 0, 1, "Samsung", "S85" }, // hack
 	  { 20487168, 3648, 2808, 0, 0, 0, 0, 13, 0x94, 5, 1, "Samsung", "WB550" },
 	  { 24000000, 4000, 3000, 0, 0, 0, 0, 13, 0x94, 5, 1, "Samsung", "WB550" },
 	  { 12582980, 3072, 2048, 0, 0, 0, 0, 33, 0x61, 0, 0, "Sinar", "", 68 }, // Sinarback 23; same res. as Leaf Volare & Cantare
 	  { 33292868, 4080, 4080, 0, 0, 0, 0, 33, 0x61, 0, 0, "Sinar", "", 68 }, // Sinarback 44
 	  { 44390468, 4080, 5440, 0, 0, 0, 0, 33, 0x61, 0, 0, "Sinar", "", 68 }, // Sinarback 54
 	  { 1409024, 1376, 1024, 0, 0, 1, 0, 0, 0x49, 0, 0, "Sony", "XCD-SX910CR" },
 	  { 2818048, 1376, 1024, 0, 0, 1, 0, 97, 0x49, 0, 0, "Sony", "XCD-SX910CR" },
   };
 
   libraw_custom_camera_t
       table[64 + sizeof(const_table) / sizeof(const_table[0])];
 
 
   // clang-format on
 
   char head[64] = {0}, *cp;
   int hlen, fsize, flen, zero_fsize = 1, i, c;
+  INT64 fsize64;
   struct jhead jh;
 
   unsigned camera_count =
       parse_custom_cameras(64, table, imgdata.rawparams.custom_camera_strings);
   for (int q = 0; q < int(sizeof(const_table) / sizeof(const_table[0])); q++)
     memmove(&table[q + camera_count], &const_table[q], sizeof(const_table[0]));
   camera_count += sizeof(const_table) / sizeof(const_table[0]);
 
   tiff_flip = flip = filters = UINT_MAX; /* unknown */
   raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;
   maximum = height = width = top_margin = left_margin = 0;
   cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;
   iso_speed = shutter = aperture = focal_len = 0;
   unique_id = 0ULL;
   tiff_nifds = 0;
   is_NikonTransfer = 0;
   is_Olympus = 0;
   OlympusDNG_SubDirOffsetValid = 0;
   is_Sony = 0;
   is_pana_raw = 0;
   maker_index = LIBRAW_CAMERAMAKER_Unknown;
   FujiCropMode = 0;
   is_PentaxRicohMakernotes = 0;
   normalized_model[0] = 0;
   normalized_make[0] = 0;
   CM_found = 0;
   memset(tiff_ifd, 0, sizeof tiff_ifd);
   libraw_internal_data.unpacker_data.crx_track_selected = -1;
   libraw_internal_data.unpacker_data.CR3_CTMDtag = 0;
   imHassy.nIFD_CM[0] = imHassy.nIFD_CM[1] = -1;
   imKodak.ISOCalibrationGain = 1.0f;
   imCommon.CameraTemperature = imCommon.SensorTemperature =
       imCommon.SensorTemperature2 = imCommon.LensTemperature =
           imCommon.AmbientTemperature = imCommon.BatteryTemperature =
               imCommon.exifAmbientTemperature = -1000.0f;
 
   imgdata.color.ExifColorSpace = LIBRAW_COLORSPACE_Unknown;
   for (i = 0; i < LIBRAW_IFD_MAXCOUNT; i++)
   {
     tiff_ifd[i].dng_color[0].illuminant = tiff_ifd[i].dng_color[1].illuminant =
         0xffff;
     for (int c = 0; c < 4; c++)
       tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;
   }
 
   memset(gpsdata, 0, sizeof gpsdata);
   memset(cblack, 0, sizeof cblack);
   memset(white, 0, sizeof white);
   memset(mask, 0, sizeof mask);
   thumb_offset = thumb_length = thumb_width = thumb_height = 0;
   load_raw = thumb_load_raw = 0;
   write_thumb = &LibRaw::jpeg_thumb;
   data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0;
   kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
   timestamp = shot_order = tiff_samples = black = is_foveon = 0;
   mix_green = profile_length = data_error = zero_is_bad = 0;
   pixel_aspect = is_raw = raw_color = 1;
   tile_width = tile_length = 0;
   metadata_blocks = 0;
 
   for (i = 0; i < 4; i++)
   {
     cam_mul[i] = i == 1;
     pre_mul[i] = i < 3;
     FORC3 cmatrix[c][i] = 0;
     FORC3 rgb_cam[c][i] = c == i;
   }
   colors = 3;
   for (i = 0; i < 0x10000; i++)
     curve[i] = i;
 
   order = get2();
   hlen = get4();
   fseek(ifp, 0, SEEK_SET);
 
   if (fread(head, 1, 64, ifp) < 64)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
   libraw_internal_data.unpacker_data.lenRAFData =
       libraw_internal_data.unpacker_data.posRAFData = 0;
 
   fseek(ifp, 0, SEEK_END);
+  fsize64 = ftell(ifp);
+  if(fsize64 > LIBRAW_MAX_NONDNG_RAW_FILE_SIZE && fsize64 > LIBRAW_MAX_DNG_RAW_FILE_SIZE)
+      throw LIBRAW_EXCEPTION_TOOBIG;
+
   flen = fsize = ftell(ifp);
   if ((cp = (char *)memmem(head, 32, (char *)"MMMM", 4)) ||
       (cp = (char *)memmem(head, 32, (char *)"IIII", 4)))
   {
     parse_phase_one(cp - head);
     if (cp - head && parse_tiff(0))
       apply_tiff();
   }
   else if (order == 0x4949 || order == 0x4d4d)
   {
     if (!memcmp(head + 6, "HEAPCCDR", 8))
     {
       data_offset = hlen;
       parse_ciff(hlen, flen - hlen, 0);
       load_raw = &LibRaw::canon_load_raw;
     }
     else if (parse_tiff(0))
       apply_tiff();
   }
   else if (!memcmp(head, "\xff\xd8\xff\xe1", 4) && !memcmp(head + 6, "Exif", 4))
   {
     fseek(ifp, 4, SEEK_SET);
     data_offset = 4 + get2();
     fseek(ifp, data_offset, SEEK_SET);
     if (fgetc(ifp) != 0xff)
       parse_tiff(12);
     thumb_offset = 0;
   }
   else if (!memcmp(head + 25, "ARECOYK", 7)) // 'KYOCERA' right-to-left
   {
     strcpy(make, "Contax");
     strcpy(model, "N Digital");
     parse_kyocera();
   }
   else if (!strcmp(head, "PXN"))
   {
     strcpy(make, "Logitech");
     strcpy(model, "Fotoman Pixtura");
   }
   else if (!strcmp(head, "qktk"))
   {
     strcpy(make, "Apple");
     strcpy(model, "QuickTake 100");
     load_raw = &LibRaw::quicktake_100_load_raw;
   }
   else if (!strcmp(head, "qktn"))
   {
     strcpy(make, "Apple");
     strcpy(model, "QuickTake 150");
     load_raw = &LibRaw::kodak_radc_load_raw;
   }
   else if (!memcmp(head, "FUJIFILM", 8))
   {
     memcpy(imFuji.SerialSignature, head + 0x10, 0x0c);
     imFuji.SerialSignature[0x0c] = 0;
     memcpy(imFuji.SensorID, imFuji.SerialSignature + 0x06, 0x04);
     imFuji.SensorID[0x04] = 0;
     strncpy(model, head + 0x1c, 0x20);
     model[0x20] = 0;
     c = 11;
     while (isdigit(imFuji.SerialSignature[c]) && (c>0))
       c--;
     unique_id = (unsigned long long)atoi(imFuji.SerialSignature+c+1);
     memcpy(imFuji.RAFVersion, head + 0x3c, 4);
     imFuji.RAFVersion[4] = 0;
     fseek(ifp, 84, SEEK_SET);
     thumb_offset = get4();
     thumb_length = get4();
     fseek(ifp, 92, SEEK_SET);
     parse_fuji(get4());
     if (thumb_offset > 120)
     {
       fseek(ifp, 120, SEEK_SET);
       is_raw += (i = get4()) ? 1 : 0;
       if (is_raw == 2 && shot_select)
         parse_fuji(i);
     }
     load_raw = &LibRaw::unpacked_load_raw;
     fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);
     parse_tiff(data_offset = get4());
     parse_tiff(thumb_offset + 12);
+    parse_fuji_thumbnail(thumb_offset);
     apply_tiff();
   }
   else if (!memcmp(head, "RIFF", 4))
   {
     fseek(ifp, 0, SEEK_SET);
     parse_riff();
   }
   else if (!memcmp(head + 4, "ftypqt   ", 9))
   {
     fseek(ifp, 0, SEEK_SET);
     parse_qt(fsize);
     is_raw = 0;
   }
   else if (!memcmp(head, "\0\001\0\001\0@", 6))
   {
     fseek(ifp, 6, SEEK_SET);
     fread(make, 1, 8, ifp);
     fread(model, 1, 8, ifp);
     fread(model2, 1, 16, ifp);
     data_offset = get2();
     get2();
     raw_width = get2();
     raw_height = get2();
     load_raw = &LibRaw::nokia_load_raw;
     filters = 0x61616161;
   }
   else if (!memcmp(head, "NOKIARAW", 8))
   {
     strcpy(make, "NOKIA");
     order = 0x4949;
     fseek(ifp, 300, SEEK_SET);
     data_offset = get4();
     i = get4(); // bytes count
     width = get2();
     height = get2();
 
     // Data integrity check
     if (width < 1 || width > 16000 || height < 1 || height > 16000 ||
         i < (width * height) || i > (2 * width * height))
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
     switch (tiff_bps = i * 8 / (width * height))
     {
     case 8:
       load_raw = &LibRaw::eight_bit_load_raw;
       break;
     case 10:
       load_raw = &LibRaw::nokia_load_raw;
       break;
     case 0:
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
       break;
     }
     raw_height = height + (top_margin = i / (width * tiff_bps / 8) - height);
     mask[0][3] = 1;
     filters = 0x61616161;
   }
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
   else if (!memcmp(head, "ARRI", 4))
   {
     order = 0x4949;
     fseek(ifp, 20, SEEK_SET);
     width = get4();
     height = get4();
     strcpy(make, "ARRI");
     fseek(ifp, 668, SEEK_SET);
     fread(model, 1, 64, ifp);
     model[63] = 0;
     fseek(ifp, 760, SEEK_SET);
     fread(software, 1, 64, ifp);
     if((unsigned char)software[0] == 0xff) software[0] = 0;
     software[63] = 0;
     data_offset = 4096;
     load_raw = &LibRaw::packed_load_raw;
     load_flags = 88;
     filters = 0x61616161;
     fixupArri();
   }
   else if (!memcmp(head, "XPDS", 4))
   {
     order = 0x4949;
     fseek(ifp, 0x800, SEEK_SET);
     fread(make, 1, 41, ifp);
     raw_height = get2();
     raw_width = get2();
     fseek(ifp, 56, SEEK_CUR);
     fread(model, 1, 30, ifp);
     data_offset = 0x10000;
     load_raw = &LibRaw::canon_rmf_load_raw;
     gamma_curve(0, 12.25, 1, 1023);
   }
   else if (!memcmp(head + 4, "RED1", 4))
   {
     strcpy(make, "Red");
     strcpy(model, "One");
     parse_redcine();
     load_raw = &LibRaw::redcine_load_raw;
     gamma_curve(1 / 2.4, 12.92, 1, 4095);
     filters = 0x49494949;
   }
 #endif
   else if (!memcmp(head, "DSC-Image", 9))
     parse_rollei();
   else if (!memcmp(head, "PWAD", 4))
     parse_sinar_ia();
   else if (!memcmp(head, "\0MRM", 4))
     parse_minolta(0);
   else if (!memcmp(head, "FOVb", 4))
   {
     parse_x3f(); /* Does nothing if USE_X3FTOOLS is not defined */
   }
   else if (!memcmp(head, "CI", 2))
     parse_cine();
 #ifdef USE_6BY9RPI
   else if (!memcmp(head, "BRCM", 4)) {
 	fseek(ifp, 0, SEEK_SET);
 	strcpy(make, "RaspberryPi");
 	strcpy(model, "Pi");
 	parse_raspberrypi();
 	}
 #endif
   else if (!memcmp(head + 4, "ftypcrx ", 8))
   {
     int err;
     unsigned long long szAtomList;
     short nesting = -1;
     short nTrack = -1;
     short TrackType;
     char AtomNameStack[128];
     strcpy(make, "Canon");
 
     szAtomList = ifp->size();
     err = parseCR3(0ULL, szAtomList, nesting, AtomNameStack, nTrack, TrackType);
     if ((err == 0 || err == -14) &&
         nTrack >= 0) // no error, or too deep nesting
       selectCRXTrack(nTrack);
   }
 
+  if (dng_version)
+  {
+      if (fsize64 > LIBRAW_MAX_DNG_RAW_FILE_SIZE)
+          throw LIBRAW_EXCEPTION_TOOBIG;
+  }
+  else
+  {
+    if (fsize64 > LIBRAW_MAX_NONDNG_RAW_FILE_SIZE)
+      throw LIBRAW_EXCEPTION_TOOBIG;
+  }
+
   if (make[0] == 0)
     for (zero_fsize = i = 0; i < (int)camera_count; i++)
       if (fsize == (int)table[i].fsize)
       {
         strcpy(make, table[i].t_make);
         strcpy(model, table[i].t_model);
         flip = table[i].flags >> 2;
         zero_is_bad = table[i].flags & 2;
         data_offset = table[i].offset == 0xffff ? 0 : table[i].offset;
         raw_width = table[i].rw;
         raw_height = table[i].rh;
         left_margin = table[i].lm;
         top_margin = table[i].tm;
         width = raw_width - left_margin - table[i].rm;
         height = raw_height - top_margin - table[i].bm;
         filters = 0x1010101U * table[i].cf;
         colors = 4 - !((filters & filters >> 1) & 0x5555);
         load_flags = table[i].lf & 0xff;
         if (table[i].lf & 0x100) /* Monochrome sensor dump */
         {
           colors = 1;
           filters = 0;
         }
         switch (tiff_bps = (fsize - data_offset) * 8 / (raw_width * raw_height))
         {
         case 6:
           load_raw = &LibRaw::minolta_rd175_load_raw;
           ilm.CameraMount = LIBRAW_MOUNT_Minolta_A;
           break;
         case 8:
           load_raw = &LibRaw::eight_bit_load_raw;
           break;
         case 10:
           if ((fsize - data_offset) / raw_height * 3 >= raw_width * 4)
           {
             load_raw = &LibRaw::android_loose_load_raw;
             break;
           }
           else if (load_flags & 1)
           {
             load_raw = &LibRaw::android_tight_load_raw;
             break;
           }
         case 12:
           load_flags |= 128;
           load_raw = &LibRaw::packed_load_raw;
           break;
         case 16:
           order = 0x4949 | 0x404 * (load_flags & 1);
           tiff_bps -= load_flags >> 4;
           tiff_bps -= load_flags = load_flags >> 1 & 7;
           load_raw = table[i].offset == 0xffff
                          ? &LibRaw::unpacked_load_raw_reversed
                          : &LibRaw::unpacked_load_raw;
         }
         maximum = (1 << tiff_bps) - (1 << table[i].max);
         break;
       }
   if (zero_fsize)
     fsize = 0;
-  if (make[0] == 0)
+  if (make[0] == 0 && fsize64 < 25000000LL)
     parse_smal(0, flen);
   if (make[0] == 0)
   {
     parse_jpeg(0);
 #ifdef USE_6BY9RPI
-	if (!(strncmp(model, "ov", 2) && strncmp(model, "RP_", 3))) {
+	if (!(strncmp(model, "ov", 2) && strncmp(model, "RP_", 3) && strncmp(model, "imx477", 6))) {
 		//Assume that this isn't a raw unless the header can be found
 		is_raw = 0;
 
-		if (!strncasecmp(model, "RP_testc",8) ||
-		    !strncasecmp(model, "RP_imx477",9)) {
+		if (!strncasecmp(model, "RP_testc",8) 
+            || !strncasecmp(model, "imx477", 6) //  from PyDNG
+		    || !strncasecmp(model, "RP_imx477",9)) {
 			const long offsets[] = {
 				//IMX477 offsets
 				3375104,  //2028x1080 12bit
 				4751360,  //2028x1520 12bit
 				18711040, //4056x3040 12bit
 				1015808,  //1012x760 10bit
 				-1        //Marker for end of table
 			};
 			int offset_idx;
 			for (offset_idx=0; offsets[offset_idx]!=-1; offset_idx++) {
 				if(!fseek (ifp, -offsets[offset_idx], SEEK_END) &&
 				   fread (head, 1, 32, ifp) && !strncmp(head,"BRCM", 4)) {
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy (make, "SonyRPF");
+					strcpy (make, "RaspberryPi");
+                    strcpy(model, "RP_imx477"); // Force single model
 					black = (offset_idx == 3) ? 64 : 256;
 					parse_raspberrypi();
 					break;
 				}
 			}
 		}
 		else if (!strncasecmp(model, "RP_imx", 6)) {
 			const long offsets[] = {
 				//IMX219 offsets
 				10270208, //8MPix 3280x2464
 				2678784,  //1920x1080
 				2628608,  //1640x1232
 				1963008,  //1640x922
 				1233920,  //1280x720
 				445440,   //640x480
 				-1        //Marker for end of table
 			};
 			int offset_idx;
 			for (offset_idx = 0; offsets[offset_idx] != -1; offset_idx++) {
 				if (!fseek(ifp, -offsets[offset_idx], SEEK_END) &&
 					fread(head, 1, 32, ifp) && !strncmp(head, "BRCM", 4)) {
 
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy(make, "SonyRPF");
+					strcpy(make, "RaspberryPi");
+                    black = 66;
 					parse_raspberrypi();
 					break;
 				}
 			}
 		}
 		else if (!strncasecmp(model, "RP_OV", 5) || !strncasecmp(model, "ov5647", 6)) {
 			const long offsets[] = {
 					6404096,  //5MPix 2592x1944
 					2717696,  //1920x1080
 					1625600,  //1296x972
 					1233920,  //1296x730
 					445440,   //640x480
 					-1        //Marker for end of table
 			};
 			int offset_idx;
 			for (offset_idx = 0; offsets[offset_idx] != -1; offset_idx++) {
 				if (!fseek(ifp, -offsets[offset_idx], SEEK_END) &&
 					fread(head, 1, 32, ifp) && !strncmp(head, "BRCM", 4)) {
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy(make, "OmniVision");
-					width = raw_width;
+					strcpy(make, "RaspberryPi");
+                    strcpy(model, "ov5647"); // Force single model
+                    width = raw_width;
 					//Defaults
 					raw_width = 2611;
 					filters = 0x16161616;
+                    black = 16;
 					parse_raspberrypi();
 					break;
 				}
 			}
 	  }
 	}// else is_raw = 0;
 #else
     fseek(ifp, 0, SEEK_END);
     int sz = ftell(ifp);
     if (!strncmp(model, "RP_imx219", 9) && sz >= 0x9cb600 &&
         !fseek(ifp, -0x9cb600, SEEK_END) && fread(head, 1, 0x20, ifp) &&
         !strncmp(head, "BRCM", 4))
     {
       strcpy(make, "Broadcom");
       strcpy(model, "RPi IMX219");
       if (raw_height > raw_width)
         flip = 5;
       data_offset = ftell(ifp) + 0x8000 - 0x20;
       parse_broadcom();
       black = 66;
       maximum = 0x3ff;
       load_raw = &LibRaw::broadcom_load_raw;
       thumb_offset = 0;
       thumb_length = sz - 0x9cb600 - 1;
     }
     else if (!(strncmp(model, "ov5647", 6) && strncmp(model, "RP_OV5647", 9)) &&
              sz >= 0x61b800 && !fseek(ifp, -0x61b800, SEEK_END) &&
              fread(head, 1, 0x20, ifp) && !strncmp(head, "BRCM", 4))
     {
       strcpy(make, "Broadcom");
       if (!strncmp(model, "ov5647", 6))
         strcpy(model, "RPi OV5647 v.1");
       else
         strcpy(model, "RPi OV5647 v.2");
       if (raw_height > raw_width)
         flip = 5;
       data_offset = ftell(ifp) + 0x8000 - 0x20;
       parse_broadcom();
       black = 16;
       maximum = 0x3ff;
       load_raw = &LibRaw::broadcom_load_raw;
       thumb_offset = 0;
       thumb_length = sz - 0x61b800 - 1;
     }
     else
       is_raw = 0;
 #endif
   }
 
   // make sure strings are terminated
   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;
 
   for (i = 0; i < int(sizeof CorpTable / sizeof *CorpTable); i++)
   {
     if (strcasestr(make, CorpTable[i].CorpName))
     { /* Simplify company names */
       maker_index = CorpTable[i].CorpId;
       break;
     }
   }
 
   if (makeIs(LIBRAW_CAMERAMAKER_HMD_Global) && !strncasecmp(model, "Nokia", 5)) {
     maker_index = LIBRAW_CAMERAMAKER_Nokia;
   }  else if (makeIs(LIBRAW_CAMERAMAKER_JK_Imaging) && !strncasecmp(model, "Kodak", 5)) {
     maker_index = LIBRAW_CAMERAMAKER_Kodak;
   } else if (makeIs(LIBRAW_CAMERAMAKER_Ricoh) && !strncasecmp(model, "PENTAX", 6)) {
     maker_index = LIBRAW_CAMERAMAKER_Pentax;
   }
 
   for (i = 0; i < int(sizeof CorpTable / sizeof *CorpTable); i++) {
-    if (maker_index == CorpTable[i].CorpId) {
+    if (maker_index == (unsigned)CorpTable[i].CorpId) {
       strcpy(make, CorpTable[i].CorpName);
       break;
     }
   }
 
   if ((makeIs(LIBRAW_CAMERAMAKER_Kodak) || makeIs(LIBRAW_CAMERAMAKER_Leica)) &&
       ((cp = strcasestr(model, " DIGITAL CAMERA")) ||
        (cp = strstr(model, "FILE VERSION")))) {
     *cp = 0;
   }
 
   remove_trailing_spaces(make, sizeof(make));
   remove_trailing_spaces(model, sizeof(model));
 
   i = strbuflen(make); /* Remove make from model */
   if (!strncasecmp(model, make, i) && model[i++] == ' ')
     memmove(model, model + i, 64 - i);
 
   if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm) && !strncmp(model, "FinePix", 7)) {
     memmove(model, model + 7, strlen(model) - 6);
     if (model[0] == ' ') {
       memmove(model, model + 1, strlen(model));
     }
   } else if ((makeIs(LIBRAW_CAMERAMAKER_Kodak) || makeIs(LIBRAW_CAMERAMAKER_Konica)) &&
              !strncmp(model, "Digital Camera ", 15)) {
     memmove(model, model + 15, strlen(model) - 14);
   }
 
   desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;
   if (!is_raw)
     goto notraw;
 
   if (!height)
     height = raw_height;
   if (!width)
     width = raw_width;
 
   identify_finetune_pentax();
 
 
   if (dng_version)
   {
     if (filters == UINT_MAX)
       filters = 0;
     if (!filters)
       colors = tiff_samples;
     switch (tiff_compress)
     {
     case 0: // Compression not set, assuming uncompressed
     case 1:
       // Uncompressed float: decoder set in apply_tiff for valid files; not set for non-valid with sampleformat==3
       if ((load_raw != &LibRaw::uncompressed_fp_dng_load_raw)  && (tiff_sampleformat != 3))
         load_raw = &LibRaw::packed_dng_load_raw;
       break;
     case 7:
       load_raw = &LibRaw::lossless_dng_load_raw;
       break;
     case 8:
         if (tiff_sampleformat == 3 && tiff_bps > 8 && (tiff_bps % 8 == 0) && tiff_bps <= 32)
             load_raw = &LibRaw::deflate_dng_load_raw;
       break;
 #ifdef USE_GPRSDK
     case 9:
         load_raw = &LibRaw::vc5_dng_load_raw_placeholder;
         break;
 #endif
     case 34892:
       load_raw = &LibRaw::lossy_dng_load_raw;
       break;
     default:
       load_raw = 0;
     }
     GetNormalizedModel();
     if (makeIs(LIBRAW_CAMERAMAKER_Leica)) {
-		  if (!strcmp(model, "SL2")) {
-        height -= 3;
-      }
+		  if (!strcmp(model, "SL2")) 
+              height -= 3;
+          if (!strncasecmp(model, "Q2 MONO",7))
+              height -= 18;
     }
+
     else if (makeIs(LIBRAW_CAMERAMAKER_Olympus) &&
         (OlyID == OlyID_STYLUS_1) && // don't use normalized_model below, it is 'Stylus 1'
         (strchr(model+6, 's') ||
          strchr(model+6, 'S')))
     {
       width -= 16;
     }
     goto dng_skip;
   }
 
   if (makeIs(LIBRAW_CAMERAMAKER_Canon) && !fsize && tiff_bps != 15)
   {
       bool fromtable = false;
     if (!load_raw)
       load_raw = &LibRaw::lossless_jpeg_load_raw;
     for (i = 0; i < int(sizeof canon / sizeof *canon); i++)
       if (raw_width == canon[i][0] && raw_height == canon[i][1])
       {
         width = raw_width - (left_margin = canon[i][2]);
         height = raw_height - (top_margin = canon[i][3]);
         width -= canon[i][4];
         height -= canon[i][5];
         mask[0][1] = canon[i][6];
         mask[0][3] = -canon[i][7];
         mask[1][1] = canon[i][8];
         mask[1][3] = -canon[i][9];
         if (canon[i][10])
           filters = canon[i][10] * 0x01010101U;
         fromtable = true;
       }
     if ((unique_id | 0x20000ULL) ==
         0x2720000ULL) // "PowerShot G11", "PowerShot S90": 0x2700000, 0x2720000
                       // possibly "PowerShot SX120 IS" (if not chdk hack?): 0x2710000
     {
       left_margin = 8;
       top_margin = 16;
     }
     if(!fromtable && imCanon.AverageBlackLevel) // not known, but metadata known
     {
         FORC4 cblack[c] = imCanon.ChannelBlackLevel[c];
         black = cblack[4] = cblack[5] = 0;
         // Prevent automatic BL calculation
         mask[0][3] = 1;
         mask[0][1] = 2;
 
-        if(imCanon.SensorWidth == raw_width
-            && imCanon.SensorHeight == raw_height)
+        if ((imCanon.SensorWidth == raw_width) &&
+            (imCanon.SensorHeight == raw_height))
         {
-            left_margin = (imCanon.SensorLeftBorder+1) & 0xfffe; // round to 2
-            width = imCanon.SensorRightBorder - left_margin;
-            top_margin = (imCanon.SensorTopBorder +1)  & 0xfffe;
-            height = imCanon.SensorBottomBorder - top_margin;
+            left_margin = (imCanon.DefaultCropAbsolute.l+1) & 0xfffe; // round to 2
+            width = imCanon.DefaultCropAbsolute.r - left_margin;
+            top_margin = (imCanon.DefaultCropAbsolute.t +1)  & 0xfffe;
+            height = imCanon.DefaultCropAbsolute.b - top_margin;
         }
     }
   }
 
   identify_finetune_by_filesize(fsize);
 
   if (!strcmp(model, "KAI-0340") && find_green(16, 16, 3840, 5120) < 25)
   {
     height = 480;
     top_margin = filters = 0;
     strcpy(model, "C603");
   }
 
   GetNormalizedModel();
 
   identify_finetune_dcr(head, fsize, flen);
 
   /* Early reject for damaged images */
   if (!load_raw || height < 22 || width < 22 ||
       (tiff_bps > 16 &&
        (load_raw != &LibRaw::deflate_dng_load_raw &&
         load_raw != &LibRaw::uncompressed_fp_dng_load_raw)) ||
       tiff_samples > 4 || colors > 4 ||
       colors < 1
       /* alloc in unpack() may be fooled by size adjust */
       || ((int)width + (int)left_margin > 65535) ||
       ((int)height + (int)top_margin > 65535))
   {
     is_raw = 0;
     RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY, 1, 2);
     return;
   }
   if (!model[0])
   {
     sprintf(model, "%dx%d", width, height);
     strcpy(normalized_model, model);
   }
 
   if (!(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS) &&
       (filters == UINT_MAX)) // Default dcraw behaviour
     filters = 0x94949494;
   else if (filters == UINT_MAX)
   {
     if (tiff_nifds > 0 && tiff_samples == 1)
     {
       colors = 1;
       filters = 0;
     }
     else
       filters = 0x94949494;
   }
 
   if (thumb_offset && !thumb_height)
   {
     fseek(ifp, thumb_offset, SEEK_SET);
     if (ljpeg_start(&jh, 1))
     {
       thumb_width = jh.wide;
       thumb_height = jh.high;
     }
   }
@@ -1272,357 +1298,378 @@ notraw:
 void LibRaw::identify_process_dng_fields()
 {
 	if (!dng_version) return;
+
+	// Cleanup inset_crops if set by makernotes parser
+	imgdata.sizes.raw_inset_crops[0].cleft = imgdata.sizes.raw_inset_crops[0].ctop =
+        imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[1].ctop = 0xffff;
+    imgdata.sizes.raw_inset_crops[0].cwidth = imgdata.sizes.raw_inset_crops[0].cheight =
+        imgdata.sizes.raw_inset_crops[1].cwidth = imgdata.sizes.raw_inset_crops[1].cheight = 0;
+
+
 	int c;
 	{
 		/* copy DNG data from per-IFD field to color.dng */
 		int iifd = find_ifd_by_offset(data_offset);
 		int pifd = find_ifd_by_offset(thumb_offset);
 
-#define CFAROUND(value, filters)                                               \
-  filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6)  \
-          : value
 
 #define IFDCOLORINDEX(ifd, subset, bit)                                        \
   (tiff_ifd[ifd].dng_color[subset].parsedfields & bit)                         \
       ? ifd                                                                    \
       : ((tiff_ifd[0].dng_color[subset].parsedfields & bit) ? 0 : -1)
 
 #define IFDLEVELINDEX(ifd, bit)                                                \
   (tiff_ifd[ifd].dng_levels.parsedfields & bit)                                \
       ? ifd                                                                    \
       : ((tiff_ifd[0].dng_levels.parsedfields & bit) ? 0 : -1)
 
 #define COPYARR(to, from) memmove(&to, &from, sizeof(from))
 
 		if (iifd < (int)tiff_nifds && iifd >= 0)
 		{
 			int sidx;
 			// Per field, not per structure
 			if (!(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT))
 			{
 				int illidx[2], cmidx[2], calidx[2], abidx;
 				for (int i = 0; i < 2; i++)
 				{
 					illidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_ILLUMINANT);
 					cmidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_COLORMATRIX);
 					calidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_CALIBRATION);
 				}
 				abidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);
 				// Data found, all in same ifd, illuminants are inited
 				if (illidx[0] >= 0 && illidx[0] < (int)tiff_nifds &&
 					illidx[0] == illidx[1] && illidx[0] == cmidx[0] &&
 					illidx[0] == cmidx[1] &&
 					tiff_ifd[illidx[0]].dng_color[0].illuminant > 0 &&
 					tiff_ifd[illidx[0]].dng_color[1].illuminant > 0)
 				{
 					sidx = illidx[0]; // => selected IFD
 					double cc[4][4], cm[4][3], cam_xyz[4][3];
 					// CM -> Color Matrix
 					// CC -> Camera calibration
 					for (int j = 0; j < 4; j++)
 						for (int i = 0; i < 4; i++)
 							cc[j][i] = i == j;
 					int colidx = -1;
 
 					// IS D65 here?
 					for (int i = 0; i < 2; i++)
 					{
 						if (tiff_ifd[sidx].dng_color[i].illuminant == LIBRAW_WBI_D65)
 						{
 							colidx = i;
 							break;
 						}
 					}
 
 					// Other daylight-type ill
 					if (colidx < 0)
 						for (int i = 0; i < 2; i++)
 						{
 							int ill = tiff_ifd[sidx].dng_color[i].illuminant;
 							if (ill == LIBRAW_WBI_Daylight || ill == LIBRAW_WBI_D55 ||
 								ill == LIBRAW_WBI_D75 || ill == LIBRAW_WBI_D50 ||
 								ill == LIBRAW_WBI_Flash)
 							{
 								colidx = i;
 								break;
 							}
 						}
 					if (colidx >= 0) // Selected
 					{
 						// Init camera matrix from DNG
 						FORCC for (int j = 0; j < 3; j++) cm[c][j] =
 							tiff_ifd[sidx].dng_color[colidx].colormatrix[c][j];
 
 						if (calidx[colidx] == sidx)
 						{
 							for (int i = 0; i < colors && i < 4; i++)
 								FORCC
 								cc[i][c] = tiff_ifd[sidx].dng_color[colidx].calibration[i][c];
 						}
 
 						if (abidx == sidx)
 							for (int i = 0; i < colors && i < 4; i++)
 								FORCC cc[i][c] *= tiff_ifd[sidx].dng_levels.analogbalance[i];
 						int j;
 						FORCC for (int i = 0; i < 3; i++)
                             for (cam_xyz[c][i] = j = 0; j < colors && j < 4; j++)
 							    cam_xyz[c][i] +=
 							        cc[c][j] * cm[j][i]; // add AsShotXY later * xyz[i];
 						cam_xyz_coeff(cmatrix, cam_xyz);
 					}
 				}
 			}
 
 			bool noFujiDNGCrop = makeIs(LIBRAW_CAMERAMAKER_Fujifilm)
 				&& (!strcmp(normalized_model, "S3Pro")
 					|| !strcmp(normalized_model, "S5Pro")
 					|| !strcmp(normalized_model, "S2Pro"));
 
-			if (!noFujiDNGCrop &&
-				(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP))
+			if (!noFujiDNGCrop) // Promote DNG Crops to raw_inset_crops
 			{
 				sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);
 				int sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);
-				if (sidx >= 0 && sidx == sidx2 &&
-					tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&
-					tiff_ifd[sidx].dng_levels.default_crop[3] > 0)
-				{
-					int lm = tiff_ifd[sidx].dng_levels.default_crop[0];
-					int lmm = CFAROUND(lm, filters);
-					int tm = tiff_ifd[sidx].dng_levels.default_crop[1];
-					int tmm = CFAROUND(tm, filters);
-					int ww = tiff_ifd[sidx].dng_levels.default_crop[2];
-					int hh = tiff_ifd[sidx].dng_levels.default_crop[3];
-					if (lmm > lm)
-						ww -= (lmm - lm);
-					if (tmm > tm)
-						hh -= (tmm - tm);
-					if (left_margin + lm + ww <= raw_width &&
-						top_margin + tm + hh <= raw_height)
-					{
-						left_margin += lmm;
-						top_margin += tmm;
-						width = ww;
-						height = hh;
-					}
-				}
+                if (sidx >= 0 && sidx == sidx2 &&
+                    tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&
+                    tiff_ifd[sidx].dng_levels.default_crop[3] > 0)
+                {
+                    int lm = tiff_ifd[sidx].dng_levels.default_crop[0];
+                    int tm = tiff_ifd[sidx].dng_levels.default_crop[1];
+                    int ww = tiff_ifd[sidx].dng_levels.default_crop[2];
+                    int hh = tiff_ifd[sidx].dng_levels.default_crop[3];
+                    if ((lm + ww < int(raw_width) + int(left_margin))
+                        && (tm + hh < int(raw_height) + int(top_margin))) // Crop data is correct
+                    {
+                        imgdata.sizes.raw_inset_crops[0].cleft = left_margin + lm;
+                        imgdata.sizes.raw_inset_crops[0].cwidth = ww;
+                        imgdata.sizes.raw_inset_crops[0].ctop = top_margin + tm;
+                        imgdata.sizes.raw_inset_crops[0].cheight = hh;
+
+                        int sidx3 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_USERCROP);
+                        if (sidx3 >= 0 && sidx3 == sidx) // No need to check values range, it is checked at parse
+                        {
+                            int dt = int(imgdata.sizes.raw_inset_crops[0].cheight * tiff_ifd[sidx].dng_levels.user_crop[0]);
+                            int dl = int(imgdata.sizes.raw_inset_crops[0].cwidth * tiff_ifd[sidx].dng_levels.user_crop[1]);
+                            int db = int(imgdata.sizes.raw_inset_crops[0].cheight * tiff_ifd[sidx].dng_levels.user_crop[2]);
+                            int dr = int(imgdata.sizes.raw_inset_crops[0].cwidth * tiff_ifd[sidx].dng_levels.user_crop[3]);
+
+                            int dh = db - dt;
+                            int dw = dr - dl;
+
+                            if (dh > 0 && dw > 0
+                                && dh < imgdata.sizes.raw_inset_crops[0].cheight // No need to repeat crop for 0,0,1,1
+                                && dw < imgdata.sizes.raw_inset_crops[0].cwidth)
+                            {
+                                imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft + dl;
+                                imgdata.sizes.raw_inset_crops[1].cwidth = dw;
+                                imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop + dt;
+                                imgdata.sizes.raw_inset_crops[1].cheight = dh;
+                            }
+                        }
+
+                    }
+                }
 			}
 			if (!(imgdata.color.dng_color[0].parsedfields &
 				LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)
 			{
 				sidx = IFDCOLORINDEX(iifd, 0, LIBRAW_DNGFM_FORWARDMATRIX);
 				if (sidx >= 0)
 					COPYARR(imgdata.color.dng_color[0].forwardmatrix,
 						tiff_ifd[sidx].dng_color[0].forwardmatrix);
 			}
 			if (!(imgdata.color.dng_color[1].parsedfields &
 				LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)
 			{
 				sidx = IFDCOLORINDEX(iifd, 1, LIBRAW_DNGFM_FORWARDMATRIX);
 				if (sidx >= 0)
 					COPYARR(imgdata.color.dng_color[1].forwardmatrix,
 						tiff_ifd[sidx].dng_color[1].forwardmatrix);
 			}
 			for (int ss = 0; ss < 2; ss++)
 			{
 				sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_COLORMATRIX);
 				if (sidx >= 0)
 					COPYARR(imgdata.color.dng_color[ss].colormatrix,
 						tiff_ifd[sidx].dng_color[ss].colormatrix);
 
 				sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_CALIBRATION);
 				if (sidx >= 0)
 					COPYARR(imgdata.color.dng_color[ss].calibration,
 						tiff_ifd[sidx].dng_color[ss].calibration);
 
 				sidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_ILLUMINANT);
 				if (sidx >= 0)
 					imgdata.color.dng_color[ss].illuminant =
 					tiff_ifd[sidx].dng_color[ss].illuminant;
 			}
 			// Levels
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);
 			if (sidx >= 0)
 				COPYARR(imgdata.color.dng_levels.analogbalance,
 					tiff_ifd[sidx].dng_levels.analogbalance);
 
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BASELINEEXPOSURE);
 			if (sidx >= 0)
 				imgdata.color.dng_levels.baseline_exposure =
 				tiff_ifd[sidx].dng_levels.baseline_exposure;
 
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_WHITE);
 			if (sidx >= 0 && tiff_ifd[sidx].dng_levels.dng_whitelevel[0])
 				COPYARR(imgdata.color.dng_levels.dng_whitelevel,
 					tiff_ifd[sidx].dng_levels.dng_whitelevel);
 			else if (tiff_ifd[iifd].sample_format <= 2 && tiff_ifd[iifd].bps > 0 && tiff_ifd[iifd].bps < 32)
 				FORC4
 				imgdata.color.dng_levels.dng_whitelevel[c] = (1 << tiff_ifd[iifd].bps) - 1;
 
 
 
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ASSHOTNEUTRAL);
 			if (sidx >= 0)
 			{
 				COPYARR(imgdata.color.dng_levels.asshotneutral,
 					tiff_ifd[sidx].dng_levels.asshotneutral);
 				if (imgdata.color.dng_levels.asshotneutral[0])
 				{
 					cam_mul[3] = 0;
 					FORCC
 						if (fabs(imgdata.color.dng_levels.asshotneutral[c]) > 0.0001)
 							cam_mul[c] = 1 / imgdata.color.dng_levels.asshotneutral[c];
 				}
 			}
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BLACK);
 			if (sidx >= 0)
 			{
 				imgdata.color.dng_levels.dng_fblack =
 					tiff_ifd[sidx].dng_levels.dng_fblack;
 				imgdata.color.dng_levels.dng_black =
 					tiff_ifd[sidx].dng_levels.dng_black;
 				COPYARR(imgdata.color.dng_levels.dng_cblack,
 					tiff_ifd[sidx].dng_levels.dng_cblack);
 				COPYARR(imgdata.color.dng_levels.dng_fcblack,
 					tiff_ifd[sidx].dng_levels.dng_fcblack);
 			}
 
 
 			if (pifd >= 0)
 			{
 				sidx = IFDLEVELINDEX(pifd, LIBRAW_DNGFM_PREVIEWCS);
 				if (sidx >= 0)
 					imgdata.color.dng_levels.preview_colorspace =
 					tiff_ifd[sidx].dng_levels.preview_colorspace;
 			}
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_OPCODE2);
 			if (sidx >= 0)
 				meta_offset = tiff_ifd[sidx].opcode2_offset;
 
 			sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINTABLE);
 			INT64 linoff = -1;
 			int linlen = 0;
 			if (sidx >= 0)
 			{
 				linoff = tiff_ifd[sidx].lineartable_offset;
 				linlen = tiff_ifd[sidx].lineartable_len;
 			}
 
 			if (linoff >= 0 && linlen > 0)
 			{
 				INT64 pos = ftell(ifp);
 				fseek(ifp, linoff, SEEK_SET);
 				linear_table(linlen);
 				fseek(ifp, pos, SEEK_SET);
 			}
 			// Need to add curve too
 		}
 		/* Copy DNG black level to LibRaw's */
 		if (load_raw == &LibRaw::lossy_dng_load_raw)
 		{
 			maximum = 0xffff;
 			FORC4 imgdata.color.linear_max[c] = imgdata.color.dng_levels.dng_whitelevel[c] = 0xffff;
 		}
 		else
 		{
 			maximum = imgdata.color.dng_levels.dng_whitelevel[0];
 		}
 		black = imgdata.color.dng_levels.dng_black;
 		if (tiff_samples == 2 &&
 		    !imgdata.color.dng_levels.dng_cblack[2] &&
 		    !imgdata.color.dng_levels.dng_cblack[3] &&
 		    (imgdata.color.dng_levels.dng_cblack[4] == 1) &&
 		    (imgdata.color.dng_levels.dng_cblack[5] == 1)
             && (imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] == tiff_samples)
             ) {
 		  black = imgdata.color.dng_levels.dng_cblack[shot_select];
 		  imgdata.color.dng_levels.dng_cblack[0] = imgdata.color.dng_levels.dng_cblack[1] = 0;
 		  imgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;
 		  imgdata.color.dng_levels.dng_fcblack[0] = imgdata.color.dng_levels.dng_fcblack[1] = 0.0f;
 		  imgdata.color.dng_levels.dng_fcblack[4] = imgdata.color.dng_levels.dng_fcblack[5] = 0.0f;
 		}
 		else if (tiff_samples == 2 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples
 			== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])
 		{
 			unsigned ff = filters;
 			if (filters > 999 && colors == 3)
 				filters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) &
 				filters << 1;
 
 			/* Special case, Fuji SuperCCD dng */
 			int csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };
 			int i = 6 + shot_select;
 			for (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)
 				for (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)
 				{
 					csum[FC(row, col)] += imgdata.color.dng_levels.dng_cblack[i];
 					ccount[FC(row, col)]++;
 					i += tiff_samples;
 				}
 			for (int c = 0; c < 4; c++)
 				if (ccount[c])
 					imgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];
 			imgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;
 			filters = ff;
 		}
 		else if (tiff_samples > 2 && tiff_samples <= 4 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples
 			== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])
 		{
 			/* Special case, per_channel blacks in RepeatDim, average for per-channel */
 			int csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };
 			int i = 6;
 			for (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)
 				for (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)
 					for (unsigned c = 0; c < tiff_samples && c < 4; c++)
 					{
 						csum[c] += imgdata.color.dng_levels.dng_cblack[i];
 						ccount[c]++;
 						i++;
 					}
 			for (int c = 0; c < 4; c++)
 				if (ccount[c])
 					imgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];
 			imgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;
 		}
 
 		memmove(cblack, imgdata.color.dng_levels.dng_cblack, sizeof(cblack));
 
 		if (iifd < (int)tiff_nifds && iifd >= 0)
 		{
 			int sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINEARRESPONSELIMIT);
 			if (sidx >= 0)
 			{
 				imgdata.color.dng_levels.LinearResponseLimit =
 					tiff_ifd[sidx].dng_levels.LinearResponseLimit;
 				if (imgdata.color.dng_levels.LinearResponseLimit > 0.1 &&
 					imgdata.color.dng_levels.LinearResponseLimit <= 1.0)
 				{
 					// And approx promote it to linear_max:
 					int bl4 = 0, bl64 = 0;
 					for (int chan = 0; chan < colors && chan < 4; chan++)
 						bl4 += cblack[chan];
 					bl4 /= LIM(colors, 1, 4);
 
 					if (cblack[4] * cblack[5] > 0)
 					{
 						unsigned cnt = 0;
 						for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)
 						{
 							bl64 += cblack[c + 6];
 							cnt++;
 						}
 						bl64 /= LIM(cnt, 1, 4096);
 					}
 					int rblack = black + bl4 + bl64;
                     for (int chan = 0; chan < colors && chan < 4; chan++)
                         imgdata.color.linear_max[chan] =
                             (maximum - rblack) *
                             imgdata.color.dng_levels.LinearResponseLimit +
                             rblack;
                     if (imgdata.color.linear_max[1] && !imgdata.color.linear_max[3])
                         imgdata.color.linear_max[3] = imgdata.color.linear_max[1];
 				}
 			}
 		}
 	}
 }
@@ -1630,91 +1677,98 @@ void LibRaw::identify_process_dng_fields()
 void LibRaw::identify_finetune_pentax()
 {
     if (dng_version && data_offset)
     {
-        for(int i = 0; i < tiff_nifds; i++)
+        for(int i = 0; i < (int)tiff_nifds; i++)
             if (tiff_ifd[i].offset == data_offset)
             {
                 if (tiff_ifd[i].phint == 34892) return; // Linear DNG made from Pentax source
                 break;
             }
     }
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Pentax) ||
 		makeIs(LIBRAW_CAMERAMAKER_Samsung)) {
 		if (height == 2624 &&
 			width == 3936) // Pentax K10D, Samsung GX10;
 		{
 			height = 2616;
 			width = 3896;
 		}
 		if (height == 3136 &&
 			width == 4864) // Pentax K20D, Samsung GX20;
 		{
 			height = 3124;
 			width = 4688;
 			filters = 0x16161616;
 		}
 	}
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Pentax)) {
 		if ((width == 4352) &&
 			((unique_id == PentaxID_K_r) ||
 			(unique_id == PentaxID_K_x)))
 		{
 			width = 4309;
 			filters = 0x16161616;
 		}
 		if ((width >= 4960) &&
 			((unique_id == PentaxID_K_5) ||
 			(unique_id == PentaxID_K_5_II) ||
 				(unique_id == PentaxID_K_5_II_s)))
 		{
 			left_margin = 10;
 			width = 4950;
 			filters = 0x16161616;
 		}
 		if ((width == 6080) && (unique_id == PentaxID_K_70))
 		{
 			height = 4016;
 			top_margin = 32;
 			width = 6020;
 			left_margin = 60;
 		}
 		if ((width == 4736) && (unique_id == PentaxID_K_7))
 		{
 			height = 3122;
 			width = 4684;
 			filters = 0x16161616;
 			top_margin = 2;
 		}
 		if ((width == 6080) && (unique_id == PentaxID_K_3_II))
 		{
 			left_margin = 4;
 			width = 6040;
 		}
-		if ((width == 6112) && (unique_id == PentaxID_KP))
+        if ((width == 6304) && (unique_id == PentaxID_K_3_III)) // From DNG ActiveArea
+        {
+          left_margin = 26;
+          width = 6224;
+          top_margin = 34;
+          height = 4160;
+        }
+        if ((width == 6112) && (unique_id == PentaxID_KP))
 		{
 			// From DNG, maybe too strict
 			left_margin = 54;
 			top_margin = 28;
 			width = 6028;
 			height = raw_height - top_margin;
 		}
 		if ((width == 6080) && (unique_id == PentaxID_K_3))
 		{
 			left_margin = 4;
 			width = 6040;
 		}
 		if ((width == 7424) && (unique_id == PentaxID_645D))
 		{
 			height = 5502;
 			width = 7328;
 			filters = 0x61616161;
 			top_margin = 29;
 			left_margin = 48;
 		}
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Ricoh) &&
 		(height == 3014) && (width == 4096))  // Ricoh GX200
 		width = 4014;
 }
@@ -1755,1293 +1809,1319 @@ void LibRaw::identify_finetune_by_filesize(int fsize)
 void LibRaw::identify_finetune_dcr(char head[64], int fsize, int flen)
 {
 	static const short pana[][6] = {
 		// raw_width, raw_height, left_margin, top_margin, width_increment,
 		// height_increment
 		{3130, 1743, 4, 0, -6, 0},      /* 00 */
 		{3130, 2055, 4, 0, -6, 0},      /* 01 */
 		{3130, 2319, 4, 0, -6, 0},      /* 02 DMC-FZ8 */
 		{3170, 2103, 18, 0, -42, 20},   /* 03 */
 		{3170, 2367, 18, 13, -42, -21}, /* 04 */
 		{3177, 2367, 0, 0, -1, 0},      /* 05 DMC-L1 */
 		{3304, 2458, 0, 0, -1, 0},      /* 06 DMC-FZ30 */
 		{3330, 2463, 9, 0, -5, 0},      /* 07 DMC-FZ18 */
 		{3330, 2479, 9, 0, -17, 4},     /* 08 */
 		{3370, 1899, 15, 0, -44, 20},   /* 09 */
 		{3370, 2235, 15, 0, -44, 20},   /* 10 */
 		{3370, 2511, 15, 10, -44, -21}, /* 11 */
 		{3690, 2751, 3, 0, -8, -3},     /* 12 DMC-FZ50 */
 		{3710, 2751, 0, 0, -3, 0},      /* 13 DMC-L10 */
 		{3724, 2450, 0, 0, 0, -2},      /* 14 */
 		{3770, 2487, 17, 0, -44, 19},   /* 15 */
 		{3770, 2799, 17, 15, -44, -19}, /* 16 */
 		{3880, 2170, 6, 0, -6, 0},      /* 17 DMC-LX1 */
 		{4060, 3018, 0, 0, 0, -2},      /* 18 DMC-FZ35, DMC-FZ38 */
 		{4290, 2391, 3, 0, -8, -1},     /* 19 DMC-LX2 */
 		{4330, 2439, 17, 15, -44, -19}, /* 20 "D-LUX 3" */
 		{4508, 2962, 0, 0, -3, -4},     /* 21 */
 		{4508, 3330, 0, 0, -3, -6},     /* 22 */
 		{10480, 7794, 0, 0, -2, 0},     /* 23: G9 in high-res */
 	};
 	int i,c;
 	struct jhead jh;
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Canon) 
         && ( !tiff_flip || unique_id == CanonID_EOS_40D)
         && imCanon.MakernotesFlip)
 	{
 		tiff_flip = imCanon.MakernotesFlip;
 	}
 
 	else if (makeIs(LIBRAW_CAMERAMAKER_Nikon))
 	{
 		if (!load_raw)
 			load_raw = &LibRaw::packed_load_raw;
 		if (model[0] == 'E') // Nikon E8800, E8700, E8400, E5700, E5400, E5000,
 							 // others are diag hacks?
 			load_flags |= !data_offset << 2 | 2;
 	}
 	/* Set parameters based on camera name (for non-DNG files). */
 
 	/* Always 512 for arw2_load_raw */
 	else if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&
 		(raw_width > 3888) && !black && !cblack[0])
 	{
 		black = (load_raw == &LibRaw::sony_arw2_load_raw)
 			? 512
 			: (128 << (tiff_bps - 12));
 	}
 
 	if (is_foveon) {
 		if (height * 2 < width)
 			pixel_aspect = 0.5;
 		if (height > width)
 			pixel_aspect = 2;
 		filters = 0;
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Pentax)) {
 		if ((unique_id == PentaxID_K_1) ||
 			(unique_id == PentaxID_K_1_Mark_II)) {
 			top_margin = 18;
 			height = raw_height - top_margin;
 			if (raw_width == 7392) {
 				left_margin = 6;
 				width = 7376;
 			}
 
 		}
 		else if (unique_id == PentaxID_Optio_S_V101) { // (fsize == 3178560)
 			cam_mul[0] *= 4;
 			cam_mul[2] *= 4;
 
 		}
 		else if (unique_id == PentaxID_Optio_33WR) { // (fsize == 4775936)
 			flip = 1;
 			filters = 0x16161616;
 
 		}
 		else if (unique_id == PentaxID_staristD) {
 			load_raw = &LibRaw::unpacked_load_raw;
 			/* data_error = -1; */ /* No way to know why data_error was raised in dcraw.c, looks not needed esp. for unpacked_load_raw */
 		}
 		else if (unique_id == PentaxID_staristDS) {
 			height -= 2;
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Canon)) {
 		if (tiff_bps == 15) { // Canon sRAW
 			if (width == 3344)
 				width = 3272;
 			else if (width == 3872)
 				width = 3866;
 
 			if (height > width) {
 				SWAP(height, width);
 				SWAP(raw_height, raw_width);
 			}
 			if (width == 7200 &&
 				height == 3888) { // Canon EOS 5DS (R);
 				raw_width = width = 6480;
 				raw_height = height = 4320;
 			}
 			filters = 0;
 			tiff_samples = colors = 3;
 			load_raw = &LibRaw::canon_sraw_load_raw;
 		}
 
 		if (!strcmp(normalized_model, "PowerShot 600")) {
 			height = 613;
 			width = 854;
 			raw_width = 896;
 			colors = 4;
 			filters = 0xe1e4e1e4;
 			load_raw = &LibRaw::canon_600_load_raw;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot A5") ||
 			!strcmp(normalized_model, "PowerShot A5 Zoom")) {
 			height = 773;
 			width = 960;
 			raw_width = 992;
 			pixel_aspect = 256 / 235.0;
 			filters = 0x1e4e1e4e;
 			goto canon_a5;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot A50")) {
 			height = 968;
 			width = 1290;
 			raw_width = 1320;
 			filters = 0x1b4e4b1e;
 			goto canon_a5;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot Pro70")) {
 			height = 1024;
 			width = 1552;
 			filters = 0x1e4b4e1b;
 		canon_a5:
 			colors = 4;
 			tiff_bps = 10;
 			load_raw = &LibRaw::packed_load_raw;
 			load_flags = 40;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot Pro90 IS") ||
 			!strcmp(normalized_model, "PowerShot G1")) {
 			colors = 4;
 			filters = 0xb4b4b4b4;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot A610")) { // chdk hack
 			if (canon_s2is()) {
 				strcpy(model + 10, "S2 IS");
 				strcpy(normalized_model + 10, "S2 IS");
 			}
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot SX220 HS")) { // chdk hack
 			mask[1][3] = -4;
 			top_margin = 16;
 			left_margin = 92;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot S120")) { // chdk hack
 			raw_width = 4192;
 			raw_height = 3062;
 			width = 4022;
 			height = 3016;
 			mask[0][0] = top_margin = 31;
 			mask[0][2] = top_margin + height;
 			left_margin = 120;
 			mask[0][1] = 23;
 			mask[0][3] = 72;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot G16")) {
 			mask[0][0] = 0;
 			mask[0][2] = 80;
 			mask[0][1] = 0;
 			mask[0][3] = 16;
 			top_margin = 29;
 			left_margin = 120;
 			width = raw_width - left_margin - 48;
 			height = raw_height - top_margin - 14;
 
 		}
 		else if (!strcmp(normalized_model, "PowerShot SX50 HS")) {
 			top_margin = 17;
 		}
 
 	}
 
 	else if (makeIs(LIBRAW_CAMERAMAKER_Nikon)) {
 		if (!strcmp(model, "D1"))
 		{
 			imgdata.other.analogbalance[0] = cam_mul[0];
 			imgdata.other.analogbalance[2] = cam_mul[2];
 			imgdata.other.analogbalance[1] = imgdata.other.analogbalance[3] =
 				cam_mul[1];
 			cam_mul[0] = cam_mul[1] = cam_mul[2] = 1.0f;
 		}
 
 		else if (!strcmp(model, "D1X"))
 		{
 			width -= 4;
 			pixel_aspect = 0.5;
 		}
 		else if (!strcmp(model, "D40X") ||
 			!strcmp(model, "D60") ||
 			!strcmp(model, "D80") ||
 			!strcmp(model, "D3000"))
 		{
 			height -= 3;
 			width -= 4;
 		}
 		else if (!strcmp(model, "D3") ||
 			!strcmp(model, "D3S") ||
 			!strcmp(model, "D700"))
 		{
 			width -= 4;
 			left_margin = 2;
 		}
 		else if (!strcmp(model, "D3100"))
 		{
 			width -= 28;
 			left_margin = 6;
 		}
 		else if (!strcmp(model, "D5000") ||
 			!strcmp(model, "D90"))
 		{
 			width -= 42;
 		}
 		else if (!strcmp(model, "D5100") ||
 			!strcmp(model, "D7000") ||
 			!strcmp(model, "COOLPIX A"))
 		{
 			width -= 44;
 		}
 		else if (!strcmp(model, "D3200") ||
 			!strcmp(model, "D600") ||
 			!strcmp(model, "D610") ||
 			!strncmp(model, "D800", 4)) // Nikons: D800, D800E
 		{
 			width -= 46;
 		}
 		else if (!strcmp(model, "D4") ||
 			!strcmp(model, "Df"))
 		{
 			width -= 52;
 			left_margin = 2;
 		}
 		else if (!strcmp(model, "D500"))
 		{
 			// Empty - to avoid width-1 below
 		}
 		else if (!strncmp(model, "D40", 3) ||
 			!strncmp(model, "D50", 3) ||
 			!strncmp(model, "D70", 3))
 		{
 			width--;
 		}
 		else if (!strcmp(model, "D100"))
 		{
 			if (load_flags) // compressed NEF
 				raw_width = (width += 3) + 3;
 		}
 		else if (!strcmp(model, "D200"))
 		{
 			left_margin = 1;
 			width -= 4;
 			filters = 0x94949494;
 		}
 		else if (!strncmp(model, "D2H", 3)) // Nikons: D2H, D2Hs
 		{
 			left_margin = 6;
 			width -= 14;
 		}
 		else if (!strncmp(model, "D2X", 3)) // Nikons: D2X, D2Xs
 		{
 			if (width == 3264) // in-camera Hi-speed crop: On
 				width -= 32;
 			else
 				width -= 8;
 		}
 		else if (!strncmp(model, "D300", 4)) // Nikons: D300, D300s
 		{
 			width -= 32;
 		}
 		else if (raw_width == 4032) // Nikon "COOLPIX P7700", "COOLPIX P7800",
 									// "COOLPIX P330", "COOLPIX P340"
 		{
 			if (!strcmp(normalized_model, "COOLPIX P7700"))
 			{
 				maximum = 65504;
 				load_flags = 0;
 			}
 			else if (!strcmp(normalized_model, "COOLPIX P7800"))
 			{
 				maximum = 65504;
 				load_flags = 0;
 			}
 			else if (!strcmp(model, "COOLPIX P340"))
 			{
 				load_flags = 0;
 			}
 		}
 		else if (!strncmp(model, "COOLPIX P", 9) &&
 			raw_width != 4032) // Nikon "COOLPIX P1000", "COOLPIX P6000",
 							   // "COOLPIX P7000", "COOLPIX P7100"
 		{
 			load_flags = 24;
 			filters = 0x94949494;
 			/* the following 'if' is most probably obsolete, because we now read black
 			 * level from metadata */
 			if ((model[9] == '7') && /* P7000, P7100 */
 				((iso_speed >= 400) || (iso_speed == 0)) &&
 				!strstr(software, "V1.2")) /* v. 1.2 seen for P7000 only */
 				black = 255;
 		}
 		else if (!strncmp(model, "COOLPIX B700", 12))
 		{
 			load_flags = 24;
 		}
 		else if (!strncmp(model, "1 ",
 			2)) // Nikons: "1 AW1", "1 J1", "1 J2", "1 J3", "1 J4",
 				// "1 J5", "1 S1", "1 S2", "1 V1", "1 V2", "1 V3"
 		{
 			height -= 2;
 		}
 		else if (fsize == 1581060) // hack Nikon 1mpix: E900
 		{
 			simple_coeff(3);
 			pre_mul[0] = 1.2085;
 			pre_mul[1] = 1.0943;
 			pre_mul[3] = 1.1103;
 		}
 		else if ((fsize == 4771840) &&  // hack Nikon 3mpix: E880, E885, E990
 			strcmp(model, "E995")) // but not E995
 		{
 			filters = 0xb4b4b4b4;
 			simple_coeff(3);
 			pre_mul[0] = 1.196;
 			pre_mul[1] = 1.246;
 			pre_mul[2] = 1.018;
 		}
 		else if ((fsize == 4775936) && // hack Nikon 3mpix: E3100, E3200, E3500
 			(atoi(model + 1) < 3700)) // but not E3700;
 		{
 			filters = 0x49494949;
 		}
 		else if (fsize == 5869568) // hack Nikon 4mpix: E4300;
 		{
 			load_flags = 6;
 		}
 		else if (!strcmp(model, "E2500"))
 		{
 			height -= 2;
 			load_flags = 6;
 			colors = 4;
 			filters = 0x4b4b4b4b;
 		}
 	}
 
 	else if (makeIs(LIBRAW_CAMERAMAKER_Olympus)) {
 		if (OlyID == OlyID_C_740UZ) { // (fsize == 4775936)
 			i = find_green(12, 32, 1188864, 3576832);
 			c = find_green(12, 32, 2383920, 2387016);
 			if (abs(i) < abs(c)) {
 				SWAP(i, c);
 				load_flags = 24;
 			}
 			if (i < 0)
 				filters = 0x61616161;
 		}
 		else if (OlyID == OlyID_C_770UZ) {
 			height = 1718;
 			width = 2304;
 			filters = 0x16161616;
 			load_raw = &LibRaw::packed_load_raw;
 			load_flags = 30;
 		}
 		else {
 			height += height & 1;
 			if (exif_cfa)
 				filters = exif_cfa;
 
 			if (width == 4100) // Olympus E-PL2, E-PL1, E-P2, E-P1, E-620, E-600, E-5, E-30;
 				width -= 4;
 
 			if (width == 4080) // Olympus E-PM1, E-PL3, E-P3;
 				width -= 24;
 
 			if (width == 10400) // Olympus PEN-F, E-M1-II, E-M1-III, E-M1X
 				width -= 12;
 
 			if (width == 8200) // E-M1-III in 50Mp mode, E-M1X
 				width -= 30;
 
 			if (width == 9280) { // Olympus E-M5 Mark II;
 				width -= 6;
 				height -= 6;
 			}
 
 			if (load_raw == &LibRaw::unpacked_load_raw) {
 				load_flags = 4;
         if (imOly.ValidBits == 10) load_flags += 2;
 			}
       tiff_bps = imOly.ValidBits;
 
 			if ((OlyID == OlyID_E_300) ||
 				(OlyID == OlyID_E_500)) {
 				width -= 20;
 				if (load_raw == &LibRaw::unpacked_load_raw) {
 					maximum = 0xfc3;
 					memset(cblack, 0, sizeof cblack);
 				}
 			}
 			else if (OlyID == OlyID_STYLUS_1) {
 				width -= 16;
 				maximum = 0xfff;
 
 			}
 			else if (OlyID == OlyID_E_330) {
 				width -= 30;
 				if (load_raw == &LibRaw::unpacked_load_raw)
 					maximum = 0xf79;
 
 			}
 			else if (OlyID == OlyID_SP_550UZ) {
 				thumb_length = flen - (thumb_offset = 0xa39800);
 				thumb_height = 480;
 				thumb_width = 640;
 
 			}
 			else if (OlyID == OlyID_TG_4) {
 				width -= 16;
 
 			}
 			else if ((OlyID == OlyID_TG_5) ||
 				(OlyID == OlyID_TG_6)) {
 				width -= 26;
 			}
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_RoverShot) &&
 		(fsize == 6291456)) { // RoverShot 3320AF
 		fseek(ifp, 0x300000, SEEK_SET);
 		if ((order = guess_byte_order(0x10000)) == 0x4d4d)
 		{
 			height -= (top_margin = 16);
 			width -= (left_margin = 28);
 			maximum = 0xf5c0;
 			strcpy(make, "ISG");
 			maker_index = LIBRAW_CAMERAMAKER_ISG;
 			model[0] = 0;
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm)) {
     if (!imFuji.RAFDataGeneration && (raw_width == 2944)) // S2Pro
 		{
 			height = 2144;
 			width = 2880;
 			flip = 6;
 		}
 		else if (load_raw != &LibRaw::packed_load_raw &&
 		         strncmp(model, "X-", 2)              &&
 			       filters >= 1000) // Bayer and not an X-model
 			maximum = (is_raw == 2 && shot_select) ? 0x2f00 : 0x3e00;
 
     if (!FujiCropMode && imFuji.RAFDataGeneration && (imFuji.RAFDataGeneration != 4096))
     {
       width  = imFuji.RAFData_ImageSizeTable[0];
       height = imFuji.RAFData_ImageSizeTable[1];
     }
 		else if (FujiCropMode == 1) // FF crop on GFX
 		{
 			width = raw_width;
 			height = raw_height;
 		}
         // Do we need set height = raw_height for CropMode == 2 for all cameras??
 		else if (FujiCropMode == 4) // electronic shutter, high speed mode (1.25x crop)
 		{
 			height = raw_height;
 		}
 
 		top_margin = (raw_height >= height) ? (raw_height - height) >> 2 << 1 : 0;
 		left_margin = (raw_width >= width) ? (raw_width - width) >> 2 << 1 : 0;
 
     if (imFuji.RAFDataGeneration && (imFuji.RAFDataGeneration != 4096)) {
       switch (raw_width) {
       case 2944:                // X-S1, X10, XF1
         filters = 0x16161616;
         break;
       case 4096:                // X20, X30, XQ1, XQ2
       case 5120:                // X-Pro1, X-E1, X-A1, X-A2, X-M1
       case 6048:                // lossless compressed X100F, X-T2, X-T20, X-Pro2, X-H1, X-E3
       case 6160:                // uncompressed (unpacked) X100F, X-T2, X-T20, X-Pro2, X-H1, X-E3
         left_margin = 0;
         break;
       case 4992:                // X-E2S, X-E2, X-T10, X-T1, X100S, X100T, X70
         left_margin = 4;
         break;
       case 6384:                // X-T3, X-T4, X100V, X-S10, X-T30, X-Pro3
         top_margin = 0;
         switch (FujiCropMode) {
         case 0:        // no crop
 				  left_margin = 0;
 				  top_margin = 6;
 				  width = 6246;
 				  height = 4170;
 				  break;
 				case 2:        // sports finder mode
 				  left_margin = 624;
 				  width = 5004;
 				  height = raw_height;
 				  break;
 				case 4:        // electronic shutter, high speed mode (1.25x crop)
           left_margin = 624;
 				  width = 5004;
 				  break;
         }
         break;
       case 6912:                // GFX 50S, GFX 50R; FF crop
       case 9216:                // GFX 50S, GFX 50R; no crop
 			  left_margin = 0;
 			  top_margin = 0;
         break;
+      case 8472:                // GFX 50S II
+        left_margin = 0;
+			  top_margin  = 0;
+			  width = raw_width - 192;
+        break;
       case 9696:                // GFX 100; FF crop
       case 11808:               // GFX 100; no crop
 			  left_margin = 0;
 			  width = raw_width - 146;
 			  height = raw_height - (top_margin = 2);
 			  if (tiff_bps == 16)
 				  maximum = 0xffff;
       default:
       /* insert model name-based width/height/margins/etc. assignments */
         break;
       }
 
     } else if (!imFuji.RAFDataGeneration) {
       switch (raw_width) {
       case 2304:                // S5100
         height -= (top_margin = 6);
         break;
       case 3328:                // F550EXR, F600EXR, F770EXR, F800EXR, F900EXR,
                                 // HS20EXR, HS30EXR, HS33EXR, HS50EXR
         if ((width = raw_width - 66))
           left_margin = 34;
-        if (imgdata.sizes.raw_inset_crop.cleft == 8) // HS50EXR, F900EXR
+        if (imgdata.sizes.raw_inset_crops[0].cleft == 8) // HS50EXR, F900EXR
         {
 			    left_margin = 0;
 			    width += 2;
 			    filters = 0x16161616;
         }
         break;
       case 3664:                // "HS10 HS11"
         filters = 0x16161616;
         break;
       case 5504:                // DBP for GX680 aka DX-2000
 
 //         7712 2752 -> 5504 3856
 //         width = 688;
 //         height = 30848;
 //         raw_width = 688;
 //         raw_height = 30848;
 
-        left_margin = 32; // imgdata.sizes.raw_inset_crop.cleft
+        left_margin = 32; // imgdata.sizes.raw_inset_crops[0].cleft
         top_margin = 8;
         width = raw_width - 2*left_margin;
         height = raw_height - 2*top_margin;
 
         load_raw = &LibRaw::unpacked_load_raw_FujiDBP;
         //  maximum = 0x0fff;
         filters = 0x16161616;
         load_flags = 0;
         flip = 6;
         break;
       default:
       /* insert model name-based width/height/margins/etc. assignments */
         break;
       }
     }
 		if (fuji_layout)
 			raw_width *= is_raw;
 		if (filters == 9)
 			FORC(36)
 			((char *)xtrans)[c] =
 			xtrans_abs[(c / 6 + top_margin) % 6][(c + left_margin) % 6];
 	}
 
 	else if (makeIs(LIBRAW_CAMERAMAKER_Konica)) {
 		if (!strcmp(model, "KD-400Z")) {
 			height = 1711; // 1712
 			width = 2312;
 			raw_width = 2336;
 			goto konica_400z;
 		}
 		else if (!strcmp(model, "KD-510Z")) {
 			goto konica_510z;
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Minolta)) {
 		if (fsize == 5869568) { // hack "DiMAGE Z2"
 			load_flags = 30;
 		}
 
 		if (imSony.prd_StorageMethod == LIBRAW_MINOLTA_UNPACKED) {
 			load_raw = &LibRaw::unpacked_load_raw;
 		} else if (imSony.prd_StorageMethod == LIBRAW_MINOLTA_PACKED) {
 			load_raw = &LibRaw::packed_load_raw;
       } else if (!load_raw && (maximum = 0xfff)) {
 			load_raw = &LibRaw::unpacked_load_raw;
 		}
 
       if (imSony.prd_BayerPattern == LIBRAW_MINOLTA_G2BRG1) {
 			filters = 0x49494949;
       } else if (imSony.prd_BayerPattern == LIBRAW_MINOLTA_RGGB) {
 			filters = 0x94949494;
       }
 
       if (imSony.prd_Active_bps && imSony.prd_Total_bps) {
 			tiff_bps = imSony.prd_Active_bps;
       }
 
 		if (!strncmp(model, "DiMAGE G", 8)) // hack "DiMAGE G400", "DiMAGE G500",
                                                // "DiMAGE G530", "DiMAGE G600"
 		{
 			if (model[8] == '4') // DiMAGE G400
 			{
 				height = 1716;
 				width = 2304;
 			}
 			else if (model[8] == '5') // DiMAGE G500 / G530
 			{
 			konica_510z:
 				height = 1956;
 				width = 2607;
 				raw_width = 2624;
 			}
 			else if (model[8] == '6') // DiMAGE G600
 			{
 				height = 2136;
 				width = 2848;
 			}
 			data_offset += 14;
 			filters = 0x61616161;
 		konica_400z:
 			load_raw = &LibRaw::unpacked_load_raw;
 			maximum = 0x3df;
 			order = 0x4d4d;
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Samsung)) {
 		if (raw_width == 4704) // Samsung NX100, NX10, NX11,
 		{
 			height -= top_margin = 8;
 			width -= 2 * (left_margin = 8);
 			load_flags = 32;
 		}
 		else if (!strcmp(model, "NX3000")) // Samsung NX3000; raw_width: 5600
 		{
 			top_margin = 38;
 			left_margin = 92;
 			width = 5456;
 			height = 3634;
 			filters = 0x61616161;
 			colors = 3;
 		}
 		else if (raw_height == 3714) // Samsung NX2000, NX300M, NX300, NX30,
 		                             // "NX U" (aka:
 		                             //         "EK-GN100", "EK-GN110", "EK-GN120",
 		                             //         "EK-KN120", "Galaxy NX")
 		{
 			height -= top_margin = 18;
 			left_margin = raw_width - (width = 5536);
 			if (raw_width != 5600)
 				left_margin = top_margin = 0;
 			filters = 0x61616161;
 			colors = 3;
 		}
 		else if (raw_width == 5632) // Samsung NX1000, NX200, NX20, NX210
 		{
 			order = 0x4949;
 			height = 3694;
 			top_margin = 2;
 			width = 5574 - (left_margin = 32 + tiff_bps);
 			if (tiff_bps == 12)
 				load_flags = 80;
 		}
 		else if (raw_width == 5664) // Samsung "NX mini"
 		{
 			height -= top_margin = 17;
 			left_margin = 96;
 			width = 5544;
 			filters = 0x49494949;
 		}
 		else if (raw_width == 6496) // Samsung NX1, NX500
 		{
 			filters = 0x61616161;
 			if (!black && !cblack[0] && !cblack[1] && !cblack[2] && !cblack[3])
 				black = 1 << (tiff_bps - 7);
 		}
 		else if (!strcmp(normalized_model, "EX1")) // Samsung EX1; raw_width: 3688
 		{
 			order = 0x4949;
 			height -= 20;
 			top_margin = 2;
 			if ((width -= 6) > 3682)
 			{
 				height -= 10;
 				width -= 46;
 				top_margin = 8;
 			}
 		}
 		else if (!strcmp(normalized_model, "WB2000")) // Samsung WB2000; raw_width: 3728
 		{
 			order = 0x4949;
 			height -= 3;
 			top_margin = 2;
 			if ((width -= 10) > 3718)
 			{
 				height -= 28;
 				width -= 56;
 				top_margin = 8;
 			}
 		}
 		else if (!strcmp(model, "WB550")) // Samsung WB550; raw_width: 4000
 		{
 			order = 0x4949;
 		}
 		else if (!strcmp(model, "EX2F")) // Samsung EX2F; raw_width: 4176
 		{
 			height = 3030;
 			width = 4040;
 			top_margin = 15;
 			left_margin = 24;
 			order = 0x4949;
 			filters = 0x49494949;
 			load_raw = &LibRaw::unpacked_load_raw;
 		}
 	}
 
 	else if (makeIs(LIBRAW_CAMERAMAKER_ST_Micro) && !strcmp(model, "STV680 VGA"))
 	{
 		black = 16;
 	}
 	else if (!strcmp(model, "N95"))
 	{
 		height = raw_height - (top_margin = 2);
 	}
 	else if (!strcmp(model, "640x480"))
 	{
 		gamma_curve(0.45, 4.5, 1, 255);
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Hasselblad))
 	{
 		if (load_raw == &LibRaw::lossless_jpeg_load_raw)
 			load_raw = &LibRaw::hasselblad_load_raw;
 
 		if ((imHassy.SensorCode == 4) && !strncmp(model, "V96C", 4)) { // Hasselblad V96C
 			strcpy(model, "V96C");
 			strcpy(normalized_model, model);
 			height -= (top_margin = 6);
 			width -= (left_margin = 3) + 7;
 			filters = 0x61616161;
 
 		}
 		else if ((imHassy.SensorCode == 9) && imHassy.uncropped) { // various Hasselblad '-39'
 			height = 5444;
 			width = 7248;
 			top_margin = 4;
 			left_margin = 7;
 			filters = 0x61616161;
 
 		}
 		else if ((imHassy.SensorCode == 13) && imHassy.uncropped) { // Hasselblad H4D-40, H5D-40
 			height -= 84;
 			width -= 82;
 			top_margin = 4;
 			left_margin = 41;
 			filters = 0x61616161;
 
 		}
 		else if ((imHassy.SensorCode == 11) && imHassy.uncropped) { // Hasselblad H5D-50
 			height -= 84;
 			width -= 82;
 			top_margin = 4;
 			left_margin = 41;
 			filters = 0x61616161;
 
 		}
 		else if ((imHassy.SensorCode == 15) &&
 			!imHassy.SensorSubCode && // Hasselblad H5D-50c
 			imHassy.uncropped) {
 			left_margin = 52;
 			top_margin = 100;
 			width = 8272;
 			height = 6200;
 			black = 256;
 
 		}
 		else if ((imHassy.SensorCode == 15) &&
 			(imHassy.SensorSubCode == 2) && // various Hasselblad X1D cameras
 			imHassy.uncropped) {
 			top_margin = 96;
 			height -= 96;
 			left_margin = 48;
 			width -= 106;
 			maximum = 0xffff;
 			tiff_bps = 16;
 
 		}
 		else if ((imHassy.SensorCode == 12) && imHassy.uncropped) { // Hasselblad H4D-60
 			if (black > 500) { // (imHassy.format == LIBRAW_HF_FFF)
 				top_margin = 12;
 				left_margin = 44;
 				width = 8956;
 				height = 6708;
 				memset(cblack, 0, sizeof(cblack));
 				black = 512;
 			}
 			else { // (imHassy.format == LIBRAW_HF_3FR)
 				top_margin = 8;
 				left_margin = 40;
 				width = 8964;
 				height = 6716;
 				black += load_flags = 256;
 				maximum = 0x8101;
 			}
 
 		}
 		else if ((imHassy.SensorCode == 17) && imHassy.uncropped) { // Hasselblad H6D-100c, A6D-100c
 			left_margin = 64;
 			width = 11608;
 			top_margin = 108;
 			height = raw_height - top_margin;
 		}
 
 		if (tiff_samples > 1)
 		{
 			is_raw = tiff_samples + 1;
 			if (!shot_select && !half_size)
 				filters = 0;
 		}
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Sinar))
 	{
 		if (!load_raw)
 			load_raw = &LibRaw::unpacked_load_raw;
 		if (is_raw > 1 && !shot_select)
 			filters = 0;
 		maximum = 0x3fff;
 	}
 
 	if (load_raw == &LibRaw::sinar_4shot_load_raw)
 	{
 		if (is_raw > 1 && !shot_select)
 			filters = 0;
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Leaf))
 	{
 		maximum = 0x3fff;
 		fseek(ifp, data_offset, SEEK_SET);
 		if (ljpeg_start(&jh, 1) && jh.bits == 15)
 			maximum = 0x1fff;
 		if (tiff_samples > 1)
 			filters = 0;
 		if (tiff_samples > 1 || tile_length < raw_height)
 		{
 			load_raw = &LibRaw::leaf_hdr_load_raw;
 			raw_width = tile_width;
 		}
 		if ((width | height) == 2048)
 		{
 			if (tiff_samples == 1)
 			{
 				filters = 1;
 				strcpy(cdesc, "RBTG");
 				strcpy(model, "CatchLight");
 				strcpy(normalized_model, model);
 				top_margin = 8;
 				left_margin = 18;
 				height = 2032;
 				width = 2016;
 			}
 			else
 			{
 				strcpy(model, "DCB2");
 				strcpy(normalized_model, model);
 				top_margin = 10;
 				left_margin = 16;
 				height = 2028;
 				width = 2022;
 			}
 		}
 		else if (width + height == 3144 + 2060)
 		{
 			if (!model[0])
 			{
 				strcpy(model, "Cantare");
 				strcpy(normalized_model, model);
 			}
 			if (width > height)
 			{
 				top_margin = 6;
 				left_margin = 32;
 				height = 2048;
 				width = 3072;
 				filters = 0x61616161;
 			}
 			else
 			{
 				left_margin = 6;
 				top_margin = 32;
 				width = 2048;
 				height = 3072;
 				filters = 0x16161616;
 			}
 			if (!cam_mul[0] || model[0] == 'V')
 				filters = 0;
 			else
 				is_raw = tiff_samples;
 		}
 		else if (width == 2116) // Leaf "Valeo 6"
 		{
 			strcpy(model, "Valeo 6");
 			strcpy(normalized_model, model);
 			height -= 2 * (top_margin = 30);
 			width -= 2 * (left_margin = 55);
 			filters = 0x49494949;
 		}
 		else if (width == 3171) // Leaf "Valeo 6"
 		{
 			strcpy(model, "Valeo 6");
 			strcpy(normalized_model, model);
 			height -= 2 * (top_margin = 24);
 			width -= 2 * (left_margin = 24);
 			filters = 0x16161616;
 		}
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Panasonic))
 	{
 		if (raw_width > 0 &&
 			((flen - data_offset) / (raw_width * 8 / 7) == raw_height))
 			load_raw = &LibRaw::panasonic_load_raw;
 		if (!load_raw)
 		{
 			load_raw = &LibRaw::unpacked_load_raw;
 			load_flags = 4;
 		}
 		zero_is_bad = 1;
 		if ((height += 12) > raw_height)
 			height = raw_height;
 		for (i = 0; i < int(sizeof pana / sizeof *pana); i++)
 			if (raw_width == pana[i][0] && raw_height == pana[i][1])
 			{
 				left_margin = pana[i][2];
 				top_margin = pana[i][3];
 				width += pana[i][4];
 				height += pana[i][5];
 			}
 		if (!tiff_bps && pana_bpp >= 12 && pana_bpp <= 14)
 			tiff_bps = pana_bpp;
 
         if (!strcmp(model, "DC-LX100M2") && raw_height == 3568 && raw_width == 4816 && filters == 3)
             filters = 4;
 
 		filters = 0x01010101U *
 			(uchar) "\x94\x61\x49\x16"[((filters - 1) ^ (left_margin & 1) ^
 			(top_margin << 1)) &
 			3];
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Contax) &&
 		!strcmp(model, "N Digital")) {
 		height = 2047;
 		width = 3072;
 		filters = 0x61616161;
 		data_offset = 0x1a00;
 		load_raw = &LibRaw::packed_load_raw;
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Sony)) {
 		if (!strcmp(model, "DSC-F828")) { // Sony DSC-F828
 			width = 3288;
 			left_margin = 5;
 			mask[1][3] = -17;
 			data_offset = 862144;
 			load_raw = &LibRaw::sony_load_raw;
 			filters = 0x9c9c9c9c;
 			colors = 4;
 			strcpy(cdesc, "RGBE");
 
 		}
 		else if (!strcmp(model, "DSC-V3")) { // Sony DSC-V3
 			width = 3109;
 			left_margin = 59;
 			mask[0][1] = 9;
 			data_offset = 787392;
 			load_raw = &LibRaw::sony_load_raw;
 
 		}
 		else if (raw_width == 3984) { // Sony DSC-R1;
 			width = 3925;
 			order = 0x4d4d;
 
 		}
 		else if (raw_width == 4288) { // Sony ILCE-7S, ILCE-7SM2, ILCE-7SM3, DSLR-A700, DSLR-A500;
 			width -= 32;
 		}
 		else if (raw_width == 4600) { // Sony DSLR-A290, DSLR-A350, DSLR-A380;
 			if (!strcmp(model, "DSLR-A350"))
 				height -= 4;
 			black = 0;
 
 		}
 		else if (raw_width == 4928) {
 			// Sony DSLR-A580, NEX-C3, SLT-A35, DSC-HX99, SLT-A55,
 			// NEX-5N, SLT-A37, SLT-A57, NEX-F3, NEX-6, NEX-5R, NEX-3N, NEX-5T;
 			if (height < 3280)
 				width -= 8;
 
 		}
 		else if (raw_width == 5504) {
 			// Sony ILCE-3000, SLT-A58, DSC-RX100M3, ILCE-QX1,
 			// DSC-RX10M4, DSC-RX100M6, DSC-RX100, DSC-RX100M2, DSC-RX10,
 			// ILCE-5000, DSC-RX100M4, DSC-RX10M2, DSC-RX10M3,
 			// DSC-RX100M5, DSC-RX100M5A;
 			width -= height > 3664 ? 8 : 32;
 
 		}
 		else if (raw_width == 6048) {
 			// Sony SLT-A65, DSC-RX1, SLT-A77, DSC-RX1, ILCA-77M2,
 			// ILCE-7M3, NEX-7, SLT-A99, ILCE-7, DSC-RX1R, ILCE-6000,
 			// ILCE-5100, ILCE-7M2, ILCA-68, ILCE-6300, ILCE-9,
 			// ILCE-6500, ILCE-6400;
 			width -= 24;
 			if (strstr(normalized_model, "RX1") ||
 				strstr(normalized_model, "A99"))
 				width -= 6;
 
 		}
 		else if (raw_width == 7392) { // Sony ILCE-7R;
 			width -= 30;
 
 		}
 		else if (raw_width == 8000) {
 			// Sony ILCE-7RM2, ILCE-7RM2, ILCE-7RM3, DSC-RX1RM2, ILCA-99M2;
 			width -= 32;
 
 		}
 		else if (raw_width == 9600) { // Sony ILCE-7RM4
 			width -= 32;
 
 		}
+        else if(unique_id == SonyID_ILCE_1)
+        {
+          if (raw_width == 8704 && raw_height == 6144) // ILCE-1 FF@Compressed
+          {
+            width = 8660;
+            height = 5784;
+          }
+          else if (raw_width == 8672) // FF uncompressed/lossy
+          {
+            width -= 12;
+          }
+          else if (raw_width == 6144 && raw_height == 4096) // APSC/Lossless
+          {
+            width = 5636;
+            height = 3768;
+          }
+          else if (raw_width == 5664) // APS-C/Uncompressed or lossy
+          {
+              width -= 28;
+          }
+        }
 		else if (!strcmp(model, "DSLR-A100")) {
 			if (width == 3880) {
 				height--;
 				width = ++raw_width;
 			}
 			else {
 				height -= 4;
 				width -= 4;
 				order = 0x4d4d;
 				load_flags = 2;
 			}
 			filters = 0x61616161;
 		}
 	}
 
 	else if (!strcmp(model, "PIXL")) {
 		height -= top_margin = 4;
 		width -= left_margin = 32;
 		gamma_curve(0, 7, 1, 255);
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Kodak)) {
 
 		if (!strncasecmp(model, "EasyShare", 9)) {
 			data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000;
 			load_raw = &LibRaw::packed_load_raw;
 
 		}
 		else if (!strcmp(model, "C603") ||
 			!strcmp(model, "C330") ||
 			!strcmp(model, "12MP")) {
 			order = 0x4949;
 			if (filters && data_offset) {
 				fseek(ifp, data_offset < 4096 ? 168 : 5252, SEEK_SET);
 				read_shorts(curve, 256);
 			}
 			else
 				gamma_curve(0, 3.875, 1, 255);
 
 			load_raw = filters ? &LibRaw::eight_bit_load_raw
 				: strcmp(model, "C330") ? &LibRaw::kodak_c603_load_raw
 				: &LibRaw::kodak_c330_load_raw;
 			load_flags = tiff_bps > 16;
 			tiff_bps = 8;
 
 		}
 		else {
 			if (!strncmp(model, "NC2000", 6) ||
 				!strncmp(model, "EOSDCS", 6) ||
 				!strncmp(model, "DCS4", 4)) {
 				width -= 4;
 				left_margin = 2;
 
 			}
 			else if (!strcmp(model, "DCS660M")) {
 				black = 214;
 
 			}
 			else if (!strcmp(model, "EOS D2000C")) {
 				filters = 0x61616161;
 				if (!black) black = curve[200];
 			}
 
 			if (filters == UINT_MAX) filters = 0x61616161;
 
 			if (!strcmp(model + 4, "20X"))
 				strcpy(cdesc, "MYCY");
 			if (!strcmp(model, "DC25")) {
 				data_offset = 15424;
 			}
 
 			if (!strncmp(model, "DC2", 3)) {
 				raw_height = 2 + (height = 242);
 				if (!strncmp(model, "DC290", 5))
 					iso_speed = 100;
 				if (!strncmp(model, "DC280", 5))
 					iso_speed = 70;
 				if (flen < 100000) {
 					raw_width = 256;
 					width = 249;
 					pixel_aspect = (4.0 * height) / (3.0 * width);
 				}
 				else {
 					raw_width = 512;
 					width = 501;
 					pixel_aspect = (493.0 * height) / (373.0 * width);
 				}
 				top_margin = left_margin = 1;
 				colors = 4;
 				filters = 0x8d8d8d8d;
 				simple_coeff(1);
 				pre_mul[1] = 1.179;
 				pre_mul[2] = 1.209;
 				pre_mul[3] = 1.036;
 				load_raw = &LibRaw::eight_bit_load_raw;
 			}
 			else if (!strcmp(model, "DC40")) {
 				height = 512;
 				width = 768;
 				data_offset = 1152;
 				load_raw = &LibRaw::kodak_radc_load_raw;
 				tiff_bps = 12;
 				FORC4 cam_mul[c] = 1.0f;
 
 			}
 			else if (!strcmp(model, "DC50")) {
 				height = 512;
 				width = 768;
 				iso_speed = 84;
 				data_offset = 19712;
 				load_raw = &LibRaw::kodak_radc_load_raw;
 				FORC4 cam_mul[c] = 1.0f;
 
 			}
 			else if (!strcmp(model, "DC120")) {
 				raw_height = height = 976;
 				raw_width = width = 848;
 				iso_speed = 160;
 				pixel_aspect = height / 0.75 / width;
 				load_raw = tiff_compress == 7 ? &LibRaw::kodak_jpeg_load_raw
 					: &LibRaw::kodak_dc120_load_raw;
 
 			}
 			else if (!strcmp(model, "DCS200")) {
 				thumb_height = 128;
 				thumb_width = 192;
 				thumb_offset = 6144;
 				thumb_misc = 360;
 				iso_speed = 140;
 				write_thumb = &LibRaw::layer_thumb;
 				black = 17;
 			}
 		}
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Logitech) &&
 		!strcmp(model, "Fotoman Pixtura")) {
 		height = 512;
 		width = 768;
 		data_offset = 3632;
 		load_raw = &LibRaw::kodak_radc_load_raw;
 		filters = 0x61616161;
 		simple_coeff(2);
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Apple) &&
 		!strncmp(model, "QuickTake", 9)) {
 		if (head[5]) {
 			strcpy(model + 10, "200");
 			strcpy(normalized_model, model);
 		}
 		fseek(ifp, 544, SEEK_SET);
 		height = get2();
 		width = get2();
 		data_offset = (get4(), get2()) == 30 ? 738 : 736;
 		if (height > width) {
 			SWAP(height, width);
 			fseek(ifp, data_offset - 6, SEEK_SET);
 			flip = ~get2() & 3 ? 5 : 6;
 		}
 		filters = 0x61616161;
 
 	}
 	else if (makeIs(LIBRAW_CAMERAMAKER_Rollei) &&
 		!load_raw) {
 		switch (raw_width) {
 		case 1316: // Rollei d530flex
 			height = 1030;
 			width = 1300;
 			top_margin = 1;
 			left_margin = 6;
 			break;
 		case 2568:
 			height = 1960;
 			width = 2560;
 			top_margin = 2;
 			left_margin = 8;
 		}
 		filters = 0x16161616;
 		load_raw = &LibRaw::rollei_load_raw;
 
 	}
 	else if (!strcmp(model, "GRAS-50S5C")) {
 		height = 2048;
 		width = 2440;
 		load_raw = &LibRaw::unpacked_load_raw;
 		data_offset = 0;
 		filters = 0x49494949;
 		order = 0x4949;
 		maximum = 0xfffC;
 
 	}
 	else if (!strcmp(model, "BB-500CL")) {
 		height = 2058;
 		width = 2448;
 		load_raw = &LibRaw::unpacked_load_raw;
 		data_offset = 0;
 		filters = 0x94949494;
 		order = 0x4949;
 		maximum = 0x3fff;
 
 	}
 	else if (!strcmp(model, "BB-500GE")) {
 		height = 2058;
 		width = 2456;
 		load_raw = &LibRaw::unpacked_load_raw;
 		data_offset = 0;
 		filters = 0x94949494;
 		order = 0x4949;
 		maximum = 0x3fff;
 
 	}
 	else if (!strcmp(model, "SVS625CL")) {
 		height = 2050;
 		width = 2448;
 		load_raw = &LibRaw::unpacked_load_raw;
 		data_offset = 0;
 		filters = 0x94949494;
 		order = 0x4949;
 		maximum = 0x0fff;
 	}
 }
diff --git a/src/metadata/kodak.cpp b/src/metadata/kodak.cpp
index fec43ff0..1193eac3 100644
--- a/src/metadata/kodak.cpp
+++ b/src/metadata/kodak.cpp
@@ -72,292 +72,292 @@ short LibRaw::KodakIllumMatrix(unsigned type, float *romm_camIllum)
 /* Thanks to Alexey Danilchenko for wb as-shot parsing code */
 void LibRaw::parse_kodak_ifd(int base)
 {
   unsigned entries, tag, type, len, save;
   int c, wbi = -1;
 
   static const int wbtag_kdc[] = {
       LIBRAW_WBI_Auto,        // 64037 / 0xfa25
       LIBRAW_WBI_Fluorescent, // 64040 / 0xfa28
       LIBRAW_WBI_Tungsten,    // 64039 / 0xfa27
       LIBRAW_WBI_Daylight,    // 64041 / 0xfa29
       -1,
       -1,
       LIBRAW_WBI_Shade // 64042 / 0xfa2a
   };
 
   static const int wbtag_dcr[] = {
       LIBRAW_WBI_Daylight,    // 2120 / 0x0848
       LIBRAW_WBI_Tungsten,    // 2121 / 0x0849
       LIBRAW_WBI_Fluorescent, // 2122 / 0x084a
       LIBRAW_WBI_Flash,       // 2123 / 0x084b
       LIBRAW_WBI_Custom,      // 2124 / 0x084c
       LIBRAW_WBI_Auto         // 2125 / 0x084d
   };
 
   //  int a_blck = 0;
 
   entries = get2();
   if (entries > 1024)
     return;
   INT64 fsize = ifp->size();
   while (entries--)
   {
     tiff_get(base, &tag, &type, &len, &save);
     INT64 savepos = ftell(ifp);
     if (len > 8 && len + savepos > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     if (callbacks.exif_cb)
     {
       callbacks.exif_cb(callbacks.exifparser_data, tag | 0x20000, type, len,
                         order, ifp, base);
       fseek(ifp, savepos, SEEK_SET);
     }
     if (tag == 0x03eb) // 1003
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     else if (tag == 0x03ec) // 1004
-      imgdata.sizes.raw_inset_crop.ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
     else if (tag == 0x03ed) // 1005
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     else if (tag == 0x03ee) // 1006
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     else if (tag == 0x03ef) // 1007
     {
       if (!strcmp(model, "EOS D2000C"))
         black = get2();
       else
         imKodak.BlackLevelTop = get2();
     }
     else if (tag == 0x03f0) // 1008
     {
       if (!strcmp(model, "EOS D2000C"))
       {
         if (black) // already set by tag 1007 (0x03ef)
           black = (black + get2()) / 2;
         else
           black = get2();
       }
       else
         imKodak.BlackLevelBottom = get2();
     }
 
     else if (tag == 0x03f1)
     { // 1009 Kodak TextualInfo
       if (len > 0)
       {
         char kti[1024];
         char *pkti;
         int nsym = MIN(len, 1023);
         fread(kti, 1, nsym, ifp);
         kti[nsym] = 0;
 #ifdef LIBRAW_WIN32_CALLS
         pkti = strtok(kti, "\x0a");
 #else
         char *last = 0;
         pkti = strtok_r(kti, "\x0a", &last);
 #endif
         while (pkti != NULL)
         {
           c = 12;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Camera body:", c)))
           {
             while ((pkti[c] == ' ') && (c < (int)strlen(pkti)))
             {
               c++;
             }
             strcpy(ilm.body, pkti + c);
           }
           c = 5;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Lens:", c)))
           {
             ilm.CurFocal = atoi(pkti + c);
           }
           c = 9;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Aperture:", c)))
           {
             while (((pkti[c] == ' ') || (pkti[c] == 'f')) && (c < (int)strlen(pkti)))
             {
               c++;
             }
             ilm.CurAp = atof(pkti + c);
           }
           c = 10;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "ISO Speed:", c)))
           {
             iso_speed = atoi(pkti + c);
           }
           c = 13;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Focal Length:", c)))
           {
             ilm.CurFocal = atoi(pkti + c);
           }
           c = 13;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Max Aperture:", c)))
           {
             while (((pkti[c] == ' ') || (pkti[c] == 'f')) && (c < (int)strlen(pkti)))
             {
               c++;
             }
             ilm.MaxAp4CurFocal = atof(pkti + c);
           }
           c = 13;
           if (((int)strlen(pkti) > c) && (!strncasecmp(pkti, "Min Aperture:", c)))
           {
             while (((pkti[c] == ' ') || (pkti[c] == 'f')) && (c < (int)strlen(pkti)))
             {
               c++;
             }
             ilm.MinAp4CurFocal = atof(pkti + c);
           }
 #ifdef LIBRAW_WIN32_CALLS
           pkti = strtok(NULL, "\x0a");
 #else
           pkti = strtok_r(NULL, "\x0a", &last);
 #endif
         }
       }
     }
 
     else if (tag == 0x03f3) // 1011
       imCommon.FlashEC = getreal(type);
 
     else if (tag == 0x03fc) // 1020
     {
       wbi = getint(type);
       if ((wbi >= 0) && (wbi < 6) && (wbi != -2))
         wbi = wbtag_dcr[wbi];
     }
     else if (tag == 0x03fd && len == 72) // 1021
     {                                    /* WB set in software */
       fseek(ifp, 40, SEEK_CUR);
       FORC3 cam_mul[c] = 2048.0 / fMAX(1.0f, get2());
       wbi = -2;
     }
 
     else if ((tag == 0x0406) && (len == 1)) // 1030
       imCommon.CameraTemperature = getreal(type);
     else if ((tag == 0x0413) && (len == 1)) // 1043
       imCommon.SensorTemperature = getreal(type);
     else if (tag == 0x0848) // 2120
       Kodak_DCR_WBtags(LIBRAW_WBI_Daylight, type, wbi);
     else if (tag == 0x0849) // 2121
       Kodak_DCR_WBtags(LIBRAW_WBI_Tungsten, type, wbi);
     else if (tag == 0x084a) // 2122
       Kodak_DCR_WBtags(LIBRAW_WBI_Fluorescent, type, wbi);
     else if (tag == 0x084b) // 2123
       Kodak_DCR_WBtags(LIBRAW_WBI_Flash, type, wbi);
     else if (tag == 0x084c) // 2124
       Kodak_DCR_WBtags(LIBRAW_WBI_Custom, type, wbi);
     else if (tag == 0x084d) // 2125
     {
       if (wbi == -1)
         wbi = LIBRAW_WBI_Auto;
       Kodak_DCR_WBtags(LIBRAW_WBI_Auto, type, wbi);
     }
     else if (tag == 0x089f) // 2207
       imKodak.ISOCalibrationGain = getreal(type);
     else if (tag == 0x0903) // 2307
       imKodak.AnalogISO = iso_speed = getreal(type);
     else if (tag == 0x090d) // 2317
       linear_table(len);
     else if (tag == 0x09ce) // 2510
       stmread(imgdata.shootinginfo.InternalBodySerial, len, ifp);
     else if (tag == 0x0e92) // 3730
     {
       imKodak.val018percent = get2();
       imgdata.color.linear_max[0] = imgdata.color.linear_max[1] =
           imgdata.color.linear_max[2] = imgdata.color.linear_max[3] =
               (int)(((float)imKodak.val018percent) / 18.0f * 170.0f);
     }
     else if (tag == 0x0e93) // 3731
       imgdata.color.linear_max[0] = imgdata.color.linear_max[1] =
           imgdata.color.linear_max[2] = imgdata.color.linear_max[3] =
               imKodak.val170percent = get2();
     else if (tag == 0x0e94) // 3732
       imKodak.val100percent = get2();
     /*
         else if (tag == 0x1784)    // 6020
           iso_speed = getint(type);
     */
     else if (tag == 0xfa00) // 64000
       stmread(imgdata.shootinginfo.BodySerial, len, ifp);
     else if (tag == 0xfa0d) // 64013
     {
       wbi = fgetc(ifp);
       if ((wbi >= 0) && (wbi < 7))
         wbi = wbtag_kdc[wbi];
     }
     else if (tag == 0xfa13) // 64019
       width = getint(type);
     else if (tag == 0xfa14) // 64020
       height = (getint(type) + 1) & -2;
     /*
           height = getint(type);
 
         else if (tag == 0xfa16)  // 64022
           raw_width = get2();
         else if (tag == 0xfa17)  // 64023
           raw_height = get2();
     */
     else if (tag == 0xfa18) // 64024
     {
       imKodak.offset_left = getint(LIBRAW_EXIFTAG_TYPE_SSHORT);
       if (type != LIBRAW_EXIFTAG_TYPE_SSHORT)
         imKodak.offset_left += 1;
     }
     else if (tag == 0xfa19) // 64025
     {
       imKodak.offset_top = getint(LIBRAW_EXIFTAG_TYPE_SSHORT);
       if (type != LIBRAW_EXIFTAG_TYPE_SSHORT)
         imKodak.offset_top += 1;
     }
 
     else if (tag == 0xfa25) // 64037
       Kodak_KDC_WBtags(LIBRAW_WBI_Auto, wbi);
     else if (tag == 0xfa27) // 64039
       Kodak_KDC_WBtags(LIBRAW_WBI_Tungsten, wbi);
     else if (tag == 0xfa28) // 64040
       Kodak_KDC_WBtags(LIBRAW_WBI_Fluorescent, wbi);
     else if (tag == 0xfa29) // 64041
       Kodak_KDC_WBtags(LIBRAW_WBI_Daylight, wbi);
     else if (tag == 0xfa2a) // 64042
       Kodak_KDC_WBtags(LIBRAW_WBI_Shade, wbi);
 
     else if (tag == 0xfa31) // 64049
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     else if (tag == 0xfa32) // 64050
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     else if (tag == 0xfa3e) // 64062
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     else if (tag == 0xfa3f) // 64063
-      imgdata.sizes.raw_inset_crop.ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
 
     else if (((tag == 0x07e4) || (tag == 0xfb01)) &&
              (len == 9)) // 2020 or 64257
     {
       if (KodakIllumMatrix(type, (float *)imKodak.romm_camDaylight))
       {
         romm_coeff(imKodak.romm_camDaylight);
       }
     }
     else if (((tag == 0x07e5) || (tag == 0xfb02)) &&
              (len == 9)) // 2021 or 64258
       KodakIllumMatrix(type, (float *)imKodak.romm_camTungsten);
     else if (((tag == 0x07e6) || (tag == 0xfb03)) &&
              (len == 9)) // 2022 or 64259
       KodakIllumMatrix(type, (float *)imKodak.romm_camFluorescent);
     else if (((tag == 0x07e7) || (tag == 0xfb04)) &&
              (len == 9)) // 2023 or 64260
       KodakIllumMatrix(type, (float *)imKodak.romm_camFlash);
     else if (((tag == 0x07e8) || (tag == 0xfb05)) &&
              (len == 9)) // 2024 or 64261
       KodakIllumMatrix(type, (float *)imKodak.romm_camCustom);
     else if (((tag == 0x07e9) || (tag == 0xfb06)) &&
              (len == 9)) // 2025 or 64262
       KodakIllumMatrix(type, (float *)imKodak.romm_camAuto);
 
     fseek(ifp, save, SEEK_SET);
   }
 }
diff --git a/src/metadata/makernotes.cpp b/src/metadata/makernotes.cpp
index db21cd88..f4bb2cc7 100644
--- a/src/metadata/makernotes.cpp
+++ b/src/metadata/makernotes.cpp
@@ -60,272 +60,273 @@ unsigned wb_table1 [] = {
 void LibRaw::parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)
 {
 
   if (metadata_blocks++ > LIBRAW_MAX_METADATA_BLOCKS)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
   if (!strncmp(make, "NIKON", 5))
   {
     parseNikonMakernote(base, uptag, AdobeDNG);
     return;
   }
   else if (!strncasecmp(make, "LEICA", 5))
   {
     parseLeicaMakernote(base, uptag, is_0xc634);
     return;
   }
 
   short morder, sorder = order;
   char buf[10];
   INT64 fsize = ifp->size();
 
   fread(buf, 1, 10, ifp);
 
   if (!strcmp(buf, "EPSON"))
   {
     parseEpsonMakernote(base, uptag, AdobeDNG);
     return;
   }
   else if (!strcmp(buf, "SIGMA"))
   {
     parseSigmaMakernote(base, uptag, AdobeDNG);
     return;
   }
 
   unsigned entries, tag, type, len, save, c;
 
   uchar *CanonCameraInfo;
   unsigned lenCanonCameraInfo = 0;
   unsigned typeCanonCameraInfo = 0;
 
   uchar *table_buf_0x0116;
   ushort table_buf_0x0116_len = 0;
   uchar *table_buf_0x2010;
   ushort table_buf_0x2010_len = 0;
   uchar *table_buf_0x9050;
   ushort table_buf_0x9050_len = 0;
   uchar *table_buf_0x9400;
   ushort table_buf_0x9400_len = 0;
   uchar *table_buf_0x9402;
   ushort table_buf_0x9402_len = 0;
   uchar *table_buf_0x9403;
   ushort table_buf_0x9403_len = 0;
   uchar *table_buf_0x9406;
   ushort table_buf_0x9406_len = 0;
   uchar *table_buf_0x940c;
   ushort table_buf_0x940c_len = 0;
   uchar *table_buf_0x940e;
   ushort table_buf_0x940e_len = 0;
 
   if (!strcmp(buf, "OLYMPUS") || !strcmp(buf, "PENTAX ") ||
       (!strncmp(make, "SAMSUNG", 7) && (dng_writer == CameraDNG)))
   {
     base = ftell(ifp) - 10;
     fseek(ifp, -2, SEEK_CUR);
     order = get2();
     if (buf[0] == 'O')
       get2();
+    else if (buf[0] == 'P')
+      is_PentaxRicohMakernotes = 1;
   }
   else if (is_PentaxRicohMakernotes && (dng_writer == CameraDNG))
   {
     base = ftell(ifp) - 10;
     fseek(ifp, -4, SEEK_CUR);
     order = get2();
-    is_PentaxRicohMakernotes = 1;
   }
   else if (!strncmp(buf, "SONY", 4) ||
            !strcmp(buf, "Panasonic"))
   {
     order = 0x4949;
     fseek(ifp, 2, SEEK_CUR);
   }
   else if (!strncmp(buf, "FUJIFILM", 8))
   {
     base = ftell(ifp) - 10;
     order = 0x4949;
     fseek(ifp, 2, SEEK_CUR);
   }
   else if (!strcmp(buf, "OLYMP") ||
            !strcmp(buf, "Ricoh"))
   {
     fseek(ifp, -2, SEEK_CUR);
   }
   else if (!strcmp(buf, "AOC") || !strcmp(buf, "QVC"))
   {
     fseek(ifp, -4, SEEK_CUR);
   }
   else
   {
     fseek(ifp, -10, SEEK_CUR);
     if ((!strncmp(make, "SAMSUNG", 7) && (dng_writer == AdobeDNG)))
       base = ftell(ifp);
   }
 
   entries = get2();
   if (entries > 1000)
     return;
 
   if (!strncasecmp(make, "SONY", 4) ||
       !strncasecmp(make, "Konica", 6) ||
       !strncasecmp(make, "Minolta", 7) ||
       (!strncasecmp(make, "Hasselblad", 10) &&
        (!strncasecmp(model, "Stellar", 7) ||
         !strncasecmp(model, "Lunar", 5) ||
         !strncasecmp(model, "Lusso", 5) ||
         !strncasecmp(model, "HV", 2))))
     is_Sony = 1;
 
   if (!is_Olympus &&
       (!strncmp(make, "OLYMPUS", 7) ||
       (!strncasecmp(make, "CLAUSS", 6) && !strncasecmp(model, "piX 5oo", 7)))) {
     is_Olympus = 1;
     OlympusDNG_SubDirOffsetValid =
           strncmp(model, "E-300", 5) && strncmp(model, "E-330", 5) &&
           strncmp(model, "E-400", 5) && strncmp(model, "E-500", 5) &&
           strncmp(model, "E-1", 3);
   }
 
   morder = order;
   while (entries--)
   {
     order = morder;
 
     tiff_get(base, &tag, &type, &len, &save);
 
     INT64 pos = ifp->tell();
     if (len > 8 && pos + len > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     tag |= uptag << 16;
     if (len > 100 * 1024 * 1024)
       goto next; // 100Mb tag? No!
 
     if (!strncmp(make, "Canon", 5))
     {
       if (tag == 0x000d && len < 256000)
       { // camera info
         if (!tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         {
           CanonCameraInfo = (uchar *)malloc(MAX(16, len));
           fread(CanonCameraInfo, len, 1, ifp);
         }
         else
         {
           CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));
           fread(CanonCameraInfo, len, 4, ifp);
         }
         lenCanonCameraInfo = len;
         typeCanonCameraInfo = type;
       }
 
       else if (tag == 0x0010) // Canon ModelID
       {
         unique_id = get4();
         setCanonBodyFeatures(unique_id);
         if (lenCanonCameraInfo)
         {
           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo,
                                  typeCanonCameraInfo, AdobeDNG);
           free(CanonCameraInfo);
           CanonCameraInfo = 0;
           lenCanonCameraInfo = 0;
         }
       }
 
       else
         parseCanonMakernotes(tag, type, len, AdobeDNG);
     }
 
     else if (!strncmp(make, "FUJI", 4)) {
       parseFujiMakernotes(tag, type, len, AdobeDNG);
 
     } else if (!strncasecmp(make, "Hasselblad", 10) && !is_Sony) {
       if (tag == 0x0011) {
         imHassy.SensorCode = getint(type);
       } else if ((tag == 0x0015) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII)) {
         stmread (imHassy.SensorUnitConnector, len, ifp);
-        for (int i=0; i<len; i++) {
+        for (int i=0; i<(int)len; i++) {
           if(!isalnum(imHassy.SensorUnitConnector[i]) &&
              (imHassy.SensorUnitConnector[i]!=' ')    &&
              (imHassy.SensorUnitConnector[i]!='/')    &&
              (imHassy.SensorUnitConnector[i]!='-')) {
             imHassy.SensorUnitConnector[0] = 0;
             break;
           }
         }
       } else if (tag == 0x0016) {
         imHassy.CoatingCode = getint(type);
       } else if ((tag == 0x002a) &&
                  tagtypeIs(LIBRAW_EXIFTAG_TYPE_SRATIONAL) &&
                  (len == 12) &&
                  imHassy.SensorUnitConnector[0]) {
         FORC4 for (int i = 0; i < 3; i++)
                 imHassy.mnColorMatrix[c][i] = getreal(type);
 
       } else if ((tag == 0x0031) &&
                  imHassy.SensorUnitConnector[0]) {
         imHassy.RecommendedCrop[0] = getint(type);
         imHassy.RecommendedCrop[1] = getint(type);
       }
 
     } else if (is_Olympus) {
 
       if ((tag == 0x2010) || (tag == 0x2020) || (tag == 0x2030) ||
           (tag == 0x2031) || (tag == 0x2040) || (tag == 0x2050) ||
           (tag == 0x3000))
       {
         fseek(ifp, save - 4, SEEK_SET);
         fseek(ifp, base + get4(), SEEK_SET);
         parse_makernote_0xc634(base, tag, dng_writer);
       }
 
       if (!OlympusDNG_SubDirOffsetValid &&
           ((len > 4) ||
            ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) ||
             tagtypeIs(LIBRAW_EXIFTAG_TYPE_SSHORT)) && (len > 2)) ||
            ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG) ||
              tagtypeIs(LIBRAW_EXIFTAG_TYPE_SLONG)) && (len > 1)) ||
            tagtypeIs(LIBRAW_EXIFTAG_TYPE_RATIONAL) ||
            (type > LIBRAW_EXIFTAG_TYPE_SLONG))) {
         goto skip_Oly_broken_tags;
       }
       else {
         parseOlympusMakernotes(base, tag, type, len, AdobeDNG);
       }
     skip_Oly_broken_tags:;
     }
 
     else if (!strncmp(make, "PENTAX", 6)  ||
              !strncmp(model, "PENTAX", 6) ||
              is_PentaxRicohMakernotes)
     {
       parsePentaxMakernotes(base, tag, type, len, dng_writer);
     }
     else if (!strncmp(make, "SAMSUNG", 7))
     {
       if (dng_writer == AdobeDNG)
         parseSamsungMakernotes(base, tag, type, len, dng_writer);
       else
         parsePentaxMakernotes(base, tag, type, len, dng_writer);
     }
     else if (is_Sony)
     {
       parseSonyMakernotes(
           base, tag, type, len, AdobeDNG,
           table_buf_0x0116, table_buf_0x0116_len,
           table_buf_0x2010, table_buf_0x2010_len,
           table_buf_0x9050, table_buf_0x9050_len,
           table_buf_0x9400, table_buf_0x9400_len,
           table_buf_0x9402, table_buf_0x9402_len,
           table_buf_0x9403, table_buf_0x9403_len,
           table_buf_0x9406, table_buf_0x9406_len,
           table_buf_0x940c, table_buf_0x940c_len,
           table_buf_0x940e, table_buf_0x940e_len);
     }
   next:
     fseek(ifp, save, SEEK_SET);
   }
 
   order = sorder;
 }
@@ -333,445 +334,446 @@ void LibRaw::parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)
 void LibRaw::parse_makernote(int base, int uptag)
 {
 
   if (metadata_blocks++ > LIBRAW_MAX_METADATA_BLOCKS)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
   if (!strncmp(make, "NIKON", 5))
   {
     parseNikonMakernote(base, uptag, nonDNG);
     return;
   }
   else if (!strncasecmp(make, "LEICA", 5))
   {
     parseLeicaMakernote(base, uptag, is_0x927c);
     return;
   }
 
   if (!strncmp(make, "Nokia", 5))
     return;
 
   char buf[10];
   char another_buf[128];
 
   fseek(ifp, -12, SEEK_CUR);
   fread (another_buf, 1, 12, ifp);
   if (!strncmp(another_buf, "SONY", 4) ||
       !strncmp(another_buf, "VHAB", 4)) { // Sony branded as Hasselblad
     is_Sony = 1;
   }
 
   fread(buf, 1, 10, ifp);
 
   if (!strncmp(buf, "KDK", 3)  || /* these aren't TIFF tables */
       !strncmp(buf, "VER", 3)  ||
       !strncmp(buf, "IIII", 4) ||
       !strncmp(buf, "MMMM", 4))
     return;
 
   if (!strcmp(buf, "EPSON"))
   {
     parseEpsonMakernote(base, uptag, nonDNG);
     return;
   }
   else if (!strcmp(buf, "SIGMA"))
   {
     parseSigmaMakernote(base, uptag, CameraDNG);
     return;
   }
 
 
   unsigned entries, tag, type, len, save, c;
   unsigned i, wb[4] = {0, 0, 0, 0};
   short morder, sorder = order;
 
-  uchar *CanonCameraInfo;
+  uchar *CanonCameraInfo = 0;;
   unsigned lenCanonCameraInfo = 0;
   unsigned typeCanonCameraInfo = 0;
   imCanon.wbi = 0;
 
   uchar *table_buf_0x0116;
   ushort table_buf_0x0116_len = 0;
   uchar *table_buf_0x2010;
   ushort table_buf_0x2010_len = 0;
   uchar *table_buf_0x9050;
   ushort table_buf_0x9050_len = 0;
   uchar *table_buf_0x9400;
   ushort table_buf_0x9400_len = 0;
   uchar *table_buf_0x9402;
   ushort table_buf_0x9402_len = 0;
   uchar *table_buf_0x9403;
   ushort table_buf_0x9403_len = 0;
   uchar *table_buf_0x9406;
   ushort table_buf_0x9406_len = 0;
   uchar *table_buf_0x940c;
   ushort table_buf_0x940c_len = 0;
   uchar *table_buf_0x940e;
   ushort table_buf_0x940e_len = 0;
 
   INT64 fsize = ifp->size();
 
   /*
        The MakerNote might have its own TIFF header (possibly with
        its own byte-order!), or it might just be a table.
   */
 
   if (!strncmp(buf, "KC", 2) || /* Konica KD-400Z, KD-510Z */
       !strncmp(buf, "MLY", 3))  /* Minolta DiMAGE G series */
   {
     order = 0x4d4d;
     while ((i = ftell(ifp)) < data_offset && i < 16384)
     {
       wb[0] = wb[2];
       wb[2] = wb[1];
       wb[1] = wb[3];
       wb[3] = get2();
       if (wb[1] == 256 && wb[3] == 256 && wb[0] > 256 && wb[0] < 640 &&
           wb[2] > 256 && wb[2] < 640)
         FORC4 cam_mul[c] = wb[c];
     }
     goto quit;
   }
 
   if (!strcmp(buf, "OLYMPUS") ||
       !strcmp(buf, "PENTAX "))
   {
     base = ftell(ifp) - 10;
     fseek(ifp, -2, SEEK_CUR);
     order = get2();
     if (buf[0] == 'O')
       get2();
   }
   else if (!strncmp(buf, "SONY", 4) || // DSLR-A100
            !strcmp(buf, "Panasonic")) {
     if (buf[0] == 'S')
       is_Sony = 1;
     goto nf;
   }
   else if (!strncmp(buf, "FUJIFILM", 8))
   {
     base = ftell(ifp) - 10;
   nf:
     order = 0x4949;
     fseek(ifp, 2, SEEK_CUR);
   }
   else if (!strcmp (buf, "OLYMP")    ||
            !strncmp(buf, "LEICA", 5) ||
            !strcmp (buf, "Ricoh"))
   {
     fseek(ifp, -2, SEEK_CUR);
   }
   else if (!strcmp(buf, "AOC") || // Pentax, tribute to Asahi Optical Co.
            !strcmp(buf, "QVC"))   // Casio, from "QV-Camera"
   {
     fseek(ifp, -4, SEEK_CUR);
   }
   else if (!strncmp(buf, "CMT3", 4))
   {
     order = sget2((uchar *)(buf + 4));
     fseek(ifp, 2L, SEEK_CUR);
   }
   else if (libraw_internal_data.unpacker_data.CR3_CTMDtag)
   {
     order = sget2((uchar *)buf);
     fseek(ifp, -2L, SEEK_CUR);
   }
   else
   {
     fseek(ifp, -10, SEEK_CUR);
     if (!strncmp(make, "SAMSUNG", 7))
       base = ftell(ifp);
   }
 
   if (!is_Olympus &&
       (!strncasecmp(make, "Olympus", 7) ||
       (!strncasecmp(make, "CLAUSS", 6) && !strncasecmp(model, "piX 5oo", 7)))) {
     is_Olympus = 1;
   }
 
   if (!is_Sony &&
       (!strncasecmp(make, "SONY", 4) ||
        !strncasecmp(make, "Konica", 6) ||
        !strncasecmp(make, "Minolta", 7) ||
        (!strncasecmp(make, "Hasselblad", 10) &&
         (!strncasecmp(model, "Stellar", 7) ||
          !strncasecmp(model, "Lunar", 5) ||
          !strncasecmp(model, "Lusso", 5) ||
          !strncasecmp(model, "HV", 2))))) {
     is_Sony = 1;
   }
 
   if (strcasestr(make, "Kodak") &&
       (sget2((uchar *)buf) > 1) && // check number of entries
       (sget2((uchar *)buf) < 128) &&
       (sget2((uchar *)(buf + 4)) > 0) && // check type
       (sget2((uchar *)(buf + 4)) < 13) &&
       (sget4((uchar *)(buf + 6)) < 256) // check count
   )
     imKodak.MakerNoteKodak8a = 1; // Kodak P712 / P850 / P880
 
   entries = get2();
   if (entries > 1000)
     return;
 
   morder = order;
   while (entries--)
   {
     order = morder;
     tiff_get(base, &tag, &type, &len, &save);
     tag |= uptag << 16;
 
     INT64 _pos = ftell(ifp);
     if (len > 100 * 1024 * 1024)
 	goto next; // 100Mb tag? No!
     if (len > 8 && _pos + len > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     if (imKodak.MakerNoteKodak8a)
     {
       if ((tag == 0xff00) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG) && (len == 1))
       {
         INT64 _pos1 = get4();
         if ((_pos1 < fsize) && (_pos1 > 0))
         {
           fseek(ifp, _pos1, SEEK_SET);
           parse_makernote(base, tag);
         }
       }
       else if (tag == 0xff00f90b)
       {
         imKodak.clipBlack = get2();
       }
       else if (tag == 0xff00f90c)
       {
         imKodak.clipWhite = imgdata.color.linear_max[0] =
             imgdata.color.linear_max[1] = imgdata.color.linear_max[2] =
                 imgdata.color.linear_max[3] = get2();
       }
     }
     else if (!strncmp(make, "Canon", 5))
     {
       if (tag == 0x000d && len < 256000) // camera info
       {
         if (!tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         {
           CanonCameraInfo = (uchar *)malloc(MAX(16, len));
           fread(CanonCameraInfo, len, 1, ifp);
         }
         else
         {
           CanonCameraInfo = (uchar *)malloc(MAX(16, len * 4));
           fread(CanonCameraInfo, len, 4, ifp);
         }
         lenCanonCameraInfo = len;
         typeCanonCameraInfo = type;
       }
 
       else if (tag == 0x0010) // Canon ModelID
       {
         unique_id = get4();
         setCanonBodyFeatures(unique_id);
         if (lenCanonCameraInfo)
         {
           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo,
                                  typeCanonCameraInfo, nonDNG);
-          free(CanonCameraInfo);
+	  if(CanonCameraInfo)
+            free(CanonCameraInfo);
           CanonCameraInfo = 0;
           lenCanonCameraInfo = 0;
         }
       }
 
       else
         parseCanonMakernotes(tag, type, len, nonDNG);
     }
 
     else if (!strncmp(make, "FUJI", 4))
       parseFujiMakernotes(tag, type, len, nonDNG);
 
     else if (!strncasecmp(model, "Hasselblad X1D", 14) ||
              !strncasecmp(model, "Hasselblad H6D", 14) ||
              !strncasecmp(model, "Hasselblad A6D", 14))
     {
       if (tag == 0x0045)
       {
         imHassy.BaseISO = get4();
       }
       else if (tag == 0x0046)
       {
         imHassy.Gain = getreal(type);
       }
     }
 
     else if (!strncmp(make, "PENTAX", 6) ||
              !strncmp(make, "RICOH", 5) ||
              !strncmp(model, "PENTAX", 6))
     {
       if (!strncmp(model, "GR", 2) ||
           !strncmp(model, "GXR", 3))
       {
         parseRicohMakernotes(base, tag, type, len, CameraDNG);
       }
       else
       {
         parsePentaxMakernotes(base, tag, type, len, nonDNG);
       }
     }
 
     else if (!strncmp(make, "SAMSUNG", 7))
     {
       if (!dng_version)
         parseSamsungMakernotes(base, tag, type, len, nonDNG);
       else
         parsePentaxMakernotes(base, tag, type, len, CameraDNG);
     }
 
     else if (is_Sony)
     {
       if ((tag == 0xb028) && (len == 1) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG)) // DSLR-A100
       {
         if ((c = get4()))
         {
           fseek(ifp, c, SEEK_SET);
           parse_makernote(base, tag);
         }
       }
       else
       {
         parseSonyMakernotes(
             base, tag, type, len, nonDNG,
             table_buf_0x0116, table_buf_0x0116_len,
             table_buf_0x2010, table_buf_0x2010_len,
             table_buf_0x9050, table_buf_0x9050_len,
             table_buf_0x9400, table_buf_0x9400_len,
             table_buf_0x9402, table_buf_0x9402_len,
             table_buf_0x9403, table_buf_0x9403_len,
             table_buf_0x9406, table_buf_0x9406_len,
             table_buf_0x940c, table_buf_0x940c_len,
             table_buf_0x940e, table_buf_0x940e_len);
       }
     }
     fseek(ifp, _pos, SEEK_SET);
 
     if (!strncasecmp(make, "Hasselblad", 10) && !is_Sony) {
       if (tag == 0x0011)
         imHassy.SensorCode = getint(type);
       else if (tag == 0x0016)
         imHassy.CoatingCode = getint(type);
       else if ((tag == 0x002a) &&
                tagtypeIs(LIBRAW_EXIFTAG_TYPE_SRATIONAL) &&
                (len == 12)) {
         FORC4 for (int i = 0; i < 3; i++)
                 imHassy.mnColorMatrix[c][i] = getreal(type);
 
       } else if (tag == 0x0031) {
         imHassy.RecommendedCrop[0] = getint(type);
         imHassy.RecommendedCrop[1] = getint(type);
       }
     }
 
     if ((tag == 0x0004 || tag == 0x0114) && !strncmp(make, "KONICA", 6))
     {
       fseek(ifp, tag == 0x0004 ? 140 : 160, SEEK_CUR);
       switch (get2())
       {
       case 72:
         flip = 0;
         break;
       case 76:
         flip = 6;
         break;
       case 82:
         flip = 5;
         break;
       }
     }
 
     if (is_Olympus) {
       INT64 _pos2 = ftell(ifp);
       if ((tag == 0x2010) || (tag == 0x2020) || (tag == 0x2030) ||
           (tag == 0x2031) || (tag == 0x2040) || (tag == 0x2050) ||
           (tag == 0x3000))
       {
         if (tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) {
           parse_makernote(base, tag);
 
         } else if (tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_ifd) ||
                    tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_int32u)) {
           fseek(ifp, base + get4(), SEEK_SET);
           parse_makernote(base, tag);
         }
 
       } else {
         parseOlympusMakernotes(base, tag, type, len, nonDNG);
       }
       fseek(ifp, _pos2, SEEK_SET);
     }
 
     if ((tag == 0x0015) &&
         tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) &&
         is_raw)
     { // Hasselblad
       stmread (imHassy.SensorUnitConnector, len, ifp);
     }
 
     if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
         ((tag == 0x0081) || // Minolta
          (tag == 0x0100)))  // Olympus
     {
       thumb_offset = ftell(ifp);
       thumb_length = len;
     }
     if ((tag == 0x0088) && // Minolta, possibly Olympus too
         tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG) &&
         (thumb_offset = get4()))
       thumb_offset += base;
 
     if ((tag == 0x0089) && // Minolta, possibly Olympus too
         tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
       thumb_length = get4();
 
     if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&  // Nikon
         ((tag == 0x008c) ||
          (tag == 0x0096))) {
       meta_offset = ftell(ifp);
     }
 
     if ((tag == 0x00a1) &&
         tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
         strncasecmp(make, "Samsung", 7))
     {
       order = 0x4949;
       fseek(ifp, 140, SEEK_CUR);
       FORC3 cam_mul[c] = get4();
     }
 
     if (tag == 0xb001 && tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) // Sony ModelID
     {
       unique_id = get2();
     }
     if (tag == 0x0200 && len == 3) // Olympus
       shot_order = (get4(), get4());
 
     if (tag == 0x0f00 && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED))
     {
       if (len == 614)
         fseek(ifp, 176, SEEK_CUR);
       else if (len == 734 || len == 1502) // Kodak, Minolta, Olympus
         fseek(ifp, 148, SEEK_CUR);
       else
         goto next;
       goto get2_256;
     }
 
     if (tag == 0x2011 && len == 2) // Casio
     {
     get2_256:
       order = 0x4d4d;
       cam_mul[0] = get2() / 256.0;
       cam_mul[2] = get2() / 256.0;
     }
 
   next:
     fseek(ifp, save, SEEK_SET);
   }
diff --git a/src/metadata/mediumformat.cpp b/src/metadata/mediumformat.cpp
index e1bb5028..3ef2c045 100644
--- a/src/metadata/mediumformat.cpp
+++ b/src/metadata/mediumformat.cpp
@@ -20,490 +20,492 @@
 
 void LibRaw::parse_phase_one(int base)
 {
-  unsigned entries, tag, type, len, data, save, i, c;
+  unsigned entries, tag, type, len, data, i, c;
+  INT64 save;
   float romm_cam[3][3];
   char *cp;
 
   memset(&ph1, 0, sizeof ph1);
   fseek(ifp, base, SEEK_SET);
   order = get4() & 0xffff;
   if (get4() >> 8 != 0x526177)
     return; /* "Raw" */
   unsigned offset = get4();
   if (offset == 0xbad0bad)
     return;
   fseek(ifp, offset + base, SEEK_SET);
   entries = get4();
   if (entries > 8192)
     return; // too much??
   get4();
   while (entries--)
   {
     tag = get4();
     type = get4();
     len = get4();
     data = get4();
     save = ftell(ifp);
     fseek(ifp, base + data, SEEK_SET);
     switch (tag)
     {
 
     case 0x0102:
       stmread(imgdata.shootinginfo.BodySerial, len, ifp);
       if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) &&
           (imgdata.shootinginfo.BodySerial[1] == 0x49))
       {
         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) |
                      (imgdata.shootinginfo.BodySerial[2] & 0x3f)) -
                     0x41;
       }
       else
       {
         unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) |
                      (imgdata.shootinginfo.BodySerial[1] & 0x3f)) -
                     0x41;
       }
       setPhaseOneFeatures(unique_id);
       break;
     case 0x0203:
       stmread(imPhaseOne.Software, len, ifp);
     case 0x0204:
       stmread(imPhaseOne.SystemType, len, ifp);
     case 0x0211:
       imCommon.SensorTemperature2 = int_to_float(data);
       break;
     case 0x0401:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         ilm.CurAp = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));
       else
-        ilm.CurAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.CurAp = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       break;
     case 0x0403:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         ilm.CurFocal = int_to_float(data);
       else
-        ilm.CurFocal = getreal(type);
+        ilm.CurFocal = (float)getreal(type);
       break;
     case 0x0410:
       stmread(ilm.body, len, ifp);
       if (((unsigned char)ilm.body[0]) == 0xff)
         ilm.body[0] = 0;
       break;
     case 0x0412:
       stmread(ilm.Lens, len, ifp);
       if (((unsigned char)ilm.Lens[0]) == 0xff)
         ilm.Lens[0] = 0;
       break;
     case 0x0414:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
       {
         ilm.MaxAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));
       }
       else
       {
-        ilm.MaxAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.MaxAp4CurFocal = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       }
       break;
     case 0x0415:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
       {
         ilm.MinAp4CurFocal = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));
       }
       else
       {
-        ilm.MinAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.MinAp4CurFocal = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       }
       break;
     case 0x0416:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
       {
         ilm.MinFocal = int_to_float(data);
       }
       else
       {
-        ilm.MinFocal = getreal(type);
+        ilm.MinFocal = (float)getreal(type);
       }
       if (ilm.MinFocal > 1000.0f)
       {
         ilm.MinFocal = 0.0f;
       }
       break;
     case 0x0417:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
       {
         ilm.MaxFocal = int_to_float(data);
       }
       else
       {
-        ilm.MaxFocal = getreal(type);
+        ilm.MaxFocal = (float)getreal(type);
       }
       break;
 
     case 0x0100:
       flip = "0653"[data & 3] - '0';
       break;
     case 0x0106:
       for (i = 0; i < 9; i++)
         imgdata.color.P1_color[0].romm_cam[i] = ((float *)romm_cam)[i] =
-            getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+            (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       romm_coeff(romm_cam);
       break;
     case 0x0107:
-      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+      FORC3 cam_mul[c] = (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       break;
     case 0x0108:
       raw_width = data;
       break;
     case 0x0109:
       raw_height = data;
       break;
     case 0x010a:
       left_margin = data;
       break;
     case 0x010b:
       top_margin = data;
       break;
     case 0x010c:
       width = data;
       break;
     case 0x010d:
       height = data;
       break;
     case 0x010e:
       ph1.format = data;
       break;
     case 0x010f:
       data_offset = data + base;
       break;
     case 0x0110:
       meta_offset = data + base;
       meta_length = len;
       break;
     case 0x0112:
-      ph1.key_off = save - 4;
+      ph1.key_off = int(save - 4);
       break;
     case 0x0210:
       ph1.tag_210 = int_to_float(data);
       imCommon.SensorTemperature = ph1.tag_210;
       break;
     case 0x021a:
       ph1.tag_21a = data;
       break;
     case 0x021c:
       strip_offset = data + base;
       break;
     case 0x021d:
       ph1.t_black = data;
       break;
     case 0x0222:
       ph1.split_col = data;
       break;
     case 0x0223:
       ph1.black_col = data + base;
       break;
     case 0x0224:
       ph1.split_row = data;
       break;
     case 0x0225:
       ph1.black_row = data + base;
       break;
     case 0x0226:
       for (i = 0; i < 9; i++)
-        imgdata.color.P1_color[1].romm_cam[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        imgdata.color.P1_color[1].romm_cam[i] = (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       break;
     case 0x0301:
       model[63] = 0;
       imPhaseOne.FirmwareString[255] = 0;
       fread(imPhaseOne.FirmwareString, 1, 255, ifp);
       memcpy(model, imPhaseOne.FirmwareString, 63);
       if ((cp = strstr(model, " camera")))
         *cp = 0;
       else if ((cp = strchr(model, ',')))
         *cp = 0;
       /* minus and the letter after it are not always present
         if present, last letter means:
           C : Contax 645AF
           H : Hasselblad H1 / H2
           M : Mamiya
           V : Hasselblad 555ELD / 553ELX / 503CW / 501CM; not included below
         because of adapter conflicts (Mamiya RZ body) if not present, Phase One
         645 AF, Mamiya 645AFD Series, or anything
        */
       strcpy(imPhaseOne.SystemModel, model);
       if ((cp = strchr(model, '-')))
       {
         if (cp[1] == 'C')
         {
           strcpy(ilm.body, "Contax 645AF");
           ilm.CameraMount = LIBRAW_MOUNT_Contax645;
           ilm.CameraFormat = LIBRAW_FORMAT_645;
         }
         else if (cp[1] == 'M')
         {
           strcpy(ilm.body, "Mamiya 645");
           ilm.CameraMount = LIBRAW_MOUNT_Mamiya645;
           ilm.CameraFormat = LIBRAW_FORMAT_645;
         }
         else if (cp[1] == 'H')
         {
           strcpy(ilm.body, "Hasselblad H1/H2");
           ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_H;
           ilm.CameraFormat = LIBRAW_FORMAT_645;
         }
         *cp = 0;
       }
     }
     fseek(ifp, save, SEEK_SET);
   }
 
   if (!ilm.body[0] && !imgdata.shootinginfo.BodySerial[0])
   {
     fseek(ifp, meta_offset, SEEK_SET);
     order = get2();
     fseek(ifp, 6, SEEK_CUR);
     fseek(ifp, meta_offset + get4(), SEEK_SET);
     entries = get4();
     get4();
     while (entries--)
     {
       tag = get4();
       len = get4();
       data = get4();
       save = ftell(ifp);
       fseek(ifp, meta_offset + data, SEEK_SET);
       if (tag == 0x0407)
       {
         stmread(imgdata.shootinginfo.BodySerial, len, ifp);
         if ((imgdata.shootinginfo.BodySerial[0] == 0x4c) &&
             (imgdata.shootinginfo.BodySerial[1] == 0x49))
         {
           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) |
                        (imgdata.shootinginfo.BodySerial[2] & 0x3f)) -
                       0x41;
         }
         else
         {
           unique_id = (((imgdata.shootinginfo.BodySerial[0] & 0x3f) << 5) |
                        (imgdata.shootinginfo.BodySerial[1] & 0x3f)) -
                       0x41;
         }
         setPhaseOneFeatures(unique_id);
       }
       fseek(ifp, save, SEEK_SET);
     }
   }
 
   if ((ilm.MaxAp4CurFocal > 0.7f) &&
       (ilm.MinAp4CurFocal > 0.7f)) {
     float MinAp4CurFocal = MAX(ilm.MaxAp4CurFocal,ilm.MinAp4CurFocal);
     ilm.MaxAp4CurFocal   = MIN(ilm.MaxAp4CurFocal,ilm.MinAp4CurFocal);
     ilm.MinAp4CurFocal = MinAp4CurFocal;
   }
 
   load_raw = ph1.format < 3 ? &LibRaw::phase_one_load_raw
                             : &LibRaw::phase_one_load_raw_c;
   maximum = 0xffff;
   strcpy(make, "Phase One");
   if (model[0])
     return;
   switch (raw_height)
   {
   case 2060:
     strcpy(model, "LightPhase");
     break;
   case 2682:
     strcpy(model, "H 10");
     break;
   case 4128:
     strcpy(model, "H 20");
     break;
   case 5488:
     strcpy(model, "H 25");
     break;
   }
 }
 
-void LibRaw::parse_mos(int offset)
+void LibRaw::parse_mos(INT64 offset)
 {
   char data[40];
-  int from, i, c, neut[4], planes = 0, frot = 0;
+  int i, c, neut[4], planes = 0, frot = 0;
+  INT64 from;
   unsigned skip;
   static const char *mod[] = {
       /* DM22, DM28, DM40, DM56 are somewhere here too */
       "",             //  0
       "DCB2",         //  1
       "Volare",       //  2
       "Cantare",      //  3
       "CMost",        //  4
       "Valeo 6",      //  5
       "Valeo 11",     //  6
       "Valeo 22",     //  7
       "Valeo 11p",    //  8
       "Valeo 17",     //  9
       "",             // 10
       "Aptus 17",     // 11
       "Aptus 22",     // 12
       "Aptus 75",     // 13
       "Aptus 65",     // 14
       "Aptus 54S",    // 15
       "Aptus 65S",    // 16
       "Aptus 75S",    // 17
       "AFi 5",        // 18
       "AFi 6",        // 19
       "AFi 7",        // 20
       "AFi-II 7",     // 21
       "Aptus-II 7",   // 22 (same CMs as Mamiya DM33)
       "",             // 23
       "Aptus-II 6",   // 24 (same CMs as Mamiya DM28)
       "AFi-II 10",    // 25
       "",             // 26
       "Aptus-II 10",  // 27 (same CMs as Mamiya DM56)
       "Aptus-II 5",   // 28 (same CMs as Mamiya DM22)
       "",             // 29
       "DM33",         // 30, make is Mamiya
       "",             // 31
       "",             // 32
       "Aptus-II 10R", // 33
       "Aptus-II 8",   // 34 (same CMs as Mamiya DM40)
       "",             // 35
       "Aptus-II 12",  // 36
       "",             // 37
       "AFi-II 12"     // 38
   };
   float romm_cam[3][3];
 
   fseek(ifp, offset, SEEK_SET);
   while (!feof(ifp))
   {
     if (get4() != 0x504b5453)
       break;
     get4();
     fread(data, 1, 40, ifp);
     skip = get4();
     from = ftell(ifp);
 
     if (!strcmp(data, "CameraObj_camera_type"))
     {
       stmread(ilm.body, (unsigned)skip, ifp);
       if (ilm.body[0])
       {
         if (!strncmp(ilm.body, "Mamiya R", 8))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Mamiya67;
           ilm.CameraFormat = LIBRAW_FORMAT_67;
         }
         else if (!strncmp(ilm.body, "Hasselblad 5", 12))
         {
           ilm.CameraFormat = LIBRAW_FORMAT_66;
           ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_V;
         }
         else if (!strncmp(ilm.body, "Hasselblad H", 12))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_H;
           ilm.CameraFormat = LIBRAW_FORMAT_645;
         }
         else if (!strncmp(ilm.body, "Mamiya 6", 8) ||
                  !strncmp(ilm.body, "Phase One 6", 11))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Mamiya645;
           ilm.CameraFormat = LIBRAW_FORMAT_645;
         }
         else if (!strncmp(ilm.body, "Large F", 7))
         {
           ilm.CameraMount = LIBRAW_MOUNT_LF;
           ilm.CameraFormat = LIBRAW_FORMAT_LF;
         }
         else if (!strncmp(model, "Leaf AFi", 8))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Rollei_bayonet;
           ilm.CameraFormat = LIBRAW_FORMAT_66;
         }
       }
     }
     if (!strcmp(data, "back_serial_number"))
     {
       char buffer[sizeof(imgdata.shootinginfo.BodySerial)];
       char *words[4];
       stmread(buffer, (unsigned)skip, ifp);
       /*nwords = */
           getwords(buffer, words, 4, sizeof(imgdata.shootinginfo.BodySerial));
       strcpy(imgdata.shootinginfo.BodySerial, words[0]);
     }
     if (!strcmp(data, "CaptProf_serial_number"))
     {
       char buffer[sizeof(imgdata.shootinginfo.InternalBodySerial)];
       char *words[4];
       stmread(buffer, (unsigned)skip, ifp);
       /*nwords =*/ getwords(buffer, words, 4,
                         sizeof(imgdata.shootinginfo.InternalBodySerial));
       strcpy(imgdata.shootinginfo.InternalBodySerial, words[0]);
     }
 
     if (!strcmp(data, "JPEG_preview_data"))
     {
       thumb_offset = from;
       thumb_length = skip;
     }
     if (!strcmp(data, "icc_camera_profile"))
     {
       profile_offset = from;
       profile_length = skip;
     }
     if (!strcmp(data, "ShootObj_back_type"))
     {
       fscanf(ifp, "%d", &i);
       if ((unsigned)i < sizeof mod / sizeof(*mod))
       {
         strcpy(model, mod[i]);
         if (!strncmp(model, "AFi", 3))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Rollei_bayonet;
           ilm.CameraFormat = LIBRAW_FORMAT_66;
         }
         ilm.CamID = i;
       }
     }
     if (!strcmp(data, "icc_camera_to_tone_matrix"))
     {
       for (i = 0; i < 9; i++)
         ((float *)romm_cam)[i] = int_to_float(get4());
       romm_coeff(romm_cam);
     }
     if (!strcmp(data, "CaptProf_color_matrix"))
     {
       for (i = 0; i < 9; i++)
         fscanf(ifp, "%f", (float *)romm_cam + i);
       romm_coeff(romm_cam);
     }
     if (!strcmp(data, "CaptProf_number_of_planes"))
       fscanf(ifp, "%d", &planes);
     if (!strcmp(data, "CaptProf_raw_data_rotation"))
       fscanf(ifp, "%d", &flip);
     if (!strcmp(data, "CaptProf_mosaic_pattern"))
       FORC4
       {
         fscanf(ifp, "%d", &i);
         if (i == 1)
           frot = c ^ (c >> 1); // 0123 -> 0132
       }
     if (!strcmp(data, "ImgProf_rotation_angle"))
     {
       fscanf(ifp, "%d", &i);
       flip = i - flip;
     }
     if (!strcmp(data, "NeutObj_neutrals") && !cam_mul[0])
     {
       FORC4 fscanf(ifp, "%d", neut + c);
       FORC3
       if (neut[c + 1])
         cam_mul[c] = (float)neut[0] / neut[c + 1];
     }
     if (!strcmp(data, "Rows_data"))
       load_flags = get4();
     parse_mos(from);
     fseek(ifp, skip + from, SEEK_SET);
   }
   if (planes)
     filters = (planes == 1) * 0x01010101U *
               (uchar) "\x94\x61\x16\x49"[(flip / 90 + frot) & 3];
 }
diff --git a/src/metadata/misc_parsers.cpp b/src/metadata/misc_parsers.cpp
index 57a22c2c..964bdd95 100644
--- a/src/metadata/misc_parsers.cpp
+++ b/src/metadata/misc_parsers.cpp
@@ -297,69 +297,69 @@ void LibRaw::parse_riff()
 void LibRaw::parse_rollei()
 {
   char line[128], *val;
   struct tm t;
 
   fseek(ifp, 0, SEEK_SET);
   memset(&t, 0, sizeof t);
   do
   {
     line[0] = 0;
     if (!fgets(line, 128, ifp))
       break;
     line[127] = 0;
     if(!line[0]) break; // zero-length
     if ((val = strchr(line, '=')))
       *val++ = 0;
     else
       val = line + strbuflen(line);
     if (!strcmp(line, "DAT"))
       sscanf(val, "%d.%d.%d", &t.tm_mday, &t.tm_mon, &t.tm_year);
     if (!strcmp(line, "TIM"))
       sscanf(val, "%d:%d:%d", &t.tm_hour, &t.tm_min, &t.tm_sec);
     if (!strcmp(line, "HDR"))
       thumb_offset = atoi(val);
     if (!strcmp(line, "X  "))
       raw_width = atoi(val);
     if (!strcmp(line, "Y  "))
       raw_height = atoi(val);
     if (!strcmp(line, "TX "))
       thumb_width = atoi(val);
     if (!strcmp(line, "TY "))
       thumb_height = atoi(val);
     if (!strcmp(line, "APT"))
       aperture = atof(val);
     if (!strcmp(line, "SPE"))
       shutter = atof(val);
     if (!strcmp(line, "FOCLEN"))
       focal_len = atof(val);
     if (!strcmp(line, "BLKOFS"))
       black = atoi(val) +1;
     if (!strcmp(line, "ORI"))
       switch (atoi(val)) {
       case 1:
         flip = 6;
         break;
       case 2:
         flip = 3;
         break;
       case 3:
         flip = 5;
         break;
       }
     if (!strcmp(line, "CUTRECT")) {
       sscanf(val, "%hu %hu %hu %hu",
-             &imgdata.sizes.raw_inset_crop.cleft,
-             &imgdata.sizes.raw_inset_crop.ctop,
-             &imgdata.sizes.raw_inset_crop.cwidth,
-             &imgdata.sizes.raw_inset_crop.cheight);
+             &imgdata.sizes.raw_inset_crops[0].cleft,
+             &imgdata.sizes.raw_inset_crops[0].ctop,
+             &imgdata.sizes.raw_inset_crops[0].cwidth,
+             &imgdata.sizes.raw_inset_crops[0].cheight);
     }
   } while (strncmp(line, "EOHD", 4));
   data_offset = thumb_offset + thumb_width * thumb_height * 2;
   t.tm_year -= 1900;
   t.tm_mon -= 1;
   if (mktime(&t) > 0)
     timestamp = mktime(&t);
   strcpy(make, "Rollei");
   strcpy(model, "d530flex");
   write_thumb = &LibRaw::rollei_thumb;
 }
@@ -576,107 +576,115 @@ void LibRaw::get_timestamp(int reversed)
 #ifdef USE_6BY9RPI
 void LibRaw::parse_raspberrypi()
 {
 	//This structure is at offset 0xB0 from the 'BRCM' ident.
 	struct brcm_raw_header {
 		uint8_t name[32];
 		uint16_t h_width;
 		uint16_t h_height;
 		uint16_t padding_right;
 		uint16_t padding_down;
 		uint32_t dummy[6];
 		uint16_t transform;
 		uint16_t format;
 		uint8_t bayer_order;
 		uint8_t bayer_format;
 	};
 	//Values taken from https://github.com/raspberrypi/userland/blob/master/interface/vctypes/vc_image_types.h
 #define BRCM_FORMAT_BAYER  33
 #define BRCM_BAYER_RAW8    2
 #define BRCM_BAYER_RAW10   3
 #define BRCM_BAYER_RAW12   4
 #define BRCM_BAYER_RAW14   5
 #define BRCM_BAYER_RAW16   6
 
 	struct brcm_raw_header header;
 	uint8_t brcm_tag[4];
 
+    if (ftell(ifp) > 22LL) // 22 bytes is minimum jpeg size
+    {
+        thumb_length = ftell(ifp);
+        thumb_offset = 0;
+        thumb_width = thumb_height = 0;
+        load_flags |= 0x4000; // flag: we have JPEG from beginning to meta_offset
+    }
+
 	// Sanity check that the caller has found a BRCM header
 	if (!fread(brcm_tag, 1, sizeof(brcm_tag), ifp) ||
 		memcmp(brcm_tag, "BRCM", sizeof(brcm_tag)))
 		return;
 
 	width = raw_width;
 	data_offset = ftell(ifp) + 0x8000 - sizeof(brcm_tag);
 
 	if (!fseek(ifp, 0xB0 - int(sizeof(brcm_tag)), SEEK_CUR) &&
 		fread(&header, 1, sizeof(header), ifp)) {
 		switch (header.bayer_order) {
 		case 0: //RGGB
 			filters = 0x94949494;
 			break;
 		case 1: //GBRG
 			filters = 0x49494949;
 			break;
 		default:
 		case 2: //BGGR
 			filters = 0x16161616;
 			break;
 		case 3: //GRBG
 			filters = 0x61616161;
 			break;
 		}
 
 		if (header.format == BRCM_FORMAT_BAYER) {
 			switch (header.bayer_format) {
 			case BRCM_BAYER_RAW8:
 				load_raw = &LibRaw::rpi_load_raw8;
 				//1 pixel per byte
 				raw_stride = ((header.h_width + header.padding_right) + 31)&(~31);
 				width = header.h_width;
 				raw_height = height = header.h_height;
 				is_raw = 1;
 				order = 0x4d4d;
 				break;
 			case BRCM_BAYER_RAW10:
 				load_raw = &LibRaw::nokia_load_raw;
 				//4 pixels per 5 bytes
 				raw_stride = (((((header.h_width + header.padding_right) * 5) + 3) >> 2) + 31)&(~31);
 				width = header.h_width;
 				raw_height = height = header.h_height;
 				is_raw = 1;
 				order = 0x4d4d;
 				break;
 			case BRCM_BAYER_RAW12:
 				load_raw = &LibRaw::rpi_load_raw12;
 				//2 pixels per 3 bytes
 				raw_stride = (((((header.h_width + header.padding_right) * 3) + 1) >> 1) + 31)&(~31);
 				width = header.h_width;
 				raw_height = height = header.h_height;
 				is_raw = 1;
 				order = 0x4d4d;
 				break;
 			case BRCM_BAYER_RAW14:
 				load_raw = &LibRaw::rpi_load_raw14;
 				//4 pixels per 7 bytes
 				raw_stride = (((((header.h_width + header.padding_right) * 7) + 3) >> 2) + 31)&(~31);
 				width = header.h_width;
 				raw_height = height = header.h_height;
 				is_raw = 1;
 				order = 0x4d4d;
 				break;
 			case BRCM_BAYER_RAW16:
 				load_raw = &LibRaw::rpi_load_raw16;
 				//1 pixel per 2 bytes
 				raw_stride = (((header.h_width + header.padding_right) << 1) + 31)&(~31);
 				width = header.h_width;
 				raw_height = height = header.h_height;
 				is_raw = 1;
 				order = 0x4d4d;
 				break;
 			default:
 				break;
 			}
 		}
 	}
 }
 #endif
diff --git a/src/metadata/nikon.cpp b/src/metadata/nikon.cpp
index a637ec24..b46c4d96 100644
--- a/src/metadata/nikon.cpp
+++ b/src/metadata/nikon.cpp
@@ -14,202 +14,208 @@
 
 #include "../../internal/dcraw_defs.h"
 
+// void hexDump(char *title, void *addr, int len);
+
+unsigned sget4_order (short _order, uchar *s);
+double sget_fixed32u (short _order, uchar *s);
+double AngleConversion_a (short _order, uchar *s);
+double AngleConversion (short _order, uchar *s);
+
 static const uchar xlat[2][256] = {
     {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f,
      0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3, 0xc7, 0xe9, 0x2f, 0x95, 0xa7,
      0x95, 0x1f, 0xdf, 0x7f, 0x2b, 0x29, 0xc7, 0x0d, 0xdf, 0x07, 0xef, 0x71,
      0x89, 0x3d, 0x13, 0x3d, 0x3b, 0x13, 0xfb, 0x0d, 0x89, 0xc1, 0x65, 0x1f,
      0xb3, 0x0d, 0x6b, 0x29, 0xe3, 0xfb, 0xef, 0xa3, 0x6b, 0x47, 0x7f, 0x95,
      0x35, 0xa7, 0x47, 0x4f, 0xc7, 0xf1, 0x59, 0x95, 0x35, 0x11, 0x29, 0x61,
      0xf1, 0x3d, 0xb3, 0x2b, 0x0d, 0x43, 0x89, 0xc1, 0x9d, 0x9d, 0x89, 0x65,
      0xf1, 0xe9, 0xdf, 0xbf, 0x3d, 0x7f, 0x53, 0x97, 0xe5, 0xe9, 0x95, 0x17,
      0x1d, 0x3d, 0x8b, 0xfb, 0xc7, 0xe3, 0x67, 0xa7, 0x07, 0xf1, 0x71, 0xa7,
      0x53, 0xb5, 0x29, 0x89, 0xe5, 0x2b, 0xa7, 0x17, 0x29, 0xe9, 0x4f, 0xc5,
      0x65, 0x6d, 0x6b, 0xef, 0x0d, 0x89, 0x49, 0x2f, 0xb3, 0x43, 0x53, 0x65,
      0x1d, 0x49, 0xa3, 0x13, 0x89, 0x59, 0xef, 0x6b, 0xef, 0x65, 0x1d, 0x0b,
      0x59, 0x13, 0xe3, 0x4f, 0x9d, 0xb3, 0x29, 0x43, 0x2b, 0x07, 0x1d, 0x95,
      0x59, 0x59, 0x47, 0xfb, 0xe5, 0xe9, 0x61, 0x47, 0x2f, 0x35, 0x7f, 0x17,
      0x7f, 0xef, 0x7f, 0x95, 0x95, 0x71, 0xd3, 0xa3, 0x0b, 0x71, 0xa3, 0xad,
      0x0b, 0x3b, 0xb5, 0xfb, 0xa3, 0xbf, 0x4f, 0x83, 0x1d, 0xad, 0xe9, 0x2f,
      0x71, 0x65, 0xa3, 0xe5, 0x07, 0x35, 0x3d, 0x0d, 0xb5, 0xe9, 0xe5, 0x47,
      0x3b, 0x9d, 0xef, 0x35, 0xa3, 0xbf, 0xb3, 0xdf, 0x53, 0xd3, 0x97, 0x53,
      0x49, 0x71, 0x07, 0x35, 0x61, 0x71, 0x2f, 0x43, 0x2f, 0x11, 0xdf, 0x17,
      0x97, 0xfb, 0x95, 0x3b, 0x7f, 0x6b, 0xd3, 0x25, 0xbf, 0xad, 0xc7, 0xc5,
      0xc5, 0xb5, 0x8b, 0xef, 0x2f, 0xd3, 0x07, 0x6b, 0x25, 0x49, 0x95, 0x25,
      0x49, 0x6d, 0x71, 0xc7},
     {0xa7, 0xbc, 0xc9, 0xad, 0x91, 0xdf, 0x85, 0xe5, 0xd4, 0x78, 0xd5, 0x17,
      0x46, 0x7c, 0x29, 0x4c, 0x4d, 0x03, 0xe9, 0x25, 0x68, 0x11, 0x86, 0xb3,
      0xbd, 0xf7, 0x6f, 0x61, 0x22, 0xa2, 0x26, 0x34, 0x2a, 0xbe, 0x1e, 0x46,
      0x14, 0x68, 0x9d, 0x44, 0x18, 0xc2, 0x40, 0xf4, 0x7e, 0x5f, 0x1b, 0xad,
      0x0b, 0x94, 0xb6, 0x67, 0xb4, 0x0b, 0xe1, 0xea, 0x95, 0x9c, 0x66, 0xdc,
      0xe7, 0x5d, 0x6c, 0x05, 0xda, 0xd5, 0xdf, 0x7a, 0xef, 0xf6, 0xdb, 0x1f,
      0x82, 0x4c, 0xc0, 0x68, 0x47, 0xa1, 0xbd, 0xee, 0x39, 0x50, 0x56, 0x4a,
      0xdd, 0xdf, 0xa5, 0xf8, 0xc6, 0xda, 0xca, 0x90, 0xca, 0x01, 0x42, 0x9d,
      0x8b, 0x0c, 0x73, 0x43, 0x75, 0x05, 0x94, 0xde, 0x24, 0xb3, 0x80, 0x34,
      0xe5, 0x2c, 0xdc, 0x9b, 0x3f, 0xca, 0x33, 0x45, 0xd0, 0xdb, 0x5f, 0xf5,
      0x52, 0xc3, 0x21, 0xda, 0xe2, 0x22, 0x72, 0x6b, 0x3e, 0xd0, 0x5b, 0xa8,
      0x87, 0x8c, 0x06, 0x5d, 0x0f, 0xdd, 0x09, 0x19, 0x93, 0xd0, 0xb9, 0xfc,
      0x8b, 0x0f, 0x84, 0x60, 0x33, 0x1c, 0x9b, 0x45, 0xf1, 0xf0, 0xa3, 0x94,
      0x3a, 0x12, 0x77, 0x33, 0x4d, 0x44, 0x78, 0x28, 0x3c, 0x9e, 0xfd, 0x65,
      0x57, 0x16, 0x94, 0x6b, 0xfb, 0x59, 0xd0, 0xc8, 0x22, 0x36, 0xdb, 0xd2,
      0x63, 0x98, 0x43, 0xa1, 0x04, 0x87, 0x86, 0xf7, 0xa6, 0x26, 0xbb, 0xd6,
      0x59, 0x4d, 0xbf, 0x6a, 0x2e, 0xaa, 0x2b, 0xef, 0xe6, 0x78, 0xb6, 0x4e,
      0xe0, 0x2f, 0xdc, 0x7c, 0xbe, 0x57, 0x19, 0x32, 0x7e, 0x2a, 0xd0, 0xb8,
      0xba, 0x29, 0x00, 0x3c, 0x52, 0x7d, 0xa8, 0x49, 0x3b, 0x2d, 0xeb, 0x25,
      0x49, 0xfa, 0xa3, 0xaa, 0x39, 0xa7, 0xc5, 0xa7, 0x50, 0x11, 0x36, 0xfb,
      0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65, 0x7e, 0xb0, 0xdf, 0xaf, 0x4e,
      0xb3, 0x61, 0x7f, 0x2f} };
 
-
-
 void LibRaw::processNikonLensData(uchar *LensData, unsigned len)
 {
 
-  ushort i;
+  ushort i=0;
   if (imgdata.lens.nikon.LensType & 0x80) {
     strcpy (ilm.LensFeatures_pre, "AF-P");
   } else if (!(imgdata.lens.nikon.LensType & 0x01)) {
     ilm.LensFeatures_pre[0] = 'A';
     ilm.LensFeatures_pre[1] = 'F';
   } else {
     ilm.LensFeatures_pre[0] = 'M';
     ilm.LensFeatures_pre[1] = 'F';
   }
 
   if (imgdata.lens.nikon.LensType & 0x40) {
     ilm.LensFeatures_suf[0] = 'E';
   } else if (imgdata.lens.nikon.LensType & 0x04) {
     ilm.LensFeatures_suf[0] = 'G';
   } else if (imgdata.lens.nikon.LensType & 0x02) {
     ilm.LensFeatures_suf[0] = 'D';
   }
 
   if (imgdata.lens.nikon.LensType & 0x08)
   {
     ilm.LensFeatures_suf[1] = ' ';
     ilm.LensFeatures_suf[2] = 'V';
     ilm.LensFeatures_suf[3] = 'R';
   }
 
   if (imgdata.lens.nikon.LensType & 0x10)
   {
     ilm.LensMount = ilm.CameraMount = LIBRAW_MOUNT_Nikon_CX;
     ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_1INCH;
   }
   else
     ilm.LensMount = ilm.CameraMount = LIBRAW_MOUNT_Nikon_F;
 
   if (imgdata.lens.nikon.LensType & 0x20)
   {
     strcpy(ilm.Adapter, "FT-1");
     ilm.LensMount = LIBRAW_MOUNT_Nikon_F;
     ilm.CameraMount = LIBRAW_MOUNT_Nikon_CX;
     ilm.CameraFormat = LIBRAW_FORMAT_1INCH;
   }
 
   imgdata.lens.nikon.LensType = imgdata.lens.nikon.LensType & 0xdf;
 
   if ((len < 20) || (len == 58))
   {
     switch (len)
     {
     case 9:
       i = 2;
       break;
     case 15:
       i = 7;
       break;
     case 16:
       i = 8;
       break;
-    case 58: // "Z 6", "Z 7", "Z 50", D780, "Z 5"
+    case 58: // "Z 6", "Z 6 II", "Z 7", "Z 7 II", "Z 50", D780, "Z 5", "Z fc"
       if (model[6] == 'Z')
         ilm.CameraMount = LIBRAW_MOUNT_Nikon_Z;
       if (imNikon.HighSpeedCropFormat != 12)
         ilm.CameraFormat = LIBRAW_FORMAT_FF;
       i = 1;
       while ((LensData[i] == LensData[0]) && (i < 17))
         i++;
       if (i == 17)
       {
         ilm.LensMount = LIBRAW_MOUNT_Nikon_Z;
         ilm.LensID = sget2(LensData + 0x2c);
         switch (ilm.LensID) {
           case 11: case 12:
             ilm.LensFormat = LIBRAW_FORMAT_APSC;
             break;
-          case 1:  case 2:  case 4:  case 8:
-          case 9:  case 13: case 14: case 15:
+          case  1: case  2: case  4: case  8:
+          case  9: case 13: case 14: case 15:
           case 16: case 17: case 18: case 21:
-          case 22: case 23:
+          case 22: case 23: case 24: case 27:
+          case 29:
             ilm.LensFormat = LIBRAW_FORMAT_FF;
             break;
         }
         if (ilm.MaxAp4CurFocal < 0.7f)
           ilm.MaxAp4CurFocal = libraw_powf64l(
               2.0f, (float)sget2(LensData + 0x32) / 384.0f - 1.0f);
         if (ilm.CurAp < 0.7f)
           ilm.CurAp = libraw_powf64l(
               2.0f, (float)sget2(LensData + 0x34) / 384.0f - 1.0f);
         if (fabsf(ilm.CurFocal) < 1.1f)
           ilm.CurFocal = sget2(LensData + 0x38);
         return;
       }
       i = 9;
       ilm.LensMount = LIBRAW_MOUNT_Nikon_F;
       if (ilm.CameraMount == LIBRAW_MOUNT_Nikon_Z)
         strcpy(ilm.Adapter, "FTZ");
       break;
     }
     imgdata.lens.nikon.LensIDNumber = LensData[i];
     imgdata.lens.nikon.LensFStops = LensData[i + 1];
     ilm.LensFStops = (float)imgdata.lens.nikon.LensFStops / 12.0f;
     if (fabsf(ilm.MinFocal) < 1.1f)
     {
       if ((imgdata.lens.nikon.LensType ^ (uchar)0x01) || LensData[i + 2])
         ilm.MinFocal =
             5.0f * libraw_powf64l(2.0f, (float)LensData[i + 2] / 24.0f);
       if ((imgdata.lens.nikon.LensType ^ (uchar)0x01) || LensData[i + 3])
         ilm.MaxFocal =
             5.0f * libraw_powf64l(2.0f, (float)LensData[i + 3] / 24.0f);
       if ((imgdata.lens.nikon.LensType ^ (uchar)0x01) || LensData[i + 4])
         ilm.MaxAp4MinFocal =
             libraw_powf64l(2.0f, (float)LensData[i + 4] / 24.0f);
       if ((imgdata.lens.nikon.LensType ^ (uchar)0x01) || LensData[i + 5])
         ilm.MaxAp4MaxFocal =
             libraw_powf64l(2.0f, (float)LensData[i + 5] / 24.0f);
     }
     imgdata.lens.nikon.MCUVersion = LensData[i + 6];
     if (i != 2)
     {
       if ((LensData[i - 1]) && (fabsf(ilm.CurFocal) < 1.1f))
         ilm.CurFocal =
             5.0f * libraw_powf64l(2.0f, (float)LensData[i - 1] / 24.0f);
       if (LensData[i + 7])
         imgdata.lens.nikon.EffectiveMaxAp =
             libraw_powf64l(2.0f, (float)LensData[i + 7] / 24.0f);
     }
     ilm.LensID = (unsigned long long)LensData[i] << 56 |
                  (unsigned long long)LensData[i + 1] << 48 |
                  (unsigned long long)LensData[i + 2] << 40 |
                  (unsigned long long)LensData[i + 3] << 32 |
                  (unsigned long long)LensData[i + 4] << 24 |
                  (unsigned long long)LensData[i + 5] << 16 |
                  (unsigned long long)LensData[i + 6] << 8 |
                  (unsigned long long)imgdata.lens.nikon.LensType;
   }
   else if ((len == 459) || (len == 590))
   {
     memcpy(ilm.Lens, LensData + 390, 64);
   }
   else if (len == 509)
   {
     memcpy(ilm.Lens, LensData + 391, 64);
   }
   else if (len == 879)
   {
     memcpy(ilm.Lens, LensData + 680, 64);
   }
 
   return;
 }
@@ -237,621 +243,800 @@ void LibRaw::Nikon_NRW_WBtag(int wb, int skip)
 void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
 {
 
   unsigned offset = 0, entries, tag, type, len, save;
 
   unsigned c, i;
-  uchar *LensData_buf;
+  unsigned LensData_len = 0;
+  uchar *LensData_buf=0;
   uchar ColorBalanceData_buf[324];
   int ColorBalanceData_ready = 0;
   uchar ci, cj, ck;
   unsigned serial = 0;
   unsigned custom_serial = 0;
-  unsigned LensData_len = 0;
+
+  unsigned ShotInfo_len = 0;
+  uchar *ShotInfo_buf=0;
+
+/* for dump:
+uchar *cj_block, *ck_block;
+*/
 
   short morder, sorder = order;
   char buf[10];
   INT64 fsize = ifp->size();
 
   fread(buf, 1, 10, ifp);
 
   if (!strcmp(buf, "Nikon"))
   {
     if (buf[6] != '\2')
       return;
     base = ftell(ifp);
     order = get2();
     if (get2() != 42)
       goto quit;
     offset = get4();
     fseek(ifp, INT64(offset) - 8LL, SEEK_CUR);
   }
   else
   {
     fseek(ifp, -10, SEEK_CUR);
   }
 
   entries = get2();
   if (entries > 1000)
     return;
   morder = order;
 
   while (entries--)
   {
     order = morder;
     tiff_get(base, &tag, &type, &len, &save);
 
     INT64 pos = ifp->tell();
     if (len > 8 && pos + len > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     tag |= uptag << 16;
     if (len > 100 * 1024 * 1024)
       goto next; // 100Mb tag? No!
 
     if (tag == 0x0002)
     {
       if (!iso_speed)
         iso_speed = (get2(), get2());
     }
     else if (tag == 0x000a)
     {
       ilm.LensMount = ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
     }
     else if ((tag == 0x000c) && (len == 4) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_RATIONAL))
     {
       cam_mul[0] = getreal(type);
       cam_mul[2] = getreal(type);
       cam_mul[1] = getreal(type);
       cam_mul[3] = getreal(type);
     }
     else if (tag == 0x0011)
     {
       if (is_raw)
       {
         fseek(ifp, get4() + base, SEEK_SET);
         parse_tiff_ifd(base);
       }
     }
     else if (tag == 0x0012)
     {
       uchar uc1 = fgetc(ifp);
       uchar uc2 = fgetc(ifp);
       uchar uc3 = fgetc(ifp);
       if (uc3)
         imCommon.FlashEC = (float)(uc1 * uc2) / (float)uc3;
     }
     else if (tag == 0x0014)
     {
       if (tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary))
       {
         if (len == 2560)
         { // E5400, E8400, E8700, E8800
           fseek(ifp, 0x4e0L, SEEK_CUR);
           order = 0x4d4d;
           cam_mul[0] = get2() / 256.0;
           cam_mul[2] = get2() / 256.0;
           cam_mul[1] = cam_mul[3] = 1.0;
           icWBC[LIBRAW_WBI_Auto][0] = get2();
           icWBC[LIBRAW_WBI_Auto][2] = get2();
           icWBC[LIBRAW_WBI_Daylight][0] = get2();
           icWBC[LIBRAW_WBI_Daylight][2] = get2();
           fseek(ifp, 0x18L, SEEK_CUR);
           icWBC[LIBRAW_WBI_Tungsten][0] = get2();
           icWBC[LIBRAW_WBI_Tungsten][2] = get2();
           fseek(ifp, 0x18L, SEEK_CUR);
           icWBC[LIBRAW_WBI_FL_W][0] = get2();
           icWBC[LIBRAW_WBI_FL_W][2] = get2();
           icWBC[LIBRAW_WBI_FL_N][0] = get2();
           icWBC[LIBRAW_WBI_FL_N][2] = get2();
           icWBC[LIBRAW_WBI_FL_D][0] = get2();
           icWBC[LIBRAW_WBI_FL_D][2] = get2();
           icWBC[LIBRAW_WBI_Cloudy][0] = get2();
           icWBC[LIBRAW_WBI_Cloudy][2] = get2();
           fseek(ifp, 0x18L, SEEK_CUR);
           icWBC[LIBRAW_WBI_Flash][0] = get2();
           icWBC[LIBRAW_WBI_Flash][2] = get2();
 
           icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] =
             icWBC[LIBRAW_WBI_Daylight][1] = icWBC[LIBRAW_WBI_Daylight][3] =
             icWBC[LIBRAW_WBI_Tungsten][1] = icWBC[LIBRAW_WBI_Tungsten][3] =
             icWBC[LIBRAW_WBI_FL_W][1] = icWBC[LIBRAW_WBI_FL_W][3] =
             icWBC[LIBRAW_WBI_FL_N][1] = icWBC[LIBRAW_WBI_FL_N][3] =
             icWBC[LIBRAW_WBI_FL_D][1] = icWBC[LIBRAW_WBI_FL_D][3] =
             icWBC[LIBRAW_WBI_Cloudy][1] = icWBC[LIBRAW_WBI_Cloudy][3] =
             icWBC[LIBRAW_WBI_Flash][1] = icWBC[LIBRAW_WBI_Flash][3] = 256;
 
           if (strncmp(model, "E8700", 5))
           {
             fseek(ifp, 0x18L, SEEK_CUR);
             icWBC[LIBRAW_WBI_Shade][0] = get2();
             icWBC[LIBRAW_WBI_Shade][2] = get2();
             icWBC[LIBRAW_WBI_Shade][1] = icWBC[LIBRAW_WBI_Shade][3] = 256;
           }
         }
         else if (len == 1280)
         { // E5000, E5700
           cam_mul[0] = cam_mul[1] = cam_mul[2] = cam_mul[3] = 1.0;
         }
         else
         {
           fread(buf, 1, 10, ifp);
           if (!strncmp(buf, "NRW ", 4))
           { // P6000, P7000, P7100, B700, P1000
             if (!strcmp(buf + 4, "0100"))
             { // P6000
               fseek(ifp, 0x13deL, SEEK_CUR);
               cam_mul[0] = get4() << 1;
               cam_mul[1] = get4();
               cam_mul[3] = get4();
               cam_mul[2] = get4() << 1;
               Nikon_NRW_WBtag(LIBRAW_WBI_Daylight, 0);
               Nikon_NRW_WBtag(LIBRAW_WBI_Cloudy, 0);
               fseek(ifp, 0x10L, SEEK_CUR);
               Nikon_NRW_WBtag(LIBRAW_WBI_Tungsten, 0);
               Nikon_NRW_WBtag(LIBRAW_WBI_FL_W, 0);
               Nikon_NRW_WBtag(LIBRAW_WBI_Flash, 0);
               fseek(ifp, 0x10L, SEEK_CUR);
               Nikon_NRW_WBtag(LIBRAW_WBI_Custom, 0);
               Nikon_NRW_WBtag(LIBRAW_WBI_Auto, 0);
             }
             else
             { // P7000, P7100, B700, P1000
               fseek(ifp, 0x16L, SEEK_CUR);
               black = get2();
               if (cam_mul[0] < 0.1f)
               {
                 fseek(ifp, 0x16L, SEEK_CUR);
                 cam_mul[0] = get4() << 1;
                 cam_mul[1] = get4();
                 cam_mul[3] = get4();
                 cam_mul[2] = get4() << 1;
               }
               else
               {
                 fseek(ifp, 0x26L, SEEK_CUR);
               }
               if (len != 332)
               { // not A1000
                 Nikon_NRW_WBtag(LIBRAW_WBI_Daylight, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Cloudy, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Shade, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Tungsten, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_FL_W, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_FL_N, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_FL_D, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_HT_Mercury, 1);
                 fseek(ifp, 0x14L, SEEK_CUR);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Custom, 1);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Auto, 1);
               }
               else
               {
                 fseek(ifp, 0xc8L, SEEK_CUR);
                 Nikon_NRW_WBtag(LIBRAW_WBI_Auto, 1);
               }
             }
           }
         }
       }
     }
     else if (tag == 0x001b)
     {
       imNikon.HighSpeedCropFormat = get2();
       imNikon.SensorHighSpeedCrop.cwidth = get2();
       imNikon.SensorHighSpeedCrop.cheight = get2();
       imNikon.SensorWidth = get2();
       imNikon.SensorHeight = get2();
       imNikon.SensorHighSpeedCrop.cleft = get2();
       imNikon.SensorHighSpeedCrop.ctop = get2();
       switch (imNikon.HighSpeedCropFormat)
       {
       case 0:
       case 1:
       case 2:
       case 4:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 11:
         ilm.CameraFormat = LIBRAW_FORMAT_FF;
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 12:
         ilm.CameraFormat = LIBRAW_FORMAT_APSC;
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 3:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
         break;
       case 6:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
         break;
       case 17:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
         break;
       default:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
         break;
       }
     }
     else if (tag == 0x001d)
     { // serial number
       if (len > 0)
       {
         int model_len = (int)strbuflen(model);
         while ((c = fgetc(ifp)) && (len-- > 0) && (c != (unsigned)EOF))
         {
           if ((!custom_serial) && (!isdigit(c)))
           {
             if (((model_len == 3) && !strcmp(model, "D50")) ||
                 ((model_len >= 4) && !isalnum(model[model_len - 4]) &&
                  !strncmp(&model[model_len - 3], "D50", 3)))
             {
               custom_serial = 34;
             }
             else
             {
               custom_serial = 96;
             }
             break;
           }
           serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);
         }
         if (!imgdata.shootinginfo.BodySerial[0])
           sprintf(imgdata.shootinginfo.BodySerial, "%d", serial);
       }
     }
     else if (tag == 0x001e) {
       switch (get2()) {
       case 1:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 2:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
     } else if (tag == 0x0025)
     {
       imCommon.real_ISO = int(100.0 * libraw_powf64l(2.0, double((uchar)fgetc(ifp)) / 12.0 - 5.0));
       if (!iso_speed || (iso_speed == 65535))
       {
         iso_speed = imCommon.real_ISO;
       }
     }
     else if (tag == 0x0022)
     {
       imNikon.Active_D_Lighting = get2();
     }
     else if (tag == 0x003b)
     { // WB for multi-exposure (ME); all 1s for regular exposures
       imNikon.ME_WB[0] = getreal(type);
       imNikon.ME_WB[2] = getreal(type);
       imNikon.ME_WB[1] = getreal(type);
       imNikon.ME_WB[3] = getreal(type);
     }
     else if (tag == 0x003d)
     { // not corrected for file bitcount, to be patched in open_datastream
       FORC4 cblack[RGGB_2_RGBG(c)] = get2();
       i = cblack[3];
       FORC3 if (i > cblack[c]) i = cblack[c];
       FORC4 cblack[c] -= i;
       black += i;
     }
     else if (tag == 0x0045)
     { /* upper left pixel (x,y), size (width,height) */
-      imgdata.sizes.raw_inset_crop.cleft = get2();
-      imgdata.sizes.raw_inset_crop.ctop = get2();
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     }
     else if (tag == 0x0082)
     { // lens attachment
       stmread(ilm.Attachment, len, ifp);
     }
     else if (tag == 0x0083)
     { // lens type
       imgdata.lens.nikon.LensType = fgetc(ifp);
     }
     else if (tag == 0x0084)
     { // lens
       ilm.MinFocal = getreal(type);
       ilm.MaxFocal = getreal(type);
       ilm.MaxAp4MinFocal = getreal(type);
       ilm.MaxAp4MaxFocal = getreal(type);
     }
     else if (tag == 0x0088) // AFInfo
     {
       if (!imCommon.afcount)
       {
         imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
         imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
         imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
         imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
         fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
         imCommon.afcount = 1;
       }
     }
     else if (tag == 0x008b) // lens f-stops
     {
       uchar uc1 = fgetc(ifp);
       uchar uc2 = fgetc(ifp);
       uchar uc3 = fgetc(ifp);
       if (uc3)
       {
         imgdata.lens.nikon.LensFStops = uc1 * uc2 * (12 / uc3);
         ilm.LensFStops = (float)imgdata.lens.nikon.LensFStops / 12.0f;
       }
     }
     else if ((tag == 0x008c) || (tag == 0x0096))
     {
       meta_offset = ftell(ifp);
     }
+    else if ((tag == 0x0091) && (len > 4))
+    {
+      ShotInfo_len = len;
+      ShotInfo_buf = (uchar *)malloc(ShotInfo_len);
+
+/* for dump:
+cj_block = (uchar *)malloc(ShotInfo_len);
+ck_block = (uchar *)malloc(ShotInfo_len);
+*/
+
+      fread(ShotInfo_buf, ShotInfo_len, 1, ifp);
+      FORC4 imNikon.ShotInfoVersion =
+          imNikon.ShotInfoVersion * 10 + ShotInfo_buf[c] - '0';
+    }
     else if (tag == 0x0093)
     {
       imNikon.NEFCompression = i = get2();
       if ((i == 7) || (i == 9))
       {
         ilm.LensMount = LIBRAW_MOUNT_FixedLens;
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (tag == 0x0097)
     { // ver97
       FORC4 imNikon.ColorBalanceVersion =
           imNikon.ColorBalanceVersion * 10 + fgetc(ifp) - '0';
       switch (imNikon.ColorBalanceVersion)
       {
       case 100: // NIKON D100
         fseek(ifp, 0x44L, SEEK_CUR);
         FORC4 cam_mul[RBGG_2_RGBG(c)] = get2();
         break;
       case 102: // NIKON D2H
         fseek(ifp, 0x6L, SEEK_CUR);
         FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();
         break;
       case 103: // NIKON D70, D70s
         fseek(ifp, 0x10L, SEEK_CUR);
         FORC4 cam_mul[c] = get2();
       }
       if (imNikon.ColorBalanceVersion >= 200)
       {
         /*
         204: NIKON D2X, D2Xs
         205: NIKON D50
         206: NIKON D2Hs
         207: NIKON D200
         208: NIKON D40, D40X, D80
         209: NIKON D3, D3X, D300, D700
         210: NIKON D60
         211: NIKON D90, D5000
         212: NIKON D300S
         213: NIKON D3000
         214: NIKON D3S
         215: NIKON D3100
         216: NIKON D5100, D7000
         217: NIKON D4, D600, D800, D800E, D3200
         -= unknown =-
         218: NIKON D5200, D7100
         219: NIKON D5300
         220: NIKON D610, Df
         221: NIKON D3300
         222: NIKON D4S
         223: NIKON D750, D810
         224: NIKON D3400, D3500, D5500, D5600, D7200
         225: NIKON D5, D500
         226: NIKON D7500
         227: NIKON D850
          */
         if (imNikon.ColorBalanceVersion != 205)
         {
           fseek(ifp, 0x118L, SEEK_CUR);
         }
         ColorBalanceData_ready =
             (fread(ColorBalanceData_buf, 324, 1, ifp) == 1);
       }
       if ((imNikon.ColorBalanceVersion >= 400) &&
           (imNikon.ColorBalanceVersion <= 405))
       { // 1 J1, 1 V1, 1 J2, 1 V2, 1 J3, 1 S1, 1 AW1, 1 S2, 1 J4, 1 V3, 1 J5
         ilm.CameraFormat = LIBRAW_FORMAT_1INCH;
         ilm.CameraMount = LIBRAW_MOUNT_Nikon_CX;
       }
       else if ((imNikon.ColorBalanceVersion >= 500) &&
                (imNikon.ColorBalanceVersion <= 502))
       { // P7700, P7800, P330, P340
         ilm.CameraMount = ilm.LensMount = LIBRAW_MOUNT_FixedLens;
         ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
       }
       else if (imNikon.ColorBalanceVersion == 601)
       { // Coolpix A
         ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_APSC;
         ilm.CameraMount = ilm.LensMount = LIBRAW_MOUNT_FixedLens;
         ilm.FocalType = LIBRAW_FT_PRIME_LENS;
       }
     }
     else if (tag == 0x0098) // contains lens data
     {
       FORC4 imNikon.LensDataVersion =
           imNikon.LensDataVersion * 10 + fgetc(ifp) - '0';
       switch (imNikon.LensDataVersion)
       {
       case 100:
         LensData_len = 9;
         break;
       case 101:
       case 201: // encrypted, starting from v.201
       case 202:
       case 203:
         LensData_len = 15;
         break;
       case 204:
         LensData_len = 16;
         break;
       case 400:
         LensData_len = 459;
         break;
       case 401:
         LensData_len = 590;
         break;
       case 402:
         LensData_len = 509;
         break;
       case 403:
         LensData_len = 879;
         break;
       case 800:
       case 801:
         LensData_len = 58;
         break;
       }
       if (LensData_len)
       {
         LensData_buf = (uchar *)malloc(LensData_len);
         fread(LensData_buf, LensData_len, 1, ifp);
       }
     }
     else if (tag == 0x00a0)
     {
       stmread(imgdata.shootinginfo.BodySerial, len, ifp);
     }
     else if (tag == 0x00a7) // shutter count
     {
       imNikon.key = fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp) ^ fgetc(ifp);
       if (custom_serial)
       {
         ci = xlat[0][custom_serial];
       }
       else
       {
         ci = xlat[0][serial & 0xff];
       }
       cj = xlat[1][imNikon.key];
       ck = 0x60;
       if (((unsigned)(imNikon.ColorBalanceVersion - 200) < 18) &&
           ColorBalanceData_ready)
       {
         for (i = 0; i < 324; i++)
           ColorBalanceData_buf[i] ^= (cj += ci * ck++);
         i = "66666>666;6A;:;555"[imNikon.ColorBalanceVersion - 200] - '0';
         FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =
             sget2(ColorBalanceData_buf + (i & -2) + c * 2);
       }
 
       if (LensData_len)
       {
         if (imNikon.LensDataVersion > 200)
         {
           cj = xlat[1][imNikon.key];
           ck = 0x60;
           for (i = 0; i < LensData_len; i++)
           {
             LensData_buf[i] ^= (cj += ci * ck++);
           }
         }
         processNikonLensData(LensData_buf, LensData_len);
         LensData_len = 0;
         free(LensData_buf);
       }
+      if (ShotInfo_len && (imNikon.ShotInfoVersion >= 208)) {
+        unsigned RotationOffset = 0,
+                 OrientationOffset = 0;
+
+        cj = xlat[1][imNikon.key];
+        ck = 0x60;
+        for (i = 4; i < ShotInfo_len; i++) {
+          ShotInfo_buf[i] ^= (cj += ci * ck++);
+
+/* for dump:
+cj_block[i-4] = cj;
+ck_block[i-4] = ck-1;
+*/
+        }
+/* for dump:
+printf ("==>> ci: 0x%02x, cj at start: 0x%02x\n",
+ci, xlat[1][imNikon.key]);
+hexDump("ck array:", ck_block, ShotInfo_len-4);
+hexDump("cj array:", cj_block, ShotInfo_len-4);
+free(cj_block);
+free(ck_block);
+*/
+
+        switch (imNikon.ShotInfoVersion) {
+        case 208: // ShotInfoD80, Rotation
+          RotationOffset = 590;
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = *(ShotInfo_buf+RotationOffset) & 0x07;
+          }
+          break;
+
+        case 231: // ShotInfoD4S, Rotation, Roll/Pitch/Yaw
+          OrientationOffset  = 0x350b;
+          RotationOffset     = 0x3693;
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = (*(ShotInfo_buf+RotationOffset)>>4) & 0x03;
+          }
+          break;
+
+        case 233: // ShotInfoD810, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x84);
+          break;
+
+        case 238: // D5,   ShotInfoD500, Rotation, Roll/Pitch/Yaw
+        case 239: // D500, ShotInfoD500, Rotation, Roll/Pitch/Yaw
+          RotationOffset = sget4_order(morder, ShotInfo_buf+0x10) + 0xca;
+          if (RotationOffset > 0xca) {
+            RotationOffset -= 0xb0;
+          }
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = *(ShotInfo_buf+RotationOffset) & 0x03;
+          }
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0xa0);
+          break;
+
+        case 243: // ShotInfoD850, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0xa0);
+          break;
+
+        case 246: // ShotInfoD6, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x9c);
+          break;
+
+        case 800: // Z 6, Z 7,     ShotInfoZ7_2, Roll/Pitch/Yaw
+        case 803: // Z 6_2, Z 7_2, ShotInfoZ7_2, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x98);
+          break;
+//        case 804: // Z fc
+//          break;
+        }
+        if (OrientationOffset && ((OrientationOffset+12)<ShotInfo_len)) {
+          if (imNikon.ShotInfoVersion == 231) // ShotInfoD4S
+            imNikon.RollAngle = AngleConversion_a(morder, ShotInfo_buf+OrientationOffset);
+          else
+            imNikon.RollAngle = AngleConversion(morder, ShotInfo_buf+OrientationOffset);
+          imNikon.PitchAngle  = AngleConversion (morder, ShotInfo_buf+OrientationOffset+4);
+          imNikon.YawAngle    = AngleConversion (morder, ShotInfo_buf+OrientationOffset+8);
+        }
+        if ((RotationOffset) && (imNikon.MakernotesFlip < 4))
+          imNikon.MakernotesFlip = "0863"[imNikon.MakernotesFlip] - '0';
+        ShotInfo_len = 0;
+        free(ShotInfo_buf);
+      }     
     }
     else if (tag == 0x00a8)
     { // contains flash data
       FORC4 imNikon.FlashInfoVersion =
           imNikon.FlashInfoVersion * 10 + fgetc(ifp) - '0';
     }
     else if (tag == 0x00b0)
     {
       get4(); // ME (multi-exposure) tag version, 4 symbols
       imNikon.ExposureMode = get4();
       imNikon.nMEshots = get4();
       imNikon.MEgainOn = get4();
     }
     else if (tag == 0x00b7) // AFInfo2
     {
       if (!imCommon.afcount)
       {
         imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
         imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
         int ver = 0;
         FORC4  ver = ver * 10 + (fgetc(ifp) - '0');
         imCommon.afdata[imCommon.afcount].AFInfoData_version = ver;
         imCommon.afdata[imCommon.afcount].AFInfoData_length = len-4;
         imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
         fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
         imCommon.afcount = 1;
       }
     }
     else if (tag == 0x00b9)
     {
       imNikon.AFFineTune = fgetc(ifp);
       imNikon.AFFineTuneIndex = fgetc(ifp);
       imNikon.AFFineTuneAdj = (int8_t)fgetc(ifp);
     }
     else if ((tag == 0x0100) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED))
     {
       thumb_offset = ftell(ifp);
       thumb_length = len;
     }
     else if (tag == 0x0e01)
     { /* Nikon Software / in-camera edit Note */
       int loopc = 0;
       int WhiteBalanceAdj_active = 0;
       order = 0x4949;
       fseek(ifp, 22, SEEK_CUR);
       for (offset = 22; offset + 22 < len; offset += 22 + i)
       {
         if (loopc++ > 1024)
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
         tag = get4();
         fseek(ifp, 14, SEEK_CUR);
         i = get4() - 4;
 
         if (tag == 0x76a43204)
         {
           WhiteBalanceAdj_active = fgetc(ifp);
         }
         else if (tag == 0xbf3c6c20)
         {
           if (WhiteBalanceAdj_active)
           {
             union {
               double dbl;
               unsigned long long lng;
             } un;
             un.dbl = getreal(LIBRAW_EXIFTAG_TYPE_DOUBLE);
             if ((un.lng != 0x3FF0000000000000ULL) &&
                 (un.lng != 0x000000000000F03FULL))
             {
               cam_mul[0] = un.dbl;
               cam_mul[2] = getreal(LIBRAW_EXIFTAG_TYPE_DOUBLE);
               cam_mul[1] = cam_mul[3] = 1.0;
               i -= 16;
             }
             else
               i -= 8;
           }
           fseek(ifp, i, SEEK_CUR);
         }
         else if (tag == 0x76a43207)
         {
           flip = get2();
         }
         else
         {
           fseek(ifp, i, SEEK_CUR);
         }
       }
     }
     else if (tag == 0x0e22)
     {
       FORC4 imNikon.NEFBitDepth[c] = get2();
     }
   next:
     fseek(ifp, save, SEEK_SET);
   }
 quit:
   order = sorder;
 }
+
+unsigned sget4_order (short _order, uchar *s) {
+  unsigned v;
+  if (_order == 0x4949)
+    v= s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
+  else
+    v= s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];
+  return v;
+}
+
+double sget_fixed32u (short _order, uchar *s) {
+  unsigned v = sget4_order (_order, s);
+  return ((double)v / 6.5536 + 0.5) / 10000.0;
+}
+
+double AngleConversion_a (short _order, uchar *s) {
+  double v = sget_fixed32u(_order, s);
+  if (v < 180.0) return -v;
+  return 360.0-v;
+}
+
+double AngleConversion (short _order, uchar *s) {
+  double v = sget_fixed32u(_order, s);
+  if (v <= 180.0) return v;
+  return v-360.0;
+}
+
+/* ========= */
+/*
+void hexDump(char *title, void *addr, int len) 
+{
+    int i;
+    unsigned char buff[17];
+    unsigned char *pc = (unsigned char*)addr;
+
+    // Output description if given.
+    if (title != NULL)
+        printf ("%s:\n", title);
+
+    // Process every byte in the data.
+    for (i = 0; i < len; i++) {
+        // Multiple of 16 means new line (with line offset).
+
+        if ((i % 16) == 0) {
+            // Just don't print ASCII for the zeroth line.
+            if (i != 0)
+                printf("  %s\n", buff);
+
+            // Output the offset.
+            printf("  %04x ", i);
+        }
+
+        // Now the hex code for the specific character.
+        printf(" %02x", pc[i]);
+
+        // And store a printable ASCII character for later.
+        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
+            buff[i % 16] = '.';
+        } else {
+            buff[i % 16] = pc[i];
+        }
+
+        buff[(i % 16) + 1] = '\0';
+    }
+
+    // Pad out last line if not exactly 16 characters.
+    while ((i % 16) != 0) {
+        printf("   ");
+        i++;
+    }
+
+    // And print the final ASCII bit.
+    printf("  %s\n", buff);
+}
+*/
diff --git a/src/metadata/normalize_model.cpp b/src/metadata/normalize_model.cpp
index dd6c5754..e3de0dbb 100644
--- a/src/metadata/normalize_model.cpp
+++ b/src/metadata/normalize_model.cpp
@@ -19,1387 +19,1398 @@
 void LibRaw::GetNormalizedModel()
 {
 
   int i, j;
   char *ps;
   int try_xml = 0;
 
   static const struct
   {
     unsigned long long id;
     char t_model[20];
   } unique[] =
 // clang-format off
     {
       { CanonID_EOS_M50,           "EOS M50"}, // Kiss M
       { CanonID_EOS_M6_Mark_II,    "EOS M6 Mark II"},
       { CanonID_EOS_M200,          "EOS M200"},
       { CanonID_EOS_D30,           "EOS D30"},
       { CanonID_EOS_D60,           "EOS D60"},
       { CanonID_EOS_M3,            "EOS M3"},
       { CanonID_EOS_M10,           "EOS M10"},
       { CanonID_EOS_M5,            "EOS M5"},
       { CanonID_EOS_M100,          "EOS M100"},
       { CanonID_EOS_M6,            "EOS M6"},
       { CanonID_EOS_1D,            "EOS-1D"},
       { CanonID_EOS_1Ds,           "EOS-1Ds"},
       { CanonID_EOS_10D,           "EOS 10D"},
       { CanonID_EOS_1D_Mark_III,   "EOS-1D Mark III"},
       { CanonID_EOS_300D,          "EOS 300D"}, // Digital Rebel / Kiss Digital
       { CanonID_EOS_1D_Mark_II,    "EOS-1D Mark II"},
       { CanonID_EOS_20D,           "EOS 20D"},
       { CanonID_EOS_450D,          "EOS 450D"}, // Digital Rebel XSi / Kiss X2
       { CanonID_EOS_1Ds_Mark_II,   "EOS-1Ds Mark II"},
       { CanonID_EOS_350D,          "EOS 350D"}, // Digital Rebel XT / Kiss Digital N
       { CanonID_EOS_40D,           "EOS 40D"},
       { CanonID_EOS_5D,            "EOS 5D"},
       { CanonID_EOS_1Ds_Mark_III,  "EOS-1Ds Mark III"},
       { CanonID_EOS_5D_Mark_II,    "EOS 5D Mark II"},
       { CanonID_EOS_1D_Mark_II_N,  "EOS-1D Mark II N"},
       { CanonID_EOS_30D,           "EOS 30D"},
       { CanonID_EOS_400D,          "EOS 400D"}, // Digital Rebel XTi / Kiss Digital X
       { CanonID_EOS_7D,            "EOS 7D"},
       { CanonID_EOS_500D,          "EOS 500D"},   // Rebel T1i / Kiss X3
       { CanonID_EOS_1000D,         "EOS 1000D"}, // Digital Rebel XS / Kiss F
       { CanonID_EOS_50D,           "EOS 50D"},
       { CanonID_EOS_1D_X,          "EOS-1D X"},
       { CanonID_EOS_550D,          "EOS 550D"}, // Rebel T2i / Kiss X4
       { CanonID_EOS_1D_Mark_IV,    "EOS-1D Mark IV"},
       { CanonID_EOS_5D_Mark_III,   "EOS 5D Mark III"},
       { CanonID_EOS_600D,          "EOS 600D"}, // Rebel T3i / Kiss X5
       { CanonID_EOS_60D,           "EOS 60D"},
       { CanonID_EOS_1100D,         "EOS 1100D"}, // Rebel T3 / Kiss X50
       { CanonID_EOS_7D_Mark_II,    "EOS 7D Mark II"},
       { CanonID_EOS_650D,          "EOS 650D"}, // Rebel T4i / Kiss X6i
       { CanonID_EOS_6D,            "EOS 6D"},
       { CanonID_EOS_1D_C,          "EOS-1D C"},
       { CanonID_EOS_70D,           "EOS 70D"},
       { CanonID_EOS_700D,          "EOS 700D"},   // Rebel T5i / Kiss X7i
       { CanonID_EOS_1200D,         "EOS 1200D"}, // Rebel T5 / Kiss X70 / Hi
       { CanonID_EOS_1D_X_Mark_II,  "EOS-1D X Mark II"},
       { CanonID_EOS_M,             "EOS M"},
       { CanonID_EOS_100D,          "EOS 100D"}, // Rebel SL1 / Kiss X7
       { CanonID_EOS_760D,          "EOS 760D"}, // Rebel T6s / 8000D
       { CanonID_EOS_5D_Mark_IV,    "EOS 5D Mark IV"},
       { CanonID_EOS_80D,           "EOS 80D"},
       { CanonID_EOS_M2,            "EOS M2"},
       { CanonID_EOS_5DS,           "EOS 5DS"},
       { CanonID_EOS_750D,          "EOS 750D"}, // Rebel T6i / Kiss X8i
       { CanonID_EOS_5DS_R,         "EOS 5DS R"},
       { CanonID_EOS_1300D,         "EOS 1300D"}, // Rebel T6 / Kiss X80
       { CanonID_EOS_800D,          "EOS 800D"},   // Rebel T7i / Kiss X9i
       { CanonID_EOS_6D_Mark_II,    "EOS 6D Mark II"},
       { CanonID_EOS_77D,           "EOS 77D"},     // 9000D
       { CanonID_EOS_200D,          "EOS 200D"},   // Rebel SL2 / Kiss X9
       { CanonID_EOS_R5,            "EOS R5"},
       { CanonID_EOS_3000D,         "EOS 3000D"}, // Rebel T100 / 4000D
       { CanonID_EOS_R,             "EOS R"},
       { CanonID_EOS_1D_X_Mark_III, "EOS-1D X Mark III"},
       { CanonID_EOS_1500D,         "EOS 1500D"}, // Rebel T7 / 2000D / Kiss X90
       { CanonID_EOS_RP,            "EOS RP"},
       { CanonID_EOS_850D,          "EOS 850D"},  // EOS Rebel T8i / X10i
       { CanonID_EOS_250D,          "EOS 250D"}, // Rebel SL3 / 200D II / Kiss X10
       { CanonID_EOS_90D,           "EOS 90D"},
+      { CanonID_EOS_R3,            "EOS R3"},
       { CanonID_EOS_R6,            "EOS R6"},
+      { CanonID_EOS_M50_Mark_II,   "EOS M50 Mark II"}, // M50m2, Kiss M2
     },
 #if 0
     olyque[] = {
       { OlyID_E_20,            "E-20"},
       { OlyID_E_20,            "E-20,E-20N,E-20P"},
       { OlyID_E_1,             "E-1"},
       { OlyID_E_300,           "E-300"},
       { OlyID_SP_550UZ,        "SP-550UZ"},
       { OlyID_SP_550UZ,        "SP550UZ"},
       { OlyID_SP_510UZ,        "SP-510UZ"},
       { OlyID_SP_510UZ,        "SP510UZ"},
       { OlyID_SP_560UZ,        "SP-560UZ"},
       { OlyID_SP_560UZ,        "SP560UZ"},
       { OlyID_SP_570UZ,        "SP-570UZ"},
       { OlyID_SP_570UZ,        "SP570UZ"},
       { OlyID_SP_565UZ,        "SP-565UZ"},
       { OlyID_SP_565UZ,        "SP565UZ"},
       { OlyID_XZ_1,            "XZ-1"},
       { OlyID_XZ_2,            "XZ-2"},
       { OlyID_XZ_10,           "XZ-10"},
       { OlyID_STYLUS_1,        "Stylus 1"},
       { OlyID_STYLUS_1,        "STYLUS1"},
       { OlyID_STYLUS_1,        "STYLUS1,1s"},
       { OlyID_SH_2,            "SH-2"},
       { OlyID_TG_4,            "TG-4"},
       { OlyID_TG_5,            "TG-5"},
       { OlyID_TG_6,            "TG-6"},
       { OlyID_E_10,            "E-10"},
       { OlyID_AIR_A01,         "AIR A01"},
       { OlyID_AIR_A01,         "AIR-A01"},
       { OlyID_E_330,           "E-330"},
       { OlyID_E_500,           "E-500"},
       { OlyID_E_400,           "E-400"},
       { OlyID_E_510,           "E-510"},
       { OlyID_E_3,             "E-3"},
       { OlyID_E_410,           "E-410"},
       { OlyID_E_420,           "E-420"},
       { OlyID_E_30,            "E-30"},
       { OlyID_E_520,           "E-520"},
       { OlyID_E_P1,            "E-P1"},
       { OlyID_E_620,           "E-620"},
       { OlyID_E_P2,            "E-P2"},
       { OlyID_E_PL1,           "E-PL1"},
       { OlyID_E_450,           "E-450"},
       { OlyID_E_600,           "E-600"},
       { OlyID_E_P3,            "E-P3"},
       { OlyID_E_5,             "E-5"},
       { OlyID_E_PL2,           "E-PL2"},
       { OlyID_E_M5,            "E-M5"},
       { OlyID_E_PL3,           "E-PL3"},
       { OlyID_E_PM1,           "E-PM1"},
       { OlyID_E_PL1s,          "E-PL1s"},
       { OlyID_E_PL5,           "E-PL5"},
       { OlyID_E_PM2,           "E-PM2"},
       { OlyID_E_P5,            "E-P5"},
       { OlyID_E_PL6,           "E-PL6"},
       { OlyID_E_PL7,           "E-PL7"},
       { OlyID_E_M1,            "E-M1"},
       { OlyID_E_M10,           "E-M10"},
       { OlyID_E_M5_Mark_II,    "E-M5 Mark II"},
       { OlyID_E_M5_Mark_II,    "E-M5MarkII"},
       { OlyID_E_M5_Mark_II,    "E-M5_M2"},
       { OlyID_E_M10_Mark_II,   "E-M10 Mark II"}, // Clauss piX 5oo
       { OlyID_E_M10_Mark_II,   "E-M10MarkII"},
       { OlyID_E_M10_Mark_II,   "E-M10_M2"},
       { OlyID_PEN_F,           "PEN-F"},
       { OlyID_E_PL8,           "E-PL8"},
       { OlyID_E_M1_Mark_II,    "E-M1 Mark II"},
       { OlyID_E_M1_Mark_II,    "E-M1MarkII"},
       { OlyID_E_M1_Mark_II,    "E-M1_M2"},
       { OlyID_E_M10_Mark_III,  "E-M10 Mark III"},
       { OlyID_E_M10_Mark_III,  "E-M10_M3"},
       { OlyID_E_PL9,           "E-PL9"},
       { OlyID_E_M1X,           "E-M1X"},
       { OlyID_E_PL10,          "E-PL10"},
       { OlyID_E_M10_Mark_IV,   "E-M10 Mark IV"},
       { OlyID_E_M10_Mark_IV,   "E-M10MarkIV"},
       { OlyID_E_M10_Mark_IV,   "E-M10_M4"},
       { OlyID_E_M5_Mark_III,   "E-M5 Mark III"},
       { OlyID_E_M5_Mark_III,   "E-M5MarkIII"},
       { OlyID_E_M5_Mark_III,   "E-M5_M3"},
       { OlyID_E_M1_Mark_III,   "E-M1 Mark III"},
       { OlyID_E_M1_Mark_III,   "E-M1MarkIII"},
       { OlyID_E_M1_Mark_III,   "E-M1_M3"},
+      { OlyID_E_P7             "E-P7"},
       { OlyID_C_3030Z,         "C-3030Z"},
       { OlyID_C_3030Z,         "C3030Z"},
       { OlyID_C_5050Z,         "C-5050Z"},
       { OlyID_C_5050Z,         "C5050Z"},
       { OlyID_C_350Z,          "C-350Z"},
       { OlyID_C_350Z,          "X200,D560Z,C350Z"},
       { OlyID_C_740UZ,         "C-740UZ"},
       { OlyID_C_740UZ,         "C740UZ"},
       { OlyID_C_5060WZ,        "C-5060WZ"},
       { OlyID_C_5060WZ,        "C5060WZ"},
       { OlyID_C_8080WZ,        "C-8080WZ"},
       { OlyID_C_8080WZ,        "C8080WZ"},
       { OlyID_C_770UZ,         "C-770UZ"},
       { OlyID_C_770UZ,         "C770UZ"},
       { OlyID_C_7070WZ,        "C-7070WZ"},
       { OlyID_C_7070WZ,        "C7070WZ"},
       { OlyID_C_7000Z,         "C-7000Z"},
       { OlyID_C_7000Z,         "C70Z,C7000Z"},
       { OlyID_SP_500UZ,        "SP-500UZ"},
       { OlyID_SP_500UZ,        "SP500UZ"},
       { OlyID_SP_310,          "SP-310"},
       { OlyID_SP_310,          "SP310"},
       { OlyID_SP_350,          "SP-350"},
       { OlyID_SP_350,          "SP350"},
       { OlyID_SP_320,          "SP-320"},
       { OlyID_SP_320,          "SP320"},
     },
 
     penique[] = {
       { PentaxID_Optio_S,      "Optio S"},
       { PentaxID_Optio_S_V101, "Optio S V1.01"},
       { PentaxID_staristD,     "*istD"},
       { PentaxID_staristD,     "*ist D"},
       { PentaxID_Optio_33WR,   "Optio 33WR"},
       { PentaxID_Optio_S4,     "Optio S4"},
       { PentaxID_Optio_750Z,   "Optio 750Z"},
       { PentaxID_staristDS,    "*istDS"},
       { PentaxID_staristDS,    "*ist DS"},
       { PentaxID_staristDL,    "*istDL"},
       { PentaxID_staristDL,    "*ist DL"},
       { PentaxID_staristDS2,   "*istDS2"},
       { PentaxID_staristDS2,   "*ist DS2"},
-      { PentaxID_GX_1S,        "GX-1S"},       // Samsung
+      { PentaxID_GX_1S,        "GX-1S"},        // Samsung
       { PentaxID_staristDL2,   "*istDL2"},
       { PentaxID_staristDL2,   "*ist DL2"},
-      { PentaxID_GX_1L,        "GX-1L"},       // Samsung
+      { PentaxID_GX_1L,        "GX-1L"},        // Samsung
       { PentaxID_K100D,        "K100D"},
       { PentaxID_K110D,        "K110D"},
       { PentaxID_K100D_Super,  "K100D Super"},
       { PentaxID_K10D,         "K10D"},
-      { PentaxID_GX10,         "GX10"},        // Samsung
-      { PentaxID_GX10,         "GX-10"},       // Samsung
+      { PentaxID_GX10,         "GX10"},         // Samsung
+      { PentaxID_GX10,         "GX-10"},        // Samsung
       { PentaxID_K20D,         "K20D"},
-      { PentaxID_GX20,         "GX20"},        // Samsung
-      { PentaxID_GX20,         "GX-20"},       // Samsung
+      { PentaxID_GX20,         "GX20"},         // Samsung
+      { PentaxID_GX20,         "GX-20"},        // Samsung
       { PentaxID_K200D,        "K200D"},
       { PentaxID_K2000,        "K2000"},
       { PentaxID_K_m,          "K-m"},
       { PentaxID_K_7,          "K-7"},
       { PentaxID_K_x,          "K-x"},
       { PentaxID_645D,         "645D"},
       { PentaxID_K_r,          "K-r"},
       { PentaxID_K_5,          "K-5"},
       { PentaxID_Q,            "Q"},
       { PentaxID_K_01,         "K-01"},
       { PentaxID_K_30,         "K-30"},
       { PentaxID_Q10,          "Q10"},
       { PentaxID_K_5_II,       "K-5 II"},
       { PentaxID_K_5_II_s,     "K-5 II s"},
       { PentaxID_Q7,           "Q7"},
       { PentaxID_MX_1,         "MX-1"},
       { PentaxID_K_50,         "K-50"},
       { PentaxID_K_3,          "K-3"},
       { PentaxID_K_500,        "K-500"},
       { PentaxID_645Z,         "645Z"},
       { PentaxID_K_S1,         "K-S1"},
-      { PentaxID_K_S2,         "K-S2"},        // Ricoh
+      { PentaxID_K_S2,         "K-S2"},         // Ricoh
       { PentaxID_Q_S1,         "Q-S1"},
-      { PentaxID_K_1,          "K-1"},         // Ricoh
-      { PentaxID_K_3_II,       "K-3 II"},      // Ricoh
-      { PentaxID_GR_III,       "GR III"},      // Ricoh
-      { PentaxID_K_70,         "K-70"},        // Ricoh
-      { PentaxID_KP,           "KP"},          // Ricoh
-      { PentaxID_K_1_Mark_II,  "K-1 Mark II"}, // Ricoh
+      { PentaxID_K_1,          "K-1"},          // Ricoh
+      { PentaxID_K_3_II,       "K-3 II"},       // Ricoh
+      { PentaxID_GR_III,       "GR III"},       // Ricoh
+      { PentaxID_K_70,         "K-70"},         // Ricoh
+      { PentaxID_KP,           "KP"},           // Ricoh
+      { PentaxID_K_1_Mark_II,  "K-1 Mark II"},  // Ricoh
+      { PentaxID_K_3_III,      "K-3 Mark III"}, // Ricoh
+      { PentaxID_GR_IIIx,      "GR IIIx"},
     },
 #endif
     sonique[] = {
       { SonyID_DSC_R1,         "DSC-R1"},
       { SonyID_DSLR_A100,      "DSLR-A100"},
       { SonyID_DSLR_A900,      "DSLR-A900"},
       { SonyID_DSLR_A700,      "DSLR-A700"},
       { SonyID_DSLR_A200,      "DSLR-A200"},
       { SonyID_DSLR_A350,      "DSLR-A350"},
       { SonyID_DSLR_A300,      "DSLR-A300"},
       { SonyID_DSLR_A900_APSC, "DSLR-A900"},
       { SonyID_DSLR_A380,      "DSLR-A380"},    // DSLR-A390
       { SonyID_DSLR_A330,      "DSLR-A330"},
       { SonyID_DSLR_A230,      "DSLR-A230"},
       { SonyID_DSLR_A290,      "DSLR-A290"},
       { SonyID_DSLR_A850,      "DSLR-A850"},
       { SonyID_DSLR_A850_APSC, "DSLR-A850"},
       { SonyID_DSLR_A550,      "DSLR-A550"},
       { SonyID_DSLR_A500,      "DSLR-A500"},
       { SonyID_DSLR_A450,      "DSLR-A450"},
       { SonyID_NEX_5,          "NEX-5"},
       { SonyID_NEX_3,          "NEX-3"},
       { SonyID_SLT_A33,        "SLT-A33"},
       { SonyID_SLT_A55,        "SLT-A55"},      // SLT-A55V
       { SonyID_DSLR_A560,      "DSLR-A560"},
       { SonyID_DSLR_A580,      "DSLR-A580"},
       { SonyID_NEX_C3,         "NEX-C3"},
       { SonyID_SLT_A35,        "SLT-A35"},
       { SonyID_SLT_A65,        "SLT-A65"},      // SLT-A65V
       { SonyID_SLT_A77,        "SLT-A77"},      // SLT-A77V
       { SonyID_NEX_5N,         "NEX-5N"},
       { SonyID_NEX_7,          "NEX-7"},        // Hasselblad Lunar
       { SonyID_NEX_VG20,       "NEX-VG20"},
       { SonyID_SLT_A37,        "SLT-A37"},
       { SonyID_SLT_A57,        "SLT-A57"},
       { SonyID_NEX_F3,         "NEX-F3"},
       { SonyID_SLT_A99,        "SLT-A99"},      // SLT-A99V / Hasselblad HV
       { SonyID_NEX_6,          "NEX-6"},
       { SonyID_NEX_5R,         "NEX-5R"},
       { SonyID_DSC_RX100,      "DSC-RX100"},    // Hasselblad Stellar
       { SonyID_DSC_RX1,        "DSC-RX1"},
       { SonyID_NEX_VG900,      "NEX-VG900"},
       { SonyID_NEX_VG30,       "NEX-VG30"},
       { SonyID_ILCE_3000,      "ILCE-3000"},    // ILCE-3500
       { SonyID_SLT_A58,        "SLT-A58"},
       { SonyID_NEX_3N,         "NEX-3N"},
       { SonyID_ILCE_7,         "ILCE-7"},
       { SonyID_NEX_5T,         "NEX-5T"},
       { SonyID_DSC_RX100M2,    "DSC-RX100M2"},  // Hasselblad Stellar II
       { SonyID_DSC_RX10,       "DSC-RX10"},
       { SonyID_DSC_RX1R,       "DSC-RX1R"},
       { SonyID_ILCE_7R,        "ILCE-7R"},      // Hasselblad Lusso
       { SonyID_ILCE_6000,      "ILCE-6000"},
       { SonyID_ILCE_5000,      "ILCE-5000"},
       { SonyID_DSC_RX100M3,    "DSC-RX100M3"},
       { SonyID_ILCE_7S,        "ILCE-7S"},
       { SonyID_ILCA_77M2,      "ILCA-77M2"},
       { SonyID_ILCE_5100,      "ILCE-5100"},
       { SonyID_ILCE_7M2,       "ILCE-7M2"},
       { SonyID_DSC_RX100M4,    "DSC-RX100M4"},
       { SonyID_DSC_RX10M2,     "DSC-RX10M2"},
       { SonyID_DSC_RX1RM2,     "DSC-RX1RM2"},
       { SonyID_ILCE_QX1,       "ILCE-QX1"},
       { SonyID_ILCE_7RM2,      "ILCE-7RM2"},
       { SonyID_ILCE_7SM2,      "ILCE-7SM2"},
       { SonyID_ILCA_68,        "ILCA-68"},
       { SonyID_ILCA_99M2,      "ILCA-99M2"},
       { SonyID_DSC_RX10M3,     "DSC-RX10M3"},
       { SonyID_DSC_RX100M5,    "DSC-RX100M5"},
       { SonyID_ILCE_6300,      "ILCE-6300"},
       { SonyID_ILCE_9,         "ILCE-9"},
       { SonyID_ILCE_6500,      "ILCE-6500"},
       { SonyID_ILCE_7RM3,      "ILCE-7RM3"},
       { SonyID_ILCE_7M3,       "ILCE-7M3"},
       { SonyID_DSC_RX0,        "DSC-RX0"},
       { SonyID_DSC_RX10M4,     "DSC-RX10M4"},
       { SonyID_DSC_RX100M6,    "DSC-RX100M6"},
       { SonyID_DSC_HX99,       "DSC-HX99"},
       { SonyID_DSC_RX100M5A,   "DSC-RX100M5A"},
       { SonyID_ILCE_6400,      "ILCE-6400"},
       { SonyID_DSC_RX0M2,      "DSC-RX0M2"},
       { SonyID_DSC_RX100M7,    "DSC-RX100M7"},
       { SonyID_ILCE_7RM4,      "ILCE-7RM4"},
       { SonyID_ILCE_9M2,       "ILCE-9M2"},
       { SonyID_ILCE_6600,      "ILCE-6600"},
       { SonyID_ILCE_6100,      "ILCE-6100"},
       { SonyID_ZV_1,           "ZV-1"},
       { SonyID_ILCE_7C,        "ILCE-7C"},
+      { SonyID_ZV_E10,         "ZV-E10"},
       { SonyID_ILCE_7SM3,      "ILCE-7SM3"},
+      { SonyID_ILCE_1,         "ILCE-1"},
+      { SonyID_ILME_FX3,       "ILME-FX3"},
+      { SonyID_ILCE_7RM3A,     "ILCE-7RM3A"},
+      { SonyID_ILCE_7RM4A,     "ILCE-7RM4A"},
     };
 
   static const char *orig;
 
   static const char fujialias[][16] = {
     "@DBP for GX680", "DX-2000",
     "@F500EXR", "F505EXR",
     "@F600EXR", "F605EXR",
     "@F770EXR", "F775EXR",
     "@HS10", "HS10 HS11",
     "@HS20EXR", "HS22EXR",
     "@HS30EXR", "HS33EXR", "HS35EXR",
     "@S5100", "S5500",
     "@S5200", "S5600",
     "@S6000fd", "S6500fd",
     "@S9000", "S9500",
     "@S9100", "S9600",
     "@S200EXR", "S205EXR",
     "@X-T1 IR", "X-T1IR",
+    "@GFX 100S", "GFX100S",
+    "@GFX 50S II", "GFX50S II"
   };
 
   static const char kodakalias[][16] = {
     "@DCS Pro 14N", "Camerz ZDS 14", // Camerz rebadge make: "Photo Control"
     "@DCS720X", "SCS2000",
     "@DCS520C", "EOS D2000C", "EOS D2000", // EOS rebadge make: Canon
     "@DCS560C", "EOS D6000C", "EOS D6000", // EOS rebadge make: Canon
     "@DCS460M", "DCS460A", // 'A' was supposed to stand for 'achromatic', marketing changed it to 'M'
     "@DCS460",  "DCS460C", "DCS460D",
     "@DCS465",  "DCS465C", "DCS465D",
     "@EOSDCS1", "EOSDCS1B", "EOSDCS1C",
     "@EOSDCS3", "EOSDCS3B", "EOSDCS3C",
   };
 
   static const struct
   {
     const char *Kmodel;
     ushort mount;
   } Kodak_mounts[] = {
       {"DCS465", LIBRAW_MOUNT_DigitalBack},
       {"DCS5", LIBRAW_MOUNT_Canon_EF},
       {"DCS Pro SLR/c", LIBRAW_MOUNT_Canon_EF},
       {"DCS", LIBRAW_MOUNT_Nikon_F},
       {"EOS", LIBRAW_MOUNT_Canon_EF},
       {"NC2000", LIBRAW_MOUNT_Nikon_F}, // AP "News Camera"
       {"Pixpro S-1", LIBRAW_MOUNT_mFT},
       {"ProBack", LIBRAW_MOUNT_DigitalBack},
       {"SCS1000", LIBRAW_MOUNT_Canon_EF},
   };
 
   static const char *KodakMonochrome[] = {
       "DCS420M",    "DCS420A",  "DCS420I",
       "DCS460M",    "DCS460A",  "DCS460I",
       "DCS465M",    "DCS465A",  "DCS465I",
       "DCS560M",    "DCS660M",  "DCS760M", "EOS D2000M", "EOS D6000M",
       "EOSDCS1M",   "EOSDCS1I",
       "EOSDCS3M",   "EOSDCS3I",
       "EOSDCS5M",   "EOSDCS5I",
       "NC2000M",    "NC2000A",  "NC2000I",
   };
 
   static const char leafalias[][16] = {
       // Leaf re-badged to Mamiya
     "@Aptus-II 5",  "DM22",
     "@Aptus-II 6",  "DM28",
     "@Aptus-II 7",  "DM33",
     "@Aptus-II 8",  "DM40",
     "@Aptus-II 10", "DM56",
   };
 
   static const char KonicaMinolta_aliases[][24] = {
     "@DG-5D", "DYNAX 5D", "MAXXUM 5D", "ALPHA-5 DIGITAL", "ALPHA SWEET DIGITAL",
     "@DG-7D", "DYNAX 7D", "MAXXUM 7D", "ALPHA-7 DIGITAL",
   };
 
   static const char nikonalias[][16] = {
       "@COOLPIX 2100",  "E2100",         "@COOLPIX 2500",  "E2500",
       "@COOLPIX 3200",  "E3200",         "@COOLPIX 3700",  "E3700",
       "@COOLPIX 4300",  "E4300",         "@COOLPIX 4500",  "E4500",
       "@COOLPIX 5000",  "E5000",         "@COOLPIX 5400",  "E5400",
       "@COOLPIX 5700",  "E5700",         "@COOLPIX 8400",  "E8400",
       "@COOLPIX 8700",  "E8700",         "@COOLPIX 8800",  "E8800",
       "@COOLPIX 700",   "E700",          "@COOLPIX 800",   "E800",
       "@COOLPIX 880",   "E880",          "@COOLPIX 900",   "E900",
       "@COOLPIX 950",   "E950",          "@COOLPIX 990",   "E990",
       "@COOLPIX 995",   "E995",          "@COOLPIX P7700", "COOLPIX Deneb",
       "@COOLPIX P7800", "COOLPIX Kalon",
   };
 
   static const char olyalias[][32] = { // Olympus
     "@AIR A01", "AIR-A01",
     "@C-3030Z", "C3030Z",
     "@C-5050Z", "C5050Z",
     "@C-5060WZ", "C5060WZ",
     "@C-7000Z", "C7000Z", "C70Z,C7000Z", "C70Z",
     "@C-7070WZ", "C7070WZ",
     "@C-8080WZ", "C8080WZ",
     "@C-350Z", "C350Z", "X200,D560Z,C350Z", "X200", "D560Z",
     "@C-740UZ", "C740UZ",
     "@C-770UZ", "C770UZ",
     "@E-20", "E-20,E-20N,E-20P", "E-20N", "E-20P",
     "@E-M10 Mark II", "E-M10MarkII", "E-M10_M2", "piX 5oo",
     "@E-M10 Mark III", "E-M10MarkIII", "E-M10_M3",
     "@E-M10 Mark IV", "E-M10MarkIV", "E-M10_M4",
     "@E-M1 Mark II", "E-M1MarkII", "E-M1_M2",
     "@E-M1 Mark III", "E-M1MarkIII", "E-M1_M3",
     "@E-M5 Mark II", "E-M5MarkII", "E-M5_M2",
     "@E-M5 Mark III", "E-M5MarkIII", "E-M5_M3",
     "@SH-2", "SH-3",
     "@SP-310", "SP310",
     "@SP-320", "SP320",
     "@SP-350", "SP350",
     "@SP-500UZ", "SP500UZ",
     "@SP-510UZ", "SP510UZ",
     "@SP-550UZ", "SP550UZ",
     "@SP-560UZ", "SP560UZ",
     "@SP-565UZ", "SP565UZ",
     "@SP-570UZ", "SP570UZ",
     "@Stylus 1", "STYLUS1", "STYLUS1s", "STYLUS1,1s",
   };
 
   static const char panalias[][16] = { // Panasonic, PanaLeica
 // fixed lens
     "@DMC-FX150", "DMC-FX180",
     "@DC-FZ1000M2", "DC-FZ10002", "V-Lux 5",
     "@DMC-FZ1000", "V-LUX (Typ 114)",
     "@DMC-FZ2500", "DMC-FZ2000", "DMC-FZH1",
     "@DMC-FZ100", "V-LUX 2",
     "@DMC-FZ150", "V-LUX 3",
     "@DMC-FZ200", "V-LUX 4",
     "@DMC-FZ300", "DMC-FZ330",
     "@DMC-FZ35", "DMC-FZ38",
     "@DMC-FZ40", "DMC-FZ42", "DMC-FZ45", "DC-FZ40", "DC-FZ42", "DC-FZ45",
     "@DMC-FZ50", "V-LUX 1", "V-LUX1",
     "@DMC-FZ70", "DMC-FZ72",
     "@DC-FZ80", "DC-FZ81", "DC-FZ82", "DC-FZ83", "DC-FZ85",
     "@DMC-LC1", "DIGILUX 2", "Digilux 2", "DIGILUX2",
     "@DMC-LF1", "C (Typ 112)",
     "@DC-LX100M2", "D-Lux 7",
     "@DMC-LX100", "D-LUX (Typ 109)", "D-Lux (Typ 109)",
     "@DMC-LX1", "D-Lux2", "D-LUX2", "D-LUX 2",
     "@DMC-LX2", "D-LUX 3", "D-LUX3",
     "@DMC-LX3", "D-LUX 4",
     "@DMC-LX5", "D-LUX 5",
     "@DMC-LX7", "D-LUX 6",
     "@DMC-LX9", "DMC-LX10", "DMC-LX15",
     "@DMC-ZS100", "DMC-ZS110", "DMC-TZ100", "DMC-TZ101", "DMC-TZ110", "DMC-TX1",
     "@DC-ZS200", "DC-ZS220", "DC-TZ200", "DC-TZ202", "DC-TZ220", "DC-TX2", "C-Lux", "CAM-DC25",
     "@DMC-ZS40", "DMC-TZ60", "DMC-TZ61",
     "@DMC-ZS50", "DMC-TZ70", "DMC-TZ71",
     "@DMC-ZS60", "DMC-TZ80", "DMC-TZ81", "DMC-TZ82", "DMC-TZ85",
     "@DC-ZS70", "DC-TZ90", "DC-TZ91", "DC-TZ92", "DC-TZ93",
     "@DC-ZS80", "DC-TZ95", "DC-TZ96", "DC-TZ97",
 
 // interchangeable lens
     "@DC-G100",  "DC-G110",
     "@DC-G99",   "DC-G90",   "DC-G91",  "DC-G95",
     "@DMC-G7",   "DMC-G70",
     "@DMC-G8",   "DMC-G80",  "DMC-G81", "DMC-G85",
     "@DMC-GH4",  "AG-GH4",   "CGO4",
     "@DC-GF10",  "DC-GF90",  "DC-GX880",
     "@DC-GF9",   "DC-GX850", "DC-GX800",
     "@DMC-GM1",  "DMC-GM1S",
     "@DMC-GX85", "DMC-GX80", "DMC-GX7MK2",
     "@DC-GX9",   "DC-GX7MK3",
     "@DMC-L1",   "DIGILUX 3", "DIGILUX3", // full 4/3 mount, not m43
   };
 
   static const char phase1alias[][16] = {
     "@H20",  "H 20",
     "@H25",  "H 25",
     "@P20+", "P 20+",
     "@P20",  "P 20",
     "@P21+", "P 21+", "M18", // "Mamiya M18"
     "@P21",  "P 21",
     "@P25+", "P 25+", "M22", // "Mamiya M22"
     "@P25",  "P 25",
     "@P30+", "P 30+", "M31", // "Mamiya M31"
     "@P30",  "P 30",
     "@P40+", "P 40+",
     "@P40",  "P 40",
     "@P45+", "P 45+",
     "@P45",  "P 45",
     "@P65+", "P 65+",
     "@P65",  "P 65",
   };
 
   static const char SamsungPentax_aliases[][16] = {
     "@*istDL2", "*ist DL2", "GX-1L",
     "@*istDS2", "*ist DS2", "GX-1S",
     "@*istDL",  "*ist DL",
     "@*istDS",  "*ist DS",
     "@*istD",   "*ist D",
     "@K10D", "GX10", "GX-10",
     "@K20D", "GX20", "GX-20",
     "@K-m", "K2000",
   };
 
   static const char samsungalias[][64] = {
     "@EX1", "TL500",
     "@NX U", "EK-GN100", "EK-GN110", "EK-GN120", "EK-KN120", "Galaxy NX",
     "@NX mini", "NXF1",
     "@WB2000", "TL350",
       //    "@WB5000", "WB5000/HZ25W", // no spaces around the slash separating names
       //    "@WB5500", "WB5500 / VLUU WB5500 / SAMSUNG HZ50W",
       //    "@WB500", "WB510 / VLUU WB500 / SAMSUNG HZ10W",
       //    "@WB550", "WB560 / VLUU WB550 / SAMSUNG HZ15W",
       //    "@WB650", "SAMSUNG WB650 / VLUU WB650 / SAMSUNG WB660" aka HZ35W
   };
 
 //clang-format on
   if (makeIs(LIBRAW_CAMERAMAKER_VLUU)) {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Samsung);
   }
 
   if (makeIs(LIBRAW_CAMERAMAKER_Samsung) &&
       (ilm.CameraMount == LIBRAW_MOUNT_Pentax_K)) {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Pentax);
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Unknown)) {
     if (strcasestr(model, "Google")) {
 		  setMakeFromIndex(LIBRAW_CAMERAMAKER_Google);
     }
 #ifdef USE_6BY9RPI
 	else if(strcasestr(make,"RaspberryPi"))
-		setMakeFromIndex(LIBRAW_CAMERAMAKER_Broadcom);
+		setMakeFromIndex(LIBRAW_CAMERAMAKER_RaspberryPi);
 #endif
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Hasselblad) && is_Sony)
   {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Sony);
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Clauss) && (OlyID == OlyID_E_M10_Mark_II))
   {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Olympus);
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
              (!strncmp(model, "EOS D2000", 9) || // don't use unique_id here
               !strncmp(model, "EOS D6000", 9) || // because ids for Monochrome models are unknown
               !strncmp(model, "EOSDCS", 6))) {
     setMakeFromIndex(LIBRAW_CAMERAMAKER_Kodak);
 //    if (unique_id == CanonID_EOS_D2000C) {
 //
 //    } else if (unique_id  == CanonID_EOS_D6000C) {
 ///
 //    }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_PhotoControl) &&
              !strncasecmp(model, "Camerz ZDS 14", 13)) {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Kodak);
 
   } else {
     strcpy(normalized_make, make);
   }
 
   if (makeIs(LIBRAW_CAMERAMAKER_Apple)) {
     if ((imgdata.color.UniqueCameraModel[0]) &&
         (!strncmp(model, "iPad", 4) || !strncmp(model, "iPhone", 6)))
     strcpy(model, imgdata.color.UniqueCameraModel);
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Kodak)) {
     if ((model[6] == ' ') &&
         (!strncmp(model, "DCS4", 4) ||
          !strncmp(model, "NC2000", 6)))
     {
       model[6] = 0;
     }
     if ((model[6] != 'A') &&
         (model[6] != 'I') &&
         (model[6] != 'M') &&
         !strncmp(model, "NC2000", 6))
     {
       model[6] = 0;
     }
   }
 
   else if (makeIs(LIBRAW_CAMERAMAKER_Ricoh) &&
            !strncmp(model, "GXR", 3)) {
     strcpy(ilm.body, "Ricoh GXR");
     if (!imgdata.lens.Lens[0] && imgdata.color.UniqueCameraModel[0]) {
       strcpy (imgdata.lens.Lens, imgdata.color.UniqueCameraModel);
       remove_caseSubstr (imgdata.lens.Lens, (char *)"Ricoh");
       remove_caseSubstr (imgdata.lens.Lens, (char *)"Lens");
       removeExcessiveSpaces (imgdata.lens.Lens);
     }
     if (ilm.LensID == LIBRAW_LENS_NOT_SET) {
       if (strstr(imgdata.lens.Lens, "50mm"))
         ilm.LensID = 1;
       else if (strstr(imgdata.lens.Lens, "S10"))
         ilm.LensID = 2;
       else if (strstr(imgdata.lens.Lens, "P10"))
         ilm.LensID = 3;
       else if (strstr(imgdata.lens.Lens, "28mm"))
         ilm.LensID = 5;
       else if (strstr(imgdata.lens.Lens, "A16"))
         ilm.LensID = 6;
     }
     switch (ilm.LensID) {
     case 1: // GR Lens A12 50mm F2.5 Macro
       strcpy(model, "GXR A12 50mm");
       ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_APSC;
       ilm.CameraMount = LIBRAW_MOUNT_RicohModule;
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_PRIME_LENS;
       break;
     case 2:
       strcpy(model, "GXR S10");
       ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_1div1p7INCH;
       ilm.CameraMount = LIBRAW_MOUNT_RicohModule;
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
       break;
     case 3: // Ricoh Lens P10 28-300mm F3.5-5.6 VC
       strcpy(model, "GXR P10");
       ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_1div2p3INCH;
       ilm.CameraMount = LIBRAW_MOUNT_RicohModule;
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
       break;
     case 5: // GR Lens A12 28mm F2.5
       strcpy(model, "GXR A12 28mm");
       ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_APSC;
       ilm.CameraMount = LIBRAW_MOUNT_RicohModule;
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_PRIME_LENS;
       break;
     case 6: // Ricoh Lens A16 24-85mm F3.5-5.5
       strcpy(model, "GXR A16");
       ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_APSC;
       ilm.CameraMount = LIBRAW_MOUNT_RicohModule;
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
       ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
       break;
     case 8: // Ricoh Mount A12 (Leica M lenses)
       strcpy(model, "GXR Mount A12");
       ilm.CameraFormat = LIBRAW_FORMAT_APSC;
       ilm.CameraMount = LIBRAW_MOUNT_Leica_M;
       ilm.LensID = LIBRAW_LENS_NOT_SET;
       break;
     }
   }
 
   strcpy(normalized_model, model);
 
   if (makeIs(LIBRAW_CAMERAMAKER_Canon))
   {
     if (unique_id)
     {
       if ((unique_id != CanonID_EOS_D2000C) &&
           (unique_id != CanonID_EOS_D6000C))
       {
         for (i = 0; i < int(sizeof unique / sizeof *unique); i++)
         {
           if (unique_id == unique[i].id)
           {
             strcpy(model, unique[i].t_model);
             strcpy(normalized_model, unique[i].t_model);
             break;
           }
         }
       }
     }
     else
     {
       if ((dng_version) &&
           (strlen(imgdata.color.UniqueCameraModel) > 6) &&
           strncmp(imgdata.color.UniqueCameraModel+6, "PowerShot", 9))
       {
         for (i = 0; i < int(sizeof unique / sizeof *unique); i++)
         {
           if (!strcmp(unique[i].t_model, imgdata.color.UniqueCameraModel+6))
           {
             ilm.CamID = unique_id = unique[i].id;
             strcpy(normalized_model, unique[i].t_model);
             try_xml = 1;
             break;
           }
         }
       }
     }
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm))
   {
     for (i = 0; i < int(sizeof fujialias / sizeof *fujialias); i++)
     {
       if (fujialias[i][0] == '@')
       {
         orig = fujialias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, fujialias[i]))
       {
         strcpy(normalized_model, orig);
         break;
       }
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Hasselblad)) {
     parseHassyModel();
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Mamiya))
   {
     for (i = 0; i < int(sizeof phase1alias / sizeof *phase1alias); i++)
     { // re-badged Phase One backs
       if (phase1alias[i][0] == '@') orig = phase1alias[i] + 1;
       else if (!strcmp(model, phase1alias[i]))
       {
         setMakeFromIndex(LIBRAW_CAMERAMAKER_PhaseOne);
         strcpy(normalized_model, orig);
         break;
       }
     }
     for (i = 0; i < int(sizeof leafalias / sizeof *leafalias); i++)
     { // re-badged Leaf backs
       if (leafalias[i][0] == '@') orig = leafalias[i] + 1;
       else if (!strcmp(model, leafalias[i]))
       {
         setMakeFromIndex(LIBRAW_CAMERAMAKER_Leaf);
         strcpy(normalized_model, orig);
         break;
       }
     }
 
     /* repeating, because make for some Mamiya re-badged Leaf backs is set to
      * Leaf */
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Leaf))
   {
     for (i = 0; i < int(sizeof leafalias / sizeof *leafalias); i++)
     { // re-badged Leaf backs
       if (leafalias[i][0] == '@')
       {
         orig = leafalias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, leafalias[i]))
       { // maybe to change regular "make" to "Mamiya" too
         strcpy(normalized_model, orig);
         break;
       }
     }
     if ((ps = strchr(normalized_model, '(')))
       *ps = 0;
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Minolta) ||
            makeIs(LIBRAW_CAMERAMAKER_Konica))
   {
     if (makeIs(LIBRAW_CAMERAMAKER_Konica) && !strncasecmp(model, "DiMAGE", 6))
     {
       setMakeFromIndex(LIBRAW_CAMERAMAKER_Minolta);
       strcpy(make, "Minolta");
     }
     else
     {
       for (i = 0;
            i<int(sizeof KonicaMinolta_aliases / sizeof *KonicaMinolta_aliases);
            i++)
       {
         if (KonicaMinolta_aliases[i][0] == '@')
         {
           orig = KonicaMinolta_aliases[i] + 1;
           if (!strcmp(model, orig))
           {
             setMakeFromIndex(LIBRAW_CAMERAMAKER_Minolta);
             strcpy(make, "Minolta");
             break;
           }
         }
         else if (!strcasecmp(model, KonicaMinolta_aliases[i]))
         {
           setMakeFromIndex(LIBRAW_CAMERAMAKER_Minolta);
           strcpy(make, "Minolta");
           strcpy(normalized_model, orig);
           break;
         }
       }
     }
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Nikon))
   {
     for (i = 0; i < int(sizeof nikonalias / sizeof *nikonalias); i++)
     {
       if (nikonalias[i][0] == '@')
       {
         orig = nikonalias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, nikonalias[i]))
       {
         strcpy(normalized_model, orig);
         break;
       }
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Olympus)) {
     for (i = 0; i < int(sizeof olyalias / sizeof *olyalias); i++) {
       if (olyalias[i][0] == '@') {
         orig = olyalias[i] + 1;
         if (!strcmp(model, orig)) break;
       } else if (!strcmp(model, olyalias[i])) {
         strcpy(normalized_model, orig);
         break;
       }
     }
 
     if (!OlyID) {
       if (!strcmp(normalized_model, "C-740UZ")) {
         ilm.CamID = OlyID = unique_id = OlyID_C_740UZ;
 
       } else if (!strcmp(normalized_model, "C-770UZ")) {
         ilm.CamID = OlyID = unique_id = OlyID_C_770UZ;
       }
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Panasonic) ||
              makeIs(LIBRAW_CAMERAMAKER_Leica) ||
              makeIs(LIBRAW_CAMERAMAKER_Yuneec))
   {
     for (i = 0; i < int(sizeof panalias / sizeof *panalias); i++)
     {
       if (panalias[i][0] == '@')
       {
         orig = panalias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, panalias[i]))
       {
         setMakeFromIndex(LIBRAW_CAMERAMAKER_Panasonic);
         strcpy(normalized_model, orig);
         break;
       }
     }
   } else if (makeIs(LIBRAW_CAMERAMAKER_Pentax)) {
-
     if (!unique_id) {
       if (!strcmp(model, "Optio S")) {
         ilm.CamID = unique_id = PentaxID_Optio_S;
       } else if (!strcmp(model, "Optio S V1.01")) {
         ilm.CamID = unique_id = PentaxID_Optio_S_V101;
       } else if (!strcmp(model, "Optio S4")) {
         ilm.CamID = unique_id = PentaxID_Optio_S4;
       } else if (!strcmp(model, "Optio 750Z")) {
         ilm.CamID = unique_id = PentaxID_Optio_750Z;
       } else if (!strcmp(model, "Optio 33WR")) {
         ilm.CamID = unique_id = PentaxID_Optio_33WR;
       }
     }
 
     for (i = 0;
     i < int(sizeof SamsungPentax_aliases / sizeof *SamsungPentax_aliases);
     i++) {
       if (SamsungPentax_aliases[i][0] == '@') {
         orig = SamsungPentax_aliases[i] + 1;
         if (!strcmp(model, orig)) break;
       } else if (!strcmp(model, SamsungPentax_aliases[i])) {
         strcpy(normalized_model, orig);
         break;
       }
     }
     if (!strncmp(model, "GR", 2)) {
 	  setMakeFromIndex(LIBRAW_CAMERAMAKER_Ricoh);
       strcpy(make, "Ricoh");
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_PhaseOne))
   {
     for (i = 0; i < int(sizeof phase1alias / sizeof *phase1alias); i++)
     {
       if (phase1alias[i][0] == '@')
       {
         orig = phase1alias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, phase1alias[i]))
       {
         strcpy(normalized_model, orig);
         break;
       }
     }
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Samsung))
   {
     j = 0;
     if (strstr(model, "WB5500") || strstr(model, "HZ50W"))
     {
       strcpy(model, "WB5500");
       j++;
     }
     else if (strstr(model, "WB5000") || strstr(model, "HZ25W"))
     {
       strcpy(model, "WB5000");
       j++;
     }
     else if (strstr(model, "WB550") || strstr(model, "HZ15W"))
     {
       strcpy(model, "WB550");
       j++;
     }
     else if (strstr(model, "WB500") || strstr(model, "HZ10W"))
     {
       strcpy(model, "WB500");
       j++;
     }
     if (j)
     {
       strcpy(normalized_model, model);
     }
     else
     {
       for (i = 0; i < int(sizeof samsungalias / sizeof *samsungalias); i++)
       {
         if (samsungalias[i][0] == '@')
         {
           orig = samsungalias[i] + 1;
           if (!strcmp(model, orig)) break;
         }
         else if (!strcmp(model, samsungalias[i]))
         {
           strcpy(normalized_model, orig);
           break;
         }
       }
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Sony)) {
     if (unique_id)
     {
       for (i = 0; i < int(sizeof sonique / sizeof *sonique); i++)
       {
         if (unique_id == sonique[i].id)
         {
           if (!strcmp(make, "Sony"))
             strcpy(model, sonique[i].t_model);
           strcpy(normalized_model, sonique[i].t_model);
           break;
         }
       }
     }
 
   } else if (makeIs(LIBRAW_CAMERAMAKER_Kodak)) {
     remove_caseSubstr (normalized_model, (char *)"EasyShare");
     remove_caseSubstr (normalized_model, (char *)"ZOOM");
     removeExcessiveSpaces (normalized_model);
     for (i = 0; i < int(sizeof kodakalias / sizeof *kodakalias); i++)
     {
       if (kodakalias[i][0] == '@')
       {
         orig = kodakalias[i] + 1;
         if (!strcmp(model, orig)) break;
       }
       else if (!strcmp(model, kodakalias[i]))
       {
         strcpy(normalized_model, orig);
         break;
       }
     }
 
     if (strstr(model, "DC25"))
     {
       strcpy(model, "DC25");
       strcpy(normalized_model, model);
     }
     else if (!strcmp(model, "40"))
     {
       strcpy(model, "DC40");
       strcpy(normalized_model, model);
     }
     else if (strstr(model, "DC50"))
     {
       strcpy(model, "DC50");
       strcpy(normalized_model, model);
     }
     else if (strstr(model, "DC120"))
     {
       strcpy(model, "DC120");
       strcpy(normalized_model, model);
     }
 
     for (i = 0; i < int(sizeof KodakMonochrome / sizeof *KodakMonochrome); i++)
     {
       if (!strncmp(model, KodakMonochrome[i], strlen(KodakMonochrome[i])))
       {
         colors = 1;
         filters = 0;
       }
     }
   }
 
   if (ilm.body[0])
   {
     if ((ilm.CameraMount != LIBRAW_MOUNT_Hasselblad_V) &&
         !strncmp(ilm.body, "Hasselblad ", 11) &&
         ((ilm.body[11] == 'C') || (ilm.body[11] == '2') ||
          (ilm.body[11] == '5') || (ilm.body[11] == '9')))
     {
       ilm.CameraFormat = LIBRAW_FORMAT_66;
       ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_V;
     }
     else if (!strncmp(ilm.body, "XF", 2) || !strncmp(ilm.body, "645DF", 5))
     {
       ilm.CameraMount = LIBRAW_MOUNT_Mamiya645;
       ilm.CameraFormat = LIBRAW_FORMAT_645;
     }
     else if (!strncmp(ilm.body, "Sinarcam", 2))
     {
       ilm.CameraMount = LIBRAW_MOUNT_LF;
       ilm.CameraFormat = LIBRAW_FORMAT_LF;
       strcat(ilm.body, " shutter system");
     }
   }
 
   if (makeIs(LIBRAW_CAMERAMAKER_Kodak))
   {
     if (((ilm.CameraMount == LIBRAW_MOUNT_DigitalBack) ||
          (ilm.CameraMount == LIBRAW_MOUNT_Unknown)) &&
         !strncmp(model2, "PB645", 5))
     {
       ilm.CameraFormat = LIBRAW_FORMAT_645;
       if (model2[5] == 'C')
       {
         ilm.CameraMount = LIBRAW_MOUNT_Contax645;
         strcpy(ilm.body, "Contax 645");
       }
       else if (model2[5] == 'H')
       {
         ilm.CameraMount = LIBRAW_MOUNT_Hasselblad_H;
         strcpy(ilm.body, "Hasselblad H1/H2");
       }
       else if (model2[5] == 'M')
       {
         ilm.CameraMount = LIBRAW_MOUNT_Mamiya645;
         strcpy(ilm.body, "Mamiya 645");
       }
 
     } else if (!strncasecmp(model, "PIXPRO S-1", 10)) {
       ilm.CameraFormat = LIBRAW_FORMAT_FT;
     } else if (!strncasecmp(model, "PIXPRO ", 7)) {
       ilm.CameraFormat = LIBRAW_FORMAT_1div2p3INCH;
     }
   }
 
   else if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm))
   {
     if (!strncmp(normalized_model, "DBP", 3))
     {
       strcpy(ilm.body, "Fujifilm GX680");
     }
   }
 
   if ((ilm.CameraFormat == LIBRAW_FORMAT_Unknown) ||
       (ilm.CameraMount == LIBRAW_MOUNT_Unknown) ||
       (ilm.CameraMount == LIBRAW_MOUNT_IL_UM))
   {
 
     if (makeIs(LIBRAW_CAMERAMAKER_Canon))
     {
       if (strncmp(normalized_model, "EOS", 3))
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Nikon))
     {
       if (normalized_model[0] == 'D')
       {
         ilm.CameraMount = LIBRAW_MOUNT_Nikon_F;
       }
       else
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Panasonic))
     {
       if (!strncmp(normalized_model, "DC-S", 4))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_FF;
         ilm.CameraMount = LIBRAW_MOUNT_LPS_L;
       }
       else if (!strncmp(normalized_model, "DMC-L1", 6) ||
                !strncmp(normalized_model, "DMC-L10", 7))
       {
         ilm.CameraFormat = ilm.CameraMount = LIBRAW_FORMAT_FT;
       }
       else if (!strncmp(normalized_model + 2, "-G", 2) ||
                !strncmp(normalized_model + 3, "-G", 2))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_FT;
         ilm.CameraMount = LIBRAW_MOUNT_mFT;
       }
       else
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
         ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
         if (!strncmp(normalized_model + 2, "-LX100", 6) || // DC-LX100M2
             !strncmp(normalized_model + 3, "-LX100", 6))
         { // DMC-LX100
           ilm.CameraFormat = ilm.LensFormat = LIBRAW_FORMAT_FT;
         }
         else if (!strncmp(normalized_model, "DMC-CM1", 7))
         {
           ilm.FocalType = LIBRAW_FT_PRIME_LENS;
         }
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm))
     {
       if (!strncmp(normalized_model, "GFX ", 4))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_CROP645;
         ilm.CameraMount = LIBRAW_MOUNT_Fuji_GF;
       }
       else if (!strncmp(normalized_model, "X-", 2) &&
                (strncmp(normalized_model, "X-S1", 4) || !strncmp(normalized_model, "X-S10", 5)))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         ilm.CameraMount = LIBRAW_MOUNT_Fuji_X;
       }
       else if (((normalized_model[0] == 'S') && // S2Pro, S3Pro, S5Pro
                 (normalized_model[2] == 'P')) ||
                !strncasecmp(normalized_model, "IS Pro", 6))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         ilm.CameraMount = LIBRAW_MOUNT_Nikon_F;
       }
       else if (!strncmp(normalized_model, "DBP", 3))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_68;
         ilm.CameraMount = LIBRAW_MOUNT_Fuji_GX;
       }
       else
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Samsung))
     {
       if ((normalized_model[0] == 'N') &&
           (normalized_model[1] == 'X')) // DNG converters delete makernotes
       {
         if ((normalized_model[2] == 'F') && (normalized_model[3] == '1'))
         {
           ilm.CameraMount = LIBRAW_MOUNT_Samsung_NX_M;
           ilm.CameraFormat = LIBRAW_FORMAT_1INCH;
         }
         else
         {
           ilm.CameraMount = LIBRAW_MOUNT_Samsung_NX;
           ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         }
       }
       else
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Kodak))
     {
       ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       for (i = 0; i < int(sizeof Kodak_mounts / sizeof *Kodak_mounts); i++)
       {
         if (!strncmp(normalized_model, Kodak_mounts[i].Kmodel,
                      strlen(Kodak_mounts[i].Kmodel)))
         {
           ilm.CameraMount = Kodak_mounts[i].mount;
           break;
         }
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Minolta))
     {
       if (!strcmp(normalized_model, "DG-5D") ||
           !strcmp(normalized_model, "DG-7D"))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         ilm.CameraMount = LIBRAW_MOUNT_Minolta_A;
       }
       else if (!strncasecmp(normalized_model, "DiMAGE", 6))
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Casio) ||
              makeIs(LIBRAW_CAMERAMAKER_Creative))
     {
       ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Sigma))
     {
       if (!strncmp(normalized_model, "fp", 2))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_FF;
         ilm.CameraMount = LIBRAW_MOUNT_LPS_L;
       }
       else if (!strncasecmp(normalized_model, "SD", 2))
       {
         ilm.CameraMount = LIBRAW_MOUNT_Sigma_X3F;
         if (!strcmp(normalized_model, "SD1") || (normalized_model[4] == 'M'))
         {
           ilm.CameraFormat = LIBRAW_FORMAT_SigmaMerrill;
         }
         else if (normalized_model[11] == 'H')
         { // 'sd Quattro H'
           ilm.CameraFormat = LIBRAW_FORMAT_SigmaAPSH;
         }
         else if (normalized_model[4] == 'Q')
         { // 'sd Quattro'
           ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         }
         else
         {
           ilm.CameraFormat = LIBRAW_FORMAT_SigmaAPSC;
         }
       }
       else if (!strncasecmp(normalized_model, "DP", 2))
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
         if (normalized_model[4] == 'M')
         {
           ilm.CameraFormat = LIBRAW_FORMAT_SigmaMerrill;
         }
         else if (normalized_model[4] == 'Q')
         {
           ilm.CameraFormat = LIBRAW_FORMAT_APSC;
         }
         else
         {
           ilm.CameraFormat = LIBRAW_FORMAT_SigmaAPSC;
         }
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Konica))
     {
       if (!strncmp(model, "KD-", 3))
       { // Konica KD-400Z, KD-510Z
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Mamiya))
     {
       if (!strncmp(normalized_model, "ZD", 2))
       {
         ilm.CameraFormat = LIBRAW_FORMAT_3648;
         ilm.CameraMount = LIBRAW_MOUNT_Mamiya645;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Sony))
     {
       if (!strncmp(normalized_model, "XCD-", 4))
       {
         ilm.CameraMount = LIBRAW_MOUNT_C;
       }
       else if (!strncmp(normalized_model, "DSC-V3", 6) ||
                !strncmp(normalized_model, "DSC-F828", 8))
       {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
         imSony.CameraType = LIBRAW_SONY_DSC;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Polaroid) &&
              !strncmp(normalized_model, "x530", 4))
     {
       ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Rollei) &&
              !strncmp(normalized_model, "d530flex", 8))
     {
       ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Pentax) &&
              !strncmp(normalized_model, "Optio", 5)) {
         ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Epson) &&
              !strncmp(normalized_model, "R-D1", 4))
     {
       ilm.CameraMount = LIBRAW_MOUNT_Leica_M;
       ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     }
   }
 
   if ((ilm.LensMount == LIBRAW_MOUNT_Canon_RF) &&
       (ilm.LensID == 61182)                    &&
       (imCanon.RF_lensID != 0))                {
     ilm.LensID = imCanon.RF_lensID;
   }
 
   if (ilm.LensMount == LIBRAW_MOUNT_Unknown)
   {
     if (makeIs(LIBRAW_CAMERAMAKER_Samsung))
     {
       if ((imgdata.lens.Lens[0] == 'N') &&
           (imgdata.lens.Lens[1] == 'X')) // same DNG problem
       {
         if (imgdata.lens.Lens[2] == '-')
         {
           ilm.LensMount = LIBRAW_MOUNT_Samsung_NX_M;
           ilm.LensFormat = LIBRAW_FORMAT_1INCH;
         }
         else
         {
           ilm.LensMount = LIBRAW_MOUNT_Samsung_NX;
           ilm.LensFormat = LIBRAW_FORMAT_APSC;
         }
       }
     }
   }
 
   if ((ilm.LensID == LIBRAW_LENS_NOT_SET) &&
       xmpdata &&
       (strlen(xmpdata) > 9))
   {
     if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
         try_xml &&
         (ps = strstr(xmpdata, "LensID=\"")))
     {
       ilm.LensID = atoi(ps + 8);
       if (ilm.LensID == 61182)
       {
         ilm.LensMount = ilm.CameraMount = LIBRAW_MOUNT_Canon_RF;
       }
     }
     else if (makeIs(LIBRAW_CAMERAMAKER_Samsung))
     {
       if ((ilm.LensMount == LIBRAW_MOUNT_Samsung_NX) &&
           (ps = strstr(xmpdata, "LensID=\"(")))
       {
         ilm.LensID = atoi(ps + 9);
       }
     }
   }
 
   if (ilm.CameraMount == LIBRAW_MOUNT_FixedLens)
   {
     if (ilm.CameraFormat)
       ilm.LensFormat = ilm.CameraFormat;
     if (ilm.LensMount == LIBRAW_MOUNT_Unknown)
       ilm.LensMount = LIBRAW_MOUNT_FixedLens;
   }
 
   if ((ilm.CameraMount != LIBRAW_MOUNT_Unknown) &&
       (ilm.CameraMount != LIBRAW_MOUNT_FixedLens) &&
       (ilm.LensMount == LIBRAW_MOUNT_Unknown)) {
     if (ilm.LensID == LIBRAW_LENS_NOT_SET) ilm.LensMount = LIBRAW_MOUNT_IL_UM;
     else ilm.LensMount = ilm.CameraMount;
     }
 }
diff --git a/src/metadata/olympus.cpp b/src/metadata/olympus.cpp
index e04b705a..5456ceb2 100644
--- a/src/metadata/olympus.cpp
+++ b/src/metadata/olympus.cpp
@@ -173,87 +173,101 @@ void LibRaw::parseOlympus_Equipment(unsigned tag, unsigned type, unsigned len,
   return;
 }
 void LibRaw::parseOlympus_CameraSettings(int base, unsigned tag, unsigned type,
                                          unsigned len, unsigned dng_writer)
 {
   // uptag 0x2020
 
   int c;
   switch (tag)
   {
   case 0x0101:
     if (dng_writer == nonDNG)
     {
       thumb_offset = get4() + base;
     }
     break;
   case 0x0102:
     if (dng_writer == nonDNG)
     {
       thumb_length = get4();
     }
     break;
   case 0x0200:
     imgdata.shootinginfo.ExposureMode = get2();
     break;
   case 0x0202:
     imgdata.shootinginfo.MeteringMode = get2();
     break;
   case 0x0301:
     imgdata.shootinginfo.FocusMode = imOly.FocusMode[0] = get2();
     if (len == 2)
     {
       imOly.FocusMode[1] = get2();
     }
     break;
   case 0x0304:
     for (c = 0; c < 64; c++)
     {
       imOly.AFAreas[c] = get4();
     }
     break;
   case 0x0305:
     for (c = 0; c < 5; c++)
     {
       imOly.AFPointSelected[c] = getreal(type);
     }
     break;
   case 0x0306:
     imOly.AFFineTune = fgetc(ifp);
     break;
   case 0x0307:
     FORC3 imOly.AFFineTuneAdj[c] = get2();
     break;
   case 0x0401:
     imCommon.FlashEC = getreal(type);
     break;
   case 0x0507:
     imOly.ColorSpace = get2();
     switch (imOly.ColorSpace) {
     case 0:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
       break;
     case 1:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
       break;
     case 2:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_ProPhotoRGB;
       break;
     default:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
       break;
     }
     break;
   case 0x0600:
     imgdata.shootinginfo.DriveMode = imOly.DriveMode[0] = get2();
     for (c = 1; c < (int)len && c < 5; c++)
     {
       imOly.DriveMode[c] = get2();
     }
     break;
+  case 0x0601:
+  	imOly.Panorama_mode = get2();
+  	imOly.Panorama_frameNum = get2();
+  	break;
   case 0x0604:
     imgdata.shootinginfo.ImageStabilization = get4();
     break;
+  case 0x0804:
+    imOly.StackedImage[0] = get4();
+    imOly.StackedImage[1] = get4();
+    if (imOly.StackedImage[0] == 3) {
+      imOly.isLiveND = 1;
+      imOly.LiveNDfactor = imOly.StackedImage[1];
+    } else {
+      imOly.isLiveND = 0;
+    }
+    break;
   }
 
   return;
 }
@@ -261,206 +275,207 @@ void LibRaw::parseOlympus_CameraSettings(int base, unsigned tag, unsigned type,
 void LibRaw::parseOlympus_ImageProcessing(unsigned tag, unsigned type,
                                           unsigned len, unsigned dng_writer)
 {
   // uptag 0x2040
 
   int i, c, wb[4], nWB, tWB, wbG;
   ushort CT;
   short sorder;
 
   if ((tag == 0x0100) && (dng_writer == nonDNG))
   {
     cam_mul[0] = get2() / 256.0;
     cam_mul[2] = get2() / 256.0;
   }
   else if ((tag == 0x0101) && (len == 2) &&
            ((OlyID == OlyID_E_410) || (OlyID == OlyID_E_510)))
   {
     for (i = 0; i < 64; i++)
     {
       icWBCCTC[i][2] = icWBCCTC[i][4] = icWBC[i][1] = icWBC[i][3] = 0x100;
     }
     for (i = 64; i < 256; i++)
     {
       icWBC[i][1] = icWBC[i][3] = 0x100;
     }
   }
   else if ((tag > 0x0101) && (tag <= 0x0111))
   {
     nWB = tag - 0x0101;
     tWB = Oly_wb_list2[nWB << 1];
     CT = Oly_wb_list2[(nWB << 1) | 1];
     wb[0] = get2();
     wb[2] = get2();
     if (tWB != 0x100)
     {
       icWBC[tWB][0] = wb[0];
       icWBC[tWB][2] = wb[2];
     }
     if (CT)
     {
       icWBCCTC[nWB - 1][0] = CT;
       icWBCCTC[nWB - 1][1] = wb[0];
       icWBCCTC[nWB - 1][3] = wb[2];
     }
     if (len == 4)
     {
       wb[1] = get2();
       wb[3] = get2();
       if (tWB != 0x100)
       {
         icWBC[tWB][1] = wb[1];
         icWBC[tWB][3] = wb[3];
       }
       if (CT)
       {
         icWBCCTC[nWB - 1][2] = wb[1];
         icWBCCTC[nWB - 1][4] = wb[3];
       }
     }
   }
   else if ((tag >= 0x0112) && (tag <= 0x011e))
   {
     nWB = tag - 0x0112;
     wbG = get2();
     tWB = Oly_wb_list2[nWB << 1];
     if (nWB)
       icWBCCTC[nWB - 1][2] = icWBCCTC[nWB - 1][4] = wbG;
     if (tWB != 0x100)
       icWBC[tWB][1] = icWBC[tWB][3] = wbG;
   }
   else if (tag == 0x011f)
   {
     wbG = get2();
     if (icWBC[LIBRAW_WBI_Flash][0])
       icWBC[LIBRAW_WBI_Flash][1] =
           icWBC[LIBRAW_WBI_Flash][3] = wbG;
     FORC4 if (icWBC[LIBRAW_WBI_Custom1 + c][0])
         icWBC[LIBRAW_WBI_Custom1 + c][1] =
         icWBC[LIBRAW_WBI_Custom1 + c][3] = wbG;
   }
   else if (tag == 0x0121)
   {
     icWBC[LIBRAW_WBI_Flash][0] = get2();
     icWBC[LIBRAW_WBI_Flash][2] = get2();
     if (len == 4)
     {
       icWBC[LIBRAW_WBI_Flash][1] = get2();
       icWBC[LIBRAW_WBI_Flash][3] = get2();
     }
   }
   else if ((tag == 0x0200) && (dng_writer == nonDNG) &&
            strcmp(software, "v757-71"))
   {
     for (i = 0; i < 3; i++)
     {
       if (!imOly.ColorSpace)
       {
         FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;
       }
       else
       {
         FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;
       }
     }
   }
   else if ((tag == 0x0600) && (dng_writer == nonDNG))
   {
     FORC4 cblack[RGGB_2_RGBG(c)] = get2();
   }
   else if ((tag == 0x0611) && (dng_writer == nonDNG))
   {
      imOly.ValidBits = get2();
   }
   else if ((tag == 0x0612) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
   }
   else if ((tag == 0x0613) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if ((tag == 0x0614) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
   }
   else if ((tag == 0x0615) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   else if ((tag == 0x0805) && (len == 2))
   {
     imOly.SensorCalibration[0] = getreal(type);
     imOly.SensorCalibration[1] = getreal(type);
     if ((dng_writer == nonDNG) && (OlyID != OlyID_XZ_1))
       FORC4 imgdata.color.linear_max[c] = imOly.SensorCalibration[0];
   }
   else if (tag == 0x1112)
   {
     sorder = order;
     order = 0x4d4d;
     c = get2();
     order = sorder;
     switch (c) {
     case 0x0101:
     case 0x0901:
     case 0x0909:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 0x0104:
     case 0x0401:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 0x0201:
     case 0x0202:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 0x0301:
     case 0x0303:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 0x0404:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_6to6;
+//      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_6to6;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 0x0505:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
       break;
     case 0x0606:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_7to6;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_7to6;
       break;
     case 0x0707:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_6to5;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_6to5;
       break;
     case 0x0808:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_7to5;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_7to5;
       break;
     default:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
       break;
     }
   }
   else if (tag == 0x1113)
   {
     imOly.AspectFrame[0] = get2();
     imOly.AspectFrame[1] = get2();
     imOly.AspectFrame[2] = get2();
     imOly.AspectFrame[3] = get2();
   }
   else if (tag == 0x1306)
   {
     c = get2();
     if ((c != 0) && (c != 100))
     {
       if (c < 61)
         imCommon.CameraTemperature = (float)c;
       else
         imCommon.CameraTemperature = (float)(c - 32) / 1.8f;
       if ((imCommon.exifAmbientTemperature > -273.15f) &&
           ((OlyID == OlyID_TG_5) ||
            (OlyID == OlyID_TG_6))
       )
         imCommon.CameraTemperature += imCommon.exifAmbientTemperature;
     }
   }
 
   return;
 }
@@ -468,65 +483,65 @@ void LibRaw::parseOlympus_ImageProcessing(unsigned tag, unsigned type,
 void LibRaw::parseOlympus_RawInfo(unsigned tag, unsigned type, unsigned len,
                                   unsigned dng_writer)
 {
   // uptag 0x3000
 
   int wb_ind, c, i;
 
   if ((tag == 0x0110) && strcmp(software, "v757-71"))
   {
     icWBC[LIBRAW_WBI_Auto][0] = get2();
     icWBC[LIBRAW_WBI_Auto][2] = get2();
     if (len == 2)
     {
       for (i = 0; i < 256; i++)
         icWBC[i][1] = icWBC[i][3] = 0x100;
     }
   }
   else if ((((tag >= 0x0120) && (tag <= 0x0124)) ||
             ((tag >= 0x0130) && (tag <= 0x0133))) &&
            strcmp(software, "v757-71"))
   {
     if (tag <= 0x0124)
       wb_ind = tag - 0x0120;
     else
       wb_ind = tag - 0x0130 + 5;
 
     icWBC[Oly_wb_list1[wb_ind]][0] = get2();
     icWBC[Oly_wb_list1[wb_ind]][2] = get2();
   }
   else if ((tag == 0x0200) && (dng_writer == nonDNG))
   {
     for (i = 0; i < 3; i++)
     {
       if (!imOly.ColorSpace)
       {
         FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;
       }
       else
       {
         FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;
       }
     }
   }
   else if ((tag == 0x0600) && (dng_writer == nonDNG))
   {
     FORC4 cblack[RGGB_2_RGBG(c)] = get2();
   }
   else if ((tag == 0x0612) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
   }
   else if ((tag == 0x0613) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if ((tag == 0x0614) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
   }
   else if ((tag == 0x0615) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   return;
 }
@@ -535,136 +550,136 @@ void LibRaw::parseOlympus_RawInfo(unsigned tag, unsigned type, unsigned len,
 void LibRaw::parseOlympusMakernotes (int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer) {
 
   int c;
-  unsigned a, b;
+  unsigned a;
   if ((tag >= 0x20100000) && (tag <= 0x2010ffff)) {
         parseOlympus_Equipment((tag & 0x0000ffff), type, len, dng_writer);
 
   } else if ((tag >= 0x20200000) && (tag <= 0x2020ffff)) {
     parseOlympus_CameraSettings(base, (tag & 0x0000ffff), type, len, dng_writer);
 
   } else if ((tag >= 0x20400000) && (tag <= 0x2040ffff)) {
      parseOlympus_ImageProcessing((tag & 0x0000ffff), type, len, dng_writer);
 
   } else if ((tag >= 0x30000000) && (tag <= 0x3000ffff)) {
         parseOlympus_RawInfo((tag & 0x0000ffff), type, len, dng_writer);
 
   } else {
 		switch (tag) {
 			case 0x0200:
 			  FORC3 if ((imOly.SpecialMode[c] = get4()) >= 0xff) imOly.SpecialMode[c] = 0xffffffff;
 			  break;
 			case 0x0207:
 				getOlympus_CameraType2();
 				break;
 			case 0x0404:
 			case 0x101a:
 				if (!imgdata.shootinginfo.BodySerial[0] && (dng_writer == nonDNG))
 					stmread(imgdata.shootinginfo.BodySerial, len, ifp);
 				break;
 			case 0x1002:
 				ilm.CurAp = libraw_powf64l(2.0f, getreal(type) / 2);
 				break;
 			case 0x1007:
 				imCommon.SensorTemperature = (float)get2();
 				break;
 			case 0x1008:
 				imCommon.LensTemperature = (float)get2();
 				break;
 			case 0x100b:
 				if (imOly.FocusMode[0] == 0xffff) {
 					imgdata.shootinginfo.FocusMode = imOly.FocusMode[0] = get2();
 					if (imgdata.shootinginfo.FocusMode == 1)
 						imgdata.shootinginfo.FocusMode = imOly.FocusMode[0] = 10;
 				}
 				break;
       case 0x100d:
         if (imOly.ZoomStepCount == 0xffff) imOly.ZoomStepCount = get2();
         break;
       case 0x100e:
         if (imOly.FocusStepCount == 0xffff) imOly.FocusStepCount = get2();
         break;
 			case 0x1011:
 				if (strcmp(software, "v757-71") && (dng_writer == nonDNG)) {
 					for (int i = 0; i < 3; i++) {
 						if (!imOly.ColorSpace) {
 							FORC3 cmatrix[i][c] = ((short)get2()) / 256.0;
 						} else {
 							FORC3 imgdata.color.ccm[i][c] = ((short)get2()) / 256.0;
 						}
 					}
 				}
 				break;
 			case 0x1012:
 			  if (dng_writer == nonDNG)
 				  FORC4 cblack[RGGB_2_RGBG(c)] = get2();
 				break;
 			case 0x1017:
 				if (dng_writer == nonDNG)
 				  cam_mul[0] = get2() / 256.0;
 				break;
 			case 0x1018:
 				if (dng_writer == nonDNG)
 				  cam_mul[2] = get2() / 256.0;
 				break;
 			case 0x102c:
 				if (dng_writer == nonDNG)
 				  imOly.ValidBits = get2();
 				break;
 			case 0x1038:
 				imOly.AFResult = get2();
 				break;
       case 0x103b:
         if (imOly.FocusStepInfinity == 0xffff) imOly.FocusStepInfinity = get2();
         break;
       case 0x103c:
         if (imOly.FocusStepNear == 0xffff) imOly.FocusStepNear = get2();
         break;
 			case 0x20300108:
 			case 0x20310109:
 				if (dng_writer == nonDNG) {
           imOly.ColorSpace = get2();
           switch (imOly.ColorSpace) {
           case 0:
             imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
             break;
           case 1:
             imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
             break;
           case 2:
             imCommon.ColorSpace = LIBRAW_COLORSPACE_ProPhotoRGB;
             break;
           default:
             imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
             break;
           }
 				}
 			case 0x20500209:
 				imOly.AutoFocus = get2();
 				break;
 			case 0x20500300:
 			  imOly.ZoomStepCount = get2();
 			  break;
 			case 0x20500301:
 			  imOly.FocusStepCount = get2();
 			  break;
 			case 0x20500303:
 			  imOly.FocusStepInfinity = get2();
 			  break;
 			case 0x20500304:
 			  imOly.FocusStepNear = get2();
 			  break;
 			case 0x20500305:
 			  a = get4();
-			  b = get4();
+			  /*b = */ get4(); // b is not used, so removed
 			  if (a >= 0x7f000000) imOly.FocusDistance = -1.0; // infinity
 			  else imOly.FocusDistance = (double) a / 1000.0;  // convert to meters
 			  break;
 			case 0x20500308:
 				imOly.AFPoint = get2();
 				break;
 			case 0x20501500:
 				getOlympus_SensorTemperature(len);
 				break;
 		}
   }
 }
diff --git a/src/metadata/pentax.cpp b/src/metadata/pentax.cpp
index 9ba2365b..559b3570 100644
--- a/src/metadata/pentax.cpp
+++ b/src/metadata/pentax.cpp
@@ -19,81 +19,83 @@
 void LibRaw::setPentaxBodyFeatures(unsigned long long id)
 {
 
   ilm.CamID = id;
 
   switch (id) {
   case PentaxID_staristD:
   case PentaxID_staristDS:
   case PentaxID_staristDL:
   case PentaxID_staristDS2:
   case PentaxID_GX_1S:
   case PentaxID_staristDL2:
   case PentaxID_GX_1L:
   case PentaxID_K100D:
   case PentaxID_K110D:
   case PentaxID_K100D_Super:
   case PentaxID_K10D:
   case PentaxID_GX10:
   case PentaxID_K20D:
   case PentaxID_GX20:
   case PentaxID_K200D:
   case PentaxID_K2000:
   case PentaxID_K_m:
   case PentaxID_K_7:
   case PentaxID_K_x:
   case PentaxID_K_r:
   case PentaxID_K_5:
   case PentaxID_K_01:
   case PentaxID_K_30:
   case PentaxID_K_5_II:
   case PentaxID_K_5_II_s:
   case PentaxID_K_50:
   case PentaxID_K_3:
   case PentaxID_K_500:
   case PentaxID_K_S1:
   case PentaxID_K_S2:
   case PentaxID_K_3_II:
+  case PentaxID_K_3_III:
   case PentaxID_K_70:
   case PentaxID_KP:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_K;
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     break;
   case PentaxID_K_1:
   case PentaxID_K_1_Mark_II:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_K;
     ilm.CameraFormat = LIBRAW_FORMAT_FF;
     break;
   case PentaxID_645D:
   case PentaxID_645Z:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_645;
     ilm.CameraFormat = LIBRAW_FORMAT_CROP645;
     break;
   case PentaxID_Q:
   case PentaxID_Q10:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_Q;
     ilm.CameraFormat = LIBRAW_FORMAT_1div2p3INCH;
     break;
   case PentaxID_Q7:
   case PentaxID_Q_S1:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_Q;
     ilm.CameraFormat = LIBRAW_FORMAT_1div1p7INCH;
     break;
   case PentaxID_MX_1:
     ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     ilm.CameraFormat = LIBRAW_FORMAT_1div1p7INCH;
     ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
     break;
   case PentaxID_GR_III:
+  case PentaxID_GR_IIIx:
     ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     ilm.LensFormat = LIBRAW_FORMAT_APSC;
     ilm.FocalType = LIBRAW_FT_PRIME_LENS;
     break;
   default:
     ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
   }
   return;
 }
@@ -236,271 +238,282 @@ void LibRaw::PentaxLensInfo(unsigned long long id, unsigned len) // tag 0x0207
 void LibRaw::parsePentaxMakernotes(int base, unsigned tag, unsigned type,
                                    unsigned len, unsigned dng_writer)
 {
 
   int c;
 // printf ("==>> =%s= tag:0x%x, type: %d, len:%d\n", model, tag, type, len);
 
   if (tag == 0x0005)
   {
     unique_id = get4();
     setPentaxBodyFeatures(unique_id);
   }
   else if (tag == 0x0008)
   { /* 4 is raw, 7 is raw w/ pixel shift, 8 is raw w/ dynamic pixel shift */
     imPentax.Quality = get2();
   }
   else if (tag == 0x000d)
   {
     imgdata.shootinginfo.FocusMode = imPentax.FocusMode[0] = get2();
   }
   else if (tag == 0x000e)
   {
     imgdata.shootinginfo.AFPoint = imPentax.AFPointSelected[0] = get2();
     if (len == 2)
       imPentax.AFPointSelected_Area = get2();
   }
   else if (tag == 0x000f)
   {
     if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
     {
       imPentax.AFPointsInFocus = get4();
       if (!imPentax.AFPointsInFocus) imPentax.AFPointsInFocus = 0xffffffff;
       else imPentax.AFPointsInFocus_version = 3;
     }
     else if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
     {
       imPentax.AFPointsInFocus = (unsigned) get2();
       if (imPentax.AFPointsInFocus == 0x0000ffff)
         imPentax.AFPointsInFocus = 0xffffffff;
       else imPentax.AFPointsInFocus_version = 2;
     }
   }
   else if (tag == 0x0010)
   {
     imPentax.FocusPosition = get2();
   }
   else if (tag == 0x0013)
   {
     ilm.CurAp = (float)get2() / 10.0f;
   }
   else if (tag == 0x0014)
   {
     PentaxISO(get2());
   }
   else if (tag == 0x0017)
   {
     imgdata.shootinginfo.MeteringMode = get2();
   }
   else if (tag == 0x001b) {
     cam_mul[2] = get2() / 256.0;
   }
   else if (tag == 0x001c) {
     cam_mul[0] = get2() / 256.0;
   }
   else if (tag == 0x001d)
   {
     ilm.CurFocal = (float)get4() / 100.0f;
   }
   else if (tag == 0x0034)
   {
     uchar uc;
     FORC4
     {
       fread(&uc, 1, 1, ifp);
       imPentax.DriveMode[c] = uc;
     }
     imgdata.shootinginfo.DriveMode = imPentax.DriveMode[0];
   }
   else if (tag == 0x0037) {
     switch (get2()) {
     case 0:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
       break;
     case 1:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
       break;
     default:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
       break;
     }
   }
   else if (tag == 0x0038)
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if (tag == 0x0039)
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   else if (tag == 0x003c)
   {
-    if ((len == 4) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED))
+    if ((len == 4) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED)) {
       imPentax.AFPointsInFocus = get4() & 0x7ff;
-      if (!imPentax.AFPointsInFocus) imPentax.AFPointsInFocus = 0xffffffff;
-      else imPentax.AFPointsInFocus_version = 1;
+      if (!imPentax.AFPointsInFocus) {
+        imPentax.AFPointsInFocus = 0xffffffff;
+      }
+      else {
+        imPentax.AFPointsInFocus_version = 1;
+      }
+    }
   }
   else if (tag == 0x003f)
   {
     unsigned a = unsigned(fgetc(ifp)) << 8;
     ilm.LensID = a | fgetc(ifp);
   }
   else if (tag == 0x0047)
   {
     imCommon.CameraTemperature = (float)fgetc(ifp);
   }
   else if (tag == 0x004d)
   {
     if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SLONG))
       imCommon.FlashEC = getreal(type) / 256.0f;
     else
       imCommon.FlashEC = (float)((signed short)fgetc(ifp)) / 6.0f;
   }
   else if (tag == 0x005c)
   {
     fgetc(ifp);
     imgdata.shootinginfo.ImageStabilization = (short)fgetc(ifp);
   }
   else if (tag == 0x0072)
   {
     imPentax.AFAdjustment = get2();
   }
   else if ((tag == 0x007e) && (dng_writer == nonDNG))
   {
     imgdata.color.linear_max[0] = imgdata.color.linear_max[1] =
         imgdata.color.linear_max[2] = imgdata.color.linear_max[3] =
             get4();
   }
   else if (tag == 0x0080)
   {
     short a = (short)fgetc(ifp);
     switch (a)
     {
     case 0:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 1:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 2:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 3:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     }
   }
 
   else if ((tag == 0x0200) && (dng_writer == nonDNG)) { // Pentax black level
     FORC4 cblack[RGGB_2_RGBG(c)] = get2();
   }
 
   else if ((tag == 0x0201) && (dng_writer == nonDNG)) { // Pentax As Shot WB
     FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();
   }
 
   else if ((tag == 0x0203) && (dng_writer == nonDNG))
   {
     for (int i = 0; i < 3; i++)
       FORC3 cmatrix[i][c] = ((short)get2()) / 8192.0;
   }
   else if (tag == 0x0205)
   {
     if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
     {
       imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
       imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
       imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
       imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
       fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
       if ((len < 25) && (len >= 11))
       {
         imPentax.AFPointMode = (imCommon.afdata[imCommon.afcount].AFInfoData[3] >>4) & 0x0f;
         imPentax.FocusMode[1] = imCommon.afdata[imCommon.afcount].AFInfoData[3] & 0x0f;
         imPentax.AFPointSelected[1] = sget2(imCommon.afdata[imCommon.afcount].AFInfoData+4);
 // Pentax K-m has multiexposure set to 8 when no multi-exposure is in effect
         imPentax.MultiExposure = imCommon.afdata[imCommon.afcount].AFInfoData[10] & 0x0f;
       }
       imCommon.afcount++;
     }
   }
   else if (tag == 0x0207)
   {
     if (len < 65535) // Safety belt
       PentaxLensInfo(ilm.CamID, len);
   }
   else if ((tag >= 0x020d) && (tag <= 0x0214))
   {
     FORC4 icWBC[Pentax_wb_list1[tag - 0x020d]][RGGB_2_RGBG(c)] = get2();
   }
+  else if ((tag == 0x021d) && (len == 18) &&
+           tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) && (dng_writer == nonDNG))
+  {
+    for (int i = 0; i < 3; i++)
+      FORC3 cmatrix[i][c] = ((short)get2()) / 8192.0;
+  }
   else if (tag == 0x021f)
   {
     if ((unique_id != PentaxID_K_1)    &&
         (unique_id != PentaxID_K_3)    &&
         (unique_id != PentaxID_K_3_II) &&
         (unique_id != PentaxID_K_1_Mark_II))
     {
       fseek (ifp, 0x0b, SEEK_CUR);
       imPentax.AFPointsInFocus = (unsigned) fgetc(ifp);
       if (!imPentax.AFPointsInFocus) imPentax.AFPointsInFocus = 0xffffffff;
       else imPentax.AFPointsInFocus_version = 4;
     }
   }
   else if ((tag == 0x0220) && (dng_writer == nonDNG)) {
     meta_offset = ftell(ifp);
   }
   else if (tag == 0x0221)
   {
     int nWB = get2();
     if (nWB <= int(sizeof(icWBCCTC) / sizeof(icWBCCTC[0])))
       FORC(nWB)
       {
         icWBCCTC[c][0] = (unsigned)0xcfc6 - get2();
         fseek(ifp, 2, SEEK_CUR);
         icWBCCTC[c][1] = get2();
         icWBCCTC[c][2] = icWBCCTC[c][4] = 0x2000;
         icWBCCTC[c][3] = get2();
       }
   }
   else if (tag == 0x0215)
   {
     fseek(ifp, 16, SEEK_CUR);
     sprintf(imgdata.shootinginfo.InternalBodySerial, "%d", get4());
   }
   else if (tag == 0x0229)
   {
     stmread(imgdata.shootinginfo.BodySerial, len, ifp);
   }
   else if (tag == 0x022d)
   {
     int wb_ind;
     getc(ifp);
-    for (int wb_cnt = 0; wb_cnt < Pentax_wb_list2.size(); wb_cnt++)
+    for (int wb_cnt = 0; wb_cnt < (int)Pentax_wb_list2.size(); wb_cnt++)
     {
       wb_ind = getc(ifp);
-      if (wb_ind >= 0 && wb_ind < Pentax_wb_list2.size() )
+      if (wb_ind >= 0 && wb_ind < (int)Pentax_wb_list2.size() )
         FORC4 icWBC[Pentax_wb_list2[wb_ind]][RGGB_2_RGBG(c)] = get2();
     }
   }
   else if (tag == 0x0239) // Q-series lens info (LensInfoQ)
   {
     char LensInfo[20];
     fseek(ifp, 12, SEEK_CUR);
     stread(ilm.Lens, 30, ifp);
     strcat(ilm.Lens, " ");
     stread(LensInfo, 20, ifp);
     strcat(ilm.Lens, LensInfo);
   }
   else if (tag == 0x0245)
   {
     if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT) {
       imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
       imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
       imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
       imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
       fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
       imCommon.afcount++;
     }
   }
 }
diff --git a/src/metadata/sony.cpp b/src/metadata/sony.cpp
index 7621a618..8366813b 100644
--- a/src/metadata/sony.cpp
+++ b/src/metadata/sony.cpp
@@ -98,324 +98,379 @@ void LibRaw::sony_decrypt(unsigned *data, int len, int start, int key)
 {
 #ifndef LIBRAW_NOTHREADS
 #define pad tls->sony_decrypt.pad
 #define p tls->sony_decrypt.p
 #else
   static unsigned pad[128], p;
 #endif
   if (start)
   {
     for (p = 0; p < 4; p++)
       pad[p] = key = key * 48828125ULL + 1;
     pad[3] = pad[3] << 1 | (pad[0] ^ pad[2]) >> 31;
     for (p = 4; p < 127; p++)
       pad[p] = (pad[p - 4] ^ pad[p - 2]) << 1 | (pad[p - 3] ^ pad[p - 1]) >> 31;
     for (p = 0; p < 127; p++)
       pad[p] = htonl(pad[p]);
   }
   while (len--)
   {
     *data++ ^= pad[p & 127] = pad[(p + 1) & 127] ^ pad[(p + 65) & 127];
     p++;
   }
 #ifndef LIBRAW_NOTHREADS
 #undef pad
 #undef p
 #endif
 }
 void LibRaw::setSonyBodyFeatures(unsigned long long id)
 {
   static const struct
   {
     ushort scf[11];
     /*
     scf[0]  camera id
     scf[1]  camera format
     scf[2]  camera mount: Minolta A, Sony E, fixed,
     scf[3]  camera type: DSLR, NEX, SLT, ILCE, ILCA, DSC
-    scf[4]  lens mount
+    scf[4]  lens mount, LIBRAW_MOUNT_FixedLens or LIBRAW_MOUNT_Unknown
     scf[5]  tag 0x2010 group (0 if not used)
     scf[6]  offset of Sony ISO in 0x2010 table, 0xffff if not valid
     scf[7]  offset of ShutterCount3 in 0x9050 table, 0xffff if not valid
     scf[8]  offset of MeteringMode in 0x2010 table, 0xffff if not valid
     scf[9]  offset of ExposureProgram in 0x2010 table, 0xffff if not valid
     scf[10] offset of ReleaseMode2 in 0x2010 table, 0xffff if not valid
     */
   } SonyCamFeatures[] = {
-      {SonyID_DSLR_A100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A700, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A200, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A350, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A900, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A380, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A330, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A230, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A850, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A850, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A550, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A450, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_5, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A33, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A55, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A560, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A580, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_C3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A35, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A65, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_SLT_A77, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_NEX_5N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 1,
-       0x113e, 0x01bd, 0x1174, 0x1175, 0x112c},
-      {SonyID_NEX_7, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_NEX_VG20, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_SLT_A37, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_SLT_A57, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_NEX_F3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_SLT_A99, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_6, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_5R, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX100, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1254, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_VG900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_VG30, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_3000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_SLT_A58, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_3N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_7, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_NEX_5T, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX100M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 6, 0x113c, 0xffff, 0x1064, 0x1065, 0x1018},
-      {SonyID_DSC_RX10, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX1R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_7R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_6000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_5000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01aa, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7S, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_77M2, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0,
-       7, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_5100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX1RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_QX1, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7SM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_68, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0,
-       7, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_99M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M5, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_6300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_9, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7RM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7M3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX0, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX100M6, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_HX99, LIBRAW_FORMAT_1div2p3INCH, LIBRAW_MOUNT_FixedLens,
-       LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b,
-       0x024c, 0x0208},
-      {SonyID_DSC_RX100M5A, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6400, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX0M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX100M7, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7RM4, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_9M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6600, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ZV_1, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7C, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7SM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSLR_A100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A700, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A200, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A350, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A900, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A380, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A330, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A230, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A850, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A850, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A550, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A450, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_5, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A33, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A55, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A560, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A580, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_C3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A35, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A65, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_SLT_A77, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_NEX_5N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010a, 0x113e, 0x01bd, 0x1174, 0x1175, 0x112c},
+      {SonyID_NEX_7, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_NEX_VG20, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_SLT_A37, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_SLT_A57, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_NEX_F3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_SLT_A99, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_6, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_5R, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX100, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_VG900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_VG30, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_3000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_SLT_A58, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_3N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_7, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_NEX_5T, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX100M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010f, 0x113c, 0xffff, 0x1064, 0x1065, 0x1018},
+      {SonyID_DSC_RX10, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX1R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_7R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_6000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_5000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01aa, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7S, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_77M2, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_5100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX1RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_QX1, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7SM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_68, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_99M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M5, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_6300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_9, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7RM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7M3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX0, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M6, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_HX99, LIBRAW_FORMAT_1div2p3INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M5A, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6400, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX0M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M7, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7RM4, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_9M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6600, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ZV_1, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7C, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+
+// a la SonyID_ILCE_6100
+      {SonyID_ZV_E10, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+
+      {SonyID_ILCE_7SM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILCE_1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILME_FX3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILCE_7RM3A, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7RM4A, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
   };
   ilm.CamID = id;
 
   if (id == SonyID_DSC_R1)
   {
     ilm.CameraMount = ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     imSony.CameraType = LIBRAW_SONY_DSC;
+    imSony.group2010 = LIBRAW_SONY_Tag2010None;
+    imSony.group9050 = LIBRAW_SONY_Tag9050None;
     return;
   }
 
-  for (int i = 0; i < (sizeof SonyCamFeatures / sizeof *SonyCamFeatures); i++) {
+  for (unsigned i = 0; i < (sizeof SonyCamFeatures / sizeof *SonyCamFeatures); i++) {
     if (SonyCamFeatures[i].scf[0] == id) {
       ilm.CameraFormat = SonyCamFeatures[i].scf[1];
       ilm.CameraMount = SonyCamFeatures[i].scf[2];
       imSony.CameraType = SonyCamFeatures[i].scf[3];
       if (SonyCamFeatures[i].scf[4])
         ilm.LensMount = SonyCamFeatures[i].scf[4];
       imSony.group2010 = SonyCamFeatures[i].scf[5];
       imSony.real_iso_offset = SonyCamFeatures[i].scf[6];
       imSony.ImageCount3_offset = SonyCamFeatures[i].scf[7];
       imSony.MeteringMode_offset = SonyCamFeatures[i].scf[8];
       imSony.ExposureProgram_offset = SonyCamFeatures[i].scf[9];
       imSony.ReleaseMode2_offset = SonyCamFeatures[i].scf[10];
       break;
     }
   }
 
+  switch (id) {
+  case SonyID_ILCE_6100:
+  case SonyID_ILCE_6300:
+  case SonyID_ILCE_6400:
+  case SonyID_ILCE_6500:
+  case SonyID_ILCE_6600:
+  case SonyID_ILCE_7C:
+  case SonyID_ILCE_7M3:
+  case SonyID_ILCE_7RM2:
+  case SonyID_ILCE_7RM3A:
+  case SonyID_ILCE_7RM3:
+  case SonyID_ILCE_7RM4:
+  case SonyID_ILCE_7RM4A:
+  case SonyID_ILCE_7SM2:
+  case SonyID_ILCE_9:
+  case SonyID_ILCE_9M2:
+  case SonyID_ILCA_99M2:
+  case SonyID_ZV_E10:
+    imSony.group9050 = LIBRAW_SONY_Tag9050b;
+    break;
+  case SonyID_ILCE_7SM3:
+  case SonyID_ILCE_1:
+  case SonyID_ILME_FX3:
+    imSony.group9050 = LIBRAW_SONY_Tag9050c;
+    break;
+  default:
+    if ((imSony.CameraType != LIBRAW_SONY_DSC) &&
+        (imSony.CameraType != LIBRAW_SONY_DSLR))
+      imSony.group9050 = LIBRAW_SONY_Tag9050a;
+    else
+      imSony.group9050 = LIBRAW_SONY_Tag9050None;
+    break;
+  }
+
   char *sbstr = strstr(software, " v");
   if (sbstr != NULL)
   {
     sbstr += 2;
     strcpy(imCommon.firmware, sbstr);
     imSony.firmware = atof(sbstr);
 
     if ((id == SonyID_ILCE_7) ||
         (id == SonyID_ILCE_7R))
     {
       if (imSony.firmware < 1.2f)
         imSony.ImageCount3_offset = 0x01aa;
       else
         imSony.ImageCount3_offset = 0x01c0;
     }
     else if (id == SonyID_ILCE_6000)
     {
       if (imSony.firmware < 2.0f)
         imSony.ImageCount3_offset = 0x01aa;
       else
         imSony.ImageCount3_offset = 0x01c0;
     }
     else if ((id == SonyID_ILCE_7S) ||
              (id == SonyID_ILCE_7M2))
     {
       if (imSony.firmware < 1.2f)
         imSony.ImageCount3_offset = 0x01a0;
       else
         imSony.ImageCount3_offset = 0x01b6;
     }
   }
+
+  if ((id == SonyID_ILCE_7SM3) &&
+      !strcmp(model, "MODEL-NAME")) {
+    imSony.group9050 = LIBRAW_SONY_Tag9050a;
+  }
+
 }
 
 void LibRaw::parseSonyLensType2(uchar a, uchar b)
 {
   ushort lid2;
   lid2 = (((ushort)a) << 8) | ((ushort)b);
   if (!lid2)
     return;
   if (lid2 < 0x100)
   {
     if ((ilm.AdapterID != 0x4900) && (ilm.AdapterID != 0xef00))
     {
       ilm.AdapterID = lid2;
       switch (lid2)
       {
-      case 1: // Sony LA-EA1 or Sigma MC-11 Adapter
-      case 2: // Sony LA-EA2
-      case 3: // Sony LA-EA3
-      case 6: // Sony LA-EA4
-      case 7: // Sony LA-EA5
+      case     1: // Sony LA-EA1 or Sigma MC-11 Adapter
+      case     2: // Sony LA-EA2
+      case     3: // Sony LA-EA3
+      case     6: // Sony LA-EA4
+      case     7: // Sony LA-EA5
+      case 24593: // LA-EA4r MonsterAdapter, id = 0x6011
         ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
         break;
       case  44: // Metabones Canon EF Smart Adapter
       case  78: // Metabones Canon EF Smart Adapter Mark III or Other Adapter
       case 184: // Metabones Canon EF Speed Booster Ultra
       case 234: // Metabones Canon EF Smart Adapter Mark IV
       case 239: // Metabones Canon EF Speed Booster
         ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
         break;
       }
     }
   }
   else
     ilm.LensID = lid2;
 
   if ((lid2 >= 50481) &&
       (lid2 < 50500)) {
     strcpy(ilm.Adapter, "MC-11");
     ilm.AdapterID = 0x4900;
   } else if ((lid2 > 0xef00) &&
              (lid2 < 0xffff) &&
              (lid2 != 0xff00)) {
     ilm.AdapterID = 0xef00;
     ilm.LensID -= ilm.AdapterID;
     ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
   }
 
   return;
 }
@@ -517,33 +572,33 @@ void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)
 
 void LibRaw::process_Sony_0x2010(uchar *buf, ushort len)
 {
-  if (!imSony.group2010)
-    return;
+
+  if (imSony.group2010 == LIBRAW_SONY_Tag2010None) return;
 
   if ((imSony.real_iso_offset != 0xffff) &&
       (len >= (imSony.real_iso_offset + 2)) && (imCommon.real_ISO < 0.1f))
   {
     uchar s[2];
     s[0] = SonySubstitution[buf[imSony.real_iso_offset]];
     s[1] = SonySubstitution[buf[imSony.real_iso_offset + 1]];
     imCommon.real_ISO =
         100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));
   }
 
   if ((imSony.MeteringMode_offset != 0xffff) &&
       (imSony.ExposureProgram_offset != 0xffff) &&
       (len >= (imSony.MeteringMode_offset + 2)))
   {
     imgdata.shootinginfo.MeteringMode =
         SonySubstitution[buf[imSony.MeteringMode_offset]];
     imgdata.shootinginfo.ExposureProgram =
         SonySubstitution[buf[imSony.ExposureProgram_offset]];
   }
 
   if ((imSony.ReleaseMode2_offset != 0xffff) &&
       (len >= (imSony.ReleaseMode2_offset + 2)))
   {
     imgdata.shootinginfo.DriveMode =
         SonySubstitution[buf[imSony.ReleaseMode2_offset]];
   }
 }
@@ -551,189 +606,162 @@ void LibRaw::process_Sony_0x2010(uchar *buf, ushort len)
 void LibRaw::process_Sony_0x9050(uchar *buf, ushort len, unsigned long long id)
 {
   ushort lid;
   uchar s[4];
   int c;
 
-  if ((id == SonyID_ILCE_7SM3) &&
-      strcmp(model, "MODEL-NAME")) // ? check the firmware version instead ?
-  {
-    if (len <= 0x8d)
-      return;
-    unsigned long long b88 = SonySubstitution[buf[0x88]];
-    unsigned long long b89 = SonySubstitution[buf[0x89]];
-    unsigned long long b8a = SonySubstitution[buf[0x8a]];
-    unsigned long long b8b = SonySubstitution[buf[0x8b]];
-    unsigned long long b8c = SonySubstitution[buf[0x8c]];
-    unsigned long long b8d = SonySubstitution[buf[0x8d]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%06llx",
-            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) +
-                b8d);
-    return;
-  }
+  if ((imSony.group9050 == LIBRAW_SONY_Tag9050None) &&
+      (imSony.CameraType != LIBRAW_SONY_DSC) &&
+      (imSony.CameraType != LIBRAW_SONY_DSLR))
+    imSony.group9050 = LIBRAW_SONY_Tag9050a;
+
+  if (imSony.group9050 == LIBRAW_SONY_Tag9050None) return;
 
   if ((ilm.CameraMount != LIBRAW_MOUNT_Sony_E) &&
-      (ilm.CameraMount != LIBRAW_MOUNT_FixedLens))
+      (imSony.CameraType != LIBRAW_SONY_DSC))
   {
     if (len < 2)
       return;
     if (buf[0])
       ilm.MaxAp4CurFocal =
         my_roundf(
           libraw_powf64l(2.0f, ((float)SonySubstitution[buf[0]] / 8.0 - 1.06f) / 2.0f) *
              10.0f) / 10.0f;
 
     if (buf[1])
       ilm.MinAp4CurFocal =
         my_roundf(
           libraw_powf64l(2.0f, ((float)SonySubstitution[buf[1]] / 8.0 - 1.06f) / 2.0f) *
              10.0f) / 10.0f;
   }
 
-  if ((id == SonyID_ILCE_6100) ||
-      (id == SonyID_ILCE_6300) ||
-      (id == SonyID_ILCE_6400) ||
-      (id == SonyID_ILCE_6500) ||
-      (id == SonyID_ILCE_6600) ||
-      (id == SonyID_ILCE_7C)   ||
-      (id == SonyID_ILCE_7M3)  ||
-      (id == SonyID_ILCE_7RM2) ||
-      (id == SonyID_ILCE_7RM3) ||
-      (id == SonyID_ILCE_7RM4) ||
-      (id == SonyID_ILCE_7SM2) ||
-      (id == SonyID_ILCE_9)    ||
-      (id == SonyID_ILCE_9M2)  ||
-      (id == SonyID_ILCA_99M2)) // 9050 ver.b
-  {
-    if (len <= 0x8d)
-      return;
+  if ((imSony.group9050 == LIBRAW_SONY_Tag9050b) ||
+      (imSony.group9050 == LIBRAW_SONY_Tag9050c)) {
+    if (len <= 0x8d) return;
     unsigned long long b88 = SonySubstitution[buf[0x88]];
     unsigned long long b89 = SonySubstitution[buf[0x89]];
     unsigned long long b8a = SonySubstitution[buf[0x8a]];
     unsigned long long b8b = SonySubstitution[buf[0x8b]];
     unsigned long long b8c = SonySubstitution[buf[0x8c]];
     unsigned long long b8d = SonySubstitution[buf[0x8d]];
     sprintf(imgdata.shootinginfo.InternalBodySerial, "%06llx",
-            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) +
-                b8d);
-  }
-  else if ((ilm.CameraMount == LIBRAW_MOUNT_Sony_E) &&
-           (id != SonyID_NEX_5N) &&
-           (id != SonyID_NEX_7)  &&
-           (id != SonyID_NEX_VG20)) // other 9050 versions
-  {
-    if (len <= 0x7f)
-      return;
-    unsigned b7c = SonySubstitution[buf[0x7c]];
-    unsigned b7d = SonySubstitution[buf[0x7d]];
-    unsigned b7e = SonySubstitution[buf[0x7e]];
-    unsigned b7f = SonySubstitution[buf[0x7f]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%04x",
-            (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);
-  }
-  else if (ilm.CameraMount == LIBRAW_MOUNT_Minolta_A)
-  {
-    if (len <= 0xf4)
-      return;
-    unsigned long long bf0 = SonySubstitution[buf[0xf0]];
-    unsigned long long bf1 = SonySubstitution[buf[0xf1]];
-    unsigned long long bf2 = SonySubstitution[buf[0xf2]];
-    unsigned long long bf3 = SonySubstitution[buf[0xf3]];
-    unsigned long long bf4 = SonySubstitution[buf[0xf4]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%05llx",
-            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);
-  }
-
-  if (ilm.CameraMount != LIBRAW_MOUNT_FixedLens)
+            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);
+
+  } else if (imSony.group9050 == LIBRAW_SONY_Tag9050a) {
+      if ((ilm.CameraMount == LIBRAW_MOUNT_Sony_E) &&
+             (id != SonyID_NEX_5N) &&
+             (id != SonyID_NEX_7)  &&
+             (id != SonyID_NEX_VG20)) {
+      if (len <= 0x7f) return;
+      unsigned b7c = SonySubstitution[buf[0x7c]];
+      unsigned b7d = SonySubstitution[buf[0x7d]];
+      unsigned b7e = SonySubstitution[buf[0x7e]];
+      unsigned b7f = SonySubstitution[buf[0x7f]];
+      sprintf(imgdata.shootinginfo.InternalBodySerial, "%04x",
+              (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);
+
+    } else if (ilm.CameraMount == LIBRAW_MOUNT_Minolta_A) {
+      if (len <= 0xf4) return;
+      unsigned long long bf0 = SonySubstitution[buf[0xf0]];
+      unsigned long long bf1 = SonySubstitution[buf[0xf1]];
+      unsigned long long bf2 = SonySubstitution[buf[0xf2]];
+      unsigned long long bf3 = SonySubstitution[buf[0xf3]];
+      unsigned long long bf4 = SonySubstitution[buf[0xf4]];
+      sprintf(imgdata.shootinginfo.InternalBodySerial, "%05llx",
+              (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);
+    }
+  }
+
+  if (imSony.CameraType != LIBRAW_SONY_DSC)
   {
     if (len <= 0x106)
       return;
     if (buf[0x3d] | buf[0x3c])
     {
       lid = SonySubstitution[buf[0x3d]] << 8 | SonySubstitution[buf[0x3c]];
       ilm.CurAp = libraw_powf64l(2.0f, ((float)lid / 256.0f - 16.0f) / 2.0f);
     }
     if (buf[0x105] &&
         (ilm.LensMount != LIBRAW_MOUNT_Canon_EF) &&
         (ilm.LensMount != LIBRAW_MOUNT_Sigma_X3F)) {
       switch (SonySubstitution[buf[0x105]]) {
         case 1:
           ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
           break;
         case 2:
           ilm.LensMount = LIBRAW_MOUNT_Sony_E;
         break;
       }
     }
     if (buf[0x106]) {
       switch (SonySubstitution[buf[0x106]]) {
         case 1:
           ilm.LensFormat = LIBRAW_FORMAT_APSC;
           break;
         case 2:
           ilm.LensFormat = LIBRAW_FORMAT_FF;
         break;
       }
     }
   }
 
   if (ilm.CameraMount == LIBRAW_MOUNT_Sony_E)
   {
     if (len <= 0x108)
       return;
     parseSonyLensType2(
         SonySubstitution[buf[0x0108]], // LensType2 - Sony lens ids
         SonySubstitution[buf[0x0107]]);
   }
 
   if (len <= 0x10a)
     return;
   if ((ilm.LensID == LIBRAW_LENS_NOT_SET) &&
       (ilm.CameraMount == LIBRAW_MOUNT_Minolta_A) &&
       (buf[0x010a] | buf[0x0109]))
   {
     ilm.LensID = // LensType - Minolta/Sony lens ids
         SonySubstitution[buf[0x010a]] << 8 | SonySubstitution[buf[0x0109]];
 
     if ((ilm.LensID > 0x4900) && (ilm.LensID <= 0x5900))
     {
       ilm.AdapterID = 0x4900;
       ilm.LensID -= ilm.AdapterID;
       ilm.LensMount = LIBRAW_MOUNT_Sigma_X3F;
       strcpy(ilm.Adapter, "MC-11");
     }
 
     else if ((ilm.LensID > 0xef00) && (ilm.LensID < 0xffff) &&
              (ilm.LensID != 0xff00))
     {
       ilm.AdapterID = 0xef00;
       ilm.LensID -= ilm.AdapterID;
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
     }
   }
 
   if ((id >= SonyID_SLT_A65) && (id <= SonyID_NEX_F3))
   {
     if (len <= 0x116)
       return;
     // "SLT-A65", "SLT-A77", "NEX-7", "NEX-VG20",
     // "SLT-A37", "SLT-A57", "NEX-F3", "Lunar"
     parseSonyLensFeatures(SonySubstitution[buf[0x115]],
                           SonySubstitution[buf[0x116]]);
   }
   else if (ilm.CameraMount != LIBRAW_MOUNT_FixedLens)
   {
     if (len <= 0x117)
       return;
     parseSonyLensFeatures(SonySubstitution[buf[0x116]],
                           SonySubstitution[buf[0x117]]);
   }
 
   if ((imSony.ImageCount3_offset != 0xffff) &&
       (len >= (imSony.ImageCount3_offset + 4)))
   {
     FORC4 s[c] = SonySubstitution[buf[imSony.ImageCount3_offset + c]];
     imSony.ImageCount3 = sget4(s);
   }
 
   return;
 }
@@ -741,86 +769,69 @@ void LibRaw::process_Sony_0x9050(uchar *buf, ushort len, unsigned long long id)
 void LibRaw::process_Sony_0x9400(uchar *buf, ushort len, unsigned long long id)
 {
 
   uchar s[4];
   int c;
   uchar bufx = buf[0];
 
   if (((bufx == 0x23) ||
        (bufx == 0x24) ||
        (bufx == 0x26) ||
-       (bufx == 0x28)) &&
+       (bufx == 0x28) ||
+       (bufx == 0x31)) &&
       (len >= 0x1f)) // 0x9400 'c' version
   {
+    imSony.Sony0x9400_version = 0xc;
+    imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];
 
-    if ((id == SonyID_ILCE_6100)    ||
-        (id == SonyID_ILCE_6400)    ||
-        (id == SonyID_ILCE_6600)    ||
-        (id == SonyID_ILCE_7M3)     ||
-        (id == SonyID_ILCE_7RM3)    ||
-        (id == SonyID_ILCE_7RM4)    ||
-        (id == SonyID_ILCE_9)       ||
-        (id == SonyID_ILCE_9M2)     ||
-        (id == SonyID_DSC_RX10M4)   ||
-        (id == SonyID_DSC_RX100M5A) ||
-        (id == SonyID_DSC_RX100M6)  ||
-        (id == SonyID_DSC_RX100M7)  ||
-        (id == SonyID_DSC_HX99)     ||
-        (id == SonyID_DSC_RX0M2)    ||
-        (id == SonyID_ZV_1))
-    {
-      imSony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];
-    }
-    else
-    {
+    if ((imSony.group2010 == LIBRAW_SONY_Tag2010g) ||
+        (imSony.group2010 == LIBRAW_SONY_Tag2010h)) {
       FORC4 s[c] = SonySubstitution[buf[0x0a + c]];
       imSony.ShotNumberSincePowerUp = sget4(s);
+    } else {
+      imSony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];
     }
 
-    imSony.Sony0x9400_version = 0xc;
-
-    imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];
-
     FORC4 s[c] = SonySubstitution[buf[0x12 + c]];
     imSony.Sony0x9400_SequenceImageNumber = sget4(s);
 
     imSony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x16]]; // shots
 
     FORC4 s[c] = SonySubstitution[buf[0x1a + c]];
     imSony.Sony0x9400_SequenceFileNumber = sget4(s);
 
     imSony.Sony0x9400_SequenceLength2 = SonySubstitution[buf[0x1e]]; // files
   }
 
   else if ((bufx == 0x0c) && (len >= 0x1f)) // 0x9400 'b' version
   {
     imSony.Sony0x9400_version = 0xb;
 
     FORC4 s[c] = SonySubstitution[buf[0x08 + c]];
     imSony.Sony0x9400_SequenceImageNumber = sget4(s);
 
     FORC4 s[c] = SonySubstitution[buf[0x0c + c]];
     imSony.Sony0x9400_SequenceFileNumber = sget4(s);
 
     imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];
 
     imSony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x1e]];
   }
 
   else if ((bufx == 0x0a) && (len >= 0x23)) // 0x9400 'a' version
   {
     imSony.Sony0x9400_version = 0xa;
 
     FORC4 s[c] = SonySubstitution[buf[0x08 + c]];
     imSony.Sony0x9400_SequenceImageNumber = sget4(s);
 
     FORC4 s[c] = SonySubstitution[buf[0x0c + c]];
     imSony.Sony0x9400_SequenceFileNumber = sget4(s);
 
     imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x10]];
 
     imSony.Sony0x9400_SequenceLength1 = SonySubstitution[buf[0x22]];
   }
 
   else
     return;
 }
@@ -928,57 +939,57 @@ void LibRaw::process_Sony_0x940c(uchar *buf, ushort len)
 void LibRaw::process_Sony_0x940e(uchar *buf, ushort len, unsigned long long id)
 {
   if (len < 3)
     return;
 
   if (((imSony.CameraType != LIBRAW_SONY_SLT) &&
        (imSony.CameraType != LIBRAW_SONY_ILCA)) ||
       (id == SonyID_SLT_A33)  ||
       (id == SonyID_SLT_A35)  ||
       (id == SonyID_SLT_A55))
     return;
 
   int c;
   imSony.AFType = SonySubstitution[buf[0x02]];
 
   if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
   {
     unsigned tag = 0x940e;
     imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
     imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
     imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
     imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
-    FORC(imCommon.afdata[imCommon.afcount].AFInfoData_length)
+    FORC((int)imCommon.afdata[imCommon.afcount].AFInfoData_length)
       imCommon.afdata[imCommon.afcount].AFInfoData[c] = SonySubstitution[buf[c]];
     imCommon.afcount++;
   }
 
   if (imSony.CameraType == LIBRAW_SONY_ILCA)
   {
     if (len >= 0x0051)
     {
       imgdata.shootinginfo.FocusMode = SonySubstitution[buf[0x05]];
       imSony.nAFPointsUsed =
           MIN(10, sizeof imSony.AFPointsUsed);
       FORC(imSony.nAFPointsUsed) imSony.AFPointsUsed[c] = SonySubstitution[buf[0x10 +c]];
       imSony.AFAreaMode = (uint16_t)SonySubstitution[buf[0x3a]];
       imSony.AFMicroAdjValue = SonySubstitution[buf[0x0050]];
       if (!imSony.AFMicroAdjValue) imSony.AFMicroAdjValue = 0x7f;
       else imSony.AFMicroAdjOn = 1;
     }
   }
   else
   {
     if (len >= 0x017e)
     {
       imSony.AFAreaMode = (uint16_t)SonySubstitution[buf[0x0a]];
       imgdata.shootinginfo.FocusMode = SonySubstitution[buf[0x0b]];
       imSony.nAFPointsUsed =
           MIN(4, sizeof imSony.AFPointsUsed);
       FORC(imSony.nAFPointsUsed) imSony.AFPointsUsed[c] = SonySubstitution[buf[0x016e +c]];
       imSony.AFMicroAdjValue = SonySubstitution[buf[0x017d]];
       if (!imSony.AFMicroAdjValue) imSony.AFMicroAdjValue = 0x7f;
       else imSony.AFMicroAdjOn = 1;
     }
   }
 
 }
@@ -986,978 +997,966 @@ void LibRaw::process_Sony_0x940e(uchar *buf, ushort len, unsigned long long id)
 void LibRaw::parseSonyMakernotes(
     int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer,
     uchar *&table_buf_0x0116, ushort &table_buf_0x0116_len,
     uchar *&table_buf_0x2010, ushort &table_buf_0x2010_len,
     uchar *&table_buf_0x9050, ushort &table_buf_0x9050_len,
     uchar *&table_buf_0x9400, ushort &table_buf_0x9400_len,
     uchar *&table_buf_0x9402, ushort &table_buf_0x9402_len,
     uchar *&table_buf_0x9403, ushort &table_buf_0x9403_len,
     uchar *&table_buf_0x9406, ushort &table_buf_0x9406_len,
     uchar *&table_buf_0x940c, ushort &table_buf_0x940c_len,
     uchar *&table_buf_0x940e, ushort &table_buf_0x940e_len)
 {
 
   ushort lid, a, c, d;
   uchar *table_buf;
   uchar uc;
   uchar s[2];
   int LensDataValid = 0;
   unsigned uitemp;
 
 // printf ("==>> tag 0x%x, len %d, type %d, model =%s=, cam.id 0x%llx, cam.type %d, =%s=\n",
 // tag, len, type, model, ilm.CamID, imSony.CameraType, imSony.MetaVersion);
 
   if (tag == 0xb001) // Sony ModelID
   {
     unique_id = get2();
     setSonyBodyFeatures(unique_id);
 
     if (table_buf_0x0116_len)
     {
       process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, unique_id);
       free(table_buf_0x0116);
       table_buf_0x0116_len = 0;
     }
 
     if (table_buf_0x2010_len)
     {
       process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);
       free(table_buf_0x2010);
       table_buf_0x2010_len = 0;
     }
 
     if (table_buf_0x9050_len)
     {
       process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, unique_id);
       free(table_buf_0x9050);
       table_buf_0x9050_len = 0;
     }
 
     if (table_buf_0x9400_len)
     {
       process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);
       free(table_buf_0x9400);
       table_buf_0x9400_len = 0;
     }
 
     if (table_buf_0x9402_len)
     {
       process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);
       free(table_buf_0x9402);
       table_buf_0x9402_len = 0;
     }
 
     if (table_buf_0x9403_len)
     {
       process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);
       free(table_buf_0x9403);
       table_buf_0x9403_len = 0;
     }
 
     if (table_buf_0x9406_len)
     {
       process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);
       free(table_buf_0x9406);
       table_buf_0x9406_len = 0;
     }
 
     if (table_buf_0x940c_len)
     {
       process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);
       free(table_buf_0x940c);
       table_buf_0x940c_len = 0;
     }
 
     if (table_buf_0x940e_len)
     {
       process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, unique_id);
       free(table_buf_0x940e);
       table_buf_0x940e_len = 0;
     }
   }
   else if (tag == 0xb000)
   {
     FORC4 imSony.FileFormat = imSony.FileFormat * 10 + fgetc(ifp);
   }
   else if (tag == 0xb026)
   {
     uitemp = get4();
     if (uitemp != 0xffffffff)
       imgdata.shootinginfo.ImageStabilization = uitemp;
   }
   else if (((tag == 0x0001) || // Minolta CameraSettings, big endian
             (tag == 0x0003)) &&
            (len >= 196))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
 
     lid = 0x01 << 2;
     imgdata.shootinginfo.ExposureMode =
         (unsigned)table_buf[lid] << 24 | (unsigned)table_buf[lid + 1] << 16 |
         (unsigned)table_buf[lid + 2] << 8 | (unsigned)table_buf[lid + 3];
 
     lid = 0x06 << 2;
     imgdata.shootinginfo.DriveMode =
         (unsigned)table_buf[lid] << 24 | (unsigned)table_buf[lid + 1] << 16 |
         (unsigned)table_buf[lid + 2] << 8 | (unsigned)table_buf[lid + 3];
 
     lid = 0x07 << 2;
     imgdata.shootinginfo.MeteringMode =
         (unsigned)table_buf[lid] << 24 | (unsigned)table_buf[lid + 1] << 16 |
         (unsigned)table_buf[lid + 2] << 8 | (unsigned)table_buf[lid + 3];
 
     lid = 0x25 << 2;
     imSony.MinoltaCamID =
         (unsigned)table_buf[lid] << 24 | (unsigned)table_buf[lid + 1] << 16 |
         (unsigned)table_buf[lid + 2] << 8 | (unsigned)table_buf[lid + 3];
     if (imSony.MinoltaCamID != 0xffffffff)
       ilm.CamID = imSony.MinoltaCamID;
 
     lid = 0x30 << 2;
     imgdata.shootinginfo.FocusMode =
         table_buf[lid + 3]?LIBRAW_SONY_FOCUSMODE_MF:LIBRAW_SONY_FOCUSMODE_AF;
     free(table_buf);
   }
   else if ((tag == 0x0004) && // Minolta CameraSettings7D, big endian
            (len >= 227))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
 
     lid = 0x0;
     imgdata.shootinginfo.ExposureMode =
         (ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1];
 
     lid = 0x0e << 1;
     imgdata.shootinginfo.FocusMode = (short)table_buf[lid + 1];
     switch (imgdata.shootinginfo.FocusMode) {
       case 0: case 1: imgdata.shootinginfo.FocusMode += 2; break;
       case 3: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_MF; break;
     }
     lid = 0x10 << 1;
     imgdata.shootinginfo.AFPoint =
         (ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1];
 
     lid = 0x25 << 1;
     switch ((ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1]) {
     case 0:
     case 1:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
       break;
     case 4:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
       break;
     default:
       imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
       break;
     }
 
     lid = 0x71 << 1;
     imgdata.shootinginfo.ImageStabilization =
         (ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1];
 
     free(table_buf);
   }
   else if ((tag == 0x0010) && // CameraInfo
            strncasecmp(model, "DSLR-A100", 9) &&
            !strncasecmp(make, "SONY", 4) &&
            ((len == 368) ||  // a700                         : CameraInfo
             (len == 5478) || // a850, a900                   : CameraInfo
             (len == 5506) || // a200, a300, a350             : CameraInfo2
             (len == 6118) || // a230, a290, a330, a380, a390 : CameraInfo2
             (len == 15360))  // a450, a500, a550, a560, a580 : CameraInfo3
                              // a33, a35, a55
                              // NEX-3, NEX-5, NEX-5C, NEX-C3, NEX-VG10E
 
   )
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
 		if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
 		{
 			imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
 			imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
 			imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
 			imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
 			memcpy(imCommon.afdata[imCommon.afcount].AFInfoData, table_buf, imCommon.afdata[imCommon.afcount].AFInfoData_length);
 			imCommon.afcount++;
 		}
     if (memcmp(table_buf, "\xff\xff\xff\xff\xff\xff\xff\xff", 8) &&
         memcmp(table_buf, "\x00\x00\x00\x00\x00\x00\x00\x00", 8))
     {
       LensDataValid = 1;
     }
     switch (len)
     {
     case 368:  // a700: CameraInfo
     case 5478: // a850, a900: CameraInfo
       if ((!dng_writer) ||
           (saneSonyCameraInfo(table_buf[0], table_buf[3], table_buf[2],
                               table_buf[5], table_buf[4], table_buf[7])))
       {
         if (LensDataValid)
         {
           if (table_buf[0] | table_buf[3])
             ilm.MinFocal = bcd2dec(table_buf[0]) * 100 + bcd2dec(table_buf[3]);
           if (table_buf[2] | table_buf[5])
             ilm.MaxFocal = bcd2dec(table_buf[2]) * 100 + bcd2dec(table_buf[5]);
           if (table_buf[4])
             ilm.MaxAp4MinFocal = bcd2dec(table_buf[4]) / 10.0f;
           if (table_buf[4])
             ilm.MaxAp4MaxFocal = bcd2dec(table_buf[7]) / 10.0f;
           parseSonyLensFeatures(table_buf[1], table_buf[6]);
         }
 
         imSony.AFPointSelected = table_buf[21];
         imgdata.shootinginfo.AFPoint = (ushort)table_buf[25];
 
         if (len == 5478)
         {
           imSony.AFMicroAdjValue = table_buf[0x130] - 20;
           imSony.AFMicroAdjOn = (((table_buf[0x131] & 0x80) == 0x80) ? 1 : 0);
           imSony.AFMicroAdjRegisteredLenses = table_buf[0x131] & 0x7f;
         }
       }
       break;
     default:
       // CameraInfo2 & 3
       if ((!dng_writer) ||
           (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3],
                               table_buf[4], table_buf[5], table_buf[6])))
       {
         if ((LensDataValid) && strncasecmp(model, "NEX-5C", 6))
         {
           if (table_buf[1] | table_buf[2])
             ilm.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);
           if (table_buf[3] | table_buf[4])
             ilm.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);
           if (table_buf[5])
             ilm.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;
           if (table_buf[6])
             ilm.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;
           parseSonyLensFeatures(table_buf[0], table_buf[7]);
         }
 
         if (                 // CameraInfo2
             (len == 5506) || // a200, a300, a350
             (len == 6118))   // a230, a290, a330, a380, a390
         {
           imSony.AFPointSelected = table_buf[0x14];
         }
         else if (!strncasecmp(model, "DSLR-A450", 9) ||
                  !strncasecmp(model, "DSLR-A500", 9) ||
                  !strncasecmp(model, "DSLR-A550", 9))
         {
           imSony.AFPointSelected = table_buf[0x14];
           if (table_buf[0x15]) /* focus mode values translated to values in tag 0x201b */
             imgdata.shootinginfo.FocusMode = table_buf[0x15]+1;
           else imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_MF;
          imgdata.shootinginfo.AFPoint = (ushort)table_buf[0x18];
         }
         else if (!strncasecmp(model, "SLT-", 4)      ||
                  !strncasecmp(model, "DSLR-A560", 9) ||
                  !strncasecmp(model, "DSLR-A580", 9))
         {
           imSony.AFPointSelected = table_buf[0x1c];
           if (table_buf[0x1d])
             imgdata.shootinginfo.FocusMode = table_buf[0x1d]+1;
           else imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_MF;
           imgdata.shootinginfo.AFPoint = (ushort)table_buf[0x20];
         }
       }
     }
     free(table_buf);
   }
   else if ((!dng_writer) &&
            ((tag == 0x0020) || (tag == 0xb0280020)))
   {
     if (!strncasecmp(model, "DSLR-A100", 9)) // WBInfoA100
     {
       fseek(ifp, 0x49dc, SEEK_CUR);
       stmread(imgdata.shootinginfo.InternalBodySerial, 13, ifp);
     }
     else if ((len == 19154) || // a200 a230 a290 a300 a330 a350 a380 a390 : FocusInfo
              (len == 19148))   // a700 a850 a900                          : FocusInfo
     {
       table_buf = (uchar *)malloc(0x0080);
       fread(table_buf, 0x0080, 1, ifp);
       imgdata.shootinginfo.DriveMode = table_buf[14];
       imgdata.shootinginfo.ExposureProgram = table_buf[63];
       free(table_buf);
       fseek (ifp, 0x09bb - 0x0080, SEEK_CUR); // offset 2491 from the start of tag 0x0020
       imSony.FocusPosition = (ushort)fgetc(ifp);
     }
     else if (len == 20480) // a450 a500 a550 a560 a580 a33 a35 a55 : MoreInfo
                            // NEX-3 NEX-5 NEX-C3 NEX-VG10E         : MoreInfo
     {
       a = get2();
       /*b =*/ get2();
       c = get2();
       d = get2();
       if ((a) && (c == 1))
       {
         fseek(ifp, INT64(d) - 8LL, SEEK_CUR);
         table_buf = (uchar *)malloc(256);
         fread(table_buf, 256, 1, ifp);
         imgdata.shootinginfo.DriveMode = table_buf[1];
         imgdata.shootinginfo.ExposureProgram = table_buf[2];
         imgdata.shootinginfo.MeteringMode = table_buf[3];
         switch (table_buf[6]) {
         case 1:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
           break;
         case 2:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
           break;
         default:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
           break;
         }
         if (strncasecmp(model, "DSLR-A450", 9) &&
             strncasecmp(model, "DSLR-A500", 9) &&
             strncasecmp(model, "DSLR-A550", 9))
         { // NEX-3, NEX-5, NEX-5C??, NEX-C3, NEX-VG10(E), a560, a580, a33, a35, a55
           imgdata.shootinginfo.FocusMode = table_buf[0x13];
           switch (table_buf[0x13]) {
             case 17: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_AF_S; break;
             case 18: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_AF_C; break;
             case 19: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_AF_A; break;
             case 32: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_MF; break;
             case 48: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_DMF; break;
             default: imgdata.shootinginfo.FocusMode = table_buf[0x13]; break;
           }
           if (!strncasecmp(model, "DSLR-A560", 9) ||
               !strncasecmp(model, "DSLR-A580", 9) ||
               !strncasecmp(model, "SLT-A33", 7)   ||
               !strncasecmp(model, "SLT-A35", 7)   ||
               !strncasecmp(model, "SLT-A55", 7)   ||
               !strncasecmp(model, "NEX-VG10", 8)  ||
               !strncasecmp(model, "NEX-C3", 6))
             imSony.FocusPosition = (ushort)table_buf[0x2f]; // FocusPosition2
           else  // NEX-3, NEX-5, NEX-5C
             imSony.FocusPosition = (ushort)table_buf[0x2b]; // FocusPosition2
         }
         else // a450 a500 a550
         {
           imSony.FocusPosition = (ushort)table_buf[0x29]; // FocusPosition2
         }
         free(table_buf);
       }
     }
   }
   else if (tag == 0x0102)
   {
     imSony.Quality = get4();
   }
   else if (tag == 0x0104)
   {
     imCommon.FlashEC = getreal(type);
   }
   else if (tag == 0x0105) // Teleconverter
   {
     ilm.TeleconverterID = get4();
   }
   else if (tag == 0x0107)
   {
     uitemp = get4();
     if (uitemp == 1)
       imgdata.shootinginfo.ImageStabilization = 0;
     else if (uitemp == 5)
       imgdata.shootinginfo.ImageStabilization = 1;
     else
       imgdata.shootinginfo.ImageStabilization = uitemp;
   }
   else if ((tag == 0xb0280088) && (dng_writer == nonDNG))
   {
     thumb_offset = get4() + base;
   }
   else if ((tag == 0xb0280089) && (dng_writer == nonDNG))
   {
     thumb_length = get4();
   }
   else if (((tag == 0x0114) || // CameraSettings
             (tag == 0xb0280114)) &&
            (len < 256000))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     switch (len)
     {
     case 260: // Sony a100, big endian
       imgdata.shootinginfo.ExposureMode =
           ((ushort)table_buf[0]) << 8 | ((ushort)table_buf[1]);
       lid = 0x0a << 1;
       imgdata.shootinginfo.DriveMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       lid = 0x0c << 1;
       imgdata.shootinginfo.FocusMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       switch (imgdata.shootinginfo.FocusMode) {
         case 0: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_AF_S; break;
         case 1: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_AF_C; break;
         case 5: imgdata.shootinginfo.FocusMode = LIBRAW_SONY_FOCUSMODE_MF; break;
       }
       lid = 0x0d << 1;
       imSony.AFPointSelected = table_buf[lid + 1];
       lid = 0x0e << 1;
       imSony.AFAreaMode = (uint16_t)table_buf[lid + 1];
       lid = 0x12 << 1;
       imgdata.shootinginfo.MeteringMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
 
       lid = 0x17 << 1;
       switch ((ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1]) {
       case 0:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 2:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_MonochromeGamma;
         break;
       case 5:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
 
       break;
     case 448: // Minolta "DYNAX 5D" and its aliases, big endian
       lid = 0x0a << 1;
       imgdata.shootinginfo.ExposureMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       lid = 0x25 << 1;
       imgdata.shootinginfo.MeteringMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
 
       lid = 0x2f << 1;
       switch ((ushort)table_buf[lid] << 8 | (ushort)table_buf[lid + 1]) {
       case 0:
       case 1:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 2:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_MonochromeGamma;
         break;
       case 4:
       case 5:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
 
       lid = 0xbd << 1;
       imgdata.shootinginfo.ImageStabilization =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       break;
     case 280: // a200 a300 a350 a700
     case 364: // a850 a900
       // CameraSettings and CameraSettings2 are big endian
       if (table_buf[2] | table_buf[3])
       {
         lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);
         ilm.CurAp = libraw_powf64l(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);
       }
       lid = 0x04 << 1;
       imgdata.shootinginfo.DriveMode = table_buf[lid + 1];
       lid = 0x11 << 1;
       imSony.AFAreaMode = (uint16_t)table_buf[lid + 1];
       lid = 0x1b << 1;
       switch (((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1])) {
       case 0:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 1:
       case 5:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
       lid = 0x4d << 1;
       imgdata.shootinginfo.FocusMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       switch (imgdata.shootinginfo.FocusMode) {
         case 1: case 2: case 3: imgdata.shootinginfo.FocusMode++; break;
         case 4: imgdata.shootinginfo.FocusMode +=2; break;
       }
       if (!imCommon.ColorSpace ||
           (imCommon.ColorSpace == LIBRAW_COLORSPACE_Unknown)) {
         lid = 0x83 << 1;
         switch (((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1])) {
         case 6:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
           break;
         case 5:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
           break;
         default:
           imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
           break;
         }
       }
       break;
     case 332: // a230 a290 a330 a380 a390
       // CameraSettings and CameraSettings2 are big endian
       if (table_buf[2] | table_buf[3])
       {
         lid = (((ushort)table_buf[2]) << 8) | ((ushort)table_buf[3]);
         ilm.CurAp = libraw_powf64l(2.0f, ((float)lid / 8.0f - 1.0f) / 2.0f);
       }
       lid = 0x10 << 1;
       imSony.AFAreaMode = (uint16_t)table_buf[lid + 1];
       lid = 0x4d << 1;
       imgdata.shootinginfo.FocusMode =
           ((ushort)table_buf[lid]) << 8 | ((ushort)table_buf[lid + 1]);
       switch (imgdata.shootinginfo.FocusMode) {
         case 1: case 2: case 3: imgdata.shootinginfo.FocusMode++; break;
         case 4: imgdata.shootinginfo.FocusMode +=2; break;
      }
       lid = 0x7e << 1;
       imgdata.shootinginfo.DriveMode = table_buf[lid + 1];
       break;
     case 1536: // a560 a580 a33 a35 a55 NEX-3 NEX-5 NEX-5C NEX-C3 NEX-VG10E
     case 2048: // a450 a500 a550
       // CameraSettings3 are little endian
       switch (table_buf[0x0e]) {
       case 1:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_sRGB;
         break;
       case 2:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_AdobeRGB;
         break;
       default:
         imCommon.ColorSpace = LIBRAW_COLORSPACE_Unknown;
         break;
       }
       imSony.AFAreaMode = (uint16_t)table_buf[0x24];
       imgdata.shootinginfo.DriveMode = table_buf[0x34];
       parseSonyLensType2(table_buf[1016], table_buf[1015]);
       if (ilm.LensMount != LIBRAW_MOUNT_Canon_EF)
       {
         switch (table_buf[153])
         {
         case 16:
           ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
           break;
         case 17:
           ilm.LensMount = LIBRAW_MOUNT_Sony_E;
           break;
         }
       }
       break;
     }
     free(table_buf);
   }
   else if ((tag == 0x3000) && (len < 256000))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     if (len >= 0x19)
     {
       for (int i = 0; i < 20; i++)
         imSony.SonyDateTime[i] = table_buf[6 + i];
     }
     if (len >= 0x43) // MetaVersion: (unique_id >= 286)
     {
       memcpy (imSony.MetaVersion, table_buf+0x34, 15);
       imSony.MetaVersion[15] = 0;
     }
     free(table_buf);
   }
   else if (tag == 0x0116 && len < 256000)
   {
     table_buf_0x0116 = (uchar *)malloc(len);
     table_buf_0x0116_len = len;
     fread(table_buf_0x0116, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x0116(table_buf_0x0116, table_buf_0x0116_len, ilm.CamID);
       free(table_buf_0x0116);
       table_buf_0x0116_len = 0;
     }
   }
   else if (tag == 0x2008)
   {
     imSony.LongExposureNoiseReduction = get4();
   }
   else if (tag == 0x2009)
   {
     imSony.HighISONoiseReduction = get2();
   }
   else if (tag == 0x200a)
   {
     imSony.HDR[0] = get2();
     imSony.HDR[1] = get2();
   }
   else if (tag == 0x2010 && len < 256000)
   {
     table_buf_0x2010 = (uchar *)malloc(len);
     table_buf_0x2010_len = len;
     fread(table_buf_0x2010, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x2010(table_buf_0x2010, table_buf_0x2010_len);
       free(table_buf_0x2010);
       table_buf_0x2010_len = 0;
     }
   }
   else if (tag == 0x201a)
   {
     imSony.ElectronicFrontCurtainShutter = get4();
   }
   else if (tag == 0x201b)
   {
     if ((imSony.CameraType != LIBRAW_SONY_DSC) ||
-        (ilm.CamID == SonyID_DSC_RX10M4)   ||
-        (ilm.CamID == SonyID_DSC_RX100M6)  ||
-        (ilm.CamID == SonyID_DSC_RX100M5A) ||
-        (ilm.CamID == SonyID_DSC_RX0M2)    ||
-        (ilm.CamID == SonyID_DSC_HX99)     ||
-        (ilm.CamID == SonyID_DSC_RX100M7)  ||
-        (ilm.CamID == SonyID_ZV_1))
+        (imSony.group2010 == LIBRAW_SONY_Tag2010i))
     {
       short t = (short)fgetc(ifp);
       if (imgdata.shootinginfo.FocusMode != t)
       {
         imgdata.shootinginfo.FocusMode = t;
       }
     }
   }
   else if ((tag == 0x201c) &&
            (len == 1) &&
            tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE))
   {
     imSony.AFAreaModeSetting = (uint8_t)fgetc(ifp);
   }
   else if ((tag == 0x201d) &&
            (len == 2) &&
            tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
   {
       imSony.FlexibleSpotPosition[0] = get2();
       imSony.FlexibleSpotPosition[1] = get2();
   }
   else if (tag == 0x201e)
   {
     if (imSony.CameraType != LIBRAW_SONY_DSC)
     {
       imSony.AFPointSelected = imSony.AFPointSelected_0x201e = fgetc(ifp);
     }
   }
   else if (tag == 0x2020) // AFPointsUsed
   {
     if (imSony.CameraType != LIBRAW_SONY_DSC)
     {
       if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
       {
         imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
         imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
         imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
         imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
         fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
         imSony.nAFPointsUsed =
             MIN(imCommon.afdata[imCommon.afcount].AFInfoData_length, sizeof imSony.AFPointsUsed);
         memcpy(imSony.AFPointsUsed, imCommon.afdata[imCommon.afcount].AFInfoData, imSony.nAFPointsUsed);
         imCommon.afcount++;
       }
     }
   }
   else if (tag == 0x2021) // AFTracking
   {
     if ((imSony.CameraType != LIBRAW_SONY_DSC) ||
-        (ilm.CamID == SonyID_DSC_RX10M4)   ||
-        (ilm.CamID == SonyID_DSC_RX100M6)  ||
-        (ilm.CamID == SonyID_DSC_RX100M5A) ||
-        (ilm.CamID == SonyID_DSC_RX0M2)    ||
-        (ilm.CamID == SonyID_DSC_HX99)     ||
-        (ilm.CamID == SonyID_DSC_RX100M7)  ||
-        (ilm.CamID == SonyID_ZV_1))
+        (imSony.group2010 == LIBRAW_SONY_Tag2010i))
     {
       imSony.AFTracking = fgetc(ifp);
     }
   }
   else if (tag == 0x2022) // FocalPlaneAFPointsUsed
   {
     if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
     {
       imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
       imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
       imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
       imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
       fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
       imCommon.afcount++;
     }
   }
   else if (tag == 0x2027)
   {
     FORC4 imSony.FocusLocation[c] = get2();
   }
   else if (tag == 0x2028)
   {
     if (get2())
     {
       imSony.VariableLowPassFilter = get2();
     }
   }
   else if (tag == 0x2029)
   {
     imSony.RAWFileType = get2();
   }
   else if (tag == 0x202c)
   {
     imSony.MeteringMode2 = get2();
   }
 
   else if (tag == 0x202a) // FocalPlaneAFPointsUsed, newer??
   {
     if (imCommon.afcount < LIBRAW_AFDATA_MAXCOUNT)
     {
       imCommon.afdata[imCommon.afcount].AFInfoData_tag = tag;
       imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
       imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
       imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
       fread(imCommon.afdata[imCommon.afcount].AFInfoData, imCommon.afdata[imCommon.afcount].AFInfoData_length, 1, ifp);
 		  imCommon.afcount++;
     }
   }
   else if (tag == 0x202f)
   {
     imSony.PixelShiftGroupID = get4();
     imSony.PixelShiftGroupPrefix = imSony.PixelShiftGroupID >> 22;
     imSony.PixelShiftGroupID =
         ((imSony.PixelShiftGroupID >> 17) & (unsigned)0x1f) *
             (unsigned)1000000 +
         ((imSony.PixelShiftGroupID >> 12) & (unsigned)0x1f) * (unsigned)10000 +
         ((imSony.PixelShiftGroupID >> 6) & (unsigned)0x3f) * (unsigned)100 +
         (imSony.PixelShiftGroupID & (unsigned)0x3f);
 
     imSony.numInPixelShiftGroup = fgetc(ifp);
     imSony.nShotsInPixelShiftGroup = fgetc(ifp);
   }
   else if (tag == 0x9050 && len < 256000) // little endian
   {
     table_buf_0x9050 = (uchar *)malloc(len);
     table_buf_0x9050_len = len;
     fread(table_buf_0x9050, len, 1, ifp);
 
     if (ilm.CamID)
     {
       process_Sony_0x9050(table_buf_0x9050, table_buf_0x9050_len, ilm.CamID);
       free(table_buf_0x9050);
       table_buf_0x9050_len = 0;
     }
   }
   else if (tag == 0x9400 && len < 256000)
   {
     table_buf_0x9400 = (uchar *)malloc(len);
     table_buf_0x9400_len = len;
     fread(table_buf_0x9400, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x9400(table_buf_0x9400, table_buf_0x9400_len, unique_id);
       free(table_buf_0x9400);
       table_buf_0x9400_len = 0;
     }
   }
   else if (tag == 0x9402 && len < 256000)
   {
     table_buf_0x9402 = (uchar *)malloc(len);
     table_buf_0x9402_len = len;
     fread(table_buf_0x9402, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x9402(table_buf_0x9402, table_buf_0x9402_len);
       free(table_buf_0x9402);
       table_buf_0x9402_len = 0;
     }
   }
   else if (tag == 0x9403 && len < 256000)
   {
     table_buf_0x9403 = (uchar *)malloc(len);
     table_buf_0x9403_len = len;
     fread(table_buf_0x9403, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x9403(table_buf_0x9403, table_buf_0x9403_len);
       free(table_buf_0x9403);
       table_buf_0x9403_len = 0;
     }
   }
   else if ((tag == 0x9405) && (len < 256000) && (len > 0x64))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     uc = table_buf[0x0];
     if (imCommon.real_ISO < 0.1f)
     {
       if ((uc == 0x25) || (uc == 0x3a) || (uc == 0x76) || (uc == 0x7e) ||
           (uc == 0x8b) || (uc == 0x9a) || (uc == 0xb3) || (uc == 0xe1))
       {
         s[0] = SonySubstitution[table_buf[0x04]];
         s[1] = SonySubstitution[table_buf[0x05]];
         imCommon.real_ISO =
             100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));
       }
     }
     free(table_buf);
   }
   else if ((tag == 0x9404) && (len < 256000) && (len > 0x21))
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     uc = table_buf[0x00];
     if (((uc == 0x70) ||
          (uc == 0x8a) ||
          (uc == 0xcd) ||
          (uc == 0xe7) ||
          (uc == 0xea)) &&
          (table_buf[0x03] == 0x08))
     {
       if ((imSony.CameraType == LIBRAW_SONY_ILCA) ||
           (imSony.CameraType == LIBRAW_SONY_SLT))
       {
         imSony.FocusPosition = (ushort)SonySubstitution[table_buf[0x20]]; // FocusPosition2
       }
     }
     free(table_buf);
   }
   else if (tag == 0x9406 && len < 256000)
   {
     table_buf_0x9406 = (uchar *)malloc(len);
     table_buf_0x9406_len = len;
     fread(table_buf_0x9406, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x9406(table_buf_0x9406, table_buf_0x9406_len);
       free(table_buf_0x9406);
       table_buf_0x9406_len = 0;
     }
   }
   else if (tag == 0x940c && len < 256000)
   {
     table_buf_0x940c = (uchar *)malloc(len);
     table_buf_0x940c_len = len;
     fread(table_buf_0x940c, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x940c(table_buf_0x940c, table_buf_0x940c_len);
       free(table_buf_0x940c);
       table_buf_0x940c_len = 0;
     }
   }
   else if (tag == 0x940e && len < 256000)
   {
     table_buf_0x940e = (uchar *)malloc(len);
     table_buf_0x940e_len = len;
     fread(table_buf_0x940e, len, 1, ifp);
     if (ilm.CamID)
     {
       process_Sony_0x940e(table_buf_0x940e, table_buf_0x940e_len, ilm.CamID);
       free(table_buf_0x940e);
       table_buf_0x940e_len = 0;
     }
   }
   else if ((tag == 0x9416) && (len < 256000) && (len > 0x0076)) {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     if (imCommon.real_ISO < 0.1f) {
       s[0] = SonySubstitution[table_buf[0x04]];
       s[1] = SonySubstitution[table_buf[0x05]];
       imCommon.real_ISO =
           100.0f * libraw_powf64l(2.0f, (16 - ((float)sget2(s)) / 256.0f));
     }
     imgdata.shootinginfo.ExposureProgram = SonySubstitution[table_buf[0x35]];
     if ((ilm.LensMount != LIBRAW_MOUNT_Canon_EF) &&
         (ilm.LensMount != LIBRAW_MOUNT_Sigma_X3F)) {
       switch (SonySubstitution[table_buf[0x0048]]) {
       case 1:
       case 3:
         ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
         break;
       case 2:
         ilm.LensMount = LIBRAW_MOUNT_Sony_E;
         break;
       }
     }
     switch (SonySubstitution[table_buf[0x0049]]) {
       case 1:
         ilm.LensFormat = LIBRAW_FORMAT_APSC;
         break;
       case 2:
         ilm.LensFormat = LIBRAW_FORMAT_FF;
         break;
     }
     if (ilm.LensMount == LIBRAW_MOUNT_Sony_E)
       parseSonyLensType2(SonySubstitution[table_buf[0x4c]], SonySubstitution[table_buf[0x4b]]);
     free(table_buf);
   }
   else if (((tag == 0xb027) ||
             (tag == 0x010c)) &&
            (ilm.LensID == LIBRAW_LENS_NOT_SET))
   {
     ilm.LensID = get4();
     if ((ilm.LensID > 0x4900) && (ilm.LensID <= 0x5900))
     {
       ilm.AdapterID = 0x4900;
       ilm.LensID -= ilm.AdapterID;
       ilm.LensMount = LIBRAW_MOUNT_Sigma_X3F;
       strcpy(ilm.Adapter, "MC-11");
     }
 
     else if ((ilm.LensID > 0xef00) &&
              (ilm.LensID < 0xffff) &&
              (ilm.LensID != 0xff00))
     {
       ilm.AdapterID = 0xef00;
       ilm.LensID -= ilm.AdapterID;
       ilm.LensMount = LIBRAW_MOUNT_Canon_EF;
     }
 
     else if (((ilm.LensID != LIBRAW_LENS_NOT_SET) && (ilm.LensID < 0xef00)) ||
              (ilm.LensID == 0xff00))
       ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
     /*
         if (tag == 0x010c)
           ilm.CameraMount = LIBRAW_MOUNT_Minolta_A;
     */
   }
   else if (tag == 0xb02a && len < 256000) // Sony LensSpec
   {
     table_buf = (uchar *)malloc(len);
     fread(table_buf, len, 1, ifp);
     if ((!dng_writer) ||
         (saneSonyCameraInfo(table_buf[1], table_buf[2], table_buf[3],
                             table_buf[4], table_buf[5], table_buf[6])))
     {
       if (table_buf[1] | table_buf[2])
         ilm.MinFocal = bcd2dec(table_buf[1]) * 100 + bcd2dec(table_buf[2]);
       if (table_buf[3] | table_buf[4])
         ilm.MaxFocal = bcd2dec(table_buf[3]) * 100 + bcd2dec(table_buf[4]);
       if (table_buf[5])
         ilm.MaxAp4MinFocal = bcd2dec(table_buf[5]) / 10.0f;
       if (table_buf[6])
         ilm.MaxAp4MaxFocal = bcd2dec(table_buf[6]) / 10.0f;
       parseSonyLensFeatures(table_buf[0], table_buf[7]);
     }
     free(table_buf);
   }
-  else if ((tag == 0xb02b) && !imgdata.sizes.raw_inset_crop.cwidth &&
+  else if ((tag == 0xb02b) && !imgdata.sizes.raw_inset_crops[0].cwidth &&
            (len == 2))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get4();
-    imgdata.sizes.raw_inset_crop.cwidth = get4();
+    imgdata.sizes.raw_inset_crops[0].cheight = get4();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get4();
   }
   else if (tag == 0xb041)
   {
     imgdata.shootinginfo.ExposureMode = get2();
   }
   else if ((tag == 0xb043) &&
            (len == 1) &&
            tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
   {
     imSony.AFAreaMode = get2();
   }
 }
@@ -2174,137 +2173,137 @@ void LibRaw::parseSonySR2(uchar *_cbuf_SR2, unsigned SR2SubIFDOffset,
 void LibRaw::parseSonySRF(unsigned len)
 {
 
   if ((len > 0xfffff) || (len == 0))
     return;
 
   INT64 save = ftell(ifp);
   INT64 offset =  0x0310c0 - save; /* for non-DNG this value normally is 0x8ddc */
   if (len < offset || offset < 0)
     return;
   try {
 
       INT64 decrypt_len = offset >> 2; /* master key offset value is the next
                                           un-encrypted metadata field after SRF0 */
 
       unsigned i, nWB;
-      unsigned MasterKey, SRF2Key;
+      unsigned MasterKey, SRF2Key=0;
       INT64 srf_offset, tag_offset, tag_dataoffset;
       int tag_dataunitlen;
       //uchar *srf_buf;
       ushort entries;
       unsigned tag_id, tag_type, tag_datalen;
 
       //srf_buf = (uchar *)malloc(len+64);
       checked_buffer_t srf_buf(order, len);
       fread(srf_buf.data(), len, 1, ifp);
 
       offset += srf_buf[offset] << 2;
 
       /* master key is stored in big endian */
       MasterKey = ((unsigned)srf_buf[offset] << 24) |
           ((unsigned)srf_buf[offset + 1] << 16) |
           ((unsigned)srf_buf[offset + 2] << 8) |
           (unsigned)srf_buf[offset + 3];
 
       /* skip SRF0 */
       srf_offset = 0;
       entries = srf_buf.sget2(srf_offset);
       if (entries > 1000)
           goto restore_after_parseSonySRF;
       offset = srf_offset + 2;
       srf_offset = srf_buf.sget4(offset + 12 * entries) - save; /* SRF0 ends with SRF1 abs. position */
 
       /* get SRF1, it has fixed 40 bytes length and contains keys to decode metadata
        * and raw data */
       if (srf_offset < 0 || decrypt_len < srf_offset / 4)
           goto restore_after_parseSonySRF;
       sony_decrypt((unsigned *)(srf_buf.data() + srf_offset), decrypt_len - srf_offset / 4,
           1, MasterKey);
       entries = srf_buf.sget2(srf_offset);
       if (entries > 1000)
           goto restore_after_parseSonySRF;
       offset = srf_offset + 2;
       tag_offset = offset;
 
       while (entries--) {
           if (tiff_sget(save, srf_buf.data(), len,
               &tag_offset, &tag_id, &tag_type, &tag_dataoffset,
               &tag_datalen, &tag_dataunitlen) == 0) {
               if (tag_id == 0x0000) {
                   SRF2Key = srf_buf.sget4(tag_dataoffset);
               }
               else if (tag_id == 0x0001) {
                   /*RawDataKey =*/ srf_buf.sget4(tag_dataoffset);
               }
           }
           else goto restore_after_parseSonySRF;
       }
       offset = tag_offset;
 
       /* get SRF2 */
       srf_offset = srf_buf.sget4(offset) - save; /* SRFn ends with SRFn+1 position */
       if (srf_offset < 0 || decrypt_len < srf_offset / 4)
           goto restore_after_parseSonySRF;
       sony_decrypt((unsigned *)(srf_buf.data() + srf_offset), decrypt_len - srf_offset / 4,
           1, SRF2Key);
 
       entries = srf_buf.sget2(srf_offset);
       if (entries > 1000)
           goto restore_after_parseSonySRF;
       offset = srf_offset + 2;
       tag_offset = offset;
 
       while (entries--) {
           if (srf_buf.tiff_sget(save,
               &tag_offset, &tag_id, &tag_type, &tag_dataoffset,
               &tag_datalen, &tag_dataunitlen) == 0) {
               if ((tag_id >= 0x00c0) && (tag_id <= 0x00ce)) {
                   i = (tag_id - 0x00c0) % 3;
                   nWB = (tag_id - 0x00c0) / 3;
                   icWBC[Sony_SRF_wb_list[nWB]][i] = srf_buf.sget4(tag_dataoffset);
                   if (i == 1) {
                       icWBC[Sony_SRF_wb_list[nWB]][3] =
                           icWBC[Sony_SRF_wb_list[nWB]][i];
                   }
               }
               else if ((tag_id >= 0x00d0) && (tag_id <= 0x00d2)) {
                   i = (tag_id - 0x00d0) % 3;
                   cam_mul[i] = srf_buf.sget4(tag_dataoffset);
                   if (i == 1) {
                       cam_mul[3] = cam_mul[i];
                   }
               }
               else switch (tag_id) {
                   /*
                   0x0002  SRF6Offset
                   0x0003  SRFDataOffset (?)
                   0x0004  RawDataOffset
                   0x0005  RawDataLength
                   */
               case 0x0043:
                   ilm.MaxAp4MaxFocal = srf_buf.sgetreal(tag_type, tag_dataoffset);
                   break;
               case 0x0044:
                   ilm.MaxAp4MinFocal = srf_buf.sgetreal(tag_type, tag_dataoffset);
                   break;
               case 0x0045:
                   ilm.MinFocal = srf_buf.sgetreal(tag_type, tag_dataoffset);
                   break;
               case 0x0046:
                   ilm.MaxFocal = srf_buf.sgetreal(tag_type, tag_dataoffset);
                   break;
               }
           }
           else goto restore_after_parseSonySRF;
       }
       offset = tag_offset;
 
   restore_after_parseSonySRF:;
   }
   catch (...) // srf_buf can raise IO_EOF exception, catch it and return usual way
   {
       fseek(ifp, save, SEEK_SET);
       return;
   }
   fseek(ifp, save, SEEK_SET);
 }
diff --git a/src/metadata/tiff.cpp b/src/metadata/tiff.cpp
index d55fdc94..edb30a62 100644
--- a/src/metadata/tiff.cpp
+++ b/src/metadata/tiff.cpp
@@ -22,1461 +22,1512 @@
 int LibRaw::parse_tiff_ifd(int base)
 {
   unsigned entries, tag, type, len, plen = 16, save, utmp;
   int ifd, use_cm = 0, cfa, i, j, c, ima_len = 0;
   char *cbuf, *cp;
   uchar cfa_pat[16], cfa_pc[] = {0, 1, 2, 3}, tab[256];
   double fm[3][4], cc[4][4], cm[4][3], cam_xyz[4][3], num;
   double ab[] = {1, 1, 1, 1}, asn[] = {0, 0, 0, 0}, xyz[] = {1, 1, 1};
   unsigned sony_curve[] = {0, 0, 0, 0, 0, 4095};
   unsigned *buf, sony_offset = 0, sony_length = 0, sony_key = 0;
   struct jhead jh;
 
   ushort *rafdata;
 
   if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])
     return 1;
   ifd = tiff_nifds++;
   for (j = 0; j < 4; j++)
     for (i = 0; i < 4; i++)
       cc[j][i] = i == j;
+
+  if (!libraw_internal_data.unpacker_data.ifd0_offset)
+    libraw_internal_data.unpacker_data.ifd0_offset = base;
+
   entries = get2();
   if (entries > 512)
     return 1;
 
   INT64 fsize = ifp->size();
 
   while (entries--)
   {
     tiff_get(base, &tag, &type, &len, &save);
     INT64 savepos = ftell(ifp);
     if (len > 8 && savepos + len > 2 * fsize)
     {
       fseek(ifp, save, SEEK_SET); // Recover tiff-read position!!
       continue;
     }
     if (callbacks.exif_cb)
     {
       callbacks.exif_cb(callbacks.exifparser_data,
                         tag | (is_pana_raw ? 0x30000 : ((ifd + 1) << 20)), type,
                         len, order, ifp, base);
       fseek(ifp, savepos, SEEK_SET);
     }
 
     if (!is_pana_raw)
     { /* processing of EXIF tags that collide w/ PanasonicRaw tags */
       switch (tag)
       {
       case 0x0001:
         if (len == 4)
           is_pana_raw = get4();
         break;
       case 0x000b: /* 11, Std. EXIF Software tag */
         fgets(software, 64, ifp);
         if (!strncmp(software, "Adobe", 5) || !strncmp(software, "dcraw", 5) ||
             !strncmp(software, "UFRaw", 5) || !strncmp(software, "Bibble", 6) ||
             !strcmp(software, "Digital Photo Professional"))
           is_raw = 0;
         break;
       case 0x001c: /*  28, safeguard, probably not needed */
       case 0x001d: /*  29, safeguard, probably not needed */
       case 0x001e: /*  30, safeguard, probably not needed */
         cblack[tag - 0x001c] = get2();
         cblack[3] = cblack[1];
         break;
 
       case 0x0111: /* 273, StripOffset */
         if (len > 1 && len < 16384)
         {
           off_t sav = ftell(ifp);
           tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));
           tiff_ifd[ifd].strip_offsets_count = len;
           for (int i = 0; i < (int)len; i++)
             tiff_ifd[ifd].strip_offsets[i] = get4() + base;
           fseek(ifp, sav, SEEK_SET); // restore position
         }
         /* fallback */
       case 0x0201: /* 513, JpegIFOffset */
       case 0xf007: // 61447
         tiff_ifd[ifd].offset = get4() + base;
         if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)
         {
           fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);
           if (ljpeg_start(&jh, 1))
           {
-            tiff_ifd[ifd].comp = 6;
-            tiff_ifd[ifd].t_width = jh.wide;
-            tiff_ifd[ifd].t_height = jh.high;
-            tiff_ifd[ifd].bps = jh.bits;
-            tiff_ifd[ifd].samples = jh.clrs;
-            if (!(jh.sraw || (jh.clrs & 1)))
-              tiff_ifd[ifd].t_width *= jh.clrs;
-            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)
+            if (!dng_version && !strcasecmp(make, "SONY") && tiff_ifd[ifd].phint == 32803 &&
+                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD
             {
-              tiff_ifd[ifd].t_width /= 2;
-              tiff_ifd[ifd].t_height *= 2;
+              tiff_ifd[ifd].comp = 6;
+              tiff_ifd[ifd].bps = jh.bits;
+              tiff_ifd[ifd].samples = 1;
+            }
+            else
+            {
+              tiff_ifd[ifd].comp = 6;
+              tiff_ifd[ifd].bps = jh.bits;
+              tiff_ifd[ifd].t_width = jh.wide;
+              tiff_ifd[ifd].t_height = jh.high;
+              tiff_ifd[ifd].samples = jh.clrs;
+              if (!(jh.sraw || (jh.clrs & 1)))
+                tiff_ifd[ifd].t_width *= jh.clrs;
+              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)
+              {
+                tiff_ifd[ifd].t_width /= 2;
+                tiff_ifd[ifd].t_height *= 2;
+              }
+              i = order;
+              parse_tiff(tiff_ifd[ifd].offset + 12);
+              order = i;
             }
-            i = order;
-            parse_tiff(tiff_ifd[ifd].offset + 12);
-            order = i;
           }
         }
         break;
       }
     }
     else
     { /* processing Panasonic-specific "PanasonicRaw" tags */
       switch (tag)
       {
       case 0x0004: /*   4, SensorTopBorder */
-        imgdata.sizes.raw_inset_crop.ctop = get2();
+        imgdata.sizes.raw_inset_crops[0].ctop = get2();
         break;
       case 0x000a: /*  10, BitsPerSample */
         pana_bpp = get2();
         break;
       case 0x000b: /*  11, Compression */
         imPana.Compression = get2();
         break;
       case 0x000e: /*  14, LinearityLimitRed */
       case 0x000f: /*  15, LinearityLimitGreen */
       case 0x0010: /*  16, LinearityLimitBlue */
         imgdata.color.linear_max[tag - 14] = get2();
+        if (imgdata.color.linear_max[tag - 14] == 16383)
+            imgdata.color.linear_max[tag - 14] -= 64;
+        if (imgdata.color.linear_max[tag - 14] == 4095)
+          imgdata.color.linear_max[tag - 14] -= 16;
         if (tag == 0x000f) // 15, LinearityLimitGreen
           imgdata.color.linear_max[3] = imgdata.color.linear_max[1];
         break;
       case 0x0013: /*  19, WBInfo */
         if ((i = get2()) > 0x100)
           break;
         for (c = 0; c < i; c++)
         {
           if ((j = get2()) < 0x100)
           {
             icWBC[j][0] = get2();
             icWBC[j][2] = get2();
             icWBC[j][1] = icWBC[j][3] =
                 0x100;
           }
           else // light source out of EXIF numbers range
             get4();
         }
         break;
       case 0x0018: /* 24, HighISOMultiplierRed */
       case 0x0019: /* 25, HighISOMultiplierGreen */
       case 0x001a: /* 26, HighISOMultiplierBlue */
         imPana.HighISOMultiplier[tag - 0x0018] = get2();
         break;
       case 0x001c: /*  28, BlackLevelRed */
       case 0x001d: /*  29, BlackLevelGreen */
       case 0x001e: /*  30, BlackLevelBlue */
         pana_black[tag - 0x001c] = get2();
         break;
       case 0x002d: /*  45, RawFormat */
                    /* pana_encoding: tag 0x002d (45dec)
                         not used - DMC-LX1/FZ30/FZ50/L1/LX1/LX2
                         2 - RAW DMC-FZ8/FZ18
                         3 - RAW DMC-L10
                         4 - RW2 for most other models, including G9 in "pixel shift off"
                       mode and YUNEEC CGO4            (must add 15 to black levels for
                       RawFormat == 4)            5 - RW2 DC-GH5s; G9 in "pixel shift on"
                       mode            6 - RW2            DC-S1, DC-S1R in "pixel shift off"
                       mode            7 -            RW2 DC-S1R (probably            DC-S1 too) in
                       "pixel shift on" mode
                    */
         pana_encoding = get2();
         break;
       case 0x002f: /*  47, CropTop */
-        imgdata.sizes.raw_inset_crop.ctop = get2();
+        imgdata.sizes.raw_inset_crops[0].ctop = get2();
         break;
       case 0x0030: /*  48, CropLeft */
-        imgdata.sizes.raw_inset_crop.cleft = get2();
+        imgdata.sizes.raw_inset_crops[0].cleft = get2();
         break;
       case 0x0031: /*  49, CropBottom */
-        imgdata.sizes.raw_inset_crop.cheight =
-            get2() - imgdata.sizes.raw_inset_crop.ctop;
+        imgdata.sizes.raw_inset_crops[0].cheight =
+            get2() - imgdata.sizes.raw_inset_crops[0].ctop;
         break;
       case 0x0032: /*  50, CropRight */
-        imgdata.sizes.raw_inset_crop.cwidth =
-            get2() - imgdata.sizes.raw_inset_crop.cleft;
+        imgdata.sizes.raw_inset_crops[0].cwidth =
+            get2() - imgdata.sizes.raw_inset_crops[0].cleft;
         break;
       case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */
         if (iso_speed == 65535)
           iso_speed = get4();
         break;
       case 0x011c: /* 284, Gamma */
       {
         int n = get2();
         if (n >= 1024)
           imPana.gamma = (float)n / 1024.0f;
         else if (n >= 256)
           imPana.gamma = (float)n / 256.0f;
         else
           imPana.gamma = (float)n / 100.0f;
       }
       break;
       case 0x0120: /* 288, CameraIFD, contains tags 0x1xxx, 0x2xxx, 0x3xxx */
       {
         unsigned sorder = order;
         unsigned long sbase = base;
         base = ftell(ifp);
         order = get2();
         fseek(ifp, 2, SEEK_CUR);
         fseek(ifp, INT64(get4()) - 8LL, SEEK_CUR);
         parse_tiff_ifd(base);
         base = sbase;
         order = sorder;
       }
       break;
       case 0x0121: /* 289, Multishot, 0 is Off, 65536 is Pixel Shift */
         imPana.Multishot = get4();
         break;
       case 0x1001:
       	if (imPana.Multishot == 0) {
       	  imPana.Multishot = get4();
       	  if (imPana.Multishot)
       	    imPana.Multishot += 65535;
       	}
         break;
       case 0x1100:
         imPana.FocusStepNear = get2();
         break;
       case 0x1101:
         imPana.FocusStepCount = get2();
         break;
       case 0x1105:
         imPana.ZoomPosition = get4();
         break;
       case 0x1201:
         if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT)) {
           imPana.LensManufacturer = fgetc(ifp);
         } else if (type == 258) {
           imPana.LensManufacturer = get4();
           if (imPana.LensManufacturer >= 257) {
             ilm.LensMount = LIBRAW_MOUNT_LPS_L;
             ilm.LensFormat = LIBRAW_FORMAT_FF;
           }
         }
         break;
       case 0x1202:
         if (ilm.LensMount == LIBRAW_MOUNT_LPS_L) {
           if ((utmp = get2())) ilm.LensID = utmp;
         } else if ((imPana.LensManufacturer != 0xff) &&
                    (imPana.LensManufacturer != 0xffffffff)) {
           if ((utmp = (fgetc(ifp) << 8) | fgetc(ifp)))
             ilm.LensID = (imPana.LensManufacturer << 16) + utmp;
         }
         break;
       case 0x1203: /* 4611, FocalLengthIn35mmFormat, contained in 0x0120
                       CameraIFD */
         if (imgdata.lens.FocalLengthIn35mmFormat < 0.65f)
           imgdata.lens.FocalLengthIn35mmFormat = get2();
         break;
       case 0x2009: /* 8201, contained in 0x0120 CameraIFD */
         if ((pana_encoding == 4) || (pana_encoding == 5))
         {
           i = MIN(8, len);
           int permut[8] = {3, 2, 1, 0, 3 + 4, 2 + 4, 1 + 4, 0 + 4};
           imPana.BlackLevelDim = len;
           for (j = 0; j < i; j++)
           {
             imPana.BlackLevel[permut[j]] =
                 (float)(get2()) / (float)(powf(2.f, 14.f - pana_bpp));
           }
         }
         break;
       case 0x3420: /* 13344, WB_RedLevelAuto, contained in 0x0120 CameraIFD */
         icWBC[LIBRAW_WBI_Auto][0] = get2();
         icWBC[LIBRAW_WBI_Auto][1] = icWBC[LIBRAW_WBI_Auto][3] = 1024.0f;
         break;
       case 0x3421: /* 13345, WB_BlueLevelAuto, contained in 0x0120 CameraIFD */
         icWBC[LIBRAW_WBI_Auto][2] = get2();
         break;
       case 0x0002: /*   2, ImageWidth */
         tiff_ifd[ifd].t_width = getint(type);
         break;
       case 0x0003: /*   3, ImageHeight */
         tiff_ifd[ifd].t_height = getint(type);
         break;
       case 0x0005: /*   5, SensorLeftBorder */
         width = get2();
-        imgdata.sizes.raw_inset_crop.cleft = width;
+        imgdata.sizes.raw_inset_crops[0].cleft = width;
         break;
       case 0x0006: /*   6, SensorBottomBorder */
         height = get2();
-        imgdata.sizes.raw_inset_crop.cheight =
-            height - imgdata.sizes.raw_inset_crop.ctop;
+        imgdata.sizes.raw_inset_crops[0].cheight =
+            height - imgdata.sizes.raw_inset_crops[0].ctop;
         break;
       case 0x0007: /*   7, SensorRightBorder */
         i = get2();
         width += i;
-        imgdata.sizes.raw_inset_crop.cwidth =
-            i - imgdata.sizes.raw_inset_crop.cleft;
+        imgdata.sizes.raw_inset_crops[0].cwidth =
+            i - imgdata.sizes.raw_inset_crops[0].cleft;
         break;
       case 0x0009: /*   9, CFAPattern */
         if ((i = get2()))
           filters = i;
         break;
       case 0x0011: /*  17, RedBalance */
       case 0x0012: /*  18, BlueBalance */
         if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT) && len == 1)
           cam_mul[(tag - 0x0011) * 2] = get2() / 256.0;
         break;
       case 0x0017: /*  23, ISO */
         if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_SHORT))
           iso_speed = get2();
         break;
       case 0x0024: /*  36, WBRedLevel */
       case 0x0025: /*  37, WBGreenLevel */
       case 0x0026: /*  38, WBBlueLevel */
         cam_mul[tag - 0x0024] = get2();
         break;
       case 0x0027: /*  39, WBInfo2 */
         if ((i = get2()) > 0x100)
           break;
         for (c = 0; c < i; c++)
         {
           if ((j = get2()) < 0x100)
           {
             icWBC[j][0] = get2();
             icWBC[j][1] = icWBC[j][3] = get2();
             icWBC[j][2] = get2();
           }
           else
             fseek(ifp, 6, SEEK_CUR);
         }
         break;
         if (len < 50 || cam_mul[0] > 0.001f)
           break;
         fseek(ifp, 12, SEEK_CUR);
         FORC3 cam_mul[c] = get2();
         break;
       case 0x002e: /*  46, JpgFromRaw */
         if ((type != LIBRAW_EXIFTAG_TYPE_UNDEFINED) || (fgetc(ifp) != 0xff) || (fgetc(ifp) != 0xd8))
           break;
         thumb_offset = ftell(ifp) - 2;
         thumb_length = len;
         break;
 
       case 0x0118: /* 280, Panasonic RW2 offset */
         if (type != LIBRAW_EXIFTAG_TYPE_LONG)
           break;
         load_raw = &LibRaw::panasonic_load_raw;
         load_flags = 0x2008;
       case 0x0111: /* 273, StripOffset */
         if (len > 1 && len < 16384)
         {
           off_t sav = ftell(ifp);
           tiff_ifd[ifd].strip_offsets = (int *)calloc(len, sizeof(int));
           tiff_ifd[ifd].strip_offsets_count = len;
           for (int i = 0; i < (int)len; i++)
             tiff_ifd[ifd].strip_offsets[i] = get4() + base;
           fseek(ifp, sav, SEEK_SET); // restore position
         }
         /* fallthrough */
         tiff_ifd[ifd].offset = get4() + base;
         if (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0)
         {
           fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);
           if (ljpeg_start(&jh, 1))
           {
             tiff_ifd[ifd].comp = 6;
             tiff_ifd[ifd].t_width = jh.wide;
             tiff_ifd[ifd].t_height = jh.high;
             tiff_ifd[ifd].bps = jh.bits;
             tiff_ifd[ifd].samples = jh.clrs;
             if (!(jh.sraw || (jh.clrs & 1)))
               tiff_ifd[ifd].t_width *= jh.clrs;
             if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)
             {
               tiff_ifd[ifd].t_width /= 2;
               tiff_ifd[ifd].t_height *= 2;
             }
             i = order;
             parse_tiff(tiff_ifd[ifd].offset + 12);
             order = i;
           }
         }
         break;
       }
 
     } /* processing of Panasonic-specific tags finished */
 
     switch (tag)
     {            /* processing of general EXIF tags */
     case 0xf000: /* 61440, Fuji HS10 table */
       fseek(ifp, get4() + base, SEEK_SET);
       parse_tiff_ifd(base);
       break;
     case 0x00fe: /* NewSubfileType */
       tiff_ifd[ifd].newsubfiletype = getreal(type);
       break;
     case 0x0100: /* 256, ImageWidth */
     case 0xf001: /* 61441, Fuji RAF RawImageFullWidth */
       tiff_ifd[ifd].t_width = getint(type);
       break;
     case 0x0101: /* 257, ImageHeight */
     case 0xf002: /* 61442, Fuji RAF RawImageFullHeight */
       tiff_ifd[ifd].t_height = getint(type);
       break;
     case 0x0102: /* 258, BitsPerSample */
     case 0xf003: /* 61443, Fuji RAF 0xf003 */
-      tiff_ifd[ifd].samples = len & 7;
+      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115
+        tiff_ifd[ifd].samples = len & 7;
       tiff_ifd[ifd].bps = getint(type);
       if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)
         tiff_bps = tiff_ifd[ifd].bps;
       break;
     case 0xf006: /* 61446, Fuji RAF 0xf006 */
       raw_height = 0;
       if (tiff_ifd[ifd].bps > 12)
         break;
       load_raw = &LibRaw::packed_load_raw;
       load_flags = get4() ? 24 : 80;
       break;
     case 0x0103: /* 259, Compression */
                  /*
                     262	 = Kodak 262
                   32767  = Sony ARW Compressed
                   32769  = Packed RAW
                   32770  = Samsung SRW Compressed
                   32772  = Samsung SRW Compressed 2
                   32867  = Kodak KDC Compressed
                   34713  = Nikon NEF Compressed
                   65000  = Kodak DCR Compressed
                   65535  = Pentax PEF Compressed
                  */
       tiff_ifd[ifd].comp = getint(type);
       break;
     case 0x0106: /* 262, PhotometricInterpretation */
       tiff_ifd[ifd].phint = get2();
       break;
     case 0x010e: /* 270, ImageDescription */
       fread(desc, 512, 1, ifp);
       break;
     case 0x010f: /* 271, Make */
       fgets(make, 64, ifp);
       break;
     case 0x0110: /* 272, Model */
       if (!strncmp(make, "Hasselblad", 10) && model[0] &&
           (imHassy.format != LIBRAW_HF_Imacon))
         break;
       fgets(model, 64, ifp);
       break;
     case 0x0116: // 278
       tiff_ifd[ifd].rows_per_strip = getint(type);
       break;
     case 0x0112: /* 274, Orientation */
       tiff_ifd[ifd].t_flip = "50132467"[get2() & 7] - '0';
       break;
     case 0x0115: /* 277, SamplesPerPixel */
       tiff_ifd[ifd].samples = getint(type) & 7;
       break;
     case 0x0152: /* Extrasamples */
       tiff_ifd[ifd].extrasamples = (getint(type) & 0xff) + 1024;
       break;
     case 0x0117: /* 279, StripByteCounts */
       if (len > 1 && len < 16384)
       {
         off_t sav = ftell(ifp);
         tiff_ifd[ifd].strip_byte_counts = (int *)calloc(len, sizeof(int));
         tiff_ifd[ifd].strip_byte_counts_count = len;
         for (int i = 0; i < (int)len; i++)
           tiff_ifd[ifd].strip_byte_counts[i] = get4();
         fseek(ifp, sav, SEEK_SET); // restore position
       }
       /* fallback */
     case 0x0202: // 514
     case 0xf008: // 61448
       tiff_ifd[ifd].bytes = get4();
       break;
     case 0xf00e: // 61454, FujiFilm "As Shot"
       FORC3 cam_mul[GRBG_2_RGBG(c)] = getint(type);
       break;
     case 0x0131: /* 305, Software */
       fgets(software, 64, ifp);
       if (!strncmp(software, "Adobe", 5) || !strncmp(software, "dcraw", 5) ||
           !strncmp(software, "UFRaw", 5) || !strncmp(software, "Bibble", 6) ||
           !strcmp(software, "Digital Photo Professional"))
         is_raw = 0;
       break;
     case 0x0132: /* 306, DateTime */
       get_timestamp(0);
       break;
     case 0x013b: /* 315, Artist */
       fread(artist, 64, 1, ifp);
       break;
     case 0x013d: // 317
       tiff_ifd[ifd].predictor = getint(type);
       break;
     case 0x0142: /* 322, TileWidth */
       tiff_ifd[ifd].t_tile_width = getint(type);
       break;
     case 0x0143: /* 323, TileLength */
       tiff_ifd[ifd].t_tile_length = getint(type);
       break;
     case 0x0144: /* 324, TileOffsets */
       tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();
       if (len == 1)
         tiff_ifd[ifd].t_tile_width = tiff_ifd[ifd].t_tile_length = 0;
       if (len == 4)
       {
         load_raw = &LibRaw::sinar_4shot_load_raw;
         is_raw = 5;
       }
       break;
     case 0x0145: // 325
       tiff_ifd[ifd].bytes = len > 1 ? ftell(ifp) : get4();
       break;
     case 0x014a: /* 330, SubIFDs */
       if (!strcmp(model, "DSLR-A100") && tiff_ifd[ifd].t_width == 3872)
       {
         load_raw = &LibRaw::sony_arw_load_raw;
         data_offset = get4() + base;
         ifd++;
         if (ifd >= int(sizeof tiff_ifd / sizeof tiff_ifd[0]))
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
         break;
       }
       if (!strncmp(make, "Hasselblad", 10) &&
           libraw_internal_data.unpacker_data.hasselblad_parser_flag)
       {
         fseek(ifp, ftell(ifp) + 4, SEEK_SET);
         fseek(ifp, get4() + base, SEEK_SET);
         parse_tiff_ifd(base);
         break;
       }
       if (len > 1000)
         len = 1000; /* 1000 SubIFDs is enough */
       while (len--)
       {
         i = ftell(ifp);
         fseek(ifp, get4() + base, SEEK_SET);
         if (parse_tiff_ifd(base))
           break;
         fseek(ifp, i + 4, SEEK_SET);
       }
       break;
     case 0x0153: // 339
       tiff_ifd[ifd].sample_format = getint(type);
       break;
     case 0x0190: // 400
       strcpy(make, "Sarnoff");
       maximum = 0xfff;
       break;
     case 0x02bc: // 700
       if ((tagtypeIs(LIBRAW_EXIFTAG_TYPE_BYTE) ||
           tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII) ||
           tagtypeIs(LIBRAW_EXIFTAG_TYPE_SBYTE) ||
           tagtypeIs(LIBRAW_EXIFTOOLTAGTYPE_binary)) &&
           (len > 1) && (len < 5100000))
       {
         xmpdata = (char *)malloc(xmplen = len + 1);
         fread(xmpdata, len, 1, ifp);
         xmpdata[len] = 0;
       }
       break;
     case 0x7000:
       imSony.SonyRawFileType = get2();
       break;
     case 0x7010: // 28688
       FORC4 sony_curve[c + 1] = get2() >> 2 & 0xfff;
       for (i = 0; i < 5; i++)
         for (j = sony_curve[i] + 1; j <= (int)sony_curve[i + 1]; j++)
           curve[j] = curve[j - 1] + (1 << i);
       break;
     case 0x7200: // 29184, Sony SR2Private
       sony_offset = get4();
       break;
     case 0x7201: // 29185, Sony SR2Private
       sony_length = get4();
       break;
     case 0x7221: // 29217, Sony SR2Private
       sony_key = get4();
       break;
     case 0x7250: // 29264, Sony SR2Private
       parse_minolta(ftell(ifp));
       raw_width = 0;
       break;
     case 0x7303: // 29443, Sony SR2SubIFD
       FORC4 cam_mul[GRBG_2_RGBG(c)] = get2();
       break;
     case 0x7313: // 29459, Sony SR2SubIFD
       FORC4 cam_mul[RGGB_2_RGBG(c)] = get2();
       break;
     case 0x7310: // 29456, Sony SR2SubIFD
       FORC4 cblack[RGGB_2_RGBG(c)] = get2();
       i = cblack[3];
       FORC3 if (i > (int)cblack[c]) i = cblack[c];
       FORC4 cblack[c] -= i;
       black = i;
       break;
     case 0x827d: /* 33405, Model2 */
                  /*
                   for Kodak ProBack 645 PB645x-yyyy 'x' is:
                   'M' for Mamiya 645
                   'C' for Contax 645
                   'H' for Hasselblad H-series
                  */
       fgets(model2, 64, ifp);
       break;
     case 0x828d: /* 33421, CFARepeatPatternDim */
       if (get2() == 6 && get2() == 6)
         tiff_ifd[ifd].t_filters = filters = 9;
       break;
     case 0x828e: /* 33422, CFAPattern */
       if (filters == 9)
       {
         FORC(36)((char *)xtrans)[c] = fgetc(ifp) & 3;
         break;
       }
     case 0xfd09: /* 64777, Kodak P-series */
       if (len == 36)
       {
         tiff_ifd[ifd].t_filters = filters = 9;
         colors = 3;
         FORC(36) xtrans[0][c] = fgetc(ifp) & 3;
       }
       else if (len > 0)
       {
         if ((plen = len) > 16)
           plen = 16;
         fread(cfa_pat, 1, plen, ifp);
         for (colors = cfa = i = 0; i < (int)plen && colors < 4; i++)
         {
           if (cfa_pat[i] > 31)
             continue; // Skip wrong data
           colors += !(cfa & (1 << cfa_pat[i]));
           cfa |= 1 << cfa_pat[i];
         }
         if (cfa == 070)
           memcpy(cfa_pc, "\003\004\005", 3); /* CMY */
         if (cfa == 072)
           memcpy(cfa_pc, "\005\003\004\001", 4); /* GMCY */
         goto guess_cfa_pc;
       }
       break;
     case 0x8290: // 33424
     case 0xfe00: // 65024
       fseek(ifp, get4() + base, SEEK_SET);
       parse_kodak_ifd(base);
       break;
     case 0x829a: /* 33434, ExposureTime */
       tiff_ifd[ifd].t_shutter = shutter = getreal(type);
       break;
     case 0x829d: /* 33437, FNumber */
       aperture = getreal(type);
       break;
     case 0x9400:
       imCommon.exifAmbientTemperature = getreal(type);
       if ((imCommon.CameraTemperature > -273.15f) &&
           ((OlyID == OlyID_TG_5) || (OlyID == OlyID_TG_6)))
         imCommon.CameraTemperature +=
             imCommon.exifAmbientTemperature;
       break;
     case 0x9401:
       imCommon.exifHumidity = getreal(type);
       break;
     case 0x9402:
       imCommon.exifPressure = getreal(type);
       break;
     case 0x9403:
       imCommon.exifWaterDepth = getreal(type);
       break;
     case 0x9404:
       imCommon.exifAcceleration = getreal(type);
       break;
     case 0x9405:
       imCommon.exifCameraElevationAngle = getreal(type);
       break;
     case 0xa405: // FocalLengthIn35mmFormat
       imgdata.lens.FocalLengthIn35mmFormat = get2();
       break;
     case 0xa431: // BodySerialNumber
     case 0xc62f:
       stmread(imgdata.shootinginfo.BodySerial, len, ifp);
       break;
     case 0xa432: // LensInfo, 42034dec, Lens Specification per EXIF standard
       imgdata.lens.MinFocal = getreal(type);
       imgdata.lens.MaxFocal = getreal(type);
       imgdata.lens.MaxAp4MinFocal = getreal(type);
       imgdata.lens.MaxAp4MaxFocal = getreal(type);
       break;
     case 0xa435: // LensSerialNumber
       stmread(imgdata.lens.LensSerial, len, ifp);
       break;
     case 0xc630: // DNG LensInfo, Lens Specification per EXIF standard
       imgdata.lens.MinFocal = getreal(type);
       imgdata.lens.MaxFocal = getreal(type);
       imgdata.lens.MaxAp4MinFocal = getreal(type);
       imgdata.lens.MaxAp4MaxFocal = getreal(type);
       break;
     case 0xa420: /* 42016, ImageUniqueID */
       stmread(imgdata.color.ImageUniqueID, len, ifp);
       break;
     case 0xc65d: /* 50781, RawDataUniqueID */
       imgdata.color.RawDataUniqueID[16] = 0;
       fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);
       break;
     case 0xa433: // LensMake
       stmread(imgdata.lens.LensMake, len, ifp);
       break;
     case 0xa434: // LensModel
       stmread(imgdata.lens.Lens, len, ifp);
       if (!strncmp(imgdata.lens.Lens, "----", 4))
         imgdata.lens.Lens[0] = 0;
       break;
     case 0x9205:
       imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
       break;
     case 0x8602: /* 34306, Leaf white balance */
       FORC4
       {
         int q = get2();
         if (q)
           cam_mul[GRGB_2_RGBG(c)] = 4096.0 / q;
       }
       break;
     case 0x8603: /* 34307, Leaf CatchLight color matrix */
       fread(software, 1, 7, ifp);
       if (strncmp(software, "MATRIX", 6))
         break;
       colors = 4;
       for (raw_color = i = 0; i < 3; i++)
       {
         FORC4 fscanf(ifp, "%f", &rgb_cam[i][GRGB_2_RGBG(c)]);
         if (!use_camera_wb)
           continue;
         num = 0;
         FORC4 num += rgb_cam[i][c];
         FORC4 rgb_cam[i][c] /= MAX(1, num);
       }
       break;
     case 0x8606: /* 34310, Leaf metadata */
       parse_mos(ftell(ifp));
     case 0x85ff: // 34303
       strcpy(make, "Leaf");
       break;
     case 0x8769: /* 34665, EXIF tag */
       fseek(ifp, get4() + base, SEEK_SET);
       parse_exif(base);
       break;
     case 0x8825: /* 34853, GPSInfo tag */
     {
       unsigned pos;
       fseek(ifp, pos = (get4() + base), SEEK_SET);
       parse_gps(base);
       fseek(ifp, pos, SEEK_SET);
       parse_gps_libraw(base);
     }
     break;
     case 0x8773: /* 34675, InterColorProfile */
     case 0xc68f: /* 50831, AsShotICCProfile */
       profile_offset = ftell(ifp);
       profile_length = len;
       break;
     case 0x9102: /* 37122, CompressedBitsPerPixel */
       kodak_cbpp = get4();
       break;
     case 0x920a: /* 37386, FocalLength */
       focal_len = getreal(type);
       break;
     case 0x9211: /* 37393, ImageNumber */
       shot_order = getint(type);
       break;
     case 0x9215: /* 37397, ExposureIndex */
       imCommon.exifExposureIndex = getreal(type);
       break;
     case 0x9218: /* 37400, old Kodak KDC tag */
       for (raw_color = i = 0; i < 3; i++)
       {
         getreal(type);
         FORC3 rgb_cam[i][c] = getreal(type);
       }
       break;
     case 0xa010: // 40976
       strip_offset = get4();
       switch (tiff_ifd[ifd].comp)
       {
       case 0x8002: // 32770
         load_raw = &LibRaw::samsung_load_raw;
         break;
       case 0x8004: // 32772
         load_raw = &LibRaw::samsung2_load_raw;
         break;
       case 0x8005: // 32773
         load_raw = &LibRaw::samsung3_load_raw;
         break;
       }
       break;
     case 0xb4c3: /* 46275, Imacon tags */
       imHassy.format = LIBRAW_HF_Imacon;
       strcpy(make, "Imacon");
       data_offset = ftell(ifp);
       ima_len = len;
       break;
     case 0xb4c7: // 46279
       if (!ima_len)
         break;
       fseek(ifp, 38, SEEK_CUR);
     case 0xb4c2: // 46274
       fseek(ifp, 40, SEEK_CUR);
       raw_width = get4();
       raw_height = get4();
       left_margin = get4() & 7;
       width = raw_width - left_margin - (get4() & 7);
       top_margin = get4() & 7;
       height = raw_height - top_margin - (get4() & 7);
       if (raw_width == 7262 && ima_len == 234317952)
       {
         height = 5412;
         width = 7216;
         left_margin = 7;
         filters = 0;
       }
       else if (raw_width == 7262)
       {
         height = 5444;
         width = 7244;
         left_margin = 7;
       }
       fseek(ifp, 52, SEEK_CUR);
       FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       fseek(ifp, 114, SEEK_CUR);
       flip = (get2() >> 7) * 90;
       if (width * (height * 6l) == ima_len)
       {
         if (flip % 180 == 90)
           SWAP(width, height);
         raw_width = width;
         raw_height = height;
         left_margin = top_margin = filters = flip = 0;
       }
       c = unsigned(height) * unsigned(width) / 1000000;
       if (c == 32)
         c--;
       sprintf(model, "Ixpress %d-Mp", c);
       load_raw = &LibRaw::imacon_full_load_raw;
       if (filters)
       {
         if (left_margin & 1)
           filters = 0x61616161;
         load_raw = &LibRaw::unpacked_load_raw;
       }
       maximum = 0xffff;
       break;
     case 0xc516: /* 50454, Sinar tag */
     case 0xc517: // 50455
       if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))
         break;
       if (fread(cbuf, 1, len, ifp) != (int)len)
         throw LIBRAW_EXCEPTION_IO_CORRUPT; // cbuf to be free'ed in recycle
       cbuf[len - 1] = 0;
       for (cp = cbuf - 1; cp && cp < cbuf + len; cp = strchr(cp, '\n'))
         if (!strncmp(++cp, "Neutral ", 8))
           sscanf(cp + 8, "%f %f %f", cam_mul, cam_mul + 1, cam_mul + 2);
       free(cbuf);
       break;
     case 0xc51a: // 50458
       if (!make[0])
         strcpy(make, "Hasselblad");
       break;
     case 0xc51b: /* 50459, Hasselblad tag */
       if (!libraw_internal_data.unpacker_data.hasselblad_parser_flag)
       {
         libraw_internal_data.unpacker_data.hasselblad_parser_flag = 1;
         i = order;
         j = ftell(ifp);
         c = tiff_nifds;
         order = get2();
         fseek(ifp, j + (get2(), get4()), SEEK_SET);
         parse_tiff_ifd(j);
         maximum = 0xffff;
         tiff_nifds = c;
         order = i;
         break;
       }
     case 0xc612: /* 50706, DNGVersion */
       FORC4 dng_version = (dng_version << 8) + fgetc(ifp);
       if (!make[0])
         strcpy(make, "DNG");
       is_raw = 1;
       break;
     case 0xc614: /* 50708, UniqueCameraModel */
       stmread(imgdata.color.UniqueCameraModel, len, ifp);
       if (model[0])
         break;
       strncpy(make, imgdata.color.UniqueCameraModel,
               MIN(len, sizeof(imgdata.color.UniqueCameraModel)));
       if ((cp = strchr(make, ' ')))
       {
         strcpy(model, cp + 1);
         *cp = 0;
       }
       break;
     case 0xc616: /* 50710, CFAPlaneColor */
       if (filters == 9)
         break;
       if (len > 4)
         len = 4;
       colors = len;
       fread(cfa_pc, 1, colors, ifp);
     guess_cfa_pc:
       FORCC tab[cfa_pc[c]] = c;
       cdesc[c] = 0;
       for (i = 16; i--;)
         filters = filters << 2 | tab[cfa_pat[i % plen]];
       filters -= !filters;
       tiff_ifd[ifd].t_filters = filters;
       break;
     case 0xc617: /* 50711, CFALayout */
       if (get2() == 2)
         tiff_ifd[ifd].t_fuji_width = fuji_width = 1;
       break;
     case 0x0123: // 291
     case 0xc618: /* 50712, LinearizationTable */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINTABLE;
       tiff_ifd[ifd].lineartable_offset = ftell(ifp);
       tiff_ifd[ifd].lineartable_len = len;
       linear_table(len);
       break;
     case 0xc619: /* 50713, BlackLevelRepeatDim */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
       tiff_ifd[ifd].dng_levels.dng_fcblack[4] =
           tiff_ifd[ifd].dng_levels.dng_cblack[4] = cblack[4] = get2();
       tiff_ifd[ifd].dng_levels.dng_fcblack[5] =
           tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[5] = get2();
       if (cblack[4] * cblack[5] >
           (LIBRAW_CBLACK_SIZE -
            7)) // Use last cblack item as DNG black level count
         tiff_ifd[ifd].dng_levels.dng_fcblack[4] =
             tiff_ifd[ifd].dng_levels.dng_fcblack[5] =
                 tiff_ifd[ifd].dng_levels.dng_cblack[4] =
                     tiff_ifd[ifd].dng_levels.dng_cblack[5] = cblack[4] =
                         cblack[5] = 1;
       break;
 
     case 0xf00c:
       if (imFuji.RAFDataGeneration != 4096)
       {
         unsigned fwb[4];
         FORC4 fwb[c] = get4();
         if (fwb[3] < 0x100)
         {
           FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];
           icWBC[fwb[3]][3] = icWBC[fwb[3]][1];
           if ((fwb[3] == 17) &&                                      // Tungsten WB
               (libraw_internal_data.unpacker_data.lenRAFData > 3) &&
               (libraw_internal_data.unpacker_data.lenRAFData < 10240000))
           {
             INT64 f_save = ftell(ifp);
             rafdata = (ushort *)malloc(
                 sizeof(ushort) * libraw_internal_data.unpacker_data.lenRAFData);
             fseek(ifp, libraw_internal_data.unpacker_data.posRAFData, SEEK_SET);
             fread(rafdata, sizeof(ushort),
                   libraw_internal_data.unpacker_data.lenRAFData, ifp);
             fseek(ifp, f_save, SEEK_SET);
 
             uchar *PrivateMknBuf = (uchar *)rafdata;
             int PrivateMknLength = libraw_internal_data.unpacker_data.lenRAFData
                                    << 1;
             for (int pos = 0; pos < PrivateMknLength - 16; pos++)
             {
               if (!memcmp(PrivateMknBuf + pos, "TSNERDTS", 8)) // STDRENST
               {
                 imFuji.isTSNERDTS = 1;
                 break;
               }
             }
-            int fj;
+            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef
+            int is34 = 0;
+            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S
+                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II
+                (imFuji.RAFDataVersion == 0x0262) || // X-T4
+                (imFuji.RAFDataVersion == 0x0264) || // X-S10
+                (imFuji.RAFDataVersion == 0x0265) || // X-E4
+                !strcmp(model, "X-Pro3")     ||
+                !strcmp(model, "GFX 100S")   ||
+                !strcmp(model, "GFX100S")    ||
+                !strcmp(model, "GFX 50S II") ||
+                !strcmp(model, "GFX50S II")  ||
+                !strcmp(model, "X100V")      ||
+                !strcmp(model, "X-T4")       ||
+                !strcmp(model, "X-E4")       ||
+                !strcmp(model, "X-S10"))
+// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K
+// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras
+              is34 = 1;
+
             for (int fi = 0;
-                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)
-            { // looking for Tungsten WB
+                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB
+            {
               if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&
-                  (fwb[2] == rafdata[fi + 2]))
-              { // found Tungsten WB
+                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB
+              {
                 if (rafdata[fi - 15] !=
                     fwb[0]) // 15 is offset of Tungsten WB from the first
                             // preset, Fine Weather WB
                   continue;
-                for (int wb_ind = 0, ofst = fi - 15; wb_ind < Fuji_wb_list1.size();
+                for (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();
                      wb_ind++, ofst += 3)
                 {
                   icWBC[Fuji_wb_list1[wb_ind]][1] =
                       icWBC[Fuji_wb_list1[wb_ind]][3] = rafdata[ofst];
                   icWBC[Fuji_wb_list1[wb_ind]][0] = rafdata[ofst + 1];
                   icWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];
                 }
 
-                if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                    (imFuji.RAFDataVersion == 0x0261) || // X100V
-                    (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                    (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                if (is34)
                   fi += 24;
                 fi += 96;
                 for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table
                 {
                   if (rafdata[fj] != rafdata[fi])
                   {
                     fj -= 93;
-// X-Pro3 has 34 CCT values instead of 31, manual still clames 2500 to 10000 K
-// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras
-                    if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                        (imFuji.RAFDataVersion == 0x0261) || // X100V
-                        (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                        (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                    if (is34)
                       fj -= 9;
+// printf ("wb start in DNG: 0x%04x\n", fj*2-0x4e);
                     for (int iCCT = 0, ofst = fj; iCCT < 31;
                          iCCT++, ofst += 3)
                     {
                       icWBCCTC[iCCT][0] = FujiCCT_K[iCCT];
                       icWBCCTC[iCCT][1] = rafdata[ofst + 1];
                       icWBCCTC[iCCT][2] = icWBCCTC[iCCT][4] = rafdata[ofst];
                       icWBCCTC[iCCT][3] = rafdata[ofst + 2];
                     }
                     break;
                   }
                 }
                 free(rafdata);
                 break;
               }
             }
           }
         }
         FORC4 fwb[c] = get4();
         if (fwb[3] < 0x100) {
           FORC3 icWBC[fwb[3]][GRBG_2_RGBG(c)] = fwb[c];
           icWBC[fwb[3]][3] = icWBC[fwb[3]][1];
         }
       }
       break;
     case 0xf00d:
       if (imFuji.RAFDataGeneration != 4096)
       {
         FORC3 icWBC[LIBRAW_WBI_Auto][GRBG_2_RGBG(c)] = getint(type);
         icWBC[LIBRAW_WBI_Auto][3] = icWBC[LIBRAW_WBI_Auto][1];
       }
       break;
     case 0xc615: /* 50709, LocalizedCameraModel */
       stmread(imgdata.color.LocalizedCameraModel, len, ifp);
       break;
     case 0xf00a: // 61450
       cblack[4] = cblack[5] = MIN(sqrt((double)len), 64);
     case 0xc61a: /* 50714, BlackLevel */
       if (tiff_ifd[ifd].samples > 1 &&
           tiff_ifd[ifd].samples == (int)len) // LinearDNG, per-channel black
       {
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
         for (i = 0; i < 4 && i < (int)len; i++)
         {
           tiff_ifd[ifd].dng_levels.dng_fcblack[i] = getreal(type);
           tiff_ifd[ifd].dng_levels.dng_cblack[i] = cblack[i] =
               tiff_ifd[ifd].dng_levels.dng_fcblack[i] + 0.5;
         }
         // Record len in last cblack field
         tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] = len;
 
         tiff_ifd[ifd].dng_levels.dng_fblack =
             tiff_ifd[ifd].dng_levels.dng_black = black = 0;
       }
       else if (tiff_ifd[ifd].samples > 1 // Linear DNG w repeat dim
                && (tiff_ifd[ifd].samples * cblack[4] * cblack[5] == len))
       {
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
         tiff_ifd[ifd].dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1] =
             cblack[LIBRAW_CBLACK_SIZE - 1] = len;
         for (i = 0; i < (int)len && i < LIBRAW_CBLACK_SIZE - 7; i++)
         {
           tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] = getreal(type);
           tiff_ifd[ifd].dng_levels.dng_cblack[i + 6] = cblack[i + 6] =
               tiff_ifd[ifd].dng_levels.dng_fcblack[i + 6] + 0.5;
         }
       }
       else if ((cblack[4] * cblack[5] < 2) && len == 1)
       {
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
         tiff_ifd[ifd].dng_levels.dng_fblack = getreal(type);
         black = tiff_ifd[ifd].dng_levels.dng_black =
             tiff_ifd[ifd].dng_levels.dng_fblack;
       }
       else if (cblack[4] * cblack[5] <= len)
       {
         FORC(int(cblack[4] * cblack[5]))
         {
           tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c] = getreal(type);
           cblack[6 + c] = tiff_ifd[ifd].dng_levels.dng_fcblack[6 + c];
         }
         black = 0;
         FORC4
         cblack[c] = 0;
 
         if (tag == 0xc61a)
         {
           tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
           FORC(int(cblack[4] * cblack[5]))
           tiff_ifd[ifd].dng_levels.dng_cblack[6 + c] = cblack[6 + c];
           tiff_ifd[ifd].dng_levels.dng_fblack = 0;
           tiff_ifd[ifd].dng_levels.dng_black = 0;
           FORC4
           tiff_ifd[ifd].dng_levels.dng_fcblack[c] =
               tiff_ifd[ifd].dng_levels.dng_cblack[c] = 0;
         }
       }
       break;
     case 0xc61b: /* 50715, BlackLevelDeltaH */
     case 0xc61c: /* 50716, BlackLevelDeltaV */
       for (num = i = 0; i < (int)len && i < 65536; i++)
         num += getreal(type);
       if (len > 0)
       {
         black += num / len + 0.5;
         tiff_ifd[ifd].dng_levels.dng_fblack += num / float(len);
         tiff_ifd[ifd].dng_levels.dng_black += num / len + 0.5;
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BLACK;
       }
       break;
     case 0xc61d: /* 50717, WhiteLevel */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_WHITE;
       tiff_ifd[ifd].dng_levels.dng_whitelevel[0] = maximum = getint(type);
       if (tiff_ifd[ifd].samples > 1) // Linear DNG case
         for (i = 1; i < 4 && i < (int)len; i++)
           tiff_ifd[ifd].dng_levels.dng_whitelevel[i] = getint(type);
       break;
     case 0xc61e: /* DefaultScale */
     {
       float q1 = getreal(type);
       float q2 = getreal(type);
       if (q1 > 0.00001f && q2 > 0.00001f)
       {
         pixel_aspect = q1 / q2;
         if (pixel_aspect > 0.995 && pixel_aspect < 1.005)
           pixel_aspect = 1.0;
       }
     }
     break;
     case 0xc61f: /* 50719, DefaultCropOrigin */
       if (len == 2)
       {
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPORIGIN;
         tiff_ifd[ifd].dng_levels.default_crop[0] = getreal(type);
         tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);
         if (!strncasecmp(make, "SONY", 4))
         {
-          imgdata.sizes.raw_inset_crop.cleft =
+          imgdata.sizes.raw_inset_crops[0].cleft =
               tiff_ifd[ifd].dng_levels.default_crop[0];
-          imgdata.sizes.raw_inset_crop.ctop =
+          imgdata.sizes.raw_inset_crops[0].ctop =
               tiff_ifd[ifd].dng_levels.default_crop[1];
         }
       }
       break;
 
     case 0xc620: /* 50720, DefaultCropSize */
       if (len == 2)
       {
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_CROPSIZE;
         tiff_ifd[ifd].dng_levels.default_crop[2] = getreal(type);
         tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);
         if (!strncasecmp(make, "SONY", 4))
         {
-          imgdata.sizes.raw_inset_crop.cwidth =
+          imgdata.sizes.raw_inset_crops[0].cwidth =
               tiff_ifd[ifd].dng_levels.default_crop[2];
-          imgdata.sizes.raw_inset_crop.cheight =
+          imgdata.sizes.raw_inset_crops[0].cheight =
               tiff_ifd[ifd].dng_levels.default_crop[3];
         }
       }
       break;
 
+    case 0xc7b5: /* 51125 DefaultUserCrop */
+      if (len == 4)
+      {
+          int cnt = 0;
+          FORC4
+          {
+              float v = getreal(type);
+              if (v >= 0.f && v <= 1.f)
+              {
+                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;
+                  cnt++;
+              }
+          }
+          if(cnt == 4 // valid values
+              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom
+              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right
+              )
+            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;
+      }
+      break;
     case 0x74c7:
       if ((len == 2) && !strncasecmp(make, "SONY", 4))
       {
-        imgdata.sizes.raw_inset_crop.cleft = get4();
-        imgdata.sizes.raw_inset_crop.ctop = get4();
+        imgdata.sizes.raw_inset_crops[0].cleft = get4();
+        imgdata.sizes.raw_inset_crops[0].ctop = get4();
       }
       break;
 
     case 0x74c8:
       if ((len == 2) && !strncasecmp(make, "SONY", 4))
       {
-        imgdata.sizes.raw_inset_crop.cwidth = get4();
-        imgdata.sizes.raw_inset_crop.cheight = get4();
+        imgdata.sizes.raw_inset_crops[0].cwidth = get4();
+        imgdata.sizes.raw_inset_crops[0].cheight = get4();
       }
       break;
 
     case 0xc65a: // 50778
       tiff_ifd[ifd].dng_color[0].illuminant = get2();
       tiff_ifd[ifd].dng_color[0].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;
       break;
     case 0xc65b: // 50779
       tiff_ifd[ifd].dng_color[1].illuminant = get2();
       tiff_ifd[ifd].dng_color[1].parsedfields |= LIBRAW_DNGFM_ILLUMINANT;
       break;
 
     case 0xc621: /* 50721, ColorMatrix1 */
     case 0xc622: /* 50722, ColorMatrix2 */
     {
       int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);
       i = tag == 0xc621 ? 0 : 1;
       if (chan)
       {
         tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_COLORMATRIX;
         imHassy.nIFD_CM[i] = ifd;
       }
       FORC(chan) for (j = 0; j < 3; j++)
       {
         tiff_ifd[ifd].dng_color[i].colormatrix[c][j] = cm[c][j] = getreal(type);
       }
       use_cm = 1;
     }
     break;
 
     case 0xc714: /* ForwardMatrix1 */
     case 0xc715: /* ForwardMatrix2 */
     {
       int chan = (len == 9) ? 3 : (len == 12 ? 4 : 0);
       i = tag == 0xc714 ? 0 : 1;
       if (chan)
         tiff_ifd[ifd].dng_color[i].parsedfields |= LIBRAW_DNGFM_FORWARDMATRIX;
       for (j = 0; j < 3; j++)
         FORC(chan)
         {
           tiff_ifd[ifd].dng_color[i].forwardmatrix[j][c] = fm[j][c] =
               getreal(type);
         }
     }
     break;
 
     case 0xc623: /* 50723, CameraCalibration1 */
     case 0xc624: /* 50724, CameraCalibration2 */
     {
       int chan = (len == 9) ? 3 : (len == 16 ? 4 : 0);
       j = tag == 0xc623 ? 0 : 1;
       if (chan)
         tiff_ifd[ifd].dng_color[j].parsedfields |= LIBRAW_DNGFM_CALIBRATION;
       for (i = 0; i < chan; i++)
         FORC(chan)
         {
           tiff_ifd[ifd].dng_color[j].calibration[i][c] = cc[i][c] =
               getreal(type);
         }
     }
     break;
     case 0xc627: /* 50727, AnalogBalance */
       if (len >= 3)
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ANALOGBALANCE;
       for (c = 0; c < (int)len && c < 4; c++)
       {
         tiff_ifd[ifd].dng_levels.analogbalance[c] = ab[c] = getreal(type);
       }
       break;
     case 0xc628: /* 50728, AsShotNeutral */
       if (len >= 3)
         tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_ASSHOTNEUTRAL;
       for (c = 0; c < (int)len && c < 4; c++)
         tiff_ifd[ifd].dng_levels.asshotneutral[c] = asn[c] = getreal(type);
       break;
     case 0xc629: /* 50729, AsShotWhiteXY */
       xyz[0] = getreal(type);
       xyz[1] = getreal(type);
       xyz[2] = 1 - xyz[0] - xyz[1];
       FORC3 xyz[c] /= LibRaw_constants::d65_white[c];
       break;
     case 0xc62a: /* DNG: 50730 BaselineExposure */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_BASELINEEXPOSURE;
       tiff_ifd[ifd].dng_levels.baseline_exposure = getreal(type);
       break;
     case 0xc62e: /* DNG: 50734 LinearResponseLimit */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_LINEARRESPONSELIMIT;
       tiff_ifd[ifd].dng_levels.LinearResponseLimit = getreal(type);
       break;
 
     case 0xc634: /* 50740 : DNG Adobe, DNG Pentax, Sony SR2, DNG Private */
       {
         char mbuf[64];
         INT64 curr_pos, start_pos = ftell(ifp);
         unsigned MakN_order, m_sorder = order;
         unsigned MakN_length;
         unsigned pos_in_original_raw;
         fread(mbuf, 1, 6, ifp);
 
         if (!strcmp(mbuf, "Adobe"))
         {
           order = 0x4d4d; // Adobe header is always in "MM" / big endian
           curr_pos = start_pos + 6;
           while (curr_pos + 8 - start_pos <= len)
           {
             fread(mbuf, 1, 4, ifp);
             curr_pos += 8;
 
             if (!strncmp(mbuf, "Pano", 4))
             { // PanasonicRaw, yes, they use "Pano" as signature
               parseAdobePanoMakernote();
             }
 
             if (!strncmp(mbuf, "MakN", 4))
             {
               MakN_length = get4();
               MakN_order = get2();
               pos_in_original_raw = get4();
               order = MakN_order;
 
               INT64 save_pos = ifp->tell();
               parse_makernote_0xc634(curr_pos + 6 - pos_in_original_raw, 0,
                                      AdobeDNG);
 
               curr_pos = save_pos + MakN_length - 6;
               fseek(ifp, curr_pos, SEEK_SET);
 
               fread(mbuf, 1, 4, ifp);
               curr_pos += 8;
 
               if (!strncmp(mbuf, "Pano ", 4))
               {
                 parseAdobePanoMakernote();
               }
 
               if (!strncmp(mbuf, "RAF ", 4))
               { // Fujifilm Raw, AdobeRAF
                 parseAdobeRAFMakernote();
               }
 
               if (!strncmp(mbuf, "SR2 ", 4))
               {
                 order = 0x4d4d;
                 MakN_length = get4();
                 MakN_order = get2();
                 pos_in_original_raw = get4();
                 order = MakN_order;
 
                 unsigned *buf_SR2;
                 unsigned entries, tag, type, len, save;
                 unsigned SR2SubIFDOffset = 0;
                 unsigned SR2SubIFDLength = 0;
                 unsigned SR2SubIFDKey = 0;
                 int base = curr_pos + 6 - pos_in_original_raw;
                 entries = get2();
                 while (entries--)
                 {
                   tiff_get(base, &tag, &type, &len, &save);
 
                   if (tag == 0x7200)
                   {
                     SR2SubIFDOffset = get4();
                   }
                   else if (tag == 0x7201)
                   {
                     SR2SubIFDLength = get4();
                   }
                   else if (tag == 0x7221)
                   {
                     SR2SubIFDKey = get4();
                   }
                   fseek(ifp, save, SEEK_SET);
                 }
 
                 if (SR2SubIFDLength && (SR2SubIFDLength < 10240000) &&
                     (buf_SR2 = (unsigned *)malloc(SR2SubIFDLength + 1024)))
                 { // 1024b for safety
                   fseek(ifp, SR2SubIFDOffset + base, SEEK_SET);
                   fread(buf_SR2, SR2SubIFDLength, 1, ifp);
                   sony_decrypt(buf_SR2, SR2SubIFDLength / 4, 1, SR2SubIFDKey);
                   parseSonySR2((uchar *)buf_SR2, SR2SubIFDOffset,
                                SR2SubIFDLength, AdobeDNG);
 
                   free(buf_SR2);
                 }
 
               } /* SR2 processed */
               break;
             }
           }
         }
         else
         {
           fread(mbuf + 6, 1, 2, ifp);
           if (!strcmp(mbuf, "RICOH") && ((sget2((uchar *)mbuf + 6) == 0x4949) ||
                                          (sget2((uchar *)mbuf + 6) == 0x4d4d)))
           {
             is_PentaxRicohMakernotes = 1;
           }
           if (!strcmp(mbuf, "PENTAX ") || !strcmp(mbuf, "SAMSUNG") ||
               is_PentaxRicohMakernotes)
           {
             fseek(ifp, start_pos, SEEK_SET);
             parse_makernote_0xc634(base, 0, CameraDNG);
           }
         }
         fseek(ifp, start_pos, SEEK_SET);
         order = m_sorder;
       }
       if (dng_version)
       {
         break;
       }
       parse_minolta(j = get4() + base);
       fseek(ifp, j, SEEK_SET);
       parse_tiff_ifd(base);
       break;
     case 0xc640: // 50752
       read_shorts(cr2_slice, 3);
       break;
     case 0xc68b: /* 50827, OriginalRawFileName */
       stmread(imgdata.color.OriginalRawFileName, len, ifp);
       break;
     case 0xc68d: /* 50829 ActiveArea */
       tiff_ifd[ifd].t_tm = top_margin = getint(type);
       tiff_ifd[ifd].t_lm = left_margin = getint(type);
       tiff_ifd[ifd].t_vheight = height = getint(type) - top_margin;
       tiff_ifd[ifd].t_vwidth = width = getint(type) - left_margin;
       break;
     case 0xc68e: /* 50830 MaskedAreas */
       for (i = 0; i < (int)len && i < 32; i++)
         ((int *)mask)[i] = getint(type);
       black = 0;
       break;
     case 0xc71a: /* 50970, PreviewColorSpace */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_PREVIEWCS;
       tiff_ifd[ifd].dng_levels.preview_colorspace = getint(type);
       break;
     case 0xc741: /* 51009, OpcodeList2 */
       tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_OPCODE2;
       tiff_ifd[ifd].opcode2_offset = meta_offset = ftell(ifp);
       break;
     case 0xfd04: /* 64772, Kodak P-series */
       if (len < 13)
         break;
       fseek(ifp, 16, SEEK_CUR);
       data_offset = get4();
       fseek(ifp, 28, SEEK_CUR);
       data_offset += get4();
       load_raw = &LibRaw::packed_load_raw;
       break;
     case 0xfe02: // 65026
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII))
         fgets(model2, 64, ifp);
     }
     fseek(ifp, save, SEEK_SET);
   }
   if (sony_length && sony_length < 10240000 &&
       (buf = (unsigned *)malloc(sony_length)))
   {
     fseek(ifp, sony_offset, SEEK_SET);
     fread(buf, sony_length, 1, ifp);
     sony_decrypt(buf, sony_length / 4, 1, sony_key);
     parseSonySR2((uchar *)buf, sony_offset, sony_length, nonDNG);
     free(buf);
   }
   for (i = 0; i < colors && i < 4; i++)
     FORCC cc[i][c] *= ab[i];
   if (use_cm)
   {
     FORCC for (i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0; j < colors; j++)
         cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];
     cam_xyz_coeff(cmatrix, cam_xyz);
   }
   if (asn[0])
   {
     cam_mul[3] = 0;
     FORCC
     if (fabs(asn[c]) > 0.0001)
       cam_mul[c] = 1 / asn[c];
   }
   if (!use_cm)
     FORCC if (fabs(cc[c][c]) > 0.0001) pre_mul[c] /= cc[c][c];
   return 0;
 }
@@ -1517,548 +1568,551 @@ int ifd_size_t_cmp(const void *a, const void *b)
 void LibRaw::apply_tiff()
 {
   int max_samp = 0, ties = 0, raw = -1, thm = -1, i;
   unsigned long long ns, os;
   struct jhead jh;
 
   thumb_misc = 16;
   if (thumb_offset)
   {
     fseek(ifp, thumb_offset, SEEK_SET);
     if (ljpeg_start(&jh, 1))
     {
       if ((unsigned)jh.bits < 17 && (unsigned)jh.wide < 0x10000 &&
           (unsigned)jh.high < 0x10000)
       {
         thumb_misc = jh.bits;
         thumb_width = jh.wide;
         thumb_height = jh.high;
       }
     }
   }
   for (i = tiff_nifds; i--;)
   {
     if (tiff_ifd[i].t_shutter)
       shutter = tiff_ifd[i].t_shutter;
     tiff_ifd[i].t_shutter = shutter;
   }
 
   if (dng_version)
   {
     int ifdc = 0;
     for (i = 0; i < (int)tiff_nifds; i++)
     {
       if (tiff_ifd[i].t_width < 1 || tiff_ifd[i].t_width > 65535 ||
           tiff_ifd[i].t_height < 1 || tiff_ifd[i].t_height > 65535)
         continue; /* wrong image dimensions */
 
       int samp = tiff_ifd[i].samples;
       if (samp == 2)
         samp = 1; // Fuji 2-frame
       max_samp = LIM(MAX(max_samp, samp), 1,
                      3); // max_samp is needed for thumbnail selection below
 
       if (tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892)
         continue;
 
       if ((tiff_ifd[i].newsubfiletype == 0) // main image
                                             // Enhanced demosaiced:
           || (tiff_ifd[i].newsubfiletype == 16 &&
               (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED))
           // Preview: 0x1 or 0x10001
           || ((tiff_ifd[i].newsubfiletype & 0xffff) == 1 &&
               (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS)))
       {
         // Add this IFD to dng_frames
         libraw_internal_data.unpacker_data.dng_frames[ifdc] =
             ((tiff_ifd[i].newsubfiletype & 0xffff) << 16) | ((i << 8) & 0xff00);
         ifdc++;
         // Fuji SuperCCD: second frame:
         if ((tiff_ifd[i].newsubfiletype == 0) && tiff_ifd[i].samples == 2)
         {
           libraw_internal_data.unpacker_data.dng_frames[ifdc] =
               ((tiff_ifd[i].newsubfiletype & 0xffff) << 16) |
               ((i << 8) & 0xff00) | 1;
           ifdc++;
         }
       }
     }
     if (ifdc)
     {
       if (ifdc > 1 && (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE))
       {
         ifd_size_t arr[LIBRAW_IFD_MAXCOUNT * 2];
         memset(arr, 0, sizeof(arr));
         for (int i = 0; i < ifdc && i < LIBRAW_IFD_MAXCOUNT * 2; i++)
         {
           int ifdidx =
               (libraw_internal_data.unpacker_data.dng_frames[i] >> 8) & 0xff;
           arr[i].ifdi = libraw_internal_data.unpacker_data.dng_frames[i];
           arr[i].databits =
               tiff_ifd[ifdidx].t_width * tiff_ifd[ifdidx].t_height *
                   tiff_ifd[ifdidx].samples * tiff_ifd[ifdidx].bps +
               (0x100 -
                (arr[i].ifdi & 0xff)); // add inverted frame # to ensure same
                                       // sort order for similar sized frames.
         }
         qsort(arr, MIN(ifdc, LIBRAW_IFD_MAXCOUNT * 2), sizeof(arr[0]),
               ifd_size_t_cmp);
         for (int i = 0; i < ifdc && i < LIBRAW_IFD_MAXCOUNT * 2; i++)
           libraw_internal_data.unpacker_data.dng_frames[i] = arr[i].ifdi;
       }
 
       int idx = LIM((int)shot_select, 0, ifdc - 1);
       i = (libraw_internal_data.unpacker_data.dng_frames[idx] >> 8) &
           0xff; // extract frame# back
 
       raw_width = tiff_ifd[i].t_width;
       raw_height = tiff_ifd[i].t_height;
       tiff_bps = tiff_ifd[i].bps;
       tiff_compress = tiff_ifd[i].comp;
       tiff_sampleformat = tiff_ifd[i].sample_format;
       data_offset = tiff_ifd[i].offset;
       data_size = tiff_ifd[i].bytes;
       tiff_flip = tiff_ifd[i].t_flip;
       tiff_samples = tiff_ifd[i].samples;
       tile_width = tiff_ifd[i].t_tile_width;
       tile_length = tiff_ifd[i].t_tile_length;
       fuji_width = tiff_ifd[i].t_fuji_width;
       if (tiff_samples != 2) /* special case: Fuji SuperCCD */
       {
         if (tiff_ifd[i].phint == 34892)
           filters = 0;
         else if (i > 0 && tiff_ifd[i].phint == 32803 &&
                  tiff_ifd[0].phint == 32803 && !tiff_ifd[i].t_filters &&
                  tiff_ifd[0].t_filters)
           filters = tiff_ifd[0].t_filters;
         else
           filters = tiff_ifd[i].t_filters;
         width = tiff_ifd[i].t_vwidth;
         height = tiff_ifd[i].t_vheight;
         top_margin = tiff_ifd[i].t_tm;
         left_margin = tiff_ifd[i].t_lm;
         shutter = tiff_ifd[i].t_shutter;
         if (tiff_ifd[i].dng_levels.dng_whitelevel[0])
           maximum = tiff_ifd[i].dng_levels.dng_whitelevel[0];
         else if (tiff_ifd[i].sample_format <= 2 && tiff_bps > 0 &&
                  tiff_bps < 32) // SampleFormat: 0-default(1), 1 - Uint, 2 - Int
           maximum = (1 << tiff_bps) - 1;
         else if (tiff_ifd[i].sample_format == 3)
           maximum = 1; // Defaults for FP
       }
       raw = i;
       is_raw = ifdc;
     }
     else
       is_raw = 0;
   }
   else
   {
     // Fix for broken Sony bps tag
     if (!strncasecmp(make, "Sony", 4))
     {
         for (i = 0; i < (int)tiff_nifds; i++)
         {
             if (tiff_ifd[i].bps > 33 && tiff_ifd[i].samples == 1)
             {
                 int bps = 14; // default
                 if (tiff_ifd[i].dng_levels.dng_whitelevel[0] > 0)
                 {
                     for(int c = 0,j=1; c < 16; c++, j<<=1)
-                        if (j > tiff_ifd[i].dng_levels.dng_whitelevel[0])
+                        if (j > (int)tiff_ifd[i].dng_levels.dng_whitelevel[0])
                         {
                             bps = c; break;
                         }
                 }
                 tiff_ifd[i].bps = bps;
             }
         }
     }
 
     for (i = 0; i < (int)tiff_nifds; i++)
     {
       if (tiff_ifd[i].t_width < 1 || tiff_ifd[i].t_width > 65535 ||
           tiff_ifd[i].t_height < 1 || tiff_ifd[i].t_height > 65535)
         continue; /* wrong image dimensions */
       if (max_samp < tiff_ifd[i].samples)
         max_samp = tiff_ifd[i].samples;
       if (max_samp > 3)
         max_samp = 3;
 
       os = unsigned(raw_width) * unsigned(raw_height);
       ns = unsigned(tiff_ifd[i].t_width) * unsigned(tiff_ifd[i].t_height);
       if (tiff_bps)
       {
         os *= tiff_bps;
         ns *= tiff_ifd[i].bps;
       }
       /* too complex if below, so separate if to skip RGB+Alpha TIFFs*/
       if (tiff_ifd[i].phint == 2 && tiff_ifd[i].extrasamples > 0 && tiff_ifd[i].samples > 3)
           continue; // SKIP RGB+Alpha IFDs
 
       if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&
             unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&
             (unsigned)tiff_ifd[i].bps < 33 &&
             (unsigned)tiff_ifd[i].samples < 13 && ns &&
             ((ns > os && (ties = 1)) || (ns == os && (int)shot_select == ties++)))
       {
         raw_width = tiff_ifd[i].t_width;
         raw_height = tiff_ifd[i].t_height;
         tiff_bps = tiff_ifd[i].bps;
         tiff_compress = tiff_ifd[i].comp;
         tiff_sampleformat = tiff_ifd[i].sample_format;
         data_offset = tiff_ifd[i].offset;
         data_size = tiff_ifd[i].bytes;
         tiff_flip = tiff_ifd[i].t_flip;
         tiff_samples = tiff_ifd[i].samples;
         tile_width = tiff_ifd[i].t_tile_width;
         tile_length = tiff_ifd[i].t_tile_length;
         shutter = tiff_ifd[i].t_shutter;
         raw = i;
       }
     }
     if (is_raw == 1 && ties)
       is_raw = ties;
   }
   if (is_NikonTransfer && raw >= 0)
   {
     if (tiff_ifd[raw].bps == 16)
     {
       if (tiff_compress == 1)
       {
         if ((raw_width * raw_height * 3) == (tiff_ifd[raw].bytes << 1))
         {
           tiff_bps = tiff_ifd[raw].bps = 12;
         }
         else
         {
           tiff_bps = tiff_ifd[raw].bps = 14;
         }
       }
     }
     else if (tiff_ifd[raw].bps == 8)
     {
       if (tiff_compress == 1)
       {
         is_NikonTransfer = 2; // 8-bit debayered TIFF, like CoolScan NEFs
         imgdata.rawparams.coolscan_nef_gamma = 2.2f;
       }
     }
   }
 
   if (!tile_width)
     tile_width = INT_MAX;
   if (!tile_length)
     tile_length = INT_MAX;
   for (i = tiff_nifds; i--;)
     if (tiff_ifd[i].t_flip)
       tiff_flip = tiff_ifd[i].t_flip;
 
 #if 0
   if (raw < 0 && is_raw)
       is_raw = 0;
 #endif
 
   if (raw >= 0 && !load_raw)
     switch (tiff_compress)
     {
     case 32767:
       if (!dng_version &&
           INT64(tiff_ifd[raw].bytes) == INT64(raw_width) * INT64(raw_height))
       {
         tiff_bps = 14;
         load_raw = &LibRaw::sony_arw2_load_raw;
         break;
       }
       if (!dng_version && !strncasecmp(make, "Sony", 4) &&
           INT64(tiff_ifd[raw].bytes) ==
               INT64(raw_width) * INT64(raw_height) * 2LL)
       {
         tiff_bps = 14;
         load_raw = &LibRaw::unpacked_load_raw;
         break;
       }
       if (INT64(tiff_ifd[raw].bytes) * 8ULL !=
           INT64(raw_width) * INT64(raw_height) * INT64(tiff_bps))
       {
         raw_height += 8;
         load_raw = &LibRaw::sony_arw_load_raw;
         break;
       }
       load_flags = 79;
     case 32769:
       load_flags++;
     case 32770:
     case 32773:
       goto slr;
     case 0:
     case 1:
         if (dng_version && tiff_sampleformat == 3 &&
           (tiff_bps > 8 && (tiff_bps % 8 == 0) && (tiff_bps <= 32))) // only 16,24, and 32 are allowed
         {
             load_raw = &LibRaw::uncompressed_fp_dng_load_raw;
             break;
         }
       // Sony 14-bit uncompressed
       if (!dng_version && !strncasecmp(make, "Sony", 4) &&
           INT64(tiff_ifd[raw].bytes) ==
               INT64(raw_width) * INT64(raw_height) * 2LL)
       {
         tiff_bps = 14;
         load_raw = &LibRaw::unpacked_load_raw;
         break;
       }
       if (!dng_version && !strncasecmp(make, "Sony", 4) &&
           tiff_ifd[raw].samples == 4 &&
           INT64(tiff_ifd[raw].bytes) ==
               INT64(raw_width) * INT64(raw_height) * 8LL) // Sony ARQ
       {
         // maybe to detect ARQ with the following:
         // if (tiff_ifd[raw].phint == 32892)
         tiff_bps = 14;
         tiff_samples = 4;
         load_raw = &LibRaw::sony_arq_load_raw;
         filters = 0;
         strcpy(cdesc, "RGBG");
         break;
       }
       if (!strncasecmp(make, "Nikon", 5) &&
           (!strncmp(software, "Nikon Scan", 10) || (is_NikonTransfer == 2) ||
            strcasestr(model, "COOLSCAN")))
       {
         load_raw = &LibRaw::nikon_coolscan_load_raw;
         raw_color = 1;
         filters = 0;
         break;
       }
       if ((!strncmp(make, "OLYMPUS", 7) ||
            (!strncasecmp(make, "CLAUSS", 6) &&
             !strncasecmp(model, "piX 5oo", 7))) && // 0x5330303539 works here
           (INT64(tiff_ifd[raw].bytes) * 2ULL ==
            INT64(raw_width) * INT64(raw_height) * 3ULL))
         load_flags = 24;
       if (!dng_version && INT64(tiff_ifd[raw].bytes) * 5ULL ==
                               INT64(raw_width) * INT64(raw_height) * 8ULL)
       {
         load_flags = 81;
         tiff_bps = 12;
       }
     slr:
       switch (tiff_bps)
       {
       case 8:
         load_raw = &LibRaw::eight_bit_load_raw;
         break;
       case 12:
         if (tiff_ifd[raw].phint == 2)
           load_flags = 6;
         if (!strncasecmp(make, "NIKON", 5) &&
             !strncasecmp(model, "COOLPIX A1000", 13) &&
             data_size == raw_width * raw_height * 2)
           load_raw = &LibRaw::unpacked_load_raw;
         else
           load_raw = &LibRaw::packed_load_raw;
         break;
       case 14:
         load_flags = 0;
       case 16:
         load_raw = &LibRaw::unpacked_load_raw;
         if ((!strncmp(make, "OLYMPUS", 7) ||
              (!strncasecmp(make, "CLAUSS", 6) &&
               !strncasecmp(model, "piX 5oo", 7))) && // 0x5330303539 works here
             (INT64(tiff_ifd[raw].bytes) * 7ULL >
              INT64(raw_width) * INT64(raw_height)))
           load_raw = &LibRaw::olympus_load_raw;
       }
       break;
     case 6:
     case 7:
     case 99:
-      load_raw = &LibRaw::lossless_jpeg_load_raw;
+      if (!dng_version && tiff_compress == 6 && !strcasecmp(make, "SONY"))
+        load_raw = &LibRaw::sony_ljpeg_load_raw;
+      else
+        load_raw = &LibRaw::lossless_jpeg_load_raw;
       break;
     case 262:
       load_raw = &LibRaw::kodak_262_load_raw;
       break;
     case 34713:
       if ((INT64(raw_width) + 9LL) / 10LL * 16LL * INT64(raw_height) ==
           INT64(tiff_ifd[raw].bytes))
       {
         load_raw = &LibRaw::packed_load_raw;
         load_flags = 1;
       }
       else if (INT64(raw_width) * INT64(raw_height) * 3LL ==
                INT64(tiff_ifd[raw].bytes) * 2LL)
       {
         load_raw = &LibRaw::packed_load_raw;
         if (model[0] == 'N')
           load_flags = 80;
       }
       else if (INT64(raw_width) * INT64(raw_height) * 3LL ==
                INT64(tiff_ifd[raw].bytes))
       {
         load_raw = &LibRaw::nikon_yuv_load_raw;
         gamma_curve(1 / 2.4, 12.92, 1, 4095);
         memset(cblack, 0, sizeof cblack);
         filters = 0;
       }
       else if (INT64(raw_width) * INT64(raw_height) * 2LL ==
                INT64(tiff_ifd[raw].bytes))
       {
         load_raw = &LibRaw::unpacked_load_raw;
         load_flags = 4;
         order = 0x4d4d;
       }
       else if (INT64(raw_width) * INT64(raw_height) * 3LL ==
                INT64(tiff_ifd[raw].bytes) * 2LL)
       {
         load_raw = &LibRaw::packed_load_raw;
         load_flags = 80;
       }
       else if (tiff_ifd[raw].rows_per_strip &&
                tiff_ifd[raw].strip_offsets_count &&
                tiff_ifd[raw].strip_offsets_count ==
                    tiff_ifd[raw].strip_byte_counts_count)
       {
         int fit = 1;
         for (int i = 0; i < tiff_ifd[raw].strip_byte_counts_count - 1;
              i++) // all but last
           if (INT64(tiff_ifd[raw].strip_byte_counts[i]) * 2LL !=
               INT64(tiff_ifd[raw].rows_per_strip) * INT64(raw_width) * 3LL)
           {
             fit = 0;
             break;
           }
         if (fit)
           load_raw = &LibRaw::nikon_load_striped_packed_raw;
         else
           load_raw = &LibRaw::nikon_load_raw; // fallback
       }
       else if ((((INT64(raw_width) * 3LL / 2LL) + 15LL) / 16LL) * 16LL *
                    INT64(raw_height) ==
                INT64(tiff_ifd[raw].bytes))
       {
         load_raw = &LibRaw::nikon_load_padded_packed_raw;
         load_flags = (((INT64(raw_width) * 3ULL / 2ULL) + 15ULL) / 16ULL) *
                      16ULL; // bytes per row
       }
       else
         load_raw = &LibRaw::nikon_load_raw;
       break;
     case 65535:
       load_raw = &LibRaw::pentax_load_raw;
       break;
     case 65000:
       switch (tiff_ifd[raw].phint)
       {
       case 2:
         load_raw = &LibRaw::kodak_rgb_load_raw;
         filters = 0;
         break;
       case 6:
         load_raw = &LibRaw::kodak_ycbcr_load_raw;
         filters = 0;
         break;
       case 32803:
         load_raw = &LibRaw::kodak_65000_load_raw;
       }
     case 32867:
     case 34892:
       break;
     case 8:
       break;
 #ifdef USE_GPRSDK
     case 9:
       if (dng_version)
         break; /* Compression=9 supported for dng if we compiled with GPR SDK */
                /* Else: fallthrough */
 #endif
     default:
       is_raw = 0;
     }
   if (!dng_version)
   {
       if (((tiff_samples == 3 && tiff_ifd[raw].bytes &&
           !(tiff_bps == 16 &&
               !strncmp(make, "Leaf", 4)) && // Allow Leaf/16bit/3color files
           tiff_bps != 14 &&
           (tiff_compress & -16) != 32768) ||
           (tiff_bps == 8 && strncmp(make, "Phase", 5) &&
               strncmp(make, "Leaf", 4) && !strcasestr(make, "Kodak") &&
               !strstr(model2, "DEBUG RAW"))) &&
           !strcasestr(model, "COOLSCAN") && strncmp(software, "Nikon Scan", 10) &&
           is_NikonTransfer != 2)
           is_raw = 0;
 
       if (is_raw && raw >= 0 && tiff_ifd[raw].phint == 2 && tiff_ifd[raw].extrasamples > 0 && tiff_ifd[raw].samples > 3)
           is_raw = 0; // SKIP RGB+Alpha IFDs
   }
 
   INT64 fsizecheck = 0ULL;
 
   if (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS)
       fsizecheck = ifp->size();
   else if ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS)
       && !strncasecmp(make,"Ricoh",5))
       fsizecheck = ifp->size();
 
   for (i = 0; i < (int)tiff_nifds; i++)
     if (i != raw &&
         (tiff_ifd[i].samples == max_samp ||
          (tiff_ifd[i].comp == 7 &&
           tiff_ifd[i].samples == 1)) /* Allow 1-bps JPEGs */
         && tiff_ifd[i].bps > 0 && tiff_ifd[i].bps < 33 &&
         tiff_ifd[i].phint != 32803 && tiff_ifd[i].phint != 34892 &&
         unsigned(tiff_ifd[i].t_width | tiff_ifd[i].t_height) < 0x10000 &&
         unsigned(tiff_ifd[i].t_width * tiff_ifd[i].t_height /
                 (SQR(tiff_ifd[i].bps) + 1)) >
             unsigned(thumb_width * thumb_height / (SQR(thumb_misc) + 1)) &&
         tiff_ifd[i].comp != 34892)
     {
-        if (fsizecheck > 0ULL)
+        if (fsizecheck > 0LL)
         {
             bool ok = true;
             if (tiff_ifd[i].strip_byte_counts_count && tiff_ifd[i].strip_offsets_count)
                 for (int s = 0; s < MIN(tiff_ifd[i].strip_byte_counts_count, tiff_ifd[i].strip_offsets_count); s++)
                 {
                     if (tiff_ifd[i].strip_offsets[s] + tiff_ifd[i].strip_byte_counts[s] > fsizecheck)
                     {
                         ok = false;
                         break;
                     }
                 }
             else if (tiff_ifd[i].bytes > 0)
                 if (tiff_ifd[i].offset + tiff_ifd[i].bytes > fsizecheck)
                     ok = false;
 
             if(!ok)
                 continue;
         }
 
       thumb_width = tiff_ifd[i].t_width;
       thumb_height = tiff_ifd[i].t_height;
       thumb_offset = tiff_ifd[i].offset;
       thumb_length = tiff_ifd[i].bytes;
       thumb_misc = tiff_ifd[i].bps;
       thm = i;
     }
   if (thm >= 0)
   {
     thumb_misc |= tiff_ifd[thm].samples << 5;
     switch (tiff_ifd[thm].comp)
     {
     case 0:
       write_thumb = &LibRaw::layer_thumb;
       break;
     case 1:
       if (tiff_ifd[thm].bps <= 8)
         write_thumb = &LibRaw::ppm_thumb;
       else if (!strncmp(make, "Imacon", 6))
         write_thumb = &LibRaw::ppm16_thumb;
       else
         thumb_load_raw = &LibRaw::kodak_thumb_load_raw;
       break;
     case 65000:
       thumb_load_raw = tiff_ifd[thm].phint == 6 ? &LibRaw::kodak_ycbcr_load_raw
                                                 : &LibRaw::kodak_rgb_load_raw;
     }
   }
 }
diff --git a/src/tables/cameralist.cpp b/src/tables/cameralist.cpp
index 5de8a4bc..cc25b527 100644
--- a/src/tables/cameralist.cpp
+++ b/src/tables/cameralist.cpp
@@ -20,1209 +20,1234 @@ const int RAWSPEED_DATA_COUNT =
     (sizeof(_rawspeed_data_xml) / sizeof(_rawspeed_data_xml[0]));
 #endif
 // clang-format off
 // Supported cameras:
 static const char *static_camera_list[] = {
 	"Adobe Digital Negative (DNG)",
 	"AgfaPhoto DC-833m",
 	"Alcatel 5035D",
 	"Apple iPad Pro",
 	"Apple iPhone SE",
 	"Apple iPhone 6s",
 	"Apple iPhone 6 plus",
 	"Apple iPhone 7",
 	"Apple iPhone 7 plus",
 	"Apple iPhone 8",
 	"Apple iPhone 8 plus",
 	"Apple iPhone X",
-	"Apple iPhone 12 Max",
-	"Apple iPhone 12 Max Pro",
+	"Apple iPhone 12 Pro",
+	"Apple iPhone 12 Pro Max",
+	"Apple iPhone 13 Pro",
 	"Apple QuickTake 100",
 	"Apple QuickTake 150",
 	"Apple QuickTake 200",
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 	"ARRI ALEXA",
 	"ARRI ALEXA65",
 	"ARRI ALEXA LF",
 	"ARRI ALEXA XT",
 	"ARRI ALEXA SXT",
 #endif
 	"ASUS ZenPhone4",
 	"ASUS ZenPhone6",
 	"AutelRobotics XB015",
 	"AutelRobotics XT705 (EVO II)",
 	"AVT F-080C",
 	"AVT F-145C",
 	"AVT F-201C",
 	"AVT F-510C",
 	"AVT F-810C",
 	"Baumer TXG14",
 	"BlackMagic Cinema Camera",
 	"BlackMagic Micro Cinema Camera",
 	"BlackMagic Pocket Cinema Camera",
 	"BlackMagic Production Camera 4k",
 	"BlackMagic URSA",
 	"BlackMagic URSA Mini 4k",
 	"BlackMagic URSA Mini 4.6k",
 	"BlackMagic URSA Mini Pro 4.6k",
 	"BQ Aquarius U",
 	"Canon PowerShot 600",
 	"Canon PowerShot A5",
 	"Canon PowerShot A5 Zoom",
 	"Canon PowerShot A50",
 	"Canon PowerShot A410 (CHDK hack)",
 	"Canon PowerShot A460 (CHDK hack)",
 	"Canon PowerShot A470 (CHDK hack)",
 	"Canon PowerShot A480 (CHDK hack)",
 	"Canon PowerShot A530 (CHDK hack)",
 	"Canon PowerShot A540 (CHDK hack)",
 	"Canon PowerShot A550 (CHDK hack)",
 	"Canon PowerShot A560 (CHDK hack)",
 	"Canon PowerShot A570 IS (CHDK hack)",
 	"Canon PowerShot A590 IS (CHDK hack)",
 	"Canon PowerShot A610 (CHDK hack)",
 	"Canon PowerShot A620 (CHDK hack)",
 	"Canon PowerShot A630 (CHDK hack)",
 	"Canon PowerShot A640 (CHDK hack)",
 	"Canon PowerShot A650 IS (CHDK hack)",
 	"Canon PowerShot A710 IS (CHDK hack)",
 	"Canon PowerShot A720 IS (CHDK hack)",
 	"Canon PowerShot A3300 IS (CHDK hack)",
 	"Canon PowerShot D10 (CHDK hack)",
 	"Canon PowerShot ELPH 130 IS / IXUS 140 / IXY 110F (CHDK hack)",
 	"Canon PowerShot ELPH 160 / IXUS 160 (CHDK hack)",
 	"Canon PowerShot Pro70",
 	"Canon PowerShot Pro90 IS",
 	"Canon PowerShot Pro1",
 	"Canon PowerShot G1",
 	"Canon PowerShot G1 X",
 	"Canon PowerShot G1 X Mark II",
 	"Canon PowerShot G1 X Mark III",
 	"Canon PowerShot G2",
 	"Canon PowerShot G3",
 	"Canon PowerShot G3 X",
 	"Canon PowerShot G5",
 	"Canon PowerShot G5 X",
 	"Canon PowerShot G5 X Mark II",
 	"Canon PowerShot G6",
 	"Canon PowerShot G7 (CHDK hack)",
 	"Canon PowerShot G7 X",
 	"Canon PowerShot G7 X Mark II",
 	"Canon PowerShot G7 X Mark III",
 	"Canon PowerShot G9",
 	"Canon PowerShot G9 X",
 	"Canon PowerShot G9 X Mark II",
 	"Canon PowerShot G10",
 	"Canon PowerShot G11",
 	"Canon PowerShot G12",
 	"Canon PowerShot G15",
 	"Canon PowerShot G16",
 	"Canon PowerShot S2 IS (CHDK hack)",
 	"Canon PowerShot S3 IS (CHDK hack)",
 	"Canon PowerShot S5 IS (CHDK hack)",
 	"Canon PowerShot SD300 / IXUS 40 / IXY Digital 50 (CHDK hack)",
 	"Canon PowerShot SD750 / IXUS 75 / IXY Digital 90 (CHDK hack)",
 	"Canon PowerShot SD900 / Digital IXUS 900 Ti / IXY Digital 1000 (CHDK hack)",
 	"Canon PowerShot SD950 IS / Digital IXUS 960 IS / IXY Digital 2000 IS (CHDK hack)",
 	"Canon PowerShot SD1200 IS / Digital IXUS 95 IS / IXY Digital 110 IS (CHDK hack)",
 	"Canon PowerShot S30",
 	"Canon PowerShot S40",
 	"Canon PowerShot S45",
 	"Canon PowerShot S50",
 	"Canon PowerShot S60",
 	"Canon PowerShot S70",
 	"Canon PowerShot S90",
 	"Canon PowerShot S95",
 	"Canon PowerShot S100",
 	"Canon PowerShot S110",
 	"Canon PowerShot S120",
 	"Canon PowerShot SX1 IS",
 	"Canon PowerShot SX40 HS (CHDK hack, CR2)",
 	"Canon PowerShot SX50 HS",
 	"Canon PowerShot SX60 HS",
 	"Canon PowerShot SX70 HS",
 	"Canon PowerShot SX100 IS (CHDK hack)",
 	"Canon PowerShot SX110 IS (CHDK hack)",
 	"Canon PowerShot SX120 IS (CHDK hack)",
 	"Canon PowerShot SX130 IS (CHDK hack)",
 	"Canon PowerShot SX160 IS (CHDK hack)",
 	"Canon PowerShot SX220 HS (CHDK hack)",
 	"Canon PowerShot SX510 HS (CHDK hack)",
 	"Canon PowerShot SX710 HS (CHDK hack)",
 	"Canon PowerShot SX10 IS (CHDK hack)",
 	"Canon PowerShot SX20 IS (CHDK hack)",
 	"Canon PowerShot SX30 IS (CHDK hack)",
 	"Canon EOS R",
 	"Canon EOS RP",
 	"Canon EOS R5",
 	"Canon EOS R6",
 	"Canon EOS D30",
 	"Canon EOS D60",
 	"Canon EOS 5DS",
 	"Canon EOS 5DS R",
 	"Canon EOS 5D",
 	"Canon EOS 5D Mark II",
 	"Canon EOS 5D Mark III",
 	"Canon EOS 5D Mark IV",
 	"Canon EOS 6D",
 	"Canon EOS 6D Mark II",
 	"Canon EOS 7D",
 	"Canon EOS 7D Mark II",
 	"Canon EOS 10D",
 	"Canon EOS 20D",
 	"Canon EOS 20Da",
 	"Canon EOS 30D",
 	"Canon EOS 40D",
 	"Canon EOS 50D",
 	"Canon EOS 60D",
 	"Canon EOS 60Da",
 	"Canon EOS 70D",
 	"Canon EOS 77D / 9000D",
 	"Canon EOS 80D",
 	"Canon EOS 90D",
 	"Canon EOS 100D / Rebel SL1 / Kiss X7",
 	"Canon EOS 200D / Rebel SL2 / Kiss X9",
 	"Canon EOS 250D / 200D II / Rebel SL3 / Kiss X10",
 	"Canon EOS 300D / Digital Rebel / Kiss Digital",
 	"Canon EOS 350D / Digital Rebel XT / Kiss Digital N",
 	"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X",
 	"Canon EOS 450D / Digital Rebel XSi / Kiss X2",
 	"Canon EOS 500D / Rebel T1i / Kiss X3",
 	"Canon EOS 550D / Rebel T2i / Kiss X4",
 	"Canon EOS 600D / Rebel T3i / Kiss X5",
 	"Canon EOS 650D / Rebel T4i / Kiss X6i",
 	"Canon EOS 700D / Rebel T5i / Kiss X7i",
 	"Canon EOS 750D / Rebel T6i / Kiss X8i",
 	"Canon EOS 760D / Rebel T6S / 8000D",
 	"Canon EOS 800D / Rebel T7i / Kiss X9i",
 	"Canon EOS 850D / Rebel T8i / Kiss X10i",
 	"Canon EOS 1000D / Digital Rebel XS / Kiss F",
 	"Canon EOS 1100D / Rebel T3 / Kiss X50",
 	"Canon EOS 1200D / Kiss X70 / REBEL T5 / Hi",
 	"Canon EOS 1300D / Rebel T6 / Kiss X80",
 	"Canon EOS 1500D / 2000D / Rebel T7 / Kiss X90",
 	"Canon EOS 3000D / 4000D / Rebel T100",
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 	"Canon EOS C500",
 #endif
 	"Canon EOS D2000",
 	"Canon EOS M",
 	"Canon EOS M2",
 	"Canon EOS M3",
 	"Canon EOS M5",
 	"Canon EOS M6",
 	"Canon EOS M6 Mark II",
 	"Canon EOS M10",
 	"Canon EOS M50 / Kiss M",
+	"Canon EOS M50 Mark II",
 	"Canon EOS M100",
 	"Canon EOS M200",
 	"Canon EOS-1D C",
 	"Canon EOS-1D X",
 	"Canon EOS-1D X Mark II",
 	"Canon EOS-1D X Mark III",
 	"Canon EOS-1D",
 	"Canon EOS-1D Mark II",
 	"Canon EOS-1D Mark II N",
 	"Canon EOS-1D Mark III",
 	"Canon EOS-1D Mark IV",
 	"Canon EOS-1Ds",
 	"Canon EOS-1Ds Mark II",
 	"Canon EOS-1Ds Mark III",
 	"Casio QV-2000UX (secret menu hack)",
 	"Casio QV-3000EX (secret menu hack)",
 	"Casio QV-3500EX (secret menu hack)",
 	"Casio QV-4000 (secret menu hack)",
 	"Casio QV-5700 (secret menu hack)",
 	"Casio QV-R41",
 	"Casio QV-R51",
 	"Casio QV-R61",
 	"Casio EX-F1",
 	"Casio EX-FC300S",
 	"Casio EX-FC400S",
 	"Casio EX-FH20",
 	"Casio EX-FH25",
 	"Casio EX-FH100",
 	"Casio EX-S20 / M20",
 	"Casio EX-S100",
 	"Casio EX-Z4",
 	"Casio EX-Z50",
 	"Casio EX-Z500",
 	"Casio EX-Z55",
 	"Casio EX-Z60",
 	"Casio EX-Z75",
 	"Casio EX-Z750",
 	"Casio EX-Z8",
 	"Casio EX-Z850",
 	"Casio EX-Z1050",
 	"Casio EX-ZR100",
 	"Casio EX-Z1080",
 	"Casio EX-ZR700",
 	"Casio EX-ZR710",
 	"Casio EX-ZR750",
 	"Casio EX-ZR800",
 	"Casio EX-ZR850",
 	"Casio EX-ZR1000",
 	"Casio EX-ZR1100",
 	"Casio EX-ZR1200",
 	"Casio EX-ZR1300",
 	"Casio EX-ZR1500",
 	"Casio EX-ZR3000",
 	"Casio EX-ZR3100",
 	"Casio EX-ZR3200",
 	"Casio EX-ZR3500",
 	"Casio EX-ZR3600",
 	"Casio EX-ZR3700",
 	"Casio EX-ZR4000 / 5000",
 	"Casio EX-ZR4100 / 5100",
 	"Casio EX-100",
 	"Casio EX-100F",
 	"Casio EX-100PRO",
 	"Casio EX-10",
 	"Casio EX-P505 (secret menu hack)",
 	"Casio EX-P600 (secret menu hack)",
 	"Casio EX-P700 (secret menu hack)",
 	"CLAUSS pix500",
 	"Contax N Digital",
 	"Creative PC-CAM 600",
 	"Digital Bolex D16",
 	"Digital Bolex D16M",
 	"DJI 4384x3288",
 	"DJI Mavic Air",
 	"DJI Mavic Air2",
+	"DJI Mavic Air 2S",
 	"DJI Mavic Mini2",
 	"DJI Osmo Action",
 	"DJI Pocket",
 	"DJI Phantom4 Pro/Pro+",
 	"DJI Zenmuse X5",
 	"DJI Zenmuse X5R",
 	"DXO One",
 	"Epson R-D1",
 	"Epson R-D1s",
 	"Epson R-D1x",
 	"Eyedeas E1",
 	"Foculus 531C",
 	"FujiFilm DBP for GX680 / DX-2000",
 	"FujiFilm E550",
 	"FujiFilm E900",
 	"FujiFilm F500EXR / F505EXR",
 	"FujiFilm F550EXR",
 	"FujiFilm F600EXR / F605EXR",
 	"FujiFilm F700",
 	"FujiFilm F710",
 	"FujiFilm F770EXR / F775EXR",
 	"FujiFilm F800EXR",
 	"FujiFilm F810",
 	"FujiFilm F900EXR",
 	"FujiFilm S2Pro",
 	"FujiFilm S3Pro",
 	"FujiFilm S5Pro",
 	"FujiFilm S20Pro",
 	"FujiFilm S1",
 	"FujiFilm S100FS",
 	"FujiFilm S5000",
 	"FujiFilm S5100 / S5500",
 	"FujiFilm S5200 / S5600",
 	"FujiFilm S6000fd / S6500fd",
 	"FujiFilm S7000",
 	"FujiFilm S9000 / S9500",
 	"FujiFilm S9100 / S9600",
 	"FujiFilm S200EXR / S205EXR",
 	"FujiFilm SL1000",
 	"FujiFilm HS10/HS11",
 	"FujiFilm HS20EXR / HS22EXR",
 	"FujiFilm HS30EXR / HS33EXR / HS35EXR",
 	"FujiFilm HS50EXR",
 	"FujiFilm GFX 50S",
+	"FujiFilm GFX 50S II",
 	"FujiFilm GFX 50R",
 	"FujiFilm GFX 100",
+	"FujiFilm GFX 100S",
 	"FujiFilm X-Pro1",
 	"FujiFilm X-Pro2",
 	"FujiFilm X-Pro3",
 	"FujiFilm X-S1",
 	"FujiFilm XQ1",
 	"FujiFilm XQ2",
 	"FujiFilm X100",
 	"FujiFilm X100F",
 	"FujiFilm X100S",
 	"FujiFilm X100T",
 	"FujiFilm X100V",
 	"FujiFilm X10",
 	"FujiFilm X20",
 	"FujiFilm X30",
 	"FujiFilm X70",
 	"FujiFilm X-A1",
 	"FujiFilm X-A2",
 	"FujiFilm X-A3",
 	"FujiFilm X-A5",
 	"FujiFilm X-A7",
 	"FujiFilm X-A10",
 	"FujiFilm X-A20",
 	"FujiFilm X-E1",
 	"FujiFilm X-E2",
 	"FujiFilm X-E2S",
 	"FujiFilm X-E3",
+	"FujiFilm X-E4",
 	"FujiFilm X-M1",
 	"FujiFilm XF1",
 	"FujiFilm XF10",
 	"FujiFilm X-H1",
 	"FujiFilm X-T1",
 	"FujiFilm X-S10",
 	"FujiFilm X-T1 Graphite Silver",
 	"FujiFilm X-T2",
 	"FujiFilm X-T3",
-	"FujiFilm X-T4 (uncompressed and lossless compressed only)",
+	"FujiFilm X-T4",
 	"FujiFilm X-T10",
 	"FujiFilm X-T20",
 	"FujiFilm X-T30",
 	"FujiFilm X-T100",
 	"FujiFilm X-T200",
 	"FujiFilm IS-1",
 	"Gione E7",
 	"GITUP GIT2",
 	"GITUP GIT2P",
 	"GITUP G3 DUO (16:9 mode only)",
 	"Google Pixel",
 	"Google Pixel XL",
 	"Google Pixel 3a",
 	"Google Pixel 4 XL",
 	"Google Pixel 4a (5G)",
 	"Google Pixel 5",
 #ifdef  USE_GPRSDK
 	"GoPro Fusion",
 	"GoPro HERO5",
 	"GoPro HERO6",
 	"GoPro HERO7",
 	"GoPro HERO8",
+	"GoPro HERO9",
+	"GoPro HERO10",
 #endif
 	"Hasselblad H2D-22",
 	"Hasselblad H2D-39",
 	"Hasselblad H3DII-22",
 	"Hasselblad H3DII-31",
 	"Hasselblad H3DII-39",
 	"Hasselblad H3DII-50",
 	"Hasselblad H3D-22",
 	"Hasselblad H3D-31",
 	"Hasselblad H3D-39",
 	"Hasselblad H4D-60",
 	"Hasselblad H4D-50",
 	"Hasselblad H4D-40",
 	"Hasselblad H4D-31",
 	"Hasselblad H5D-60",
 	"Hasselblad H5D-50",
 	"Hasselblad H5D-50c",
 	"Hasselblad H5D-40",
 	"Hasselblad H6D-100c",
 	"Hasselblad A6D-100c", // Aerial camera
 	"Hasselblad CFV",
 	"Hasselblad CFV-50",
 	"Hasselblad CFV II 50C",
 	"Hasselblad CFH",
 	"Hasselblad CF-22",
 	"Hasselblad CF-31",
 	"Hasselblad CF-39",
 	"Hasselblad V96C",
 	"Hasselblad L1D-20c (DJI Mavic 2 Pro)",
 	"Hasselblad Lusso",
 	"Hasselblad Lunar",
 	"Hasselblad True Zoom",
 	"Hasselblad Stellar",
 	"Hasselblad Stellar II",
 	"Hasselblad HV",
 	"Hasselblad X1D",
 	"Hasselblad X1D II 50C",
 	"HTC UltraPixel",
 	"HTC MyTouch 4G",
 	"HTC One (A9)",
 	"HTC One (M9)",
 	"HTC 10",
 	"HTC U12",
 	"Huawei P8 Lite (PRA-LX1)",
 	"Huawei P9 (EVA-L09/AL00)",
 	"Huawei P10 (VTR-L09)",
 	"Huawei P10+ (VKY-L09)",
 	"Huawei P10 Lite (WAS-LX1A)",
 	"Huawei P20 (EML-L09)",
+	"Huawei P20 Lite (ANE-LX1)",
 	"Huawei P20 Pro (CLT-L29/L09)",
 	"Huawei P30 Pro (VOG-L29)",
 	"Huawei Honor6a",
 	"Huawei Honor7a pro",
 	"Huawei Honor8 (FRD-L09)",
 	"Huawei Honor9",
 	"Huawei Honor10",
 	"Huawei Honor20",
 	"Huawei Honor View 10 (BKL-L09)",
 	"Huawei Honor View 20 (PCT-L29)",
 	"Huawei Honor 20 Pro (YAL-L41)",
 	"Huawei Mate8 (NXT-L29)",
 	"Huawei Mate10 (BLA-L29)",
 	"Huawei Mate20 Pro (LYA-L29)",
 	"Huawei Mate20 Lite (SNE-LX1)",
 	"Imacon Ixpress 96, 96C",
 	"Imacon Ixpress 384, 384C (single shot only)",
 	"Imacon Ixpress 132C",
 	"Imacon Ixpress 528C (single shot only)",
 	"ISG 2020x1520",
 	"Ikonoskop A-Cam dII Panchromatic",
 	"Ikonoskop A-Cam dII",
+	"Kandao QooCam 8K",
 	"Kinefinity KineMINI",
 	"Kinefinity KineRAW Mini",
 	"Kinefinity KineRAW S35",
 	"Kodak DC20",
 	"Kodak DC25",
 	"Kodak DC40",
 	"Kodak DC50",
 	"Kodak DC120",
 	"Kodak DCS200",
 	"Kodak DCS315C",
 	"Kodak DCS330C",
 	"Kodak DCS420",
 	"Kodak DCS460",
 	"Kodak DCS460M",
 	"Kodak DCS460",
 	"Kodak DCS520C",
 	"Kodak DCS560C",
 	"Kodak DCS620C",
 	"Kodak DCS620X",
 	"Kodak DCS660C",
 	"Kodak DCS660M",
 	"Kodak DCS720X",
 	"Kodak DCS760C",
 	"Kodak DCS760M",
 	"Kodak EOSDCS1",
 	"Kodak EOSDCS3",
 	"Kodak NC2000",
 	"Kodak ProBack",
 	"Kodak PB645C",
 	"Kodak PB645H",
 	"Kodak PB645M",
 	"Kodak DCS Pro 14n",
 	"Kodak DCS Pro 14nx",
 	"Kodak DCS Pro SLR/c",
 	"Kodak DCS Pro SLR/n",
 	"Kodak C330",
 	"Kodak C603",
 	"Kodak P850",
 	"Kodak P880",
 	"Kodak PIXPRO AZ901",
 	"Kodak PIXPRO S-1",
 	"Kodak Z980",
 	"Kodak Z981",
 	"Kodak Z990",
 	"Kodak Z1015",
 	"Kodak KAI-0340",
 	"Konica KD-400Z",
 	"Konica KD-510Z",
 	"Leaf AFi 5",
 	"Leaf AFi 6",
 	"Leaf AFi 7",
 	"Leaf AFi-II 6",
 	"Leaf AFi-II 7",
 	"Leaf AFi-II 10",
 	"Leaf AFi-II 10R",
 	"Leaf Aptus-II 5",
 	"Leaf Aptus-II 6",
 	"Leaf Aptus-II 7",
 	"Leaf Aptus-II 8",
 	"Leaf Aptus-II 10",
 	"Leaf Aptus-II 12",
 	"Leaf Aptus-II 12R",
 	"Leaf Aptus 17",
 	"Leaf Aptus 22",
 	"Leaf Aptus 54S",
 	"Leaf Aptus 65",
 	"Leaf Aptus 65S",
 	"Leaf Aptus 75",
 	"Leaf Aptus 75S",
 	"Leaf Cantare",
 	"Leaf Cantare XY",
 	"Leaf CatchLight",
 	"Leaf CMost",
 	"Leaf Credo 40",
 	"Leaf Credo 50",
 	"Leaf Credo 60",
 	"Leaf Credo 80 (low compression mode only)",
 	"Leaf DCB-II",
 	"Leaf Valeo 6",
 	"Leaf Valeo 11",
 	"Leaf Valeo 17",
 	"Leaf Valeo 17wi",
 	"Leaf Valeo 22",
 	"Leaf Valeo 22wi",
 	"Leaf Volare",
 	"Lenovo a820",
 	"Leica C (Typ 112)",
 	"Leica CL",
 	"Leica C-Lux / CAM-DC25",
 	"Leica Digilux 2",
 	"Leica Digilux 3",
 	"Leica Digital-Modul-R",
 	"Leica D-LUX2",
 	"Leica D-LUX3",
 	"Leica D-LUX4",
 	"Leica D-LUX5",
 	"Leica D-LUX6",
 	"Leica D-LUX7",
 	"Leica D-Lux (Typ 109)",
 	"Leica M8",
 	"Leica M8.2",
 	"Leica M9",
 	"Leica M10",
 	"Leica M10-D",
 	"Leica M10-P",
 	"Leica M10-R",
 	"Leica M10 Monochrom",
 	"Leica M (Typ 240)",
 	"Leica M (Typ 262)",
 	"Leica Monochrom (Typ 240)",
 	"Leica Monochrom (Typ 246)",
 	"Leica M-D (Typ 262)",
 	"Leica M-E",
 	"Leica M-P",
 	"Leica R8",
 	"Leica Q (Typ 116)",
 	"Leica Q-P",
 	"Leica Q2",
 	"Leica Q2 Monochrom",
 	"Leica S",
 	"Leica S2",
 	"Leica S3",
 	"Leica S (Typ 007)",
 	"Leica SL (Typ 601)",
 	"Leica SL2",
 	"Leica SL2-S",
 	"Leica T (Typ 701)",
 	"Leica TL",
 	"Leica TL2",
 	"Leica X1",
 	"Leica X (Typ 113)",
 	"Leica X2",
 	"Leica X-E (Typ 102)",
 	"Leica X-U (Typ 113)",
 	"Leica V-LUX1",
 	"Leica V-LUX2",
 	"Leica V-LUX3",
 	"Leica V-LUX4",
 	"Leica V-LUX5",
 	"Leica V-Lux (Typ 114)",
 	"Leica X VARIO (Typ 107)",
 	"LG G3",
 	"LG G4",
 	"LG G5 (H850)",
 	"LG G6",
 	"LG V20 (F800K)",
 	"LG V20 (H910)",
 	"LG VS995",
 	"Logitech Fotoman Pixtura",
 	"Mamiya ZD",
 	"Matrix 4608x3288",
 	"Meizy MX4",
 	"Micron 2010",
 	"Minolta RD175 / Agfa ActionCam",
 	"Minolta DiMAGE 5",
 	"Minolta DiMAGE 7",
 	"Minolta DiMAGE 7i",
 	"Minolta DiMAGE 7Hi",
 	"Minolta DiMAGE A1",
 	"Minolta DiMAGE A2",
 	"Minolta DiMAGE A200",
 	"Minolta DiMAGE G400",
 	"Minolta DiMAGE G500",
 	"Minolta DiMAGE G530",
 	"Minolta DiMAGE G600",
 	"Minolta DiMAGE Z2",
 	"Minolta Alpha/Dynax/Maxxum 5D",
 	"Minolta Alpha/Dynax/Maxxum 7D",
 	"Motorola PIXL",
 	"Motorola Moto G (5S)",
 	"Motorola Moto G7 Play",
 	"Nikon D1",
 	"Nikon D1H",
 	"Nikon D1X",
 	"Nikon D2H",
 	"Nikon D2Hs",
 	"Nikon D2X",
 	"Nikon D2Xs",
 	"Nikon D3",
 	"Nikon D3s",
 	"Nikon D3X",
 	"Nikon D4",
 	"Nikon D4s",
 	"Nikon D40",
 	"Nikon D40X",
 	"Nikon D5",
 	"Nikon D50",
 	"Nikon D6",
 	"Nikon D60",
 	"Nikon D70",
 	"Nikon D70s",
 	"Nikon D80",
 	"Nikon D90",
 	"Nikon D100",
 	"Nikon D200",
 	"Nikon D300",
 	"Nikon D300s",
 	"Nikon D500",
 	"Nikon D600",
 	"Nikon D610",
 	"Nikon D700",
 	"Nikon D750",
 	"Nikon D780",
 	"Nikon D800",
 	"Nikon D800E",
 	"Nikon D810",
 	"Nikon D810A",
 	"Nikon D850",
 	"Nikon D3000",
 	"Nikon D3100",
 	"Nikon D3200",
 	"Nikon D3300",
 	"Nikon D3400",
 	"Nikon D3500",
 	"Nikon D5000",
 	"Nikon D5100",
 	"Nikon D5200",
 	"Nikon D5300",
 	"Nikon D5500",
 	"Nikon D5600",
 	"Nikon D7000",
 	"Nikon D7100",
 	"Nikon D7200",
 	"Nikon D7500",
 	"Nikon Df",
 	"Nikon Z 5",
 	"Nikon Z 6",
 	"Nikon Z 6 II",
 	"Nikon Z 7",
 	"Nikon Z 7 II",
 	"Nikon Z 50",
+	"Nikon Z fc",
 	"Nikon 1 AW1",
 	"Nikon 1 J1",
 	"Nikon 1 J2",
 	"Nikon 1 J3",
 	"Nikon 1 J4",
 	"Nikon 1 J5",
 	"Nikon 1 S1",
 	"Nikon 1 S2",
 	"Nikon 1 V1",
 	"Nikon 1 V2",
 	"Nikon 1 V3",
 	"Nikon Coolpix 700 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 800 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 880 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 900 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 950 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 990 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 995 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 2100 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 2500 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 3200 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 3700 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 4300 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 4500 (\"DIAG RAW\" hack)",
 	"Nikon Coolpix 5000",
 	"Nikon Coolpix 5400",
 	"Nikon Coolpix 5700",
 	"Nikon Coolpix 8400",
 	"Nikon Coolpix 8700",
 	"Nikon Coolpix 8800",
 	"Nikon Coolpix A",
 	"Nikon Coolpix A1000",
 	"Nikon Coolpix B700",
 	"Nikon Coolpix P330",
 	"Nikon Coolpix P340",
 	"Nikon Coolpix P950",
 	"Nikon Coolpix P6000",
 	"Nikon Coolpix P1000",
 	"Nikon Coolpix P7000",
 	"Nikon Coolpix P7100",
 	"Nikon Coolpix P7700",
 	"Nikon Coolpix P7800",
 	"Nikon Coolpix S6 (\"DIAG RAW\" hack)",
 	"Nikon Coolscan NEF",
 	"Nokia 7 Plus",
 	"Nokia 8.3 5G",
 	"Nokia 9",
 	"Nokia N95",
 	"Nokia X2",
 	"Nokia 1200x1600",
 	"Nokia Lumia 930",
 	"Nokia Lumia 950 XL",
 	"Nokia Lumia 1020",
 	"Nokia Lumia 1520",
 	"Olympus AIR A01",
 	"Olympus C-3030Z",
 	"Olympus C-5050Z",
 	"Olympus C-5060WZ",
 	"Olympus C-7070WZ",
 	"Olympus C-70Z / C-7000Z",
 	"Olympus C-740UZ",
 	"Olympus C-770UZ",
 	"Olympus C-8080WZ",
 	"Olympus X200 / D-560Z / C-350Z",
 	"Olympus E-1",
 	"Olympus E-3",
 	"Olympus E-5",
 	"Olympus E-10",
 	"Olympus E-20 / E-20N / E-20P",
 	"Olympus E-30",
 	"Olympus E-300",
 	"Olympus E-330",
 	"Olympus E-400",
 	"Olympus E-410",
 	"Olympus E-420",
 	"Olympus E-450",
 	"Olympus E-500",
 	"Olympus E-510",
 	"Olympus E-520",
 	"Olympus E-600",
 	"Olympus E-620",
 	"Olympus E-P1",
 	"Olympus E-P2",
 	"Olympus E-P3",
 	"Olympus E-P5",
+	"Olympus E-P7",
 	"Olympus E-PL1",
 	"Olympus E-PL1s",
 	"Olympus E-PL2",
 	"Olympus E-PL3",
 	"Olympus E-PL5",
 	"Olympus E-PL6",
 	"Olympus E-PL7",
 	"Olympus E-PL8",
 	"Olympus E-PL9",
 	"Olympus E-PL10",
 	"Olympus E-PM1",
 	"Olympus E-PM2",
 	"Olympus E-M1",
 	"Olympus E-M1 Mark II",
 	"Olympus E-M1 Mark III",
 	"Olympus E-M1X",
 	"Olympus E-M10",
 	"Olympus E-M10 Mark II",
 	"Olympus E-M10 Mark III",
 	"Olympus E-M10 Mark IV",
 	"Olympus E-M5",
 	"Olympus E-M5 Mark II",
 	"Olympus E-M5 Mark III",
 	"Olympus Pen-F",
 	"Olympus SP-310",
 	"Olympus SP-320",
 	"Olympus SP-350",
 	"Olympus SP-500UZ",
 	"Olympus SP-510UZ",
 	"Olympus SP-550UZ",
 	"Olympus SP-560UZ",
 	"Olympus SP-565UZ",
 	"Olympus SP-570UZ",
 	"Olympus Stylus 1",
 	"Olympus Stylus 1s",
 	"Olympus SH-2",
 	"Olympus SH-3",
 	"Olympus TG-4",
 	"Olympus TG-5",
 	"Olympus TG-6",
 	"Olympus XZ-1",
 	"Olympus XZ-2",
 	"Olympus XZ-10",
 	"OmniVision 4688",
 	"OmniVision OV5647",
 	"OmniVision OV5648",
 	"OmniVision OV8850",
 	"OmniVision 13860",
 	"OnePlus 6 (A6003)",
 	"OnePlus 6T",
 	"OnePlus 7 Pro (GM1913)",
 	"OnePlus 8 Pro (IN2023)",
 	"OnePlus One",
 	"OnePlus A3303",
 	"OnePlus A5000",
 	"Panasonic DMC-CM1",
 	"Panasonic DMC-FZ8",
 	"Panasonic DMC-FZ18",
 	"Panasonic DMC-FZ28",
 	"Panasonic DMC-FZ30",
 	"Panasonic DMC-FZ35 / FZ38",
 	"Panasonic DMC-FZ40 / FZ42 / FZ45",
 	"Panasonic DMC-FZ50",
 	"Panasonic DMC-FZ70 / FZ72",
 	"Panasonic DC-FZ80 / FZ81 / FZ82 / FZ83 / FZ85",
 	"Panasonic DMC-FZ100",
 	"Panasonic DMC-FZ150",
 	"Panasonic DMC-FZ200",
 	"Panasonic DMC-FZ300 / FZ330",
 	"Panasonic DMC-FZ1000",
 	"Panasonic DC-FZ1000 II / FZ1000M2 / DC-FZ10002",
 	"Panasonic DMC-FZ2000 / FZ2500 / FZH1",
 	"Panasonic DMC-FX150 / FX180",
 	"Panasonic DMC-G1",
 	"Panasonic DMC-G10",
 	"Panasonic DMC-G2",
 	"Panasonic DMC-G3",
 	"Panasonic DMC-G5",
 	"Panasonic DMC-G6",
 	"Panasonic DMC-G7 / G70",
 	"Panasonic DMC-G8 / G80 / G81 / G85",
 	"Panasonic DC-G9",
 	"Panasonic DC-G90 / G95 / G91 / G99",
 	"Panasonic DC-G100 / G110",
 	"Panasonic DMC-GF1",
 	"Panasonic DMC-GF2",
 	"Panasonic DMC-GF3",
 	"Panasonic DMC-GF5",
 	"Panasonic DMC-GF6",
 	"Panasonic DMC-GF7",
 	"Panasonic DC-GF10 / GF90",
 	"Panasonic DMC-GH1",
 	"Panasonic DMC-GH2",
 	"Panasonic DMC-GH3",
 	"Panasonic DMC-GH4",
 	"Panasonic AG-GH4",
 	"Panasonic DC-GH5",
 	"Panasonic DC-GH5S",
+	"Panasonic DC-GH5 Mark II",
 	"Panasonic DMC-GM1",
 	"Panasonic DMC-GM1s",
 	"Panasonic DMC-GM5",
 	"Panasonic DMC-GX1",
 	"Panasonic DMC-GX7",
 	"Panasonic DMC-GX8",
 	"Panasonic DC-GX9 / GX7mkIII",
 	"Panasonic DMC-GX80 / GX85, DMC-GX7mkII",
 	"Panasonic DC-GX800 / GX850, DC-GF9",
 	"Panasonic DMC-L1",
 	"Panasonic DMC-L10",
 	"Panasonic DMC-LC1",
 	"Panasonic DMC-LF1",
 	"Panasonic DMC-LX1",
 	"Panasonic DMC-LX2",
 	"Panasonic DMC-LX3",
 	"Panasonic DMC-LX5",
 	"Panasonic DMC-LX7",
 	"Panasonic DMC-LX9 / LX10 / LX15",
 	"Panasonic DMC-LX100",
 	"Panasonic DC-LX100M2",
 	"Panasonic DC-S1",
 	"Panasonic DC-S1H",
 	"Panasonic DC-S1R",
 	"Panasonic DC-S5",
 	"Panasonic DMC-ZS40, DMC-TZ60 / TZ61",
 	"Panasonic DMC-ZS50, DMC-TZ70 / TZ71",
 	"Panasonic DMC-ZS60, DMC-TZ80 / TZ81 / TZ82 / TZ85",
 	"Panasonic DC-ZS70, DC-TZ90 / TZ91 / TZ92 / TZ93",
 	"Panasonic DC-ZS80, DC-TZ95 / TZ96 / TZ97",
 	"Panasonic DMC-ZS100 / ZS110, DMC-TZ100 / TZ101 / TZ110, DMC-TX1",
 	"Panasonic DC-ZS200 / ZS220, DC-TZ200 / TZ202 / TZ220, DC-TX2",
 	"PARROT Anafi",
 	"PARROT Bebop 2",
 	"PARROT Bebop Drone",
 	"Pentax *ist D",
 	"Pentax *ist DL",
 	"Pentax *ist DL2",
 	"Pentax *ist DS",
 	"Pentax *ist DS2",
 	"Pentax K10D",
 	"Pentax K20D",
 	"Pentax K100D",
 	"Pentax K100D Super",
 	"Pentax K110D",
 	"Pentax K200D",
 	"Pentax K2000/K-m",
 	"Pentax KP",
 	"Pentax K-x",
 	"Pentax K-r",
 	"Pentax K-01",
 	"Pentax K-1",
 	"Pentax K-1 Mark II",
 	"Pentax K-3",
-	"Pentax K-3 II",
+	"Pentax K-3 Mark II",
+	"Pentax K-3 Mark III",
 	"Pentax K-30",
 	"Pentax K-5",
 	"Pentax K-5 II",
 	"Pentax K-5 IIs",
 	"Pentax K-50",
 	"Pentax K-500",
 	"Pentax K-7",
 	"Pentax K-70",
 	"Pentax K-S1",
 	"Pentax K-S2",
 	"Pentax MX-1",
 	"Pentax Q",
 	"Pentax Q7",
 	"Pentax Q10",
 	"Pentax QS-1",
 	"Pentax Optio S (secret menu or hack)",
 	"Pentax Optio S4 (secret menu or hack)",
 	"Pentax Optio 33WR (secret menu or hack)",
 	"Pentax Optio 750Z (secret menu or hack)",
 	"Pentax 645D",
 	"Pentax 645Z",
 	"PhaseOne IQ140",
 	"PhaseOne IQ150",
 	"PhaseOne IQ160",
 	"PhaseOne IQ180",
 	"PhaseOne IQ180 IR",
 	"PhaseOne IQ250",
 	"PhaseOne IQ260",
 	"PhaseOne IQ260 Achromatic",
 	"PhaseOne IQ280",
 	"PhaseOne IQ3 50MP",
 	"PhaseOne IQ3 60MP",
 	"PhaseOne IQ3 80MP",
 	"PhaseOne IQ3 100MP",
 	"PhaseOne IQ3 100MP Trichromatic",
 	"PhaseOne IQ4 150MP",
 	"PhaseOne LightPhase",
 	"PhaseOne Achromatic+",
 	"PhaseOne H 10",
 	"PhaseOne H 20",
 	"PhaseOne H 25",
 	"PhaseOne P 20",
 	"PhaseOne P 20+",
 	"PhaseOne P 21",
 	"PhaseOne P 25",
 	"PhaseOne P 25+",
 	"PhaseOne P 30",
 	"PhaseOne P 30+",
 	"PhaseOne P 40+",
 	"PhaseOne P 45",
 	"PhaseOne P 45+",
 	"PhaseOne P 65",
 	"PhaseOne P 65+",
 	"Photron BC2-HD",
 	"Pixelink A782",
 #ifdef USE_X3FTOOLS
 	"Polaroid x530",
 #endif
 	"RaspberryPi Camera",
 	"RaspberryPi Camera V2",
+#ifdef USE_6BY9RPI
+	"RaspberryPi HQ Camera",
+#endif
 	"Ricoh GR",
 	"Realme 3 Pro",
 	"Ricoh GR II",
 	"Ricoh GR III",
+	"Ricoh GR IIIx",
 	"Ricoh GR Digital",
 	"Ricoh GR Digital II",
 	"Ricoh GR Digital III",
 	"Ricoh GR Digital IV",
 	"Ricoh Caplio GX100",
 	"Ricoh Caplio GX200",
 	"Ricoh GXR Mount A12",
 	"Ricoh GXR GR Lens A12 50mm F2.5 Macro",
 	"Ricoh GXR GR Lens A12 28mm F2.5",
 	"Ricoh GXR Ricoh Lens A16 24-85mm F3.5-5.5",
 	"Ricoh GXR Ricoh Lens S10 24-72mm F2.5-4.4 VC",
 	"Ricoh GXR Ricoh Lens P10 28-300 mm F3.5-5.6 VC",
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 #ifndef NO_JASPER
 	"Redcode R3D format",
 #endif
 #endif
 	"Rollei d530flex",
 	"RoverShot 3320af",
 	"Samsung EX1 / TL500",
 	"Samsung EX2F",
 	"Samsung GX-1L",
 	"Samsung GX-1S",
 	"Samsung GX10",
 	"Samsung GX20",
 	"Samsung Galaxy Nexus",
 	"Samsung Galaxy Note 9",
 	"Samsung Galaxy NX (EK-GN120)",
 	"Samsung Galaxy S3",
 	"Samsung Galaxy S6 (SM-G920F)",
 	"Samsung Galaxy S7",
 	"Samsung Galaxy S7 Edge",
 	"Samsung Galaxy S8 (SM-G950U)",
 	"Samsung Galaxy S9 (SM-G960F)",
 	"Samsung Galaxy S9+ (SM-G965U / 965F)",
 	"Samsung Galaxy S10 (SM-G973F)",
 	"Samsung Galaxy S10+ (SM-G975U)",
 	"Samsung NX1",
 	"Samsung NX5",
 	"Samsung NX10",
 	"Samsung NX11",
 	"Samsung NX100",
 	"Samsung NX1000",
 	"Samsung NX1100",
 	"Samsung NX20",
 	"Samsung NX200",
 	"Samsung NX210",
 	"Samsung NX2000",
 	"Samsung NX30",
 	"Samsung NX300",
 	"Samsung NX300M",
 	"Samsung NX3000",
 	"Samsung NX500",
 	"Samsung NX mini / NXF1",
 	"Samsung Pro815",
 	"Samsung WB550 / WB560 / HZ15W",
 	"Samsung WB2000 / TL350",
 	"Samsung WB5000 / HZ25W",
 	"Samsung S85 (hacked)",
 	"Samsung S850 (hacked)",
 	"Sarnoff 4096x5440",
 	"Seitz 6x17",
 	"Seitz Roundshot D3",
 	"Seitz Roundshot D2X",
 	"Seitz Roundshot D2Xs",
 	"Sigma fp",
 #ifdef USE_X3FTOOLS
 	"Sigma SD9 (raw decode only)",
 	"Sigma SD10 (raw decode only)",
 	"Sigma SD14 (raw decode only)",
 	"Sigma SD15 (raw decode only)",
 	"Sigma SD1",
 	"Sigma SD1 Merrill",
 	"Sigma DP1",
 	"Sigma DP1 Merrill",
 	"Sigma DP1S",
 	"Sigma DP1X",
 	"Sigma DP2",
 	"Sigma DP2 Merrill",
 	"Sigma DP2S",
 	"Sigma DP2X",
 	"Sigma DP3 Merrill",
 	"Sigma dp0 Quattro",
 	"Sigma dp1 Quattro",
 	"Sigma dp2 Quattro",
 	"Sigma dp3 Quattro",
 	"Sigma sd Quattro",
 	"Sigma sd Quattro H",
 #else
 		"Sigma dp0 Quattro (DNG only)",
 		"Sigma dp1 Quattro (DNG only)",
 		"Sigma dp2 Quattro (DNG only)",
 		"Sigma dp3 Quattro (DNG only)",
 		"Sigma sd Quattro (DNG only)",
 		"Sigma sd Quattro H (DNG only)",
 #endif
 	"Sinar eMotion 22",
 	"Sinar eMotion 54",
 	"Sinar eSpirit 65",
 	"Sinar eMotion 75",
 	"Sinar eVolution 75",
 	"Sinar 3072x2048 (Sinarback 23)",
 	"Sinar 4080x4080 (Sinarback 44)",
 	"Sinar 4080x5440",
 	"Sinar STI format",
 	"Sinar Sinarback 54",
 	"SMaL Ultra-Pocket 3",
 	"SMaL Ultra-Pocket 4",
 	"SMaL Ultra-Pocket 5",
+	"Sony ILCE-1 (A1)",
 	"Sony ILCE-7 (A7)",
 	"Sony ILCE-7M2 (A7 II)",
 	"Sony ILCE-7M3 (A7 III)",
 	"Sony ILCE-7C (A7C)",
 	"Sony ILCE-7R (A7R",
 	"Sony ILCE-7RM2 (A7R II)",
 	"Sony ILCE-7RM3 (A7R III)",
+	"Sony ILCE-7RM3A (A7R IIIA)",
 	"Sony ILCE-7RM4 (A7R IV)",
+	"Sony ILCE-7RM4A (A7R IVA)",
 	"Sony ILCE-7S (A7S)",
 	"Sony ILCE-7SM2 (A7S II)",
 	"Sony ILCE-7SM3 (A7S III)",
 	"Sony ILCE-9 (A9)",
 	"Sony ILCE-9M2 (A9 II)",
 	"Sony ILCA-68 (A68)",
 	"Sony ILCA-77M2 (A77-II)",
 	"Sony ILCA-99M2 (A99-II)",
 	"Sony ILCE-3000 / 3500",
 	"Sony ILCE-5000",
 	"Sony ILCE-5100",
 	"Sony ILCE-6000",
 	"Sony ILCE-6100",
 	"Sony ILCE-6300",
 	"Sony ILCE-6400",
 	"Sony ILCE-6500",
 	"Sony ILCE-6600",
 	"Sony ILCE-QX1",
 	"Sony DSC-F828",
 	"Sony DSC-HX95",
 	"Sony DSC-HX99",
 	"Sony DSC-R1",
 	"Sony DSC-RX0",
 	"Sony DSC-RX0 II",
 	"Sony DSC-RX1",
 	"Sony DSC-RX1R",
 	"Sony DSC-RX1R II",
 	"Sony DSC-RX10",
 	"Sony DSC-RX10 II",
 	"Sony DSC-RX10 III",
 	"Sony DSC-RX10 IV",
 	"Sony DSC-RX100",
 	"Sony DSC-RX100 II",
 	"Sony DSC-RX100 III",
 	"Sony DSC-RX100 IV",
 	"Sony DSC-RX100 V",
 	"Sony DSC-RX100 VA",
 	"Sony DSC-RX100 VI",
 	"Sony DSC-RX100 VII",
 	"Sony DSC-V3",
 	"Sony DSLR-A100",
 	"Sony DSLR-A200",
 	"Sony DSLR-A230",
 	"Sony DSLR-A290",
 	"Sony DSLR-A300",
 	"Sony DSLR-A330",
 	"Sony DSLR-A350",
 	"Sony DSLR-A380 / A390",
 	"Sony DSLR-A450",
 	"Sony DSLR-A500",
 	"Sony DSLR-A550",
 	"Sony DSLR-A560",
 	"Sony DSLR-A580",
 	"Sony DSLR-A700",
 	"Sony DSLR-A850",
 	"Sony DSLR-A900",
 	"Sony NEX-3",
 	"Sony NEX-3N",
 	"Sony NEX-5",
 	"Sony NEX-5N",
 	"Sony NEX-5R",
 	"Sony NEX-5T",
 	"Sony NEX-6",
 	"Sony NEX-7",
 	"Sony NEX-C3",
 	"Sony NEX-F3",
 	"Sony NEX-VG20",
 	"Sony NEX-VG30",
 	"Sony NEX-VG900",
 	"Sony SLT-A33",
 	"Sony SLT-A35",
 	"Sony SLT-A37",
 	"Sony SLT-A55(V)",
 	"Sony SLT-A57",
 	"Sony SLT-A58",
 	"Sony SLT-A65(V)",
 	"Sony SLT-A77(V)",
 	"Sony SLT-A99(V)",
 	"Sony XCD-SX910CR",
 	"Sony IMX135-mipi 13mp",
 	"Sony IMX135-QCOM",
 	"Sony IMX072-mipi",
 	"Sony IMX214",
 	"Sony IMX219",
 	"Sony IMX230",
 	"Sony IMX298-mipi 16mp",
 	"Sony IMX219-mipi 8mp",
 	"Sony Xperia 5 II (XQ-AS52)",
 	"Sony Xperia L",
+	"Sony Xperia 1 III",
 	"Sony ZV-1 (DCZV1/B)",
+	"Sony ZV-E10",
 	"STV680 VGA",
 	"PtGrey GRAS-50S5C",
 	"JaiPulnix BB-500CL",
 	"JaiPulnix BB-500GE",
 	"SVS SVS625CL",
 	"Vivo X51 5G (V2006)",
 	"Yi M1",
 	"YUNEEC CGO3",
 	"YUNEEC CGO3P",
 	"YUNEEC CGO4",
 	"Xiaomi MI3",
 	"Xiaomi MI 8",
 	"Xiaomi MI 9 Lite",
 	"Xiaomi MI MAX",
+	"Xiaomi POCO M3",
 	"Xiaomi RedMi Note3 Pro",
 	"Xiaomi RedMi Note7",
+	"Xiaomi RedMi Note 8T",
 	"Xiaomi FIMI X8SE",
 	"Xiaoyi YIAC3 (YI 4k)",
 	"Zeiss ZX1",
 	"Zenit M",
 	NULL
 };
 // clang-format on
diff --git a/src/tables/colordata.cpp b/src/tables/colordata.cpp
index e2bf971f..7e7f5e10 100644
--- a/src/tables/colordata.cpp
+++ b/src/tables/colordata.cpp
@@ -21,1759 +21,1788 @@
 /*
    All matrices are from Adobe DNG Converter unless otherwise noted.
  */
 int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
                         int internal_only)
 {
   // clang-format off
   static const struct
   {
 	  unsigned m_idx;
 	  const char *prefix;
 	  int t_black, t_maximum, trans[12];
   } table[] = {
     { LIBRAW_CAMERAMAKER_Agfa, "DC-833m", 0, 0,
       { 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Apple, "QuickTake", 0, 0,
       { 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Broadcom, "RPi IMX219", 66, 0x3ff,
       { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } }, /* LibRaw */
     { LIBRAW_CAMERAMAKER_Broadcom, "RPi OV5647", 16, 0x3ff,
       { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
 	{ LIBRAW_CAMERAMAKER_Broadcom, "Pi", 16, 0x3ff,
 	  { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
 
+#ifdef USE_6BY9RPI // this code normalizes model to LIBRAW_CAMERAMAKER_RaspberryPi
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "RP_imx477", 0, 0, // Do not set black, it is set at parser to 256 or 64
+      { 5603, -1351, -600, -2872, 11180, 2132, 600, 453, 5821 } }, /* PyDNG */
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "RP_imx", 66, 0x3ff,
+      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } }, /* LibRaw */
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "ov5647", 16, 0x3ff,
+      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
+#endif
     { LIBRAW_CAMERAMAKER_Canon, "EOS D30", 0, 0,
       { 9900,-2771,-1324,-7072,14229,3140,-2790,3344,8861 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS D60", 0, 0xfa0,
       { 6211,-1358,-896,-8557,15766,3012,-3001,3507,8567 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 5DS", 0, 0x3c96, // same CMs: 5DS, "5DS R" */
       { 6250,-711,-808,-5153,12794,2636,-1249,2198,5610 } }, // v.2
     { LIBRAW_CAMERAMAKER_Canon, "EOS 5D Mark IV", 0, 0,
       { 6446,-366,-864,-4436,12204,2513,-952,2496,6348 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 5D Mark III", 0, 0x3c80,
       { 6722,-635,-963,-4287,12460,2028,-908,2162,5668 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 5D Mark II", 0, 0x3cf0,
       { 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 5D", 0, 0xe6c,
       { 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 6D Mark II", 0, 0x38de,
       { 6875,-970,-932,-4691,12459,2501,-874,1953,5809 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 6D", 0, 0x3c82,
       { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 77D", 0, 0,
       { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 7D Mark II", 0, 0x3510,
       { 7268,-1082,-969,-4186,11839,2663,-825,2029,5839 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 7D", 0, 0x3510,
       { 6844,-996,-856,-3876,11761,2396,-593,1772,6198 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 850D", 0, 0,
       { 9079,-1923,-1236,-4677,12454,2492,-922,2319,5565}},
     { LIBRAW_CAMERAMAKER_Canon, "EOS 800D", 0, 0,
       { 6970,-512,-968,-4425,12161,2553,-739,1982,5601 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 80D", 0, 0,
       { 7457,-671,-937,-4849,12495,2643,-1213,2354,5492 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 10D", 0, 0xfa0,
       { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 250D", 0, 0,
       { 9079,-1923,-1236,-4677,12454,2492,-922,2319,5565 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 200D", 0, 0,
       { 7377,-742,-998,-4235,11981,2549,-673,1918,5538 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 20Da", 0, 0,
       { 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 20D", 0, 0xfff,
       { 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 30D", 0, 0,
       { 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 40D", 0, 0x3f60,
       { 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 50D", 0, 0x3d93,
       { 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 60Da", 0, 0x2ff7,
       { 17492,-7240,-2023,-1791,10323,1701,-186,1329,5406 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 60D", 0, 0x2ff7,
       { 6719,-994,-925,-4408,12426,2211,-887,2129,6051 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 70D", 0, 0x3bc7,
       { 7034,-804,-1014,-4420,12564,2058,-851,1994,5758 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 100D", 0, 0x350f,
       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 300D", 0, 0xfa0,
       { 8250,-2044,-1127,-8092,15606,2664,-2893,3453,8348 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 350D", 0, 0xfff,
       { 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 3000D", 0, 0,
       { 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 400D", 0, 0xe8e,
       { 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 450D", 0, 0x390d,
       { 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 500D", 0, 0x3479,
       { 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 550D", 0, 0x3dd7,
       { 6941,-1164,-857,-3825,11597,2534,-416,1540,6039 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 600D", 0, 0x3510,
       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 650D", 0, 0x354d,
       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 750D", 0, 0x3c00,
       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 760D", 0, 0x3c00,
       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 700D", 0, 0x3c00,
       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 90D", 0, 0,
       { 11498, -3759, -1516, -5073, 12954,  2349,  -892,  1867,  6118}},
     { LIBRAW_CAMERAMAKER_Canon, "EOS 1000D", 0, 0xe43,
       { 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 1100D", 0, 0x3510,
       { 6444,-904,-893,-4563,12308,2535,-903,2016,6728 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 1200D", 0, 0x37c2,
       { 6461,-907,-882,-4300,12184,2378,-819,1944,5931 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 1300D", 0, 0x37c2,
       { 6939,-1016,-866,-4428,12473,2177,-1175,2178,6162 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS 1500D", 0, 0,
       { 8300,-2110,-1120,-4917,12694,2482,-938,2141,5666 } }, // v.2
 
     { LIBRAW_CAMERAMAKER_Canon, "EOS RP", 0, 0,
       { 8608,-2097,-1178,-5425,13265,2383,-1149,2238,5680 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS R5", 0, 0,
       { 9766,-2953,-1254,-4276,12116,2433,-437,1336,5131 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS R6", 0, 0,
       { 8293,-1611,-1132,-4759,12711,2275,-1013,2415,5509 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS R", 0, 0,
       { 8293,-1789,-1094,-5025,12925,2327,-1199,2769,6108 } }, // v.2
 
     { LIBRAW_CAMERAMAKER_Canon, "EOS M6 Mark II", 0, 0,
       { 11498,-3759,-1516,-5073,12954,2349,-892,1867,6118 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M6", 0, 0,
       { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M50 Mark II", 0, 0,
       { 10463,-2173,-1437,-4856,12635,2482,-1216,2915,7237 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M50", 0, 0,
       { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M5", 0, 0,
       { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M3", 0, 0,
       { 6362,-823,-847,-4426,12109,2616,-743,1857,5635 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M200", 0, 0,
       { 10463,-2173,-1437,-4856,12635,2482,-1216,2915,7237 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M2", 0, 0,
       { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M100", 0, 0,
       { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M10", 0, 0,
       { 6400,-480,-888,-5294,13416,2047,-1296,2203,6137 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS M", 0, 0,
       { 6602,-841,-939,-4472,12458,2247,-975,2039,6148 } },
 
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1Ds Mark III", 0, 0x3bb0,
       { 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1Ds Mark II", 0, 0xe80,
       { 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D Mark IV", 0, 0x3bb0,
       { 6014,-220,-795,-4109,12014,2361,-561,1824,5787 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D Mark III", 0, 0x3bb0,
       { 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D Mark II N", 0, 0xe80,
       { 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D Mark II", 0, 0xe80,
       { 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1Ds", 0, 0xe20,
       { 3925,4060,-1739,-8973,16552,2545,-3287,3945,8243 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D C", 0, 0x3c4e,
       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D X Mark III", 0, 0,
       {  8971, -2022, -1242, -5405, 13249,  2380, -1280,  2483,  6072}},
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D X Mark II", 0, 0x3c4e,
       { 7596,-978,-967,-4808,12571,2503,-1398,2567,5752 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D X", 0, 0x3c4e,
       { 6847,-614,-1014,-4669,12737,2139,-1197,2488,6846 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS-1D", 0, 0xe20,
       { 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS C500", 853, 0,
       { 17851,-10604,922,-7425,16662,763,-3660,3636,22278 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Canon, "IXUS 160", 0, 0,
       { 11657,-3781,-1136,-3544,11262,2283,-160,1219,4700 } }, /* DJC */
     {LIBRAW_CAMERAMAKER_Canon, "PowerShot 600", 0, 0,
       { -3822,10019,1311,4085,-157,3386,-5341,10829,4812,-1969,10969,1126 } },
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A3300 IS", 0, 0,
       { 10826,-3654,-1023,-3215,11310,1906,0,999,4960 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A460", 0, 0,
       { 6493,-2338,-885,-1589,5934,697,-445,1368,2543 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A470", 0, 0,
       { 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A530", 0, 0,
       { 7252,-2405,-1223,-2102,6560,523,-112,704,3007 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A50", 0, 0,
       { -6233,10706,1825,3260,821,3980,-6512,10745,6287,-2539,12232,262 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A5", 0, 0,
       { -5707,10308,2002,2662,1829,4139,-6265,11063,6033,-2659,11911,593 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A610", 0, 0,
       { 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A620", 0, 0,
       { 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A630", 0, 0,
       { 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A640", 0, 0,
       { 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A650 IS", 0, 0,
       { 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot A720 IS", 0, 0,
       { 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot D10", 127, 0,
       { 14052,-5229,-1156,-1325,9420,2252,-498,1957,4116 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G10", 0, 0,
       { 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G11", 0, 0,
       { 12177,-4817,-1069,-1612,9864,2049,-98,850,4471 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G12", 0, 0,
       { 13244,-5501,-1248,-1508,9858,1935,-270,1083,4366 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G15", 0, 0,
       { 7474,-2301,-567,-4056,11456,2975,-222,716,4181 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G16", 0, 0,
       { 8020,-2687,-682,-3704,11879,2052,-965,1921,5556 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G1 X Mark III", 0, 0,
       { 8532,-701,-1167,-4095,11879,2508,-797,2424,7010 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G1 X Mark II", 0, 0,
       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G1 X", 0, 0,
       { 7378,-1255,-1043,-4088,12251,2048,-876,1946,5805 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G1", 0, 0,
       { -5686,10300,2223,4725,-1157,4383,-6128,10783,6163,-2688,12093,604 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G2", 0, 0,
       { 9194,-2787,-1059,-8098,15657,2608,-2610,3064,7867 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G3 X", 0, 0,
       { 9701,-3857,-921,-3149,11537,1817,-786,1817,5147 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G3", 0, 0,
       { 9326,-2882,-1084,-7940,15447,2677,-2620,3090,7740 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G5 X Mark II",0, 0,
       { 11629, -5713, -914, -2706, 11090, 1842, -206, 1225, 5515 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G5 X",0, 0,
       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G5", 0, 0,
       { 9869,-2972,-942,-7314,15098,2369,-1898,2536,7282 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G6", 0, 0,
       { 9876,-3774,-871,-7613,14807,3071,-1448,1305,7485 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G7 X Mark III", 0, 0,
       { 11629, -5713, -914, -2706, 11090, 1842, -206, 1225, 5515 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G7 X Mark II", 0, 0,
       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G7 X", 0, 0,
       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G9 X Mark II", 0, 0,
       { 10056,-4131,-944,-2576,11143,1625,-238,1294,5179 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G9 X",0, 0,
       { 9602,-3823,-937,-2984,11495,1675,-407,1415,5049 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot G9", 0, 0,
       { 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S2 IS", 0, 0,
       { 5477,-1435,-992,-1868,6639,510,-58,792,2670 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S3 IS", 0, 0,
       { 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S30", 0, 0,
       { 10744,-3813,-1142,-7962,15966,2075,-2492,2805,7744 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S40", 0, 0,
       { 8606,-2573,-949,-8237,15489,2974,-2649,3076,9100 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S45", 0, 0, // +
       { 8251,-2410,-964,-8047,15430,2823,-2380,2824,8119 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S50", 0, 0,
       { 8979,-2658,-871,-7721,15500,2357,-1773,2366,6634 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S60", 0, 0,
       { 8794,-2482,-797,-7804,15403,2572,-1422,1996,7083 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S70", 0, 0,
       { 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S90", 0, 0,
       { 12374,-5016,-1049,-1677,9902,2078,-83,852,4683 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S95", 0, 0,
       { 13440,-5896,-1279,-1236,9598,1931,-180,1001,4651 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S120", 0, 0,
       { 6961,-1685,-695,-4625,12945,1836,-1114,2152,5518 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S110", 0, 0,
       { 8039,-2643,-654,-3783,11230,2930,-206,690,4194 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot S100", 0, 0,
       { 7968,-2565,-636,-2873,10697,2513,180,667,4211 } },
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SD300", 0, 0,
       { 6526,-1720,-1075,-1390,5945,602,-90,820,2380 } }, // CHDK
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX1 IS", 0, 0,
       { 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX20 IS", 0, 0,
       { 8275,-2904,-1260,-128,5305,505,51,481,2450 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX30 IS", 0, 0,
       { 13014,-4698,-1026,-2001,9615,2386,-164,1423,3759 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX40 HS", 0, 0,
       { 54480,-17404,-8039,-7505,44044,1136,-580,7158,11891 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX50 HS", 0, 0,
       { 12432,-4753,-1247,-2110,10691,1629,-412,1623,4926 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX60 HS", 0, 0,
       { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX70 HS", 0, 0,
       { 18285,-8907,-1951,-1845,10688,1323,364,1101,5139 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX110 IS", 0, 0,
       { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX120 IS", 0, 0,
       { 7286,-2242,-1047,41,4401,457,269,684,1864 } }, // CHDK
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX220 HS", 0, 0,
       { 13898,-5076,-1447,-1405,10109,1297,-244,1860,3687 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot SX710 HS", 0, 0,
       { 13161,-5451,-1344,-1989,10654,1531,-47,1271,4955 } },
 
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot Pro1", 0, 0,
       { 10062,-3522,-1000,-7643,15117,2730,-765,817,7322 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot Pro70", 34, 0,
       { -5106,10695,1576,3820,53,4566,-6497,10736,6701,-3336,11887,1394 } },
     { LIBRAW_CAMERAMAKER_Canon, "PowerShot Pro90", 0, 0,
       { -5912,10768,2288,4612,-989,4333,-6153,10897,5944,-2907,12288,624 } },
 
     { LIBRAW_CAMERAMAKER_Casio, "EX-F1", 0, 0,
       { 9084,-2016,-848,-6711,14351,2570,-1059,1725,6135 } },
     { LIBRAW_CAMERAMAKER_Casio, "EX-FH100", 0, 0,
       { 12771,-4179,-1558,-2149,10938,1375,-453,1751,4494 } },
     { LIBRAW_CAMERAMAKER_Casio, "EX-S20", 0, 0,
       { 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Casio, "EX-Z750", 0, 0,
       { 10819,-3873,-1099,-4903,13730,1175,-1755,3751,4632 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Casio, "EX-Z10", 128, 0xfff,
       { 9790,-3338,-603,-2321,10222,2099,-344,1273,4799 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_CINE, "650", 0, 0,
       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },
     { LIBRAW_CAMERAMAKER_CINE, "660", 0, 0,
       { 3390,480,-500,-800,3610,340,-550,2336,1192 } },
 	  { LIBRAW_CAMERAMAKER_CINE, "", 0, 0, /* empty camera name*/
       { 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },
 
     { LIBRAW_CAMERAMAKER_Contax, "N Digital", 0, 0xf1e,
       { 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },
 
     { LIBRAW_CAMERAMAKER_DXO, "ONE", 0, 0,
       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
 
     { LIBRAW_CAMERAMAKER_Epson, "R-D1", 0, 0, // same CMs: R-D1, R-D1s, R-D1x
       { 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "DBP for GX680", -128, 0x0fff,
       { 12741,-4916,-1420,-8510,16791,1715,-1767,2302,7771 } }, /* temp, copy from S2Pro */
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "E550", 0, 0,
       { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "E900", 0, 0,
       { 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F5", 0, 0, // F500EXR/F505EXR; F550EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F6", 0, 0, // F600EXR/F605EXR; F660EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F77", 0, 0xfe9, // F770EXR/F775EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F7", 0, 0, // same CMs: F700, F710EXR
       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F810", 0, 0,
       { 11044,-3888,-1120,-7248,15167,2208,-1531,2276,8069 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F8", 0, 0, // F800EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "F900EXR", 0, 0,
       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
 
-    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 100", 0, 0,
+    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 100", 0, 0, // same CMs: "GFX 100", "GFX 100S"/"GFX100S", "GFX 100 IR"
       { 16212,-8423,-1583,-4336,12583,1937,-195,726,6199 } },
-    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 50", 0, 0, // same CMs: "GFX 50S", "GFX 50R"
+    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 50", 0, 0,  // same CMs: "GFX 50S", "GFX 50R", "GFX 50S II"
       { 11756,-4754,-874,-3056,11045,2305,-381,1457,6006 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "HS10", 0, 0xf68,
       { 12440,-3954,-1183,-1123,9674,1708,-83,1614,4086 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "HS2", 0, 0, // HS20EXR/HS22EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "HS3", 0, 0, // HS30EXR/HS33EXR/HS35EXR
       { 13690,-5358,-1474,-3369,11600,1998,-132,1554,4395 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "HS50EXR", 0, 0,
       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "IS-1", 0, 0,
       { 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "IS Pro", 0, 0,
       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "S5000", 0, 0,
       { 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S5100", 0, 0,
       { 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S5200", 0, 0, // S5200/S5600
       { 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S6", 0, 0, // S6000fd/S6500fd
       { 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S7000", 0, 0,
       { 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S9000", 0, 0, // S9000/S9500
       { 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S9100", 0, 0, // S9100/S9600
       { 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "S100FS", -514, 0,
       { 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "S20Pro", 0, 0,
       { 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S20", -512, 0x3fff, // S200EXR/S205EXR
       { 11401,-4498,-1312,-5088,12751,2613,-838,1568,5941 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "SL1000", 0, 0,
       { 11705,-4262,-1107,-2282,10791,1709,-555,1713,4945 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "S1", 0, 0,
       { 12297,-4882,-1202,-2106,10691,1623,-88,1312,4790 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S2Pro", -128, 0,
       { 12741,-4916,-1420,-8510,16791,1715,-1767,2302,7771 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S3Pro", 0, 0,
       { 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "S5Pro", 0, 0,
       { 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "X100F", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X100S", 0, 0,
       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X100T", 0, 0,
       { 10592,-4262,-1008,-3514,11355,2465,-870,2025,6386 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X100V", 0, 0,
       { 13426,-6334,-1177,-4244,12136,2371,580,1303,5980 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X100", 0, 0,
       { 12161,-4457,-1069,-5034,12874,2400,-795,1724,6904 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "X10", 0, 0,
       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X20", 0, 0,
       { 11768,-4971,-1133,-4904,12927,2183,-480,1723,4605 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X30", 0, 0,
       { 12328,-5256,-1144,-4469,12927,1675,-87,1291,4351 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X70", 0, 0,
       { 10450,-4329,-878,-3217,11105,2421,-752,1758,6519 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "XF10", 0, 0,
       { 11673,-4760,-1041,-3988,12058,2166,-771,1417,5569 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "XF1", 0, 0,
       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "XQ", 0, 0,  // same CMs: XQ1, XQ2
       { 9252,-2704,-1064,-5893,14265,1717,-1101,2341,4349 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-Pro1", 0, 0,
       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-Pro2", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-Pro3", 0, 0,
       { 13426,-6334,-1177,-4244,12136,2371,580,1303,5980 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A10", 0, 0,
       { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A20", 0, 0,
       { 11540,-4999,-991,-2949,10963,2278,-382,1049,5605} },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A1", 0, 0,
       { 11086,-4555,-839,-3512,11310,2517,-815,1341,5940 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A2", 0, 0,
       { 10763,-4560,-917,-3346,11311,2322,-475,1135,5843 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A3", 0, 0,
       { 12407,-5222,-1086,-2971,11116,2120,-294,1029,5284 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A5", 0, 0,
       { 11673,-4760,-1041,-3988,12058,2166,-771,1417,5569 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-A7", 0, 0,
       { 15055,-7391,-1274,-4062,12071,2238,-610,1217,6147 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-E1", 0, 0,
       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-E2S", 0, 0,
       { 11562,-5118,-961,-3022,11007,2311,-525,1569,6097 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-E2", 0, 0,
       { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-E3", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
+    { LIBRAW_CAMERAMAKER_Fujifilm, "X-E4", 0, 0,
+      { 13426, -6334, -1177, -4244, 12136, 2371, -580, 1303, 5980 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-H1", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-M1", 0, 0,
       { 10413,-3996,-993,-3721,11640,2361,-733,1540,6011 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-S10", 0, 0,
       { 13426,-6334,-1177,-4244,12136,2371,-580,1303,5980 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-S1", 0, 0,
       { 13509,-6199,-1254,-4430,12733,1865,-331,1441,5022 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T100", 0, 0,
       { 11673,-4760,-1041,-3988,12058,2166,-771,1417,5569 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T1", 0, 0, /* same CMs: X-T1, "X-T1IR", "X-T1 IR", X-T10 */
       { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T200", 0, 0,
       { 15055,-7391,-1274,-4062,12071,2238,-610,1217,6147 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T2", 0, 0,  // same CMs: X-T2, X-T20
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T3", 0, 0,   // same CMs: X-T3, X-T30
       { 13426,-6334,-1177,-4244,12136,2371,580,1303,5980 } }, // v.2
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-T4", 0, 0,
       { 13426,-6334,-1177,-4244,12136,2371,580,1303,5980 } },
 
     { LIBRAW_CAMERAMAKER_GITUP, "G3DUO", 130, 62000,
        { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
 
     { LIBRAW_CAMERAMAKER_GITUP, "GIT2P", 4160, 0,
       { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
     { LIBRAW_CAMERAMAKER_GITUP, "GIT2", 3200, 0,
       { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
 
     { LIBRAW_CAMERAMAKER_GoPro, "HERO5 Black", 0, 0,
 	    { 10344,-4210,-620,-2315,10625,1948,93,1058,5541 } },
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "L1D-20c", 0, 0,
       {  7310, -2746,  -646, -2991, 10847,  2469,   163,   585,  6324}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "16-Uncoated-3FR", 0, 0,
       {  8519, -3260,  -280, -5081, 13459,  1738, -1449,  2960,  7809}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "16-Uncoated-FFF", 0, 0,
       {  8068, -2959,  -108, -5788, 13608,  2389, -1002,  2237,  8162}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "16-Uncoated", 0, 0,
-      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },
+      {  8519, -3260,  -280, -5081, 13459,  1738, -1449,  2960,  7809}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated-3FR", 0, 0,
       {  8523, -3257,  -280, -5078, 13458,  1743, -1449,  2961,  7809}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated-FFF", 0, 0,
       {  8068, -2959,  -108, -5788, 13608,  2389, -1002,  2237,  8162}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated", 0, 0,
-      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },
+      {  8519, -3260,  -280, -5081, 13459,  1738, -1449,  2960,  7809}},
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "31-Uncoated-FFF", 0, 0,
       {  5155, -1201,   200, -5841, 13197,  2950, -1101,  2317,  6988}},
     {LIBRAW_CAMERAMAKER_Hasselblad, "31-Uncoated", 0, 0,
       {  5458, -1448,   145, -4479, 12338,  2401, -1659,  3086,  6710}},
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "39-Uncoated-3FR", 0, 0,
       {  3904,  -100,   262, -4318, 12407,  2128, -1598,  3594,  6233}},
     {LIBRAW_CAMERAMAKER_Hasselblad, "39-Uncoated-FFF", 0, 0,
       {  4739,  -932,   295, -4829, 12220,  2952, -1027,  2341,  7083}},
     {LIBRAW_CAMERAMAKER_Hasselblad, "39-Uncoated", 0, 0,
       {  3894,  -110,   287, -4672, 12610,  2295, -2092,  4100,  6196}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "39-Coated-3FR", 0, 0,
       {  5427, -1147,   173, -3834, 12073,  1969, -1444,  3320,  5621}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "39-Coated-FFF", 0, 0,
       {  5323, -1233,   399, -4926, 12362,  2894,  -856,  2471,  5961}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "39-Coated", 0, 0,
-      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },
+      {  3857,   452,   -46, -6008, 14477,  1596, -2627,  4481,  5718}},
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated5-3FR", 0, 0,
       {  7014, -2067,  -540, -4821, 13016,  1980, -1663,  3089,  6940}},
     {LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated5-FFF", 0, 0,
       {  5963, -1357,  -172, -5439, 12762,  3007,  -964,  2222,  7172}},
     {LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated5", 0, 0,
       {  6159, -1402,  -177, -5439, 12762,  3007,  -955,  2200,  7104}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated-3FR", 0, 0,
       {  6550, -1681,  -399, -4626, 12598,  2257, -1807,  3354,  6486}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated-FFF", 0, 0,
       {  6041, -1375,  -174, -5439, 10000,  3007,  -930,  2145,  6923}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated", 0, 0,
-	    { 6159,-1402,-177,-5439,12762,3007,-955,2200,7104 } },
+	    {  6159, -1402,  -177, -5439, 12762,  3007,  -955,  2200,  7104}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated5-3FR", 0, 0,
       {  5707,  -693,  -382, -4285, 12669,  1773, -1615,  3519,  5410}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated5-FFF", 0, 0,
       {  5263,  -612,    39, -4950, 12426,  2843,  -935,  2423,  5941}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated5", 0, 0,
       {  5656,  -659,  -346, -3923, 12306,  1791, -1602,  3509,  5442}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated-3FR", 0, 0,
       {  5656,  -659,  -346, -3923, 12305,  1790, -1602,  3509,  5442}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated-FFF", 0, 0,
       {  5280,  -614,    39, -4950, 12426,  2843,  -939,  2434,  5968}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated", 0, 0,
-	    { 5656,-659,-346,-3923,12306,1791,-1602,3509,5442 } },
+	    {  5656,  -659,  -346, -3923, 12306, 1791,  -1602,  3509,  5442}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-15-Coated5-II-3FR", 0, 0,
       { 10887, -6152,  1034, -3564, 12412,  4224,    63,   626, 10123}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-15-Coated5-II-FFF", 0, 0,
       {  4932,  -835,   141, -4878, 11868,  3437, -1138,  1961,  7067}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-15-Coated5-II", 0, 0,
       {  8737, -4937,   830, -2860,  9961,  3390,    51,   502,  8124}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-15-Coated5", 0, 0,
 	    { 4932,-835,141,-4878,11868,3437,-1138,1961,7067 } },
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "60-Coated-3FR", 0, 0,
       {  9296,   336, -1088, -6442, 14323,  2289, -1433,  2942,  5756}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "60-Coated", 0, 0,
-	    { 9662,-684,-279,-4903,12293,2950,-344,1669,6024 } },
+	    {  9662,  -684,  -279, -4903, 12293,  2950,  -344,  1669,  6024}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "100-17-Coated5", 0, 0,
       {  5110, -1357,  -308, -5573, 12835,  3077, -1279,  2025,  7010}},
 
     { LIBRAW_CAMERAMAKER_HTC, "One A9", 64, 1023,
       { 101,-20,-2,-11,145,41,-24,1,56 } }, /* this is FM1 transposed */
 
     { LIBRAW_CAMERAMAKER_Imacon, "Ixpress", 0, 0,
       { 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Kodak, "NC2000", 0, 0, // AP Nikon
       { 13891,-6055,-803,-465,9919,642,2121,82,1291 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS315C", -8, 0,
       { 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS330C", -8, 0,
       { 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS420", 0, 0,
       { 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS46", 0, 0, // same CM as EOSDCS1 and DCS465 DB
       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS520C", -178, 0, // same CamID: DCS520C, "EOS D2000C"
       { 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS560C", -177, 0, // same CamID: DCS560C, "EOS D6000C"
       { 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS620C", -177, 0,
       { 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS620X", -176, 0,
       { 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS660C", -173, 0,
       { 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS720X", 0, 0,
       { 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS760C", 0, 0,
       { 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS Pro SLR", 0, 0,
       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS Pro 14nx", 0, 0,
       { 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
     { LIBRAW_CAMERAMAKER_Kodak, "DCS Pro 14", 0, 0, // same CamID: "DCS Pro 14N", "Photo Control Camerz ZDS 14"
       { 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },
     { LIBRAW_CAMERAMAKER_Kodak, "EOSDCS1", 0, 0,
       { 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
     { LIBRAW_CAMERAMAKER_Kodak, "EOSDCS3", 0, 0,
       { 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },
     { LIBRAW_CAMERAMAKER_Kodak, "ProBack645", 0, 0,
       { 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },
     { LIBRAW_CAMERAMAKER_Kodak, "ProBack", 0, 0,
       { 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },
 
     {LIBRAW_CAMERAMAKER_Kodak, "PIXPRO AZ901", 0, 0,	// dng
       { 21875, -8006, -2558,   634,  8194,  1104,  1535,   951,  6969}},
     { LIBRAW_CAMERAMAKER_Kodak, "P712", 0, 3963,
       { 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },
     { LIBRAW_CAMERAMAKER_Kodak, "P850", 0, 3964,
       { 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },
     { LIBRAW_CAMERAMAKER_Kodak, "P880", 0, 3963,
       { 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },
     { LIBRAW_CAMERAMAKER_Kodak, "Z980", 0, 0,
       { 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },
     { LIBRAW_CAMERAMAKER_Kodak, "Z981", 0, 0,
       { 12729,-4717,-1188,-1367,9187,2582,274,860,4411 } },
     { LIBRAW_CAMERAMAKER_Kodak, "Z990", 0, 0xfed,
       { 11749,-4048,-1309,-1867,10572,1489,-138,1449,4522 } },
     { LIBRAW_CAMERAMAKER_Kodak, "Z1015", 0, 0xef1,
       { 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },
 
     {LIBRAW_CAMERAMAKER_Leaf, "AFi 54S", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "AFi 65S", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "AFi 75S", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 17", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 22", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 54S", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 65S", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 65", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 75S", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "Aptus 75", 0, 0,
       {  7914,  1414, -1190, -8776, 16582,  2280, -2811,  4605,  5562}},
     {LIBRAW_CAMERAMAKER_Leaf, "C-Most", 0, 0,
       {  3952,  2188,   449, -6701, 14584,  2275, -4536,  7349,  6535}},
     {LIBRAW_CAMERAMAKER_Leaf, "Credo 40", 0, 0,
       {  8035,   435,  -962, -6001, 13872,  2320, -1159,  3065,  5434}},
     {LIBRAW_CAMERAMAKER_Leaf, "Credo 50", 0, 0, // emb
       { 10325,   845,  -604, -4113, 13385,   481, -1791,  4163,  6924}},
     {LIBRAW_CAMERAMAKER_Leaf, "Credo 60", 0, 0,
       {  8035,   435,  -962, -6001, 13872,  2320, -1159,  3065,  5434}},
     {LIBRAW_CAMERAMAKER_Leaf, "Credo 80", 0, 0,
       {  6294,   686,  -712, -5435, 13417,  2211, -1006,  2435,  5042}},
     {LIBRAW_CAMERAMAKER_Leaf, "Valeo 11", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Valeo 17", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Valeo 22", 0, 0,
       {  8236,  1746, -1313, -8251, 15953,  2428, -3672,  5786,  5771}},
     {LIBRAW_CAMERAMAKER_Leaf, "Valeo 6", 0, 0,
       {  3952,  2188,   449, -6701, 14584,  2275, -4536,  7349,  6535}},
 
 //     { LIBRAW_CAMERAMAKER_Leaf, "AFi-II 6", 0, 0,
     { LIBRAW_CAMERAMAKER_Leaf, "AFi-II 7", 0, 0,
       { 7691,-108,-339,-6185,13627,2833,-2046,3899,5952 } },
     { LIBRAW_CAMERAMAKER_Leaf, "AFi-II 10", 0, 0,
       { 6719,1147,-148,-6929,14061,3176,-1781,3343,5424 } },
 
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 5", 0, 0,
       { 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 6", 0, 0,
       { 7989,-113,-352,-6185,13627,2833,-2028,3866,5901 } },
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 7", 0, 0,
       { 8209,-116,-362,-6185,13627,2833,-1962,3740,5709 } },
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 8", 0, 0,
       { 7361,1257,-163,-6929,14061,3176,-1839,3454,5603 } },
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 10R", 0, 0,
       { 7167,1224,-158,-6929,14061,3176,-1826,3429,5562 } },
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 10", 0, 0,
       { 7527,1285,-166,-6929,14061,3176,-1995,3747,6077 } },
 //     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 12R", 0, 0,
     { LIBRAW_CAMERAMAKER_Leaf, "Aptus-II 12", 0, 0,
       { 7361,1257,-163,-6929,14061,3176,-1695,3182,5162 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "CL", 0, 0,
       { 7743,-2896,-921,-4211,12271,2169,-697,1562,5491 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "M8", 0, 0,
       { 7675,-2196,-305,-5860,14119,1856,-2425,4006,6578 } },
     { LIBRAW_CAMERAMAKER_Leica, "M9", 0, 0,
       { 6687,-1751,-291,-3556,11373,2492,-548,2204,7146 } },
     { LIBRAW_CAMERAMAKER_Leica, "M10", 0, 0, // same CMs: M10, M10-D, M10-P
       { 9090,-3342,-740,-4006,13456,493,-569,2266,6871 } },
     { LIBRAW_CAMERAMAKER_Leica, "M (Typ 2", 0, 0, // same CMs: "M (Typ 240)", "M (Typ 262)", "M-D (Typ 262)"
       { 7199,-2140,-712,-4005,13327,649,-810,2521,6673 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "Q (Typ 116)", 0, 0,
       { 10068,-4043,-1068,-5319,14268,1044,-765,1701,6522 } },
     { LIBRAW_CAMERAMAKER_Leica, "Q2", 0, 0,
       { 12312,-5440,-1307,-6408,15499,824,-1075,1677,7220 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "SL (Typ 601)", 0, 0,
       { 11865,-4523,-1441,-5423,14458,935,-1587,2687,4830 } },
     { LIBRAW_CAMERAMAKER_Leica, "S (Typ 007)", 0, 0,
       { 6063,-2234,-231,-5210,13787,1500,-1043,2866,6997 } },
     { LIBRAW_CAMERAMAKER_Leica, "S2", 0, 0,
       { 5627,-721,-447,-4423,12456,2192,-1048,2948,7379 } },
     { LIBRAW_CAMERAMAKER_Leica, "S3", 0, 0,
 //      { 5147,-1464,-318,-5374,13263,2325,-1425,2918,6450 } },
       { 5092,-1630,-470,-6313,14297,2170,-1603,3135,5982 } },
     {LIBRAW_CAMERAMAKER_Leica, "S", 0, 0, // same CMs: "S-E (Typ 006)", "S (Typ 006)"
       { 5749,-1072,-382,-4274,12432,2048,-1166,3104,7105 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "TL2", 0, 0,
       { 6375,-2062,-732,-4878,12838,2262,-877,1705,6204 } },
     { LIBRAW_CAMERAMAKER_Leica, "T", 0, 0, // same CMs: TL, "T (Typ 701)"
       { 6295,-1679,-475,-5586,13046,2837,-1410,1889,7075 } },
 
     { LIBRAW_CAMERAMAKER_Leica, "X2", 0, 0,
       { 8336,-2853,-699,-4425,11989,2760,-954,1625,6396 } },
     { LIBRAW_CAMERAMAKER_Leica, "X1", 0, 0,
       { 9055,-2611,-666,-4906,12652,2519,-555,1384,7417 } },
     { LIBRAW_CAMERAMAKER_Leica, "X", 0, 0, /*  same CMs: "X (Typ 113)", "X-U (Typ 113)", XV, "X Vario (Typ 107)" */
       { 9062,-3198,-828,-4065,11772,2603,-761,1468,6458 } },
 
     { LIBRAW_CAMERAMAKER_Mamiya,"ZD", 0, 0,
       { 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },
 
     { LIBRAW_CAMERAMAKER_Micron, "2010", 110, 0,
       { 16695,-3761,-2151,155,9682,163,3433,951,4904 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE 5", 0, 0xf7d,
       { 9117,-3063,-973,-7949,15763,2306,-2752,3136,8093 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE 7Hi", 0, 0xf7d,
       { 11555,-4064,-1256,-7903,15633,2409,-2811,3320,7358 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE 7i", 0, 0xf7d,
       { 11050,-3791,-1199,-7875,15585,2434,-2797,3359,7560 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE 7", 0, 0xf7d,
       { 9258,-2879,-1008,-8076,15847,2351,-2806,3280,7821 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE A1", 0, 0xf8b,
       { 9274,-2548,-1167,-8220,16324,1943,-2273,2721,8340 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE A200", 0, 0,
       { 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE A2", 0, 0xf8f,
       { 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DiMAGE Z2", 0, 0,
       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Minolta, "DG-5D", 0, 0xffb, // same CamID: "ALPHA 5D", "DYNAX 5D", "MAXXUM 5D", "Alpha Sweet Digital"
       { 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },
     { LIBRAW_CAMERAMAKER_Minolta, "DG-7D", 0, 0xffb, // same CamID: "ALPHA 7D", "DYNAX 7D", "MAXXUM 7D"
       { 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },
 
     { LIBRAW_CAMERAMAKER_Motorola, "PIXL", 0, 0,
       { 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Nikon, "1 AW1", 0, 0,
       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 J3", 0, 0,
       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 J4", 0, 0,
       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 J5", 0, 0,
       { 7520,-2518,-645,-3844,12102,1945,-913,2249,6835 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 S2", -200, 0,
       { 6612,-1342,-618,-3338,11055,2623,-174,1792,5075 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 V2", 0, 0,
       { 6588,-1305,-693,-3277,10987,2634,-355,2016,5106 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 V3", -200, 0,
       { 5958,-1559,-571,-4021,11453,2939,-634,1548,5087 } },
     { LIBRAW_CAMERAMAKER_Nikon, "1 ", 0, 0,      /* same CMs: "1 J1", "1 J2", "1 S1", "1 V1" */
       { 8994,-2667,-865,-4594,12324,2552,-699,1786,6260 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 2100", 0, 0, // a.k.a. E2100
       { 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711 } }, /* DJC, copied from Z2, new white balance */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 2500", 0, 0, // a.k.a. E2500, possibly same CM as for E5000
       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 3200", 0, 0, // a.k.a. E3200
       { 9846,-2085,-1019,-3278,11109,2170,-774,2134,5745 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 4300", 0, 0, // a.k.a. E4300
       { 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } }, /* DJC, copied from Minolta DiMAGE Z2 */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 4500", 0, 0, // a.k.a. E4500, possibly same CM as for E5000
       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 5000", 0, 0, // a.k.a. E5000
       { -6678,12805,2248,5725,-499,3375,-5903,10713,6034,-270,9976,134 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 5400", 0, 0, // a.k.a. E5400
       { 9349,-2988,-1001,-7918,15766,2266,-2097,2680,6839 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 5700", 0, 0, // a.k.a. E5700
       { -6475,12496,2428,5409,-16,3180,-5965,10912,5866,-177,9918,248 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 8400", 0, 0, // a.k.a. E8400
       { 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 8700", 0, 0, // a.k.a. E8700
       { 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 8800", 0, 0, // a.k.a. E8800
       { 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 700", 0, 0x3dd, // a.k.a. E700
       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 800", 0, 0x3dd, // a.k.a. E800
       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 950", 0, 0x3dd, // a.k.a. E950
       { -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } }, /* DJC */
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX 995", 0, 0,     // a.k.a. E995
       { -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } }, /* DJC, copied from E5000 */
 
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX A1000", 0, 0,
       { 10601,-3487,-1127,-2931,11443,1676,-587,1740,5278 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX B700", 0, 0,
       { 14387,-6014,-1299,-1357,9975,1616,467,1047,4744 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX A", 0, 0,
       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P1000", 0, 0,
       { 14294,-6116,-1333,-1628,10219,1637,-14,1158,5022 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P6000", 0, 0,
       { 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P7000", 0, 0,
       { 11432,-3679,-1111,-3169,11239,2202,-791,1380,4455 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P7100", 0, 0,
       { 11053,-4269,-1024,-1976,10182,2088,-526,1263,4469 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P7700", -3200, 0, // same CamID: "COOLPIX P7700", "COOLPIX Deneb"
       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P7800", -3200, 0, // same CamID: "COOLPIX P7800", "COOLPIX Kalon"
       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P330", -200, 0,
       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
     { LIBRAW_CAMERAMAKER_Nikon, "COOLPIX P340", -200, 0,
       { 10321,-3920,-931,-2750,11146,1824,-442,1545,5539 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Coolpix P950", 0, 0,
       { 13307, -5641, -1290, -2048, 10581,  1689,   -64,  1222,  5176}},
 
     { LIBRAW_CAMERAMAKER_Nikon, "D3000", 0, 0,
       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3100", 0, 0,
       { 7911,-2167,-813,-5327,13150,2408,-1288,2483,7968 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3200", 0, 0xfb9,
       { 7013,-1408,-635,-5268,12902,2640,-1470,2801,7379 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3300", 0, 0,
       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3400", 0, 0,
       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3500", 0, 0,
       { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5000", 0, 0xf00,
       { 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5100", 0, 0x3de6,
       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5200", 0, 0,
       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5300", 0, 0,
       { 6988,-1384,-714,-5631,13410,2447,-1485,2204,7318 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5500", 0, 0,
       { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5600", 0, 0,
       { 8821,-2938,-785,-4178,12142,2287,-824,1651,6860 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D7000", 0, 0,
       { 8198,-2239,-724,-4871,12389,2798,-1043,2050,7181 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D7100", 0, 0,
       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D7200", 0, 0,
       { 8322,-3112,-1047,-6367,14342,2179,-988,1638,6394 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D7500", 0, 0,
       { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "D100", 0, 0,
       { 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D200", 0, 0xfbc,
       { 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D300", 0, 0,    // same CMs: D300, D300s
       { 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D500", 0, 0,
       { 8813,-3210,-1036,-4703,12868,2021,-1054,1940,6129 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D600", 0, 0x3e07,
       { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D610",0, 0,
       { 8178,-2245,-609,-4857,12394,2776,-1207,2086,7298 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D700", 0, 0,
       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D750", -600, 0,
       { 9020,-2890,-715,-4535,12436,2348,-934,1919,7086 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D780", -600, 0,
       { 9943,-3269,-839,-5323,13269,2259,-1198,2083,7557 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D800", 0, 0,    // same CMs: D800, D800E
       { 7866,-2108,-555,-4869,12483,2681,-1176,2069,7501 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D810A", 0, 0,
       { 11973,-5685,-888,-1965,10326,1901,-115,1123,7169 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D810", 0, 0,
       { 9369,-3195,-791,-4488,12430,2301,-893,1796,6872 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D850", 0, 0,
       { 10405,-3755,-1270,-5461,13787,1793,-1040,2015,6785 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "D40X", 0, 0,
       { 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D40", 0, 0,
       { 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D50", 0, 0,
       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D60", 0, 0,
       { 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D70", 0, 0,     // same CMs: D70, D70s
       { 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D80", 0, 0,
       { 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D90", 0, 0xf00,
       { 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "D1H", 0, 0,
       { 7659,-2238,-935,-8942,16969,2004,-2701,3051,8690 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D1X", 0, 0,
       { 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D1", 0, 0,
 //      { 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } }, /* multiplied by 2.218750, 1.0, 1.148438 */
       { 7637,-2199,-974,-9109,17099,2043,-2822,3306,8372 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D2H", 0, 0,     // same CMs: D2H, D2Hs
       { 5733,-911,-629,-7967,15987,2055,-3050,4013,7048 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D2X", 0, 0,     // same CMs: D2X, D2Xs
       { 10231,-2768,-1254,-8302,15900,2551,-797,681,7148 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3S", 0, 0,
       { 8828,-2406,-694,-4874,12603,2541,-660,1509,7587 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3X", 0, 0,
       { 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D3", 0, 0,
       { 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D4", 0, 0,      // same CMs: D4, D4S (and Df)
       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D5", 0, 0,
       { 9200,-3522,-992,-5755,13803,2117,-753,1486,6338 } },
     { LIBRAW_CAMERAMAKER_Nikon, "D6", 0, 0,
       { 9028,-3423,-1035,-6321,14265,2217,-1013,1683,6928 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Df", 0, 0,
       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "Z 50", 0, 0,
-       { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
+      { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Z 5", 0, 0,
       { 8695,-2558,-648,-5015,12711,2575,-1279,2215,7514 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Z 6", 0, 0,
       { 9943,-3269,-839,-5323,13269,2259,-1198,2083,7557 } },  // 'Z 6'(v.2), 'Z 6_2'
     { LIBRAW_CAMERAMAKER_Nikon, "Z 7", 0, 0,
       { 13705,-6004,-1400,-5464,13568,2062,-940,1706,7618 } }, // 'Z 7'(v.2), 'Z 7_2'
+    { LIBRAW_CAMERAMAKER_Nikon, "Z fc", 0, 0,
+      { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "AIR A01", 0, 0xfe1,
       { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "C-5050Z", 0, 0,
       { 10633,-3234,-1285,-7460,15570,1967,-1917,2510,6299 } },
     { LIBRAW_CAMERAMAKER_Olympus, "C-5060WZ", 0, 0,
       { 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },
     { LIBRAW_CAMERAMAKER_Olympus, "C-7070WZ", 0, 0,
       { 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },
     { LIBRAW_CAMERAMAKER_Olympus, "C-7000Z", 0, 0,
       { 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },
     { LIBRAW_CAMERAMAKER_Olympus, "C-8080WZ", 0, 0,
       { 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-300", 0, 0,
       { 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-330", 0, 0,
       { 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-400", 0, 0,
       { 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-410", 0, 0xf6a,
       { 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-420", 0, 0xfd7,
       { 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-450", 0, 0xfd2,
       { 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-500", 0, 0,
       { 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-510", 0, 0xf6a,
       { 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-520", 0, 0xfd2,
       { 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-600", 0, 0xfaf,
       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-620", 0, 0xfaf,
       { 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-10", 0, 0x3ff,
       { 12970,-4703,-1433,-7466,15843,1644,-2191,2451,6668 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-20", 0, 0x3ff,  // model is "E-20,E-20N,E-20P"
       { 13414,-4950,-1517,-7166,15293,1960,-2325,2664,7212 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-30", 0, 0xfbc,
       { 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-1", 0, 0,
       { 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-3", 0, 0xf99,
       { 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-5", 0, 0xeec,
       { 11200,-3783,-1325,-4576,12593,2206,-695,1742,7504 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-P1", 0, 0xffd,
       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-P2", 0, 0xffd,
       { 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-P3", 0, 0,
       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-P5", 0, 0,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
+    { LIBRAW_CAMERAMAKER_Olympus, "E-P7", 0, 0,
+      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL10", 0, 0,
       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL1s", 0, 0,
       { 11409,-3872,-1393,-4572,12757,2003,-709,1810,7415 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL1", 0, 0,
       { 11408,-4289,-1215,-4286,12385,2118,-387,1467,7787 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL2", 0, 0xcf3,
       { 15030,-5552,-1806,-3987,12387,1767,-592,1670,7023 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL3", 0, 0,
       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL5", 0, 0xfcb,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL6", 0, 0,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL7", 0, 0,
       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL8", 0, 0,
       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL9", 0, 0,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-PM1", 0, 0,
       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-PM2", 0, 0,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-M10 Mark IV", 0, 0,
       { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M10", 0, 0,	  // Same CMs: E-M10, E-M10 Mark II, E-M10 Mark III; "CLAUSS piX 5oo"
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M1X", 0, 0,
       { 11896,-5110,-1076,-3181,11378,2048,-519,1224,5166 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-M1 Mark III", 0, 0,
       { 11896,-5110,-1076,-3181,11378,2048,-519,1224,5166 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M1 Mark II", 0, 0,
       { 9383,-3170,-763,-2457,10702,2020,-384,1236,5552 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M1", 0, 0,
       { 7687,-1984,-606,-4327,11928,2721,-1381,2339,6452 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-M5 Mark III", 0, 0,
       { 11896,-5110,-1076,-3181,11378,2048,-519,1224,5166 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M5 Mark II", 0, 0,
       { 9422,-3258,-711,-2655,10898,2015,-512,1354,5512 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-M5", 0, 0xfe1,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "PEN-F",0, 0,
       { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "SH-2", 0, 0, // same CamID: SH-2, SH-3
      { 10156,-3425,-1077,-2611,11177,1624,-385,1592,5080 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "SP-350", 0, 0,
       { 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-3", 0, 0,	// Same CMs: SP310, SP320
       { 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-500UZ", 0, 0xfff,
       { 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-510UZ", 0, 0xffe,
       { 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-550UZ", 0, 0xffe,
       { 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-560UZ", 0, 0xff9,
       { 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-565UZ", 0, 0,
       { 11856,-4469,-1159,-4814,12368,2756,-993,1779,5589 } },
     { LIBRAW_CAMERAMAKER_Olympus, "SP-570UZ", 0, 0,
       { 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "STYLUS 1",0, 0,	// Olympus "STYLUS 1 and STYLUS 1s have the same CamID, cameras are slightly different
       { 8360,-2420,-880,-3928,12353,1739,-1381,2416,5173 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "TG-4", 0, 0,
      { 11426,-4159,-1126,-2066,10678,1593,-120,1327,4998 } },
     { LIBRAW_CAMERAMAKER_Olympus, "TG-", 0, 0, // same CMs: TG-5, TG-6
      { 10899,-3833,-1082,-2112,10736,1575,-267,1452,5269 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "XZ-10", 0, 0,
       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
     { LIBRAW_CAMERAMAKER_Olympus, "XZ-1", 0, 0,
       { 10901,-4095,-1074,-1141,9208,2293,-62,1417,5158 } },
     { LIBRAW_CAMERAMAKER_Olympus, "XZ-2", 0, 0,
       { 9777,-3483,-925,-2886,11297,1800,-602,1663,5134 } },
 
 	{ LIBRAW_CAMERAMAKER_OmniVison, "", 16, 0x3ff,
       { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Pentax, "*istDL2", 0, 0,
       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
     { LIBRAW_CAMERAMAKER_Pentax, "*istDL", 0, 0,
       { 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },
     { LIBRAW_CAMERAMAKER_Pentax, "*istDS2", 0, 0,
       { 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
     { LIBRAW_CAMERAMAKER_Pentax, "*istDS", 0, 0,
       { 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },
     { LIBRAW_CAMERAMAKER_Pentax, "*istD", 0, 0,
       { 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },
 
     { LIBRAW_CAMERAMAKER_Pentax, "K-01", 0, 0,
       { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K10D", 0, 0,
       { 9679,-2965,-811,-8622,16514,2182,-975,883,9793 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K1", 0, 0, // same CMs: K100D, "K100D Super", K110D
       { 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K20D", 0, 0,
       { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K200D", 0, 0,
       { 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-m", 0, 0,
       { 9730,-2989,-970,-8527,16258,2381,-1060,970,8362 } },
     { LIBRAW_CAMERAMAKER_Pentax, "KP", 0, 0,
       { 7825,-2160,-1403,-4841,13555,1349,-1559,2449,5814 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-x", 0, 0,
       { 8843,-2837,-625,-5025,12644,2668,-411,1234,7410 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-r", 0, 0,
       { 9895,-3077,-850,-5304,13035,2521,-883,1768,6936 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-1", 0, 0, // same CMs: K-1, "K-1 Mark II"
       { 8596,-2981,-639,-4202,12046,2431,-685,1424,6122 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-30", 0, 0,
       { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },
+    { LIBRAW_CAMERAMAKER_Pentax, "K-3 Mark III", 0, 0,
+      {  9251, -3817, -1069, -4627, 12667,  2175,  -798,  1660,  5633 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-3", 0, 0, // same CMs: K-3, "K-3 II"
       { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-500", 0, 0,
       { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-50", 0, 0,
       { 8109,-2740,-608,-4593,12175,2731,-1006,1515,6545 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-5 II", 0, 0, // same CMs: "K-5 II" and "K-5 IIs"
       { 8170,-2725,-639,-4440,12017,2744,-771,1465,6599 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-5", 0, 0,
       { 8713,-2833,-743,-4342,11900,2772,-722,1543,6247 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-70", 0, 0,
       { 8766,-3149,-747,-3976,11943,2292,-517,1259,5552 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-7", 0, 0,
       { 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },
     { LIBRAW_CAMERAMAKER_Pentax, "KP", 0, 0,
       { 8617,-3228,-1034,-4674,12821,2044,-803,1577,5728 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-S1", 0, 0,
       { 8512,-3211,-787,-4167,11966,2487,-638,1288,6054 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-S2", 0, 0,
       { 8662,-3280,-798,-3928,11771,2444,-586,1232,6054 } },
 
     { LIBRAW_CAMERAMAKER_Pentax, "Q-S1", 0, 0,
       { 12995,-5593,-1107,-1879,10139,2027,-64,1233,4919 } },
     { LIBRAW_CAMERAMAKER_Pentax, "Q7", 0, 0,
       { 10901,-3938,-1025,-2743,11210,1738,-823,1805,5344 } },
     { LIBRAW_CAMERAMAKER_Pentax, "Q10", 0, 0,
       { 11562,-4183,-1172,-2357,10919,1641,-582,1726,5112 } },
     { LIBRAW_CAMERAMAKER_Pentax, "Q", 0, 0,
       { 11731,-4169,-1267,-2015,10727,1473,-217,1492,4870 } },
 
     { LIBRAW_CAMERAMAKER_Pentax, "MX-1", 0, 0,
       { 9296,-3146,-888,-2860,11287,1783,-618,1698,5151 } },
 
     { LIBRAW_CAMERAMAKER_Pentax, "645D", 0, 0x3e00,
       { 10646,-3593,-1158,-3329,11699,1831,-667,2874,6287 } },
     { LIBRAW_CAMERAMAKER_Pentax, "645Z", 0, 0,
       { 9519,-3591,-664,-4074,11725,2671,-624,1501,6653 } },
 
 
     {LIBRAW_CAMERAMAKER_Panasonic, "DC-S1R", 0, 0,
       { 11822,-5321,-1249,-5958,15114,766,-614,1264,7043 } },
     {LIBRAW_CAMERAMAKER_Panasonic, "DC-S1H", 0, 0,
       { 9397,-3719,-805,-5425,13326,2309,-972,1715,6034 } },
     {LIBRAW_CAMERAMAKER_Panasonic, "DC-S1", 0, 0,
       { 9744,-3905,-779,-4899,12807,2324,-798,1630,5827 } },
     {LIBRAW_CAMERAMAKER_Panasonic, "DC-S5", 0, 0,
       { 9744,-3905,-779,-4899,12807,2324,-798,1630,5827 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-CM1", -15, 0, // same CMs: DMC-CM1, DMC-CM10
       { 8770,-3194,-820,-2871,11281,1803,-513,1552,4434 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-FZ1000M2", -15, 0,
       { 9803,-4185,-992,-4066,12578,1628,-838,1824,5288 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ1000", -15, 0,
       { 7830,-2696,-763,-3325,11667,1866,-641,1712,4824 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ2500", -15, 0,
       { 7386,-2443,-743,-3437,11864,1757,-608,1660,4766 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ100", -15, 0xfff,
       { 16197,-6146,-1761,-2393,10765,1869,366,2238,5248 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ150", -15, 0xfff,
       { 11904,-4541,-1189,-2355,10899,1662,-296,1586,4289 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ200", -15, 0xfff,
       { 8112,-2563,-740,-3730,11784,2197,-941,2075,4933 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ300", -15, 0xfff,
       { 8378,-2798,-769,-3068,11410,1877,-538,1792,4623 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ18", 0, 0,
       { 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ28", -15, 0xf96,
       { 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ30", 0, 0xf94,
       { 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ35", -15, 0,
       { 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ40", -15, 0,
       { 13639,-5535,-1371,-1698,9633,2430,316,1152,4108 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ50", 0, 0,
       { 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ70", -15, 0,
       { 11532,-4324,-1066,-2375,10847,1749,-564,1699,4351 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-FZ80", -15, 0,
       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FZ8", 0, 0xf7f,
       { 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },
 
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-L10", -15, 0xf96,
       { 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-L1", 0, 0xf7f,
       { 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LC1", 0, 0,
       { 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LF1", -15, 0,
       { 9379,-3267,-816,-3227,11560,1881,-926,1928,5340 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-LX100M2", -15, 0,
       { 8585,-3127,-833,-4005,12250,1953,-650,1494,4862 } }, // v.2
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX100", -15, 0,
       { 8844,-3538,-768,-3709,11762,2200,-698,1792,5220 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX1", 0, 0xf7f,
       { 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX2", 0, 0,
       { 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX3", -15, 0,
       { 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX5", -15, 0,
       { 10909,-4295,-948,-1333,9306,2399,22,1738,4582 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX7", -15, 0,
       { 10148,-3743,-991,-2837,11366,1659,-701,1893,4899 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-LX9", -15, 0,
       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-FX150", -15, 0xfff,
       { 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-G99", -15, 0,
       { 9657,-3963,-748,-3361,11378,2258,-568,1415,5158 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-G100", -15, 0,
       { 8370,-2869,-710,-3389,11372,2298,-640,1599,4887 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G10", 0, 0,
       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G1", -15, 0xf94,
       { 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G2", -15, 0xf3c,
       { 10113,-3400,-1114,-4765,12683,2317,-377,1437,6710 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G3", -15, 0xfff,
       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G5", -15, 0xfff,
       { 7798,-2562,-740,-3879,11584,2613,-1055,2248,5434 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G6", -15, 0xfff,
       { 8294,-2891,-651,-3869,11590,2595,-1183,2267,5352 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G7", -15, 0xfff,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-G8", -15, 0xfff,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-G9", -15, 0,
       { 7685,-2375,-634,-3687,11700,2249,-748,1546,5111 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GH1", -15, 0xf92,
       { 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GH2", -15, 0xf95,
       { 7780,-2410,-806,-3913,11724,2484,-1018,2390,5298 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GH3", -15, 0,
       { 6559,-1752,-491,-3672,11407,2586,-962,1875,5130 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GH4", -15, 0,
       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5s", -15, 0,
       { 6929,-2355,-708,-4192,12534,1828,-1097,1989,5195 } },
+    { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5M2", 0, 0,
+      {  9300, -3659,  -755, -2981, 10988,  2287,  -190,  1077,  5016 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5", -15, 0,
       { 7641,-2336,-605,-3218,11299,2187,-485,1338,5121 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GM1", -15, 0,
       { 6770,-1895,-744,-5232,13145,2303,-1664,2691,5703 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GM5", -15, 0,
       { 8238,-3244,-679,-3921,11814,2384,-836,2022,5852 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GF10", -15, 0,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF1", -15, 0xf92,
       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF2", -15, 0xfff,
       { 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF3", -15, 0xfff,
       { 9051,-2468,-1204,-5212,13276,2121,-1197,2510,6890 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF5", -15, 0xfff,
       { 8228,-2945,-660,-3938,11792,2430,-1094,2278,5793 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF6", -15, 0,
       { 8130,-2801,-946,-3520,11289,2552,-1314,2511,5791 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF7", -15, 0,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GF8", -15, 0,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GF9", -15, 0,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GX85", -15, 0,
       { 7771,-3020,-629,-4029,11950,2345,-821,1977,6119 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GX1", -15, 0,
       { 6763,-1919,-863,-3868,11515,2684,-1216,2387,5879 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GX7", -15,0,
       { 7610,-2780,-576,-4614,12195,2733,-1375,2393,6490 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-GX8", -15,0,
       { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GX9", -15, 0,
       { 7564,-2263,-606,-3148,11239,2177,-540,1435,4853 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-ZS100", -15, 0,
       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-ZS200", -15, 0,
       { 7790,-2736,-755,-3452,11870,1769,-628,1647,4898 } },
 
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-ZS40", -15, 0,
       { 8607,-2822,-808,-3755,11930,2049,-820,2060,5224 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-ZS50", -15, 0,
       { 8802,-3135,-789,-3151,11468,1904,-550,1745,4810 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DMC-ZS60", -15, 0,
       { 8550,-2908,-842,-3195,11529,1881,-338,1603,4631 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-ZS70", -15, 0,
       { 9052,-3117,-883,-3045,11346,1927,-205,1520,4730 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-ZS80", -15, 0,
       { 12194,-5340,-1329,-3035,11394,1858,-50,1418,5219 } },
 
     { LIBRAW_CAMERAMAKER_PhaseOne, "H20", 0, 0,
       { 3906,1422,-467,-9953,18472,1365,-3307,4496,6406 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "H25", 0, 0,
       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ4 150MP", 0, 0,
       {  6644, -2257,  -804, -6459, 14562,  2019, -1221,  1876,  6411}},
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ140", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ150", 0, 0,
       {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* temp */ /* emb */
 //      { 3984,0,0,0,10000,0,0,0,7666 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ160", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ180", 0, 0,
       { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },
 
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ250",0, 0,
 //    {3984,0,0,0,10000,0,0,0,7666}},
       {10325,845,-604,-4113,13385,481,-1791,4163,6924}}, /* emb */
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ260", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ280", 0, 0,
       { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },
 
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ3 100MP", 0, 0,
 //    {2423,0,0,0,9901,0,0,0,7989}},
       { 10999,354,-742,-4590,13342,937,-1060,2166,8120} }, /* emb */
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ3 50MP", 0, 0,
 //      { 3984,0,0,0,10000,0,0,0,7666 } },
       {10058,1079,-587,-4135,12903,944,-916,2726,7480}}, /* emb */
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ3 60MP", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "IQ3 80MP", 0, 0,
       { 6294,686,-712,-5435,13417,2211,-1006,2435,5042 } },
 
     { LIBRAW_CAMERAMAKER_PhaseOne, "P21", 0, 0,
       { 6516,-2050,-507,-8217,16703,1479,-3492,4741,8489 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "P30", 0, 0,
       { 4516,-244,-36,-7020,14976,2174,-3206,4670,7087 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "P40", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "P45", 0, 0,
       { 5053,-24,-117,-5685,14077,1703,-2619,4491,5850 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "P65", 0, 0,
       { 8035,435,-962,-6001,13872,2320,-1159,3065,5434 } },
     { LIBRAW_CAMERAMAKER_PhaseOne, "P2", 0, 0,
       { 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
 
     { LIBRAW_CAMERAMAKER_Photron, "BC2-HD", 0, 0,
       { 14603,-4122,-528,-1810,9794,2017,-297,2763,5936 } }, /* DJC */
 
 	  { LIBRAW_CAMERAMAKER_Polaroid, "x530", 0, 0,
       { 13458,-2556,-510,-5444,15081,205,0,0,12120 } },
 
 	  { LIBRAW_CAMERAMAKER_RED, "One", 704, 0xffff,
       { 21014,-7891,-2613,-3056,12201,856,-2203,5125,8042 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Ricoh, "S10 24-72mm F2.5-4.4 VC", 0, 0,
       { 10531,-4043,-878,-2038,10270,2052,-107,895,4577 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR A12 50mm F2.5 MACRO", 0, 0,
       { 8849,-2560,-689,-5092,12831,2520,-507,1280,7104 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR DIGITAL 2", 0, 0,
       { 8846,-2704,-729,-5265,12708,2871,-1471,1955,6218 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR DIGITAL 3", 0, 0,
       { 8170,-2496,-655,-5147,13056,2312,-1367,1859,5265 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR DIGITAL 4", 0, 0,
       { 8771,-3151,-837,-3097,11015,2389,-703,1343,4924 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR III", 0, 0,
       { 6127,-1777,-585,-5913,13699,2428,-1088,1780,6017 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR II", 0, 0,
       { 5329,-1459,-390,-5407,12930,2768,-1119,1772,6046 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GR", 0, 0,
       { 5329,-1459,-390,-5407,12930,2768,-1119,1772,6046 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GX200", 0, 0,
       { 8040,-2368,-626,-4659,12543,2363,-1125,1581,5660 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR Mount A12", 0, 0,
       { 7834,-2182,-739,-5453,13409,2241,-952,2005,6620 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR A12 50mm", 0, 0,
       { 8849,-2560,-689,-5092,12831,2520,-507,1280,7104 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR A12 28mm", 0, 0,
       { 10228,-3159,-933,-5304,13158,2371,-943,1873,6685 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR A16", 0, 0,
       { 7837,-2538,-730,-4370,12184,2461,-868,1648,5830 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR P10", 0, 0,
       { 13168,-5128,-1663,-3006,11569,1611,-373,1244,4907 } },
     { LIBRAW_CAMERAMAKER_Ricoh, "GXR S10", 0, 0,
       { 8963,-2926,-754,-4881,12921,2164,-1464,1944,4901 } },
 
     { LIBRAW_CAMERAMAKER_Samsung, "EX1", 0, 0x3e00,
       { 8898,-2498,-994,-3144,11328,2066,-760,1381,4576 } },
     { LIBRAW_CAMERAMAKER_Samsung, "EX2F", 0, 0x7ff,
       { 10648,-3897,-1055,-2022,10573,1668,-492,1611,4742 } },
 //    { LIBRAW_CAMERAMAKER_Samsung, "GX20", 0, 0,
 //      { 23213,-14575,-4840,-7077,16564,316,385,-1656,9398 } }, // Adobe DNG
 //      { 27717,-17403,-5779,-8450,19778,377,459,1978,11221 } }, // Samsung DNG
 //      { 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },  // Adobe DCP
 
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S6 Edge Rear Camera", 0, 0,
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S6 Rear Camera", 0, 0,
     { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S6", 0, 0, // same CMs: "Galaxy S6", "Galaxy S6 Edge"
       { 13699,-5767,-1384,-4449,13879,499,-467,1691,5892 } },
 
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S7 Edge Rear Camera", 0, 0,
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S7 Rear Camera", 0, 0,
     { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S7", 0, 0, // same CMs: "Galaxy S7", "Galaxy S7 Edge"
       { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },
 
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S8+ Rear Camera", 0, 0,
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S8 Rear Camera", 0, 0,
     { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S8", 0, 0, // same CMs: "Galaxy S8", "Galaxy S8+"
       { 9927,-3704,-1024,-3935,12758,1257,-389,1512,4993 } },
 
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S9+ Rear Camera", 0, 0,
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S9 Rear Camera", 0, 0,
     { LIBRAW_CAMERAMAKER_Samsung, "Galaxy S9", 0, 0, // same CMs: "Galaxy S9", "Galaxy S9+"
       { 13292,-6142,-1268,-4095,12890,1283,-557,1930,5163 } },
 //    { LIBRAW_CAMERAMAKER_Samsung, "Galaxy Note 9 Rear Telephoto Camera", 0, 0,
     { LIBRAW_CAMERAMAKER_Samsung, "Galaxy Note 9 Rear Camera", 0, 0,
       { 13292,-6142,-1268,-4095,12890,1283,-557,1930,5163 } },
 
     { LIBRAW_CAMERAMAKER_Samsung, "NX U", 0, 0,
       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX3300", 0, 0,
       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX3000", 0, 0,
       { 8060,-2933,-761,-4504,12890,1762,-630,1489,5227 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX30", 0, 0, // same CMs: NX30, NX300, NX300M
       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX2000", 0, 0,
       { 7557,-2522,-739,-4679,12949,1894,-840,1777,5311 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX2", 0, 0xfff, // same CMs: NX20, NX200, NX210
       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX1000", 0, 0,
       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX1100", 0, 0,
       { 6933,-2268,-753,-4921,13387,1647,-803,1641,6096 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX11", 0, 0,
       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX10", 0, 0, // same CMs: NX10, NX100
       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX500", 0, 0,
       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX5", 0, 0,
       { 10332,-3234,-1168,-6111,14639,1520,-1352,2647,8331 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX1", 0, 0,
       { 10686,-4042,-1052,-3595,13238,276,-464,1259,5931 } },
     { LIBRAW_CAMERAMAKER_Samsung, "NX mini", 0, 0,
       { 5222,-1196,-550,-6540,14649,2009,-1666,2819,5657 } },
 
     { LIBRAW_CAMERAMAKER_Samsung, "WB2000", 0, 0xfff,
       { 12093,-3557,-1155,-1000,9534,1733,-22,1787,4576 } },
     { LIBRAW_CAMERAMAKER_Samsung, "WB5000", 0, 0,
       {  7675, -2195,  -305, -5860, 14118,  1857, -2425,  4007,  6578}},
     { LIBRAW_CAMERAMAKER_Samsung, "S85", 0, 0,
       { 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } }, /* DJC */
 
 // Foveon: LibRaw color data
     { LIBRAW_CAMERAMAKER_Sigma, "dp0 Quattro", 2047, 0,
       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },
     { LIBRAW_CAMERAMAKER_Sigma, "dp1 Quattro", 2047, 0,
       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },
     { LIBRAW_CAMERAMAKER_Sigma, "dp2 Quattro", 2047, 0,
       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },
     { LIBRAW_CAMERAMAKER_Sigma, "dp3 Quattro", 2047, 0,
       { 13801,-3390,-1016,5535,3802,877,1848,4245,3730 } },
     { LIBRAW_CAMERAMAKER_Sigma, "sd Quattro H", 256, 0,
       { 1295,108,-311,256,828,-65,-28,750,254 } }, /* temp */
     { LIBRAW_CAMERAMAKER_Sigma, "sd Quattro", 2047, 0,
       { 1295,108,-311,256,828,-65,-28,750,254 } }, /* temp */
     { LIBRAW_CAMERAMAKER_Sigma, "SD9", 15, 4095,
       { 13564,-2537,-751,-5465,15154,194,-67,116,10425 } },
     { LIBRAW_CAMERAMAKER_Sigma, "SD10", 15, 16383,
       { 6787,-1682,575,-3091,8357,160,217,-369,12314 } },
     { LIBRAW_CAMERAMAKER_Sigma, "SD14", 15, 16383,
       { 13589,-2509,-739,-5440,15104,193,-61,105,10554 } },
     { LIBRAW_CAMERAMAKER_Sigma, "SD15", 15, 4095,
       { 13556,-2537,-730,-5462,15144,195,-61,106,10577 } },
 // Merrills + SD1
     { LIBRAW_CAMERAMAKER_Sigma, "SD1", 31, 4095,
       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } }, /* LibRaw */
     { LIBRAW_CAMERAMAKER_Sigma, "DP1 Merrill", 31, 4095,
       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } }, /* LibRaw */
     { LIBRAW_CAMERAMAKER_Sigma, "DP2 Merrill", 31, 4095,
       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } }, /* LibRaw */
     { LIBRAW_CAMERAMAKER_Sigma, "DP3 Merrill", 31, 4095,
       { 5133,-1895,-353,4978,744,144,3837,3069,2777 } }, /* LibRaw */
 // Sigma DP (non-Merrill Versions)
     { LIBRAW_CAMERAMAKER_Sigma, "DP1X", 0, 4095,
       { 13704,-2452,-857,-5413,15073,186,-89,151,9820 } },
     { LIBRAW_CAMERAMAKER_Sigma, "DP1", 0, 4095,
       { 12774,-2591,-394,-5333,14676,207,15,-21,12127 } },
     { LIBRAW_CAMERAMAKER_Sigma, "DP", 0, 4095,
       //  { 7401,-1169,-567,2059,3769,1510,664,3367,5328 } },
       { 13100,-3638,-847,6855,2369,580,2723,3218,3251 } }, /* LibRaw */
 
 	{ LIBRAW_CAMERAMAKER_Sinar, "", 0, 0,
       { 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } }, /* DJC */
 
     { LIBRAW_CAMERAMAKER_Sony, "DSC-F828", 0, 0,
       { 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-R1", 0, 0,
       { 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-V3", 0, 0,
       { 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },
 
     { LIBRAW_CAMERAMAKER_Sony, "DSC-HX9", -800, 0, // same CMs: DSC-HX95, DSC-HX99
       { 13076,-5686,-1481,-4027,12851,1251,-167,725,4937 } },
 
     { LIBRAW_CAMERAMAKER_Sony, "ZV-1", -800, 0,
       {8280,-2987,-703,-3531,11645,2133,-550,1542,5312 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ZV-E10", 0, 0,
+      { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } }, // a la ILCE-6100
+
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M7", -800, 0,
       {10315, -4390, -937, -4859, 12734, 2365, -734, 1537, 5997 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M6", -800, 0,
       { 7325,-2321,-596,-3494,11674,2055,-668,1562,5031 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M5A", -800, 0,
       { 11176,-4700,-965,-4004,12184,2032,-763,1726,5876 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M", -800, 0, // same CMs: DSC-RX100M2, DSC-RX100M3, DSC-RX100M4, DSC-RX100M5
       { 6596,-2079,-562,-4782,13016,1933,-970,1581,5181 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100", 0, 0,
       { 8651,-2754,-1057,-3464,12207,1373,-568,1398,4434 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX10M4", -800, 0,
       { 7699,-2566,-629,-2967,11270,1928,-378,1286,4807 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX10",0, 0, // same CMs: DSC-RX10, DSC-RX10M2, DSC-RX10M3
       { 6679,-1825,-745,-5047,13256,1953,-1580,2422,5183 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX1RM2", 0, 0,
       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX1R", 0, 0,
       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX1", 0, 0,
       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
 
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX0", -800, 0, // same CMs: DSC-RX0, DSC-RX0M2
       { 9396,-3507,-843,-2497,11111,1572,-343,1355,5089 } },
 
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A100", 0, 0xfeb,
       { 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A290", 0, 0,
       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A2", 0, 0, // same CMs: DSLR-A200, DSLR-A230
       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A300", 0, 0,
       { 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A330", 0, 0,
       { 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A3", 0, 0, // same CMs: DSLR-A350, DSLR-A380, DSLR-A390
       { 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A450", 0, 0, // close to 16596 if arw is 14-bit
       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A580", 0, 16596,
       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A500", 0, 16596,
       { 6046,-1127,-278,-5574,13076,2786,-691,1419,7625 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A5", 0, 16596,  // same CMs: DSLR-A550, DSLR-A560
       { 4950,-580,-103,-5228,12542,3029,-709,1435,7371 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A700", 0, 0,
       { 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A850", 0, 0,
       { 5413,-1162,-365,-5665,13098,2866,-608,1179,8440 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSLR-A900", 0, 0,
       { 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } },
 
     { LIBRAW_CAMERAMAKER_Sony, "ILCA-68", 0, 0,
       { 6435,-1903,-536,-4722,12449,2550,-663,1363,6517 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCA-77M2", 0, 0,
       { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCA-99M2", 0, 0,
       { 6660,-1918,-471,-4613,12398,2485,-649,1433,6447 } },
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-9", 0, 0, // same CMs: ILCE-9, ILCE-9M2
-      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7SM3", 0, 0,
-      { 6912,-2127,-469,-4470,12175,2587,-398,1478,6492 } }, // preliminary
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7S", 0, 0, // same CMs: ILCE-7S, ILCE-7SM2
-      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
 
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM4", 0, 0,
-      { 7662, -2686,-660,-5240, 12965,2530, -796, 1508, 6167 }},
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM3", 0, 0,
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-1", 0, 0,
+      { 8161, -2947, -739, -4811, 12668, 2389, -437, 1229, 6524}},
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM4", 0, 0, // same CMs: ILCE-7RM4, ILCE-7RM4A
+      { 7662, -2686,-660,-5240, 12965,2530, -796, 1508, 6167 } },
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM3", 0, 0, // same CMs: ILCE-7RM3, ILCE-7RM3A
       { 6640,-1847,-503,-5238,13010,2474,-993,1673,6527 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM2", 0, 0,
       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7R", 0, 0,
       { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },
+
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7SM3", 0, 0,
+      { 6912,-2127,-469,-4470,12175,2587,-398,1478,6492 } },
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7S", 0, 0, // same CMs: ILCE-7S, ILCE-7SM2
+      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7C", 0, 0,
       { 7374,-2389,-551,-5435,13162,2519,-1006,1795,6552 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7M3", 0, 0,
       { 7374,-2389,-551,-5435,13162,2519,-1006,1795,6552 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7", 0, 0, // same CMs: ILCE-7, ILCE-7M2
       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-9", 0, 0, // same CMs: ILCE-9, ILCE-9M2
+      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6100", 0, 0,
       { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6300", 0, 0,
       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6400", 0, 0,
       { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6500", 0, 0,
       { 5973,-1695,-419,-3826,11797,2293,-639,1398,5789 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6600", 0, 0,
       { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE", 0, 0, // same CMs: ILCE-3000, ILCE-5000, ILCE-5100, ILCE-6000, ILCE-QX1
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ILME-FX3", 0, 0,
+      { 6912, -2127, -469, -4470, 12175, 2587, -398, 1478, 6492 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5N", 0, 0,
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5R", 0, 0,
       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5T", 0, 0,
       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5", 0, 0,
       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-3N", 0, 0,
       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-3", 0, 0,
       { 6549,-1550,-436,-4880,12435,2753,-854,1868,6976 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-6", 0, 0,
       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-7", 0, 0,
       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-VG30", 0, 0,
       { 6129,-1545,-418,-4930,12490,2743,-977,1693,6615 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-VG900", 0, 0,
       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX", 0, 0, // same CMs: NEX-C3, NEX-F3, NEX-VG20
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A33", 0, 0,
       { 6069,-1221,-366,-5221,12779,2734,-1024,2066,6834 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A35", 0, 0,
       { 5986,-1618,-415,-4557,11820,3120,-681,1404,6971 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A37", 0, 0,
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A55", 0, 0,
       { 5932,-1492,-411,-4813,12285,2856,-741,1524,6739 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A5", 0, 0, // same CMs: SLT-A57, SLT-A58
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A65", 0, 0,
       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A77", 0, 0,
       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
     { LIBRAW_CAMERAMAKER_Sony, "SLT-A99", 0, 0,
       { 6344,-1612,-462,-4863,12477,2681,-865,1786,6899 } },
     { LIBRAW_CAMERAMAKER_Sony, "MODEL-NAME", 0, 0,
       { 5491,-1192,-363,-4951,12342,2948,-911,1722,7192 } },
 
     { LIBRAW_CAMERAMAKER_YI, "M1", 0, 0,
       { 7712,-2059,-653,-3882,11494,2726,-710,1332,5958 } },
   };
   // clang-format on
 
   double cam_xyz[4][3];
   //char name[130];
   int i, j;
 
   if (colors > 4 || colors < 1)
     return 1;
 
   int bl4 = (cblack[0] + cblack[1] + cblack[2] + cblack[3]) / 4, bl64 = 0;
   if (cblack[4] * cblack[5] > 0)
   {
     for (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)
       bl64 += cblack[c + 6];
     bl64 /= cblack[4] * cblack[5];
   }
   int rblack = black + bl4 + bl64;
 
   for (i = 0; i < int(sizeof table / sizeof *table); i++)
   {
 	  if (table[i].m_idx == make_idx)
 	  {
-		  unsigned l = strlen(table[i].prefix);
+		  size_t l = strlen(table[i].prefix);
 		  if (!l ||  !strncasecmp(t_model, table[i].prefix, l))
 		  {
 			  if (!dng_version)
 			  {
 				  if (table[i].t_black > 0)
 				  {
 					  black = (ushort)table[i].t_black;
 					  memset(cblack, 0, sizeof(cblack));
 				  }
 				  else if (table[i].t_black < 0 && rblack == 0)
 				  {
 					  black = (ushort)(-table[i].t_black);
 					  memset(cblack, 0, sizeof(cblack));
 				  }
 				  if (table[i].t_maximum)
 					  maximum = (ushort)table[i].t_maximum;
 			  }
 			  if (table[i].trans[0])
 			  {
 				  for (raw_color = j = 0; j < 12; j++)
 					  if (internal_only)
-						  imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.0;
+						  imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.f;
 					  else
-						  imgdata.color.cam_xyz[j / 3][j % 3] = ((double *)cam_xyz)[j] =
-						  table[i].trans[j] / 10000.0;
+                          ((double *)cam_xyz)[j] = imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.f;
 				  if (!internal_only)
 					  cam_xyz_coeff(rgb_cam, cam_xyz);
 			  }
 			  return 1; // CM found
 		  }
 	  }
   }
   return 0; // CM not found
 }
diff --git a/src/tables/wblists.cpp b/src/tables/wblists.cpp
index c565aef6..f377cd3e 100644
--- a/src/tables/wblists.cpp
+++ b/src/tables/wblists.cpp
@@ -25,7 +25,7 @@ libraw_static_table_t LibRaw::tagtype_dataunit_bytes(_tagtype_dataunit_bytes, _A
 
 int libraw_tagtype_dataunit_bytes(int tagtype)
 {
-    return _tagtype_dataunit_bytes[(tagtype <= _ARR_SZ(_tagtype_dataunit_bytes)) ? tagtype : 0];
+    return _tagtype_dataunit_bytes[((unsigned)tagtype <= _ARR_SZ(_tagtype_dataunit_bytes)) ? tagtype : 0];
 }
 
 
diff --git a/src/utils/decoder_info.cpp b/src/utils/decoder_info.cpp
index c6c43bc2..01ba2141 100644
--- a/src/utils/decoder_info.cpp
+++ b/src/utils/decoder_info.cpp
@@ -24,371 +24,375 @@ const char *LibRaw::unpack_function_name()
 int LibRaw::get_decoder_info(libraw_decoder_info_t *d_info)
 {
   if (!d_info)
     return LIBRAW_UNSPECIFIED_ERROR;
   d_info->decoder_name = 0;
   d_info->decoder_flags = 0;
   if (!load_raw)
     return LIBRAW_OUT_OF_ORDER_CALL;
 
   // dcraw.c names order
   if (load_raw == &LibRaw::android_tight_load_raw)
   {
     d_info->decoder_name = "android_tight_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::android_loose_load_raw)
   {
     d_info->decoder_name = "android_loose_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::vc5_dng_load_raw_placeholder)
   {
       d_info->decoder_name = "vc5_dng_load_raw_placeholder()";
   }
   else if (load_raw == &LibRaw::canon_600_load_raw)
   {
     d_info->decoder_name = "canon_600_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::fuji_compressed_load_raw)
   {
     d_info->decoder_name = "fuji_compressed_load_raw()";
   }
   else if (load_raw == &LibRaw::fuji_14bit_load_raw)
   {
     d_info->decoder_name = "fuji_14bit_load_raw()";
   }
   else if (load_raw == &LibRaw::canon_load_raw)
   {
     d_info->decoder_name = "canon_load_raw()";
   }
   else if (load_raw == &LibRaw::lossless_jpeg_load_raw)
   {
     d_info->decoder_name = "lossless_jpeg_load_raw()";
     d_info->decoder_flags =
         LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::canon_sraw_load_raw)
   {
     d_info->decoder_name = "canon_sraw_load_raw()";
     // d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::crxLoadRaw)
   {
     d_info->decoder_name = "crxLoadRaw()";
   }
   else if (load_raw == &LibRaw::lossless_dng_load_raw)
   {
     d_info->decoder_name = "lossless_dng_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE |
                             LIBRAW_DECODER_TRYRAWSPEED |
                             LIBRAW_DECODER_ADOBECOPYPIXEL;
   }
   else if (load_raw == &LibRaw::packed_dng_load_raw)
   {
     d_info->decoder_name = "packed_dng_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE |
                             LIBRAW_DECODER_TRYRAWSPEED |
                             LIBRAW_DECODER_ADOBECOPYPIXEL;
   }
   else if (load_raw == &LibRaw::pentax_load_raw)
   {
     d_info->decoder_name = "pentax_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::nikon_load_raw)
   {
     d_info->decoder_name = "nikon_load_raw()";
     d_info->decoder_flags =
         LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;
   }
   else if (load_raw == &LibRaw::nikon_coolscan_load_raw)
   {
     d_info->decoder_name = "nikon_coolscan_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::nikon_load_sraw)
   {
     d_info->decoder_name = "nikon_load_sraw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::nikon_yuv_load_raw)
   {
     d_info->decoder_name = "nikon_load_yuv_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::rollei_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "rollei_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::phase_one_load_raw)
   {
     d_info->decoder_name = "phase_one_load_raw()";
   }
   else if (load_raw == &LibRaw::phase_one_load_raw_c)
   {
     d_info->decoder_name = "phase_one_load_raw_c()";
   }
   else if (load_raw == &LibRaw::hasselblad_load_raw)
   {
     d_info->decoder_name = "hasselblad_load_raw()";
   }
   else if (load_raw == &LibRaw::leaf_hdr_load_raw)
   {
     d_info->decoder_name = "leaf_hdr_load_raw()";
   }
   else if (load_raw == &LibRaw::unpacked_load_raw)
   {
     d_info->decoder_name = "unpacked_load_raw()";
 	d_info->decoder_flags = LIBRAW_DECODER_FLATDATA;
   }
   else if (load_raw == &LibRaw::unpacked_load_raw_reversed)
   {
     d_info->decoder_name = "unpacked_load_raw_reversed()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::sinar_4shot_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "sinar_4shot_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_SINAR4SHOT;
   }
   else if (load_raw == &LibRaw::imacon_full_load_raw)
   {
     d_info->decoder_name = "imacon_full_load_raw()";
   }
   else if (load_raw == &LibRaw::hasselblad_full_load_raw)
   {
     d_info->decoder_name = "hasselblad_full_load_raw()";
   }
   else if (load_raw == &LibRaw::packed_load_raw)
   {
     d_info->decoder_name = "packed_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::broadcom_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "broadcom_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::nokia_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "nokia_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
   else if (load_raw == &LibRaw::canon_rmf_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "canon_rmf_load_raw()";
   }
 #endif
   else if (load_raw == &LibRaw::panasonic_load_raw)
   {
     d_info->decoder_name = "panasonic_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::panasonicC6_load_raw)
   {
     d_info->decoder_name = "panasonicC6_load_raw()";
   }
   else if (load_raw == &LibRaw::panasonicC7_load_raw)
   {
     d_info->decoder_name = "panasonicC7_load_raw()";
   }
   else if (load_raw == &LibRaw::olympus_load_raw)
   {
     d_info->decoder_name = "olympus_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::minolta_rd175_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "minolta_rd175_load_raw()";
   }
   else if (load_raw == &LibRaw::quicktake_100_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "quicktake_100_load_raw()";
   }
   else if (load_raw == &LibRaw::kodak_radc_load_raw)
   {
     d_info->decoder_name = "kodak_radc_load_raw()";
   }
   else if (load_raw == &LibRaw::kodak_jpeg_load_raw)
   {
     // UNTESTED + RBAYER
     d_info->decoder_name = "kodak_jpeg_load_raw()";
   }
   else if (load_raw == &LibRaw::lossy_dng_load_raw)
   {
     // Check rbayer
     d_info->decoder_name = "lossy_dng_load_raw()";
     d_info->decoder_flags =
         LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;
   }
   else if (load_raw == &LibRaw::kodak_dc120_load_raw)
   {
     d_info->decoder_name = "kodak_dc120_load_raw()";
   }
   else if (load_raw == &LibRaw::eight_bit_load_raw)
   {
     d_info->decoder_name = "eight_bit_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::kodak_c330_load_raw)
   {
     d_info->decoder_name = "kodak_yrgb_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::kodak_c603_load_raw)
   {
     d_info->decoder_name = "kodak_yrgb_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::kodak_262_load_raw)
   {
     d_info->decoder_name = "kodak_262_load_raw()"; // UNTESTED!
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::kodak_65000_load_raw)
   {
     d_info->decoder_name = "kodak_65000_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;
   }
   else if (load_raw == &LibRaw::kodak_ycbcr_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "kodak_ycbcr_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::kodak_rgb_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "kodak_rgb_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::sony_load_raw)
   {
     d_info->decoder_name = "sony_load_raw()";
   }
+  else if (load_raw == &LibRaw::sony_ljpeg_load_raw)
+  {
+    d_info->decoder_name = "sony_ljpeg_load_raw()";
+  }
   else if (load_raw == &LibRaw::sony_arw_load_raw)
   {
     d_info->decoder_name = "sony_arw_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::sony_arw2_load_raw)
   {
     d_info->decoder_name = "sony_arw2_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE |
                             LIBRAW_DECODER_TRYRAWSPEED |
                             LIBRAW_DECODER_SONYARW2;
   }
   else if (load_raw == &LibRaw::sony_arq_load_raw)
   {
     d_info->decoder_name = "sony_arq_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_LEGACY_WITH_MARGINS | LIBRAW_DECODER_FLATDATA | LIBRAW_DECODER_FLAT_BG2_SWAPPED;
   }
   else if (load_raw == &LibRaw::samsung_load_raw)
   {
     d_info->decoder_name = "samsung_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;
   }
   else if (load_raw == &LibRaw::samsung2_load_raw)
   {
     d_info->decoder_name = "samsung2_load_raw()";
   }
   else if (load_raw == &LibRaw::samsung3_load_raw)
   {
     d_info->decoder_name = "samsung3_load_raw()";
   }
   else if (load_raw == &LibRaw::smal_v6_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "smal_v6_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
   else if (load_raw == &LibRaw::smal_v9_load_raw)
   {
     // UNTESTED
     d_info->decoder_name = "smal_v9_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;
   }
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
   else if (load_raw == &LibRaw::redcine_load_raw)
   {
     d_info->decoder_name = "redcine_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;
   }
 #endif
   else if (load_raw == &LibRaw::x3f_load_raw)
   {
     d_info->decoder_name = "x3f_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC | LIBRAW_DECODER_FIXEDMAXC |
                             LIBRAW_DECODER_LEGACY_WITH_MARGINS;
   }
   else if (load_raw == &LibRaw::pentax_4shot_load_raw)
   {
     d_info->decoder_name = "pentax_4shot_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;
   }
   else if (load_raw == &LibRaw::deflate_dng_load_raw)
   {
     d_info->decoder_name = "deflate_dng_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;
   }
   else if (load_raw == &LibRaw::uncompressed_fp_dng_load_raw)
   {
     d_info->decoder_name = "uncompressed_fp_dng_load_raw()";
     d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;
   }
   else if (load_raw == &LibRaw::nikon_load_striped_packed_raw)
   {
     d_info->decoder_name = "nikon_load_striped_packed_raw()";
   }
   else if (load_raw == &LibRaw::nikon_load_padded_packed_raw)
   {
     d_info->decoder_name = "nikon_load_padded_packed_raw()";
   }
   else if (load_raw == &LibRaw::nikon_14bit_load_raw)
   {
     d_info->decoder_name = "nikon_14bit_load_raw()";
   }
   /* -- added 07/02/18 -- */
   else if (load_raw == &LibRaw::unpacked_load_raw_fuji_f700s20)
   {
     d_info->decoder_name = "unpacked_load_raw_fuji_f700s20()";
   }
   else if (load_raw == &LibRaw::unpacked_load_raw_FujiDBP)
   {
     d_info->decoder_name = "unpacked_load_raw_FujiDBP()";
   }
 #ifdef USE_6BY9RPI
   else if (load_raw == &LibRaw::rpi_load_raw8)
   {
 	d_info->decoder_name = "rpi_load_raw8";
   }
   else if (load_raw == &LibRaw::rpi_load_raw12)
   {
 	d_info->decoder_name = "rpi_load_raw12";
   }
   else if (load_raw == &LibRaw::rpi_load_raw14)
   {
 	d_info->decoder_name = "rpi_load_raw14";
   }
   else if (load_raw == &LibRaw::rpi_load_raw16)
   {
 	d_info->decoder_name = "rpi_load_raw16";
   }
 #endif
   else
   {
     d_info->decoder_name = "Unknown unpack function";
     d_info->decoder_flags = LIBRAW_DECODER_NOTSET;
   }
   return LIBRAW_SUCCESS;
 }
diff --git a/src/utils/init_close_utils.cpp b/src/utils/init_close_utils.cpp
index 19090c91..ce420853 100644
--- a/src/utils/init_close_utils.cpp
+++ b/src/utils/init_close_utils.cpp
@@ -124,195 +124,201 @@ void x3f_clear(void *);
 void LibRaw::recycle()
 {
   recycle_datastream();
 #define FREE(a)                                                                \
   do                                                                           \
   {                                                                            \
     if (a)                                                                     \
     {                                                                          \
       free(a);                                                                 \
       a = NULL;                                                                \
     }                                                                          \
   } while (0)
 
   FREE(imgdata.image);
 
   // explicit cleanup of afdata allocations; entire array is zeroed below
   for (int i = 0; i < LIBRAW_AFDATA_MAXCOUNT; i++)
       FREE(MN.common.afdata[i].AFInfoData);
 
   FREE(imgdata.thumbnail.thumb);
   FREE(libraw_internal_data.internal_data.meta_data);
   FREE(libraw_internal_data.output_data.histogram);
   FREE(libraw_internal_data.output_data.oprof);
   FREE(imgdata.color.profile);
   FREE(imgdata.rawdata.ph1_cblack);
   FREE(imgdata.rawdata.ph1_rblack);
   FREE(imgdata.rawdata.raw_alloc);
   FREE(imgdata.idata.xmpdata);
 
 #undef FREE
 
   ZERO(imgdata.sizes);
-  imgdata.sizes.raw_inset_crop.cleft = 0xffff;
-  imgdata.sizes.raw_inset_crop.ctop  = 0xffff;
+  imgdata.sizes.raw_inset_crops[0].cleft = imgdata.sizes.raw_inset_crops[1].cleft = 0xffff;
+  imgdata.sizes.raw_inset_crops[0].ctop  = imgdata.sizes.raw_inset_crops[1].ctop = 0xffff;
 
   ZERO(imgdata.idata);
   ZERO(imgdata.color);
   ZERO(imgdata.lens);
   ZERO(imgdata.other);
   ZERO(imgdata.rawdata);
   ZERO(imgdata.shootinginfo);
   ZERO(imgdata.thumbnail);
   ZERO(MN);
   cleargps(&imgdata.other.parsed_gps);
   ZERO(libraw_internal_data);
 
   imgdata.lens.makernotes.FocalUnits = 1;
   imgdata.lens.makernotes.LensID = LIBRAW_LENS_NOT_SET;
   imgdata.shootinginfo.DriveMode = -1;
   imgdata.shootinginfo.FocusMode = -1;
   imgdata.shootinginfo.MeteringMode = -1;
   imgdata.shootinginfo.AFPoint = -1;
   imgdata.shootinginfo.ExposureMode = -1;
   imgdata.shootinginfo.ExposureProgram = -1;
   imgdata.shootinginfo.ImageStabilization = -1;
 
   imgdata.color.dng_levels.baseline_exposure = -999.f;
   imgdata.color.dng_levels.LinearResponseLimit = 1.f;
   imgdata.color.dng_color[0].illuminant =
       imgdata.color.dng_color[1].illuminant = LIBRAW_WBI_None;
   for (int i = 0; i < 4; i++) imgdata.color.dng_levels.analogbalance[i] = 1.0f;
 
-  MN.canon.SensorLeftBorder = -1;
-  MN.canon.SensorTopBorder = -1;
-  MN.canon.AutoLightingOptimizer = 3; // 'off' value
+  MN.canon.DefaultCropAbsolute.l = -1;
+  MN.canon.DefaultCropAbsolute.t = -1;
+  MN.canon.AutoLightingOptimizer =  3; // 'off' value
 
   MN.fuji.WB_Preset = 0xffff;
   MN.fuji.ExpoMidPointShift = -999.f;
   MN.fuji.DynamicRange = 0xffff;
   MN.fuji.FilmMode = 0xffff;
   MN.fuji.DynamicRangeSetting = 0xffff;
   MN.fuji.DevelopmentDynamicRange = 0xffff;
   MN.fuji.AutoDynamicRange = 0xffff;
   MN.fuji.DRangePriority = 0xffff;
   MN.fuji.FocusMode = 0xffff;
   MN.fuji.AFMode = 0xffff;
   MN.fuji.FocusPixel[0] = MN.fuji.FocusPixel[1] = 0xffff;
   MN.fuji.FocusSettings = 0xffffffff;
   MN.fuji.AF_C_Settings = 0xffffffff;
   MN.fuji.FocusWarning = 0xffff;
   for (int i = 0; i < 3; i++) MN.fuji.ImageStabilization[i] = 0xffff;
   MN.fuji.DriveMode = -1;
+  MN.fuji.ImageCount = -1;
+  MN.fuji.AutoBracketing = -1;
+  MN.fuji.SequenceNumber = -1;
+  MN.fuji.SeriesLength = -1;
+  MN.fuji.PixelShiftOffset[0] = MN.fuji.PixelShiftOffset[1] = -999.f;
 
   MN.hasselblad.nIFD_CM[0] = MN.hasselblad.nIFD_CM[1] = -1;
 
   MN.kodak.BlackLevelTop = 0xffff;
   MN.kodak.BlackLevelBottom = 0xffff;
   MN.kodak.ISOCalibrationGain = 1.0f;
 
   MN.nikon.SensorHighSpeedCrop.cleft = 0xffff;
   MN.nikon.SensorHighSpeedCrop.ctop = 0xffff;
 
   MN.olympus.FocusMode[0] = 0xffff;
   MN.olympus.AutoFocus    = 0xffff;
   MN.olympus.AFPoint      = 0xffff;
   MN.olympus.AFResult     = 0xffff;
   MN.olympus.AFFineTune   = 0xff;
   for (int i = 0; i < 3; i++) {
     MN.olympus.AFFineTuneAdj[i] = (short)0x8000;
     MN.olympus.SpecialMode[i] = 0xffffffff;
   }
   MN.olympus.ZoomStepCount = 0xffff;
   MN.olympus.FocusStepCount = 0xffff;
   MN.olympus.FocusStepInfinity = 0xffff;
   MN.olympus.FocusStepNear = 0xffff;
   MN.olympus.FocusDistance = -999.0;
   for (int i = 0; i < 4; i++) MN.olympus.AspectFrame[i] = 0xffff;
+  MN.olympus.StackedImage[0] = 0xffffffff;
 
   MN.panasonic.LensManufacturer = 0xffffffff;
 
   MN.pentax.FocusMode[0] =
     MN.pentax.FocusMode[1] = 0xffff;
   MN.pentax.AFPointSelected[1] = 0xffff;
   MN.pentax.AFPointSelected_Area = 0xffff;
   MN.pentax.AFPointsInFocus = 0xffffffff;
   MN.pentax.AFPointMode = 0xff;
 
   MN.ricoh.AFStatus = 0xffff;
   MN.ricoh.AFAreaMode = 0xffff;
   MN.ricoh.WideAdapter = 0xffff;
   MN.ricoh.CropMode = 0xffff;
   MN.ricoh.NDFilter = 0xffff;
   MN.ricoh.AutoBracketing = 0xffff;
   MN.ricoh.MacroMode = 0xffff;
   MN.ricoh.FlashMode = 0xffff;
   MN.ricoh.FlashExposureComp = -999.0;
   MN.ricoh.ManualFlashOutput = -999.0;
 
   MN.samsung.ColorSpace[0] = MN.samsung.ColorSpace[1] = -1;
 
   MN.sony.CameraType = LIBRAW_SONY_CameraType_UNKNOWN;
   MN.sony.group2010 = 0;
   MN.sony.real_iso_offset = 0xffff;
   MN.sony.ImageCount3_offset = 0xffff;
   MN.sony.MeteringMode_offset = 0xffff;
   MN.sony.ExposureProgram_offset = 0xffff;
   MN.sony.ReleaseMode2_offset = 0xffff;
   MN.sony.ElectronicFrontCurtainShutter = 0xffffffff;
   MN.sony.MinoltaCamID = 0xffffffff;
   MN.sony.RAWFileType = 0xffff;
   MN.sony.AFAreaModeSetting = 0xff;
   MN.sony.AFAreaMode = 0xffff;
   MN.sony.FlexibleSpotPosition[0] =
       MN.sony.FlexibleSpotPosition[1] = 0xffff;
   MN.sony.AFPointSelected = MN.sony.AFPointSelected_0x201e = 0xff;
   MN.sony.AFTracking = 0xff;
   MN.sony.FocusPosition = 0xffff;
   MN.sony.LongExposureNoiseReduction = 0xffffffff;
   MN.sony.Quality = 0xffffffff;
   MN.sony.HighISONoiseReduction = 0xffff;
   MN.sony.SonyRawFileType = 0xffff;
   MN.sony.AFMicroAdjValue = 0x7f;
   MN.sony.AFMicroAdjOn = -1;
   MN.sony.AFMicroAdjRegisteredLenses = 0xff;
 
   _exitflag = 0;
 #ifdef USE_RAWSPEED
   if (_rawspeed_decoder)
   {
     RawSpeed::RawDecoder *d =
         static_cast<RawSpeed::RawDecoder *>(_rawspeed_decoder);
     delete d;
   }
   _rawspeed_decoder = 0;
 #endif
 #ifdef USE_DNGSDK
   if (dngnegative)
   {
     dng_negative *ng = (dng_negative *)dngnegative;
     delete ng;
     dngnegative = 0;
   }
   if(dngimage)
   {
       dng_image *dimage = (dng_image*)dngimage;
       delete dimage;
       dngimage = 0;
   }
 #endif
 #ifdef USE_X3FTOOLS
   if (_x3f_data)
   {
     x3f_clear(_x3f_data);
     _x3f_data = 0;
   }
 #endif
   memmgr.cleanup();
 
   imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;
   imgdata.progress_flags = 0;
 
   load_raw = thumb_load_raw = 0;
 
   tls->init();
 }
diff --git a/src/utils/open.cpp b/src/utils/open.cpp
index 98b6887a..655dfae6 100644
--- a/src/utils/open.cpp
+++ b/src/utils/open.cpp
@@ -155,22 +155,26 @@ int LibRaw::libraw_openfile_tail(LibRaw_abstract_datastream *stream)
 int LibRaw::open_file(const char *fname)
 {
     LibRaw_abstract_datastream *stream;
     try
     {
 #ifdef LIBRAW_WIN32_CALLS
         stream = new LibRaw_bigfile_buffered_datastream(fname);
 #else
         stream = new LibRaw_bigfile_datastream(fname);
 #endif
     }
-
     catch (const std::bad_alloc&)
     {
         recycle();
         return LIBRAW_UNSUFFICIENT_MEMORY;
     }
+    if ((stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE))
+    {
+      delete stream;
+      return LIBRAW_TOO_BIG;
+    }
     return libraw_openfile_tail(stream);
 }
 
 #if defined(WIN32) || defined(_WIN32)
 #ifndef LIBRAW_WIN32_UNICODEPATHS
@@ -178,26 +182,32 @@ int LibRaw::open_file(const wchar_t *, INT64)
 {
     return LIBRAW_NOT_IMPLEMENTED;
 }
 #else
 int LibRaw::open_file(const wchar_t *fname)
 {
     LibRaw_abstract_datastream *stream;
     try
     {
 #ifdef LIBRAW_WIN32_CALLS
         stream = new LibRaw_bigfile_buffered_datastream(fname);
 #else
         stream = new LibRaw_bigfile_datastream(fname);
 #endif
     }
     catch (const std::bad_alloc&)
     {
         recycle();
         return LIBRAW_UNSUFFICIENT_MEMORY;
     }
+    if ((stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))
+    {
+      delete stream;
+      return LIBRAW_TOO_BIG;
+    }
+
     return libraw_openfile_tail(stream);
 }
 #endif
 #endif
 
 #endif
@@ -205,34 +215,37 @@ int LibRaw::open_file(const wchar_t *fname)
 int LibRaw::open_buffer(const void *buffer, size_t size)
 {
   // this stream will close on recycle()
   if (!buffer || buffer == (const void *)-1)
     return LIBRAW_IO_ERROR;
 
+  if ((size > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (size > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))   
+      return LIBRAW_TOO_BIG;
+
   LibRaw_buffer_datastream *stream;
   try
   {
     stream = new LibRaw_buffer_datastream(buffer, size);
   }
   catch (const std::bad_alloc& )
   {
     recycle();
     return LIBRAW_UNSUFFICIENT_MEMORY;
   }
   if (!stream->valid())
   {
     delete stream;
     return LIBRAW_IO_ERROR;
   }
   ID.input_internal = 0; // preserve from deletion on error
   int ret = open_datastream(stream);
   if (ret == LIBRAW_SUCCESS)
   {
     ID.input_internal = 1; // flag to delete datastream on recycle
   }
   else
   {
     delete stream;
     ID.input_internal = 0;
   }
   return ret;
 }
@@ -444,622 +457,725 @@ const int foveon_count = sizeof(foveon_data) / sizeof(foveon_data[0]);
 int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 {
 
   if (!stream)
     return ENOENT;
   if (!stream->valid())
     return LIBRAW_IO_ERROR;
+  if ((stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))
+      return LIBRAW_TOO_BIG;
+
   recycle();
   if (callbacks.pre_identify_cb)
   {
     int r = (callbacks.pre_identify_cb)(this);
     if (r == 1)
       goto final;
   }
 
   try
   {
 	  ID.input = stream;
 	  SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);
 
 	  identify();
 
 	  imgdata.lens.Lens[sizeof(imgdata.lens.Lens) - 1] = 0; // make sure lens is 0-terminated
 
 	  if (callbacks.post_identify_cb)
 		  (callbacks.post_identify_cb)(this);
 
-#define isRIC imgdata.sizes.raw_inset_crop
+#define isRIC imgdata.sizes.raw_inset_crops[0]
 
 	  if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Fujifilm)
 		  && (!strcmp(imgdata.idata.normalized_model, "S3Pro")
 			  || !strcmp(imgdata.idata.normalized_model, "S5Pro")
 			  || !strcmp(imgdata.idata.normalized_model, "S2Pro")))
 	  {
 		  isRIC.cleft = isRIC.ctop = 0xffff;
 		  isRIC.cwidth = isRIC.cheight = 0;
 	  }
+      // Wipe out canon  incorrect in-camera crop
+      if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Canon)
+          && isRIC.cleft == 0 && isRIC.ctop == 0 // non symmetric!
+          && isRIC.cwidth < (imgdata.sizes.raw_width * 4 / 5))  // less than 80% of sensor width
+      {
+        isRIC.cleft = isRIC.ctop = 0xffff;
+        isRIC.cwidth = isRIC.cheight = 0;
+      }
 
       // Wipe out non-standard WB
       if (!imgdata.idata.dng_version &&
           (makeIs(LIBRAW_CAMERAMAKER_Sony) && !strcmp(imgdata.idata.normalized_model, "DSC-F828"))
           && !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB))
       {
           for (int i = 0; i < 4; i++) imgdata.color.cam_mul[i] = (i == 1);
           memset(imgdata.color.WB_Coeffs, 0, sizeof(imgdata.color.WB_Coeffs));
           memset(imgdata.color.WBCT_Coeffs, 0, sizeof(imgdata.color.WBCT_Coeffs));
       }
 
 	  if (load_raw == &LibRaw::nikon_load_raw)
 		  nikon_read_curve();
 
 	  if (load_raw == &LibRaw::lossless_jpeg_load_raw &&
 		  MN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&
 		  /* Not normalized models here, it is intentional */
 		  (!strncasecmp(imgdata.idata.model, "EOS D2000", 9) || // if we want something different for B&W cameras,
 			  !strncasecmp(imgdata.idata.model, "EOS D6000", 9)))  // it's better to compare with CamIDs
 	  {
 		  imgdata.color.black = 0;
 		  imgdata.color.maximum = 4501;
 		  memset(imgdata.color.cblack, 0, sizeof(imgdata.color.cblack));
 		  memset(imgdata.sizes.mask, 0, sizeof(imgdata.sizes.mask));
 		  imgdata.sizes.mask[0][3] = 1; // to skip mask re-calc
 		  libraw_internal_data.unpacker_data.load_flags |= 512;
 	  }
 
 	  if (load_raw == &LibRaw::panasonic_load_raw)
 	  {
 		  if (libraw_internal_data.unpacker_data.pana_encoding == 6 ||
 			  libraw_internal_data.unpacker_data.pana_encoding == 7)
 		  {
 			  for (int i = 0; i < 3; i++)
 				  imgdata.color.cblack[i] =
 				  libraw_internal_data.internal_data.pana_black[i];
 			  imgdata.color.cblack[3] = imgdata.color.cblack[1];
 			  imgdata.color.cblack[4] = imgdata.color.cblack[5] = 0;
 			  imgdata.color.black = 0;
 			  imgdata.color.maximum =
 				  MAX(imgdata.color.linear_max[0],
 					  MAX(imgdata.color.linear_max[1], imgdata.color.linear_max[2]));
 		  }
 
 		  if (libraw_internal_data.unpacker_data.pana_encoding == 6)
 		  {
-			  int rowbytes = imgdata.sizes.raw_width / 11 * 16;
-			  if ((imgdata.sizes.raw_width % 11) == 0 &&
-				  (INT64(imgdata.sizes.raw_height) * rowbytes ==
-					  INT64(libraw_internal_data.unpacker_data.data_size)))
+			  int rowbytes11 = imgdata.sizes.raw_width / 11 * 16;
+              int rowbytes14 = imgdata.sizes.raw_width / 14 * 16;
+              INT64 ds = INT64(libraw_internal_data.unpacker_data.data_size);
+              if (!ds)
+                  ds = libraw_internal_data.internal_data.input->size() - libraw_internal_data.unpacker_data.data_offset;
+              if ((imgdata.sizes.raw_width % 11) == 0 &&
+				  (INT64(imgdata.sizes.raw_height) * rowbytes11 == ds))
 				  load_raw = &LibRaw::panasonicC6_load_raw;
-			  else
+              else if ((imgdata.sizes.raw_width % 14) == 0 &&
+                (INT64(imgdata.sizes.raw_height) * rowbytes14 == ds))
+                  load_raw = &LibRaw::panasonicC6_load_raw;
+              else
 				  imgdata.idata.raw_count = 0; // incorrect size
 		  }
 		  else if (libraw_internal_data.unpacker_data.pana_encoding == 7)
 		  {
 			  int pixperblock =
 				  libraw_internal_data.unpacker_data.pana_bpp == 14 ? 9 : 10;
 			  int rowbytes = imgdata.sizes.raw_width / pixperblock * 16;
 			  if ((imgdata.sizes.raw_width % pixperblock) == 0 &&
 				  (INT64(imgdata.sizes.raw_height) * rowbytes ==
 					  INT64(libraw_internal_data.unpacker_data.data_size)))
 				  load_raw = &LibRaw::panasonicC7_load_raw;
 			  else
 				  imgdata.idata.raw_count = 0; // incorrect size
 		  }
 	  }
 
 #define NIKON_14BIT_SIZE(rw, rh)                                               \
   (((unsigned)(ceilf((float)(rw * 7 / 4) / 16.0)) * 16) * rh)
 
 	  // Ugly hack, replace with proper data/line size for different
 	  // cameras/format when available
 	  if (makeIs(LIBRAW_CAMERAMAKER_Nikon)
 		  && (!strncasecmp(imgdata.idata.model, "Z", 1) || !strcasecmp(imgdata.idata.model,"D6"))
 		  &&  NIKON_14BIT_SIZE(imgdata.sizes.raw_width, imgdata.sizes.raw_height) ==
 		  libraw_internal_data.unpacker_data.data_size)
 	  {
 		  load_raw = &LibRaw::nikon_14bit_load_raw;
 	  }
 #undef NIKON_14BIT_SIZE
 
 	  // Linear max from 14-bit camera, but on 12-bit data?
 	  if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&
 		  imgdata.color.maximum > 0 &&
 		  imgdata.color.linear_max[0] > (long)imgdata.color.maximum &&
 		  imgdata.color.linear_max[0] <= (long)imgdata.color.maximum * 4)
 		  for (int c = 0; c < 4; c++)
 			  imgdata.color.linear_max[c] /= 4;
 
 	  if (makeIs(LIBRAW_CAMERAMAKER_Canon))
 	  {
-		  if (MN.canon.SensorLeftBorder != -1)
-		  { // tag 0x00e0 SensorInfo was parsed
-			  if (isRIC.aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
+		  if (MN.canon.DefaultCropAbsolute.l != -1)  // tag 0x00e0 SensorInfo was parsed
+		  {
+			  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
 			  { // tag 0x009a AspectInfo was parsed
-				  isRIC.cleft += MN.canon.SensorLeftBorder;
-				  isRIC.ctop += MN.canon.SensorTopBorder;
+				  isRIC.cleft += MN.canon.DefaultCropAbsolute.l;
+				  isRIC.ctop  += MN.canon.DefaultCropAbsolute.t;
 			  }
 			  else
 			  {
-				  isRIC.cleft = MN.canon.SensorLeftBorder;
-				  isRIC.ctop = MN.canon.SensorTopBorder;
-				  isRIC.cwidth = MN.canon.SensorRightBorder - MN.canon.SensorLeftBorder + 1;
-				  isRIC.cheight = MN.canon.SensorBottomBorder - MN.canon.SensorTopBorder + 1;
+				  isRIC.cleft   = MN.canon.DefaultCropAbsolute.l;
+				  isRIC.ctop    = MN.canon.DefaultCropAbsolute.t;
+				  isRIC.cwidth  = MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;
+				  isRIC.cheight = MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;
 			  }
 		  }
 		  else
 		  {
-			  if (isRIC.aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
+			  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
 			  {
 			  }
 			  else
 			  { // Canon PowerShot S2 IS
 			  }
 		  }
 #undef isRIC
+          if (imgdata.color.raw_bps < 14 && !imgdata.idata.dng_version && load_raw != &LibRaw::canon_sraw_load_raw)
+          {
+              unsigned xmax = (1 << imgdata.color.raw_bps) - 1;
+              if (MN.canon.SpecularWhiteLevel > xmax) // Adjust 14-bit metadata to real bps
+              {
+                int div = 1 << (14 - imgdata.color.raw_bps);
+                for (int c = 0; c < 4; c++) imgdata.color.linear_max[c] /= div;
+                for (int c = 0; c < 4; c++)  MN.canon.ChannelBlackLevel[c] /= div;
+                MN.canon.AverageBlackLevel /= div;
+                MN.canon.SpecularWhiteLevel /= div;
+                MN.canon.NormalWhiteLevel /= div;
+              }
+          }
 	  }
 
 	  if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
 		  (load_raw == &LibRaw::canon_sraw_load_raw) &&
 		  imgdata.sizes.raw_width > 0)
 	  {
 		  float ratio =
 			  float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);
 		  if ((ratio < 0.57 || ratio > 0.75) &&
 			  MN.canon.SensorHeight > 1 &&
 			  MN.canon.SensorWidth > 1)
 		  {
 			  imgdata.sizes.raw_width = MN.canon.SensorWidth;
-			  imgdata.sizes.left_margin = MN.canon.SensorLeftBorder;
+			  imgdata.sizes.left_margin = MN.canon.DefaultCropAbsolute.l;
 			  imgdata.sizes.iwidth = imgdata.sizes.width =
-				  MN.canon.SensorRightBorder - MN.canon.SensorLeftBorder + 1;
+				  MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;
 			  imgdata.sizes.raw_height = MN.canon.SensorHeight;
-			  imgdata.sizes.top_margin = MN.canon.SensorTopBorder;
+			  imgdata.sizes.top_margin = MN.canon.DefaultCropAbsolute.t;
 			  imgdata.sizes.iheight = imgdata.sizes.height =
-				  MN.canon.SensorBottomBorder - MN.canon.SensorTopBorder + 1;
+				  MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;
 			  libraw_internal_data.unpacker_data.load_flags |=
 				  256; // reset width/height in canon_sraw_load_raw()
 			  imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;
 		  }
 		  else if (imgdata.sizes.raw_width == 4032 &&
 			  imgdata.sizes.raw_height == 3402 &&
 			  !strcasecmp(imgdata.idata.model, "EOS 80D")) // 80D hardcoded
 		  {
 			  imgdata.sizes.raw_width = 4536;
 			  imgdata.sizes.left_margin = 28;
 			  imgdata.sizes.iwidth = imgdata.sizes.width =
 				  imgdata.sizes.raw_width - imgdata.sizes.left_margin;
 			  imgdata.sizes.raw_height = 3024;
 			  imgdata.sizes.top_margin = 8;
 			  imgdata.sizes.iheight = imgdata.sizes.height =
 				  imgdata.sizes.raw_height - imgdata.sizes.top_margin;
 			  libraw_internal_data.unpacker_data.load_flags |= 256;
 			  imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;
 		  }
 	  }
 
 #ifdef USE_DNGSDK
 	  if (imgdata.idata.dng_version
 		  &&libraw_internal_data.unpacker_data.tiff_compress == 34892
 		  && libraw_internal_data.unpacker_data.tiff_bps == 8
 		  && libraw_internal_data.unpacker_data.tiff_samples == 3
 		  && load_raw == &LibRaw::lossy_dng_load_raw)
 	  {
 		  // Data should be linearized by DNG SDK
 		  C.black = 0;
 		  memset(C.cblack, 0, sizeof(C.cblack));
 	  }
 #endif
 
 	  // XTrans Compressed?
 	  if (!imgdata.idata.dng_version &&
 		  makeIs(LIBRAW_CAMERAMAKER_Fujifilm) &&
 		  (load_raw == &LibRaw::unpacked_load_raw))
 	  {
 		  if (imgdata.sizes.raw_width * (imgdata.sizes.raw_height * 2ul) !=
 			  libraw_internal_data.unpacker_data.data_size)
 		  {
 			  if ((imgdata.sizes.raw_width * (imgdata.sizes.raw_height * 7ul)) / 4 ==
 				  libraw_internal_data.unpacker_data.data_size)
 				  load_raw = &LibRaw::fuji_14bit_load_raw;
 			  else
 				  parse_fuji_compressed_header();
 		  }
-		  if (imgdata.idata.filters == 9)
-		  {
-			  // Adjust top/left margins for X-Trans
-			  int newtm = imgdata.sizes.top_margin % 6
-				  ? (imgdata.sizes.top_margin / 6 + 1) * 6
-				  : imgdata.sizes.top_margin;
-			  int newlm = imgdata.sizes.left_margin % 6
-				  ? (imgdata.sizes.left_margin / 6 + 1) * 6
-				  : imgdata.sizes.left_margin;
-			  if (newtm != imgdata.sizes.top_margin ||
-				  newlm != imgdata.sizes.left_margin)
-			  {
-				  imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);
-				  imgdata.sizes.top_margin = newtm;
-				  imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);
-				  imgdata.sizes.left_margin = newlm;
-				  for (int c1 = 0; c1 < 6; c1++)
-					  for (int c2 = 0; c2 < 6; c2++)
-						  imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];
-			  }
-		  }
 	  }
-	  if (!libraw_internal_data.internal_output_params.fuji_width
-		  && imgdata.idata.filters >= 1000
-		  && ((imgdata.sizes.top_margin % 2) || (imgdata.sizes.left_margin % 2)))
+      // set raw_inset_crops[1] via raw_aspect
+      if (imgdata.sizes.raw_aspect >= LIBRAW_IMAGE_ASPECT_MINIMAL_REAL_ASPECT_VALUE
+          && imgdata.sizes.raw_aspect <= LIBRAW_IMAGE_ASPECT_MAXIMAL_REAL_ASPECT_VALUE
+          /* crops[0] is valid*/
+          && (imgdata.sizes.raw_inset_crops[0].cleft < 0xffff)
+          && (imgdata.sizes.raw_inset_crops[0].cleft + imgdata.sizes.raw_inset_crops[0].cwidth <= imgdata.sizes.raw_width)
+          && (imgdata.sizes.raw_inset_crops[0].ctop < 0xffff)
+          && (imgdata.sizes.raw_inset_crops[0].ctop + imgdata.sizes.raw_inset_crops[0].cheight <= imgdata.sizes.raw_height)
+          && imgdata.sizes.raw_inset_crops[0].cwidth > 0 && imgdata.sizes.raw_inset_crops[0].cheight >0
+          /* crops[1] is not set*/
+          && (imgdata.sizes.raw_inset_crops[1].cleft == 0xffff)
+          && (imgdata.sizes.raw_inset_crops[1].ctop == 0xffff)
+          )
+      {
+          float c0_ratio = float(imgdata.sizes.raw_inset_crops[0].cwidth) / float(imgdata.sizes.raw_inset_crops[0].cheight);
+          float c1_ratio = float(imgdata.sizes.raw_aspect) / 1000.f;
+          if (c0_ratio / c1_ratio < 0.98 || c0_ratio / c1_ratio > 1.02) // set crops[1]
+          {
+              if (c1_ratio > c0_ratio) // requested image is wider, cut from top/bottom
+              {
+                  int newheight =  int(imgdata.sizes.raw_inset_crops[0].cwidth / c1_ratio);
+                  int dtop = (imgdata.sizes.raw_inset_crops[0].cheight - newheight) / 2;
+                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop + dtop;
+                  imgdata.sizes.raw_inset_crops[1].cheight = newheight;
+                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft;
+                  imgdata.sizes.raw_inset_crops[1].cwidth = imgdata.sizes.raw_inset_crops[0].cwidth;
+              }
+              else
+              {
+                  int newwidth = int(imgdata.sizes.raw_inset_crops[0].cheight * c1_ratio);
+                  int dleft = (imgdata.sizes.raw_inset_crops[0].cwidth - newwidth) / 2;
+                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft + dleft;
+                  imgdata.sizes.raw_inset_crops[1].cwidth = newwidth;
+                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop;
+                  imgdata.sizes.raw_inset_crops[1].cheight = imgdata.sizes.raw_inset_crops[0].cheight;
+              }
+          }
+      }
+
+      int adjust_margins = 0;
+      if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm) && (imgdata.idata.filters == 9))
+      {
+          // Adjust top/left margins for X-Trans
+          int newtm = imgdata.sizes.top_margin % 6
+              ? (imgdata.sizes.top_margin / 6 + 1) * 6
+              : imgdata.sizes.top_margin;
+          int newlm = imgdata.sizes.left_margin % 6
+              ? (imgdata.sizes.left_margin / 6 + 1) * 6
+              : imgdata.sizes.left_margin;
+          if (newtm != imgdata.sizes.top_margin ||
+              newlm != imgdata.sizes.left_margin)
+          {
+              imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);
+              imgdata.sizes.top_margin = newtm;
+              imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);
+              imgdata.sizes.left_margin = newlm;
+              for (int c1 = 0; c1 < 6; c1++)
+                  for (int c2 = 0; c2 < 6; c2++)
+                      imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];
+          }
+          adjust_margins = 6;
+      }
+      else if (!libraw_internal_data.internal_output_params.fuji_width
+          && imgdata.idata.filters >= 1000)
 	  {
-		  int crop[2] = { 0,0 };
-		  unsigned filt;
-		  int c;
-		  if (imgdata.sizes.top_margin % 2)
-		  {
-			  imgdata.sizes.top_margin += 1;
-			  imgdata.sizes.height -= 1;
-			  crop[1] = 1;
-		  }
-		  if (imgdata.sizes.left_margin % 2)
-		  {
-			  imgdata.sizes.left_margin += 1;
-			  imgdata.sizes.width -= 1;
-			  crop[0] = 1;
-		  }
-		  for (filt = c = 0; c < 16; c++)
-			  filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;
-		  imgdata.idata.filters = filt;
+          if ((imgdata.sizes.top_margin % 2) || (imgdata.sizes.left_margin % 2))
+          {
+              int crop[2] = { 0,0 };
+              unsigned filt;
+              int c;
+              if (imgdata.sizes.top_margin % 2)
+              {
+                  imgdata.sizes.top_margin += 1;
+                  imgdata.sizes.height -= 1;
+                  crop[1] = 1;
+              }
+              if (imgdata.sizes.left_margin % 2)
+              {
+                  imgdata.sizes.left_margin += 1;
+                  imgdata.sizes.width -= 1;
+                  crop[0] = 1;
+              }
+              for (filt = c = 0; c < 16; c++)
+                  filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;
+              imgdata.idata.filters = filt;
+          }
+          adjust_margins = 2;
 	  }
 
+      if(adjust_margins) // adjust crop_inset margins
+          for (int i = 0; i < 2; i++)
+          {
+              if (imgdata.sizes.raw_inset_crops[i].cleft && imgdata.sizes.raw_inset_crops[i].cleft < 0xffff
+                  && imgdata.sizes.raw_inset_crops[i].cwidth && imgdata.sizes.raw_inset_crops[i].cwidth < 0xffff
+                  && (imgdata.sizes.raw_inset_crops[i].cleft%adjust_margins)
+                  && (imgdata.sizes.raw_inset_crops[i].cwidth > adjust_margins))
+              {
+                  int newleft = ((imgdata.sizes.raw_inset_crops[i].cleft / adjust_margins) + 1) * adjust_margins;
+                  int diff = newleft - imgdata.sizes.raw_inset_crops[i].cleft;
+                  if (diff > 0)
+                  {
+                      imgdata.sizes.raw_inset_crops[i].cleft += diff;
+                      imgdata.sizes.raw_inset_crops[i].cwidth -= diff;
+                  }
+              }
+              if (imgdata.sizes.raw_inset_crops[i].ctop && imgdata.sizes.raw_inset_crops[i].ctop < 0xffff
+                  && imgdata.sizes.raw_inset_crops[i].cheight && imgdata.sizes.raw_inset_crops[i].cheight < 0xffff
+                  && (imgdata.sizes.raw_inset_crops[i].ctop%adjust_margins)
+                  && (imgdata.sizes.raw_inset_crops[i].cheight > adjust_margins))
+              {
+                  int newtop = ((imgdata.sizes.raw_inset_crops[i].ctop / adjust_margins) + 1) * adjust_margins;
+                  int diff = newtop - imgdata.sizes.raw_inset_crops[i].ctop;
+                  if (diff > 0)
+                  {
+                      imgdata.sizes.raw_inset_crops[i].ctop += diff;
+                      imgdata.sizes.raw_inset_crops[i].cheight -= diff;
+                  }
+              }
+          }
+
+
 #ifdef USE_DNGSDK
 	  if (
 		  imgdata.rawparams.use_dngsdk &&
 		  !(imgdata.rawparams.options & (LIBRAW_RAWOPTIONS_DNG_STAGE2 | LIBRAW_RAWOPTIONS_DNG_STAGE3 | LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST)))
 #endif
 	  {
 		  // Fix DNG white balance if needed: observed only for Kalpanika X3F tools produced DNGs
 		  if (imgdata.idata.dng_version && (imgdata.idata.filters == 0) &&
 			  imgdata.idata.colors > 1 && imgdata.idata.colors < 5)
 		  {
 			  float delta[4] = { 0.f, 0.f, 0.f, 0.f };
 			  int black[4];
 			  for (int c = 0; c < 4; c++)
 				  black[c] = imgdata.color.dng_levels.dng_black +
 				  imgdata.color.dng_levels.dng_cblack[c];
 			  for (int c = 0; c < imgdata.idata.colors; c++)
 				  delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - black[c];
 			  float mindelta = delta[0], maxdelta = delta[0];
 			  for (int c = 1; c < imgdata.idata.colors; c++)
 			  {
 				  if (mindelta > delta[c])
 					  mindelta = delta[c];
 				  if (maxdelta < delta[c])
 					  maxdelta = delta[c];
 			  }
 			  if (mindelta > 1 && maxdelta < (mindelta * 20)) // safety
 			  {
 				  for (int c = 0; c < imgdata.idata.colors; c++)
 				  {
 					  imgdata.color.cam_mul[c] /= (delta[c] / maxdelta);
 					  imgdata.color.pre_mul[c] /= (delta[c] / maxdelta);
 				  }
 				  imgdata.color.maximum = imgdata.color.cblack[0] + maxdelta;
 			  }
 		  }
 	  }
 
     if (imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP) &&
 		makeIs(LIBRAW_CAMERAMAKER_Panasonic)
           && !strcasecmp(imgdata.idata.normalized_model, "DMC-LX100"))
       imgdata.sizes.width = 4288;
 
-    if (imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP)
-	&& makeIs(LIBRAW_CAMERAMAKER_Leica)
+    if (imgdata.idata.dng_version
+    	&& makeIs(LIBRAW_CAMERAMAKER_Leica)
         && !strcasecmp(imgdata.idata.normalized_model, "SL2"))
         	imgdata.sizes.height -= 16;
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&
-        imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP))
+        imgdata.idata.dng_version)
     {
       if (S.raw_width == 3984)
         S.width = 3925;
       else if (S.raw_width == 4288)
         S.width = S.raw_width - 32;
       else if (S.raw_width == 4928 && S.height < 3280)
         S.width = S.raw_width - 8;
       else if (S.raw_width == 5504)
         S.width = S.raw_width - (S.height > 3664 ? 8 : 32);
     }
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&
         !imgdata.idata.dng_version)
     {
         if(load_raw ==&LibRaw::sony_arq_load_raw)
         {
             if(S.raw_width > 12000) // A7RM4 16x, both APS-C and APS
                 S.width = S.raw_width - 64;
             else // A7RM3/M4 4x merge
                 S.width = S.raw_width - 32;
         }
 
       if (((!strncasecmp(imgdata.idata.model, "ILCE-7RM", 8) ||
             !strcasecmp(imgdata.idata.model, "ILCA-99M2")) &&
            (S.raw_width == 5216 || S.raw_width == 6304)) // A7RM2/M3/A99M2 in APS mode; A7RM4 in APS-C
           ||
           (!strcasecmp(imgdata.idata.model, "ILCE-7R") && S.raw_width >= 4580 &&
            S.raw_width < 5020) // A7R in crop mode, no samples, so size est.
           || (!strcasecmp(imgdata.idata.model, "ILCE-7") &&
               S.raw_width == 3968) // A7 in crop mode
           ||
           ((!strncasecmp(imgdata.idata.model, "ILCE-7M", 7) ||
             !strcasecmp(imgdata.idata.model, "ILCE-9") ||
 #if 0
             !strcasecmp(imgdata.idata.model,
                         "SLT-A99V")) // Does SLT-A99 also have APS-C mode??
 #endif
            (mnCamID == SonyID_SLT_A99)) // 2 reasons: some cameras are SLT-A99, no 'V'; some are Hasselblad HV
            && S.raw_width > 3750 &&
            S.raw_width < 4120) // A7M2, A7M3, AA9, most likely APS-C raw_width
                                // is 3968 (same w/ A7), but no samples, so guess
           || (!strncasecmp(imgdata.idata.model, "ILCE-7S", 7) &&
               S.raw_width == 2816) // A7S2=> exact, hope it works for A7S-I too
       )
         S.width = S.raw_width - 32;
     }
 
 
     // FIXME: it is possible that DNG contains 4x main frames + some previews; in this case imgdata.idata.raw_count will be greater than 4
 	if (makeIs(LIBRAW_CAMERAMAKER_Pentax) &&
         /*!strcasecmp(imgdata.idata.model,"K-3 II")  &&*/
             imgdata.idata.raw_count == 4 &&
         (imgdata.rawparams.options & LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES))
     {
       imgdata.idata.raw_count = 1;
       imgdata.idata.filters = 0;
       imgdata.idata.colors = 4;
       imgdata.sizes.top_margin+=2;
       imgdata.sizes.left_margin+=2;
       imgdata.sizes.width-=4;
       imgdata.sizes.height-=4;
       IO.mix_green = 1;
       pentax_component_load_raw = load_raw;
       load_raw = &LibRaw::pentax_4shot_load_raw;
     }
 
 	if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Leaf) &&
         !strcmp(imgdata.idata.model, "Credo 50"))
     {
       imgdata.color.pre_mul[0] = 1.f / 0.3984f;
       imgdata.color.pre_mul[2] = 1.f / 0.7666f;
       imgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;
     }
 
 	if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Fujifilm) &&
         (!strncmp(imgdata.idata.model, "S20Pro", 6) ||
          !strncmp(imgdata.idata.model, "F700", 4)))
     {
       imgdata.sizes.raw_width /= 2;
       load_raw = &LibRaw::unpacked_load_raw_fuji_f700s20;
     }
 
     if (load_raw == &LibRaw::packed_load_raw &&
 		makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
         !libraw_internal_data.unpacker_data.load_flags &&
         (!strncasecmp(imgdata.idata.model, "D810", 4) ||
          !strcasecmp(imgdata.idata.model, "D4S")) &&
         libraw_internal_data.unpacker_data.data_size * 2 ==
             imgdata.sizes.raw_height * imgdata.sizes.raw_width * 3)
     {
       libraw_internal_data.unpacker_data.load_flags = 80;
     }
     // Adjust BL for Sony A900/A850
     if (load_raw == &LibRaw::packed_load_raw &&
 		makeIs(LIBRAW_CAMERAMAKER_Sony)) // 12 bit sony, but metadata may be for 14-bit range
     {
       if (C.maximum > 4095)
         C.maximum = 4095;
       if (C.black > 256 || C.cblack[0] > 256)
       {
         C.black /= 4;
         for (int c = 0; c < 4; c++)
           C.cblack[c] /= 4;
         for (unsigned c = 0; c < C.cblack[4] * C.cblack[5]; c++)
           C.cblack[6 + c] /= 4;
       }
     }
 
 	if (load_raw == &LibRaw::nikon_yuv_load_raw) // Is it Nikon sRAW?
     {
       load_raw = &LibRaw::nikon_load_sraw;
       C.black = 0;
       memset(C.cblack, 0, sizeof(C.cblack));
       imgdata.idata.filters = 0;
       libraw_internal_data.unpacker_data.tiff_samples = 3;
       imgdata.idata.colors = 3;
       double beta_1 = -5.79342238397656E-02;
       double beta_2 = 3.28163551282665;
       double beta_3 = -8.43136004842678;
       double beta_4 = 1.03533181861023E+01;
       for (int i = 0; i <= 3072; i++)
       {
         double x = (double)i / 3072.;
         double y = (1. - exp(-beta_1 * x - beta_2 * x * x - beta_3 * x * x * x -
                              beta_4 * x * x * x * x));
         if (y < 0.)
           y = 0.;
         imgdata.color.curve[i] = (y * 16383.);
       }
       for (int i = 0; i < 3; i++)
         for (int j = 0; j < 4; j++)
           imgdata.color.rgb_cam[i][j] = float(i == j);
     }
     // Adjust BL for Nikon 12bit
     if ((load_raw == &LibRaw::nikon_load_raw ||
          load_raw == &LibRaw::packed_load_raw ||
          load_raw == &LibRaw::nikon_load_padded_packed_raw) &&
 		 makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
         strncmp(imgdata.idata.model, "COOLPIX", 7) &&
         libraw_internal_data.unpacker_data.tiff_bps == 12)
     {
       C.maximum = 4095;
       C.black /= 4;
       for (int c = 0; c < 4; c++)
         C.cblack[c] /= 4;
       for (unsigned c = 0; c < C.cblack[4] * C.cblack[5]; c++)
         C.cblack[6 + c] /= 4;
     }
 
     // Adjust wb_already_applied
     if (load_raw == &LibRaw::nikon_load_sraw)
       imgdata.color.as_shot_wb_applied =
           LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_NIKON_SRAW;
     else if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
              MN.canon.multishot[0] >= 8 &&
              MN.canon.multishot[1] > 0)
       imgdata.color.as_shot_wb_applied =
           LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_CANON;
     else if (makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
              MN.nikon.ExposureMode == 1)
       imgdata.color.as_shot_wb_applied =
           LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_NIKON;
 	else if (makeIs(LIBRAW_CAMERAMAKER_Pentax) &&
              ((MN.pentax.MultiExposure & 0x01) == 1))
       imgdata.color.as_shot_wb_applied =
           LIBRAW_ASWB_APPLIED | LIBRAW_ASWB_PENTAX;
     else
       imgdata.color.as_shot_wb_applied = 0;
 
     // Adjust Highlight Linearity limit
     if (C.linear_max[0] < 0)
     {
       if (imgdata.idata.dng_version)
       {
         for (int c = 0; c < 4; c++)
           C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c + 6];
       }
       else
       {
         for (int c = 0; c < 4; c++)
           C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];
       }
     }
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
 		(!C.linear_max[0]) && (C.maximum > 1024) && (load_raw != &LibRaw::nikon_load_sraw))
     {
       C.linear_max[0] = C.linear_max[1] = C.linear_max[2] = C.linear_max[3] =
           (long)((float)(C.maximum) / 1.07f);
     }
 
     // Correct WB for Samsung GX20
 	if (
 #if 0
         /* GX20 should be corrected, but K20 is not */
         makeIs(LIBRAW_CAMERAMAKER_Pentax) &&
 		!strcasecmp(imgdata.idata.normalized_model, "K20D")
 #endif
 #if 0
 		!strcasecmp(imgdata.idata.make, "Samsung") &&
         !strcasecmp(imgdata.idata.model, "GX20")
 #endif
     makeIs(LIBRAW_CAMERAMAKER_Pentax) &&
     (mnCamID == PentaxID_GX20) // Samsung rebranding
 		)
     {
       for (int cnt = LIBRAW_WBI_Unknown; cnt <= LIBRAW_WBI_StudioTungsten; cnt++) {
         if (C.WB_Coeffs[cnt][1]) {
           C.WB_Coeffs[cnt][0] = (int)((float)(C.WB_Coeffs[cnt][0]) * 1.0503f);
           C.WB_Coeffs[cnt][2] = (int)((float)(C.WB_Coeffs[cnt][2]) * 2.2867f);
         }
       }
       for (int cnt = 0; cnt < 64; cnt++) {
         if (C.WBCT_Coeffs[cnt][0] > 0.0f) {
           C.WBCT_Coeffs[cnt][1] *= 1.0503f;
           C.WBCT_Coeffs[cnt][3] *= 2.2867f;
         }
       }
       for(int cnt = 0; cnt < 4; cnt++)
         imgdata.color.pre_mul[cnt] =
           C.WB_Coeffs[LIBRAW_WBI_Daylight][cnt];
     }
 
     // Adjust BL for Panasonic
     if (load_raw == &LibRaw::panasonic_load_raw &&
 		makeIs(LIBRAW_CAMERAMAKER_Panasonic) &&
         ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])
     {
       if (libraw_internal_data.unpacker_data.pana_encoding == 5)
         libraw_internal_data.internal_output_params.zero_is_bad = 0;
       C.black = 0;
       int add = libraw_internal_data.unpacker_data.pana_encoding == 4 ? 15 : 0;
       C.cblack[0] = ID.pana_black[0] + add;
       C.cblack[1] = C.cblack[3] = ID.pana_black[1] + add;
       C.cblack[2] = ID.pana_black[2] + add;
       unsigned i = C.cblack[3];
       for (int c = 0; c < 3; c++)
         if (i > C.cblack[c])
           i = C.cblack[c];
       for (int c = 0; c < 4; c++)
         C.cblack[c] -= i;
       C.black = i;
     }
 
     // Adjust sizes for X3F processing
 #ifdef USE_X3FTOOLS
 	if (load_raw == &LibRaw::x3f_load_raw)
     {
       for (int i = 0; i < foveon_count; i++)
         if (!strcasecmp(imgdata.idata.make, foveon_data[i].make) &&
             !strcasecmp(imgdata.idata.model, foveon_data[i].model) &&
             imgdata.sizes.raw_width == foveon_data[i].raw_width &&
             imgdata.sizes.raw_height == foveon_data[i].raw_height)
         {
           imgdata.sizes.top_margin = foveon_data[i].top_margin;
           imgdata.sizes.left_margin = foveon_data[i].left_margin;
           imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;
           imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;
           C.maximum = foveon_data[i].white;
           break;
         }
     }
 #endif
 #if 0
     size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;
     float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);
     float bpp2 = float(bytes)/float(S.width)/float(S.height);
     if(!strcasecmp(imgdata.idata.make,"Hasselblad") && bpp == 6.0f)
       {
         load_raw = &LibRaw::hasselblad_full_load_raw;
         S.width = S.raw_width;
         S.height = S.raw_height;
         P1.filters = 0;
         P1.colors=3;
         P1.raw_count=1;
         C.maximum=0xffff;
       }
 #endif
     if (C.profile_length)
     {
       if (C.profile)
         free(C.profile);
       C.profile = malloc(C.profile_length);
       merror(C.profile, "LibRaw::open_file()");
       ID.input->seek(ID.profile_offset, SEEK_SET);
       ID.input->read(C.profile, C.profile_length, 1);
     }
 
     SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);
   }
   catch (const std::bad_alloc&)
   {
       EXCEPTION_HANDLER(LIBRAW_EXCEPTION_ALLOC);
   }
   catch (const LibRaw_exceptions& err)
   {
     EXCEPTION_HANDLER(err);
   }
   catch (const std::exception& ee)
   {
     EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);
   }
diff --git a/src/utils/thumb_utils.cpp b/src/utils/thumb_utils.cpp
index 00af09bd..6a08db92 100644
--- a/src/utils/thumb_utils.cpp
+++ b/src/utils/thumb_utils.cpp
@@ -232,34 +232,39 @@ void LibRaw::kodak_thumb_loader()
 int LibRaw::thumbOK(INT64 maxsz)
 {
   if (!ID.input)
     return 0;
   if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&
                        load_raw == &LibRaw::broadcom_load_raw) // RPi
+#ifdef USE_6BY9RPI
+      && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000 &&
+           (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||
+            load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))
+#endif
   )
     return 0;
   INT64 fsize = ID.input->size();
-  if (fsize > 0x7fffffffU)
-    return 0; // No thumb for raw > 2Gb
+  if (fsize > 0xffffffffU)
+    return 0; // No thumb for raw > 4Gb-1
   int tsize = 0;
   int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;
   if (write_thumb == &LibRaw::jpeg_thumb)
     tsize = T.tlength;
   else if (write_thumb == &LibRaw::ppm_thumb)
     tsize = tcol * T.twidth * T.theight;
   else if (write_thumb == &LibRaw::ppm16_thumb)
     tsize = tcol * T.twidth * T.theight *
             ((imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS) ? 2 : 1);
 #ifdef USE_X3FTOOLS
   else if (write_thumb == &LibRaw::x3f_thumb_loader)
   {
     tsize = x3f_thumb_size();
   }
 #endif
   else // Kodak => no check
     tsize = 1;
   if (tsize < 0)
     return 0;
   if (maxsz > 0 && tsize > maxsz)
     return 0;
   return (tsize + ID.toffset <= fsize) ? 1 : 0;
 }
diff --git a/src/utils/utils_libraw.cpp b/src/utils/utils_libraw.cpp
index 3ca4f27b..f76556d9 100644
--- a/src/utils/utils_libraw.cpp
+++ b/src/utils/utils_libraw.cpp
@@ -612,6 +612,37 @@ short LibRaw::tiff_sget (unsigned save, uchar *buf, unsigned buf_len, INT64 *tag
   return 0;
 }
 
+#define rICC  imgdata.sizes.raw_inset_crops
+#define S imgdata.sizes
+#define RS imgdata.rawdata.sizes
+int LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop)
+
+{
+    int adjindex = -1;
+	int limwidth = S.width * maxcrop;
+	int limheight = S.height * maxcrop;
+
+    for(int i = 1; i >= 0; i--)
+        if (mask & (1<<i))
+            if (rICC[i].ctop < 0xffff && rICC[i].cleft < 0xffff
+                && rICC[i].cleft + rICC[i].cwidth <= S.raw_width
+                && rICC[i].ctop + rICC[i].cheight <= S.raw_height
+				&& rICC[i].cwidth >= limwidth && rICC[i].cheight >= limheight)
+            {
+                adjindex = i;
+                break;
+            }
+
+    if (adjindex >= 0)
+    {
+        RS.left_margin = S.left_margin = rICC[adjindex].cleft;
+        RS.top_margin = S.top_margin = rICC[adjindex].ctop;
+        RS.width = S.width = MIN(rICC[adjindex].cwidth, int(S.raw_width) - int(S.left_margin));
+        RS.height = S.height = MIN(rICC[adjindex].cheight, int(S.raw_height) - int(S.top_margin));
+    }
+    return adjindex + 1;
+}
+
 char** LibRaw::malloc_omp_buffers(int buffer_count, size_t buffer_size, const char* where)
 {
     char** buffers = (char**)malloc(sizeof(char*) * buffer_count);
diff --git a/src/x3f/x3f_parse_process.cpp b/src/x3f/x3f_parse_process.cpp
index 0272fc79..5ac9aa6f 100644
--- a/src/x3f/x3f_parse_process.cpp
+++ b/src/x3f/x3f_parse_process.cpp
@@ -107,190 +107,190 @@ static void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)
 void LibRaw::parse_x3f()
 {
   x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);
   if (!x3f)
     return;
   _x3f_data = x3f;
 
   x3f_header_t *H = NULL;
 
   H = &x3f->header;
   // Parse RAW size from RAW section
   x3f_directory_entry_t *DE = x3f_get_raw(x3f);
   if (!DE)
     return;
   imgdata.sizes.flip = H->rotation;
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
   imgdata.sizes.raw_width = ID->columns;
   imgdata.sizes.raw_height = ID->rows;
   // Parse other params from property section
 
   DE = x3f_get_prop(x3f);
   if ((x3f_load_data(x3f, DE) == X3F_OK))
   {
     // Parse property list
     DEH = &DE->header;
     x3f_property_list_t *PL = &DEH->data_subsection.property_list;
     utf16_t *datap = (utf16_t *)PL->data;
     uint32_t maxitems = PL->data_size / sizeof(utf16_t);
     if (PL->property_table.size != 0)
     {
       int i;
       x3f_property_t *P = PL->property_table.element;
-      for (i = 0; i < PL->num_properties; i++)
+      for (i = 0; i < (int)PL->num_properties; i++)
       {
         char name[100], value[100];
         int noffset = (P[i].name - datap);
         int voffset = (P[i].value - datap);
-        if (noffset < 0 || noffset > maxitems || voffset < 0 ||
-            voffset > maxitems)
+        if (noffset < 0 || noffset > (int)maxitems || voffset < 0 ||
+            voffset > (int)maxitems)
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
         int maxnsize = maxitems - (P[i].name - datap);
         int maxvsize = maxitems - (P[i].value - datap);
-        utf2char(P[i].name, name, MIN(maxnsize, sizeof(name)));
-        utf2char(P[i].value, value, MIN(maxvsize, sizeof(value)));
+        utf2char(P[i].name, name, MIN(maxnsize, ((int)sizeof(name))));
+        utf2char(P[i].value, value, MIN(maxvsize, ((int)sizeof(value))));
         if (!strcmp(name, "ISO"))
           imgdata.other.iso_speed = atoi(value);
         if (!strcmp(name, "CAMMANUF"))
           strcpy(imgdata.idata.make, value);
         if (!strcmp(name, "CAMMODEL"))
           strcpy(imgdata.idata.model, value);
         if (!strcmp(name, "CAMSERIAL"))
           strcpy(imgdata.shootinginfo.BodySerial, value);
         if (!strcmp(name, "WB_DESC"))
           strcpy(imgdata.color.model2, value);
         if (!strcmp(name, "TIME"))
           imgdata.other.timestamp = atoi(value);
         if (!strcmp(name, "SHUTTER"))
           imgdata.other.shutter = atof(value);
         if (!strcmp(name, "APERTURE"))
           imgdata.other.aperture = atof(value);
         if (!strcmp(name, "FLENGTH"))
           imgdata.other.focal_len = atof(value);
         if (!strcmp(name, "FLEQ35MM"))
           imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);
         if (!strcmp(name, "IMAGERTEMP"))
           MN.common.SensorTemperature = atof(value);
         if (!strcmp(name, "LENSARANGE"))
         {
           char *sp;
           imgdata.lens.makernotes.MaxAp4CurFocal =
               imgdata.lens.makernotes.MinAp4CurFocal = atof(value);
           sp = strrchr(value, ' ');
           if (sp)
           {
             imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);
             if (imgdata.lens.makernotes.MaxAp4CurFocal >
                 imgdata.lens.makernotes.MinAp4CurFocal)
               my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal,
                       imgdata.lens.makernotes.MinAp4CurFocal);
           }
         }
         if (!strcmp(name, "LENSFRANGE"))
         {
           char *sp;
           imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal =
               atof(value);
           sp = strrchr(value, ' ');
           if (sp)
           {
             imgdata.lens.makernotes.MaxFocal = atof(sp);
             if ((imgdata.lens.makernotes.MaxFocal + 0.17f) <
                 imgdata.lens.makernotes.MinFocal)
               my_swap(float, imgdata.lens.makernotes.MaxFocal,
                       imgdata.lens.makernotes.MinFocal);
           }
         }
         if (!strcmp(name, "LENSMODEL"))
         {
           char *sp;
           imgdata.lens.makernotes.LensID =
               strtol(value, &sp, 16); // atoi(value);
           if (imgdata.lens.makernotes.LensID)
             imgdata.lens.makernotes.LensMount = Sigma_X3F;
         }
       }
       imgdata.idata.raw_count = 1;
       load_raw = &LibRaw::x3f_load_raw;
       imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;
       imgdata.idata.is_foveon = 1;
       libraw_internal_data.internal_output_params.raw_color =
           1;                          // Force adobe coeff
       imgdata.color.maximum = 0x3fff; // To be reset by color table
       libraw_internal_data.unpacker_data.order = 0x4949;
     }
   }
   else
   {
     // No property list
     if (imgdata.sizes.raw_width == 5888 || imgdata.sizes.raw_width == 2944 ||
         imgdata.sizes.raw_width == 6656 || imgdata.sizes.raw_width == 3328 ||
         imgdata.sizes.raw_width == 5504 ||
         imgdata.sizes.raw_width == 2752) // Quattro
     {
       imgdata.idata.raw_count = 1;
       load_raw = &LibRaw::x3f_load_raw;
       imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;
       imgdata.idata.is_foveon = 1;
       libraw_internal_data.internal_output_params.raw_color =
           1; // Force adobe coeff
       libraw_internal_data.unpacker_data.order = 0x4949;
       strcpy(imgdata.idata.make, "SIGMA");
 #if 1
       // Try to find model number in first 2048 bytes;
       int pos = libraw_internal_data.internal_data.input->tell();
       libraw_internal_data.internal_data.input->seek(0, SEEK_SET);
       unsigned char buf[2048];
       libraw_internal_data.internal_data.input->read(buf, 2048, 1);
       libraw_internal_data.internal_data.input->seek(pos, SEEK_SET);
       unsigned char *fnd = (unsigned char *)lr_memmem(buf, 2048, "SIGMA dp", 8);
       unsigned char *fndsd =
           (unsigned char *)lr_memmem(buf, 2048, "sd Quatt", 8);
       if (fnd)
       {
         unsigned char *nm = fnd + 8;
         snprintf(imgdata.idata.model, 64, "dp%c Quattro",
                  *nm <= '9' && *nm >= '0' ? *nm : '2');
       }
       else if (fndsd)
       {
         snprintf(imgdata.idata.model, 64, "%s", fndsd);
       }
       else
 #endif
           if (imgdata.sizes.raw_width == 6656 ||
               imgdata.sizes.raw_width == 3328)
         strcpy(imgdata.idata.model, "sd Quattro H");
       else
         strcpy(imgdata.idata.model, "dp2 Quattro");
     }
     // else
   }
   // Try to get thumbnail data
   LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;
   if ((DE = x3f_get_thumb_jpeg(x3f)))
   {
     format = LIBRAW_THUMBNAIL_JPEG;
   }
   else if ((DE = x3f_get_thumb_plain(x3f)))
   {
     format = LIBRAW_THUMBNAIL_BITMAP;
   }
   if (DE)
   {
     x3f_directory_entry_header_t *DEH = &DE->header;
     x3f_image_data_t *ID = &DEH->data_subsection.image_data;
     imgdata.thumbnail.twidth = ID->columns;
     imgdata.thumbnail.theight = ID->rows;
     imgdata.thumbnail.tcolors = 3;
     imgdata.thumbnail.tformat = format;
     libraw_internal_data.internal_data.toffset = DE->input.offset;
     write_thumb = &LibRaw::x3f_thumb_loader;
   }
   DE = x3f_get_camf(x3f);
   if (DE && DE->input.size > 28)
   {
     libraw_internal_data.unpacker_data.meta_offset = DE->input.offset + 8;
     libraw_internal_data.unpacker_data.meta_length = DE->input.size - 28;
   }
 }
@@ -321,48 +321,48 @@ INT64 LibRaw::x3f_thumb_size()
 void LibRaw::x3f_thumb_loader()
 {
   try
   {
     x3f_t *x3f = (x3f_t *)_x3f_data;
     if (!x3f)
       return; // No data pointer set
     x3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);
     if (!DE)
       DE = x3f_get_thumb_plain(x3f);
     if (!DE)
       return;
     if (X3F_OK != x3f_load_data(x3f, DE))
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     x3f_directory_entry_header_t *DEH = &DE->header;
     x3f_image_data_t *ID = &DEH->data_subsection.image_data;
     imgdata.thumbnail.twidth = ID->columns;
     imgdata.thumbnail.theight = ID->rows;
     imgdata.thumbnail.tcolors = 3;
     if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)
     {
       imgdata.thumbnail.thumb = (char *)malloc(ID->data_size);
       merror(imgdata.thumbnail.thumb, "LibRaw::x3f_thumb_loader()");
       memmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);
       imgdata.thumbnail.tlength = ID->data_size;
     }
     else if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)
     {
       imgdata.thumbnail.tlength = ID->columns * ID->rows * 3;
       imgdata.thumbnail.thumb = (char *)malloc(ID->columns * ID->rows * 3);
       merror(imgdata.thumbnail.thumb, "LibRaw::x3f_thumb_loader()");
       char *src0 = (char *)ID->data;
-      for (int row = 0; row < ID->rows; row++)
+      for (int row = 0; row < (int)ID->rows; row++)
       {
         int offset = row * ID->row_stride;
         if (offset + ID->columns * 3 > ID->data_size)
           break;
         char *dest = &imgdata.thumbnail.thumb[row * ID->columns * 3];
         char *src = &src0[offset];
         memmove(dest, src, ID->columns * 3);
       }
     }
   }
   catch (...)
   {
     // do nothing
   }
 }
@@ -402,85 +402,85 @@ void LibRaw::x3f_dpq_interpolate_rg()
 void LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)
 {
   unsigned short *image = (ushort *)imgdata.rawdata.color3_image;
   for (int y = 0;
        y < imgdata.rawdata.sizes.height + imgdata.rawdata.sizes.top_margin;
        y += ystep)
   {
     if (y < imgdata.rawdata.sizes.top_margin)
       continue;
     if (y < scale)
       continue;
     if (y > imgdata.rawdata.sizes.raw_height - scale)
       break;
     uint16_t *row0 = &image[imgdata.sizes.raw_width * 3 * y]; // ÐÐ°ÑˆÐ° ÑÑ‚Ñ€Ð¾ÐºÐ°
     uint16_t *row_minus =
         &image[imgdata.sizes.raw_width * 3 * (y - scale)]; // Ð¡Ñ‚Ñ€Ð¾ÐºÐ° Ð²Ñ‹ÑˆÐµ
     uint16_t *row_plus =
         &image[imgdata.sizes.raw_width * 3 * (y + scale)]; // Ð¡Ñ‚Ñ€Ð¾ÐºÐ° Ð½Ð¸Ð¶Ðµ
     for (int x = 0;
          x < imgdata.rawdata.sizes.width + imgdata.rawdata.sizes.left_margin;
          x += xstep)
     {
       if (x < imgdata.rawdata.sizes.left_margin)
         continue;
       if (x < scale)
         continue;
       if (x > imgdata.rawdata.sizes.raw_width - scale)
         break;
       uint16_t *pixel0 = &row0[x * 3];
       uint16_t *pixel_top = &row_minus[x * 3];
       uint16_t *pixel_bottom = &row_plus[x * 3];
       uint16_t *pixel_left = &row0[(x - scale) * 3];
       uint16_t *pixel_right = &row0[(x + scale) * 3];
       uint16_t *pixf = pixel_top;
       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_bottom[2] - pixel0[2]))
         pixf = pixel_bottom;
       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_left[2] - pixel0[2]))
         pixf = pixel_left;
       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_right[2] - pixel0[2]))
         pixf = pixel_right;
       int blocal = pixel0[2], bnear = pixf[2];
-      if (blocal < imgdata.color.black + 16 || bnear < imgdata.color.black + 16)
+      if (blocal < (int)imgdata.color.black + 16 || bnear < (int)imgdata.color.black + 16)
       {
         if (pixel0[0] < imgdata.color.black)
           pixel0[0] = imgdata.color.black;
         if (pixel0[1] < imgdata.color.black)
           pixel0[1] = imgdata.color.black;
         pixel0[0] = CLIP(
             (pixel0[0] - imgdata.color.black) * 4 + imgdata.color.black, 16383);
         pixel0[1] = CLIP(
             (pixel0[1] - imgdata.color.black) * 4 + imgdata.color.black, 16383);
       }
       else
       {
         float multip = float(bnear - imgdata.color.black) /
                        float(blocal - imgdata.color.black);
         if (pixel0[0] < imgdata.color.black)
           pixel0[0] = imgdata.color.black;
         if (pixel0[1] < imgdata.color.black)
           pixel0[1] = imgdata.color.black;
         float pixf0 = pixf[0];
         if (pixf0 < imgdata.color.black)
           pixf0 = imgdata.color.black;
         float pixf1 = pixf[1];
         if (pixf1 < imgdata.color.black)
           pixf1 = imgdata.color.black;
 
         pixel0[0] = CLIP(
             ((float(pixf0 - imgdata.color.black) * multip +
               imgdata.color.black) +
              ((pixel0[0] - imgdata.color.black) * 3.75 + imgdata.color.black)) /
                 2,
             16383);
         pixel0[1] = CLIP(
             ((float(pixf1 - imgdata.color.black) * multip +
               imgdata.color.black) +
              ((pixel0[1] - imgdata.color.black) * 3.75 + imgdata.color.black)) /
                 2,
             16383);
         // pixel0[1] = float(pixf[1]-imgdata.color.black)*multip +
         // imgdata.color.black;
       }
     }
   }
 }
@@ -558,145 +558,145 @@ void LibRaw::x3f_dpq_interpolate_af_sd(int xstart, int ystart, int xend,
 void LibRaw::x3f_load_raw()
 {
   // already in try/catch
   int raise_error = 0;
   x3f_t *x3f = (x3f_t *)_x3f_data;
   if (!x3f)
     return; // No data pointer set
   if (X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))
   {
     x3f_directory_entry_t *DE = x3f_get_raw(x3f);
     x3f_directory_entry_header_t *DEH = &DE->header;
     x3f_image_data_t *ID = &DEH->data_subsection.image_data;
     if (!ID)
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     x3f_quattro_t *Q = ID->quattro;
     x3f_huffman_t *HUF = ID->huffman;
     x3f_true_t *TRU = ID->tru;
     uint16_t *data = NULL;
     if (ID->rows != S.raw_height || ID->columns != S.raw_width)
     {
       raise_error = 1;
       goto end;
     }
     if (HUF != NULL)
       data = HUF->x3rgb16.data;
     if (TRU != NULL)
       data = TRU->x3rgb16.data;
     if (data == NULL)
     {
       raise_error = 1;
       goto end;
     }
 
     size_t datasize = S.raw_height * S.raw_width * 3 * sizeof(unsigned short);
     S.raw_pitch = S.raw_width * 3 * sizeof(unsigned short);
     if (!(imgdata.rawdata.raw_alloc = malloc(datasize)))
       throw LIBRAW_EXCEPTION_ALLOC;
 
     imgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;
     // swap R/B channels for known old cameras
     if (!strcasecmp(P1.make, "Polaroid") && !strcasecmp(P1.model, "x530"))
     {
       ushort(*src)[3] = (ushort(*)[3])data;
       for (int p = 0; p < S.raw_height * S.raw_width; p++)
       {
         imgdata.rawdata.color3_image[p][0] = src[p][2];
         imgdata.rawdata.color3_image[p][1] = src[p][1];
         imgdata.rawdata.color3_image[p][2] = src[p][0];
       }
     }
     else if (HUF)
       memmove(imgdata.rawdata.raw_alloc, data, datasize);
     else if (TRU && (!Q || !Q->quattro_layout))
       memmove(imgdata.rawdata.raw_alloc, data, datasize);
     else if (TRU && Q)
     {
       // Move quattro data in place
       // R/B plane
-      for (int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height / 2;
+      for (int prow = 0; prow < (int)TRU->x3rgb16.rows && prow < S.raw_height / 2;
            prow++)
       {
         ushort(*destrow)[3] =
             (unsigned short(*)[3]) &
             imgdata.rawdata
                 .color3_image[prow * 2 * S.raw_pitch / 3 / sizeof(ushort)][0];
         ushort(*srcrow)[3] =
             (unsigned short(*)[3]) & data[prow * TRU->x3rgb16.row_stride];
         for (int pcol = 0;
-             pcol < TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)
+             pcol < (int)TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)
         {
           destrow[pcol * 2][0] = srcrow[pcol][0];
           destrow[pcol * 2][1] = srcrow[pcol][1];
         }
       }
-      for (int row = 0; row < Q->top16.rows && row < S.raw_height; row++)
+      for (int row = 0; row < (int)Q->top16.rows && row < S.raw_height; row++)
       {
         ushort(*destrow)[3] =
             (unsigned short(*)[3]) &
             imgdata.rawdata
                 .color3_image[row * S.raw_pitch / 3 / sizeof(ushort)][0];
-        ushort(*srcrow) =
+        ushort *srcrow =
             (unsigned short *)&Q->top16.data[row * Q->top16.columns];
-        for (int col = 0; col < Q->top16.columns && col < S.raw_width; col++)
+        for (int col = 0; col < (int)Q->top16.columns && col < S.raw_width; col++)
           destrow[col][2] = srcrow[col];
       }
     }
 
 #if 1
     if (TRU && Q &&
         !(imgdata.rawparams.specials & LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATEAF))
     {
       if (imgdata.sizes.raw_width == 5888 &&
           imgdata.sizes.raw_height == 3672) // dpN Quattro normal
       {
         x3f_dpq_interpolate_af(32, 8, 2);
       }
       else if (imgdata.sizes.raw_width == 5888 &&
                imgdata.sizes.raw_height == 3776) // sd Quattro normal raw
       {
         x3f_dpq_interpolate_af_sd(216, 464, imgdata.sizes.raw_width - 1, 3312,
                                   16, 32, 2);
       }
       else if (imgdata.sizes.raw_width == 6656 &&
                imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw
       {
         x3f_dpq_interpolate_af_sd(232, 592, imgdata.sizes.raw_width - 1, 3920,
                                   16, 32, 2);
       }
       else if (imgdata.sizes.raw_width == 3328 &&
                imgdata.sizes.raw_height == 2240) // sd Quattro H half size
       {
         x3f_dpq_interpolate_af_sd(116, 296, imgdata.sizes.raw_width - 1, 2200,
                                   8, 16, 1);
       }
       else if (imgdata.sizes.raw_width == 5504 &&
                imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw
       {
         x3f_dpq_interpolate_af_sd(8, 192, imgdata.sizes.raw_width - 1, 3185, 16,
                                   32, 2);
       }
       else if (imgdata.sizes.raw_width == 2752 &&
                imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size
       {
         x3f_dpq_interpolate_af_sd(4, 96, imgdata.sizes.raw_width - 1, 1800, 8,
                                   16, 1);
       }
       else if (imgdata.sizes.raw_width == 2944 &&
                imgdata.sizes.raw_height == 1836) // dpN Quattro small raw
       {
         x3f_dpq_interpolate_af(16, 4, 1);
       }
       else if (imgdata.sizes.raw_width == 2944 &&
                imgdata.sizes.raw_height == 1888) // sd Quattro small
       {
         x3f_dpq_interpolate_af_sd(108, 232, imgdata.sizes.raw_width - 1, 1656,
                                   8, 16, 1);
       }
     }
 #endif
     if (TRU && Q && Q->quattro_layout &&
         !(imgdata.rawparams.specials & LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATERG))
       x3f_dpq_interpolate_rg();
   }
   else
     raise_error = 1;
diff --git a/src/x3f/x3f_utils_patched.cpp b/src/x3f/x3f_utils_patched.cpp
index 53e02cc3..a84b8be9 100644
--- a/src/x3f/x3f_utils_patched.cpp
+++ b/src/x3f/x3f_utils_patched.cpp
@@ -73,103 +73,103 @@ unsigned x3f_sget4(uchar *s)
 unsigned x3f_get4(LibRaw_abstract_datastream *f)
 {
   uchar str[4] = {0xff, 0xff, 0xff, 0xff};
   f->read(str, 1, 4);
   return x3f_sget4(str);
 }
 
 #define FREE(P)                                                                \
   do                                                                           \
   {                                                                            \
     free(P);                                                                   \
     (P) = NULL;                                                                \
   } while (0)
 
 #define PUT_GET_N(_buffer, _size, _file, _func)                                \
   do                                                                           \
   {                                                                            \
     int _left = _size;                                                         \
     while (_left != 0)                                                         \
     {                                                                          \
       int _cur = _file->_func(_buffer, 1, _left);                              \
       if (_cur == 0)                                                           \
       {                                                                        \
         throw LIBRAW_EXCEPTION_IO_CORRUPT;                                     \
       }                                                                        \
       _left -= _cur;                                                           \
     }                                                                          \
   } while (0)
 
 #define GET1(_v)                                                               \
   do                                                                           \
   {                                                                            \
     (_v) = x3f_get1(I->input.file);                                            \
   } while (0)
 #define GET2(_v)                                                               \
   do                                                                           \
   {                                                                            \
     (_v) = x3f_get2(I->input.file);                                            \
   } while (0)
 #define GET4(_v)                                                               \
   do                                                                           \
   {                                                                            \
     (_v) = x3f_get4(I->input.file);                                            \
   } while (0)
 
 #define GET4F(_v)                                                              \
   do                                                                           \
   {                                                                            \
     union {                                                                    \
       int32_t i;                                                               \
       float f;                                                                 \
     } _tmp;                                                                    \
     _tmp.i = x3f_get4(I->input.file);                                          \
     (_v) = _tmp.f;                                                             \
   } while (0)
 
 #define GETN(_v, _s) PUT_GET_N(_v, _s, I->input.file, read)
 
 #define GET_TABLE(_T, _GETX, _NUM, _TYPE)                                      \
   do                                                                           \
   {                                                                            \
     int _i;                                                                    \
     (_T).size = (_NUM);                                                        \
     (_T).element =                                                             \
         (_TYPE *)realloc((_T).element, (_NUM) * sizeof((_T).element[0]));      \
-    for (_i = 0; _i < (_T).size; _i++)                                         \
+    for (_i = 0; _i < (int)(_T).size; _i++)                                         \
       _GETX((_T).element[_i]);                                                 \
   } while (0)
 
 #define GET_PROPERTY_TABLE(_T, _NUM)                                           \
   do                                                                           \
   {                                                                            \
     int _i;                                                                    \
     (_T).size = (_NUM);                                                        \
     (_T).element = (x3f_property_t *)realloc(                                  \
         (_T).element, (_NUM) * sizeof((_T).element[0]));                       \
-    for (_i = 0; _i < (_T).size; _i++)                                         \
+    for (_i = 0; _i < (int)(_T).size; _i++)                                         \
     {                                                                          \
       GET4((_T).element[_i].name_offset);                                      \
       GET4((_T).element[_i].value_offset);                                     \
     }                                                                          \
   } while (0)
 
 #define GET_TRUE_HUFF_TABLE(_T)                                                \
   do                                                                           \
   {                                                                            \
     int _i;                                                                    \
     (_T).element = NULL;                                                       \
     for (_i = 0;; _i++)                                                        \
     {                                                                          \
       (_T).size = _i + 1;                                                      \
       (_T).element = (x3f_true_huffman_element_t *)realloc(                    \
           (_T).element, (_i + 1) * sizeof((_T).element[0]));                   \
       GET1((_T).element[_i].code_size);                                        \
       GET1((_T).element[_i].code);                                             \
       if ((_T).element[_i].code_size == 0)                                     \
         break;                                                                 \
     }                                                                          \
   } while (0)
 
 /* --------------------------------------------------------------------- */
 /* Allocating Huffman tree help data                                   */
 /* --------------------------------------------------------------------- */
@@ -287,221 +287,221 @@ static void cleanup_huffman(x3f_huffman_t **HUFP)
 static x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)
 {
   x3f_huffman_t *HUF = (x3f_huffman_t *)calloc(1, sizeof(x3f_huffman_t));
 
   cleanup_huffman(HUFP);
 
   /* Set all not read data block pointers to NULL */
   HUF->mapping.size = 0;
   HUF->mapping.element = NULL;
   HUF->table.size = 0;
   HUF->table.element = NULL;
   HUF->tree.nodes = NULL;
   HUF->row_offsets.size = 0;
   HUF->row_offsets.element = NULL;
   HUF->rgb8.data = NULL;
   HUF->rgb8.buf = NULL;
   HUF->x3rgb16.data = NULL;
   HUF->x3rgb16.buf = NULL;
 
   *HUFP = HUF;
 
   return HUF;
 }
 
 /* --------------------------------------------------------------------- */
 /* Creating a new x3f structure from file                                */
 /* --------------------------------------------------------------------- */
 
 /* extern */ x3f_t *x3f_new_from_file(LibRaw_abstract_datastream *infile)
 {
   if (!infile)
     return NULL;
   INT64 fsize = infile->size();
   x3f_t *x3f = (x3f_t *)calloc(1, sizeof(x3f_t));
   if (!x3f)
     throw LIBRAW_EXCEPTION_ALLOC;
   try
   {
     x3f_info_t *I = NULL;
     x3f_header_t *H = NULL;
     x3f_directory_section_t *DS = NULL;
     int i, d;
 
     I = &x3f->info;
     I->error = NULL;
     I->input.file = infile;
     I->output.file = NULL;
 
     /* Read file header */
     H = &x3f->header;
     infile->seek(0, SEEK_SET);
     GET4(H->identifier);
 
     if (H->identifier != X3F_FOVb)
     {
       free(x3f);
       return NULL;
     }
 
     GET4(H->version);
     GETN(H->unique_identifier, SIZE_UNIQUE_IDENTIFIER);
     /* TODO: the meaning of the rest of the header for version >= 4.0 (Quattro)
      * is unknown */
     if (H->version < X3F_VERSION_4_0)
     {
       GET4(H->mark_bits);
       GET4(H->columns);
       GET4(H->rows);
       GET4(H->rotation);
       if (H->version >= X3F_VERSION_2_1)
       {
         int num_ext_data =
             H->version >= X3F_VERSION_3_0 ? NUM_EXT_DATA_3_0 : NUM_EXT_DATA_2_1;
 
         GETN(H->white_balance, SIZE_WHITE_BALANCE);
         if (H->version >= X3F_VERSION_2_3)
           GETN(H->color_mode, SIZE_COLOR_MODE);
         GETN(H->extended_types, num_ext_data);
         for (i = 0; i < num_ext_data; i++)
           GET4F(H->extended_data[i]);
       }
     }
 
     /* Go to the beginning of the directory */
     infile->seek(-4, SEEK_END);
     infile->seek(x3f_get4(infile), SEEK_SET);
 
     /* Read the directory header */
     DS = &x3f->directory_section;
     GET4(DS->identifier);
     GET4(DS->version);
     GET4(DS->num_directory_entries);
 
     if (DS->num_directory_entries > 50)
       goto _err; // too much direntries, most likely broken file
 
     if (DS->num_directory_entries > 0)
     {
       size_t size = DS->num_directory_entries * sizeof(x3f_directory_entry_t);
       DS->directory_entry = (x3f_directory_entry_t *)calloc(1, size);
     }
 
     /* Traverse the directory */
-    for (d = 0; d < DS->num_directory_entries; d++)
+    for (d = 0; d < (int)DS->num_directory_entries; d++)
     {
       x3f_directory_entry_t *DE = &DS->directory_entry[d];
       x3f_directory_entry_header_t *DEH = &DE->header;
       uint32_t save_dir_pos;
 
       /* Read the directory entry info */
       GET4(DE->input.offset);
       GET4(DE->input.size);
       if (DE->input.offset + DE->input.size > fsize * 2)
         goto _err;
 
       DE->output.offset = 0;
       DE->output.size = 0;
 
       GET4(DE->type);
 
       /* Save current pos and go to the entry */
       save_dir_pos = infile->tell();
       infile->seek(DE->input.offset, SEEK_SET);
 
       /* Read the type independent part of the entry header */
       DEH = &DE->header;
       GET4(DEH->identifier);
       GET4(DEH->version);
 
       /* NOTE - the tests below could be made on DE->type instead */
 
       if (DEH->identifier == X3F_SECp)
       {
         x3f_property_list_t *PL = &DEH->data_subsection.property_list;
         if (!PL)
           goto _err;
         /* Read the property part of the header */
         GET4(PL->num_properties);
         GET4(PL->character_format);
         GET4(PL->reserved);
         GET4(PL->total_length);
 
         /* Set all not read data block pointers to NULL */
         PL->data = NULL;
         PL->data_size = 0;
       }
 
       if (DEH->identifier == X3F_SECi)
       {
         x3f_image_data_t *ID = &DEH->data_subsection.image_data;
         if (!ID)
           goto _err;
         /* Read the image part of the header */
         GET4(ID->type);
         GET4(ID->format);
         ID->type_format = (ID->type << 16) + (ID->format);
         GET4(ID->columns);
         GET4(ID->rows);
         GET4(ID->row_stride);
 
         /* Set all not read data block pointers to NULL */
         ID->huffman = NULL;
 
         ID->data = NULL;
         ID->data_size = 0;
       }
 
       if (DEH->identifier == X3F_SECc)
       {
         x3f_camf_t *CAMF = &DEH->data_subsection.camf;
         if (!CAMF)
           goto _err;
         /* Read the CAMF part of the header */
         GET4(CAMF->type);
         GET4(CAMF->tN.val0);
         GET4(CAMF->tN.val1);
         GET4(CAMF->tN.val2);
         GET4(CAMF->tN.val3);
 
         /* Set all not read data block pointers to NULL */
         CAMF->data = NULL;
         CAMF->data_size = 0;
 
         /* Set all not allocated help pointers to NULL */
         CAMF->table.element = NULL;
         CAMF->table.size = 0;
         CAMF->tree.nodes = NULL;
         CAMF->decoded_data = NULL;
         CAMF->decoded_data_size = 0;
         CAMF->entry_table.element = NULL;
         CAMF->entry_table.size = 0;
       }
 
       /* Reset the file pointer back to the directory */
       infile->seek(save_dir_pos, SEEK_SET);
     }
 
     return x3f;
   _err:
     if (x3f)
     {
       DS = &x3f->directory_section;
       if (DS && DS->directory_entry)
         free(DS->directory_entry);
       free(x3f);
     }
     return NULL;
   }
   catch (...)
   {
     x3f_directory_section_t *DS = &x3f->directory_section;
     if (DS && DS->directory_entry)
       free(DS->directory_entry);
     free(x3f);
     return NULL;
   }
 }
 
 /* --------------------------------------------------------------------- */
 /* Clean up an x3f structure                                             */
 /* --------------------------------------------------------------------- */
@@ -509,74 +509,74 @@ static x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)
 static void free_camf_entry(camf_entry_t *entry)
 {
   FREE(entry->property_name);
   FREE(entry->property_value);
   FREE(entry->matrix_decoded);
   FREE(entry->matrix_dim_entry);
 }
 
 /* extern */ x3f_return_t x3f_delete(x3f_t *x3f)
 {
   x3f_directory_section_t *DS;
   int d;
 
   if (x3f == NULL)
     return X3F_ARGUMENT_ERROR;
 
   DS = &x3f->directory_section;
   if (DS->num_directory_entries > 50)
     return X3F_ARGUMENT_ERROR;
 
-  for (d = 0; d < DS->num_directory_entries; d++)
+  for (d = 0; d < (int)DS->num_directory_entries; d++)
   {
     x3f_directory_entry_t *DE = &DS->directory_entry[d];
     x3f_directory_entry_header_t *DEH = &DE->header;
     if (DEH->identifier == X3F_SECp)
     {
       x3f_property_list_t *PL = &DEH->data_subsection.property_list;
       FREE(PL->property_table.element);
       FREE(PL->data);
     }
 
     if (DEH->identifier == X3F_SECi)
     {
       x3f_image_data_t *ID = &DEH->data_subsection.image_data;
 
       if (ID)
       {
         cleanup_huffman(&ID->huffman);
         cleanup_true(&ID->tru);
         cleanup_quattro(&ID->quattro);
         FREE(ID->data);
       }
     }
 
     if (DEH->identifier == X3F_SECc)
     {
       x3f_camf_t *CAMF = &DEH->data_subsection.camf;
       int i;
       if (CAMF)
       {
         FREE(CAMF->data);
         FREE(CAMF->table.element);
         cleanup_huffman_tree(&CAMF->tree);
         FREE(CAMF->decoded_data);
-        for (i = 0; i < CAMF->entry_table.size; i++)
+        for (i = 0; i < (int)CAMF->entry_table.size; i++)
         {
           free_camf_entry(&CAMF->entry_table.element[i]);
         }
       }
       FREE(CAMF->entry_table.element);
     }
   }
 
   FREE(DS->directory_entry);
   FREE(x3f);
 
   return X3F_OK;
 }
 
 /* --------------------------------------------------------------------- */
 /* Getting a reference to a directory entry                              */
 /* --------------------------------------------------------------------- */
 
 /* TODO: all those only get the first instance */
@@ -584,108 +584,108 @@ static void free_camf_entry(camf_entry_t *entry)
 static x3f_directory_entry_t *x3f_get(x3f_t *x3f, uint32_t type,
                                       uint32_t image_type)
 {
   x3f_directory_section_t *DS;
   int d;
 
   if (x3f == NULL)
     return NULL;
 
   DS = &x3f->directory_section;
 
-  for (d = 0; d < DS->num_directory_entries; d++)
+  for (d = 0; d < (int)DS->num_directory_entries; d++)
   {
     x3f_directory_entry_t *DE = &DS->directory_entry[d];
     x3f_directory_entry_header_t *DEH = &DE->header;
 
     if (DEH->identifier == type)
     {
       switch (DEH->identifier)
       {
       case X3F_SECi:
       {
         x3f_image_data_t *ID = &DEH->data_subsection.image_data;
 
         if (ID->type_format == image_type)
           return DE;
       }
       break;
       default:
         return DE;
       }
     }
   }
 
   return NULL;
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_raw(x3f_t *x3f)
 {
   x3f_directory_entry_t *DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_X530)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_HUFFMAN_10BIT)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_TRUE)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_MERRILL)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_QUATTRO)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQ)) != NULL)
     return DE;
 
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH)) != NULL)
     return DE;
   if ((DE = x3f_get(x3f, X3F_SECi, X3F_IMAGE_RAW_SDQH2)) != NULL)
     return DE;
 
   return NULL;
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_thumb_plain(x3f_t *x3f)
 {
   return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_PLAIN);
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_thumb_huffman(x3f_t *x3f)
 {
   return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_HUFFMAN);
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_thumb_jpeg(x3f_t *x3f)
 {
   return x3f_get(x3f, X3F_SECi, X3F_IMAGE_THUMB_JPEG);
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_camf(x3f_t *x3f)
 {
   return x3f_get(x3f, X3F_SECc, 0);
 }
 
 /* extern */ x3f_directory_entry_t *x3f_get_prop(x3f_t *x3f)
 {
   return x3f_get(x3f, X3F_SECp, 0);
 }
 
 /* For some obscure reason, the bit numbering is weird. It is
    generally some kind of "big endian" style - e.g. the bit 7 is the
    first in a byte and bit 31 first in a 4 byte int. For patterns in
    the huffman pattern table, bit 27 is the first bit and bit 26 the
    next one. */
 
 #define PATTERN_BIT_POS(_len, _bit) ((_len) - (_bit)-1)
 #define MEMORY_BIT_POS(_bit) PATTERN_BIT_POS(8, _bit)
 
 /* --------------------------------------------------------------------- */
 /* Huffman Decode                                                        */
 /* --------------------------------------------------------------------- */
 
 /* Make the huffman tree */
 
 #ifdef DBG_PRNT
@@ -745,32 +745,32 @@ static void add_code_to_tree(x3f_hufftree_t *tree, int length, uint32_t code,
 static void populate_true_huffman_tree(x3f_hufftree_t *tree,
                                        x3f_true_huffman_t *table)
 {
   int i;
 
   new_node(tree);
 
-  for (i = 0; i < table->size; i++)
+  for (i = 0; i < (int)table->size; i++)
   {
     x3f_true_huffman_element_t *element = &table->element[i];
     uint32_t length = element->code_size;
 
     if (length != 0)
     {
       /* add_code_to_tree wants the code right adjusted */
       uint32_t code = ((element->code) >> (8 - length)) & 0xff;
       uint32_t value = i;
 
       add_code_to_tree(tree, length, code, value);
 
 #ifdef DBG_PRNT
       {
         char buffer[100];
 
         x3f_printf(DEBUG, "H %5d : %5x : %5d : %02x %08x (%08x) (%s)\n", i, i,
                    value, length, code, value,
                    display_code(length, code, buffer));
       }
 #endif
     }
   }
 }
@@ -778,41 +778,41 @@ static void populate_true_huffman_tree(x3f_hufftree_t *tree,
 static void populate_huffman_tree(x3f_hufftree_t *tree, x3f_table32_t *table,
                                   x3f_table16_t *mapping)
 {
   int i;
 
   new_node(tree);
 
-  for (i = 0; i < table->size; i++)
+  for (i = 0; i < (int)table->size; i++)
   {
     uint32_t element = table->element[i];
 
     if (element != 0)
     {
       uint32_t length = HUF_TREE_GET_LENGTH(element);
       uint32_t code = HUF_TREE_GET_CODE(element);
       uint32_t value;
 
       /* If we have a valid mapping table - then the value from the
          mapping table shall be used. Otherwise we use the current
          index in the table as value. */
       if (table->size == mapping->size)
         value = mapping->element[i];
       else
         value = i;
 
       add_code_to_tree(tree, length, code, value);
 
 #ifdef DBG_PRNT
       {
         char buffer[100];
 
         x3f_printf(DEBUG, "H %5d : %5x : %5d : %02x %08x (%08x) (%s)\n", i, i,
                    value, length, code, element,
                    display_code(length, code, buffer));
       }
 #endif
     }
   }
 }
 
 #ifdef DBG_PRNT
@@ -926,70 +926,70 @@ static int32_t get_true_diff(bit_state_t *BS, x3f_hufftree_t *HTP)
 static void true_decode_one_color(x3f_image_data_t *ID, int color)
 {
   x3f_true_t *TRU = ID->tru;
   x3f_quattro_t *Q = ID->quattro;
   uint32_t seed = TRU->seed[color]; /* TODO : Is this correct ? */
   int row;
 
   x3f_hufftree_t *tree = &TRU->tree;
   bit_state_t BS;
 
   int32_t row_start_acc[2][2];
   uint32_t rows = ID->rows;
   uint32_t cols = ID->columns;
   x3f_area16_t *area = &TRU->x3rgb16;
   uint16_t *dst = area->data + color;
 
   set_bit_state(&BS, TRU->plane_address[color]);
 
   row_start_acc[0][0] = seed;
   row_start_acc[0][1] = seed;
   row_start_acc[1][0] = seed;
   row_start_acc[1][1] = seed;
 
   if (ID->type_format == X3F_IMAGE_RAW_QUATTRO ||
       ID->type_format == X3F_IMAGE_RAW_SDQ ||
       ID->type_format == X3F_IMAGE_RAW_SDQH ||
       ID->type_format == X3F_IMAGE_RAW_SDQH2)
   {
     rows = Q->plane[color].rows;
     cols = Q->plane[color].columns;
 
     if (Q->quattro_layout && color == 2)
     {
       area = &Q->top16;
       dst = area->data;
     }
   }
   else
   {
   }
 
   if (rows != area->rows || cols < area->columns)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
-  for (row = 0; row < rows; row++)
+  for (row = 0; row < (int)rows; row++)
   {
     int col;
     bool_t odd_row = row & 1;
     int32_t acc[2];
 
-    for (col = 0; col < cols; col++)
+    for (col = 0; col < (int)cols; col++)
     {
       bool_t odd_col = col & 1;
       int32_t diff = get_true_diff(&BS, tree);
       int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];
       int32_t value = prev + diff;
 
       acc[odd_col] = value;
       if (col < 2)
         row_start_acc[odd_row][odd_col] = value;
 
       /* Discard additional data at the right for binned Quattro plane 2 */
-      if (col >= area->columns)
+      if (col >= (int)area->columns)
         continue;
 
       *dst = value;
       dst += area->channels;
     }
   }
 }
@@ -1035,52 +1035,52 @@ static int32_t get_huffman_diff(bit_state_t *BS, x3f_hufftree_t *HTP)
 static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
                                int bits, int row, int offset, int *minimum)
 {
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
   x3f_huffman_t *HUF = ID->huffman;
 
   int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};
   int col;
   bit_state_t BS;
 
   if (HUF->row_offsets.element[row] > ID->data_size - 1)
 	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
   set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);
 
-  for (col = 0; col < ID->columns; col++)
+  for (col = 0; col < (int)ID->columns; col++)
   {
     int color;
 
     for (color = 0; color < 3; color++)
     {
       uint16_t c_fix;
 
       c[color] += get_huffman_diff(&BS, &HUF->tree);
       if (c[color] < 0)
       {
         c_fix = 0;
         if (c[color] < *minimum)
           *minimum = c[color];
       }
       else
       {
         c_fix = c[color];
       }
 
       switch (ID->type_format)
       {
       case X3F_IMAGE_RAW_HUFFMAN_X530:
       case X3F_IMAGE_RAW_HUFFMAN_10BIT:
         HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =
             (uint16_t)c_fix;
         break;
       case X3F_IMAGE_THUMB_HUFFMAN:
         HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;
         break;
       default:
         /* TODO: Shouldn't this be treated as a fatal error? */
         throw LIBRAW_EXCEPTION_IO_CORRUPT;
       }
     }
   }
 }
@@ -1088,19 +1088,19 @@ static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
 static void huffman_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits)
 {
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
 
   int row;
   int minimum = 0;
   int offset = legacy_offset;
 
-  for (row = 0; row < ID->rows; row++)
+  for (row = 0; row < (int)ID->rows; row++)
     huffman_decode_row(I, DE, bits, row, offset, &minimum);
 
   if (auto_legacy_offset && minimum < 0)
   {
     offset = -minimum;
-    for (row = 0; row < ID->rows; row++)
+    for (row = 0; row < (int)ID->rows; row++)
       huffman_decode_row(I, DE, bits, row, offset, &minimum);
   }
 }
@@ -1116,70 +1116,70 @@ static int32_t get_simple_diff(x3f_huffman_t *HUF, uint16_t index)
 static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
                               int bits, int row, int row_stride)
 {
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
   x3f_huffman_t *HUF = ID->huffman;
 
-  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))
+  if (row*row_stride > (int)(ID->data_size - (ID->columns*sizeof(uint32_t))))
 	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
   uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);
 
   uint16_t c[3] = {0, 0, 0};
   int col;
 
   uint32_t mask = 0;
 
   switch (bits)
   {
   case 8:
     mask = 0x0ff;
     break;
   case 9:
     mask = 0x1ff;
     break;
   case 10:
     mask = 0x3ff;
     break;
   case 11:
     mask = 0x7ff;
     break;
   case 12:
     mask = 0xfff;
     break;
   default:
     mask = 0;
     /* TODO: Shouldn't this be treated as a fatal error? */
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
     break;
   }
 
-  for (col = 0; col < ID->columns; col++)
+  for (col = 0; col < (int)ID->columns; col++)
   {
     int color;
     uint32_t val = data[col];
 
     for (color = 0; color < 3; color++)
     {
       uint16_t c_fix;
       c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);
 
       switch (ID->type_format)
       {
       case X3F_IMAGE_RAW_HUFFMAN_X530:
       case X3F_IMAGE_RAW_HUFFMAN_10BIT:
         c_fix = (int16_t)c[color] > 0 ? c[color] : 0;
 
         HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;
         break;
       case X3F_IMAGE_THUMB_HUFFMAN:
         c_fix = (int8_t)c[color] > 0 ? c[color] : 0;
 
         HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;
         break;
       default:
         /* TODO: Shouldn't this be treated as a fatal error? */
         throw LIBRAW_EXCEPTION_IO_CORRUPT;
       }
     }
   }
 }
@@ -1187,17 +1187,17 @@ static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
 static void simple_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,
                           int row_stride)
 {
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
 
   int row;
 
-  for (row = 0; row < ID->rows; row++)
+  for (row = 0; row < (int)ID->rows; row++)
     simple_decode_row(I, DE, bits, row, row_stride);
 }
 
 /* --------------------------------------------------------------------- */
 /* Loading the data in a directory entry                                 */
 /* --------------------------------------------------------------------- */
 
 /* First you set the offset to where to start reading the data ... */
@@ -1255,24 +1255,24 @@ static int32_t x3f_load_image_verbatim_size(x3f_info_t *I,
 static void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)
 {
   x3f_directory_entry_header_t *DEH = &DE->header;
   x3f_property_list_t *PL = &DEH->data_subsection.property_list;
   int i;
 
   read_data_set_offset(I, DE, X3F_PROPERTY_LIST_HEADER_SIZE);
 
   GET_PROPERTY_TABLE(PL->property_table, PL->num_properties);
 
   if (!PL->data_size)
     PL->data_size = read_data_block(&PL->data, I, DE, 0);
   uint32_t maxoffset = PL->data_size / sizeof(utf16_t) -
                        2; // at least 2 chars, value + terminating 0x0000
 
-  for (i = 0; i < PL->num_properties; i++)
+  for (i = 0; i < (int)PL->num_properties; i++)
   {
     x3f_property_t *P = &PL->property_table.element[i];
     if (P->name_offset > maxoffset || P->value_offset > maxoffset)
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     P->name = ((utf16_t *)PL->data + P->name_offset);
     P->value = ((utf16_t *)PL->data + P->value_offset);
   }
 }
@@ -1558,26 +1558,26 @@ static uint32_t x3f_load_image_size(x3f_info_t *I, x3f_directory_entry_t *DE)
 static void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)
 {
   uint32_t key = CAMF->t2.crypt_key;
   int i;
 
   CAMF->decoded_data_size = CAMF->data_size;
   CAMF->decoded_data = malloc(CAMF->decoded_data_size);
 
-  for (i = 0; i < CAMF->data_size; i++)
+  for (i = 0; i < (int)CAMF->data_size; i++)
   {
     uint8_t old, _new;
     uint32_t tmp;
 
     old = ((uint8_t *)CAMF->data)[i];
     key = (key * 1597 + 51749) % 244944;
     tmp = (uint32_t)(key * ((int64_t)301593171) >> 24);
     _new = (uint8_t)(old ^ (uint8_t)(((((key << 8) - tmp) >> 1) + tmp) >> 17));
     ((uint8_t *)CAMF->decoded_data)[i] = _new;
   }
 }
 
 /* NOTE: the unpacking in this code is in big respects identical to
    true_decode_one_color(). The difference is in the output you
    build. It might be possible to make some parts shared. NOTE ALSO:
    This means that the meta data is obfuscated using an image
    compression algorithm. */
@@ -1585,86 +1585,86 @@ static void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)
 static void camf_decode_type4(x3f_camf_t *CAMF)
 {
   uint32_t seed = CAMF->t4.decode_bias;
   int row;
 
   uint8_t *dst;
   uint32_t dst_size = CAMF->t4.decoded_data_size;
   uint8_t *dst_end;
 
   bool_t odd_dst = 0;
 
   x3f_hufftree_t *tree = &CAMF->tree;
   bit_state_t BS;
 
   int32_t row_start_acc[2][2];
   uint32_t rows = CAMF->t4.block_count;
   uint32_t cols = CAMF->t4.block_size;
 
   CAMF->decoded_data_size = dst_size;
 
   CAMF->decoded_data = malloc(CAMF->decoded_data_size);
   memset(CAMF->decoded_data, 0, CAMF->decoded_data_size);
 
   dst = (uint8_t *)CAMF->decoded_data;
   dst_end = dst + dst_size;
 
   set_bit_state(&BS, CAMF->decoding_start);
 
   row_start_acc[0][0] = seed;
   row_start_acc[0][1] = seed;
   row_start_acc[1][0] = seed;
   row_start_acc[1][1] = seed;
 
-  for (row = 0; row < rows; row++)
+  for (row = 0; row < (int)rows; row++)
   {
     int col;
     bool_t odd_row = row & 1;
     int32_t acc[2];
 
     /* We loop through all the columns and the rows. But the actual
        data is smaller than that, so we break the loop when reaching
        the end. */
-    for (col = 0; col < cols; col++)
+    for (col = 0; col < (int)cols; col++)
     {
       bool_t odd_col = col & 1;
       int32_t diff = get_true_diff(&BS, tree);
       int32_t prev = col < 2 ? row_start_acc[odd_row][odd_col] : acc[odd_col];
       int32_t value = prev + diff;
 
       acc[odd_col] = value;
       if (col < 2)
         row_start_acc[odd_row][odd_col] = value;
 
       switch (odd_dst)
       {
       case 0:
         *dst++ = (uint8_t)((value >> 4) & 0xff);
 
         if (dst >= dst_end)
         {
           goto ready;
         }
 
         *dst = (uint8_t)((value << 4) & 0xf0);
         break;
       case 1:
         *dst++ |= (uint8_t)((value >> 8) & 0x0f);
 
         if (dst >= dst_end)
         {
           goto ready;
         }
 
         *dst++ = (uint8_t)((value << 0) & 0xff);
 
         if (dst >= dst_end)
         {
           goto ready;
         }
 
         break;
       }
 
       odd_dst = !odd_dst;
     } /* end col */
   }   /* end row */
@@ -1713,26 +1713,26 @@ static void x3f_load_camf_decode_type4(x3f_camf_t *CAMF)
 static void camf_decode_type5(x3f_camf_t *CAMF)
 {
   int32_t acc = CAMF->t5.decode_bias;
 
   uint8_t *dst;
 
   x3f_hufftree_t *tree = &CAMF->tree;
   bit_state_t BS;
 
   int32_t i;
 
   CAMF->decoded_data_size = CAMF->t5.decoded_data_size;
   CAMF->decoded_data = malloc(CAMF->decoded_data_size);
 
   dst = (uint8_t *)CAMF->decoded_data;
 
   set_bit_state(&BS, CAMF->decoding_start);
 
-  for (i = 0; i < CAMF->decoded_data_size; i++)
+  for (i = 0; i < (int)CAMF->decoded_data_size; i++)
   {
     int32_t diff = get_true_diff(&BS, tree);
 
     acc = acc + diff;
     *dst++ = (uint8_t)(acc & 0xff);
   }
 }
@@ -1784,20 +1784,20 @@ static void x3f_setup_camf_text_entry(camf_entry_t *entry)
 static void x3f_setup_camf_property_entry(camf_entry_t *entry)
 {
   int i;
   uint8_t *e = (uint8_t *)entry->entry;
   uint8_t *v = (uint8_t *)entry->value_address;
   uint32_t num = entry->property_num = *(uint32_t *)v;
   uint32_t off = *(uint32_t *)(v + 4);
 
   entry->property_name = (char **)malloc(num * sizeof(uint8_t *));
   entry->property_value = (uint8_t **)malloc(num * sizeof(uint8_t *));
 
-  for (i = 0; i < num; i++)
+  for (i = 0; i < (int)num; i++)
   {
     uint32_t name_off = off + *(uint32_t *)(v + 8 + 8 * i);
     uint32_t value_off = off + *(uint32_t *)(v + 8 + 8 * i + 4);
 
     entry->property_name[i] = (char *)(e + name_off);
     entry->property_value[i] = e + value_off;
   }
 }
@@ -1839,66 +1839,66 @@ static void set_matrix_element_info(uint32_t type, uint32_t *size,
 static void get_matrix_copy(camf_entry_t *entry)
 {
   uint32_t element_size = entry->matrix_element_size;
   uint32_t elements = entry->matrix_elements;
   int i, size = (entry->matrix_decoded_type == M_FLOAT ? sizeof(double)
                                                        : sizeof(uint32_t)) *
                 elements;
 
   entry->matrix_decoded = malloc(size);
 
   switch (element_size)
   {
   case 4:
     switch (entry->matrix_decoded_type)
     {
     case M_INT:
     case M_UINT:
       memcpy(entry->matrix_decoded, entry->matrix_data, size);
       break;
     case M_FLOAT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((double *)entry->matrix_decoded)[i] =
             (double)((float *)entry->matrix_data)[i];
       break;
     default:
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     }
     break;
   case 2:
     switch (entry->matrix_decoded_type)
     {
     case M_INT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((int32_t *)entry->matrix_decoded)[i] =
             (int32_t)((int16_t *)entry->matrix_data)[i];
       break;
     case M_UINT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((uint32_t *)entry->matrix_decoded)[i] =
             (uint32_t)((uint16_t *)entry->matrix_data)[i];
       break;
     default:
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     }
     break;
   case 1:
     switch (entry->matrix_decoded_type)
     {
     case M_INT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((int32_t *)entry->matrix_decoded)[i] =
             (int32_t)((int8_t *)entry->matrix_data)[i];
       break;
     case M_UINT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((uint32_t *)entry->matrix_decoded)[i] =
             (uint32_t)((uint8_t *)entry->matrix_data)[i];
       break;
     default:
       throw LIBRAW_EXCEPTION_IO_CORRUPT;
     }
     break;
   default:
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
   }
 }
@@ -1906,39 +1906,39 @@ static void get_matrix_copy(camf_entry_t *entry)
 static void x3f_setup_camf_matrix_entry(camf_entry_t *entry)
 {
   int i;
   int totalsize = 1;
 
   uint8_t *e = (uint8_t *)entry->entry;
   uint8_t *v = (uint8_t *)entry->value_address;
   uint32_t type = entry->matrix_type = *(uint32_t *)(v + 0);
   uint32_t dim = entry->matrix_dim = *(uint32_t *)(v + 4);
   uint32_t off = entry->matrix_data_off = *(uint32_t *)(v + 8);
   camf_dim_entry_t *dentry = entry->matrix_dim_entry =
       (camf_dim_entry_t *)malloc(dim * sizeof(camf_dim_entry_t));
 
-  for (i = 0; i < dim; i++)
+  for (i = 0; i < (int)dim; i++)
   {
     uint32_t size = dentry[i].size = *(uint32_t *)(v + 12 + 12 * i + 0);
     dentry[i].name_offset = *(uint32_t *)(v + 12 + 12 * i + 4);
     dentry[i].n = *(uint32_t *)(v + 12 + 12 * i + 8);
     dentry[i].name = (char *)(e + dentry[i].name_offset);
 
-    if (dentry[i].n != i)
+    if ((int)dentry[i].n != i)
     {
     }
 
     totalsize *= size;
   }
 
   set_matrix_element_info(type, &entry->matrix_element_size,
                           &entry->matrix_decoded_type);
   entry->matrix_data = (void *)(e + off);
 
   entry->matrix_elements = totalsize;
   entry->matrix_used_space = entry->entry_size - off;
 
   /* This estimate only works for matrices above a certain size */
   entry->matrix_estimated_element_size = entry->matrix_used_space / totalsize;
 
   get_matrix_copy(entry);
 }
