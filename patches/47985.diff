commit b48ed70c79c6482e1f39b77d16e62043ff5042a5
Author: Yu Watanabe <watanabe.yu+github@gmail.com>
Date:   Tue Jun 14 15:06:27 2022 +0900

    Revert NFTSet feature
    
    This reverts PR #22587 and its follow-up commit. More specifically,
    2299b1cae32c1fb8911da0ce26efced68032f4f8 (partially),
    e176f855278d5098d3fecc5aa24ba702147d42e0,
    ceb46a31a01b3d3d1d6095d857e29ea214a2776b, and
    51bb9076ab8c050bebb64db5035852385accda35.
    
    The PR was merged without final approval, and has several issues:
    - OSS fuzz reported issues in the conf parser,
    - It calls synchrnous netlink call, it should not be especially in PID1,
    - The importance of NFTSet for CGroup and DynamicUser may be
      questionable, at least, there was no justification PID1 should support
      it.
    - For networkd, it should be implemented with Request object,
    - There is no test for the feature.
    
    Fixes #23711.
    Fixes #23717.
    Fixes #23719.
    Fixes #23720.
    Fixes #23721.
    Fixes #23759.

diff --git a/man/org.freedesktop.systemd1.xml b/man/org.freedesktop.systemd1.xml
index b9b5768bf0..7974833554 100644
--- a/man/org.freedesktop.systemd1.xml
+++ b/man/org.freedesktop.systemd1.xml
@@ -2339,3726 +2339,3702 @@ node /org/freedesktop/systemd1/unit/avahi_2ddaemon_2eservice {
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/avahi_2ddaemon_2eservice" interface="org.freedesktop.systemd1.Service">
 node /org/freedesktop/systemd1/unit/avahi_2ddaemon_2eservice {
   interface org.freedesktop.systemd1.Service {
     methods:
       BindMount(in  s source,
                 in  s destination,
                 in  b read_only,
                 in  b mkdir);
       MountImage(in  s source,
                  in  s destination,
                  in  b read_only,
                  in  b mkdir,
                  in  a(ss) options);
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     properties:
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Type = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ExitType = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Restart = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s PIDFile = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s NotifyAccess = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RestartUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutStartUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutStopUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TimeoutAbortUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TimeoutStartFailureMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TimeoutStopFailureMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RuntimeMaxUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RuntimeRandomizedExtraUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t WatchdogUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t WatchdogTimestamp = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t WatchdogTimestampMonotonic = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RootDirectoryStartOnly = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemainAfterExit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b GuessMainPID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (aiai) RestartPreventExitStatus = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (aiai) RestartForceExitStatus = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (aiai) SuccessExitStatus = ...;
       readonly u MainPID = ...;
       readonly u ControlPID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s BusName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u FileDescriptorStoreMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u NFileDescriptorStore = ...;
       readonly s StatusText = '...';
       readonly i StatusErrno = ...;
       readonly s Result = '...';
       readonly s ReloadResult = '...';
       readonly s CleanResult = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s USBFunctionDescriptors = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s USBFunctionStrings = '...';
       readonly u UID = ...;
       readonly u GID = ...;
       readonly u NRestarts = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s OOMPolicy = '...';
       readonly t ExecMainStartTimestamp = ...;
       readonly t ExecMainStartTimestampMonotonic = ...;
       readonly t ExecMainExitTimestamp = ...;
       readonly t ExecMainExitTimestampMonotonic = ...;
       readonly u ExecMainPID = ...;
       readonly i ExecMainCode = ...;
       readonly i ExecMainStatus = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecCondition = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecConditionEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStartPre = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecStartPreEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStart = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecStartEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStartPost = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecStartPostEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecReload = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecReloadEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStop = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecStopEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStopPost = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasasttttuii) ExecStopPostEx = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as Environment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sb) EnvironmentFiles = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as PassEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as UnsetEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u UMask = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPU = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPUSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATASoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitAS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitASSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROCSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDING = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDINGSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIO = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIOSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIME = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIMESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s WorkingDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootImage = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) RootImageOptions = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHash = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHashSignature = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashSignaturePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootVerity = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExtensionDirectories = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sba(ss)) ExtensionImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssba(ss)) MountImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i OOMScoreAdjust = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CoredumpFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Nice = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingClass = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay CPUAffinity = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUAffinityFromNUMA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i NUMAPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay NUMAMask = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimerSlackNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUSchedulingResetOnFork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NonBlocking = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay StandardInputData = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardError = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardErrorFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TTYPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYReset = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVHangup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVTDisallocate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYRows = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYColumns = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SyslogIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SyslogLevelPrefix = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogLevel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogFacility = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i LogLevelMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LogRateLimitIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogRateLimitBurst = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly aay LogExtraFields = [[...], ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s LogNamespace = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SecureBits = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CapabilityBoundingSet = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t AmbientCapabilities = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s User = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Group = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b DynamicUser = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) DynamicUserNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemoveIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SupplementaryGroups = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s PAMName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadWritePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadOnlyPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as InaccessiblePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as NoExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecSearchPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t MountFlags = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateTmp = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateDevices = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectClock = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelTunables = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelModules = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelLogs = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectControlGroups = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateNetwork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateUsers = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateMounts = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectHome = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectSystem = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SameProcessGroup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SELinuxContext = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) AppArmorProfile = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SmackProcessLabel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b IgnoreSIGPIPE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NoNewPrivileges = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SystemCallArchitectures = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SystemCallErrorNumber = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallLog = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Personality = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b LockPersonality = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictAddressFamilies = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) RuntimeDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RuntimeDirectoryPreserve = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u RuntimeDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as RuntimeDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) StateDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u StateDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as StateDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) CacheDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u CacheDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as CacheDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) LogsDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogsDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as LogsDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u ConfigurationDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ConfigurationDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutCleanUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MemoryDenyWriteExecute = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictRealtime = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictSUIDSGID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RestrictNamespaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictFileSystems = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindReadOnlyPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) TemporaryFileSystem = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MountAPIVFS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KeyringMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectProc = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProcSubset = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectHostname = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s NetworkNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IPCNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KillMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i KillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i RestartKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i FinalKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGKILL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGHUP = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i WatchdogSignal = ...;
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property Type is not documented!-->
 
     <!--property ExitType is not documented!-->
 
     <!--property Restart is not documented!-->
 
     <!--property PIDFile is not documented!-->
 
     <!--property NotifyAccess is not documented!-->
 
     <!--property RestartUSec is not documented!-->
 
     <!--property TimeoutStartFailureMode is not documented!-->
 
     <!--property TimeoutStopFailureMode is not documented!-->
 
     <!--property RuntimeMaxUSec is not documented!-->
 
     <!--property RuntimeRandomizedExtraUSec is not documented!-->
 
     <!--property WatchdogUSec is not documented!-->
 
     <!--property RootDirectoryStartOnly is not documented!-->
 
     <!--property RemainAfterExit is not documented!-->
 
     <!--property GuessMainPID is not documented!-->
 
     <!--property RestartPreventExitStatus is not documented!-->
 
     <!--property RestartForceExitStatus is not documented!-->
 
     <!--property SuccessExitStatus is not documented!-->
 
     <!--property BusName is not documented!-->
 
     <!--property FileDescriptorStoreMax is not documented!-->
 
     <!--property NFileDescriptorStore is not documented!-->
 
     <!--property StatusErrno is not documented!-->
 
     <!--property ReloadResult is not documented!-->
 
     <!--property CleanResult is not documented!-->
 
     <!--property USBFunctionDescriptors is not documented!-->
 
     <!--property USBFunctionStrings is not documented!-->
 
     <!--property UID is not documented!-->
 
     <!--property GID is not documented!-->
 
     <!--property NRestarts is not documented!-->
 
     <!--property OOMPolicy is not documented!-->
 
     <!--property ExecCondition is not documented!-->
 
     <!--property ExecConditionEx is not documented!-->
 
     <!--property ExecStartPreEx is not documented!-->
 
     <!--property ExecStartEx is not documented!-->
 
     <!--property ExecStartPostEx is not documented!-->
 
     <!--property ExecReloadEx is not documented!-->
 
     <!--property ExecStopEx is not documented!-->
 
     <!--property ExecStopPost is not documented!-->
 
     <!--property ExecStopPostEx is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--property EnvironmentFiles is not documented!-->
 
     <!--property PassEnvironment is not documented!-->
 
     <!--property UnsetEnvironment is not documented!-->
 
     <!--property UMask is not documented!-->
 
     <!--property LimitCPUSoft is not documented!-->
 
     <!--property LimitFSIZE is not documented!-->
 
     <!--property LimitFSIZESoft is not documented!-->
 
     <!--property LimitDATA is not documented!-->
 
     <!--property LimitDATASoft is not documented!-->
 
     <!--property LimitSTACK is not documented!-->
 
     <!--property LimitSTACKSoft is not documented!-->
 
     <!--property LimitCORE is not documented!-->
 
     <!--property LimitCORESoft is not documented!-->
 
     <!--property LimitRSS is not documented!-->
 
     <!--property LimitRSSSoft is not documented!-->
 
     <!--property LimitNOFILE is not documented!-->
 
     <!--property LimitNOFILESoft is not documented!-->
 
     <!--property LimitAS is not documented!-->
 
     <!--property LimitASSoft is not documented!-->
 
     <!--property LimitNPROC is not documented!-->
 
     <!--property LimitNPROCSoft is not documented!-->
 
     <!--property LimitMEMLOCK is not documented!-->
 
     <!--property LimitMEMLOCKSoft is not documented!-->
 
     <!--property LimitLOCKS is not documented!-->
 
     <!--property LimitLOCKSSoft is not documented!-->
 
     <!--property LimitSIGPENDING is not documented!-->
 
     <!--property LimitSIGPENDINGSoft is not documented!-->
 
     <!--property LimitMSGQUEUE is not documented!-->
 
     <!--property LimitMSGQUEUESoft is not documented!-->
 
     <!--property LimitNICE is not documented!-->
 
     <!--property LimitNICESoft is not documented!-->
 
     <!--property LimitRTPRIO is not documented!-->
 
     <!--property LimitRTPRIOSoft is not documented!-->
 
     <!--property LimitRTTIME is not documented!-->
 
     <!--property LimitRTTIMESoft is not documented!-->
 
     <!--property WorkingDirectory is not documented!-->
 
     <!--property RootHashPath is not documented!-->
 
     <!--property RootHashSignaturePath is not documented!-->
 
     <!--property OOMScoreAdjust is not documented!-->
 
     <!--property CoredumpFilter is not documented!-->
 
     <!--property Nice is not documented!-->
 
     <!--property IOSchedulingClass is not documented!-->
 
     <!--property IOSchedulingPriority is not documented!-->
 
     <!--property CPUSchedulingPolicy is not documented!-->
 
     <!--property CPUSchedulingPriority is not documented!-->
 
     <!--property CPUAffinity is not documented!-->
 
     <!--property CPUAffinityFromNUMA is not documented!-->
 
     <!--property NUMAPolicy is not documented!-->
 
     <!--property NUMAMask is not documented!-->
 
     <!--property TimerSlackNSec is not documented!-->
 
     <!--property CPUSchedulingResetOnFork is not documented!-->
 
     <!--property NonBlocking is not documented!-->
 
     <!--property StandardInput is not documented!-->
 
     <!--property StandardInputFileDescriptorName is not documented!-->
 
     <!--property StandardInputData is not documented!-->
 
     <!--property StandardOutput is not documented!-->
 
     <!--property StandardOutputFileDescriptorName is not documented!-->
 
     <!--property StandardError is not documented!-->
 
     <!--property StandardErrorFileDescriptorName is not documented!-->
 
     <!--property TTYPath is not documented!-->
 
     <!--property TTYReset is not documented!-->
 
     <!--property TTYVHangup is not documented!-->
 
     <!--property TTYVTDisallocate is not documented!-->
 
     <!--property TTYRows is not documented!-->
 
     <!--property TTYColumns is not documented!-->
 
     <!--property SyslogPriority is not documented!-->
 
     <!--property SyslogIdentifier is not documented!-->
 
     <!--property SyslogLevelPrefix is not documented!-->
 
     <!--property SyslogLevel is not documented!-->
 
     <!--property SyslogFacility is not documented!-->
 
     <!--property LogLevelMax is not documented!-->
 
     <!--property LogRateLimitIntervalUSec is not documented!-->
 
     <!--property LogRateLimitBurst is not documented!-->
 
     <!--property LogExtraFields is not documented!-->
 
     <!--property LogNamespace is not documented!-->
 
     <!--property AmbientCapabilities is not documented!-->
 
     <!--property User is not documented!-->
 
     <!--property Group is not documented!-->
 
     <!--property DynamicUser is not documented!-->
 
-    <!--property DynamicUserNFTSet is not documented!-->
-
     <!--property RemoveIPC is not documented!-->
 
     <!--property SetCredential is not documented!-->
 
     <!--property SetCredentialEncrypted is not documented!-->
 
     <!--property LoadCredential is not documented!-->
 
     <!--property LoadCredentialEncrypted is not documented!-->
 
     <!--property SupplementaryGroups is not documented!-->
 
     <!--property PAMName is not documented!-->
 
     <!--property ReadWritePaths is not documented!-->
 
     <!--property ReadOnlyPaths is not documented!-->
 
     <!--property InaccessiblePaths is not documented!-->
 
     <!--property ExecPaths is not documented!-->
 
     <!--property NoExecPaths is not documented!-->
 
     <!--property ExecSearchPath is not documented!-->
 
     <!--property PrivateTmp is not documented!-->
 
     <!--property PrivateDevices is not documented!-->
 
     <!--property ProtectClock is not documented!-->
 
     <!--property ProtectKernelTunables is not documented!-->
 
     <!--property ProtectKernelModules is not documented!-->
 
     <!--property ProtectKernelLogs is not documented!-->
 
     <!--property ProtectControlGroups is not documented!-->
 
     <!--property PrivateNetwork is not documented!-->
 
     <!--property PrivateUsers is not documented!-->
 
     <!--property PrivateMounts is not documented!-->
 
     <!--property PrivateIPC is not documented!-->
 
     <!--property ProtectHome is not documented!-->
 
     <!--property ProtectSystem is not documented!-->
 
     <!--property SameProcessGroup is not documented!-->
 
     <!--property UtmpIdentifier is not documented!-->
 
     <!--property UtmpMode is not documented!-->
 
     <!--property SELinuxContext is not documented!-->
 
     <!--property AppArmorProfile is not documented!-->
 
     <!--property SmackProcessLabel is not documented!-->
 
     <!--property IgnoreSIGPIPE is not documented!-->
 
     <!--property NoNewPrivileges is not documented!-->
 
     <!--property SystemCallFilter is not documented!-->
 
     <!--property SystemCallArchitectures is not documented!-->
 
     <!--property SystemCallErrorNumber is not documented!-->
 
     <!--property SystemCallLog is not documented!-->
 
     <!--property Personality is not documented!-->
 
     <!--property LockPersonality is not documented!-->
 
     <!--property RestrictAddressFamilies is not documented!-->
 
     <!--property RuntimeDirectoryPreserve is not documented!-->
 
     <!--property RuntimeDirectoryMode is not documented!-->
 
     <!--property StateDirectoryMode is not documented!-->
 
     <!--property CacheDirectoryMode is not documented!-->
 
     <!--property LogsDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectory is not documented!-->
 
     <!--property TimeoutCleanUSec is not documented!-->
 
     <!--property MemoryDenyWriteExecute is not documented!-->
 
     <!--property RestrictRealtime is not documented!-->
 
     <!--property RestrictSUIDSGID is not documented!-->
 
     <!--property RestrictNamespaces is not documented!-->
 
     <!--property RestrictFileSystems is not documented!-->
 
     <!--property BindPaths is not documented!-->
 
     <!--property BindReadOnlyPaths is not documented!-->
 
     <!--property TemporaryFileSystem is not documented!-->
 
     <!--property MountAPIVFS is not documented!-->
 
     <!--property KeyringMode is not documented!-->
 
     <!--property ProtectProc is not documented!-->
 
     <!--property ProcSubset is not documented!-->
 
     <!--property ProtectHostname is not documented!-->
 
     <!--property NetworkNamespacePath is not documented!-->
 
     <!--property IPCNamespacePath is not documented!-->
 
     <!--property KillMode is not documented!-->
 
     <!--property KillSignal is not documented!-->
 
     <!--property RestartKillSignal is not documented!-->
 
     <!--property FinalKillSignal is not documented!-->
 
     <!--property SendSIGKILL is not documented!-->
 
     <!--property SendSIGHUP is not documented!-->
 
     <!--property WatchdogSignal is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Service"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Service"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="BindMount()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="MountImage()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Type"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExitType"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Restart"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PIDFile"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NotifyAccess"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutStartUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutStopUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutAbortUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutStartFailureMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutStopFailureMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeMaxUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeRandomizedExtraUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogTimestamp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogTimestampMonotonic"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootDirectoryStartOnly"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RemainAfterExit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="GuessMainPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartPreventExitStatus"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartForceExitStatus"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SuccessExitStatus"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MainPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BusName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FileDescriptorStoreMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NFileDescriptorStore"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StatusText"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StatusErrno"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Result"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReloadResult"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CleanResult"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="USBFunctionDescriptors"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="USBFunctionStrings"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="GID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NRestarts"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OOMPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainStartTimestamp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainStartTimestampMonotonic"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainExitTimestamp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainExitTimestampMonotonic"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainCode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMainStatus"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecCondition"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecConditionEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPre"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPreEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStart"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPost"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPostEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecReload"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecReloadEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStop"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStopEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStopPost"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStopPostEx"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="Environment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EnvironmentFiles"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UnsetEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPU"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPUSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATASoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitAS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitASSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROCSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDING"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDINGSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIO"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIOSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIME"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIMESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WorkingDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImage"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImageOptions"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHash"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignature"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignaturePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootVerity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionDirectories"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OOMScoreAdjust"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CoredumpFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Nice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingClass"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinityFromNUMA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimerSlackNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingResetOnFork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NonBlocking"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputData"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardError"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardErrorFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYReset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVHangup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVTDisallocate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYRows"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYColumns"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevelPrefix"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogFacility"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogLevelMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitBurst"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogExtraFields"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogNamespace"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SecureBits"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CapabilityBoundingSet"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AmbientCapabilities"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="User"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Group"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DynamicUser"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="DynamicUserNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="RemoveIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SupplementaryGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PAMName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadWritePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="InaccessiblePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecSearchPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountFlags"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateTmp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateDevices"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectClock"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelTunables"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelModules"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelLogs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectControlGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateNetwork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateUsers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateMounts"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHome"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SameProcessGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SELinuxContext"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AppArmorProfile"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackProcessLabel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IgnoreSIGPIPE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoNewPrivileges"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallArchitectures"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallErrorNumber"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallLog"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Personality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LockPersonality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictAddressFamilies"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryPreserve"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutCleanUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryDenyWriteExecute"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictRealtime"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictSUIDSGID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNamespaces"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictFileSystems"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TemporaryFileSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountAPIVFS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeyringMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectProc"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProcSubset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHostname"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NetworkNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPCNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FinalKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGKILL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGHUP"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogSignal"/>
 
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Methods</title>
 
       <para><function>BindMount()</function> and <function>MountImage()</function> implement the same operations
       as the respective methods on the <interfacename>Manager</interfacename> object (see above). However, these
       methods operate on the service object and hence do not take a unit name parameter. Invoking the methods
       directly on the Manager object has the advantage of not requiring a <function>GetUnit()</function> call
       to get the unit object for a specific unit name. Calling the methods on the Manager object is hence a round
       trip optimization.</para>
     </refsect2>
 
     <refsect2>
       <title>Properties</title>
 
       <para>Most properties of the Service interface map directly to the corresponding settings in service
       unit files. For the sake of brevity, here's a list of all exceptions only:</para>
 
       <para><varname>TimeoutStartUSec</varname>, <varname>TimeoutStopUSec</varname> and
       <varname>TimeoutAbortUSec</varname> contain the start, stop and abort timeouts, in microseconds. Note
       the slight difference in naming when compared to the matching unit file settings (see
       <citerefentry><refentrytitle>systemd.service</refentrytitle><manvolnum>7</manvolnum></citerefentry>):
       these bus properties strictly use microseconds (and thus are suffixed <varname>USec</varname>) while
       the unit file settings default to a time unit of seconds (and thus are suffixed
       <varname>Sec</varname>), unless a different unit is explicitly specified. This reflects that fact that
       internally the service manager deals in microsecond units only, and the bus properties are a relatively
       low-level (binary) concept exposing this. The unit file settings on the other hand are relatively
       high-level (string-based) concepts and thus support more user friendly time specifications which
       default to second time units but allow other units too, if specified.</para>
 
       <para><varname>WatchdogTimestamp</varname> and <varname>WatchdogTimestampMonotonic</varname> contain
       <constant>CLOCK_REALTIME</constant>/<constant>CLOCK_MONOTONIC</constant> microsecond timestamps of the
       last watchdog ping received from the service, or 0 if none was ever received.</para>
 
       <para><varname>ExecStartPre</varname>, <varname>ExecStart</varname>, <varname>ExecStartPost</varname>,
       <varname>ExecReload</varname>, <varname>ExecStop</varname>, and <varname>ExecStop</varname> are arrays
       of structures where each struct contains: the binary path to execute; an array with all arguments to
       pass to the executed command, starting with argument 0; a boolean whether it should be considered a
       failure if the process exits uncleanly; two pairs of
       <constant>CLOCK_REALTIME</constant>/<constant>CLOCK_MONOTONIC</constant> microsecond timestamps when
       the process began and finished running the last time, or 0 if it never ran or never finished running;
       the PID of the process, or 0 if it has not run yet; the exit code and status of the last run. This
       field hence maps more or less to the corresponding setting in the service unit file but is augmented
       with runtime data.</para>
 
       <para><varname>LimitCPU</varname> (and related properties) map more or less directly to the
       corresponding settings in the service unit files except that if they aren't set, their value is
       18446744073709551615 (i.e. -1).</para>
 
       <para><varname>Capabilities</varname> contains the configured capabilities, as formatted with
       <citerefentry project="man-pages"><refentrytitle>cap_to_text</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
       </para>
 
       <para><varname>SecureBits</varname>, <varname>CapabilityBoundingSet</varname>,
       <varname>MountFlags</varname> also correspond to the configured settings of the unit files, but
       instead of being formatted as strings, they are encoded as the actual binary flags they are.
       </para>
 
       <para><varname>ExecMainStartTimestamp</varname>, <varname>ExecMainStartTimestampMonotonic</varname>,
       <varname>ExecMainExitTimestamp</varname>, <varname>ExecMainExitTimestampMonotonic</varname>,
       <varname>ExecMainPID</varname>, <varname>ExecMainCode</varname>, <varname>ExecMainStatus</varname>
       contain information about the main process of the service as far as it is known. This is often the same
       runtime information that is stored in <varname>ExecStart</varname>. However, it deviates for
       <varname>Type=forking</varname> services where the main process of the service is not forked off
       systemd directly. These fields either contain information of the last run of the process or of the
       current running process.</para>
 
       <para><varname>MainPID</varname> and <varname>ControlPID</varname> contain the main and control PID of
       the service. The main PID is the current main PID of the service and is 0 when the service currently
       has no main PID. The control PID is the PID of the current start/stop/reload process running and is 0
       if no such process is currently running. That means that <varname>ExecMainPID</varname> and
       <varname>MainPID</varname> differ in the way that the latter immediately reflects whether a main
       process is currently running while the latter possible contains information collected from the last run
       even if the process is no longer around.</para>
 
       <para><varname>StatusText</varname> contains the status text passed to the service manager via a call
       to
       <citerefentry><refentrytitle>sd_notify</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
       This may be used by services to inform the service manager about its internal state with a nice
       explanatory string.</para>
 
       <para><varname>Result</varname> encodes the execution result of the last run of the service. It is
       useful to determine the reason a service failed if it is in the <literal>failed</literal> state (see
       <varname>ActiveState</varname> above). The following values are currently known:
       <literal>success</literal> is set if the unit didn't fail. <literal>resources</literal> indicates that
       not enough resources were available to fork off and execute the service
       processes. <literal>timeout</literal> indicates that a timeout occurred while executing a service
       operation. <literal>exit-code</literal> indicates that a service process exited with an unclean exit
       code. <literal>signal</literal> indicates that a service process exited with an uncaught
       signal. <literal>core-dump</literal> indicates that a service process exited uncleanly and dumped
       core. <literal>watchdog</literal> indicates that a service did not send out watchdog ping messages
       often enough. <literal>start-limit</literal> indicates that a service has been started too frequently
       in a specific time frame (as configured in <varname>StartLimitInterval</varname>,
       <varname>StartLimitBurst</varname>).</para>
 
       <para><varname>ControlGroup</varname> indicates the control group path the processes of this service
       unit are placed in.</para>
 
       <para>The following properties map 1:1 to corresponding settings in the unit file:
       <varname>RootDirectory</varname>
       <varname>RootImage</varname>
       <varname>RootImageOptions</varname>
       <varname>RootVerity</varname>
       <varname>RootHash</varname>
       <varname>RootHashSignature</varname>
       <varname>MountImages</varname>
       <varname>ExtensionImages</varname>
       <varname>ExtensionDirectories</varname>
       see systemd.exec(5) for their meaning.</para>
 
       <para><varname>MemoryAvailable</varname> indicates how much unused memory is available to the unit before
       the <literal>MemoryMax</literal> or <literal>MemoryHigh</literal> (whichever is lower) limit set by the cgroup
       memory controller is reached. It will take into consideration limits on all parent slices, other than the
       limits set on the unit itself.</para>
 
       <para><varname>RuntimeDirectorySymlink</varname>, <varname>StateDirectorySymlink</varname>,
       <varname>CacheDirectorySymlink</varname> and  <varname>LogsDirectorySymlink</varname> respectively
       implement the destination parameter of the unit files settings <varname>RuntimeDirectory</varname>,
       <varname>StateDirectory</varname>, <varname>CacheDirectory</varname> and <varname>LogsDirectory</varname>,
       which will create a symlink of the given name to the respective directory. The messages take an unused
       <varname>flags</varname> parameter, reserved for future backward-compatible changes.</para>
     </refsect2>
   </refsect1>
 
   <refsect1>
     <title>Socket Unit Objects</title>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/avahi_2ddaemon_2esocket" interface="org.freedesktop.systemd1.Socket">
 node /org/freedesktop/systemd1/unit/avahi_2ddaemon_2esocket {
   interface org.freedesktop.systemd1.Socket {
     methods:
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     properties:
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s BindIPv6Only = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u Backlog = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s BindToDevice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SocketUser = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SocketGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u SocketMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u DirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b Accept = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b FlushPending = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b Writable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b KeepAlive = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t KeepAliveTimeUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t KeepAliveIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u KeepAliveProbes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t DeferAcceptUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NoDelay = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Priority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t ReceiveBuffer = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t SendBuffer = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IPTOS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IPTTL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t PipeSize = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b FreeBind = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b Transparent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b Broadcast = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PassCredentials = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PassSecurity = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PassPacketInfo = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Timestamping = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemoveOnStop = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) Listen = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as Symlinks = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Mark = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u MaxConnections = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u MaxConnectionsPerSource = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly x MessageQueueMaxMessages = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly x MessageQueueMessageSize = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TCPCongestion = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ReusePort = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SmackLabel = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SmackLabelIPIn = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SmackLabelIPOut = '...';
       readonly u ControlPID = ...;
       readonly s Result = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u NConnections = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u NAccepted = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u NRefused = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s FileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SocketProtocol = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TriggerLimitIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u TriggerLimitBurst = ...;
       readonly u UID = ...;
       readonly u GID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStartPre = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStartPost = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStopPre = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecStopPost = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as Environment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sb) EnvironmentFiles = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as PassEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as UnsetEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u UMask = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPU = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPUSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATASoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitAS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitASSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROCSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDING = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDINGSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIO = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIOSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIME = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIMESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s WorkingDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootImage = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) RootImageOptions = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHash = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHashSignature = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashSignaturePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootVerity = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExtensionDirectories = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sba(ss)) ExtensionImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssba(ss)) MountImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i OOMScoreAdjust = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CoredumpFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Nice = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingClass = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay CPUAffinity = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUAffinityFromNUMA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i NUMAPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay NUMAMask = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimerSlackNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUSchedulingResetOnFork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NonBlocking = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay StandardInputData = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardError = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardErrorFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TTYPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYReset = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVHangup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVTDisallocate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYRows = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYColumns = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SyslogIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SyslogLevelPrefix = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogLevel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogFacility = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i LogLevelMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LogRateLimitIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogRateLimitBurst = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly aay LogExtraFields = [[...], ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s LogNamespace = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SecureBits = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CapabilityBoundingSet = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t AmbientCapabilities = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s User = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Group = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b DynamicUser = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) DynamicUserNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemoveIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SupplementaryGroups = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s PAMName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadWritePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadOnlyPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as InaccessiblePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as NoExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecSearchPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t MountFlags = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateTmp = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateDevices = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectClock = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelTunables = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelModules = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelLogs = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectControlGroups = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateNetwork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateUsers = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateMounts = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectHome = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectSystem = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SameProcessGroup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SELinuxContext = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) AppArmorProfile = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SmackProcessLabel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b IgnoreSIGPIPE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NoNewPrivileges = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SystemCallArchitectures = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SystemCallErrorNumber = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallLog = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Personality = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b LockPersonality = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictAddressFamilies = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) RuntimeDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RuntimeDirectoryPreserve = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u RuntimeDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as RuntimeDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) StateDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u StateDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as StateDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) CacheDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u CacheDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as CacheDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) LogsDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogsDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as LogsDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u ConfigurationDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ConfigurationDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutCleanUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MemoryDenyWriteExecute = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictRealtime = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictSUIDSGID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RestrictNamespaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictFileSystems = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindReadOnlyPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) TemporaryFileSystem = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MountAPIVFS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KeyringMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectProc = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProcSubset = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectHostname = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s NetworkNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IPCNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KillMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i KillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i RestartKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i FinalKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGKILL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGHUP = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i WatchdogSignal = ...;
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property BindIPv6Only is not documented!-->
 
     <!--property Backlog is not documented!-->
 
     <!--property TimeoutUSec is not documented!-->
 
     <!--property BindToDevice is not documented!-->
 
     <!--property SocketUser is not documented!-->
 
     <!--property SocketGroup is not documented!-->
 
     <!--property SocketMode is not documented!-->
 
     <!--property DirectoryMode is not documented!-->
 
     <!--property Writable is not documented!-->
 
     <!--property KeepAlive is not documented!-->
 
     <!--property KeepAliveTimeUSec is not documented!-->
 
     <!--property KeepAliveIntervalUSec is not documented!-->
 
     <!--property KeepAliveProbes is not documented!-->
 
     <!--property DeferAcceptUSec is not documented!-->
 
     <!--property NoDelay is not documented!-->
 
     <!--property Priority is not documented!-->
 
     <!--property ReceiveBuffer is not documented!-->
 
     <!--property SendBuffer is not documented!-->
 
     <!--property IPTOS is not documented!-->
 
     <!--property IPTTL is not documented!-->
 
     <!--property PipeSize is not documented!-->
 
     <!--property FreeBind is not documented!-->
 
     <!--property Transparent is not documented!-->
 
     <!--property Broadcast is not documented!-->
 
     <!--property PassCredentials is not documented!-->
 
     <!--property PassSecurity is not documented!-->
 
     <!--property PassPacketInfo is not documented!-->
 
     <!--property Timestamping is not documented!-->
 
     <!--property RemoveOnStop is not documented!-->
 
     <!--property Listen is not documented!-->
 
     <!--property Symlinks is not documented!-->
 
     <!--property Mark is not documented!-->
 
     <!--property MaxConnections is not documented!-->
 
     <!--property MaxConnectionsPerSource is not documented!-->
 
     <!--property MessageQueueMaxMessages is not documented!-->
 
     <!--property MessageQueueMessageSize is not documented!-->
 
     <!--property TCPCongestion is not documented!-->
 
     <!--property ReusePort is not documented!-->
 
     <!--property SmackLabel is not documented!-->
 
     <!--property SmackLabelIPIn is not documented!-->
 
     <!--property SmackLabelIPOut is not documented!-->
 
     <!--property NRefused is not documented!-->
 
     <!--property FileDescriptorName is not documented!-->
 
     <!--property SocketProtocol is not documented!-->
 
     <!--property TriggerLimitIntervalUSec is not documented!-->
 
     <!--property TriggerLimitBurst is not documented!-->
 
     <!--property UID is not documented!-->
 
     <!--property GID is not documented!-->
 
     <!--property ExecStopPre is not documented!-->
 
     <!--property ExecStopPost is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--property EnvironmentFiles is not documented!-->
 
     <!--property PassEnvironment is not documented!-->
 
     <!--property UnsetEnvironment is not documented!-->
 
     <!--property UMask is not documented!-->
 
     <!--property LimitCPUSoft is not documented!-->
 
     <!--property LimitFSIZE is not documented!-->
 
     <!--property LimitFSIZESoft is not documented!-->
 
     <!--property LimitDATA is not documented!-->
 
     <!--property LimitDATASoft is not documented!-->
 
     <!--property LimitSTACK is not documented!-->
 
     <!--property LimitSTACKSoft is not documented!-->
 
     <!--property LimitCORE is not documented!-->
 
     <!--property LimitCORESoft is not documented!-->
 
     <!--property LimitRSS is not documented!-->
 
     <!--property LimitRSSSoft is not documented!-->
 
     <!--property LimitNOFILE is not documented!-->
 
     <!--property LimitNOFILESoft is not documented!-->
 
     <!--property LimitAS is not documented!-->
 
     <!--property LimitASSoft is not documented!-->
 
     <!--property LimitNPROC is not documented!-->
 
     <!--property LimitNPROCSoft is not documented!-->
 
     <!--property LimitMEMLOCK is not documented!-->
 
     <!--property LimitMEMLOCKSoft is not documented!-->
 
     <!--property LimitLOCKS is not documented!-->
 
     <!--property LimitLOCKSSoft is not documented!-->
 
     <!--property LimitSIGPENDING is not documented!-->
 
     <!--property LimitSIGPENDINGSoft is not documented!-->
 
     <!--property LimitMSGQUEUE is not documented!-->
 
     <!--property LimitMSGQUEUESoft is not documented!-->
 
     <!--property LimitNICE is not documented!-->
 
     <!--property LimitNICESoft is not documented!-->
 
     <!--property LimitRTPRIO is not documented!-->
 
     <!--property LimitRTPRIOSoft is not documented!-->
 
     <!--property LimitRTTIME is not documented!-->
 
     <!--property LimitRTTIMESoft is not documented!-->
 
     <!--property WorkingDirectory is not documented!-->
 
     <!--property RootHashPath is not documented!-->
 
     <!--property RootHashSignaturePath is not documented!-->
 
     <!--property OOMScoreAdjust is not documented!-->
 
     <!--property CoredumpFilter is not documented!-->
 
     <!--property Nice is not documented!-->
 
     <!--property IOSchedulingClass is not documented!-->
 
     <!--property IOSchedulingPriority is not documented!-->
 
     <!--property CPUSchedulingPolicy is not documented!-->
 
     <!--property CPUSchedulingPriority is not documented!-->
 
     <!--property CPUAffinity is not documented!-->
 
     <!--property CPUAffinityFromNUMA is not documented!-->
 
     <!--property NUMAPolicy is not documented!-->
 
     <!--property NUMAMask is not documented!-->
 
     <!--property TimerSlackNSec is not documented!-->
 
     <!--property CPUSchedulingResetOnFork is not documented!-->
 
     <!--property NonBlocking is not documented!-->
 
     <!--property StandardInput is not documented!-->
 
     <!--property StandardInputFileDescriptorName is not documented!-->
 
     <!--property StandardInputData is not documented!-->
 
     <!--property StandardOutput is not documented!-->
 
     <!--property StandardOutputFileDescriptorName is not documented!-->
 
     <!--property StandardError is not documented!-->
 
     <!--property StandardErrorFileDescriptorName is not documented!-->
 
     <!--property TTYPath is not documented!-->
 
     <!--property TTYReset is not documented!-->
 
     <!--property TTYVHangup is not documented!-->
 
     <!--property TTYVTDisallocate is not documented!-->
 
     <!--property TTYRows is not documented!-->
 
     <!--property TTYColumns is not documented!-->
 
     <!--property SyslogPriority is not documented!-->
 
     <!--property SyslogIdentifier is not documented!-->
 
     <!--property SyslogLevelPrefix is not documented!-->
 
     <!--property SyslogLevel is not documented!-->
 
     <!--property SyslogFacility is not documented!-->
 
     <!--property LogLevelMax is not documented!-->
 
     <!--property LogRateLimitIntervalUSec is not documented!-->
 
     <!--property LogRateLimitBurst is not documented!-->
 
     <!--property LogExtraFields is not documented!-->
 
     <!--property LogNamespace is not documented!-->
 
     <!--property AmbientCapabilities is not documented!-->
 
     <!--property User is not documented!-->
 
     <!--property Group is not documented!-->
 
     <!--property DynamicUser is not documented!-->
 
-    <!--property DynamicUserNFTSet is not documented!-->
-
     <!--property RemoveIPC is not documented!-->
 
     <!--property SetCredential is not documented!-->
 
     <!--property SetCredentialEncrypted is not documented!-->
 
     <!--property LoadCredential is not documented!-->
 
     <!--property LoadCredentialEncrypted is not documented!-->
 
     <!--property SupplementaryGroups is not documented!-->
 
     <!--property PAMName is not documented!-->
 
     <!--property ReadWritePaths is not documented!-->
 
     <!--property ReadOnlyPaths is not documented!-->
 
     <!--property InaccessiblePaths is not documented!-->
 
     <!--property ExecPaths is not documented!-->
 
     <!--property NoExecPaths is not documented!-->
 
     <!--property ExecSearchPath is not documented!-->
 
     <!--property PrivateTmp is not documented!-->
 
     <!--property PrivateDevices is not documented!-->
 
     <!--property ProtectClock is not documented!-->
 
     <!--property ProtectKernelTunables is not documented!-->
 
     <!--property ProtectKernelModules is not documented!-->
 
     <!--property ProtectKernelLogs is not documented!-->
 
     <!--property ProtectControlGroups is not documented!-->
 
     <!--property PrivateNetwork is not documented!-->
 
     <!--property PrivateUsers is not documented!-->
 
     <!--property PrivateMounts is not documented!-->
 
     <!--property PrivateIPC is not documented!-->
 
     <!--property ProtectHome is not documented!-->
 
     <!--property ProtectSystem is not documented!-->
 
     <!--property SameProcessGroup is not documented!-->
 
     <!--property UtmpIdentifier is not documented!-->
 
     <!--property UtmpMode is not documented!-->
 
     <!--property SELinuxContext is not documented!-->
 
     <!--property AppArmorProfile is not documented!-->
 
     <!--property SmackProcessLabel is not documented!-->
 
     <!--property IgnoreSIGPIPE is not documented!-->
 
     <!--property NoNewPrivileges is not documented!-->
 
     <!--property SystemCallFilter is not documented!-->
 
     <!--property SystemCallArchitectures is not documented!-->
 
     <!--property SystemCallErrorNumber is not documented!-->
 
     <!--property SystemCallLog is not documented!-->
 
     <!--property Personality is not documented!-->
 
     <!--property LockPersonality is not documented!-->
 
     <!--property RestrictAddressFamilies is not documented!-->
 
     <!--property RuntimeDirectoryPreserve is not documented!-->
 
     <!--property RuntimeDirectoryMode is not documented!-->
 
     <!--property StateDirectoryMode is not documented!-->
 
     <!--property CacheDirectoryMode is not documented!-->
 
     <!--property LogsDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectory is not documented!-->
 
     <!--property TimeoutCleanUSec is not documented!-->
 
     <!--property MemoryDenyWriteExecute is not documented!-->
 
     <!--property RestrictRealtime is not documented!-->
 
     <!--property RestrictSUIDSGID is not documented!-->
 
     <!--property RestrictNamespaces is not documented!-->
 
     <!--property RestrictFileSystems is not documented!-->
 
     <!--property BindPaths is not documented!-->
 
     <!--property BindReadOnlyPaths is not documented!-->
 
     <!--property TemporaryFileSystem is not documented!-->
 
     <!--property MountAPIVFS is not documented!-->
 
     <!--property KeyringMode is not documented!-->
 
     <!--property ProtectProc is not documented!-->
 
     <!--property ProcSubset is not documented!-->
 
     <!--property ProtectHostname is not documented!-->
 
     <!--property NetworkNamespacePath is not documented!-->
 
     <!--property IPCNamespacePath is not documented!-->
 
     <!--property KillMode is not documented!-->
 
     <!--property KillSignal is not documented!-->
 
     <!--property RestartKillSignal is not documented!-->
 
     <!--property FinalKillSignal is not documented!-->
 
     <!--property SendSIGKILL is not documented!-->
 
     <!--property SendSIGHUP is not documented!-->
 
     <!--property WatchdogSignal is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Socket"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Socket"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindIPv6Only"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Backlog"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindToDevice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketUser"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Accept"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FlushPending"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Writable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeepAlive"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeepAliveTimeUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeepAliveIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeepAliveProbes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeferAcceptUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoDelay"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Priority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReceiveBuffer"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendBuffer"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPTOS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPTTL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PipeSize"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FreeBind"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Transparent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Broadcast"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassCredentials"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassSecurity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassPacketInfo"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Timestamping"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RemoveOnStop"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Listen"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Symlinks"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Mark"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MaxConnections"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MaxConnectionsPerSource"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MessageQueueMaxMessages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MessageQueueMessageSize"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TCPCongestion"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReusePort"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackLabel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackLabelIPIn"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackLabelIPOut"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Result"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NConnections"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NAccepted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NRefused"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketProtocol"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TriggerLimitIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TriggerLimitBurst"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="GID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPre"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStartPost"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStopPre"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecStopPost"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="Environment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EnvironmentFiles"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UnsetEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPU"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPUSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATASoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitAS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitASSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROCSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDING"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDINGSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIO"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIOSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIME"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIMESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WorkingDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImage"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImageOptions"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHash"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignature"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignaturePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootVerity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionDirectories"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OOMScoreAdjust"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CoredumpFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Nice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingClass"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinityFromNUMA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimerSlackNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingResetOnFork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NonBlocking"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputData"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardError"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardErrorFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYReset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVHangup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVTDisallocate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYRows"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYColumns"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevelPrefix"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogFacility"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogLevelMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitBurst"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogExtraFields"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogNamespace"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SecureBits"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CapabilityBoundingSet"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AmbientCapabilities"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="User"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Group"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DynamicUser"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="DynamicUserNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="RemoveIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SupplementaryGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PAMName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadWritePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="InaccessiblePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecSearchPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountFlags"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateTmp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateDevices"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectClock"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelTunables"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelModules"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelLogs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectControlGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateNetwork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateUsers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateMounts"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHome"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SameProcessGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SELinuxContext"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AppArmorProfile"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackProcessLabel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IgnoreSIGPIPE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoNewPrivileges"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallArchitectures"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallErrorNumber"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallLog"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Personality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LockPersonality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictAddressFamilies"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryPreserve"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutCleanUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryDenyWriteExecute"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictRealtime"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictSUIDSGID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNamespaces"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictFileSystems"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TemporaryFileSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountAPIVFS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeyringMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectProc"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProcSubset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHostname"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NetworkNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPCNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FinalKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGKILL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGHUP"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogSignal"/>
 
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Properties</title>
 
       <para>Most of the properties map directly to the corresponding settings in socket unit files. As socket
       units can include <varname>ExecStartPre</varname> (and similar) fields which contain information about
       processes to execute. They also share most of the fields related to the execution context that Service
       objects expose (see above).</para>
 
       <para>In addition to these properties there are the following:</para>
 
       <para><varname>NAccepted</varname> contains the accumulated number of connections ever accepted on this
       socket. This only applies to sockets with <varname>Accept</varname> set to <literal>yes</literal>,
       i.e. those where systemd is responsible for accepted connections. </para>
 
       <para>Similarly <varname>NConnections</varname> contains the number of currently open connections on
       this socket. It only applies only to socket units with <varname>Accept</varname> set to
       <literal>yes</literal>.</para>
 
       <para><varname>Result</varname> encodes the reason why a socket unit failed if it is in the
       <literal>failed</literal> state (see <varname>ActiveState</varname> above). The values
       <literal>success</literal>, <literal>resources</literal>, <literal>timeout</literal>,
       <literal>exit-code</literal>, <literal>signal</literal> and <literal>core-dump</literal> have the same
       meaning as they have for the corresponding field of service units (see above). In addition to that,
       the value <literal>service-failed-permanent</literal> indicates that the service of this socket failed
       continuously.</para>
 
       <para><varname>FlushPending</varname> specifies whether to flush the socket
       just before entering the listening state. This setting only applies to sockets with
       <varname>Accept=</varname> set to <literal>no</literal>.</para>
     </refsect2>
   </refsect1>
 
   <refsect1>
     <title>Target Unit Objects</title>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/basic_2etarget" interface="org.freedesktop.systemd1.Target">
@@ -6129,1582 +6105,1570 @@ node /org/freedesktop/systemd1/unit/dev_2dttyS0_2edevice {
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/home_2emount" interface="org.freedesktop.systemd1.Mount">
 node /org/freedesktop/systemd1/unit/home_2emount {
   interface org.freedesktop.systemd1.Mount {
     methods:
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     properties:
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Where = '...';
       readonly s What = '...';
       readonly s Options = '...';
       readonly s Type = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutUSec = ...;
       readonly u ControlPID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u DirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SloppyOptions = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b LazyUnmount = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ForceUnmount = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ReadWriteOnly = ...;
       readonly s Result = '...';
       readonly u UID = ...;
       readonly u GID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecMount = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecUnmount = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecRemount = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as Environment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sb) EnvironmentFiles = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as PassEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as UnsetEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u UMask = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPU = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPUSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATASoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitAS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitASSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROCSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDING = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDINGSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIO = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIOSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIME = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIMESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s WorkingDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootImage = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) RootImageOptions = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHash = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHashSignature = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashSignaturePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootVerity = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExtensionDirectories = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sba(ss)) ExtensionImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssba(ss)) MountImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i OOMScoreAdjust = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CoredumpFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Nice = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingClass = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay CPUAffinity = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUAffinityFromNUMA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i NUMAPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay NUMAMask = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimerSlackNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUSchedulingResetOnFork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NonBlocking = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay StandardInputData = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardError = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardErrorFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TTYPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYReset = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVHangup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVTDisallocate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYRows = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYColumns = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SyslogIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SyslogLevelPrefix = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogLevel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogFacility = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i LogLevelMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LogRateLimitIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogRateLimitBurst = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly aay LogExtraFields = [[...], ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s LogNamespace = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SecureBits = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CapabilityBoundingSet = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t AmbientCapabilities = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s User = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Group = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b DynamicUser = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) DynamicUserNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemoveIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SupplementaryGroups = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s PAMName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadWritePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadOnlyPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as InaccessiblePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as NoExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecSearchPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t MountFlags = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateTmp = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateDevices = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectClock = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelTunables = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelModules = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelLogs = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectControlGroups = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateNetwork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateUsers = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateMounts = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectHome = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectSystem = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SameProcessGroup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SELinuxContext = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) AppArmorProfile = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SmackProcessLabel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b IgnoreSIGPIPE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NoNewPrivileges = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SystemCallArchitectures = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SystemCallErrorNumber = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallLog = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Personality = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b LockPersonality = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictAddressFamilies = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) RuntimeDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RuntimeDirectoryPreserve = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u RuntimeDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as RuntimeDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) StateDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u StateDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as StateDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) CacheDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u CacheDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as CacheDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) LogsDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogsDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as LogsDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u ConfigurationDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ConfigurationDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutCleanUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MemoryDenyWriteExecute = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictRealtime = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictSUIDSGID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RestrictNamespaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictFileSystems = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindReadOnlyPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) TemporaryFileSystem = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MountAPIVFS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KeyringMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectProc = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProcSubset = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectHostname = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s NetworkNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IPCNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KillMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i KillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i RestartKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i FinalKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGKILL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGHUP = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i WatchdogSignal = ...;
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property Where is not documented!-->
 
     <!--property What is not documented!-->
 
     <!--property Options is not documented!-->
 
     <!--property Type is not documented!-->
 
     <!--property TimeoutUSec is not documented!-->
 
     <!--property DirectoryMode is not documented!-->
 
     <!--property SloppyOptions is not documented!-->
 
     <!--property LazyUnmount is not documented!-->
 
     <!--property ForceUnmount is not documented!-->
 
     <!--property ReadWriteOnly is not documented!-->
 
     <!--property UID is not documented!-->
 
     <!--property GID is not documented!-->
 
     <!--property ExecUnmount is not documented!-->
 
     <!--property ExecRemount is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--property EnvironmentFiles is not documented!-->
 
     <!--property PassEnvironment is not documented!-->
 
     <!--property UnsetEnvironment is not documented!-->
 
     <!--property UMask is not documented!-->
 
     <!--property LimitCPUSoft is not documented!-->
 
     <!--property LimitFSIZE is not documented!-->
 
     <!--property LimitFSIZESoft is not documented!-->
 
     <!--property LimitDATA is not documented!-->
 
     <!--property LimitDATASoft is not documented!-->
 
     <!--property LimitSTACK is not documented!-->
 
     <!--property LimitSTACKSoft is not documented!-->
 
     <!--property LimitCORE is not documented!-->
 
     <!--property LimitCORESoft is not documented!-->
 
     <!--property LimitRSS is not documented!-->
 
     <!--property LimitRSSSoft is not documented!-->
 
     <!--property LimitNOFILE is not documented!-->
 
     <!--property LimitNOFILESoft is not documented!-->
 
     <!--property LimitAS is not documented!-->
 
     <!--property LimitASSoft is not documented!-->
 
     <!--property LimitNPROC is not documented!-->
 
     <!--property LimitNPROCSoft is not documented!-->
 
     <!--property LimitMEMLOCK is not documented!-->
 
     <!--property LimitMEMLOCKSoft is not documented!-->
 
     <!--property LimitLOCKS is not documented!-->
 
     <!--property LimitLOCKSSoft is not documented!-->
 
     <!--property LimitSIGPENDING is not documented!-->
 
     <!--property LimitSIGPENDINGSoft is not documented!-->
 
     <!--property LimitMSGQUEUE is not documented!-->
 
     <!--property LimitMSGQUEUESoft is not documented!-->
 
     <!--property LimitNICE is not documented!-->
 
     <!--property LimitNICESoft is not documented!-->
 
     <!--property LimitRTPRIO is not documented!-->
 
     <!--property LimitRTPRIOSoft is not documented!-->
 
     <!--property LimitRTTIME is not documented!-->
 
     <!--property LimitRTTIMESoft is not documented!-->
 
     <!--property WorkingDirectory is not documented!-->
 
     <!--property RootHashPath is not documented!-->
 
     <!--property RootHashSignaturePath is not documented!-->
 
     <!--property OOMScoreAdjust is not documented!-->
 
     <!--property CoredumpFilter is not documented!-->
 
     <!--property Nice is not documented!-->
 
     <!--property IOSchedulingClass is not documented!-->
 
     <!--property IOSchedulingPriority is not documented!-->
 
     <!--property CPUSchedulingPolicy is not documented!-->
 
     <!--property CPUSchedulingPriority is not documented!-->
 
     <!--property CPUAffinity is not documented!-->
 
     <!--property CPUAffinityFromNUMA is not documented!-->
 
     <!--property NUMAPolicy is not documented!-->
 
     <!--property NUMAMask is not documented!-->
 
     <!--property TimerSlackNSec is not documented!-->
 
     <!--property CPUSchedulingResetOnFork is not documented!-->
 
     <!--property NonBlocking is not documented!-->
 
     <!--property StandardInput is not documented!-->
 
     <!--property StandardInputFileDescriptorName is not documented!-->
 
     <!--property StandardInputData is not documented!-->
 
     <!--property StandardOutput is not documented!-->
 
     <!--property StandardOutputFileDescriptorName is not documented!-->
 
     <!--property StandardError is not documented!-->
 
     <!--property StandardErrorFileDescriptorName is not documented!-->
 
     <!--property TTYPath is not documented!-->
 
     <!--property TTYReset is not documented!-->
 
     <!--property TTYVHangup is not documented!-->
 
     <!--property TTYVTDisallocate is not documented!-->
 
     <!--property TTYRows is not documented!-->
 
     <!--property TTYColumns is not documented!-->
 
     <!--property SyslogPriority is not documented!-->
 
     <!--property SyslogIdentifier is not documented!-->
 
     <!--property SyslogLevelPrefix is not documented!-->
 
     <!--property SyslogLevel is not documented!-->
 
     <!--property SyslogFacility is not documented!-->
 
     <!--property LogLevelMax is not documented!-->
 
     <!--property LogRateLimitIntervalUSec is not documented!-->
 
     <!--property LogRateLimitBurst is not documented!-->
 
     <!--property LogExtraFields is not documented!-->
 
     <!--property LogNamespace is not documented!-->
 
     <!--property AmbientCapabilities is not documented!-->
 
     <!--property User is not documented!-->
 
     <!--property Group is not documented!-->
 
     <!--property DynamicUser is not documented!-->
 
-    <!--property DynamicUserNFTSet is not documented!-->
-
     <!--property RemoveIPC is not documented!-->
 
     <!--property SetCredential is not documented!-->
 
     <!--property SetCredentialEncrypted is not documented!-->
 
     <!--property LoadCredential is not documented!-->
 
     <!--property LoadCredentialEncrypted is not documented!-->
 
     <!--property SupplementaryGroups is not documented!-->
 
     <!--property PAMName is not documented!-->
 
     <!--property ReadWritePaths is not documented!-->
 
     <!--property ReadOnlyPaths is not documented!-->
 
     <!--property InaccessiblePaths is not documented!-->
 
     <!--property ExecPaths is not documented!-->
 
     <!--property NoExecPaths is not documented!-->
 
     <!--property ExecSearchPath is not documented!-->
 
     <!--property PrivateTmp is not documented!-->
 
     <!--property PrivateDevices is not documented!-->
 
     <!--property ProtectClock is not documented!-->
 
     <!--property ProtectKernelTunables is not documented!-->
 
     <!--property ProtectKernelModules is not documented!-->
 
     <!--property ProtectKernelLogs is not documented!-->
 
     <!--property ProtectControlGroups is not documented!-->
 
     <!--property PrivateNetwork is not documented!-->
 
     <!--property PrivateUsers is not documented!-->
 
     <!--property PrivateMounts is not documented!-->
 
     <!--property PrivateIPC is not documented!-->
 
     <!--property ProtectHome is not documented!-->
 
     <!--property ProtectSystem is not documented!-->
 
     <!--property SameProcessGroup is not documented!-->
 
     <!--property UtmpIdentifier is not documented!-->
 
     <!--property UtmpMode is not documented!-->
 
     <!--property SELinuxContext is not documented!-->
 
     <!--property AppArmorProfile is not documented!-->
 
     <!--property SmackProcessLabel is not documented!-->
 
     <!--property IgnoreSIGPIPE is not documented!-->
 
     <!--property NoNewPrivileges is not documented!-->
 
     <!--property SystemCallFilter is not documented!-->
 
     <!--property SystemCallArchitectures is not documented!-->
 
     <!--property SystemCallErrorNumber is not documented!-->
 
     <!--property SystemCallLog is not documented!-->
 
     <!--property Personality is not documented!-->
 
     <!--property LockPersonality is not documented!-->
 
     <!--property RestrictAddressFamilies is not documented!-->
 
     <!--property RuntimeDirectoryPreserve is not documented!-->
 
     <!--property RuntimeDirectoryMode is not documented!-->
 
     <!--property StateDirectoryMode is not documented!-->
 
     <!--property CacheDirectoryMode is not documented!-->
 
     <!--property LogsDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectory is not documented!-->
 
     <!--property TimeoutCleanUSec is not documented!-->
 
     <!--property MemoryDenyWriteExecute is not documented!-->
 
     <!--property RestrictRealtime is not documented!-->
 
     <!--property RestrictSUIDSGID is not documented!-->
 
     <!--property RestrictNamespaces is not documented!-->
 
     <!--property RestrictFileSystems is not documented!-->
 
     <!--property BindPaths is not documented!-->
 
     <!--property BindReadOnlyPaths is not documented!-->
 
     <!--property TemporaryFileSystem is not documented!-->
 
     <!--property MountAPIVFS is not documented!-->
 
     <!--property KeyringMode is not documented!-->
 
     <!--property ProtectProc is not documented!-->
 
     <!--property ProcSubset is not documented!-->
 
     <!--property ProtectHostname is not documented!-->
 
     <!--property NetworkNamespacePath is not documented!-->
 
     <!--property IPCNamespacePath is not documented!-->
 
     <!--property KillMode is not documented!-->
 
     <!--property KillSignal is not documented!-->
 
     <!--property RestartKillSignal is not documented!-->
 
     <!--property FinalKillSignal is not documented!-->
 
     <!--property SendSIGKILL is not documented!-->
 
     <!--property SendSIGHUP is not documented!-->
 
     <!--property WatchdogSignal is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Mount"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Mount"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Where"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="What"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Options"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Type"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SloppyOptions"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LazyUnmount"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ForceUnmount"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadWriteOnly"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Result"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="GID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecMount"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecUnmount"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecRemount"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="Environment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EnvironmentFiles"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UnsetEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPU"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPUSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATASoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitAS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitASSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROCSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDING"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDINGSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIO"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIOSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIME"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIMESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WorkingDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImage"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImageOptions"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHash"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignature"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignaturePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootVerity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionDirectories"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OOMScoreAdjust"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CoredumpFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Nice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingClass"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinityFromNUMA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimerSlackNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingResetOnFork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NonBlocking"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputData"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardError"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardErrorFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYReset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVHangup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVTDisallocate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYRows"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYColumns"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevelPrefix"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogFacility"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogLevelMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitBurst"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogExtraFields"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogNamespace"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SecureBits"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CapabilityBoundingSet"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AmbientCapabilities"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="User"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Group"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DynamicUser"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="DynamicUserNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="RemoveIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SupplementaryGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PAMName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadWritePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="InaccessiblePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecSearchPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountFlags"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateTmp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateDevices"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectClock"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelTunables"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelModules"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelLogs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectControlGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateNetwork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateUsers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateMounts"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHome"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SameProcessGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SELinuxContext"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AppArmorProfile"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackProcessLabel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IgnoreSIGPIPE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoNewPrivileges"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallArchitectures"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallErrorNumber"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallLog"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Personality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LockPersonality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictAddressFamilies"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryPreserve"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutCleanUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryDenyWriteExecute"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictRealtime"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictSUIDSGID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNamespaces"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictFileSystems"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TemporaryFileSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountAPIVFS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeyringMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectProc"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProcSubset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHostname"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NetworkNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPCNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FinalKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGKILL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGHUP"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogSignal"/>
 
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Properties</title>
 
       <para>Most of the properties map directly to the corresponding settings in mount unit files. As mount
       units invoke the <filename>/usr/bin/mount</filename> command, their bus objects include implicit
       <varname>ExecMount</varname> (and similar) fields which contain information about processes to
       execute. They also share most of the fields related to the execution context that Service objects
       expose (see above). In addition to these properties there are the following:</para>
 
       <para><varname>ControlPID</varname> contains the PID of the currently running
       <filename>/usr/bin/mount</filename> or <filename>/usr/bin/umount</filename> command if there is one
       running, otherwise 0.</para>
 
       <para><varname>Result</varname> contains a value explaining why a mount unit failed if it failed. It
       can take the values <literal>success</literal>, <literal>resources</literal>,
       <literal>timeout</literal>, <literal>exit-code</literal>, <literal>signal</literal>, or
       <literal>core-dump</literal> which have the identical meaning as the corresponding values of the
       corresponding field of service unit objects (see above).</para>
     </refsect2>
   </refsect1>
 
   <refsect1>
     <title>Automount Unit Objects</title>
 
     <para>All automount unit objects implement the
     <interfacename>org.freedesktop.systemd1.Automount</interfacename> interface (described here) in addition
     to the generic <interfacename>org.freedesktop.systemd1.Unit</interfacename> interface (see above).</para>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/proc_2dsys_2dfs_2dbinfmt_5fmisc_2eautomount" interface="org.freedesktop.systemd1.Automount">
@@ -7923,1540 +7887,1528 @@ node /org/freedesktop/systemd1/unit/systemd_2dtmpfiles_2dclean_2etimer {
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/dev_2dsda3_2eswap" interface="org.freedesktop.systemd1.Swap">
 node /org/freedesktop/systemd1/unit/dev_2dsda3_2eswap {
   interface org.freedesktop.systemd1.Swap {
     methods:
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     properties:
       readonly s What = '...';
       readonly i Priority = ...;
       readonly s Options = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutUSec = ...;
       readonly u ControlPID = ...;
       readonly s Result = '...';
       readonly u UID = ...;
       readonly u GID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecActivate = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("invalidates")
       readonly a(sasbttttuii) ExecDeactivate = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as Environment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sb) EnvironmentFiles = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as PassEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as UnsetEnvironment = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u UMask = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPU = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCPUSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitFSIZESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitDATASoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSTACKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitCORESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRSSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNOFILESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitAS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitASSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNPROCSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCK = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMEMLOCKSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitLOCKSSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDING = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitSIGPENDINGSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitMSGQUEUESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitNICESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIO = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTPRIOSoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIME = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LimitRTTIMESoft = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s WorkingDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootDirectory = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootImage = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) RootImageOptions = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHash = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay RootHashSignature = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootHashSignaturePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RootVerity = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExtensionDirectories = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sba(ss)) ExtensionImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssba(ss)) MountImages = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i OOMScoreAdjust = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CoredumpFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i Nice = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingClass = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i IOSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i CPUSchedulingPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay CPUAffinity = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUAffinityFromNUMA = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i NUMAPolicy = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay NUMAMask = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimerSlackNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b CPUSchedulingResetOnFork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NonBlocking = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardInputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly ay StandardInputData = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutput = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardOutputFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardError = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s StandardErrorFileDescriptorName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s TTYPath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYReset = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVHangup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b TTYVTDisallocate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYRows = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly q TTYColumns = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogPriority = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s SyslogIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SyslogLevelPrefix = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogLevel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SyslogFacility = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i LogLevelMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t LogRateLimitIntervalUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogRateLimitBurst = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly aay LogExtraFields = [[...], ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s LogNamespace = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SecureBits = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t CapabilityBoundingSet = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t AmbientCapabilities = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s User = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Group = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b DynamicUser = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) DynamicUserNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RemoveIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(say) SetCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredential = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) LoadCredentialEncrypted = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SupplementaryGroups = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s PAMName = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadWritePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ReadOnlyPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as InaccessiblePaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as NoExecPaths = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ExecSearchPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t MountFlags = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateTmp = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateDevices = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectClock = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelTunables = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelModules = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectKernelLogs = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectControlGroups = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateNetwork = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateUsers = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateMounts = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b PrivateIPC = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectHome = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectSystem = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SameProcessGroup = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpIdentifier = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s UtmpMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SELinuxContext = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) AppArmorProfile = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bs) SmackProcessLabel = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b IgnoreSIGPIPE = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b NoNewPrivileges = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallFilter = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as SystemCallArchitectures = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i SystemCallErrorNumber = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) SystemCallLog = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s Personality = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b LockPersonality = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictAddressFamilies = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) RuntimeDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s RuntimeDirectoryPreserve = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u RuntimeDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as RuntimeDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) StateDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u StateDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as StateDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) CacheDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u CacheDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as CacheDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(sst) LogsDirectorySymlink = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u LogsDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as LogsDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly u ConfigurationDirectoryMode = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly as ConfigurationDirectory = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutCleanUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MemoryDenyWriteExecute = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictRealtime = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b RestrictSUIDSGID = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RestrictNamespaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly (bas) RestrictFileSystems = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ssbt) BindReadOnlyPaths = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly a(ss) TemporaryFileSystem = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b MountAPIVFS = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KeyringMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProtectProc = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s ProcSubset = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b ProtectHostname = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s NetworkNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IPCNamespacePath = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KillMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i KillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i RestartKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i FinalKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGKILL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGHUP = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i WatchdogSignal = ...;
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property What is not documented!-->
 
     <!--property Priority is not documented!-->
 
     <!--property Options is not documented!-->
 
     <!--property TimeoutUSec is not documented!-->
 
     <!--property UID is not documented!-->
 
     <!--property GID is not documented!-->
 
     <!--property ExecDeactivate is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--property EnvironmentFiles is not documented!-->
 
     <!--property PassEnvironment is not documented!-->
 
     <!--property UnsetEnvironment is not documented!-->
 
     <!--property UMask is not documented!-->
 
     <!--property LimitCPUSoft is not documented!-->
 
     <!--property LimitFSIZE is not documented!-->
 
     <!--property LimitFSIZESoft is not documented!-->
 
     <!--property LimitDATA is not documented!-->
 
     <!--property LimitDATASoft is not documented!-->
 
     <!--property LimitSTACK is not documented!-->
 
     <!--property LimitSTACKSoft is not documented!-->
 
     <!--property LimitCORE is not documented!-->
 
     <!--property LimitCORESoft is not documented!-->
 
     <!--property LimitRSS is not documented!-->
 
     <!--property LimitRSSSoft is not documented!-->
 
     <!--property LimitNOFILE is not documented!-->
 
     <!--property LimitNOFILESoft is not documented!-->
 
     <!--property LimitAS is not documented!-->
 
     <!--property LimitASSoft is not documented!-->
 
     <!--property LimitNPROC is not documented!-->
 
     <!--property LimitNPROCSoft is not documented!-->
 
     <!--property LimitMEMLOCK is not documented!-->
 
     <!--property LimitMEMLOCKSoft is not documented!-->
 
     <!--property LimitLOCKS is not documented!-->
 
     <!--property LimitLOCKSSoft is not documented!-->
 
     <!--property LimitSIGPENDING is not documented!-->
 
     <!--property LimitSIGPENDINGSoft is not documented!-->
 
     <!--property LimitMSGQUEUE is not documented!-->
 
     <!--property LimitMSGQUEUESoft is not documented!-->
 
     <!--property LimitNICE is not documented!-->
 
     <!--property LimitNICESoft is not documented!-->
 
     <!--property LimitRTPRIO is not documented!-->
 
     <!--property LimitRTPRIOSoft is not documented!-->
 
     <!--property LimitRTTIME is not documented!-->
 
     <!--property LimitRTTIMESoft is not documented!-->
 
     <!--property WorkingDirectory is not documented!-->
 
     <!--property RootHashPath is not documented!-->
 
     <!--property RootHashSignaturePath is not documented!-->
 
     <!--property OOMScoreAdjust is not documented!-->
 
     <!--property CoredumpFilter is not documented!-->
 
     <!--property Nice is not documented!-->
 
     <!--property IOSchedulingClass is not documented!-->
 
     <!--property IOSchedulingPriority is not documented!-->
 
     <!--property CPUSchedulingPolicy is not documented!-->
 
     <!--property CPUSchedulingPriority is not documented!-->
 
     <!--property CPUAffinity is not documented!-->
 
     <!--property CPUAffinityFromNUMA is not documented!-->
 
     <!--property NUMAPolicy is not documented!-->
 
     <!--property NUMAMask is not documented!-->
 
     <!--property TimerSlackNSec is not documented!-->
 
     <!--property CPUSchedulingResetOnFork is not documented!-->
 
     <!--property NonBlocking is not documented!-->
 
     <!--property StandardInput is not documented!-->
 
     <!--property StandardInputFileDescriptorName is not documented!-->
 
     <!--property StandardInputData is not documented!-->
 
     <!--property StandardOutput is not documented!-->
 
     <!--property StandardOutputFileDescriptorName is not documented!-->
 
     <!--property StandardError is not documented!-->
 
     <!--property StandardErrorFileDescriptorName is not documented!-->
 
     <!--property TTYPath is not documented!-->
 
     <!--property TTYReset is not documented!-->
 
     <!--property TTYVHangup is not documented!-->
 
     <!--property TTYVTDisallocate is not documented!-->
 
     <!--property TTYRows is not documented!-->
 
     <!--property TTYColumns is not documented!-->
 
     <!--property SyslogPriority is not documented!-->
 
     <!--property SyslogIdentifier is not documented!-->
 
     <!--property SyslogLevelPrefix is not documented!-->
 
     <!--property SyslogLevel is not documented!-->
 
     <!--property SyslogFacility is not documented!-->
 
     <!--property LogLevelMax is not documented!-->
 
     <!--property LogRateLimitIntervalUSec is not documented!-->
 
     <!--property LogRateLimitBurst is not documented!-->
 
     <!--property LogExtraFields is not documented!-->
 
     <!--property LogNamespace is not documented!-->
 
     <!--property AmbientCapabilities is not documented!-->
 
     <!--property User is not documented!-->
 
     <!--property Group is not documented!-->
 
     <!--property DynamicUser is not documented!-->
 
-    <!--property DynamicUserNFTSet is not documented!-->
-
     <!--property RemoveIPC is not documented!-->
 
     <!--property SetCredential is not documented!-->
 
     <!--property SetCredentialEncrypted is not documented!-->
 
     <!--property LoadCredential is not documented!-->
 
     <!--property LoadCredentialEncrypted is not documented!-->
 
     <!--property SupplementaryGroups is not documented!-->
 
     <!--property PAMName is not documented!-->
 
     <!--property ReadWritePaths is not documented!-->
 
     <!--property ReadOnlyPaths is not documented!-->
 
     <!--property InaccessiblePaths is not documented!-->
 
     <!--property ExecPaths is not documented!-->
 
     <!--property NoExecPaths is not documented!-->
 
     <!--property ExecSearchPath is not documented!-->
 
     <!--property PrivateTmp is not documented!-->
 
     <!--property PrivateDevices is not documented!-->
 
     <!--property ProtectClock is not documented!-->
 
     <!--property ProtectKernelTunables is not documented!-->
 
     <!--property ProtectKernelModules is not documented!-->
 
     <!--property ProtectKernelLogs is not documented!-->
 
     <!--property ProtectControlGroups is not documented!-->
 
     <!--property PrivateNetwork is not documented!-->
 
     <!--property PrivateUsers is not documented!-->
 
     <!--property PrivateMounts is not documented!-->
 
     <!--property PrivateIPC is not documented!-->
 
     <!--property ProtectHome is not documented!-->
 
     <!--property ProtectSystem is not documented!-->
 
     <!--property SameProcessGroup is not documented!-->
 
     <!--property UtmpIdentifier is not documented!-->
 
     <!--property UtmpMode is not documented!-->
 
     <!--property SELinuxContext is not documented!-->
 
     <!--property AppArmorProfile is not documented!-->
 
     <!--property SmackProcessLabel is not documented!-->
 
     <!--property IgnoreSIGPIPE is not documented!-->
 
     <!--property NoNewPrivileges is not documented!-->
 
     <!--property SystemCallFilter is not documented!-->
 
     <!--property SystemCallArchitectures is not documented!-->
 
     <!--property SystemCallErrorNumber is not documented!-->
 
     <!--property SystemCallLog is not documented!-->
 
     <!--property Personality is not documented!-->
 
     <!--property LockPersonality is not documented!-->
 
     <!--property RestrictAddressFamilies is not documented!-->
 
     <!--property RuntimeDirectoryPreserve is not documented!-->
 
     <!--property RuntimeDirectoryMode is not documented!-->
 
     <!--property StateDirectoryMode is not documented!-->
 
     <!--property CacheDirectoryMode is not documented!-->
 
     <!--property LogsDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectoryMode is not documented!-->
 
     <!--property ConfigurationDirectory is not documented!-->
 
     <!--property TimeoutCleanUSec is not documented!-->
 
     <!--property MemoryDenyWriteExecute is not documented!-->
 
     <!--property RestrictRealtime is not documented!-->
 
     <!--property RestrictSUIDSGID is not documented!-->
 
     <!--property RestrictNamespaces is not documented!-->
 
     <!--property RestrictFileSystems is not documented!-->
 
     <!--property BindPaths is not documented!-->
 
     <!--property BindReadOnlyPaths is not documented!-->
 
     <!--property TemporaryFileSystem is not documented!-->
 
     <!--property MountAPIVFS is not documented!-->
 
     <!--property KeyringMode is not documented!-->
 
     <!--property ProtectProc is not documented!-->
 
     <!--property ProcSubset is not documented!-->
 
     <!--property ProtectHostname is not documented!-->
 
     <!--property NetworkNamespacePath is not documented!-->
 
     <!--property IPCNamespacePath is not documented!-->
 
     <!--property KillMode is not documented!-->
 
     <!--property KillSignal is not documented!-->
 
     <!--property RestartKillSignal is not documented!-->
 
     <!--property FinalKillSignal is not documented!-->
 
     <!--property SendSIGKILL is not documented!-->
 
     <!--property SendSIGHUP is not documented!-->
 
     <!--property WatchdogSignal is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Swap"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Swap"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="What"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Priority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Options"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlPID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Result"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="GID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecActivate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecDeactivate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="Environment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EnvironmentFiles"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PassEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UnsetEnvironment"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPU"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCPUSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitFSIZESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitDATASoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSTACKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitCORESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRSSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNOFILESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitAS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitASSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNPROCSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCK"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMEMLOCKSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitLOCKSSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDING"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitSIGPENDINGSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitMSGQUEUESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitNICESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIO"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTPRIOSoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIME"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LimitRTTIMESoft"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WorkingDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImage"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootImageOptions"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHash"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignature"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootHashSignaturePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RootVerity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionDirectories"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExtensionImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountImages"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="OOMScoreAdjust"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CoredumpFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Nice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingClass"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinity"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAffinityFromNUMA"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAPolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NUMAMask"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimerSlackNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUSchedulingResetOnFork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NonBlocking"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardInputData"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutput"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardOutputFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardError"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StandardErrorFileDescriptorName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYReset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVHangup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYVTDisallocate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYRows"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TTYColumns"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogPriority"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevelPrefix"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogLevel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SyslogFacility"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogLevelMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitIntervalUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogRateLimitBurst"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogExtraFields"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogNamespace"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SecureBits"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CapabilityBoundingSet"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AmbientCapabilities"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="User"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Group"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DynamicUser"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="DynamicUserNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="RemoveIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SetCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredential"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LoadCredentialEncrypted"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SupplementaryGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PAMName"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadWritePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="InaccessiblePaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoExecPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ExecSearchPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountFlags"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateTmp"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateDevices"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectClock"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelTunables"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelModules"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectKernelLogs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectControlGroups"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateNetwork"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateUsers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateMounts"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="PrivateIPC"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHome"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SameProcessGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpIdentifier"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="UtmpMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SELinuxContext"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AppArmorProfile"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SmackProcessLabel"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IgnoreSIGPIPE"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NoNewPrivileges"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallFilter"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallArchitectures"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallErrorNumber"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SystemCallLog"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Personality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LockPersonality"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictAddressFamilies"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryPreserve"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StateDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CacheDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectorySymlink"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="LogsDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectoryMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ConfigurationDirectory"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutCleanUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryDenyWriteExecute"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictRealtime"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictSUIDSGID"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNamespaces"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictFileSystems"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BindReadOnlyPaths"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TemporaryFileSystem"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MountAPIVFS"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KeyringMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectProc"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProcSubset"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ProtectHostname"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="NetworkNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPCNamespacePath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FinalKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGKILL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGHUP"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogSignal"/>
 
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Properties</title>
 
       <para>Most of the properties map directly to the corresponding settings in swap unit files. As mount
       units invoke the
       <citerefentry project="man-pages"><refentrytitle>swapon</refentrytitle><manvolnum>8</manvolnum></citerefentry> command,
       their bus objects include implicit <varname>ExecActivate</varname> (and similar) fields which contain
       information about processes to execute. They also share most of the fields related to the execution
       context that Service objects expose (see above). In addition to these properties there are the
       following:</para>
 
       <para><varname>ControlPID</varname> contains the PID of the currently running
       <citerefentry project="man-pages"><refentrytitle>swapon</refentrytitle><manvolnum>8</manvolnum></citerefentry> or
       <citerefentry project="man-pages"><refentrytitle>swapoff</refentrytitle><manvolnum>8</manvolnum></citerefentry>
       command if there is one running, otherwise 0.</para>
 
       <para><varname>Result</varname> contains a value explaining why a mount unit failed if it failed. It
       can take the values <literal>success</literal>, <literal>resources</literal>,
       <literal>timeout</literal>, <literal>exit-code</literal>, <literal>signal</literal>, or
       <literal>core-dump</literal> which have the identical meanings as the corresponding values of the
       corresponding field of service unit objects (see above).</para>
     </refsect2>
   </refsect1>
 
 
   <refsect1>
     <title>Path Unit Objects</title>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/cups_2epath" interface="org.freedesktop.systemd1.Path">
@@ -9547,1062 +9499,1050 @@ node /org/freedesktop/systemd1/unit/cups_2epath {
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/system_2eslice" interface="org.freedesktop.systemd1.Slice">
 node /org/freedesktop/systemd1/unit/system_2eslice {
   interface org.freedesktop.systemd1.Slice {
     methods:
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     properties:
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Slice"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Slice"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Properties</title>
 
       <para>Most properties correspond directly with the matching settings in slice unit files.</para>
     </refsect2>
   </refsect1>
 
   <refsect1>
     <title>Scope Unit Objects</title>
 
     <para>All scope unit objects implement the <interfacename>org.freedesktop.systemd1.Scope</interfacename>
     interface (described here) in addition to the generic
     <interfacename>org.freedesktop.systemd1.Unit</interfacename> interface (see above).</para>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/unit/session_2d1_2escope" interface="org.freedesktop.systemd1.Scope">
 node /org/freedesktop/systemd1/unit/session_2d1_2escope {
   interface org.freedesktop.systemd1.Scope {
     methods:
       Abandon();
       GetProcesses(out a(sus) processes);
       AttachProcesses(in  s subcgroup,
                       in  au pids);
     signals:
       RequestStop();
     properties:
       readonly s Controller = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t TimeoutStopUSec = ...;
       readonly s Result = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RuntimeMaxUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t RuntimeRandomizedExtraUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s Slice = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ControlGroup = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t ControlGroupId = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryAvailable = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUUsageNSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay EffectiveMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksCurrent = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPIngressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IPEgressPackets = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOReadOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteBytes = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWriteOperations = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b Delegate = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DelegateControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b CPUAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupCPUShares = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPerSecUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t CPUQuotaPeriodUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedCPUs = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay AllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly ay StartupAllowedMemoryNodes = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t IOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteBandwidthMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOReadIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IOWriteIOPSMax = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) IODeviceLatencyTargetUSec = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b BlockIOAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t BlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t StartupBlockIOWeight = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIODeviceWeight = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOReadBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(st) BlockIOWriteBandwidth = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b MemoryAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t DefaultMemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMin = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLow = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryHigh = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemorySwapMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t MemoryLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s DevicePolicy = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) DeviceAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b TasksAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly t TasksMax = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly b IPAccounting = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iayu) IPAddressDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPIngressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as IPEgressFilterPath = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly as DisableControllers = ['...', ...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMSwap = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMMemoryPressure = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly u ManagedOOMMemoryPressureLimit = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly s ManagedOOMPreference = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(ss) BPFProgram = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindAllow = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly a(iiqq) SocketBindDeny = [...];
       @org.freedesktop.DBus.Property.EmitsChangedSignal("false")
       readonly (bas) RestrictNetworkInterfaces = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
-      readonly a(iss) ControlGroupNFTSet = [...];
-      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s KillMode = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i KillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i RestartKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i FinalKillSignal = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGKILL = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly b SendSIGHUP = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly i WatchdogSignal = ...;
   };
   interface org.freedesktop.DBus.Peer { ... };
   interface org.freedesktop.DBus.Introspectable { ... };
   interface org.freedesktop.DBus.Properties { ... };
   interface org.freedesktop.systemd1.Unit { ... };
 };
     </programlisting>
 
     <!--method GetProcesses is not documented!-->
 
     <!--method AttachProcesses is not documented!-->
 
     <!--property RuntimeMaxUSec is not documented!-->
 
     <!--property RuntimeRandomizedExtraUSec is not documented!-->
 
     <!--property Slice is not documented!-->
 
     <!--property ControlGroupId is not documented!-->
 
     <!--property MemoryCurrent is not documented!-->
 
     <!--property CPUUsageNSec is not documented!-->
 
     <!--property EffectiveCPUs is not documented!-->
 
     <!--property EffectiveMemoryNodes is not documented!-->
 
     <!--property TasksCurrent is not documented!-->
 
     <!--property IPIngressBytes is not documented!-->
 
     <!--property IPIngressPackets is not documented!-->
 
     <!--property IPEgressBytes is not documented!-->
 
     <!--property IPEgressPackets is not documented!-->
 
     <!--property IOReadBytes is not documented!-->
 
     <!--property IOReadOperations is not documented!-->
 
     <!--property IOWriteBytes is not documented!-->
 
     <!--property IOWriteOperations is not documented!-->
 
     <!--property Delegate is not documented!-->
 
     <!--property DelegateControllers is not documented!-->
 
     <!--property CPUAccounting is not documented!-->
 
     <!--property CPUWeight is not documented!-->
 
     <!--property StartupCPUWeight is not documented!-->
 
     <!--property CPUShares is not documented!-->
 
     <!--property StartupCPUShares is not documented!-->
 
     <!--property CPUQuotaPerSecUSec is not documented!-->
 
     <!--property CPUQuotaPeriodUSec is not documented!-->
 
     <!--property AllowedCPUs is not documented!-->
 
     <!--property StartupAllowedCPUs is not documented!-->
 
     <!--property AllowedMemoryNodes is not documented!-->
 
     <!--property StartupAllowedMemoryNodes is not documented!-->
 
     <!--property IOAccounting is not documented!-->
 
     <!--property IOWeight is not documented!-->
 
     <!--property StartupIOWeight is not documented!-->
 
     <!--property IODeviceWeight is not documented!-->
 
     <!--property IOReadBandwidthMax is not documented!-->
 
     <!--property IOWriteBandwidthMax is not documented!-->
 
     <!--property IOReadIOPSMax is not documented!-->
 
     <!--property IOWriteIOPSMax is not documented!-->
 
     <!--property IODeviceLatencyTargetUSec is not documented!-->
 
     <!--property BlockIOAccounting is not documented!-->
 
     <!--property BlockIOWeight is not documented!-->
 
     <!--property StartupBlockIOWeight is not documented!-->
 
     <!--property BlockIODeviceWeight is not documented!-->
 
     <!--property BlockIOReadBandwidth is not documented!-->
 
     <!--property BlockIOWriteBandwidth is not documented!-->
 
     <!--property MemoryAccounting is not documented!-->
 
     <!--property DefaultMemoryLow is not documented!-->
 
     <!--property DefaultMemoryMin is not documented!-->
 
     <!--property MemoryMin is not documented!-->
 
     <!--property MemoryLow is not documented!-->
 
     <!--property MemoryHigh is not documented!-->
 
     <!--property MemoryMax is not documented!-->
 
     <!--property MemorySwapMax is not documented!-->
 
     <!--property MemoryLimit is not documented!-->
 
     <!--property DevicePolicy is not documented!-->
 
     <!--property DeviceAllow is not documented!-->
 
     <!--property TasksAccounting is not documented!-->
 
     <!--property TasksMax is not documented!-->
 
     <!--property IPAccounting is not documented!-->
 
     <!--property IPAddressAllow is not documented!-->
 
     <!--property IPAddressDeny is not documented!-->
 
     <!--property IPIngressFilterPath is not documented!-->
 
     <!--property IPEgressFilterPath is not documented!-->
 
     <!--property DisableControllers is not documented!-->
 
     <!--property ManagedOOMSwap is not documented!-->
 
     <!--property ManagedOOMMemoryPressure is not documented!-->
 
     <!--property ManagedOOMMemoryPressureLimit is not documented!-->
 
     <!--property ManagedOOMPreference is not documented!-->
 
     <!--property BPFProgram is not documented!-->
 
     <!--property SocketBindAllow is not documented!-->
 
     <!--property SocketBindDeny is not documented!-->
 
     <!--property RestrictNetworkInterfaces is not documented!-->
 
-    <!--property ControlGroupNFTSet is not documented!-->
-
     <!--property KillMode is not documented!-->
 
     <!--property KillSignal is not documented!-->
 
     <!--property RestartKillSignal is not documented!-->
 
     <!--property FinalKillSignal is not documented!-->
 
     <!--property SendSIGKILL is not documented!-->
 
     <!--property SendSIGHUP is not documented!-->
 
     <!--property WatchdogSignal is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Scope"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Unit"/>
 
     <variablelist class="dbus-interface" generated="True" extra-ref="org.freedesktop.systemd1.Scope"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="Abandon()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="GetProcesses()"/>
 
     <variablelist class="dbus-method" generated="True" extra-ref="AttachProcesses()"/>
 
     <variablelist class="dbus-signal" generated="True" extra-ref="RequestStop"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Controller"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TimeoutStopUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Result"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeMaxUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RuntimeRandomizedExtraUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Slice"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroup"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupId"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAvailable"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUUsageNSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="EffectiveMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksCurrent"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressPackets"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBytes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteOperations"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="Delegate"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DelegateControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupCPUShares"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPerSecUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="CPUQuotaPeriodUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedCPUs"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="AllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupAllowedMemoryNodes"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteBandwidthMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOReadIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IOWriteIOPSMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IODeviceLatencyTargetUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="StartupBlockIOWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIODeviceWeight"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOReadBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BlockIOWriteBandwidth"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DefaultMemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMin"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryHigh"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemorySwapMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="MemoryLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DevicePolicy"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DeviceAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="TasksMax"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAccounting"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPAddressDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPIngressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IPEgressFilterPath"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="DisableControllers"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMSwap"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressure"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMMemoryPressureLimit"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="ManagedOOMPreference"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="BPFProgram"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindAllow"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SocketBindDeny"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestrictNetworkInterfaces"/>
 
-    <variablelist class="dbus-property" generated="True" extra-ref="ControlGroupNFTSet"/>
-
     <variablelist class="dbus-property" generated="True" extra-ref="KillMode"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="KillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="RestartKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="FinalKillSignal"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGKILL"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="SendSIGHUP"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="WatchdogSignal"/>
 
     <!--End of Autogenerated section-->
 
     <refsect2>
       <title>Methods</title>
 
       <para><function>Abandon()</function> may be used to place a scope unit in the "abandoned" state. This
       may be used to inform the system manager that the manager that created the scope lost interest in the
       scope (for example, because it is terminating), without wanting to shut down the scope entirely.</para>
     </refsect2>
 
     <refsect2>
       <title>Signals</title>
 
       <para><function>RequestStop</function> is sent to the peer that is configured in the
       <varname>Controller</varname> property when systemd is requested to terminate the scope unit. A program
       registering a scope can use this to cleanly shut down the processes it added to the scope instead of
       letting systemd do it with the usual <constant>SIGTERM</constant> logic.</para>
     </refsect2>
 
     <refsect2>
       <title>Properties</title>
 
       <para>All properties correspond directly with the matching properties of service units.</para>
 
       <para><varname>Controller</varname> contains the bus name (unique or well-known) that is notified when
       the scope unit is to be shut down via a <function>RequestStop</function> signal (see below). This is
       set when the scope is created. If not set, the scope's processes will terminated with
       <constant>SIGTERM</constant> directly.</para>
     </refsect2>
   </refsect1>
 
 
   <refsect1>
     <title>Job Objects</title>
 
     <para>Job objects encapsulate scheduled or running jobs. Each unit can have none or one jobs in the
     execution queue. Each job is attached to exactly one unit.</para>
 
     <programlisting executable="systemd" node="/org/freedesktop/systemd1/job/666" interface="org.freedesktop.systemd1.Job">
diff --git a/man/systemd.exec.xml b/man/systemd.exec.xml
index c2c36d55e4..e92f615994 100644
--- a/man/systemd.exec.xml
+++ b/man/systemd.exec.xml
@@ -2831,1307 +2831,1273 @@ StandardInput=data
 StandardInputData=V2XigLJyZSBubyBzdHJhbmdlcnMgdG8gbG92ZQpZb3Uga25vdyB0aGUgcnVsZXMgYW5kIHNvIGRv \
                   IEkKQSBmdWxsIGNvbW1pdG1lbnQncyB3aGF0IEnigLJtIHRoaW5raW5nIG9mCllvdSB3b3VsZG4n \
                   dCBnZXQgdGhpcyBmcm9tIGFueSBvdGhlciBndXkKSSBqdXN0IHdhbm5hIHRlbGwgeW91IGhvdyBJ \
                   J20gZmVlbGluZwpHb3R0YSBtYWtlIHlvdSB1bmRlcnN0YW5kCgpOZXZlciBnb25uYSBnaXZlIHlv \
                   dSB1cApOZXZlciBnb25uYSBsZXQgeW91IGRvd24KTmV2ZXIgZ29ubmEgcnVuIGFyb3VuZCBhbmQg \
                   ZGVzZXJ0IHlvdQpOZXZlciBnb25uYSBtYWtlIHlvdSBjcnkKTmV2ZXIgZ29ubmEgc2F5IGdvb2Ri \
                   eWUKTmV2ZXIgZ29ubmEgdGVsbCBhIGxpZSBhbmQgaHVydCB5b3UK
 </programlisting></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LogLevelMax=</varname></term>
 
         <listitem><para>Configures filtering by log level of log messages generated by this unit. Takes a
         <command>syslog</command> log level, one of <option>emerg</option> (lowest log level, only highest priority
         messages), <option>alert</option>, <option>crit</option>, <option>err</option>, <option>warning</option>,
         <option>notice</option>, <option>info</option>, <option>debug</option> (highest log level, also lowest priority
         messages). See <citerefentry
         project='man-pages'><refentrytitle>syslog</refentrytitle><manvolnum>3</manvolnum></citerefentry> for
         details. By default no filtering is applied (i.e. the default maximum log level is <option>debug</option>). Use
         this option to configure the logging system to drop log messages of a specific service above the specified
         level. For example, set <varname>LogLevelMax=</varname><option>info</option> in order to turn off debug logging
         of a particularly chatty unit. Note that the configured level is applied to any log messages written by any
         of the processes belonging to this unit, as well as any log messages written by the system manager process
         (PID 1) in reference to this unit, sent via any supported logging protocol. The filtering is applied
         early in the logging pipeline, before any kind of further processing is done. Moreover, messages which pass
         through this filter successfully might still be dropped by filters applied at a later stage in the logging
         subsystem. For example, <varname>MaxLevelStore=</varname> configured in
         <citerefentry><refentrytitle>journald.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> might
         prohibit messages of higher log levels to be stored on disk, even though the per-unit
         <varname>LogLevelMax=</varname> permitted it to be processed.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LogExtraFields=</varname></term>
 
         <listitem><para>Configures additional log metadata fields to include in all log records generated by
         processes associated with this unit. This setting takes one or more journal field assignments in the
         format <literal>FIELD=VALUE</literal> separated by whitespace. See
         <citerefentry><refentrytitle>systemd.journal-fields</refentrytitle><manvolnum>7</manvolnum></citerefentry>
         for details on the journal field concept. Even though the underlying journal implementation permits
         binary field values, this setting accepts only valid UTF-8 values. To include space characters in a
         journal field value, enclose the assignment in double quotes ("). <!-- " fake closing quote for emacs-->
         The usual specifiers are expanded in all assignments (see below). Note that this setting is not only
         useful for attaching additional metadata to log records of a unit, but given that all fields and
         values are indexed may also be used to implement cross-unit log record matching. Assign an empty
         string to reset the list.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LogRateLimitIntervalSec=</varname></term>
         <term><varname>LogRateLimitBurst=</varname></term>
 
         <listitem><para>Configures the rate limiting that is applied to messages generated by this unit. If, in the
         time interval defined by <varname>LogRateLimitIntervalSec=</varname>, more messages than specified in
         <varname>LogRateLimitBurst=</varname> are logged by a service, all further messages within the interval are
         dropped until the interval is over. A message about the number of dropped messages is generated. The time
         specification for <varname>LogRateLimitIntervalSec=</varname> may be specified in the following units: "s",
         "min", "h", "ms", "us" (see
         <citerefentry><refentrytitle>systemd.time</refentrytitle><manvolnum>7</manvolnum></citerefentry> for details).
         The default settings are set by <varname>RateLimitIntervalSec=</varname> and <varname>RateLimitBurst=</varname>
         configured in <citerefentry><refentrytitle>journald.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LogNamespace=</varname></term>
 
         <listitem><para>Run the unit's processes in the specified journal namespace. Expects a short
         user-defined string identifying the namespace. If not used the processes of the service are run in
         the default journal namespace, i.e. their log stream is collected and processed by
         <filename>systemd-journald.service</filename>. If this option is used any log data generated by
         processes of this unit (regardless if via the <function>syslog()</function>, journal native logging
         or stdout/stderr logging) is collected and processed by an instance of the
         <filename>systemd-journald@.service</filename> template unit, which manages the specified
         namespace. The log data is stored in a data store independent from the default log namespace's data
         store. See
         <citerefentry><refentrytitle>systemd-journald.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
         for details about journal namespaces.</para>
 
         <para>Internally, journal namespaces are implemented through Linux mount namespacing and
         over-mounting the directory that contains the relevant <constant>AF_UNIX</constant> sockets used for
         logging in the unit's mount namespace. Since mount namespaces are used this setting disconnects
         propagation of mounts from the unit's processes to the host, similar to how
         <varname>ReadOnlyPaths=</varname> and similar settings (see above) work. Journal namespaces may hence
         not be used for services that need to establish mount points on the host.</para>
 
         <para>When this option is used the unit will automatically gain ordering and requirement dependencies
         on the two socket units associated with the <filename>systemd-journald@.service</filename> instance
         so that they are automatically established prior to the unit starting up. Note that when this option
         is used log output of this service does not appear in the regular
         <citerefentry><refentrytitle>journalctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>
         output, unless the <option>--namespace=</option> option is used.</para>
 
         <xi:include href="system-only.xml" xpointer="singular"/></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SyslogIdentifier=</varname></term>
 
         <listitem><para>Sets the process name ("<command>syslog</command> tag") to prefix log lines sent to
         the logging system or the kernel log buffer with. If not set, defaults to the process name of the
         executed process. This option is only useful when <varname>StandardOutput=</varname> or
         <varname>StandardError=</varname> are set to <option>journal</option> or <option>kmsg</option> (or to
         the same settings in combination with <option>+console</option>) and only applies to log messages
         written to stdout or stderr.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SyslogFacility=</varname></term>
 
         <listitem><para>Sets the <command>syslog</command> facility identifier to use when logging. One of
         <option>kern</option>, <option>user</option>, <option>mail</option>, <option>daemon</option>,
         <option>auth</option>, <option>syslog</option>, <option>lpr</option>, <option>news</option>,
         <option>uucp</option>, <option>cron</option>, <option>authpriv</option>, <option>ftp</option>,
         <option>local0</option>, <option>local1</option>, <option>local2</option>, <option>local3</option>,
         <option>local4</option>, <option>local5</option>, <option>local6</option> or
         <option>local7</option>. See <citerefentry
         project='man-pages'><refentrytitle>syslog</refentrytitle><manvolnum>3</manvolnum></citerefentry> for
         details. This option is only useful when <varname>StandardOutput=</varname> or
         <varname>StandardError=</varname> are set to <option>journal</option> or <option>kmsg</option> (or to
         the same settings in combination with <option>+console</option>), and only applies to log messages
         written to stdout or stderr. Defaults to <option>daemon</option>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SyslogLevel=</varname></term>
 
         <listitem><para>The default <command>syslog</command> log level to use when logging to the logging system or
         the kernel log buffer. One of <option>emerg</option>, <option>alert</option>, <option>crit</option>,
         <option>err</option>, <option>warning</option>, <option>notice</option>, <option>info</option>,
         <option>debug</option>. See <citerefentry
         project='man-pages'><refentrytitle>syslog</refentrytitle><manvolnum>3</manvolnum></citerefentry> for
         details. This option is only useful when <varname>StandardOutput=</varname> or
         <varname>StandardError=</varname> are set to <option>journal</option> or
         <option>kmsg</option> (or to the same settings in combination with <option>+console</option>), and only applies
         to log messages written to stdout or stderr. Note that individual lines output by executed processes may be
         prefixed with a different log level which can be used to override the default log level specified here. The
         interpretation of these prefixes may be disabled with <varname>SyslogLevelPrefix=</varname>, see below. For
         details, see <citerefentry><refentrytitle>sd-daemon</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
         Defaults to <option>info</option>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SyslogLevelPrefix=</varname></term>
 
         <listitem><para>Takes a boolean argument. If true and <varname>StandardOutput=</varname> or
         <varname>StandardError=</varname> are set to <option>journal</option> or <option>kmsg</option> (or to
         the same settings in combination with <option>+console</option>), log lines written by the executed
         process that are prefixed with a log level will be processed with this log level set but the prefix
         removed. If set to false, the interpretation of these prefixes is disabled and the logged lines are
         passed on as-is. This only applies to log messages written to stdout or stderr. For details about
         this prefixing see
         <citerefentry><refentrytitle>sd-daemon</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
         Defaults to true.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTYPath=</varname></term>
 
         <listitem><para>Sets the terminal device node to use if standard input, output, or error are connected to a TTY
         (see above). Defaults to <filename>/dev/console</filename>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTYReset=</varname></term>
 
         <listitem><para>Reset the terminal device specified with <varname>TTYPath=</varname> before and after
         execution. Defaults to <literal>no</literal>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTYVHangup=</varname></term>
 
         <listitem><para>Disconnect all clients which have opened the terminal device specified with
         <varname>TTYPath=</varname> before and after execution. Defaults to <literal>no</literal>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTYRows=</varname></term>
         <term><varname>TTYColumns=</varname></term>
 
         <listitem><para>Configure the size of the TTY specified with <varname>TTYPath=</varname>. If unset or
         set to the empty string, the kernel default is used.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTYVTDisallocate=</varname></term>
 
         <listitem><para>If the terminal device specified with <varname>TTYPath=</varname> is a virtual console
         terminal, try to deallocate the TTY before and after execution. This ensures that the screen and scrollback
         buffer is cleared. Defaults to <literal>no</literal>.</para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>Credentials</title>
 
     <variablelist class='unit-directives'>
 
       <varlistentry>
         <term><varname>LoadCredential=</varname><replaceable>ID</replaceable><optional>:<replaceable>PATH</replaceable></optional></term>
         <term><varname>LoadCredentialEncrypted=</varname><replaceable>ID</replaceable><optional>:<replaceable>PATH</replaceable></optional></term>
 
         <listitem><para>Pass a credential to the unit. Credentials are limited-size binary or textual objects
         that may be passed to unit processes. They are primarily used for passing cryptographic keys (both
         public and private) or certificates, user account information or identity information from host to
         services. The data is accessible from the unit's processes via the file system, at a read-only
         location that (if possible and permitted) is backed by non-swappable memory. The data is only
         accessible to the user associated with the unit, via the
         <varname>User=</varname>/<varname>DynamicUser=</varname> settings (as well as the superuser). When
         available, the location of credentials is exported as the <varname>$CREDENTIALS_DIRECTORY</varname>
         environment variable to the unit's processes.</para>
 
         <para>The <varname>LoadCredential=</varname> setting takes a textual ID to use as name for a
         credential plus a file system path, separated by a colon. The ID must be a short ASCII string
         suitable as filename in the filesystem, and may be chosen freely by the user. If the specified path
         is absolute it is opened as regular file and the credential data is read from it. If the absolute
         path refers to an <constant>AF_UNIX</constant> stream socket in the file system a connection is made
         to it (only once at unit start-up) and the credential data read from the connection, providing an
         easy IPC integration point for dynamically transferring credentials from other services.</para>
 
         <para>If the specified path is not absolute and itself qualifies as valid credential identifier it is
         attempted to find a credential that the service manager itself received under the specified name 
         which may be used to propagate credentials from an invoking environment (e.g. a container manager
         that invoked the service manager) into a service. If no matching system credential is found, the
         directories <filename>/etc/credstore/</filename>, <filename>/run/credstore/</filename> and
         <filename>/usr/lib/credstore/</filename> are searched for files under the credential's name  which
         hence are recommended locations for credential data on disk. If
         <varname>LoadCredentialEncrypted=</varname> is used <filename>/run/credstore.encrypted/</filename>,
         <filename>/etc/credstore.encrypted/</filename>, and
         <filename>/usr/lib/credstore.encrypted/</filename> are searched as well.</para>
 
         <para>If the file system path is omitted it is chosen identical to the credential name, i.e. this is
         a terse way to declare credentials to inherit from the service manager into a service. This option
         may be used multiple times, each time defining an additional credential to pass to the unit.</para>
 
         <para>If an absolute path referring to a directory is specified, every file in that directory
         (recursively) will be loaded as a separate credential. The ID for each credential will be the
         provided ID suffixed with <literal>_$FILENAME</literal> (e.g., <literal>Key_file1</literal>). When
         loading from a directory, symlinks will be ignored.</para>
 
         <para>The contents of the file/socket may be arbitrary binary or textual data, including newline
         characters and <constant>NUL</constant> bytes.</para>
 
         <para>The <varname>LoadCredentialEncrypted=</varname> setting is identical to
         <varname>LoadCredential=</varname>, except that the credential data is decrypted and authenticated
         before being passed on to the executed processes. Specifically, the referenced path should refer to a
         file or socket with an encrypted credential, as implemented by
         <citerefentry><refentrytitle>systemd-creds</refentrytitle><manvolnum>1</manvolnum></citerefentry>. This
         credential is loaded, decrypted, authenticated and then passed to the application in plaintext form,
         in the same way a regular credential specified via <varname>LoadCredential=</varname> would be. A
         credential configured this way may be symmetrically encrypted/authenticated with a secret key derived
         from the system's TPM2 security chip, or with a secret key stored in
         <filename>/var/lib/systemd/credentials.secret</filename>, or with both. Using encrypted and
         authenticated credentials improves security as credentials are not stored in plaintext and only
         authenticated and decrypted into plaintext the moment a service requiring them is started. Moreover,
         credentials may be bound to the local hardware and installations, so that they cannot easily be
         analyzed offline, or be generated externally.</para>
 
         <para>The credential files/IPC sockets must be accessible to the service manager, but don't have to
         be directly accessible to the unit's processes: the credential data is read and copied into separate,
         read-only copies for the unit that are accessible to appropriately privileged processes. This is
         particularly useful in combination with <varname>DynamicUser=</varname> as this way privileged data
         can be made available to processes running under a dynamic UID (i.e. not a previously known one)
         without having to open up access to all users.</para>
 
         <para>In order to reference the path a credential may be read from within a
         <varname>ExecStart=</varname> command line use <literal>${CREDENTIALS_DIRECTORY}/mycred</literal>,
         e.g. <literal>ExecStart=cat ${CREDENTIALS_DIRECTORY}/mycred</literal>. In order to reference the path
         a credential may be read from within a <varname>Environment=</varname> line use
         <literal>%d/mycred</literal>, e.g. <literal>Environment=MYCREDPATH=%d/mycred</literal>.</para>
 
         <para>Currently, an accumulated credential size limit of 1 MB per unit is enforced.</para>
 
         <para>The service manager itself may receive system credentials that can be propagated to services
         from a hosting container manager or VM hypervisor. See the <ulink
         url="https://systemd.io/CONTAINER_INTERFACE">Container Interface</ulink> documentation for details
         about the former. For the latter, use the <command>qemu</command> <literal>fw_cfg</literal> node
         <literal>opt/io.systemd.credentials/</literal>. Example qemu switch: <literal>-fw_cfg
         name=opt/io.systemd.credentials/mycred,string=supersecret</literal>. They may also be specified on
         the kernel command line using the <literal>systemd.set_credential=</literal> switch (see
         <citerefentry><refentrytitle>systemd</refentrytitle><manvolnum>1</manvolnum></citerefentry>)
         and from the UEFI firmware environment via
         <citerefentry><refentrytitle>systemd-stub</refentrytitle><manvolnum>7</manvolnum></citerefentry>.</para>
 
         <para>If referencing an <constant>AF_UNIX</constant> stream socket to connect to, the connection will
         originate from an abstract namespace socket, that includes information about the unit and the
         credential ID in its socket name. Use <citerefentry
         project='man-pages'><refentrytitle>getpeername</refentrytitle><manvolnum>2</manvolnum></citerefentry>
         to query this information. The returned socket name is formatted as <constant>NUL</constant>
         <replaceable>RANDOM</replaceable> <literal>/unit/</literal> <replaceable>UNIT</replaceable>
         <literal>/</literal> <replaceable>ID</replaceable>, i.e. a <constant>NUL</constant> byte (as required
         for abstract namespace socket names), followed by a random string (consisting of alphadecimal
         characters), followed by the literal string <literal>/unit/</literal>, followed by the requesting
         unit name, followed by the literal character <literal>/</literal>, followed by the textual credential
         ID requested. Example: <literal>\0adf9d86b6eda275e/unit/foobar.service/credx</literal> in case the
         credential <literal>credx</literal> is requested for a unit <literal>foobar.service</literal>. This
         functionality is useful for using a single listening socket to serve credentials to multiple
         consumers.</para>
 
         <para>For further information see <ulink url="https://systemd.io/CREDENTIALS">System and Service
         Credentials</ulink> documentation.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SetCredential=</varname><replaceable>ID</replaceable>:<replaceable>VALUE</replaceable></term>
         <term><varname>SetCredentialEncrypted=</varname><replaceable>ID</replaceable>:<replaceable>VALUE</replaceable></term>
 
         <listitem><para>The <varname>SetCredential=</varname> setting is similar to
         <varname>LoadCredential=</varname> but accepts a literal value to use as data for the credential,
         instead of a file system path to read the data from. Do not use this option for data that is supposed
         to be secret, as it is accessible to unprivileged processes via IPC. It's only safe to use this for
         user IDs, public key material and similar non-sensitive data. For everything else use
         <varname>LoadCredential=</varname>. In order to embed binary data into the credential data use
         C-style escaping (i.e. <literal>\n</literal> to embed a newline, or <literal>\x00</literal> to embed
         a <constant>NUL</constant> byte).</para>
 
         <para>The <varname>SetCredentialEncrypted=</varname> setting is identical to
         <varname>SetCredential=</varname> but expects an encrypted credential in literal form as value. This
         allows embedding confidential credentials securely directly in unit files. Use
         <citerefentry><refentrytitle>systemd-creds</refentrytitle><manvolnum>1</manvolnum></citerefentry>'
         <option>-p</option> switch to generate suitable <varname>SetCredentialEncrypted=</varname> lines
         directly from plaintext credentials. For further details see
         <varname>LoadCredentialEncrypted=</varname> above.</para>
 
         <para>If a credential of the same ID is listed in both <varname>LoadCredential=</varname> and
         <varname>SetCredential=</varname>, the latter will act as default if the former cannot be
         retrieved. In this case not being able to retrieve the credential from the path specified in
         <varname>LoadCredential=</varname> is not considered fatal.</para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
-  <refsect1>
-    <title>Firewall Integration</title>
-    <variablelist class='unit-directives'>
-
-      <varlistentry>
-        <term><varname>DynamicUserNFTSet=</varname><replaceable>family</replaceable>:<replaceable>table</replaceable>:<replaceable>set</replaceable></term>
-        <listitem><para>This setting provides a method for integrating <varname>DynamicUser=</varname>
-        configuration into firewall rules with NFT sets. This option expects a whitespace separated list of
-        NFT set definitions. Each definition consists of a colon-separated tuple of NFT address family (one
-        of <literal>arp</literal>, <literal>bridge</literal>, <literal>inet</literal>, <literal>ip</literal>,
-        <literal>ip6</literal>, or <literal>netdev</literal>), table name and set name. The names of tables
-        and sets must conform to lexical restrictions of NFT table names. When the unit starts, the user ID
-        will be appended to the NFT sets and it will be removed when the unit is stopped. Failures to manage
-        the sets will be ignored.</para>
-
-          <para>Example:
-          <programlisting>[Service]
-DynamicUserNFTSet=inet:filter:u</programlisting>
-          Corresponding NFT rules:
-          <programlisting>table inet filter {
-        set u {
-                typeof meta skuid
-        }
-        chain service_output {
-                meta skuid != @u drop
-                accept
-        }
-}</programlisting>
-          </para>
-        </listitem>
-      </varlistentry>
-    </variablelist>
-  </refsect1>
-
   <refsect1>
     <title>System V Compatibility</title>
     <variablelist class='unit-directives'>
 
       <varlistentry>
         <term><varname>UtmpIdentifier=</varname></term>
 
         <listitem><para>Takes a four character identifier string for an <citerefentry
         project='man-pages'><refentrytitle>utmp</refentrytitle><manvolnum>5</manvolnum></citerefentry> and wtmp entry
         for this service. This should only be set for services such as <command>getty</command> implementations (such
         as <citerefentry
         project='die-net'><refentrytitle>agetty</refentrytitle><manvolnum>8</manvolnum></citerefentry>) where utmp/wtmp
         entries must be created and cleared before and after execution, or for services that shall be executed as if
         they were run by a <command>getty</command> process (see below). If the configured string is longer than four
         characters, it is truncated and the terminal four characters are used. This setting interprets %I style string
         replacements. This setting is unset by default, i.e. no utmp/wtmp entries are created or cleaned up for this
         service.</para></listitem>
       </varlistentry>
 
       <varlistentry>
          <term><varname>UtmpMode=</varname></term>
 
          <listitem><para>Takes one of <literal>init</literal>, <literal>login</literal> or <literal>user</literal>. If
          <varname>UtmpIdentifier=</varname> is set, controls which type of <citerefentry
          project='man-pages'><refentrytitle>utmp</refentrytitle><manvolnum>5</manvolnum></citerefentry>/wtmp entries
          for this service are generated. This setting has no effect unless <varname>UtmpIdentifier=</varname> is set
          too. If <literal>init</literal> is set, only an <constant>INIT_PROCESS</constant> entry is generated and the
          invoked process must implement a <command>getty</command>-compatible utmp/wtmp logic. If
          <literal>login</literal> is set, first an <constant>INIT_PROCESS</constant> entry, followed by a
          <constant>LOGIN_PROCESS</constant> entry is generated. In this case, the invoked process must implement a
          <citerefentry
          project='die-net'><refentrytitle>login</refentrytitle><manvolnum>1</manvolnum></citerefentry>-compatible
          utmp/wtmp logic. If <literal>user</literal> is set, first an <constant>INIT_PROCESS</constant> entry, then a
          <constant>LOGIN_PROCESS</constant> entry and finally a <constant>USER_PROCESS</constant> entry is
          generated. In this case, the invoked process may be any process that is suitable to be run as session
          leader. Defaults to <literal>init</literal>.</para></listitem>
       </varlistentry>
 
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>Environment Variables in Spawned Processes</title>
 
     <para>Processes started by the service manager are executed with an environment variable block assembled from
     multiple sources. Processes started by the system service manager generally do not inherit environment variables
     set for the service manager itself (but this may be altered via <varname>PassEnvironment=</varname>), but processes
     started by the user service manager instances generally do inherit all environment variables set for the service
     manager itself.</para>
 
     <para>For each invoked process the list of environment variables set is compiled from the following sources:</para>
 
     <itemizedlist>
       <listitem><para>Variables globally configured for the service manager, using the
       <varname>DefaultEnvironment=</varname> setting in
       <citerefentry><refentrytitle>systemd-system.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       the kernel command line option <varname>systemd.setenv=</varname> understood by
       <citerefentry><refentrytitle>systemd</refentrytitle><manvolnum>1</manvolnum></citerefentry>, or via
       <citerefentry><refentrytitle>systemctl</refentrytitle><manvolnum>1</manvolnum></citerefentry>
       <command>set-environment</command> verb.</para></listitem>
 
       <listitem><para>Variables defined by the service manager itself (see the list below).</para></listitem>
 
       <listitem><para>Variables set in the service manager's own environment variable block (subject to
       <varname>PassEnvironment=</varname> for the system service manager).</para></listitem>
 
       <listitem><para>Variables set via <varname>Environment=</varname> in the unit file.</para></listitem>
 
       <listitem><para>Variables read from files specified via <varname>EnvironmentFile=</varname> in the unit
       file.</para></listitem>
 
       <listitem><para>Variables set by any PAM modules in case <varname>PAMName=</varname> is in effect,
       cf.<citerefentry
       project='man-pages'><refentrytitle>pam_env</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
       </para></listitem>
     </itemizedlist>
 
     <para>If the same environment variable is set by multiple of these sources, the later source  according
     to the order of the list above  wins. Note that as the final step all variables listed in
     <varname>UnsetEnvironment=</varname> are removed from the compiled environment variable list, immediately
     before it is passed to the executed process.</para>
 
     <para>The general philosophy is to expose a small curated list of environment variables to processes.
     Services started by the system manager (PID 1) will be started, without additional service-specific
     configuration, with just a few environment variables. The user manager inherits environment variables as
     any other system service, but in addition may receive additional environment variables from PAM, and,
     typically, additional imported variables when the user starts a graphical session. It is recommended to
     keep the environment blocks in both the system and user managers lean. Importing all variables
     inherited by the graphical session or by one of the user shells is strongly discouraged.</para>
 
     <para>Hint: <command>systemd-run -P env</command> and <command>systemd-run --user -P env</command> print
     the effective system and user service environment blocks.</para>
 
     <refsect2>
       <title>Environment Variables Set or Propagated by the Service Manager</title>
 
       <para>The following environment variables are propagated by the service manager or generated internally
       for each invoked process:</para>
 
       <variablelist class='environment-variables'>
         <varlistentry>
           <term><varname>$PATH</varname></term>
 
           <listitem><para>Colon-separated list of directories to use when launching
           executables. <command>systemd</command> uses a fixed value of
           <literal><filename>/usr/local/sbin</filename>:<filename>/usr/local/bin</filename>:<filename>/usr/sbin</filename>:<filename>/usr/bin</filename></literal>
           in the system manager. When compiled for systems with "unmerged <filename>/usr/</filename>"
           (<filename>/bin</filename> is not a symlink to <filename>/usr/bin</filename>),
           <literal>:<filename>/sbin</filename>:<filename>/bin</filename></literal> is appended. In case of
           the user manager, a different path may be configured by the distribution. It is recommended to
           not rely on the order of entries, and have only one program with a given name in
           <varname>$PATH</varname>.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$LANG</varname></term>
 
           <listitem><para>Locale. Can be set in <citerefentry
           project='man-pages'><refentrytitle>locale.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>
           or on the kernel command line (see
           <citerefentry><refentrytitle>systemd</refentrytitle><manvolnum>1</manvolnum></citerefentry> and
           <citerefentry><refentrytitle>kernel-command-line</refentrytitle><manvolnum>7</manvolnum></citerefentry>).
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$USER</varname></term>
           <term><varname>$LOGNAME</varname></term>
           <term><varname>$HOME</varname></term>
           <term><varname>$SHELL</varname></term>
 
           <listitem><para>User name (twice), home directory, and the
           login shell. The variables are set for the units that have
           <varname>User=</varname> set, which includes user
           <command>systemd</command> instances. See
           <citerefentry project='die-net'><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$INVOCATION_ID</varname></term>
 
           <listitem><para>Contains a randomized, unique 128bit ID identifying each runtime cycle of the unit, formatted
           as 32 character hexadecimal string. A new ID is assigned each time the unit changes from an inactive state into
           an activating or active state, and may be used to identify this specific runtime cycle, in particular in data
           stored offline, such as the journal. The same ID is passed to all processes run as part of the
           unit.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$XDG_RUNTIME_DIR</varname></term>
 
           <listitem><para>The directory to use for runtime objects (such as IPC objects) and volatile state. Set for all
           services run by the user <command>systemd</command> instance, as well as any system services that use
           <varname>PAMName=</varname> with a PAM stack that includes <command>pam_systemd</command>. See below and
           <citerefentry><refentrytitle>pam_systemd</refentrytitle><manvolnum>8</manvolnum></citerefentry> for more
           information.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$RUNTIME_DIRECTORY</varname></term>
           <term><varname>$STATE_DIRECTORY</varname></term>
           <term><varname>$CACHE_DIRECTORY</varname></term>
           <term><varname>$LOGS_DIRECTORY</varname></term>
           <term><varname>$CONFIGURATION_DIRECTORY</varname></term>
 
           <listitem><para>Absolute paths to the directories defined with
           <varname>RuntimeDirectory=</varname>, <varname>StateDirectory=</varname>,
           <varname>CacheDirectory=</varname>, <varname>LogsDirectory=</varname>, and
           <varname>ConfigurationDirectory=</varname> when those settings are used.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$CREDENTIALS_DIRECTORY</varname></term>
 
           <listitem><para>An absolute path to the per-unit directory with credentials configured via
           <varname>LoadCredential=</varname>/<varname>SetCredential=</varname>. The directory is marked
           read-only and is placed in unswappable memory (if supported and permitted), and is only accessible to
           the UID associated with the unit via <varname>User=</varname> or <varname>DynamicUser=</varname> (and
           the superuser).</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$MAINPID</varname></term>
 
           <listitem><para>The PID of the unit's main process if it is
           known. This is only set for control processes as invoked by
           <varname>ExecReload=</varname> and similar. </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$MANAGERPID</varname></term>
 
           <listitem><para>The PID of the user <command>systemd</command>
           instance, set for processes spawned by it. </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$LISTEN_FDS</varname></term>
           <term><varname>$LISTEN_PID</varname></term>
           <term><varname>$LISTEN_FDNAMES</varname></term>
 
           <listitem><para>Information about file descriptors passed to a
           service for socket activation. See
           <citerefentry><refentrytitle>sd_listen_fds</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$NOTIFY_SOCKET</varname></term>
 
           <listitem><para>The socket
           <function>sd_notify()</function> talks to. See
           <citerefentry><refentrytitle>sd_notify</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$WATCHDOG_PID</varname></term>
           <term><varname>$WATCHDOG_USEC</varname></term>
 
           <listitem><para>Information about watchdog keep-alive notifications. See
           <citerefentry><refentrytitle>sd_watchdog_enabled</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$SYSTEMD_EXEC_PID</varname></term>
 
           <listitem><para>The PID of the unit process (e.g. process invoked by
           <varname>ExecStart=</varname>). The child process can use this information to determine
           whether the process is directly invoked by the service manager or indirectly as a child of
           another process by comparing this value with the current PID (as similar to the scheme used in
           <citerefentry><refentrytitle>sd_listen_fds</refentrytitle><manvolnum>3</manvolnum></citerefentry>
           with <varname>$LISTEN_PID</varname> and <varname>$LISTEN_FDS</varname>).</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$TERM</varname></term>
 
           <listitem><para>Terminal type, set only for units connected to
           a terminal (<varname>StandardInput=tty</varname>,
           <varname>StandardOutput=tty</varname>, or
           <varname>StandardError=tty</varname>). See
           <citerefentry project='man-pages'><refentrytitle>termcap</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$LOG_NAMESPACE</varname></term>
 
           <listitem><para>Contains the name of the selected logging namespace when the
           <varname>LogNamespace=</varname> service setting is used.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$JOURNAL_STREAM</varname></term>
 
           <listitem><para>If the standard output or standard error output of the executed processes are connected to the
           journal (for example, by setting <varname>StandardError=journal</varname>) <varname>$JOURNAL_STREAM</varname>
           contains the device and inode numbers of the connection file descriptor, formatted in decimal, separated by a
           colon (<literal>:</literal>). This permits invoked processes to safely detect whether their standard output or
           standard error output are connected to the journal. The device and inode numbers of the file descriptors should
           be compared with the values set in the environment variable to determine whether the process output is still
           connected to the journal. Note that it is generally not sufficient to only check whether
           <varname>$JOURNAL_STREAM</varname> is set at all as services might invoke external processes replacing their
           standard output or standard error output, without unsetting the environment variable.</para>
 
           <para>If both standard output and standard error of the executed processes are connected to the journal via a
           stream socket, this environment variable will contain information about the standard error stream, as that's
           usually the preferred destination for log data. (Note that typically the same stream is used for both standard
           output and standard error, hence very likely the environment variable contains device and inode information
           matching both stream file descriptors.)</para>
 
           <para>This environment variable is primarily useful to allow services to optionally upgrade their used log
           protocol to the native journal protocol (using
           <citerefentry><refentrytitle>sd_journal_print</refentrytitle><manvolnum>3</manvolnum></citerefentry> and other
           functions) if their standard output or standard error output is connected to the journal anyway, thus enabling
           delivery of structured metadata along with logged messages.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$SERVICE_RESULT</varname></term>
 
           <listitem><para>Only used for the service unit type. This environment variable is passed to all
           <varname>ExecStop=</varname> and <varname>ExecStopPost=</varname> processes, and encodes the service
           "result". Currently, the following values are defined:</para>
 
           <table>
             <title>Defined <varname>$SERVICE_RESULT</varname> values</title>
             <tgroup cols='2'>
               <colspec colname='result'/>
               <colspec colname='meaning'/>
               <thead>
                 <row>
                   <entry>Value</entry>
                   <entry>Meaning</entry>
                 </row>
               </thead>
 
               <tbody>
                 <row>
                   <entry><literal>success</literal></entry>
                   <entry>The service ran successfully and exited cleanly.</entry>
                 </row>
                 <row>
                   <entry><literal>protocol</literal></entry>
                   <entry>A protocol violation occurred: the service did not take the steps required by its unit configuration (specifically what is configured in its <varname>Type=</varname> setting).</entry>
                 </row>
                 <row>
                   <entry><literal>timeout</literal></entry>
                   <entry>One of the steps timed out.</entry>
                 </row>
                 <row>
                   <entry><literal>exit-code</literal></entry>
                   <entry>Service process exited with a non-zero exit code; see <varname>$EXIT_CODE</varname> below for the actual exit code returned.</entry>
                 </row>
                 <row>
                   <entry><literal>signal</literal></entry>
                   <entry>A service process was terminated abnormally by a signal, without dumping core. See <varname>$EXIT_CODE</varname> below for the actual signal causing the termination.</entry>
                 </row>
                 <row>
                   <entry><literal>core-dump</literal></entry>
                   <entry>A service process terminated abnormally with a signal and dumped core. See <varname>$EXIT_CODE</varname> below for the signal causing the termination.</entry>
                 </row>
                 <row>
                   <entry><literal>watchdog</literal></entry>
                   <entry>Watchdog keep-alive ping was enabled for the service, but the deadline was missed.</entry>
                 </row>
                 <row>
                   <entry><literal>start-limit-hit</literal></entry>
                   <entry>A start limit was defined for the unit and it was hit, causing the unit to fail to start. See <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry>'s <varname>StartLimitIntervalSec=</varname> and <varname>StartLimitBurst=</varname> for details.</entry>
                 </row>
                 <row>
                   <entry><literal>resources</literal></entry>
                   <entry>A catch-all condition in case a system operation failed.</entry>
                 </row>
               </tbody>
             </tgroup>
           </table>
 
           <para>This environment variable is useful to monitor failure or successful termination of a service. Even
           though this variable is available in both <varname>ExecStop=</varname> and <varname>ExecStopPost=</varname>, it
           is usually a better choice to place monitoring tools in the latter, as the former is only invoked for services
           that managed to start up correctly, and the latter covers both services that failed during their start-up and
           those which failed during their runtime.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$EXIT_CODE</varname></term>
           <term><varname>$EXIT_STATUS</varname></term>
 
           <listitem><para>Only defined for the service unit type. These environment variables are passed to all
           <varname>ExecStop=</varname>, <varname>ExecStopPost=</varname> processes and contain exit status/code
           information of the main process of the service. For the precise definition of the exit code and status, see
           <citerefentry><refentrytitle>wait</refentrytitle><manvolnum>2</manvolnum></citerefentry>. <varname>$EXIT_CODE</varname>
           is one of <literal>exited</literal>, <literal>killed</literal>,
           <literal>dumped</literal>. <varname>$EXIT_STATUS</varname> contains the numeric exit code formatted as string
           if <varname>$EXIT_CODE</varname> is <literal>exited</literal>, and the signal name in all other cases. Note
           that these environment variables are only set if the service manager succeeded to start and identify the main
           process of the service.</para>
 
           <table>
             <title>Summary of possible service result variable values</title>
             <tgroup cols='3'>
               <colspec colname='result' />
               <colspec colname='code' />
               <colspec colname='status' />
               <thead>
                 <row>
                   <entry><varname>$SERVICE_RESULT</varname></entry>
                   <entry><varname>$EXIT_CODE</varname></entry>
                   <entry><varname>$EXIT_STATUS</varname></entry>
                 </row>
               </thead>
 
               <tbody>
                 <row>
                   <entry morerows="1" valign="top"><literal>success</literal></entry>
                   <entry valign="top"><literal>killed</literal></entry>
                   <entry><literal>HUP</literal>, <literal>INT</literal>, <literal>TERM</literal>, <literal>PIPE</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>exited</literal></entry>
                   <entry><literal>0</literal></entry>
                 </row>
                 <row>
                   <entry morerows="1" valign="top"><literal>protocol</literal></entry>
                   <entry valign="top">not set</entry>
                   <entry>not set</entry>
                 </row>
                 <row>
                   <entry><literal>exited</literal></entry>
                   <entry><literal>0</literal></entry>
                 </row>
                 <row>
                   <entry morerows="1" valign="top"><literal>timeout</literal></entry>
                   <entry valign="top"><literal>killed</literal></entry>
                   <entry><literal>TERM</literal>, <literal>KILL</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>exited</literal></entry>
                   <entry><literal>0</literal>, <literal>1</literal>, <literal>2</literal>, <literal
                   >3</literal>, , <literal>255</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>exit-code</literal></entry>
                   <entry valign="top"><literal>exited</literal></entry>
                   <entry><literal>1</literal>, <literal>2</literal>, <literal
                   >3</literal>, , <literal>255</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>signal</literal></entry>
                   <entry valign="top"><literal>killed</literal></entry>
                   <entry><literal>HUP</literal>, <literal>INT</literal>, <literal>KILL</literal>, </entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>core-dump</literal></entry>
                   <entry valign="top"><literal>dumped</literal></entry>
                   <entry><literal>ABRT</literal>, <literal>SEGV</literal>, <literal>QUIT</literal>, </entry>
                 </row>
                 <row>
                   <entry morerows="2" valign="top"><literal>watchdog</literal></entry>
                   <entry><literal>dumped</literal></entry>
                   <entry><literal>ABRT</literal></entry>
                 </row>
                 <row>
                   <entry><literal>killed</literal></entry>
                   <entry><literal>TERM</literal>, <literal>KILL</literal></entry>
                 </row>
                 <row>
                   <entry><literal>exited</literal></entry>
                   <entry><literal>0</literal>, <literal>1</literal>, <literal>2</literal>, <literal
                   >3</literal>, , <literal>255</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>exec-condition</literal></entry>
                   <entry><literal>exited</literal></entry>
                   <entry><literal>1</literal>, <literal>2</literal>, <literal>3</literal>, <literal
                   >4</literal>, , <literal>254</literal></entry>
                 </row>
                 <row>
                   <entry valign="top"><literal>oom-kill</literal></entry>
                   <entry valign="top"><literal>killed</literal></entry>
                   <entry><literal>TERM</literal>, <literal>KILL</literal></entry>
                 </row>
                 <row>
                   <entry><literal>start-limit-hit</literal></entry>
                   <entry>not set</entry>
                   <entry>not set</entry>
                 </row>
                 <row>
                   <entry><literal>resources</literal></entry>
                   <entry>any of the above</entry>
                   <entry>any of the above</entry>
                 </row>
                 <row>
                   <entry namest="results" nameend="status">Note: the process may be also terminated by a signal not sent by systemd. In particular the process may send an arbitrary signal to itself in a handler for any of the non-maskable signals. Nevertheless, in the <literal>timeout</literal> and <literal>watchdog</literal> rows above only the signals that systemd sends have been included. Moreover, using <varname>SuccessExitStatus=</varname> additional exit statuses may be declared to indicate clean termination, which is not reflected by this table.</entry>
                 </row>
               </tbody>
             </tgroup>
           </table></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$MONITOR_SERVICE_RESULT</varname></term>
           <term><varname>$MONITOR_EXIT_CODE</varname></term>
           <term><varname>$MONITOR_EXIT_STATUS</varname></term>
           <term><varname>$MONITOR_INVOCATION_ID</varname></term>
           <term><varname>$MONITOR_UNIT</varname></term>
 
           <listitem><para>Only defined for the service unit type. Those environment variable are passed to
           all <varname>ExecStart=</varname> and <varname>ExecStartPre=</varname> processes which run in
           services triggered by <varname>OnFailure=</varname> or <varname>OnSuccess=</varname> dependencies.
           </para>
 
           <para>Variables <varname>$MONITOR_SERVICE_RESULT</varname>, <varname>$MONITOR_EXIT_CODE</varname>
           and <varname>$MONITOR_EXIT_STATUS</varname> take the same values as for
           <varname>ExecStop=</varname> and <varname>ExecStopPost=</varname> processes. Variables
           <varname>$MONITOR_INVOCATION_ID</varname> and <varname>$MONITOR_UNIT</varname> are set to the
           invocaton id and unit name of the service which triggered the dependency.</para>
 
           <para>Note that when multiple services trigger the same unit, those variables will be
           <emphasis>not</emphasis> be passed. Consider using a template handler unit for that case instead:
           <literal>OnFailure=<replaceable>handler</replaceable>@%n.service</literal> for non-templated units,
           or <literal>OnFailure=<replaceable>handler</replaceable>@%p-%i.service</literal> for templated
           units.</para></listitem>
         </varlistentry>
 
         <varlistentry>
           <term><varname>$PIDFILE</varname></term>
 
           <listitem><para>The path to the configured PID file, in case the process is forked off on behalf of
           a service that uses the <varname>PIDFile=</varname> setting, see
           <citerefentry><refentrytitle>systemd.service</refentrytitle><manvolnum>5</manvolnum></citerefentry>
           for details. Service code may use this environment variable to automatically generate a PID file at
           the location configured in the unit file. This field is set to an absolute path in the file
           system.</para></listitem>
         </varlistentry>
 
       </variablelist>
 
       <para>For system services, when <varname>PAMName=</varname> is enabled and <command>pam_systemd</command> is part
       of the selected PAM stack, additional environment variables defined by systemd may be set for
       services. Specifically, these are <varname>$XDG_SEAT</varname>, <varname>$XDG_VTNR</varname>, see
       <citerefentry><refentrytitle>pam_systemd</refentrytitle><manvolnum>8</manvolnum></citerefentry> for details.</para>
     </refsect2>
 
   </refsect1>
 
   <refsect1>
     <title>Process Exit Codes</title>
 
     <para>When invoking a unit process the service manager possibly fails to apply the execution parameters configured
     with the settings above. In that case the already created service process will exit with a non-zero exit code
     before the configured command line is executed. (Or in other words, the child process possibly exits with these
     error codes, after having been created by the <citerefentry
     project='man-pages'><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call, but
     before the matching <citerefentry
     project='man-pages'><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call is
     called.) Specifically, exit codes defined by the C library, by the LSB specification and by the systemd service
     manager itself are used.</para>
 
     <para>The following basic service exit codes are defined by the C library.</para>
 
     <table>
       <title>Basic C library exit codes</title>
       <tgroup cols='3'>
         <thead>
           <row>
             <entry>Exit Code</entry>
             <entry>Symbolic Name</entry>
             <entry>Description</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>0</entry>
             <entry><constant>EXIT_SUCCESS</constant></entry>
             <entry>Generic success code.</entry>
           </row>
           <row>
             <entry>1</entry>
             <entry><constant>EXIT_FAILURE</constant></entry>
             <entry>Generic failure or unspecified error.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>The following service exit codes are defined by the <ulink
     url="https://refspecs.linuxbase.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html">LSB specification</ulink>.
     </para>
 
     <table>
       <title>LSB service exit codes</title>
       <tgroup cols='3'>
         <thead>
           <row>
             <entry>Exit Code</entry>
             <entry>Symbolic Name</entry>
             <entry>Description</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>2</entry>
             <entry><constant>EXIT_INVALIDARGUMENT</constant></entry>
             <entry>Invalid or excess arguments.</entry>
           </row>
           <row>
             <entry>3</entry>
             <entry><constant>EXIT_NOTIMPLEMENTED</constant></entry>
             <entry>Unimplemented feature.</entry>
           </row>
           <row>
             <entry>4</entry>
             <entry><constant>EXIT_NOPERMISSION</constant></entry>
             <entry>The user has insufficient privileges.</entry>
           </row>
           <row>
             <entry>5</entry>
             <entry><constant>EXIT_NOTINSTALLED</constant></entry>
             <entry>The program is not installed.</entry>
           </row>
           <row>
             <entry>6</entry>
             <entry><constant>EXIT_NOTCONFIGURED</constant></entry>
             <entry>The program is not configured.</entry>
           </row>
           <row>
             <entry>7</entry>
             <entry><constant>EXIT_NOTRUNNING</constant></entry>
             <entry>The program is not running.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>
       The LSB specification suggests that error codes 200 and above are reserved for implementations. Some of them are
       used by the service manager to indicate problems during process invocation:
     </para>
     <table>
       <title>systemd-specific exit codes</title>
       <tgroup cols='3'>
         <thead>
           <row>
             <entry>Exit Code</entry>
             <entry>Symbolic Name</entry>
             <entry>Description</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>200</entry>
             <entry><constant>EXIT_CHDIR</constant></entry>
             <entry>Changing to the requested working directory failed. See <varname>WorkingDirectory=</varname> above.</entry>
           </row>
           <row>
             <entry>201</entry>
             <entry><constant>EXIT_NICE</constant></entry>
             <entry>Failed to set up process scheduling priority (nice level). See <varname>Nice=</varname> above.</entry>
           </row>
           <row>
             <entry>202</entry>
             <entry><constant>EXIT_FDS</constant></entry>
             <entry>Failed to close unwanted file descriptors, or to adjust passed file descriptors.</entry>
           </row>
           <row>
             <entry>203</entry>
             <entry><constant>EXIT_EXEC</constant></entry>
             <entry>The actual process execution failed (specifically, the <citerefentry project='man-pages'><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></citerefentry> system call). Most likely this is caused by a missing or non-accessible executable file.</entry>
           </row>
           <row>
             <entry>204</entry>
             <entry><constant>EXIT_MEMORY</constant></entry>
             <entry>Failed to perform an action due to memory shortage.</entry>
           </row>
           <row>
             <entry>205</entry>
             <entry><constant>EXIT_LIMITS</constant></entry>
             <entry>Failed to adjust resource limits. See <varname>LimitCPU=</varname> and related settings above.</entry>
           </row>
           <row>
             <entry>206</entry>
             <entry><constant>EXIT_OOM_ADJUST</constant></entry>
             <entry>Failed to adjust the OOM setting. See <varname>OOMScoreAdjust=</varname> above.</entry>
           </row>
           <row>
             <entry>207</entry>
             <entry><constant>EXIT_SIGNAL_MASK</constant></entry>
             <entry>Failed to set process signal mask.</entry>
           </row>
           <row>
             <entry>208</entry>
             <entry><constant>EXIT_STDIN</constant></entry>
             <entry>Failed to set up standard input. See <varname>StandardInput=</varname> above.</entry>
           </row>
           <row>
             <entry>209</entry>
             <entry><constant>EXIT_STDOUT</constant></entry>
             <entry>Failed to set up standard output. See <varname>StandardOutput=</varname> above.</entry>
           </row>
           <row>
             <entry>210</entry>
             <entry><constant>EXIT_CHROOT</constant></entry>
             <entry>Failed to change root directory (<citerefentry project='man-pages'><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></citerefentry>). See <varname>RootDirectory=</varname>/<varname>RootImage=</varname> above.</entry>
           </row>
           <row>
             <entry>211</entry>
             <entry><constant>EXIT_IOPRIO</constant></entry>
             <entry>Failed to set up IO scheduling priority. See <varname>IOSchedulingClass=</varname>/<varname>IOSchedulingPriority=</varname> above.</entry>
           </row>
           <row>
             <entry>212</entry>
             <entry><constant>EXIT_TIMERSLACK</constant></entry>
             <entry>Failed to set up timer slack. See <varname>TimerSlackNSec=</varname> above.</entry>
           </row>
           <row>
             <entry>213</entry>
             <entry><constant>EXIT_SECUREBITS</constant></entry>
             <entry>Failed to set process secure bits. See <varname>SecureBits=</varname> above.</entry>
           </row>
           <row>
             <entry>214</entry>
             <entry><constant>EXIT_SETSCHEDULER</constant></entry>
             <entry>Failed to set up CPU scheduling. See <varname>CPUSchedulingPolicy=</varname>/<varname>CPUSchedulingPriority=</varname> above.</entry>
           </row>
           <row>
             <entry>215</entry>
             <entry><constant>EXIT_CPUAFFINITY</constant></entry>
             <entry>Failed to set up CPU affinity. See <varname>CPUAffinity=</varname> above.</entry>
           </row>
           <row>
             <entry>216</entry>
             <entry><constant>EXIT_GROUP</constant></entry>
             <entry>Failed to determine or change group credentials. See <varname>Group=</varname>/<varname>SupplementaryGroups=</varname> above.</entry>
           </row>
           <row>
             <entry>217</entry>
             <entry><constant>EXIT_USER</constant></entry>
             <entry>Failed to determine or change user credentials, or to set up user namespacing. See <varname>User=</varname>/<varname>PrivateUsers=</varname> above.</entry>
           </row>
           <row>
             <entry>218</entry>
             <entry><constant>EXIT_CAPABILITIES</constant></entry>
             <entry>Failed to drop capabilities, or apply ambient capabilities. See <varname>CapabilityBoundingSet=</varname>/<varname>AmbientCapabilities=</varname> above.</entry>
           </row>
           <row>
             <entry>219</entry>
             <entry><constant>EXIT_CGROUP</constant></entry>
             <entry>Setting up the service control group failed.</entry>
           </row>
           <row>
             <entry>220</entry>
             <entry><constant>EXIT_SETSID</constant></entry>
             <entry>Failed to create new process session.</entry>
           </row>
           <row>
             <entry>221</entry>
             <entry><constant>EXIT_CONFIRM</constant></entry>
             <entry>Execution has been cancelled by the user. See the <varname>systemd.confirm_spawn=</varname> kernel command line setting on <citerefentry><refentrytitle>kernel-command-line</refentrytitle><manvolnum>7</manvolnum></citerefentry> for details.</entry>
           </row>
           <row>
             <entry>222</entry>
             <entry><constant>EXIT_STDERR</constant></entry>
             <entry>Failed to set up standard error output. See <varname>StandardError=</varname> above.</entry>
           </row>
           <row>
             <entry>224</entry>
             <entry><constant>EXIT_PAM</constant></entry>
             <entry>Failed to set up PAM session. See <varname>PAMName=</varname> above.</entry>
           </row>
           <row>
             <entry>225</entry>
             <entry><constant>EXIT_NETWORK</constant></entry>
             <entry>Failed to set up network namespacing. See <varname>PrivateNetwork=</varname> above.</entry>
           </row>
           <row>
             <entry>226</entry>
             <entry><constant>EXIT_NAMESPACE</constant></entry>
             <entry>Failed to set up mount, UTS, or IPC namespacing. See <varname>ReadOnlyPaths=</varname>, <varname>ProtectHostname=</varname>, <varname>PrivateIPC=</varname>, and related settings above.</entry>
           </row>
           <row>
             <entry>227</entry>
             <entry><constant>EXIT_NO_NEW_PRIVILEGES</constant></entry>
             <entry>Failed to disable new privileges. See <varname>NoNewPrivileges=yes</varname> above.</entry>
           </row>
           <row>
             <entry>228</entry>
             <entry><constant>EXIT_SECCOMP</constant></entry>
             <entry>Failed to apply system call filters. See <varname>SystemCallFilter=</varname> and related settings above.</entry>
           </row>
           <row>
             <entry>229</entry>
             <entry><constant>EXIT_SELINUX_CONTEXT</constant></entry>
             <entry>Determining or changing SELinux context failed. See <varname>SELinuxContext=</varname> above.</entry>
           </row>
           <row>
             <entry>230</entry>
             <entry><constant>EXIT_PERSONALITY</constant></entry>
             <entry>Failed to set up an execution domain (personality). See <varname>Personality=</varname> above.</entry>
           </row>
           <row>
             <entry>231</entry>
             <entry><constant>EXIT_APPARMOR_PROFILE</constant></entry>
             <entry>Failed to prepare changing AppArmor profile. See <varname>AppArmorProfile=</varname> above.</entry>
           </row>
           <row>
             <entry>232</entry>
             <entry><constant>EXIT_ADDRESS_FAMILIES</constant></entry>
             <entry>Failed to restrict address families. See <varname>RestrictAddressFamilies=</varname> above.</entry>
           </row>
           <row>
             <entry>233</entry>
             <entry><constant>EXIT_RUNTIME_DIRECTORY</constant></entry>
             <entry>Setting up runtime directory failed. See <varname>RuntimeDirectory=</varname> and related settings above.</entry>
           </row>
           <row>
             <entry>235</entry>
             <entry><constant>EXIT_CHOWN</constant></entry>
             <entry>Failed to adjust socket ownership. Used for socket units only.</entry>
           </row>
           <row>
             <entry>236</entry>
             <entry><constant>EXIT_SMACK_PROCESS_LABEL</constant></entry>
             <entry>Failed to set SMACK label. See <varname>SmackProcessLabel=</varname> above.</entry>
           </row>
           <row>
             <entry>237</entry>
             <entry><constant>EXIT_KEYRING</constant></entry>
             <entry>Failed to set up kernel keyring.</entry>
           </row>
           <row>
             <entry>238</entry>
             <entry><constant>EXIT_STATE_DIRECTORY</constant></entry>
             <entry>Failed to set up unit's state directory. See <varname>StateDirectory=</varname> above.</entry>
           </row>
           <row>
             <entry>239</entry>
             <entry><constant>EXIT_CACHE_DIRECTORY</constant></entry>
             <entry>Failed to set up unit's cache directory. See <varname>CacheDirectory=</varname> above.</entry>
           </row>
           <row>
             <entry>240</entry>
             <entry><constant>EXIT_LOGS_DIRECTORY</constant></entry>
             <entry>Failed to set up unit's logging directory. See <varname>LogsDirectory=</varname> above.</entry>
           </row>
           <row>
             <entry>241</entry>
             <entry><constant>EXIT_CONFIGURATION_DIRECTORY</constant></entry>
             <entry>Failed to set up unit's configuration directory. See <varname>ConfigurationDirectory=</varname> above.</entry>
           </row>
           <row>
             <entry>242</entry>
             <entry><constant>EXIT_NUMA_POLICY</constant></entry>
             <entry>Failed to set up unit's NUMA memory policy. See <varname>NUMAPolicy=</varname> and <varname>NUMAMask=</varname> above.</entry>
           </row>
           <row>
             <entry>243</entry>
             <entry><constant>EXIT_CREDENTIALS</constant></entry>
             <entry>Failed to set up unit's credentials. See <varname>LoadCredential=</varname> and <varname>SetCredential=</varname> above.</entry>
           </row>
           <row>
             <entry>245</entry>
             <entry><constant>EXIT_BPF</constant></entry>
             <entry>Failed to apply BPF restrictions. See <varname>RestrictFileSystems=</varname> above.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>Finally, the BSD operating systems define a set of exit codes, typically defined on Linux systems too:</para>
 
     <table>
       <title>BSD exit codes</title>
       <tgroup cols='3'>
         <thead>
           <row>
             <entry>Exit Code</entry>
             <entry>Symbolic Name</entry>
             <entry>Description</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>64</entry>
             <entry><constant>EX_USAGE</constant></entry>
             <entry>Command line usage error</entry>
           </row>
           <row>
             <entry>65</entry>
             <entry><constant>EX_DATAERR</constant></entry>
             <entry>Data format error</entry>
           </row>
           <row>
             <entry>66</entry>
             <entry><constant>EX_NOINPUT</constant></entry>
             <entry>Cannot open input</entry>
           </row>
           <row>
             <entry>67</entry>
             <entry><constant>EX_NOUSER</constant></entry>
             <entry>Addressee unknown</entry>
           </row>
           <row>
             <entry>68</entry>
             <entry><constant>EX_NOHOST</constant></entry>
             <entry>Host name unknown</entry>
           </row>
           <row>
             <entry>69</entry>
             <entry><constant>EX_UNAVAILABLE</constant></entry>
             <entry>Service unavailable</entry>
           </row>
           <row>
             <entry>70</entry>
             <entry><constant>EX_SOFTWARE</constant></entry>
             <entry>internal software error</entry>
           </row>
           <row>
             <entry>71</entry>
             <entry><constant>EX_OSERR</constant></entry>
             <entry>System error (e.g., can't fork)</entry>
           </row>
           <row>
             <entry>72</entry>
             <entry><constant>EX_OSFILE</constant></entry>
             <entry>Critical OS file missing</entry>
           </row>
           <row>
             <entry>73</entry>
             <entry><constant>EX_CANTCREAT</constant></entry>
             <entry>Can't create (user) output file</entry>
           </row>
           <row>
             <entry>74</entry>
             <entry><constant>EX_IOERR</constant></entry>
             <entry>Input/output error</entry>
           </row>
           <row>
             <entry>75</entry>
             <entry><constant>EX_TEMPFAIL</constant></entry>
             <entry>Temporary failure; user is invited to retry</entry>
           </row>
           <row>
             <entry>76</entry>
             <entry><constant>EX_PROTOCOL</constant></entry>
             <entry>Remote error in protocol</entry>
           </row>
           <row>
             <entry>77</entry>
             <entry><constant>EX_NOPERM</constant></entry>
             <entry>Permission denied</entry>
           </row>
           <row>
             <entry>78</entry>
             <entry><constant>EX_CONFIG</constant></entry>
             <entry>Configuration error</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </refsect1>
 
   <refsect1>
     <title>Examples</title>
 
       <example>
         <title><varname>$MONITOR_<replaceable>*</replaceable></varname> usage</title>
 
         <para>A service <filename index="false">myfailer.service</filename> which can trigger an
         <varname>OnFailure=</varname> dependency.</para>
 
         <programlisting>
 [Unit]
diff --git a/man/systemd.network.xml b/man/systemd.network.xml
index d69e63e6b8..da19d98c46 100644
--- a/man/systemd.network.xml
+++ b/man/systemd.network.xml
@@ -1131,1329 +1131,1272 @@ Table=1234</programlisting></para>
           <para>Example:
           <programlisting>[Address]
 NetLabel=system_u:object_r:localnet_peer_t:s0</programlisting>
 
           With the example rules applying for interface <literal>eth0</literal>, when the interface is
           configured with an IPv4 address of 10.0.0.0/8, <command>systemd-networkd</command> performs the
           equivalent of <command>netlabelctl</command> operation
 
           <programlisting>netlabelctl unlbl add interface eth0 address:10.0.0.0/8 label:system_u:object_r:localnet_peer_t:s0</programlisting>
 
           and the reverse operation when the IPv4 address is deconfigured.</para>
         </listitem>
       </varlistentry>
-
-      <varlistentry>
-        <term><varname>IPv4NFTSet=</varname><replaceable>family</replaceable>:<replaceable>table</replaceable>:<replaceable>set</replaceable></term>
-        <term><varname>IPv6NFTSet=</varname><replaceable>family</replaceable>:<replaceable>table</replaceable>:<replaceable>set</replaceable></term>
-        <listitem>
-          <para>These settings provide a method for integrating dynamic network configuration into firewall
-          rules with NFT sets. These options expect a whitespace separated list of NFT set definitions. Each
-          definition consists of a colon-separated tuple of NFT address family (one of
-          <literal>arp</literal>, <literal>bridge</literal>, <literal>inet</literal>, <literal>ip</literal>,
-          <literal>ip6</literal>, or <literal>netdev</literal>), table name and set name. The names of tables
-          and sets must conform to lexical restrictions of NFT table names. When an interface is configured
-          with IP addresses, the addresses and subnetwork masks will be appended to the NFT sets. They will
-          be removed when the interface is deconfigured. Failures to manage the sets will be ignored.</para>
-
-          <para>Example:
-          <programlisting>[Address]
-IPv4NFTSet=netdev:filter:eth_ipv4_address
-IPv6NFTSet=netdev:filter:eth_ipv6_address</programlisting>
-          Corresponding NFT rules:
-          <programlisting>table netdev filter {
-        set eth_ipv4_address {
-                type ipv4_addr
-                flags interval
-        }
-        chain eth_ingress {
-                type filter hook ingress device "eth0" priority filter; policy drop;
-                ip daddr != @eth_ipv4_address drop
-                accept
-        }
-}</programlisting>
-          </para>
-        </listitem>
-      </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[Neighbor] Section Options</title>
 
     <para>A [Neighbor] section accepts the following keys. The neighbor section adds a permanent,
     static entry to the neighbor table (IPv6) or ARP table (IPv4) for the given hardware address on the
     links matched for the network. Specify several [Neighbor] sections to configure several static
     neighbors.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Address=</varname></term>
         <listitem>
           <para>The IP address of the neighbor.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LinkLayerAddress=</varname></term>
         <listitem>
           <para>The link layer address (MAC address or IP address) of the neighbor.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[IPv6AddressLabel] Section Options</title>
 
     <para>An [IPv6AddressLabel] section accepts the following keys. Specify several [IPv6AddressLabel]
     sections to configure several address labels. IPv6 address labels are used for address selection.
     See <ulink url="https://tools.ietf.org/html/rfc3484">RFC 3484</ulink>. Precedence is managed by
     userspace, and only the label itself is stored in the kernel.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Label=</varname></term>
         <listitem>
           <para>The label for the prefix, an unsigned integer in the range 04294967294. 0xffffffff is
           reserved. This setting is mandatory.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Prefix=</varname></term>
         <listitem>
           <para>IPv6 prefix is an address with a prefix length, separated by a slash
           <literal>/</literal> character. This setting is mandatory. </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[RoutingPolicyRule] Section Options</title>
 
     <para>An [RoutingPolicyRule] section accepts the following settings. Specify several
     [RoutingPolicyRule] sections to configure several rules.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>TypeOfService=</varname></term>
         <listitem>
           <para>Takes a number between 0 and 255 that specifies the type of service to match.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>From=</varname></term>
         <listitem>
           <para>Specifies the source address prefix to match. Possibly followed by a slash and the
           prefix length.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>To=</varname></term>
         <listitem>
           <para>Specifies the destination address prefix to match. Possibly followed by a slash and the
           prefix length.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FirewallMark=</varname></term>
         <listitem>
           <para>Specifies the iptables firewall mark value to match (a number in the range
           14294967295). Optionally, the firewall mask (also a number between 14294967295) can be
           suffixed with a slash (<literal>/</literal>), e.g., <literal>7/255</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Table=</varname></term>
         <listitem>
           <para>Specifies the routing table identifier to lookup if the rule selector matches. Takes
           one of predefined names <literal>default</literal>, <literal>main</literal>, and
           <literal>local</literal>, and names defined in <varname>RouteTable=</varname> in
           <citerefentry><refentrytitle>networkd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
           or a number between 1 and 4294967295. Defaults to <literal>main</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Priority=</varname></term>
         <listitem>
           <para>Specifies the priority of this rule. <varname>Priority=</varname> is an integer in the
           range 04294967295. Higher number means lower priority, and rules get processed in order of
           increasing number. Defaults to unset, and the kernel will pick a value dynamically.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IncomingInterface=</varname></term>
         <listitem>
           <para>Specifies incoming device to match. If the interface is loopback, the rule only matches
           packets originating from this host.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>OutgoingInterface=</varname></term>
         <listitem>
           <para>Specifies the outgoing device to match. The outgoing interface is only available for
           packets originating from local sockets that are bound to a device.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SourcePort=</varname></term>
         <listitem>
           <para>Specifies the source IP port or IP port range match in forwarding information base
           (FIB) rules. A port range is specified by the lower and upper port separated by a dash.
           Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DestinationPort=</varname></term>
         <listitem>
           <para>Specifies the destination IP port or IP port range match in forwarding information base
           (FIB) rules. A port range is specified by the lower and upper port separated by a dash.
           Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IPProtocol=</varname></term>
         <listitem>
           <para>Specifies the IP protocol to match in forwarding information base (FIB) rules. Takes IP
           protocol name such as <literal>tcp</literal>, <literal>udp</literal> or
           <literal>sctp</literal>, or IP protocol number such as <literal>6</literal> for
           <literal>tcp</literal> or <literal>17</literal> for <literal>udp</literal>. Defaults to unset.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>InvertRule=</varname></term>
         <listitem>
           <para>A boolean. Specifies whether the rule is to be inverted. Defaults to false.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Family=</varname></term>
         <listitem>
           <para>Takes a special value <literal>ipv4</literal>, <literal>ipv6</literal>, or
           <literal>both</literal>. By default, the address family is determined by the address
           specified in <varname>To=</varname> or <varname>From=</varname>. If neither
           <varname>To=</varname> nor <varname>From=</varname> are specified, then defaults to
           <literal>ipv4</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>User=</varname></term>
         <listitem>
           <para>Takes a username, a user ID, or a range of user IDs separated by a dash. Defaults to
           unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SuppressPrefixLength=</varname></term>
         <listitem>
           <para>Takes a number <replaceable>N</replaceable> in the range 0128 and rejects routing
           decisions that have a prefix length of <replaceable>N</replaceable> or less. Defaults to
           unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SuppressInterfaceGroup=</varname></term>
         <listitem>
           <para>Takes an integer in the range 02147483647 and rejects routing decisions that have
           an interface with the same group id. It has the same meaning as
           <option>suppress_ifgroup</option> in <command>ip rule</command>. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Type=</varname></term>
         <listitem>
           <para>Specifies Routing Policy Database (RPDB) rule type. Takes one of
           <literal>blackhole</literal>, <literal>unreachable</literal> or <literal>prohibit</literal>.
           </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[NextHop] Section Options</title>
 
     <para>The [NextHop] section is used to manipulate entries in the kernel's "nexthop" tables. The
     [NextHop] section accepts the following settings. Specify several [NextHop] sections to configure
     several hops.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Id=</varname></term>
         <listitem>
           <para>The id of the next hop. Takes an integer in the range 14294967295. If unspecified,
           then automatically chosen by kernel.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Gateway=</varname></term>
         <listitem>
           <para>As in the [Network] section.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Family=</varname></term>
         <listitem>
           <para>Takes one of the special values <literal>ipv4</literal> or <literal>ipv6</literal>.
           By default, the family is determined by the address specified in
           <varname>Gateway=</varname>. If <varname>Gateway=</varname> is not specified, then defaults
           to <literal>ipv4</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>OnLink=</varname></term>
         <listitem>
           <para>Takes a boolean. If set to true, the kernel does not have to check if the gateway is
           reachable directly by the current machine (i.e., attached to the local network), so that we
           can insert the nexthop in the kernel table without it being complained about. Defaults to
           <literal>no</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Blackhole=</varname></term>
         <listitem>
           <para>Takes a boolean. If enabled, packets to the corresponding routes are discarded
           silently, and <varname>Gateway=</varname> cannot be specified. Defaults to
           <literal>no</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Group=</varname></term>
         <listitem>
           <para>Takes a whitespace separated list of nexthop IDs. Each ID must be in the range
           14294967295. Optionally, each nexthop ID can take a weight after a colon
           (<literal><replaceable>id</replaceable><optional>:<replaceable>weight</replaceable></optional></literal>).
           The weight must be in the range 1255. If the weight is not specified, then it is assumed
           that the weight is 1. This setting cannot be specified with <varname>Gateway=</varname>,
           <varname>Family=</varname>, <varname>Blackhole=</varname>. This setting can be specified
           multiple times. If an empty string is assigned, then the all previous assignments are
           cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[Route] Section Options</title>
 
     <para>The [Route] section accepts the following settings. Specify several [Route] sections to
     configure several routes.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Gateway=</varname></term>
         <listitem>
           <para>Takes the gateway address or the special values <literal>_dhcp4</literal> and
           <literal>_ipv6ra</literal>. If <literal>_dhcp4</literal> or <literal>_ipv6ra</literal> is
           set, then the gateway address provided by DHCPv4 or IPv6 RA is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>GatewayOnLink=</varname></term>
         <listitem>
           <para>Takes a boolean. If set to true, the kernel does not have to check if the gateway is
           reachable directly by the current machine (i.e., attached to the local network), so that we
           can insert the route in the kernel table without it being complained about. Defaults to
           <literal>no</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Destination=</varname></term>
         <listitem>
           <para>The destination prefix of the route. Possibly followed by a slash and the prefix
           length. If omitted, a full-length host route is assumed.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Source=</varname></term>
         <listitem>
           <para>The source prefix of the route. Possibly followed by a slash and the prefix length. If
           omitted, a full-length host route is assumed.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Metric=</varname></term>
         <listitem>
           <para>The metric of the route. Takes an unsigned integer in the range 04294967295. Defaults
           to unset, and the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IPv6Preference=</varname></term>
         <listitem>
           <para>Specifies the route preference as defined in
           <ulink url="https://tools.ietf.org/html/rfc4191">RFC 4191</ulink> for Router Discovery
           messages. Which can be one of <literal>low</literal> the route has a lowest priority,
           <literal>medium</literal> the route has a default priority or <literal>high</literal> the
           route has a highest priority.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Scope=</varname></term>
         <listitem>
           <para>The scope of the IPv4 route, which can be <literal>global</literal>,
           <literal>site</literal>, <literal>link</literal>, <literal>host</literal>, or
           <literal>nowhere</literal>:</para>
           <itemizedlist>
             <listitem>
               <para><literal>global</literal> means the route can reach hosts more than one hop away.
               </para>
             </listitem>
 
             <listitem>
               <para><literal>site</literal> means an interior route in the local autonomous system.
               </para>
             </listitem>
 
             <listitem>
               <para><literal>link</literal> means the route can only reach hosts on the local network
               (one hop away).</para>
             </listitem>
 
             <listitem>
               <para><literal>host</literal> means the route will not leave the local machine (used for
               internal addresses like 127.0.0.1).</para>
             </listitem>
 
             <listitem>
               <para><literal>nowhere</literal> means the destination doesn't exist.</para>
             </listitem>
           </itemizedlist>
 
           <para>For IPv4 route, defaults to <literal>host</literal> if <varname>Type=</varname> is
           <literal>local</literal> or <literal>nat</literal>, and <literal>link</literal> if
           <varname>Type=</varname> is <literal>broadcast</literal>, <literal>multicast</literal>,
           <literal>anycast</literal>, or direct <literal>unicast</literal> routes. In other cases,
           defaults to <literal>global</literal>. The value is not used for IPv6.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PreferredSource=</varname></term>
         <listitem>
           <para>The preferred source address of the route. The address must be in the format described
           in
           <citerefentry project='man-pages'><refentrytitle>inet_pton</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Table=</varname></term>
         <listitem>
           <para>The table identifier for the route. Takes one of predefined names
           <literal>default</literal>, <literal>main</literal>, and <literal>local</literal>, and names
           defined in <varname>RouteTable=</varname> in
           <citerefentry><refentrytitle>networkd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
           or a number between 1 and 4294967295. The table can be retrieved using
           <command>ip route show table <replaceable>num</replaceable></command>. If unset and
           <varname>Type=</varname> is <literal>local</literal>, <literal>broadcast</literal>,
           <literal>anycast</literal>, or <literal>nat</literal>, then <literal>local</literal> is used.
           In other cases, defaults to <literal>main</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Protocol=</varname></term>
         <listitem>
           <para>The protocol identifier for the route. Takes a number between 0 and 255 or the special
           values <literal>kernel</literal>, <literal>boot</literal>, <literal>static</literal>,
           <literal>ra</literal> and <literal>dhcp</literal>. Defaults to <literal>static</literal>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Type=</varname></term>
         <listitem>
           <para>Specifies the type for the route. Takes one of <literal>unicast</literal>,
           <literal>local</literal>, <literal>broadcast</literal>, <literal>anycast</literal>,
           <literal>multicast</literal>, <literal>blackhole</literal>, <literal>unreachable</literal>,
           <literal>prohibit</literal>, <literal>throw</literal>, <literal>nat</literal>, and
           <literal>xresolve</literal>. If <literal>unicast</literal>, a regular route is defined, i.e.
           a route indicating the path to take to a destination network address. If
           <literal>blackhole</literal>, packets to the defined route are discarded silently. If
           <literal>unreachable</literal>, packets to the defined route are discarded and the ICMP
           message "Host Unreachable" is generated. If <literal>prohibit</literal>, packets to the
           defined route are discarded and the ICMP message "Communication Administratively Prohibited"
           is generated. If <literal>throw</literal>, route lookup in the current routing table will
           fail and the route selection process will return to Routing Policy Database (RPDB). Defaults
           to <literal>unicast</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>InitialCongestionWindow=</varname></term>
         <listitem>
           <para>The TCP initial congestion window is used during the start of a TCP connection.
           During the start of a TCP session, when a client requests a resource, the server's initial
           congestion window determines how many packets will be sent during the initial burst of data
           without waiting for acknowledgement. Takes a number between 1 and 1023. Note that 100 is
           considered an extremely large value for this option. When unset, the kernel's default
           (typically 10) will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>InitialAdvertisedReceiveWindow=</varname></term>
         <listitem>
           <para>The TCP initial advertised receive window is the amount of receive data (in bytes)
           that can initially be buffered at one time on a connection. The sending host can send only
           that amount of data before waiting for an acknowledgment and window update from the
           receiving host. Takes a number between 1 and 1023. Note that 100 is considered an extremely
           large value for this option. When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>QuickAck=</varname></term>
         <listitem>
           <para>Takes a boolean. When true enables TCP quick ack mode for the route. When unset, the
           kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FastOpenNoCookie=</varname></term>
         <listitem>
           <para>Takes a boolean. When true enables TCP fastopen without a cookie on a per-route basis.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TTLPropagate=</varname></term>
         <listitem>
           <para>Takes a boolean. When true enables TTL propagation at Label Switched Path (LSP) egress.
           When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MTUBytes=</varname></term>
         <listitem>
           <para>The maximum transmission unit in bytes to set for the route. The usual suffixes K, M,
           G, are supported and are understood to the base of 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TCPAdvertisedMaximumSegmentSize=</varname></term>
         <listitem>
           <para>Specifies the Path MSS (in bytes) hints given on TCP layer. The usual suffixes K, M, G,
           are supported and are understood to the base of 1024. An unsigned integer in the range
           14294967294. When unset, the kernel's default will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MultiPathRoute=<replaceable>address</replaceable>[@<replaceable>name</replaceable>] [<replaceable>weight</replaceable>]</varname></term>
         <listitem>
           <para>Configures multipath route. Multipath routing is the technique of using multiple
           alternative paths through a network. Takes gateway address. Optionally, takes a network
           interface name or index separated with <literal>@</literal>, and a weight in 1..256 for this
           multipath route separated with whitespace. This setting can be specified multiple times. If
           an empty string is assigned, then the all previous assignments are cleared.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>NextHop=</varname></term>
         <listitem>
           <para>Specifies the nexthop id. Takes an unsigned integer in the range 14294967295. If set,
           the corresponding [NextHop] section must be configured. Defaults to unset.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DHCPv4] Section Options</title>
 
     <para>The [DHCPv4] section configures the DHCPv4 client, if it is enabled with the
     <varname>DHCP=</varname> setting described above:</para>
 
     <variablelist class='network-directives'>
 
       <!-- DHCP packet contents -->
 
       <varlistentry>
         <term><varname>SendHostname=</varname></term>
         <listitem>
           <para>When true (the default), the machine's hostname (or the value specified with
           <varname>Hostname=</varname>, described below) will be sent to the DHCP server. Note that the
           hostname must consist only of 7-bit ASCII lower-case characters and no spaces or dots, and be
           formatted as a valid DNS domain name. Otherwise, the hostname is not sent even if this option
           is true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Hostname=</varname></term>
         <listitem>
           <para>Use this value for the hostname which is sent to the DHCP server, instead of machine's
           hostname. Note that the specified hostname must consist only of 7-bit ASCII lower-case
           characters and no spaces or dots, and be formatted as a valid DNS domain name.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MUDURL=</varname></term>
         <listitem>
           <para>When configured, the specified Manufacturer Usage Description (MUD) URL will be sent
           to the DHCPv4 server. Takes a URL of length up to 255 characters. A superficial verification
           that the string is a valid URL will be performed. DHCPv4 clients are intended to have at most
           one MUD URL associated with them. See
           <ulink url="https://tools.ietf.org/html/rfc8520">RFC 8520</ulink>.</para>
 
           <para>MUD is an embedded software standard defined by the IETF that allows IoT device makers
           to advertise device specifications, including the intended communication patterns for their
           device when it connects to the network. The network can then use this to author a
           context-specific access policy, so the device functions only within those parameters.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ClientIdentifier=</varname></term>
         <listitem>
           <para>The DHCPv4 client identifier to use. Takes one of <option>mac</option>,
           <option>duid</option> or <option>duid-only</option>. If set to <option>mac</option>, the
           MAC address of the link is used. If set to <option>duid</option>, an RFC4361-compliant Client
           ID, which is the combination of IAID and DUID (see below), is used. If set to
           <option>duid-only</option>, only DUID is used, this may not be RFC compliant, but some setups
           may require to use this. Defaults to <option>duid</option>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>VendorClassIdentifier=</varname></term>
         <listitem>
           <para>The vendor class identifier used to identify vendor type and configuration.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UserClass=</varname></term>
         <listitem>
           <para>A DHCPv4 client can use UserClass option to identify the type or category of user or
           applications it represents. The information contained in this option is a string that
           represents the user class of which the client is a member. Each class sets an identifying
           string of information to be used by the DHCP service to classify clients. Takes a
           whitespace-separated list of strings.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DUIDType=</varname></term>
         <listitem>
           <para>Override the global <varname>DUIDType=</varname> setting for this network. See
           <citerefentry><refentrytitle>networkd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>
           for a description of possible values.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DUIDRawData=</varname></term>
         <listitem>
           <para>Override the global <varname>DUIDRawData=</varname> setting for this network. See
           <citerefentry><refentrytitle>networkd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>
           for a description of possible values.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IAID=</varname></term>
         <listitem>
           <para>The DHCP Identity Association Identifier (IAID) for the interface, a 32-bit unsigned
           integer.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Anonymize=</varname></term>
         <listitem>
           <para>Takes a boolean. When true, the options sent to the DHCP server will follow the
           <ulink url="https://tools.ietf.org/html/rfc7844">RFC 7844</ulink> (Anonymity Profiles for
           DHCP Clients) to minimize disclosure of identifying information. Defaults to false.</para>
 
           <para>This option should only be set to true when <varname>MACAddressPolicy=</varname> is set
           to <option>random</option> (see
           <citerefentry><refentrytitle>systemd.link</refentrytitle><manvolnum>5</manvolnum></citerefentry>).
           </para>
 
           <para>When true, <varname>SendHostname=</varname>, <varname>ClientIdentifier=</varname>,
           <varname>VendorClassIdentifier=</varname>, <varname>UserClass=</varname>,
           <varname>RequestOptions=</varname>, <varname>SendOption=</varname>,
           <varname>SendVendorOption=</varname>, and <varname>MUDURL=</varname> are ignored.</para>
 
           <para>With this option enabled DHCP requests will mimic those generated by Microsoft
           Windows, in order to reduce the ability to fingerprint and recognize installations. This
           means DHCP request sizes will grow and lease data will be more comprehensive than normally,
           though most of the requested data is not actually used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RequestOptions=</varname></term>
         <listitem>
           <para>Sets request options to be sent to the server in the DHCPv4 request options list. A
           whitespace-separated list of integers in the range 1254. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendOption=</varname></term>
         <listitem>
           <para>Send an arbitrary raw option in the DHCPv4 request. Takes a DHCP option number, data
           type and data separated with a colon
           (<literal><replaceable>option</replaceable>:<replaceable>type</replaceable>:<replaceable>value</replaceable></literal>).
           The option number must be an integer in the range 1254. The type takes one of
           <literal>uint8</literal>, <literal>uint16</literal>, <literal>uint32</literal>,
           <literal>ipv4address</literal>, or <literal>string</literal>. Special characters in the data
           string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is
           specified, then all options specified earlier are cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendVendorOption=</varname></term>
         <listitem>
           <para>Send an arbitrary vendor option in the DHCPv4 request. Takes a DHCP option number, data
           type and data separated with a colon
           (<literal><replaceable>option</replaceable>:<replaceable>type</replaceable>:<replaceable>value</replaceable></literal>).
           The option number must be an integer in the range 1254. The type takes one of
           <literal>uint8</literal>, <literal>uint16</literal>, <literal>uint32</literal>,
           <literal>ipv4address</literal>, or <literal>string</literal>. Special characters in the data
           string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is specified,
           then all options specified earlier are cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IPServiceType=</varname></term>
         <listitem>
           <para>Takes one of the special values <literal>none</literal>, <literal>CS6</literal>, or
           <literal>CS4</literal>. When <literal>none</literal> no IP service type is set to the packet
           sent from the DHCPv4 client. When <literal>CS6</literal> (network control) or
           <literal>CS4</literal> (realtime), the corresponding service type will be set. Defaults to
           <literal>CS6</literal>.</para>
         </listitem>
       </varlistentry>
 
       <!-- How to use the DHCP lease -->
 
       <varlistentry>
         <term><varname>Label=</varname></term>
         <listitem>
           <para>Specifies the label for the IPv4 address received from the DHCP server. The label must
           be a 7-bit ASCII string with a length of 115 characters. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDNS=</varname></term>
         <listitem>
           <para>When true (the default), the DNS servers received from the DHCP server will be used.
           </para>
 
           <para>This corresponds to the <option>nameserver</option> option in
           <citerefentry project='man-pages'><refentrytitle>resolv.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RoutesToDNS=</varname></term>
         <listitem>
           <para>When true, the routes to the DNS servers received from the DHCP server will be
           configured. When <varname>UseDNS=</varname> is disabled, this setting is ignored. Defaults to
           true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseNTP=</varname></term>
         <listitem>
           <para>When true (the default), the NTP servers received from the DHCP server will be used by
           <filename>systemd-timesyncd.service</filename>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RoutesToNTP=</varname></term>
         <listitem>
           <para>When true, the routes to the NTP servers received from the DHCP server will be
           configured. When <varname>UseNTP=</varname> is disabled, this setting is ignored. Defaults to
           true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseSIP=</varname></term>
         <listitem>
           <para>When true (the default), the SIP servers received from the DHCP server will be collected
           and made available to client programs.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseMTU=</varname></term>
         <listitem>
           <para>When true, the interface maximum transmission unit from the DHCP server will be used on
           the current link. If <varname>MTUBytes=</varname> is set, then this setting is ignored.
           Defaults to false.</para>
 
           <para>Note, some drivers will reset the interfaces if the MTU is changed. For such
           interfaces, please try to use <varname>IgnoreCarrierLoss=</varname> with a short timespan,
           e.g. <literal>3 seconds</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseHostname=</varname></term>
         <listitem>
           <para>When true (the default), the hostname received from the DHCP server will be set as the
           transient hostname of the system.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDomains=</varname></term>
         <listitem>
           <para>Takes a boolean, or the special value <option>route</option>. When true, the domain
           name received from the DHCP server will be used as DNS search domain over this link, similar
           to the effect of the <option>Domains=</option> setting. If set to <option>route</option>, the
           domain name received from the DHCP server will be used for routing DNS queries only, but not
           for searching, similar to the effect of the <option>Domains=</option> setting when the
           argument is prefixed with <literal>~</literal>. Defaults to false.</para>
 
           <para>It is recommended to enable this option only on trusted networks, as setting this
           affects resolution of all hostnames, in particular of single-label names. It is generally
           safer to use the supplied domain only as routing domain, rather than as search domain, in
           order to not have it affect local resolution of single-label names.</para>
 
           <para>When set to true, this setting corresponds to the <option>domain</option> option in
           <citerefentry project='man-pages'><refentrytitle>resolv.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseRoutes=</varname></term>
         <listitem>
           <para>When true (the default), the static routes will be requested from the DHCP server and
           added to the routing table with a metric of 1024, and a scope of <option>global</option>,
           <option>link</option> or <option>host</option>, depending on the route's destination and
           gateway. If the destination is on the local host, e.g., 127.x.x.x, or the same as the link's
           own address, the scope will be set to <option>host</option>. Otherwise if the gateway is null
           (a direct route), a <option>link</option> scope will be used. For anything else, scope
           defaults to <option>global</option>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteMetric=</varname></term>
         <listitem>
           <para>Set the routing metric for routes specified by the DHCP server (including the prefix
           route added for the specified prefix). Takes an unsigned integer in the range 04294967295.
           Defaults to 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteTable=<replaceable>num</replaceable></varname></term>
         <listitem>
           <para>The table identifier for DHCP routes (a number between 1 and 4294967295, or 0 to
           unset). The table can be retrieved using
           <command>ip route show table <replaceable>num</replaceable></command>.</para>
 
           <para>When used in combination with <varname>VRF=</varname>, the VRF's routing table is
           used when this parameter is not specified.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteMTUBytes=</varname></term>
         <listitem>
           <para>Specifies the MTU for the DHCP routes. Please see the [Route] section for further
           details.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseGateway=</varname></term>
         <listitem>
           <para>When true, the gateway will be requested from the DHCP server and added to the routing
           table with a metric of 1024, and a scope of <option>link</option>. When unset, the value
           specified with <varname>UseRoutes=</varname> is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseTimezone=</varname></term>
         <listitem><para>When true, the timezone received from the DHCP server will be set as timezone
         of the local system. Defaults to false.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Use6RD=</varname></term>
         <listitem>
           <para>When true, subnets of the received IPv6 prefix are assigned to downstream interfaces
           which enables <varname>DHCPPrefixDelegation=</varname>. See also
           <varname>DHCPPrefixDelegation=</varname> in the [Network] section, the [DHCPPrefixDelegation]
           section, and <ulink url="https://tools.ietf.org/html/rfc5969">RFC 5969</ulink>. Defaults to
           false.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FallbackLeaseLifetimeSec=</varname></term>
         <listitem>
           <para>Allows one to set DHCPv4 lease lifetime when DHCPv4 server does not send the lease
           lifetime. Takes one of <literal>forever</literal> or <literal>infinity</literal>. If
           specified, the acquired address never expires. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <!-- How to communicate with the server -->
 
       <varlistentry>
         <term><varname>RequestBroadcast=</varname></term>
         <listitem>
           <para>Request the server to use broadcast messages before the IP address has been configured.
           This is necessary for devices that cannot receive RAW packets, or that cannot receive packets
           at all before an IP address has been configured. On the other hand, this must not be enabled
           on networks where broadcasts are filtered out.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MaxAttempts=</varname></term>
         <listitem>
           <para>Specifies how many times the DHCPv4 client configuration should be attempted. Takes a
           number or <literal>infinity</literal>. Defaults to <literal>infinity</literal>. Note that the
           time between retries is increased exponentially, up to approximately one per minute, so the
           network will not be overloaded even if this number is high. The default is suitable in most
           circumstances.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ListenPort=</varname></term>
         <listitem>
           <para>Set the port from which the DHCP client packets originate.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DenyList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv4 addresses. Each address can optionally take a
           prefix length after <literal>/</literal>. DHCP offers from servers in the list are rejected.
           Note that if <varname>AllowList=</varname> is configured then <varname>DenyList=</varname> is
           ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>AllowList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv4 addresses. Each address can optionally take a
           prefix length after <literal>/</literal>. DHCP offers from servers in the list are accepted.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendRelease=</varname></term>
         <listitem>
           <para>When true, the DHCPv4 client sends a DHCP release packet when it stops. Defaults to
           true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendDecline=</varname></term>
         <listitem>
           <para>A boolean. When true, <command>systemd-networkd</command> performs IPv4 Duplicate
           Address Detection to the acquired address by the DHCPv4 client. If duplicate is detected,
           the DHCPv4 client rejects the address by sending a <constant>DHCPDECLINE</constant> packet to
           the DHCP server, and tries to obtain an IP address again. See
           <ulink url="https://tools.ietf.org/html/rfc5227">RFC 5227</ulink>. Defaults to false.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>NetLabel=</varname></term>
         <listitem>
           <para>As in [Address] section.</para>
         </listitem>
       </varlistentry>
-
-      <varlistentry>
-        <term><varname>NFTSet=</varname></term>
-        <listitem>
-          <para>As in [Address] section. The type in NFT set definition must be
-          <literal>ipv4_addr</literal>.</para>
-        </listitem>
-      </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DHCPv6] Section Options</title>
 
     <para>The [DHCPv6] section configures the DHCPv6 client, if it is enabled with the
     <varname>DHCP=</varname> setting described above, or invoked by the IPv6 Router Advertisement:
     </para>
 
     <variablelist class='network-directives'>
 
       <!-- DHCP packet contents -->
 
       <varlistentry>
         <term><varname>MUDURL=</varname></term>
         <term><varname>IAID=</varname></term>
         <term><varname>DUIDType=</varname></term>
         <term><varname>DUIDRawData=</varname></term>
         <term><varname>RequestOptions=</varname></term>
         <listitem>
           <para>As in the [DHCPv4] section.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendOption=</varname></term>
         <listitem>
           <para>As in the [DHCPv4] section, however because DHCPv6 uses 16-bit fields to store option
           numbers, the option number is an integer in the range 165536.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendVendorOption=</varname></term>
         <listitem>
           <para>Send an arbitrary vendor option in the DHCPv6 request. Takes an enterprise identifier,
           DHCP option number, data type, and data separated with a colon
           (<literal><replaceable>enterprise identifier</replaceable>:<replaceable>option</replaceable>:<replaceable>type</replaceable>:<replaceable>value</replaceable></literal>).
           Enterprise identifier is an unsigned integer in the range 14294967294. The option number
           must be an integer in the range 1254. Data type takes one of <literal>uint8</literal>,
           <literal>uint16</literal>, <literal>uint32</literal>, <literal>ipv4address</literal>,
           <literal>ipv6address</literal>, or <literal>string</literal>. Special characters in the data
           string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is
           specified, then all options specified earlier are cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UserClass=</varname></term>
         <listitem>
           <para>A DHCPv6 client can use User Class option to identify the type or category of user or
           applications it represents. The information contained in this option is a string that
           represents the user class of which the client is a member. Each class sets an identifying
           string of information to be used by the DHCP service to classify clients. Special characters
           in the data string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is
           specified, then all options specified earlier are cleared. Takes a whitespace-separated list
           of strings. Note that currently <constant>NUL</constant> bytes are not allowed.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>VendorClass=</varname></term>
         <listitem>
           <para>A DHCPv6 client can use VendorClass option to identify the vendor that manufactured the
           hardware on which the client is running. The information contained in the data area of this
           option is contained in one or more opaque fields that identify details of the hardware
           configuration. Takes a whitespace-separated list of strings.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PrefixDelegationHint=</varname></term>
         <listitem>
           <para>Takes an IPv6 address with prefix length in the same format as the
           <varname>Address=</varname> in the [Network] section. The DHCPv6 client will include a prefix
           hint in the DHCPv6 solicitation sent to the server. The prefix length must be in the range
           1128. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <!-- How to use the DHCP lease -->
 
       <varlistentry>
         <term><varname>UseAddress=</varname></term>
         <listitem>
           <para>When true (the default), the IP addresses provided by the DHCPv6 server will be
           assigned.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDelegatedPrefix=</varname></term>
         <listitem>
           <para>When true (the default), the client will request the DHCPv6 server to delegate
           prefixes. If the server provides prefixes to be delegated, then subnets of the prefixes are
           assigned to the interfaces that have <varname>DHCPPrefixDelegation=yes</varname>.
           See also the <varname>DHCPPrefixDelegation=</varname> setting in the [Network] section,
           settings in the [DHCPPrefixDelegation] section, and
           <ulink url="https://www.rfc-editor.org/rfc/rfc8415.html#section-6.3">RFC 8415</ulink>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDNS=</varname></term>
         <term><varname>UseNTP=</varname></term>
         <term><varname>UseHostname=</varname></term>
         <term><varname>UseDomains=</varname></term>
         <term><varname>NetLabel=</varname></term>
         <listitem>
           <para>As in the [DHCPv4] section.</para>
         </listitem>
       </varlistentry>
 
-      <varlistentry>
-        <term><varname>NFTSet=</varname></term>
-        <listitem>
-          <para>As in [DHCPv4] section. The type in NFT set definition must be
-          <literal>ipv6_addr</literal>.</para>
-        </listitem>
-      </varlistentry>
-
       <!-- How to communicate with the server -->
 
       <varlistentry>
         <term><varname>WithoutRA=</varname></term>
         <listitem>
           <para>Allows DHCPv6 client to start without router advertisements's
           <literal>managed</literal> or <literal>other configuration</literal> flag. Takes one of
           <literal>no</literal>, <literal>solicit</literal>, or
           <literal>information-request</literal>. If this is not specified,
           <literal>solicit</literal> is used when <varname>DHCPPrefixDelegation=</varname> is enabled
           and <varname>UplinkInterface=:self</varname> is specified in the [DHCPPrefixDelegation]
           section. Otherwise, defaults to <literal>no</literal>, and the DHCPv6 client will be started
           when an RA is received. See also the <varname>DHCPv6Client=</varname> setting in the
           [IPv6AcceptRA] section.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DHCPPrefixDelegation] Section Options</title>
     <para>The [DHCPPrefixDelegation] section configures subnet prefixes of the delegated prefixes
     acquired by a DHCPv6 client, or by a DHCPv4 client through the 6RD option on another interface.
     The settings in this section are used only when the <varname>DHCPPrefixDelegation=</varname>
     setting in the [Network] section is enabled.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>UplinkInterface=</varname></term>
         <listitem>
           <para>Specifies the name or the index of the uplink interface, or one of the special values
           <literal>:self</literal> and <literal>:auto</literal>. When <literal>:self</literal>, the
           interface itself is considered the uplink interface, and
           <varname>WithoutRA=solicit</varname> is implied if the setting is not explicitly specified.
           When <literal>:auto</literal>, the first link which acquired prefixes to be delegated from
           the DHCPv6 or DHCPv4 server is selected. Defaults to <literal>:auto</literal>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SubnetId=</varname></term>
         <listitem>
           <para>Configure a specific subnet ID on the interface from a (previously) received prefix
           delegation. You can either set "auto" (the default) or a specific subnet ID (as defined in
           <ulink url="https://tools.ietf.org/html/rfc4291#section-2.5.4">RFC 4291</ulink>, section
           2.5.4), in which case the allowed value is hexadecimal, from 0 to 0x7fffffffffffffff
           inclusive.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Announce=</varname></term>
         <listitem>
           <para>Takes a boolean. When enabled, and <varname>IPv6SendRA=</varname> in [Network] section
           is enabled, the delegated prefixes are distributed through the IPv6 Router Advertisement.
           This setting will be ignored when the <varname>DHCPPrefixDelegation=</varname> setting is
           enabled on the upstream interface. Defaults to yes.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Assign=</varname></term>
         <listitem>
           <para>Takes a boolean. Specifies whether to add an address from the delegated prefixes which
           are received from the WAN interface by the DHCPv6 Prefix Delegation. When true (on LAN
           interfce), the EUI-64 algorithm will be used by default to form an interface identifier from
           the delegated prefixes. See also <varname>Token=</varname> setting below. Defaults to yes.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Token=</varname></term>
         <listitem>
           <para>Specifies an optional address generation mode for assigning an address in each
           delegated prefix. This accepts the same syntax as <varname>Token=</varname> in the
           [IPv6AcceptRA] section. If <varname>Assign=</varname> is set to false, then this setting will
           be ignored. Defaults to unset, which means the EUI-64 algorithm will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ManageTemporaryAddress=</varname></term>
         <listitem>
           <para>As in the [Address] section, but defaults to true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteMetric=</varname></term>
         <listitem>
           <para>The metric of the route to the delegated prefix subnet. Takes an unsigned integer in
           the range 04294967295. When set to 0, the kernel's default value is used. Defaults to 256.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>NetLabel=</varname></term>
         <listitem>
           <para>As in [Address] section.</para>
         </listitem>
       </varlistentry>
-
-      <varlistentry>
-        <term><varname>NFTSet=</varname></term>
-        <listitem>
-          <para>As in [DHCPv6] section. The type in NFT set definition must be
-          <literal>ipv6_addr</literal>.</para>
-        </listitem>
-      </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[IPv6AcceptRA] Section Options</title>
     <para>The [IPv6AcceptRA] section configures the IPv6 Router Advertisement (RA) client, if it is enabled
     with the <varname>IPv6AcceptRA=</varname> setting described above:</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Token=</varname></term>
         <listitem>
           <para>Specifies an optional address generation mode for the Stateless Address
           Autoconfiguration (SLAAC). The following values are supported:</para>
 
           <variablelist>
             <varlistentry>
               <term><option>eui64</option></term>
               <listitem>
                 <para>
                   The EUI-64 algorithm will be used to generate an address for that prefix. Only
                   supported by Ethernet or InfiniBand interfaces.
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><option>static:<replaceable>ADDRESS</replaceable></option></term>
               <listitem>
                 <para>
                   An IPv6 address must be specified after a colon (<literal>:</literal>), and the
                   lower bits of the supplied address are combined with the upper bits of a prefix
                   received in a Router Advertisement (RA) message to form a complete address. Note
                   that if multiple prefixes are received in an RA message, or in multiple RA messages,
                   addresses will be formed from each of them using the supplied address. This mode
                   implements SLAAC but uses a static interface identifier instead of an identifier
                   generated by using the EUI-64 algorithm. Because the interface identifier is static,
                   if Duplicate Address Detection detects that the computed address is a duplicate
                   (in use by another node on the link), then this mode will fail to provide an address
                   for that prefix. If an IPv6 address without mode is specified, then
                   <literal>static</literal> mode is assumed.
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><option>prefixstable[:<replaceable>ADDRESS</replaceable>][,<replaceable>UUID</replaceable>]</option></term>
               <listitem>
                 <para>
                   The algorithm specified in
                   <ulink url="https://tools.ietf.org/html/rfc7217">RFC 7217</ulink> will be used to
                   generate interface identifiers. This mode can optionally take an IPv6 address
                   separated with a colon (<literal>:</literal>). If an IPv6 address is specified,
                   then an interface identifier is generated only when a prefix received in an RA
                   message matches the supplied address.
                 </para>
                 <para>
                   This mode can also optionally take a non-null UUID in the format which
                   <function>sd_id128_from_string()</function> accepts, e.g.
                   <literal>86b123b969ba4b7eb8b3d8605123525a</literal> or
                   <literal>86b123b9-69ba-4b7e-b8b3-d8605123525a</literal>. If a UUID is specified, the
                   value is used as the secret key to generate interface identifiers. If not specified,
                   then an application specific ID generated with the system's machine-ID will be used
                   as the secret key. See
                   <citerefentry><refentrytitle>sd-id128</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
                   <citerefentry><refentrytitle>sd_id128_from_string</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
                   and
                   <citerefentry><refentrytitle>sd_id128_get_machine</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
                 </para>
                 <para>
                   Note that the <literal>prefixstable</literal> algorithm uses both the interface
                   name and MAC address as input to the hash to compute the interface identifier, so
                   if either of those are changed the resulting interface identifier (and address)
                   will be changed, even if the prefix received in the RA message has not been
                   changed.
                 </para>
               </listitem>
             </varlistentry>
           </variablelist>
 
           <para>If no address generation mode is specified (which is the default), or a received
           prefix does not match any of the addresses provided in <literal>prefixstable</literal>
           mode, then the EUI-64 algorithm will be used for Ethernet or InfiniBand interfaces,
           otherwise <literal>prefixstable</literal> will be used to form an interface identifier for
           that prefix.</para>
 
           <para>This setting can be specified multiple times. If an empty string is assigned, then
           the all previous assignments are cleared.</para>
 
           <para>Examples:
           <programlisting>Token=eui64
@@ -2463,2125 +2406,2118 @@ Token=prefixstable
 Token=prefixstable:2002:da8:1::</programlisting></para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDNS=</varname></term>
         <listitem>
           <para>When true (the default), the DNS servers received in the Router Advertisement will be used.</para>
 
           <para>This corresponds to the <option>nameserver</option> option in <citerefentry
           project='man-pages'><refentrytitle>resolv.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseDomains=</varname></term>
         <listitem>
           <para>Takes a boolean, or the special value <literal>route</literal>. When true, the domain name
           received via IPv6 Router Advertisement (RA) will be used as DNS search domain over this link, similar to
           the effect of the <option>Domains=</option> setting. If set to <literal>route</literal>, the domain name
           received via IPv6 RA will be used for routing DNS queries only, but not for searching, similar to the
           effect of the <option>Domains=</option> setting when the argument is prefixed with
           <literal>~</literal>. Defaults to false.</para>
 
           <para>It is recommended to enable this option only on trusted networks, as setting this affects resolution
           of all hostnames, in particular of single-label names. It is generally safer to use the supplied domain
           only as routing domain, rather than as search domain, in order to not have it affect local resolution of
           single-label names.</para>
 
           <para>When set to true, this setting corresponds to the <option>domain</option> option in <citerefentry
           project='man-pages'><refentrytitle>resolv.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteTable=<replaceable>num</replaceable></varname></term>
         <listitem>
           <para>The table identifier for the routes received in the Router Advertisement
           (a number between 1 and 4294967295, or 0 to unset).
           The table can be retrieved using <command>ip route show table <replaceable>num</replaceable></command>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteMetric=</varname></term>
         <listitem>
           <para>Set the routing metric for the routes received in the Router Advertisement. Takes an
           unsigned integer in the range 04294967295. Defaults to 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseMTU=</varname></term>
         <listitem>
           <para>Takes a boolean. When true, the MTU received in the Router Advertisement will be
           used. Defaults to true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseGateway=</varname></term>
         <listitem>
           <para>When true (the default), the router address will be configured as the default gateway.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseRoutePrefix=</varname></term>
         <listitem>
           <para>When true (the default), the routes corresponding to the route prefixes received in
           the Router Advertisement will be configured.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseAutonomousPrefix=</varname></term>
         <listitem>
           <para>When true (the default), the autonomous prefix received in the Router Advertisement will be used and take
           precedence over any statically configured ones.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseOnLinkPrefix=</varname></term>
         <listitem>
           <para>When true (the default), the onlink prefix received in the Router Advertisement will be
           used and takes precedence over any statically configured ones.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouterDenyList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 router addresses. Each address can optionally
           take a prefix length after <literal>/</literal>. Any information advertised by the listed
           router is ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouterAllowList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 router addresses. Each address can optionally
           take a prefix length after <literal>/</literal>. Only information advertised by the listed
           router is accepted. Note that if <varname>RouterAllowList=</varname> is configured then
           <varname>RouterDenyList=</varname> is ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PrefixDenyList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 prefixes. Each prefix can optionally take its
           prefix length after <literal>/</literal>. IPv6 prefixes supplied via router advertisements
           in the list are ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PrefixAllowList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 prefixes. Each prefix can optionally take its
           prefix length after <literal>/</literal>. IPv6 prefixes supplied via router advertisements
           in the list are allowed. Note that if <varname>PrefixAllowList=</varname> is configured
           then <varname>PrefixDenyList=</varname> is ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteDenyList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 route prefixes. Each prefix can optionally take
           its prefix length after <literal>/</literal>. IPv6 route prefixes supplied via router
           advertisements in the list are ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteAllowList=</varname></term>
         <listitem>
           <para>A whitespace-separated list of IPv6 route prefixes. Each prefix can optionally take
           its prefix length after <literal>/</literal>. IPv6 route prefixes supplied via router
           advertisements in the list are allowed. Note that if <varname>RouteAllowList=</varname> is
           configured then <varname>RouteDenyList=</varname> is ignored.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DHCPv6Client=</varname></term>
         <listitem>
           <para>Takes a boolean, or the special value <literal>always</literal>. When true, the
           DHCPv6 client will be started in <literal>solicit</literal> mode if the RA has the
           <literal>managed</literal> flag or <literal>information-request</literal> mode if the RA
           lacks the <literal>managed</literal> flag but has the
           <literal>other configuration</literal> flag. If set to <literal>always</literal>, the
           DHCPv6 client will be started in <literal>solicit</literal> mode when an RA is received,
           even if neither the <literal>managed</literal> nor the
           <literal>other configuration</literal> flag is set in the RA. This will be ignored when
           <varname>WithoutRA=</varname> in the [DHCPv6] section is enabled, or
           <varname>UplinkInterface=:self</varname> in the [DHCPPrefixDelegation] section is
           specified. Defaults to true.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>NetLabel=</varname></term>
         <listitem>
           <para>As in [Address] section.</para>
         </listitem>
       </varlistentry>
-      <varlistentry>
-        <term><varname>NFTSet=</varname></term>
-        <listitem>
-          <para>As in [DHCPv6] section. The type in NFT set definition must be
-          <literal>ipv6_addr</literal>.</para>
-        </listitem>
-      </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DHCPServer] Section Options</title>
     <para>The [DHCPServer] section contains settings for the DHCP server, if enabled via the
     <varname>DHCPServer=</varname> option described above:</para>
 
     <variablelist class='network-directives'>
 
       <varlistentry>
         <term><varname>ServerAddress=</varname></term>
         <listitem><para>Specifies server address for the DHCP server. Takes an IPv4 address with prefix
         length, for example <literal>192.168.0.1/24</literal>. This setting may be useful when the link on
         which the DHCP server is running has multiple static addresses. When unset, one of static addresses
         in the link will be automatically selected. Defaults to unset.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PoolOffset=</varname></term>
         <term><varname>PoolSize=</varname></term>
 
         <listitem><para>Configures the pool of addresses to hand out. The pool
         is a contiguous sequence of IP addresses in the subnet configured for
         the server address, which does not include the subnet nor the broadcast
         address. <varname>PoolOffset=</varname> takes the offset of the pool
         from the start of subnet, or zero to use the default value.
         <varname>PoolSize=</varname> takes the number of IP addresses in the
         pool or zero to use the default value. By default, the pool starts at
         the first address after the subnet address and takes up the rest of
         the subnet, excluding the broadcast address. If the pool includes
         the server address (the default), this is reserved and not handed
         out to clients.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DefaultLeaseTimeSec=</varname></term>
         <term><varname>MaxLeaseTimeSec=</varname></term>
 
         <listitem><para>Control the default and maximum DHCP lease
         time to pass to clients. These settings take time values in seconds or
         another common time unit, depending on the suffix. The default
         lease time is used for clients that did not ask for a specific
         lease time. If a client asks for a lease time longer than the
         maximum lease time, it is automatically shortened to the
         specified time. The default lease time defaults to 1h, the
         maximum lease time to 12h. Shorter lease times are beneficial
         if the configuration data in DHCP leases changes frequently
         and clients shall learn the new settings with shorter
         latencies. Longer lease times reduce the generated DHCP
         network traffic.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UplinkInterface=</varname></term>
         <listitem><para>Specifies the name or the index of the uplink interface, or one of the special
         values <literal>:none</literal> and <literal>:auto</literal>. When emitting DNS, NTP, or SIP
         servers is enabled but no servers are specified, the servers configured in the uplink interface
         will be emitted. When <literal>:auto</literal>, the link which has a default gateway with the
         highest priority will be automatically selected. When <literal>:none</literal>, no uplink
         interface will be selected. Defaults to <literal>:auto</literal>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitDNS=</varname></term>
         <term><varname>DNS=</varname></term>
 
         <listitem><para><varname>EmitDNS=</varname> takes a boolean. Configures whether the DHCP leases
         handed out to clients shall contain DNS server information. Defaults to <literal>yes</literal>.
         The DNS servers to pass to clients may be configured with the <varname>DNS=</varname> option,
         which takes a list of IPv4 addresses, or special value <literal>_server_address</literal> which
         will be converted to the address used by the DHCP server.</para>
 
         <para>If the <varname>EmitDNS=</varname> option is enabled but no servers configured, the
         servers are automatically propagated from an "uplink" interface that has appropriate servers
         set. The "uplink" interface is determined by the default route of the system with the highest
         priority. Note that this information is acquired at the time the lease is handed out, and does
         not take uplink interfaces into account that acquire DNS server information at a later point.
         If no suitable uplink interface is found the DNS server data from
         <filename>/etc/resolv.conf</filename> is used. Also, note that the leases are not refreshed if
         the uplink network configuration changes. To ensure clients regularly acquire the most current
         uplink DNS server information, it is thus advisable to shorten the DHCP lease time via
         <varname>MaxLeaseTimeSec=</varname> described above.</para>
 
         <para>This setting can be specified multiple times. If an empty string is specified, then all
         DNS servers specified earlier are cleared.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitNTP=</varname></term>
         <term><varname>NTP=</varname></term>
         <term><varname>EmitSIP=</varname></term>
         <term><varname>SIP=</varname></term>
         <term><varname>EmitPOP3=</varname></term>
         <term><varname>POP3=</varname></term>
         <term><varname>EmitSMTP=</varname></term>
         <term><varname>SMTP=</varname></term>
         <term><varname>EmitLPR=</varname></term>
         <term><varname>LPR=</varname></term>
 
         <listitem><para>Similar to the <varname>EmitDNS=</varname> and <varname>DNS=</varname> settings
         described above, these settings configure whether and what server information for the indicate
         protocol shall be emitted as part of the DHCP lease. The same syntax, propagation semantics and
         defaults apply as for <varname>EmitDNS=</varname> and <varname>DNS=</varname>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitRouter=</varname></term>
         <term><varname>Router=</varname></term>
 
         <listitem><para>The <varname>EmitRouter=</varname> setting takes a boolean value, and configures
         whether the DHCP lease should contain the router option. The <varname>Router=</varname> setting
         takes an IPv4 address, and configures the router address to be emitted. When the
         <varname>Router=</varname> setting is not specified, then the server address will be used for
         the router option. When the <varname>EmitRouter=</varname> setting is disabled, the
         <varname>Router=</varname> setting will be ignored. The <varname>EmitRouter=</varname> setting
         defaults to true, and the <varname>Router=</varname> setting defaults to unset.
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitTimezone=</varname></term>
         <term><varname>Timezone=</varname></term>
 
         <listitem><para>Takes a boolean. Configures whether the DHCP leases handed out
         to clients shall contain timezone information. Defaults to <literal>yes</literal>. The
         <varname>Timezone=</varname> setting takes a timezone string
         (such as <literal>Europe/Berlin</literal> or
         <literal>UTC</literal>) to pass to clients. If no explicit
         timezone is set, the system timezone of the local host is
         propagated, as determined by the
         <filename>/etc/localtime</filename> symlink.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BootServerAddress=</varname></term>
 
         <listitem>
           <para>Takes an IPv4 address of the boot server used by e.g. PXE boot systems. When specified, this
           address is sent in the <option>siaddr</option> field of the DHCP message header. See <ulink
           url="https://www.rfc-editor.org/rfc/rfc2131.html">RFC 2131</ulink> for more details. Defaults to
           unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BootServerName=</varname></term>
 
         <listitem>
           <para>Takes a name of the boot server used by e.g. PXE boot systems. When specified, this name is
           sent in the DHCP option 66 ("TFTP server name"). See <ulink
           url="https://www.rfc-editor.org/rfc/rfc2132.html">RFC 2132</ulink> for more details. Defaults to
           unset.</para>
 
           <para>Note that typically setting one of <varname>BootServerName=</varname> or
           <varname>BootServerAddress=</varname> is sufficient, but both can be set too, if desired.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BootFilename=</varname></term>
 
         <listitem>
           <para>Takes a path or URL to a file loaded by e.g. a PXE boot loader. When specified, this path is
           sent in the DHCP option 67 ("Bootfile name"). See <ulink
           url="https://www.rfc-editor.org/rfc/rfc2132.html">RFC 2132</ulink> for more details. Defaults to
           unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendOption=</varname></term>
         <listitem>
           <para>Send a raw option with value via DHCPv4 server. Takes a DHCP option number, data type
           and data (<literal><replaceable>option</replaceable>:<replaceable>type</replaceable>:<replaceable>value</replaceable></literal>).
           The option number is an integer in the range 1254. The type takes one of <literal>uint8</literal>,
           <literal>uint16</literal>, <literal>uint32</literal>, <literal>ipv4address</literal>, <literal>ipv6address</literal>, or
           <literal>string</literal>. Special characters in the data string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is specified,
           then all options specified earlier are cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SendVendorOption=</varname></term>
         <listitem>
           <para>Send a vendor option with value via DHCPv4 server. Takes a DHCP option number, data type
           and data (<literal><replaceable>option</replaceable>:<replaceable>type</replaceable>:<replaceable>value</replaceable></literal>).
           The option number is an integer in the range 1254. The type takes one of <literal>uint8</literal>,
           <literal>uint16</literal>, <literal>uint32</literal>, <literal>ipv4address</literal>, or
           <literal>string</literal>. Special characters in the data string may be escaped using
           <ulink url="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">C-style
           escapes</ulink>. This setting can be specified multiple times. If an empty string is specified,
           then all options specified earlier are cleared. Defaults to unset.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>BindToInterface=</varname></term>
         <listitem>
           <para>Takes a boolean value. When <literal>yes</literal>, DHCP server socket will be bound
           to its network interface and all socket communication will be restricted to this interface.
           Defaults to <literal>yes</literal>, except if <varname>RelayTarget=</varname> is used (see below),
           in which case it defaults to <literal>no</literal>.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>RelayTarget=</varname></term>
         <listitem>
           <para>Takes an IPv4 address, which must be in the format described in
           <citerefentry project='man-pages'><refentrytitle>inet_pton</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
           Turns this DHCP server into a DHCP relay agent. See <ulink url="https://tools.ietf.org/html/rfc1542">RFC 1542</ulink>.
           The address is the address of DHCP server or another relay agent to forward DHCP messages to and from.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>RelayAgentCircuitId=</varname></term>
         <listitem>
           <para>Specifies value for Agent Circuit ID suboption of Relay Agent Information option.
           Takes a string, which must be in the format <literal>string:<replaceable>value</replaceable></literal>,
           where <literal><replaceable>value</replaceable></literal> should be replaced with the value of the suboption.
           Defaults to unset (means no Agent Circuit ID suboption is generated).
           Ignored if <varname>RelayTarget=</varname> is not specified.</para>
         </listitem>
       </varlistentry>
       <varlistentry>
         <term><varname>RelayAgentRemoteId=</varname></term>
         <listitem>
           <para>Specifies value for Agent Remote ID suboption of Relay Agent Information option.
           Takes a string, which must be in the format <literal>string:<replaceable>value</replaceable></literal>,
           where <literal><replaceable>value</replaceable></literal> should be replaced with the value of the suboption.
           Defaults to unset (means no Agent Remote ID suboption is generated).
           Ignored if <varname>RelayTarget=</varname> is not specified.</para>
         </listitem>
       </varlistentry>
 
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DHCPServerStaticLease] Section Options</title>
     <para>The <literal>[DHCPServerStaticLease]</literal> section configures a static DHCP lease to assign a
     fixed IPv4 address to a specific device based on its MAC address. This section can be specified multiple
     times.</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>MACAddress=</varname></term>
 
         <listitem><para>The hardware address of a device to match. This key is mandatory.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Address=</varname></term>
 
         <listitem><para>The IPv4 address that should be assigned to the device that was matched with
         <varname>MACAddress=</varname>. This key is mandatory.</para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[IPv6SendRA] Section Options</title>
     <para>The [IPv6SendRA] section contains settings for sending IPv6 Router Advertisements and whether
     to act as a router, if enabled via the <varname>IPv6SendRA=</varname> option described above. IPv6
     network prefixes or routes are defined with one or more [IPv6Prefix] or [IPv6RoutePrefix] sections.
     </para>
 
     <variablelist class='network-directives'>
 
       <varlistentry>
         <term><varname>Managed=</varname></term>
         <term><varname>OtherInformation=</varname></term>
 
         <listitem><para>Takes a boolean. Controls whether a DHCPv6 server is used to acquire IPv6
         addresses on the network link when <varname>Managed=</varname>
         is set to <literal>true</literal> or if only additional network
         information can be obtained via DHCPv6 for the network link when
         <varname>OtherInformation=</varname> is set to
         <literal>true</literal>. Both settings default to
         <literal>false</literal>, which means that a DHCPv6 server is not being
         used.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouterLifetimeSec=</varname></term>
 
         <listitem><para>Takes a timespan. Configures the IPv6 router lifetime in seconds. The value must be 0
         seconds, or between 4 seconds and 9000 seconds. When set to 0, the host is not acting as a router.
         Defaults to 1800 seconds (30 minutes).</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouterPreference=</varname></term>
 
         <listitem><para>Configures IPv6 router preference if
         <varname>RouterLifetimeSec=</varname> is non-zero. Valid values are
         <literal>high</literal>, <literal>medium</literal> and
         <literal>low</literal>, with <literal>normal</literal> and
         <literal>default</literal> added as synonyms for
         <literal>medium</literal> just to make configuration easier. See
         <ulink url="https://tools.ietf.org/html/rfc4191">RFC 4191</ulink>
         for details. Defaults to <literal>medium</literal>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UplinkInterface=</varname></term>
         <listitem><para>Specifies the name or the index of the uplink interface, or one of the special
         values <literal>:none</literal> and <literal>:auto</literal>. When emitting DNS servers or
         search domains is enabled but no servers are specified, the servers configured in the uplink
         interface will be emitted. When <literal>:auto</literal>, the value specified to the same
         setting in the [DHCPPrefixDelegation] section will be used if
         <varname>DHCPPrefixDelegation=</varname> is enabled, otherwise the link which has a default
         gateway with the highest priority will be automatically selected. When <literal>:none</literal>,
         no uplink interface will be selected. Defaults to <literal>:auto</literal>.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitDNS=</varname></term>
         <term><varname>DNS=</varname></term>
 
         <listitem><para><varname>DNS=</varname> specifies a list of recursive DNS server IPv6 addresses
         that are distributed via Router Advertisement messages when <varname>EmitDNS=</varname> is true.
         <varname>DNS=</varname> also takes special value <literal>_link_local</literal>; in that case
         the IPv6 link-local address is distributed. If <varname>DNS=</varname> is empty, DNS servers are
         read from the [Network] section. If the [Network] section does not contain any DNS servers
         either, DNS servers from the uplink interface specified in <varname>UplinkInterface=</varname>
         will be used. When <varname>EmitDNS=</varname> is false, no DNS server information is sent in
         Router Advertisement messages. <varname>EmitDNS=</varname> defaults to true.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>EmitDomains=</varname></term>
         <term><varname>Domains=</varname></term>
 
         <listitem><para>A list of DNS search domains distributed via Router Advertisement messages when
         <varname>EmitDomains=</varname> is true. If <varname>Domains=</varname> is empty, DNS search
         domains are read from the [Network] section. If the [Network] section does not contain any DNS
         search domains either, DNS search domains from the uplink interface specified in
         <varname>UplinkInterface=</varname> will be used. When <varname>EmitDomains=</varname> is false,
         no DNS search domain information is sent in Router Advertisement messages.
         <varname>EmitDomains=</varname> defaults to true.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DNSLifetimeSec=</varname></term>
 
         <listitem><para>Lifetime in seconds for the DNS server addresses listed in
         <varname>DNS=</varname> and search domains listed in <varname>Domains=</varname>. Defaults to
         3600 seconds (one hour).</para></listitem>
       </varlistentry>
 
     </variablelist>
     </refsect1>
 
     <refsect1>
     <title>[IPv6Prefix] Section Options</title>
     <para>One or more [IPv6Prefix] sections contain the IPv6 prefixes that are announced via Router
     Advertisements. See <ulink url="https://tools.ietf.org/html/rfc4861">RFC 4861</ulink> for further
     details.</para>
 
     <variablelist class='network-directives'>
 
       <varlistentry>
         <term><varname>AddressAutoconfiguration=</varname></term>
         <term><varname>OnLink=</varname></term>
 
         <listitem><para>Takes a boolean to specify whether IPv6 addresses can be
         autoconfigured with this prefix and whether the prefix can be used for
         onlink determination. Both settings default to <literal>true</literal>
         in order to ease configuration.
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Prefix=</varname></term>
 
         <listitem><para>The IPv6 prefix that is to be distributed to hosts.  Similarly to configuring static
         IPv6 addresses, the setting is configured as an IPv6 prefix and its prefix length, separated by a
         <literal>/</literal> character. Use multiple [IPv6Prefix] sections to configure multiple IPv6
         prefixes since prefix lifetimes, address autoconfiguration and onlink status may differ from one
         prefix to another.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PreferredLifetimeSec=</varname></term>
         <term><varname>ValidLifetimeSec=</varname></term>
 
         <listitem><para>Preferred and valid lifetimes for the prefix measured in seconds.
         <varname>PreferredLifetimeSec=</varname> defaults to 1800 seconds (30 minutes) and
         <varname>ValidLifetimeSec=</varname> defaults to 3600 seconds (one hour).</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Assign=</varname></term>
         <listitem><para>Takes a boolean. When true, adds an address from the prefix. Default to false.
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Token=</varname></term>
         <listitem>
           <para>Specifies an optional address generation mode for assigning an address in each
           prefix. This accepts the same syntax as <varname>Token=</varname> in the [IPv6AcceptRA]
           section. If <varname>Assign=</varname> is set to false, then this setting will be ignored.
           Defaults to unset, which means the EUI-64 algorithm will be used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RouteMetric=</varname></term>
         <listitem>
           <para>The metric of the prefix route. Takes an unsigned integer in the range 04294967295.
           When unset or set to 0, the kernel's default value is used. This setting is ignored when
           <varname>Assign=</varname> is false.</para>
         </listitem>
       </varlistentry>
     </variablelist>
     </refsect1>
 
     <refsect1>
     <title>[IPv6RoutePrefix] Section Options</title>
     <para>One or more [IPv6RoutePrefix] sections contain the IPv6
     prefix routes that are announced via Router Advertisements. See
     <ulink url="https://tools.ietf.org/html/rfc4191">RFC 4191</ulink>
     for further details.</para>
 
     <variablelist class='network-directives'>
 
       <varlistentry>
         <term><varname>Route=</varname></term>
 
         <listitem><para>The IPv6 route that is to be distributed to hosts.  Similarly to configuring static
         IPv6 routes, the setting is configured as an IPv6 prefix routes and its prefix route length,
         separated by a <literal>/</literal> character. Use multiple [IPv6PrefixRoutes] sections to configure
         multiple IPv6 prefix routes.</para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LifetimeSec=</varname></term>
 
         <listitem><para>Lifetime for the route prefix measured in seconds.
         <varname>LifetimeSec=</varname> defaults to 3600 seconds (one hour).</para></listitem>
       </varlistentry>
 
     </variablelist>
     </refsect1>
 
     <refsect1>
     <title>[Bridge] Section Options</title>
       <para>The [Bridge] section accepts the following keys:</para>
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>UnicastFlood=</varname></term>
           <listitem>
             <para>Takes a boolean. Controls whether the bridge should flood
             traffic for which an FDB entry is missing and the destination
             is unknown through this port. When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>MulticastFlood=</varname></term>
           <listitem>
             <para>Takes a boolean. Controls whether the bridge should flood
             traffic for which an MDB entry is missing and the destination
             is unknown through this port. When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>MulticastToUnicast=</varname></term>
           <listitem>
             <para>Takes a boolean. Multicast to unicast works on top of the multicast snooping feature of
             the bridge. Which means unicast copies are only delivered to hosts which are interested in it.
             When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>NeighborSuppression=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether ARP and ND neighbor suppression is enabled for
             this port. When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Learning=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether MAC address learning is enabled for
             this port. When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>HairPin=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether traffic may be sent back out of the port on which it
             was received. When this flag is false, then the bridge will not forward traffic back out of the
             receiving port. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Isolated=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether this port is isolated or not. Within a bridge,
             isolated ports can only communicate with non-isolated ports. When set to true, this port can only
             communicate with other ports whose Isolated setting is false.  When set to false, this port
             can communicate with any other ports. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>UseBPDU=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether STP Bridge Protocol Data Units will be
             processed by the bridge port. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>FastLeave=</varname></term>
           <listitem>
             <para>Takes a boolean. This flag allows the bridge to immediately stop multicast
             traffic on a port that receives an IGMP Leave message. It is only used with
             IGMP snooping if enabled on the bridge. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>AllowPortToBeRoot=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether a given port is allowed to
             become a root port. Only used when STP is enabled on the bridge.
             When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>ProxyARP=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether proxy ARP to be enabled on this port.
             When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>ProxyARPWiFi=</varname></term>
           <listitem>
             <para>Takes a boolean. Configures whether proxy ARP to be enabled on this port
             which meets extended requirements by IEEE 802.11 and Hotspot 2.0 specifications.
             When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>MulticastRouter=</varname></term>
           <listitem>
             <para>Configures this port for having multicast routers attached. A port with a multicast
             router will receive all multicast traffic. Takes one of <literal>no</literal>
             to disable multicast routers on this port, <literal>query</literal> to let the system detect
             the presence of routers, <literal>permanent</literal> to permanently enable multicast traffic
             forwarding on this port, or <literal>temporary</literal> to enable multicast routers temporarily
             on this port, not depending on incoming queries. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Cost=</varname></term>
           <listitem>
             <para>Sets the "cost" of sending packets of this interface.
             Each port in a bridge may have a different speed and the cost
             is used to decide which link to use. Faster interfaces
             should have lower costs. It is an integer value between 1 and
             65535.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Priority=</varname></term>
           <listitem>
             <para>Sets the "priority" of sending packets on this interface.
             Each port in a bridge may have a different priority which is used
             to decide which link to use. Lower value means higher priority.
             It is an integer value between 0 to 63. Networkd does not set any
             default, meaning the kernel default value of 32 is used.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
   <refsect1>
     <title>[BridgeFDB] Section Options</title>
       <para>The [BridgeFDB] section manages the forwarding database table of a port and accepts the following
       keys. Specify several [BridgeFDB] sections to configure several static MAC table entries.</para>
 
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>MACAddress=</varname></term>
           <listitem>
             <para>As in the [Network] section. This key is mandatory.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Destination=</varname></term>
           <listitem>
             <para>Takes an IP address of the destination VXLAN tunnel endpoint.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>VLANId=</varname></term>
           <listitem>
             <para>The VLAN ID for the new static MAC table entry. If
             omitted, no VLAN ID information is appended to the new static MAC
             table entry.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>VNI=</varname></term>
           <listitem>
             <para>The VXLAN Network Identifier (or VXLAN Segment ID) to use to connect to
             the remote VXLAN tunnel endpoint. Takes a number in the range 116777215.
             Defaults to unset.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>AssociatedWith=</varname></term>
           <listitem>
             <para>Specifies where the address is associated with. Takes one of <literal>use</literal>,
             <literal>self</literal>, <literal>master</literal> or <literal>router</literal>.
             <literal>use</literal> means the address is in use. User space can use this option to
             indicate to the kernel that the fdb entry is in use. <literal>self</literal> means
             the address is associated with the port drivers fdb. Usually hardware. <literal>master</literal>
             means the address is associated with master devices fdb. <literal>router</literal> means
             the destination address is associated with a router. Note that it's valid if the referenced
             device is a VXLAN type device and has route shortcircuit enabled. Defaults to <literal>self</literal>.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>OutgoingInterface=</varname></term>
           <listitem>
             <para>Specifies the name or index of the outgoing interface for the VXLAN device driver to
             reach the remote VXLAN tunnel endpoint. Defaults to unset.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
   <refsect1>
     <title>[BridgeMDB] Section Options</title>
       <para>The [BridgeMDB] section manages the multicast membership entries forwarding database table of a port and accepts the following
       keys. Specify several [BridgeMDB] sections to configure several permanent multicast membership entries.</para>
 
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>MulticastGroupAddress=</varname></term>
           <listitem>
             <para>Specifies the IPv4 or IPv6 multicast group address to add. This setting is mandatory.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>VLANId=</varname></term>
           <listitem>
             <para>The VLAN ID for the new entry. Valid ranges are 0 (no VLAN) to 4094. Optional, defaults to 0.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[LLDP] Section Options</title>
       <para>The [LLDP] section manages the Link Layer Discovery Protocol (LLDP) and accepts the following
       keys:</para>
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>MUDURL=</varname></term>
           <listitem>
             <para>When configured, the specified Manufacturer Usage Descriptions (MUD) URL will be sent in
             LLDP packets. The syntax and semantics are the same as for <varname>MUDURL=</varname> in the
             [DHCPv4] section described above.</para>
 
             <para>The MUD URLs received via LLDP packets are saved and can be read using the
             <function>sd_lldp_neighbor_get_mud_url()</function> function.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[CAN] Section Options</title>
       <para>The [CAN] section manages the Controller Area Network (CAN bus) and accepts the
       following keys:</para>
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>BitRate=</varname></term>
           <listitem>
             <para>The bitrate of CAN device in bits per second. The usual SI prefixes (K, M) with the base of 1000 can
             be used here. Takes a number in the range 14294967295.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>SamplePoint=</varname></term>
           <listitem>
             <para>Optional sample point in percent with one decimal (e.g. <literal>75%</literal>,
             <literal>87.5%</literal>) or permille (e.g. <literal>875</literal>). This will be ignored when
             <varname>BitRate=</varname> is unspecified.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>TimeQuantaNSec=</varname></term>
           <term><varname>PropagationSegment=</varname></term>
           <term><varname>PhaseBufferSegment1=</varname></term>
           <term><varname>PhaseBufferSegment2=</varname></term>
           <term><varname>SyncJumpWidth=</varname></term>
           <listitem>
             <para>Specifies the time quanta, propagation segment, phase buffer segment 1 and 2, and the
             synchronization jump width, which allow one to define the CAN bit-timing in a hardware
             independent format as proposed by the Bosch CAN 2.0 Specification.
             <varname>TimeQuantaNSec=</varname> takes a timespan in nanoseconds.
             <varname>PropagationSegment=</varname>, <varname>PhaseBufferSegment1=</varname>,
             <varname>PhaseBufferSegment2=</varname>, and <varname>SyncJumpWidth=</varname> take number
             of time quantum specified in <varname>TimeQuantaNSec=</varname> and must be an unsigned
             integer in the range 04294967295. These settings except for
             <varname>SyncJumpWidth=</varname> will be ignored when <varname>BitRate=</varname> is
             specified.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>DataBitRate=</varname></term>
           <term><varname>DataSamplePoint=</varname></term>
           <listitem>
             <para>The bitrate and sample point for the data phase, if CAN-FD is used. These settings are
             analogous to the <varname>BitRate=</varname> and <varname>SamplePoint=</varname> keys.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>DataTimeQuantaNSec=</varname></term>
           <term><varname>DataPropagationSegment=</varname></term>
           <term><varname>DataPhaseBufferSegment1=</varname></term>
           <term><varname>DataPhaseBufferSegment2=</varname></term>
           <term><varname>DataSyncJumpWidth=</varname></term>
           <listitem>
             <para>Specifies the time quanta, propagation segment, phase buffer segment 1 and 2, and the
             synchronization jump width for the data phase, if CAN-FD is used. These settings are
             analogous to the <varname>TimeQuantaNSec=</varname> or related settings.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>FDMode=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, CAN-FD mode is enabled for the interface.
             Note, that a bitrate and optional sample point should also be set for the CAN-FD data phase using
             the <varname>DataBitRate=</varname> and <varname>DataSamplePoint=</varname> keys, or
             <varname>DataTimeQuanta=</varname> and related settings.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>FDNonISO=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, non-ISO CAN-FD mode is enabled for the
             interface. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>RestartSec=</varname></term>
           <listitem>
             <para>Automatic restart delay time. If set to a non-zero value, a restart of the CAN controller will be
             triggered automatically in case of a bus-off condition after the specified delay time. Subsecond delays can
             be specified using decimals (e.g. <literal>0.1s</literal>) or a <literal>ms</literal> or
             <literal>us</literal> postfix. Using <literal>infinity</literal> or <literal>0</literal> will turn the
             automatic restart off. By default automatic restart is disabled.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Termination=</varname></term>
           <listitem>
             <para>Takes a boolean or a termination resistor value in ohm in the range 065535. When
             <literal>yes</literal>, the termination resistor is set to 120 ohm. When
             <literal>no</literal> or <literal>0</literal> is set, the termination resistor is disabled.
             When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>TripleSampling=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, three samples (instead of one) are used to determine
             the value of a received bit by majority rule. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>BusErrorReporting=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, reporting of CAN bus errors is activated
             (those include single bit, frame format, and bit stuffing errors, unable to send dominant bit,
             unable to send recessive bit, bus overload, active error announcement, error occurred on
             transmission). When unset, the kernel's default will be used. Note: in case of a CAN bus with a
             single CAN device, sending a CAN frame may result in a huge number of CAN bus errors.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>ListenOnly=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, listen-only mode is enabled. When the
             interface is in listen-only mode, the interface neither transmit CAN frames nor send ACK
             bit. Listen-only mode is important to debug CAN networks without interfering with the
             communication or acknowledge the CAN frame. When unset, the kernel's default will be used.
             </para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>Loopback=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, loopback mode is enabled. When the
             loopback mode is enabled, the interface treats messages transmitted by itself as received
             messages. The loopback mode is important to debug CAN networks. When unset, the kernel's
             default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>OneShot=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, one-shot mode is enabled. When unset,
             the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>PresumeAck=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, the interface will ignore missing CAN
             ACKs. When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>ClassicDataLengthCode=</varname></term>
           <listitem>
             <para>Takes a boolean. When <literal>yes</literal>, the interface will handle the 4bit data
             length code (DLC). When unset, the kernel's default will be used.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[IPoIB] Section Options</title>
       <para>The [IPoIB] section manages the IP over Infiniband and accepts the following keys:</para>
       <variablelist class='network-directives'>
         <xi:include href="systemd.netdev.xml" xpointer="ipoib_mode" />
         <xi:include href="systemd.netdev.xml" xpointer="ipoib_umcast" />
       </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[QDisc] Section Options</title>
     <para>The [QDisc] section manages the traffic control queueing discipline (qdisc).</para>
 
     <variablelist class='network-directives'>
       <varlistentry>
         <term><varname>Parent=</varname></term>
         <listitem>
           <para>Specifies the parent Queueing Discipline (qdisc). Takes one of <literal>clsact</literal>
           or <literal>ingress</literal>. This is mandatory.</para>
         </listitem>
       </varlistentry>
 
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[NetworkEmulator] Section Options</title>
     <para>The [NetworkEmulator] section manages the queueing discipline (qdisc) of the network emulator. It
     can be used to configure the kernel packet scheduler and simulate packet delay and loss for UDP or TCP
     applications, or limit the bandwidth usage of a particular service to simulate internet connections.
     </para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>DelaySec=</varname></term>
         <listitem>
           <para>Specifies the fixed amount of delay to be added to all packets going out of the
           interface. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DelayJitterSec=</varname></term>
         <listitem>
           <para>Specifies the chosen delay to be added to the packets outgoing to the network
           interface. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the maximum number of packets the qdisc may hold queued at a time.
           An unsigned integer in the range 04294967294. Defaults to 1000.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LossRate=</varname></term>
         <listitem>
           <para>Specifies an independent loss probability to be added to the packets outgoing from the
           network interface. Takes a percentage value, suffixed with "%". Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DuplicateRate=</varname></term>
         <listitem>
           <para>Specifies that the chosen percent of packets is duplicated before queuing them.
           Takes a percentage value, suffixed with "%". Defaults to unset.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[TokenBucketFilter] Section Options</title>
     <para>The [TokenBucketFilter] section manages the queueing discipline (qdisc) of token bucket filter
     (tbf).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>LatencySec=</varname></term>
         <listitem>
           <para>Specifies the latency parameter, which specifies the maximum amount of time a
           packet can sit in the Token Bucket Filter (TBF). Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>LimitBytes=</varname></term>
         <listitem>
           <para>Takes the number of bytes that can be queued waiting for tokens to become available.
           When the size is suffixed with K, M, or G, it is parsed as Kilobytes, Megabytes, or Gigabytes,
           respectively, to the base of 1024. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BurstBytes=</varname></term>
         <listitem>
           <para>Specifies the size of the bucket. This is the maximum amount of bytes that tokens
           can be available for instantaneous transfer. When the size is suffixed with K, M, or G, it is
           parsed as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to
           unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Rate=</varname></term>
         <listitem>
           <para>Specifies the device specific bandwidth. When suffixed with K, M, or G, the specified
           bandwidth is parsed as Kilobits, Megabits, or Gigabits, respectively, to the base of 1000.
           Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MPUBytes=</varname></term>
         <listitem>
           <para>The Minimum Packet Unit (MPU) determines the minimal token usage (specified in bytes)
           for a packet. When suffixed with K, M, or G, the specified size is parsed as Kilobytes,
           Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to zero.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PeakRate=</varname></term>
         <listitem>
           <para>Takes the maximum depletion rate of the bucket. When suffixed with K, M, or G, the
           specified size is parsed as Kilobits, Megabits, or Gigabits, respectively, to the base of
           1000. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MTUBytes=</varname></term>
         <listitem>
           <para>Specifies the size of the peakrate bucket. When suffixed with K, M, or G, the specified
           size is parsed as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of 1024.
           Defaults to unset.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[PIE] Section Options</title>
     <para>The [PIE] section manages the queueing discipline (qdisc) of Proportional Integral
     controller-Enhanced (PIE).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the queue size in number of packets. When this limit is reached,
           incoming packets are dropped. An unsigned integer in the range 14294967294. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[FlowQueuePIE] Section Options</title>
     <para>The <literal>[FlowQueuePIE]</literal> section manages the queueing discipline
     (qdisc) of Flow Queue Proportional Integral controller-Enhanced (fq_pie).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the queue size in number of packets. When this limit is reached,
           incoming packets are dropped. An unsigned integer ranges 1 to 4294967294. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[StochasticFairBlue] Section Options</title>
     <para>The [StochasticFairBlue] section manages the queueing discipline (qdisc) of stochastic fair blue
     (sfb).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the queue size in number of packets. When this limit is reached,
           incoming packets are dropped. An unsigned integer in the range 04294967294. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[StochasticFairnessQueueing] Section Options</title>
     <para>The [StochasticFairnessQueueing] section manages the queueing discipline (qdisc) of stochastic
     fairness queueing (sfq).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PerturbPeriodSec=</varname></term>
         <listitem>
           <para>Specifies the interval in seconds for queue algorithm perturbation. Defaults to unset.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[BFIFO] Section Options</title>
     <para>The [BFIFO] section manages the queueing discipline (qdisc) of Byte limited Packet First In First
     Out (bfifo).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>LimitBytes=</varname></term>
         <listitem>
           <para>Specifies the hard limit in bytes on the FIFO buffer size. The size limit prevents overflow
           in case the kernel is unable to dequeue packets as quickly as it receives them. When this limit is
           reached, incoming packets are dropped. When suffixed with K, M, or G, the specified size is parsed
           as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to unset and
           kernel default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[PFIFO] Section Options</title>
     <para>The [PFIFO] section manages the queueing discipline (qdisc) of Packet First In First Out
     (pfifo).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the number of packets in the FIFO queue. The size limit prevents
           overflow in case the kernel is unable to dequeue packets as quickly as it receives them. When this
           limit is reached, incoming packets are dropped. An unsigned integer in the range
           04294967294. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[PFIFOHeadDrop] Section Options</title>
     <para>The [PFIFOHeadDrop] section manages the queueing discipline (qdisc) of Packet First In First Out
     Head Drop (pfifo_head_drop).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>As in [PFIFO] section.</para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
      <title>[PFIFOFast] Section Options</title>
      <para>The [PFIFOFast] section manages the queueing discipline (qdisc) of Packet First In First Out Fast
      (pfifo_fast).</para>
 
      <variablelist class='network-directives'>
        <xi:include href="tc.xml" xpointer="qdisc-parent" />
        <xi:include href="tc.xml" xpointer="qdisc-handle" />
      </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[CAKE] Section Options</title>
     <para>The [CAKE] section manages the queueing discipline (qdisc) of Common Applications Kept Enhanced
     (CAKE).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>Bandwidth=</varname></term>
         <listitem>
           <para>Specifies the shaper bandwidth. When suffixed with K, M, or G, the specified size is
           parsed as Kilobits, Megabits, or Gigabits, respectively, to the base of 1000. Defaults to
           unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>AutoRateIngress=</varname></term>
         <listitem>
           <para>Takes a boolean value. Enables automatic capacity estimation based on traffic arriving
           at this qdisc. This is most likely to be useful with cellular links, which tend to change
           quality randomly. If this setting is enabled, the <varname>Bandwidth=</varname> setting is
           used as an initial estimate. Defaults to unset, and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>OverheadBytes=</varname></term>
         <listitem>
           <para>Specifies that bytes to be addeded to the size of each packet. Bytes may be negative.
           Takes an integer in the range -64256. Defaults to unset and kernel's default is used.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MPUBytes=</varname></term>
         <listitem>
           <para>Rounds each packet (including overhead) up to the specified bytes. Takes an integer in
           the range 1256. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CompensationMode=</varname></term>
         <listitem>
           <para>Takes one of <literal>none</literal>, <literal>atm</literal>, or <literal>ptm</literal>.
           Specifies the compensation mode for overhead calculation. When <literal>none</literal>, no
           compensation is taken into account. When <literal>atm</literal>, enables the compensation for
           ATM cell framing, which is normally found on ADSL links. When <literal>ptm</literal>, enables
           the compensation for PTM encoding, which is normally found on VDSL2 links and uses a 64b/65b
           encoding scheme. Defaults to unset and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>UseRawPacketSize=</varname></term>
         <listitem>
           <para>Takes a boolean value. When true, the packet size reported by the Linux kernel will be
           used, instead of the underlying IP packet size. Defaults to unset, and the kernel's default
           is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FlowIsolationMode=</varname></term>
         <listitem>
           <para>CAKE places packets from different flows into different queues, then packets from each
           queue are delivered fairly. This specifies whether the fairness is based on source address,
           destination address, individual flows, or any combination of those. The available values are:
           </para>
 
           <variablelist>
             <varlistentry>
               <term><option>none</option></term>
               <listitem><para>
                 The flow isolation is disabled, and all traffic passes through a single queue.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>src-host</option></term>
               <listitem><para>
                 Flows are defined only by source address. Equivalent to the <literal>srchost</literal>
                 option for <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>dst-host</option></term>
               <listitem><para>
                 Flows are defined only by destination address. Equivalent to the
                 <literal>dsthost</literal> option for <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>hosts</option></term>
               <listitem><para>
                 Flows are defined by source-destination host pairs. Equivalent to the same option for
                 <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>flows</option></term>
               <listitem><para>
                 Flows are defined by the entire 5-tuple of source address, destination address,
                 transport protocol, source port and destination port. Equivalent to the same option for
                 <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>dual-src-host</option></term>
               <listitem><para>
                 Flows are defined by the 5-tuple (see <literal>flows</literal> in the above), and
                 fairness is applied first over source addresses, then over individual flows. Equivalent
                 to the <literal>dual-srchost</literal> option for <command>tc qdisc</command> command.
                 See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>dual-dst-host</option></term>
               <listitem><para>
                 Flows are defined by the 5-tuple (see <literal>flows</literal> in the above), and
                 fairness is applied first over destination addresses, then over individual flows.
                 Equivalent to the <literal>dual-dsthost</literal> option for
                 <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>triple</option></term>
               <listitem><para>
                 Flows are defined by the 5-tuple (see <literal>flows</literal>), and fairness is
                 applied over source and destination addresses, and also over individual flows.
                 Equivalent to the <literal>triple-isolate</literal> option for
                 <command>tc qdisc</command> command. See also
                 <citerefentry project='man-pages'><refentrytitle>tc-cake</refentrytitle><manvolnum>8</manvolnum></citerefentry>.
               </para></listitem>
             </varlistentry>
           </variablelist>
 
           <para>Defaults to unset and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>NAT=</varname></term>
         <listitem>
           <para>Takes a boolean value. When true, CAKE performs a NAT lookup before applying
           flow-isolation rules, to determine the true addresses and port numbers of the packet, to
           improve fairness between hosts inside the NAT. This has no practical effect when
           <varname>FlowIsolationMode=</varname> is <literal>none</literal> or <literal>flows</literal>,
           or if NAT is performed on a different host. Defaults to unset, and the kernel's default is
           used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PriorityQueueingPreset=</varname></term>
         <listitem>
           <para>CAKE divides traffic into <literal>tins</literal>, and each tin has its own independent
           set of flow-isolation queues, bandwidth threshold, and priority. This specifies the preset of
           tin profiles. The available values are:</para>
 
           <variablelist>
             <varlistentry>
               <term><option>besteffort</option></term>
               <listitem><para>
                 Disables priority queueing by placing all traffic in one tin.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>precedence</option></term>
               <listitem><para>
                 Enables priority queueing based on the legacy interpretation of TOS
                 <literal>Precedence</literal> field. Use of this preset on the modern Internet is
                 firmly discouraged.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>diffserv8</option></term>
               <listitem><para>
                 Enables priority queueing based on the Differentiated Service
                 (<literal>DiffServ</literal>) field with eight tins: Background Traffic, High
                 Throughput, Best Effort, Video Streaming, Low Latency Transactions, Interactive Shell,
                 Minimum Latency, and Network Control.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>diffserv4</option></term>
               <listitem><para>
                 Enables priority queueing based on the Differentiated Service
                 (<literal>DiffServ</literal>) field with four tins: Background Traffic, Best Effort,
                 Streaming Media, and Latency Sensitive.
               </para></listitem>
             </varlistentry>
             <varlistentry>
               <term><option>diffserv3</option></term>
               <listitem><para>
                 Enables priority queueing based on the Differentiated Service
                 (<literal>DiffServ</literal>) field with three tins: Background Traffic, Best Effort,
                 and Latency Sensitive.
               </para></listitem>
             </varlistentry>
           </variablelist>
 
           <para>Defaults to unset, and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FirewallMark=</varname></term>
         <listitem>
           <para>Takes an integer in the range 14294967295. When specified, firewall-mark-based
           overriding of CAKE's tin selection is enabled. Defaults to unset, and the kernel's default is
           used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Wash=</varname></term>
         <listitem>
           <para>Takes a boolean value. When true, CAKE clears the DSCP fields, except for ECN bits, of
           any packet passing through CAKE. Defaults to unset, and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>SplitGSO=</varname></term>
         <listitem>
           <para>Takes a boolean value. When true, CAKE will split General Segmentation Offload (GSO)
           super-packets into their on-the-wire components and dequeue them individually. Defaults to
           unset, and the kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[ControlledDelay] Section Options</title>
     <para>The [ControlledDelay] section manages the queueing discipline (qdisc) of
     controlled delay (CoDel).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the queue size in number of packets. When this limit is reached,
           incoming packets are dropped. An unsigned integer in the range 04294967294. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TargetSec=</varname></term>
         <listitem>
           <para>Takes a timespan. Specifies the acceptable minimum standing/persistent queue delay.
           Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IntervalSec=</varname></term>
         <listitem>
           <para>Takes a timespan. This is used to ensure that the measured minimum delay does not
           become too stale. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ECN=</varname></term>
         <listitem>
           <para>Takes a boolean. This can be used to mark packets instead of dropping them. Defaults to
           unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CEThresholdSec=</varname></term>
         <listitem>
           <para>Takes a timespan. This sets a threshold above which all packets are marked with ECN
           Congestion Experienced (CE). Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DeficitRoundRobinScheduler] Section Options</title>
     <para>The [DeficitRoundRobinScheduler] section manages the queueing discipline (qdisc) of Deficit Round
     Robin Scheduler (DRR).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[DeficitRoundRobinSchedulerClass] Section Options</title>
     <para>The [DeficitRoundRobinSchedulerClass] section manages the traffic control class of Deficit Round
     Robin Scheduler (DRR).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="tclass-parent" />
       <xi:include href="tc.xml" xpointer="tclass-classid" />
 
       <varlistentry>
         <term><varname>QuantumBytes=</varname></term>
         <listitem>
           <para>Specifies the amount of bytes a flow is allowed to dequeue before the scheduler moves
           to the next class. When suffixed with K, M, or G, the specified size is parsed as Kilobytes,
           Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to the MTU of the
           interface.</para>
         </listitem>
       </varlistentry>
 
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[EnhancedTransmissionSelection] Section Options</title>
     <para>The [EnhancedTransmissionSelection] section manages the queueing discipline (qdisc) of Enhanced
     Transmission Selection (ETS).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>Bands=</varname></term>
         <listitem>
           <para>Specifies the number of bands. An unsigned integer in the range 116. This value has to be at
           least large enough to cover the strict bands specified through the <varname>StrictBands=</varname>
           and bandwidth-sharing bands specified in <varname>QuantumBytes=</varname>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>StrictBands=</varname></term>
         <listitem>
           <para>Specifies the number of bands that should be created in strict mode. An unsigned integer in
           the range 116.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>QuantumBytes=</varname></term>
         <listitem>
           <para>Specifies the white-space separated list of quantum used in band-sharing bands. When
           suffixed with K, M, or G, the specified size is parsed as Kilobytes, Megabytes, or Gigabytes,
           respectively, to the base of 1024. This setting can be specified multiple times. If an empty
           string is assigned, then the all previous assignments are cleared.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>PriorityMap=</varname></term>
         <listitem>
           <para>The priority map maps the priority of a packet to a band. The argument is a whitespace
           separated list of numbers. The first number indicates which band the packets with priority 0 should
           be put to, the second is for priority 1, and so on. There can be up to 16 numbers in the list. If
           there are fewer, the default band that traffic with one of the unmentioned priorities goes to is
           the last one. Each band number must be in the range 0255. This setting can be specified multiple
           times. If an empty string is assigned, then the all previous assignments are cleared.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[GenericRandomEarlyDetection] Section Options</title>
     <para>The [GenericRandomEarlyDetection] section manages the queueing discipline (qdisc) of Generic Random
     Early Detection (GRED).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>VirtualQueues=</varname></term>
         <listitem>
           <para>Specifies the number of virtual queues. Takes an integer in the range 116. Defaults to unset
           and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DefaultVirtualQueue=</varname></term>
         <listitem>
           <para>Specifies the number of default virtual queue. This must be less than <varname>VirtualQueue=</varname>.
           Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>GenericRIO=</varname></term>
         <listitem>
           <para>Takes a boolean. It turns on the RIO-like buffering scheme. Defaults to
           unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[FairQueueingControlledDelay] Section Options</title>
     <para>The [FairQueueingControlledDelay] section manages the queueing discipline (qdisc) of fair queuing
     controlled delay (FQ-CoDel).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the real queue size. When this limit is reached, incoming packets are
           dropped. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MemoryLimitBytes=</varname></term>
         <listitem>
           <para>Specifies the limit on the total number of bytes that can be queued in this FQ-CoDel instance.
           When suffixed with K, M, or G, the specified size is parsed as Kilobytes, Megabytes, or Gigabytes,
           respectively, to the base of 1024. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Flows=</varname></term>
         <listitem>
           <para>Specifies the number of flows into which the incoming packets are classified.
           Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>TargetSec=</varname></term>
         <listitem>
           <para>Takes a timespan. Specifies the acceptable minimum standing/persistent queue delay.
           Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>IntervalSec=</varname></term>
         <listitem>
           <para>Takes a timespan. This is used to ensure that the measured minimum delay does not
           become too stale. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>QuantumBytes=</varname></term>
         <listitem>
           <para>Specifies the number of bytes used as the "deficit" in the fair queuing algorithm timespan.
           When suffixed with K, M, or G, the specified size is parsed as Kilobytes, Megabytes, or Gigabytes,
           respectively, to the base of 1024. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ECN=</varname></term>
         <listitem>
           <para>Takes a boolean. This can be used to mark packets instead of dropping them. Defaults to
           unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CEThresholdSec=</varname></term>
         <listitem>
           <para>Takes a timespan. This sets a threshold above which all packets are marked with ECN
           Congestion Experienced (CE). Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[FairQueueing] Section Options</title>
     <para>The [FairQueueing] section manages the queueing discipline (qdisc) of fair queue traffic policing
     (FQ).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the real queue size. When this limit is reached, incoming packets are
           dropped. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>FlowLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the maximum number of packets queued per flow. Defaults to
           unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>QuantumBytes=</varname></term>
         <listitem>
           <para>Specifies the credit per dequeue RR round, i.e. the amount of bytes a flow is allowed
           to dequeue at once. When suffixed with K, M, or G, the specified size is parsed as Kilobytes,
           Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to unset and kernel's
           default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>InitialQuantumBytes=</varname></term>
         <listitem>
           <para>Specifies the initial sending rate credit, i.e. the amount of bytes a new flow is
           allowed to dequeue initially. When suffixed with K, M, or G, the specified size is parsed as
           Kilobytes, Megabytes, or Gigabytes, respectively, to the base of 1024. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MaximumRate=</varname></term>
         <listitem>
           <para>Specifies the maximum sending rate of a flow. When suffixed with K, M, or G, the
           specified size is parsed as Kilobits, Megabits, or Gigabits, respectively, to the base of
           1000. Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Buckets=</varname></term>
         <listitem>
           <para>Specifies the size of the hash table used for flow lookups. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>OrphanMask=</varname></term>
         <listitem>
           <para>Takes an unsigned integer. For packets not owned by a socket, fq is able to mask a part
           of hash and reduce number of buckets associated with the traffic. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Pacing=</varname></term>
         <listitem>
           <para>Takes a boolean, and enables or disables flow pacing. Defaults to unset and kernel's
           default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CEThresholdSec=</varname></term>
         <listitem>
           <para>Takes a timespan. This sets a threshold above which all packets are marked with ECN
           Congestion Experienced (CE). Defaults to unset and kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[TrivialLinkEqualizer] Section Options</title>
     <para>The [TrivialLinkEqualizer] section manages the queueing discipline (qdisc) of trivial link
     equalizer (teql).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>Id=</varname></term>
         <listitem>
           <para>Specifies the interface ID <literal>N</literal> of teql. Defaults to <literal>0</literal>.
           Note that when teql is used, currently, the module <constant>sch_teql</constant> with
           <constant>max_equalizers=N+1</constant> option must be loaded before
           <command>systemd-networkd</command> is started.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[HierarchyTokenBucket] Section Options</title>
     <para>The [HierarchyTokenBucket] section manages the queueing discipline (qdisc) of hierarchy token
     bucket (htb).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>DefaultClass=</varname></term>
         <listitem>
           <para>Takes the minor id in hexadecimal of the default class. Unclassified traffic gets sent
           to the class. Defaults to unset.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>RateToQuantum=</varname></term>
         <listitem>
           <para>Takes an unsigned integer. The DRR quantums are calculated by dividing the value
           configured in <varname>Rate=</varname> by <varname>RateToQuantum=</varname>.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[HierarchyTokenBucketClass] Section Options</title>
     <para>The [HierarchyTokenBucketClass] section manages the traffic control class of hierarchy token bucket
     (htb).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="tclass-parent" />
       <xi:include href="tc.xml" xpointer="tclass-classid" />
 
       <varlistentry>
         <term><varname>Priority=</varname></term>
         <listitem>
           <para>Specifies the priority of the class. In the round-robin process, classes with the lowest
           priority field are tried for packets first.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>QuantumBytes=</varname></term>
         <listitem>
           <para>Specifies how many bytes to serve from leaf at once. When suffixed with K, M, or G, the
           specified size is parsed as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of
           1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MTUBytes=</varname></term>
         <listitem>
           <para>Specifies the maximum packet size we create. When suffixed with K, M, or G, the specified
           size is parsed as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>OverheadBytes=</varname></term>
         <listitem>
           <para>Takes an unsigned integer which specifies per-packet size overhead used in rate
           computations. When suffixed with K, M, or G, the specified size is parsed as Kilobytes,
           Megabytes, or Gigabytes, respectively, to the base of 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Rate=</varname></term>
         <listitem>
           <para>Specifies the maximum rate this class and all its children are guaranteed. When suffixed
           with K, M, or G, the specified size is parsed as Kilobits, Megabits, or Gigabits, respectively,
           to the base of 1000. This setting is mandatory.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CeilRate=</varname></term>
         <listitem>
           <para>Specifies the maximum rate at which a class can send, if its parent has bandwidth to spare.
           When suffixed with K, M, or G, the specified size is parsed as Kilobits, Megabits, or Gigabits,
           respectively, to the base of 1000. When unset, the value specified with <varname>Rate=</varname>
           is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BufferBytes=</varname></term>
         <listitem>
           <para>Specifies the maximum bytes burst which can be accumulated during idle period. When suffixed
           with K, M, or G, the specified size is parsed as Kilobytes, Megabytes, or Gigabytes, respectively,
           to the base of 1024.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>CeilBufferBytes=</varname></term>
         <listitem>
           <para>Specifies the maximum bytes burst for ceil which can be accumulated during idle period.
           When suffixed with K, M, or G, the specified size is parsed as Kilobytes, Megabytes, or Gigabytes,
           respectively, to the base of 1024.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[HeavyHitterFilter] Section Options</title>
     <para>The [HeavyHitterFilter] section manages the queueing discipline (qdisc) of Heavy Hitter Filter
     (hhf).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
 
       <varlistentry>
         <term><varname>PacketLimit=</varname></term>
         <listitem>
           <para>Specifies the hard limit on the queue size in number of packets. When this limit is reached,
           incoming packets are dropped. An unsigned integer in the range 04294967294. Defaults to unset and
           kernel's default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[QuickFairQueueing] Section Options</title>
     <para>The [QuickFairQueueing] section manages the queueing discipline (qdisc) of Quick Fair Queueing
     (QFQ).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="qdisc-parent" />
       <xi:include href="tc.xml" xpointer="qdisc-handle" />
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[QuickFairQueueingClass] Section Options</title>
     <para>The [QuickFairQueueingClass] section manages the traffic control class of Quick Fair Queueing
     (qfq).</para>
 
     <variablelist class='network-directives'>
       <xi:include href="tc.xml" xpointer="tclass-parent" />
       <xi:include href="tc.xml" xpointer="tclass-classid" />
 
       <varlistentry>
         <term><varname>Weight=</varname></term>
         <listitem>
           <para>Specifies the weight of the class. Takes an integer in the range 11023. Defaults to
           unset in which case the kernel default is used.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MaxPacketBytes=</varname></term>
         <listitem>
           <para>Specifies the maximum packet size in bytes for the class. When suffixed with K, M, or G, the
           specified size is parsed as Kilobytes, Megabytes, or Gigabytes, respectively, to the base of
           1024. When unset, the kernel default is used.</para>
         </listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>[BridgeVLAN] Section Options</title>
       <para>The [BridgeVLAN] section manages the VLAN ID configuration of a bridge port and accepts the
       following keys. Specify several [BridgeVLAN] sections to configure several VLAN entries. The
       <varname>VLANFiltering=</varname> option has to be enabled, see the [Bridge] section in
       <citerefentry><refentrytitle>systemd.netdev</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
 
       <variablelist class='network-directives'>
         <varlistentry>
           <term><varname>VLAN=</varname></term>
           <listitem>
             <para>The VLAN ID allowed on the port. This can be either a single ID or a range M-N. Takes
             an integer in the range 14094.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>EgressUntagged=</varname></term>
           <listitem>
             <para>The VLAN ID specified here will be used to untag frames on egress. Configuring
             <varname>EgressUntagged=</varname> implicates the use of <varname>VLAN=</varname> above and will enable the
             VLAN ID for ingress as well. This can be either a single ID or a range M-N.</para>
           </listitem>
         </varlistentry>
         <varlistentry>
           <term><varname>PVID=</varname></term>
           <listitem>
             <para>The Port VLAN ID specified here is assigned to all untagged frames at ingress.
             <varname>PVID=</varname> can be used only once. Configuring <varname>PVID=</varname> implicates the use of
             <varname>VLAN=</varname> above and will enable the VLAN ID for ingress as well.</para>
           </listitem>
         </varlistentry>
       </variablelist>
   </refsect1>
 
   <refsect1>
     <title>Examples</title>
     <example>
       <title>Static network configuration</title>
 
       <programlisting># /etc/systemd/network/50-static.network
 [Match]
diff --git a/man/systemd.resource-control.xml b/man/systemd.resource-control.xml
index 23b2d0f390..1397b886c5 100644
--- a/man/systemd.resource-control.xml
+++ b/man/systemd.resource-control.xml
@@ -967,405 +967,376 @@ DeviceAllow=block-loop
 DeviceAllow=/dev/loop-control
 </programlisting></para>
 
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DevicePolicy=auto|closed|strict</varname></term>
 
         <listitem>
           <para>
             Control the policy for allowing device access:
           </para>
           <variablelist>
             <varlistentry>
               <term><option>strict</option></term>
               <listitem>
                 <para>means to only allow types of access that are
                 explicitly specified.</para>
               </listitem>
             </varlistentry>
 
             <varlistentry>
               <term><option>closed</option></term>
               <listitem>
                 <para>in addition, allows access to standard pseudo
                 devices including
                 <filename>/dev/null</filename>,
                 <filename>/dev/zero</filename>,
                 <filename>/dev/full</filename>,
                 <filename>/dev/random</filename>, and
                 <filename>/dev/urandom</filename>.
                 </para>
               </listitem>
             </varlistentry>
 
             <varlistentry>
               <term><option>auto</option></term>
               <listitem>
                 <para>
                   in addition, allows access to all devices if no
                   explicit <varname>DeviceAllow=</varname> is present.
                   This is the default.
                 </para>
               </listitem>
             </varlistentry>
           </variablelist>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Slice=</varname></term>
 
         <listitem>
           <para>The name of the slice unit to place the unit
           in. Defaults to <filename>system.slice</filename> for all
           non-instantiated units of all unit types (except for slice
           units themselves see below). Instance units are by default
           placed in a subslice of <filename>system.slice</filename>
           that is named after the template name.</para>
 
           <para>This option may be used to arrange systemd units in a
           hierarchy of slices each of which might have resource
           settings applied.</para>
 
           <para>For units of type slice, the only accepted value for
           this setting is the parent slice. Since the name of a slice
           unit implies the parent slice, it is hence redundant to ever
           set this parameter directly for slice units.</para>
 
           <para>Special care should be taken when relying on the default slice assignment in templated service units
           that have <varname>DefaultDependencies=no</varname> set, see
           <citerefentry><refentrytitle>systemd.service</refentrytitle><manvolnum>5</manvolnum></citerefentry>, section
           "Default Dependencies" for details.</para>
 
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>Delegate=</varname></term>
 
         <listitem>
           <para>Turns on delegation of further resource control partitioning to processes of the unit. Units where this
           is enabled may create and manage their own private subhierarchy of control groups below the control group of
           the unit itself. For unprivileged services (i.e. those using the <varname>User=</varname> setting) the unit's
           control group will be made accessible to the relevant user. When enabled the service manager will refrain
           from manipulating control groups or moving processes below the unit's control group, so that a clear concept
           of ownership is established: the control group tree above the unit's control group (i.e. towards the root
           control group) is owned and managed by the service manager of the host, while the control group tree below
           the unit's control group is owned and managed by the unit itself. Takes either a boolean argument or a list
           of control group controller names. If true, delegation is turned on, and all supported controllers are
           enabled for the unit, making them available to the unit's processes for management. If false, delegation is
           turned off entirely (and no additional controllers are enabled). If set to a list of controllers, delegation
           is turned on, and the specified controllers are enabled for the unit. Note that additional controllers than
           the ones specified might be made available as well, depending on configuration of the containing slice unit
           or other units contained in it. Note that assigning the empty string will enable delegation, but reset the
           list of controllers, all assignments prior to this will have no effect.  Defaults to false.</para>
 
           <para>Note that controller delegation to less privileged code is only safe on the unified control group
           hierarchy. Accordingly, access to the specified controllers will not be granted to unprivileged services on
           the legacy hierarchy, even when requested.</para>
 
           <xi:include href="supported-controllers.xml"  xpointer="controllers-text" />
 
           <para>Not all of these controllers are available on all kernels however, and some are
           specific to the unified hierarchy while others are specific to the legacy hierarchy. Also note that the
           kernel might support further controllers, which aren't covered here yet as delegation is either not supported
           at all for them or not defined cleanly.</para>
 
           <para>For further details on the delegation model consult <ulink
           url="https://systemd.io/CGROUP_DELEGATION">Control Group APIs and Delegation</ulink>.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>DisableControllers=</varname></term>
 
         <listitem>
           <para>Disables controllers from being enabled for a unit's children. If a controller listed is already in use
           in its subtree, the controller will be removed from the subtree. This can be used to avoid child units being
           able to implicitly or explicitly enable a controller. Defaults to not disabling any controllers.</para>
 
           <para>It may not be possible to successfully disable a controller if the unit or any child of the unit in
           question delegates controllers to its children, as any delegated subtree of the cgroup hierarchy is unmanaged
           by systemd.</para>
 
           <para>Multiple controllers may be specified, separated by spaces. You may also pass
           <varname>DisableControllers=</varname> multiple times, in which case each new instance adds another controller
           to disable. Passing <varname>DisableControllers=</varname> by itself with no controller name present resets
           the disabled controller list.</para>
 
           <xi:include href="supported-controllers.xml"  xpointer="controllers-text" />
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ManagedOOMSwap=auto|kill</varname></term>
         <term><varname>ManagedOOMMemoryPressure=auto|kill</varname></term>
 
         <listitem>
           <para>Specifies how
           <citerefentry><refentrytitle>systemd-oomd.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
           will act on this unit's cgroups. Defaults to <option>auto</option>.</para>
 
           <para>When set to <option>kill</option>, the unit becomes a candidate for monitoring by
           <command>systemd-oomd</command>. If the cgroup passes the limits set by
           <citerefentry><refentrytitle>oomd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> or
           the unit configuration, <command>systemd-oomd</command> will select a descendant cgroup and send
           <constant>SIGKILL</constant> to all of the processes under it. You can find more details on
           candidates and kill behavior at
           <citerefentry><refentrytitle>systemd-oomd.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
           and
           <citerefentry><refentrytitle>oomd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
 
           <para>Setting either of these properties to <option>kill</option> will also result in
           <varname>After=</varname> and <varname>Wants=</varname> dependencies on
           <filename>systemd-oomd.service</filename> unless <varname>DefaultDependencies=no</varname>.</para>
 
           <para>When set to <option>auto</option>, <command>systemd-oomd</command> will not actively use this
           cgroup's data for monitoring and detection. However, if an ancestor cgroup has one of these
           properties set to <option>kill</option>, a unit with <option>auto</option> can still be a candidate
           for <command>systemd-oomd</command> to terminate.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ManagedOOMMemoryPressureLimit=</varname></term>
 
         <listitem>
           <para>Overrides the default memory pressure limit set by
           <citerefentry><refentrytitle>oomd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> for
           this unit (cgroup). Takes a percentage value between 0% and 100%, inclusive. This property is
           ignored unless <varname>ManagedOOMMemoryPressure=</varname><option>kill</option>. Defaults to 0%,
           which means to use the default set by
           <citerefentry><refentrytitle>oomd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>ManagedOOMPreference=none|avoid|omit</varname></term>
 
         <listitem>
           <para>Allows deprioritizing or omitting this unit's cgroup as a candidate when
           <command>systemd-oomd</command> needs to act. Requires support for extended attributes (see
           <citerefentry project='man-pages'><refentrytitle>xattr</refentrytitle><manvolnum>7</manvolnum></citerefentry>)
           in order to use <option>avoid</option> or <option>omit</option>. Additionally,
           <command>systemd-oomd</command> will ignore these extended attributes if the unit's cgroup is not
           owned by the root user.</para>
 
           <para>If this property is set to <option>avoid</option>, the service manager will convey this to
           <command>systemd-oomd</command>, which will only select this cgroup if there are no other viable
           candidates.</para>
 
           <para>If this property is set to <option>omit</option>, the service manager will convey this to
           <command>systemd-oomd</command>, which will ignore this cgroup as a candidate and will not perform
           any actions on it.</para>
 
           <para>It is recommended to use <option>avoid</option> and <option>omit</option> sparingly, as it
           can adversely affect <command>systemd-oomd</command>'s kill behavior. Also note that these extended
           attributes are not applied recursively to cgroups under this unit's cgroup.</para>
 
           <para>Defaults to <option>none</option> which means <command>systemd-oomd</command> will rank this
           unit's cgroup as defined in
           <citerefentry><refentrytitle>systemd-oomd.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>
           and <citerefentry><refentrytitle>oomd.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
           </para>
         </listitem>
       </varlistentry>
-      <varlistentry>
-        <term><varname>ControlGroupNFTSet=</varname><replaceable>family</replaceable>:<replaceable>table</replaceable>:<replaceable>set</replaceable></term>
-        <listitem>
-          <para>This setting provides a method for integrating dynamic cgroup IDs into firewall rules with
-          NFT sets. This option expects a whitespace separated list of NFT set definitions. Each definition
-          consists of a colon-separated tuple of NFT address family (one of <literal>arp</literal>,
-          <literal>bridge</literal>, <literal>inet</literal>, <literal>ip</literal>, <literal>ip6</literal>,
-          or <literal>netdev</literal>), table name and set name. The names of tables and sets must conform
-          to lexical restrictions of NFT table names. When a control group for a unit is realized, the cgroup
-          ID will be appended to the NFT sets and it will be be removed when the control group is
-          removed. Failures to manage the sets will be ignored.</para>
-
-          <para>Example:
-          <programlisting>[Unit]
-ControlGroupNFTSet=inet:filter:my_service
-</programlisting>
-          Corresponding NFT rules:
-          <programlisting>table inet filter {
-        set my_service {
-                type cgroupsv2
-        }
-        chain x {
-                socket cgroupv2 level 2 @my_service accept
-                drop
-        }
-}</programlisting>
-          </para>
-        </listitem>
-      </varlistentry>
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>Deprecated Options</title>
 
     <para>The following options are deprecated. Use the indicated superseding options instead:</para>
 
     <variablelist class='unit-directives'>
 
       <varlistentry>
         <term><varname>CPUShares=<replaceable>weight</replaceable></varname></term>
         <term><varname>StartupCPUShares=<replaceable>weight</replaceable></varname></term>
 
         <listitem>
           <para>Assign the specified CPU time share weight to the processes executed. These options take an integer
           value and control the <literal>cpu.shares</literal> control group attribute. The allowed range is 2 to
           262144. Defaults to 1024. For details about this control group attribute, see <ulink
           url="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html">CFS Scheduler</ulink>.
           The available CPU time is split up among all units within one slice relative to their CPU time share
           weight.</para>
 
           <para>While <varname>StartupCPUShares=</varname> applies to the startup and shutdown phases of the system,
           <varname>CPUShares=</varname> applies to normal runtime of the system, and if the former is not set also to
           the startup and shutdown phases. Using <varname>StartupCPUShares=</varname> allows prioritizing specific services at
           boot-up and shutdown differently than during normal runtime.</para>
 
           <para>Implies <literal>CPUAccounting=yes</literal>.</para>
 
           <para>These settings are deprecated. Use <varname>CPUWeight=</varname> and
           <varname>StartupCPUWeight=</varname> instead.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>MemoryLimit=<replaceable>bytes</replaceable></varname></term>
 
         <listitem>
           <para>Specify the limit on maximum memory usage of the executed processes. The limit specifies how much
           process and kernel memory can be used by tasks in this unit. Takes a memory size in bytes. If the value is
           suffixed with K, M, G or T, the specified memory size is parsed as Kilobytes, Megabytes, Gigabytes, or
           Terabytes (with the base 1024), respectively. Alternatively, a percentage value may be specified, which is
           taken relative to the installed physical memory on the system. If assigned the special value
           <literal>infinity</literal>, no memory limit is applied. This controls the
           <literal>memory.limit_in_bytes</literal> control group attribute. For details about this control group
           attribute, see <ulink
           url="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memory.html">Memory Resource Controller</ulink>.</para>
 
           <para>Implies <literal>MemoryAccounting=yes</literal>.</para>
 
           <para>This setting is deprecated. Use <varname>MemoryMax=</varname> instead.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BlockIOAccounting=</varname></term>
 
         <listitem>
           <para>Turn on Block I/O accounting for this unit, if the legacy control group hierarchy is used on the
           system. Takes a boolean argument. Note that turning on block I/O accounting for one unit will also implicitly
           turn it on for all units contained in the same slice and all for its parent slices and the units contained
           therein. The system default for this setting may be controlled with
           <varname>DefaultBlockIOAccounting=</varname> in
           <citerefentry><refentrytitle>systemd-system.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
 
           <para>This setting is deprecated. Use <varname>IOAccounting=</varname> instead.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BlockIOWeight=<replaceable>weight</replaceable></varname></term>
         <term><varname>StartupBlockIOWeight=<replaceable>weight</replaceable></varname></term>
 
         <listitem><para>Set the default overall block I/O weight for the executed processes, if the legacy control
         group hierarchy is used on the system. Takes a single weight value (between 10 and 1000) to set the default
         block I/O weight. This controls the <literal>blkio.weight</literal> control group attribute, which defaults to
         500. For details about this control group attribute, see <ulink
         url="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/blkio-controller.html">Block IO Controller</ulink>.
         The available I/O bandwidth is split up among all units within one slice relative to their block I/O
         weight.</para>
 
         <para>While <varname>StartupBlockIOWeight=</varname> only
         applies to the startup and shutdown phases of the system,
         <varname>BlockIOWeight=</varname> applies to the later runtime
         of the system, and if the former is not set also to the
         startup and shutdown phases. This allows prioritizing specific services at
         boot-up and shutdown differently than during runtime.</para>
 
         <para>Implies
         <literal>BlockIOAccounting=yes</literal>.</para>
 
         <para>These settings are deprecated. Use <varname>IOWeight=</varname> and <varname>StartupIOWeight=</varname>
         instead.</para>
 
       </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BlockIODeviceWeight=<replaceable>device</replaceable> <replaceable>weight</replaceable></varname></term>
 
         <listitem>
           <para>Set the per-device overall block I/O weight for the executed processes, if the legacy control group
           hierarchy is used on the system. Takes a space-separated pair of a file path and a weight value to specify
           the device specific weight value, between 10 and 1000. (Example: "/dev/sda 500"). The file path may be
           specified as path to a block device node or as any other file, in which case the backing block device of the
           file system of the file is determined. This controls the <literal>blkio.weight_device</literal> control group
           attribute, which defaults to 1000. Use this option multiple times to set weights for multiple devices. For
           details about this control group attribute, see <ulink
           url="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/blkio-controller.html">Block IO Controller</ulink>.</para>
 
           <para>Implies
           <literal>BlockIOAccounting=yes</literal>.</para>
 
           <para>This setting is deprecated. Use <varname>IODeviceWeight=</varname> instead.</para>
         </listitem>
       </varlistentry>
 
       <varlistentry>
         <term><varname>BlockIOReadBandwidth=<replaceable>device</replaceable> <replaceable>bytes</replaceable></varname></term>
         <term><varname>BlockIOWriteBandwidth=<replaceable>device</replaceable> <replaceable>bytes</replaceable></varname></term>
 
         <listitem>
           <para>Set the per-device overall block I/O bandwidth limit for the executed processes, if the legacy control
           group hierarchy is used on the system. Takes a space-separated pair of a file path and a bandwidth value (in
           bytes per second) to specify the device specific bandwidth. The file path may be a path to a block device
           node, or as any other file in which case the backing block device of the file system of the file is used. If
           the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is parsed as Kilobytes, Megabytes,
           Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
           "/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the
           <literal>blkio.throttle.read_bps_device</literal> and <literal>blkio.throttle.write_bps_device</literal>
           control group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For
           details about these control group attributes, see <ulink
           url="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/blkio-controller.html">Block IO Controller</ulink>.
           </para>
 
           <para>Implies
           <literal>BlockIOAccounting=yes</literal>.</para>
 
           <para>These settings are deprecated. Use <varname>IOReadBandwidthMax=</varname> and
           <varname>IOWriteBandwidthMax=</varname> instead.</para>
         </listitem>
       </varlistentry>
 
     </variablelist>
   </refsect1>
 
   <refsect1>
     <title>See Also</title>
     <para>
       <citerefentry><refentrytitle>systemd</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd-system.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.service</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.slice</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.scope</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.swap</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.exec</refentrytitle><manvolnum>5</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.directives</refentrytitle><manvolnum>7</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd.special</refentrytitle><manvolnum>7</manvolnum></citerefentry>,
       <citerefentry><refentrytitle>systemd-oomd.service</refentrytitle><manvolnum>8</manvolnum></citerefentry>,
       The documentation for control groups and specific controllers in the Linux kernel:
       <ulink url="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Control Groups v2</ulink>.
     </para>
   </refsect1>
 </refentry>
diff --git a/src/basic/parse-util.c b/src/basic/parse-util.c
index 0c7c562d17..35fbb5ec6a 100644
--- a/src/basic/parse-util.c
+++ b/src/basic/parse-util.c
@@ -728,60 +728,25 @@ int store_loadavg_fixed_point(unsigned long i, unsigned long f, loadavg_t *ret)
 int parse_loadavg_fixed_point(const char *s, loadavg_t *ret) {
         const char *d, *f_str, *i_str;
         unsigned long i, f;
         int r;
 
         assert(s);
         assert(ret);
 
         d = strchr(s, '.');
         if (!d)
                 return -EINVAL;
 
         i_str = strndupa_safe(s, d - s);
         f_str = d + 1;
 
         r = safe_atolu_full(i_str, 10, &i);
         if (r < 0)
                 return r;
 
         r = safe_atolu_full(f_str, 10, &f);
         if (r < 0)
                 return r;
 
         return store_loadavg_fixed_point(i, f, ret);
 }
-
-static bool nft_first_char_bad(const char c) {
-        if ((c >= 'a' && c <= 'z') ||
-            (c >= 'A' && c <= 'Z'))
-                return false;
-        return true;
-}
-
-static bool nft_next_char_bad(const char c) {
-        if ((c >= 'a' && c <= 'z') ||
-            (c >= 'A' && c <= 'Z') ||
-            (c >= '0' && c <= '9') ||
-            c == '/' || c == '\\' || c == '_' || c == '.')
-                return false;
-        return true;
-}
-
-/* Limitations are described in https://www.netfilter.org/projects/nftables/manpage.html and
- * https://bugzilla.netfilter.org/show_bug.cgi?id=1175 */
-bool nft_identifier_bad(const char *id) {
-        assert(id);
-
-        size_t len;
-        len = strlen(id);
-        if (len == 0 || len > 31)
-                return true;
-
-        if (nft_first_char_bad(id[0]))
-                return true;
-
-        for (size_t i = 1; i < len; i++)
-                if (nft_next_char_bad(id[i]))
-                        return true;
-        return false;
-}
diff --git a/src/basic/parse-util.h b/src/basic/parse-util.h
index 8530ad1c49..f2222dcffb 100644
--- a/src/basic/parse-util.h
+++ b/src/basic/parse-util.h
@@ -146,5 +146,3 @@ int parse_oom_score_adjust(const char *s, int *ret);
  * to a loadavg_t. */
 int store_loadavg_fixed_point(unsigned long i, unsigned long f, loadavg_t *ret);
 int parse_loadavg_fixed_point(const char *s, loadavg_t *ret);
-
-bool nft_identifier_bad(const char *id);
diff --git a/src/core/cgroup.c b/src/core/cgroup.c
index a3fb44fcb8..25707fce64 100644
--- a/src/core/cgroup.c
+++ b/src/core/cgroup.c
@@ -1,52 +1,51 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include <fcntl.h>
 
 #include "sd-messages.h"
 
 #include "af-list.h"
 #include "alloc-util.h"
 #include "blockdev-util.h"
 #include "bpf-devices.h"
 #include "bpf-firewall.h"
 #include "bpf-foreign.h"
 #include "bpf-socket-bind.h"
 #include "btrfs-util.h"
 #include "bus-error.h"
 #include "cgroup-setup.h"
 #include "cgroup-util.h"
 #include "cgroup.h"
 #include "devnum-util.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "firewall-util.h"
 #include "in-addr-prefix-util.h"
 #include "inotify-util.h"
 #include "io-util.h"
 #include "ip-protocol-list.h"
 #include "limits-util.h"
 #include "nulstr-util.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "percent-util.h"
 #include "process-util.h"
 #include "procfs-util.h"
 #include "restrict-ifaces.h"
 #include "special.h"
 #include "stdio-util.h"
 #include "string-table.h"
 #include "string-util.h"
 #include "virt.h"
 
 #if BPF_FRAMEWORK
 #include "bpf-dlopen.h"
 #include "bpf-link.h"
 #include "bpf/restrict_fs/restrict-fs-skel.h"
 #endif
 
 #define CGROUP_CPU_QUOTA_DEFAULT_PERIOD_USEC ((usec_t) 100 * USEC_PER_MSEC)
 
 /* Returns the log level to use when cgroup attribute writes fail. When an attribute is missing or we have access
  * problems we downgrade to LOG_DEBUG. This is supposed to be nice to container managers and kernels which want to mask
  * out specific attributes from us. */
 #define LOG_LEVEL_CGROUP_WRITE(r) (IN_SET(abs(r), ENOENT, EROFS, EACCES, EPERM) ? LOG_DEBUG : LOG_WARNING)
@@ -244,44 +243,42 @@ void cgroup_context_remove_socket_bind(CGroupSocketBindItem **head) {
 void cgroup_context_done(CGroupContext *c) {
         assert(c);
 
         while (c->io_device_weights)
                 cgroup_context_free_io_device_weight(c, c->io_device_weights);
 
         while (c->io_device_latencies)
                 cgroup_context_free_io_device_latency(c, c->io_device_latencies);
 
         while (c->io_device_limits)
                 cgroup_context_free_io_device_limit(c, c->io_device_limits);
 
         while (c->blockio_device_weights)
                 cgroup_context_free_blockio_device_weight(c, c->blockio_device_weights);
 
         while (c->blockio_device_bandwidths)
                 cgroup_context_free_blockio_device_bandwidth(c, c->blockio_device_bandwidths);
 
         while (c->device_allow)
                 cgroup_context_free_device_allow(c, c->device_allow);
 
         cgroup_context_remove_socket_bind(&c->socket_bind_allow);
         cgroup_context_remove_socket_bind(&c->socket_bind_deny);
 
         c->ip_address_allow = set_free(c->ip_address_allow);
         c->ip_address_deny = set_free(c->ip_address_deny);
 
         c->ip_filters_ingress = strv_free(c->ip_filters_ingress);
         c->ip_filters_egress = strv_free(c->ip_filters_egress);
 
         while (c->bpf_foreign_programs)
                 cgroup_context_remove_bpf_foreign_program(c, c->bpf_foreign_programs);
 
         c->restrict_network_interfaces = set_free(c->restrict_network_interfaces);
 
         cpu_set_reset(&c->cpuset_cpus);
         cpu_set_reset(&c->startup_cpuset_cpus);
         cpu_set_reset(&c->cpuset_mems);
         cpu_set_reset(&c->startup_cpuset_mems);
-
-        c->nft_set_context = nft_set_context_free_many(c->nft_set_context, &c->n_nft_set_contexts);
 }
 
 static int unit_get_kernel_memory_limit(Unit *u, const char *file, uint64_t *ret) {
@@ -418,205 +415,200 @@ static char *format_cgroup_memory_limit_comparison(char *buf, size_t l, Unit *u,
 void cgroup_context_dump(Unit *u, FILE* f, const char *prefix) {
         _cleanup_free_ char *disable_controllers_str = NULL, *cpuset_cpus = NULL, *cpuset_mems = NULL, *startup_cpuset_cpus = NULL, *startup_cpuset_mems = NULL;
         CGroupContext *c;
         struct in_addr_prefix *iaai;
 
         char cda[FORMAT_CGROUP_DIFF_MAX];
         char cdb[FORMAT_CGROUP_DIFF_MAX];
         char cdc[FORMAT_CGROUP_DIFF_MAX];
         char cdd[FORMAT_CGROUP_DIFF_MAX];
         char cde[FORMAT_CGROUP_DIFF_MAX];
 
         assert(u);
         assert(f);
 
         assert_se(c = unit_get_cgroup_context(u));
 
         prefix = strempty(prefix);
 
         (void) cg_mask_to_string(c->disable_controllers, &disable_controllers_str);
 
         cpuset_cpus = cpu_set_to_range_string(&c->cpuset_cpus);
         startup_cpuset_cpus = cpu_set_to_range_string(&c->startup_cpuset_cpus);
         cpuset_mems = cpu_set_to_range_string(&c->cpuset_mems);
         startup_cpuset_mems = cpu_set_to_range_string(&c->startup_cpuset_mems);
 
         fprintf(f,
                 "%sCPUAccounting: %s\n"
                 "%sIOAccounting: %s\n"
                 "%sBlockIOAccounting: %s\n"
                 "%sMemoryAccounting: %s\n"
                 "%sTasksAccounting: %s\n"
                 "%sIPAccounting: %s\n"
                 "%sCPUWeight: %" PRIu64 "\n"
                 "%sStartupCPUWeight: %" PRIu64 "\n"
                 "%sCPUShares: %" PRIu64 "\n"
                 "%sStartupCPUShares: %" PRIu64 "\n"
                 "%sCPUQuotaPerSecSec: %s\n"
                 "%sCPUQuotaPeriodSec: %s\n"
                 "%sAllowedCPUs: %s\n"
                 "%sStartupAllowedCPUs: %s\n"
                 "%sAllowedMemoryNodes: %s\n"
                 "%sStartupAllowedMemoryNodes: %s\n"
                 "%sIOWeight: %" PRIu64 "\n"
                 "%sStartupIOWeight: %" PRIu64 "\n"
                 "%sBlockIOWeight: %" PRIu64 "\n"
                 "%sStartupBlockIOWeight: %" PRIu64 "\n"
                 "%sDefaultMemoryMin: %" PRIu64 "\n"
                 "%sDefaultMemoryLow: %" PRIu64 "\n"
                 "%sMemoryMin: %" PRIu64 "%s\n"
                 "%sMemoryLow: %" PRIu64 "%s\n"
                 "%sMemoryHigh: %" PRIu64 "%s\n"
                 "%sMemoryMax: %" PRIu64 "%s\n"
                 "%sMemorySwapMax: %" PRIu64 "%s\n"
                 "%sMemoryLimit: %" PRIu64 "\n"
                 "%sTasksMax: %" PRIu64 "\n"
                 "%sDevicePolicy: %s\n"
                 "%sDisableControllers: %s\n"
                 "%sDelegate: %s\n"
                 "%sManagedOOMSwap: %s\n"
                 "%sManagedOOMMemoryPressure: %s\n"
                 "%sManagedOOMMemoryPressureLimit: " PERMYRIAD_AS_PERCENT_FORMAT_STR "\n"
                 "%sManagedOOMPreference: %s\n",
                 prefix, yes_no(c->cpu_accounting),
                 prefix, yes_no(c->io_accounting),
                 prefix, yes_no(c->blockio_accounting),
                 prefix, yes_no(c->memory_accounting),
                 prefix, yes_no(c->tasks_accounting),
                 prefix, yes_no(c->ip_accounting),
                 prefix, c->cpu_weight,
                 prefix, c->startup_cpu_weight,
                 prefix, c->cpu_shares,
                 prefix, c->startup_cpu_shares,
                 prefix, FORMAT_TIMESPAN(c->cpu_quota_per_sec_usec, 1),
                 prefix, FORMAT_TIMESPAN(c->cpu_quota_period_usec, 1),
                 prefix, strempty(cpuset_cpus),
                 prefix, strempty(startup_cpuset_cpus),
                 prefix, strempty(cpuset_mems),
                 prefix, strempty(startup_cpuset_mems),
                 prefix, c->io_weight,
                 prefix, c->startup_io_weight,
                 prefix, c->blockio_weight,
                 prefix, c->startup_blockio_weight,
                 prefix, c->default_memory_min,
                 prefix, c->default_memory_low,
                 prefix, c->memory_min, format_cgroup_memory_limit_comparison(cda, sizeof(cda), u, "MemoryMin"),
                 prefix, c->memory_low, format_cgroup_memory_limit_comparison(cdb, sizeof(cdb), u, "MemoryLow"),
                 prefix, c->memory_high, format_cgroup_memory_limit_comparison(cdc, sizeof(cdc), u, "MemoryHigh"),
                 prefix, c->memory_max, format_cgroup_memory_limit_comparison(cdd, sizeof(cdd), u, "MemoryMax"),
                 prefix, c->memory_swap_max, format_cgroup_memory_limit_comparison(cde, sizeof(cde), u, "MemorySwapMax"),
                 prefix, c->memory_limit,
                 prefix, tasks_max_resolve(&c->tasks_max),
                 prefix, cgroup_device_policy_to_string(c->device_policy),
                 prefix, strempty(disable_controllers_str),
                 prefix, yes_no(c->delegate),
                 prefix, managed_oom_mode_to_string(c->moom_swap),
                 prefix, managed_oom_mode_to_string(c->moom_mem_pressure),
                 prefix, PERMYRIAD_AS_PERCENT_FORMAT_VAL(UINT32_SCALE_TO_PERMYRIAD(c->moom_mem_pressure_limit)),
                 prefix, managed_oom_preference_to_string(c->moom_preference));
 
         if (c->delegate) {
                 _cleanup_free_ char *t = NULL;
 
                 (void) cg_mask_to_string(c->delegate_controllers, &t);
 
                 fprintf(f, "%sDelegateControllers: %s\n",
                         prefix,
                         strempty(t));
         }
 
         LIST_FOREACH(device_allow, a, c->device_allow)
                 fprintf(f,
                         "%sDeviceAllow: %s %s%s%s\n",
                         prefix,
                         a->path,
                         a->r ? "r" : "", a->w ? "w" : "", a->m ? "m" : "");
 
         LIST_FOREACH(device_weights, iw, c->io_device_weights)
                 fprintf(f,
                         "%sIODeviceWeight: %s %" PRIu64 "\n",
                         prefix,
                         iw->path,
                         iw->weight);
 
         LIST_FOREACH(device_latencies, l, c->io_device_latencies)
                 fprintf(f,
                         "%sIODeviceLatencyTargetSec: %s %s\n",
                         prefix,
                         l->path,
                         FORMAT_TIMESPAN(l->target_usec, 1));
 
         LIST_FOREACH(device_limits, il, c->io_device_limits)
                 for (CGroupIOLimitType type = 0; type < _CGROUP_IO_LIMIT_TYPE_MAX; type++)
                         if (il->limits[type] != cgroup_io_limit_defaults[type])
                                 fprintf(f,
                                         "%s%s: %s %s\n",
                                         prefix,
                                         cgroup_io_limit_type_to_string(type),
                                         il->path,
                                         FORMAT_BYTES(il->limits[type]));
 
         LIST_FOREACH(device_weights, w, c->blockio_device_weights)
                 fprintf(f,
                         "%sBlockIODeviceWeight: %s %" PRIu64,
                         prefix,
                         w->path,
                         w->weight);
 
         LIST_FOREACH(device_bandwidths, b, c->blockio_device_bandwidths) {
                 if (b->rbps != CGROUP_LIMIT_MAX)
                         fprintf(f,
                                 "%sBlockIOReadBandwidth: %s %s\n",
                                 prefix,
                                 b->path,
                                 FORMAT_BYTES(b->rbps));
                 if (b->wbps != CGROUP_LIMIT_MAX)
                         fprintf(f,
                                 "%sBlockIOWriteBandwidth: %s %s\n",
                                 prefix,
                                 b->path,
                                 FORMAT_BYTES(b->wbps));
         }
 
         SET_FOREACH(iaai, c->ip_address_allow)
                 fprintf(f, "%sIPAddressAllow: %s\n", prefix,
                         IN_ADDR_PREFIX_TO_STRING(iaai->family, &iaai->address, iaai->prefixlen));
         SET_FOREACH(iaai, c->ip_address_deny)
                 fprintf(f, "%sIPAddressDeny: %s\n", prefix,
                         IN_ADDR_PREFIX_TO_STRING(iaai->family, &iaai->address, iaai->prefixlen));
 
         STRV_FOREACH(path, c->ip_filters_ingress)
                 fprintf(f, "%sIPIngressFilterPath: %s\n", prefix, *path);
         STRV_FOREACH(path, c->ip_filters_egress)
                 fprintf(f, "%sIPEgressFilterPath: %s\n", prefix, *path);
 
         LIST_FOREACH(programs, p, c->bpf_foreign_programs)
                 fprintf(f, "%sBPFProgram: %s:%s",
                         prefix, bpf_cgroup_attach_type_to_string(p->attach_type), p->bpffs_path);
 
         if (c->socket_bind_allow) {
                 fprintf(f, "%sSocketBindAllow:", prefix);
                 LIST_FOREACH(socket_bind_items, bi, c->socket_bind_allow)
                         cgroup_context_dump_socket_bind_item(bi, f);
                 fputc('\n', f);
         }
 
         if (c->socket_bind_deny) {
                 fprintf(f, "%sSocketBindDeny:", prefix);
                 LIST_FOREACH(socket_bind_items, bi, c->socket_bind_deny)
                         cgroup_context_dump_socket_bind_item(bi, f);
                 fputc('\n', f);
         }
 
         if (c->restrict_network_interfaces) {
                 char *iface;
                 SET_FOREACH(iface, c->restrict_network_interfaces)
                         fprintf(f, "%sRestrictNetworkInterfaces: %s\n", prefix, iface);
         }
-
-        for (size_t i = 0; i < c->n_nft_set_contexts; i++)
-                fprintf(f, "%sControlGroupNFTSet: %s:%s:%s\n", prefix,
-                        nfproto_to_string(c->nft_set_context[i].nfproto),
-                        c->nft_set_context[i].table, c->nft_set_context[i].set);
 }
 
 void cgroup_context_dump_socket_bind_item(const CGroupSocketBindItem *item, FILE *f) {
@@ -1226,46 +1218,6 @@ static void cgroup_apply_firewall(Unit *u) {
         (void) bpf_firewall_install(u);
 }
 
-static void cgroup_apply_nft_set(Unit *u) {
-        int r;
-        CGroupContext *c;
-
-        assert(u);
-
-        assert_se(c = unit_get_cgroup_context(u));
-
-        for (size_t i = 0; i < c->n_nft_set_contexts; i++) {
-                NFTSetContext *s = &c->nft_set_context[i];
-                r = nft_set_element_add_uint64(s, u->cgroup_id);
-                if (r < 0)
-                        log_warning_errno(r, "Adding NFT family %s table %s set %s cgroup %" PRIu64 " failed, ignoring: %m",
-                                 nfproto_to_string(s->nfproto),
-                                 s->table,
-                                 s->set,
-                                 u->cgroup_id);
-        }
-}
-
-static void cgroup_delete_nft_set(Unit *u) {
-        int r;
-        CGroupContext *c;
-
-        assert(u);
-
-        assert_se(c = unit_get_cgroup_context(u));
-
-        for (size_t i = 0; i < c->n_nft_set_contexts; i++) {
-                NFTSetContext *s = &c->nft_set_context[i];
-                r = nft_set_element_del_uint64(s, u->cgroup_id);
-                if (r < 0)
-                        log_warning_errno(r, "Deleting NFT family %s table %s set %s cgroup %" PRIu64 " failed, ignoring: %m",
-                                 nfproto_to_string(s->nfproto),
-                                 s->table,
-                                 s->set,
-                                 u->cgroup_id);
-        }
-}
-
 static void cgroup_apply_socket_bind(Unit *u) {
         assert(u);
 
@@ -1397,309 +1349,307 @@ static void cgroup_apply_bpf_foreign_program(Unit *u) {
 static void cgroup_context_apply(
                 Unit *u,
                 CGroupMask apply_mask,
                 ManagerState state) {
 
         const char *path;
         CGroupContext *c;
         bool is_host_root, is_local_root;
         int r;
 
         assert(u);
 
         /* Nothing to do? Exit early! */
         if (apply_mask == 0)
                 return;
 
         /* Some cgroup attributes are not supported on the host root cgroup, hence silently ignore them here. And other
          * attributes should only be managed for cgroups further down the tree. */
         is_local_root = unit_has_name(u, SPECIAL_ROOT_SLICE);
         is_host_root = unit_has_host_root_cgroup(u);
 
         assert_se(c = unit_get_cgroup_context(u));
         assert_se(path = u->cgroup_path);
 
         if (is_local_root) /* Make sure we don't try to display messages with an empty path. */
                 path = "/";
 
         /* We generally ignore errors caused by read-only mounted cgroup trees (assuming we are running in a container
          * then), and missing cgroups, i.e. EROFS and ENOENT. */
 
         /* In fully unified mode these attributes don't exist on the host cgroup root. On legacy the weights exist, but
          * setting the weight makes very little sense on the host root cgroup, as there are no other cgroups at this
          * level. The quota exists there too, but any attempt to write to it is refused with EINVAL. Inside of
          * containers we want to leave control of these to the container manager (and if cgroup v2 delegation is used
          * we couldn't even write to them if we wanted to). */
         if ((apply_mask & CGROUP_MASK_CPU) && !is_local_root) {
 
                 if (cg_all_unified() > 0) {
                         uint64_t weight;
 
                         if (cgroup_context_has_cpu_weight(c))
                                 weight = cgroup_context_cpu_weight(c, state);
                         else if (cgroup_context_has_cpu_shares(c)) {
                                 uint64_t shares;
 
                                 shares = cgroup_context_cpu_shares(c, state);
                                 weight = cgroup_cpu_shares_to_weight(shares);
 
                                 log_cgroup_compat(u, "Applying [Startup]CPUShares=%" PRIu64 " as [Startup]CPUWeight=%" PRIu64 " on %s",
                                                   shares, weight, path);
                         } else
                                 weight = CGROUP_WEIGHT_DEFAULT;
 
                         cgroup_apply_unified_cpu_weight(u, weight);
                         cgroup_apply_unified_cpu_quota(u, c->cpu_quota_per_sec_usec, c->cpu_quota_period_usec);
 
                 } else {
                         uint64_t shares;
 
                         if (cgroup_context_has_cpu_weight(c)) {
                                 uint64_t weight;
 
                                 weight = cgroup_context_cpu_weight(c, state);
                                 shares = cgroup_cpu_weight_to_shares(weight);
 
                                 log_cgroup_compat(u, "Applying [Startup]CPUWeight=%" PRIu64 " as [Startup]CPUShares=%" PRIu64 " on %s",
                                                   weight, shares, path);
                         } else if (cgroup_context_has_cpu_shares(c))
                                 shares = cgroup_context_cpu_shares(c, state);
                         else
                                 shares = CGROUP_CPU_SHARES_DEFAULT;
 
                         cgroup_apply_legacy_cpu_shares(u, shares);
                         cgroup_apply_legacy_cpu_quota(u, c->cpu_quota_per_sec_usec, c->cpu_quota_period_usec);
                 }
         }
 
         if ((apply_mask & CGROUP_MASK_CPUSET) && !is_local_root) {
                 cgroup_apply_unified_cpuset(u, cgroup_context_allowed_cpus(c, state), "cpuset.cpus");
                 cgroup_apply_unified_cpuset(u, cgroup_context_allowed_mems(c, state), "cpuset.mems");
         }
 
         /* The 'io' controller attributes are not exported on the host's root cgroup (being a pure cgroup v2
          * controller), and in case of containers we want to leave control of these attributes to the container manager
          * (and we couldn't access that stuff anyway, even if we tried if proper delegation is used). */
         if ((apply_mask & CGROUP_MASK_IO) && !is_local_root) {
                 bool has_io, has_blockio;
                 uint64_t weight;
 
                 has_io = cgroup_context_has_io_config(c);
                 has_blockio = cgroup_context_has_blockio_config(c);
 
                 if (has_io)
                         weight = cgroup_context_io_weight(c, state);
                 else if (has_blockio) {
                         uint64_t blkio_weight;
 
                         blkio_weight = cgroup_context_blkio_weight(c, state);
                         weight = cgroup_weight_blkio_to_io(blkio_weight);
 
                         log_cgroup_compat(u, "Applying [Startup]BlockIOWeight=%" PRIu64 " as [Startup]IOWeight=%" PRIu64,
                                           blkio_weight, weight);
                 } else
                         weight = CGROUP_WEIGHT_DEFAULT;
 
                 set_io_weight(u, weight);
 
                 if (has_io) {
                         LIST_FOREACH(device_weights, w, c->io_device_weights)
                                 cgroup_apply_io_device_weight(u, w->path, w->weight);
 
                         LIST_FOREACH(device_limits, limit, c->io_device_limits)
                                 cgroup_apply_io_device_limit(u, limit->path, limit->limits);
 
                         LIST_FOREACH(device_latencies, latency, c->io_device_latencies)
                                 cgroup_apply_io_device_latency(u, latency->path, latency->target_usec);
 
                 } else if (has_blockio) {
                         LIST_FOREACH(device_weights, w, c->blockio_device_weights) {
                                 weight = cgroup_weight_blkio_to_io(w->weight);
 
                                 log_cgroup_compat(u, "Applying BlockIODeviceWeight=%" PRIu64 " as IODeviceWeight=%" PRIu64 " for %s",
                                                   w->weight, weight, w->path);
 
                                 cgroup_apply_io_device_weight(u, w->path, weight);
                         }
 
                         LIST_FOREACH(device_bandwidths, b, c->blockio_device_bandwidths) {
                                 uint64_t limits[_CGROUP_IO_LIMIT_TYPE_MAX];
 
                                 for (CGroupIOLimitType type = 0; type < _CGROUP_IO_LIMIT_TYPE_MAX; type++)
                                         limits[type] = cgroup_io_limit_defaults[type];
 
                                 limits[CGROUP_IO_RBPS_MAX] = b->rbps;
                                 limits[CGROUP_IO_WBPS_MAX] = b->wbps;
 
                                 log_cgroup_compat(u, "Applying BlockIO{Read|Write}Bandwidth=%" PRIu64 " %" PRIu64 " as IO{Read|Write}BandwidthMax= for %s",
                                                   b->rbps, b->wbps, b->path);
 
                                 cgroup_apply_io_device_limit(u, b->path, limits);
                         }
                 }
         }
 
         if (apply_mask & CGROUP_MASK_BLKIO) {
                 bool has_io, has_blockio;
 
                 has_io = cgroup_context_has_io_config(c);
                 has_blockio = cgroup_context_has_blockio_config(c);
 
                 /* Applying a 'weight' never makes sense for the host root cgroup, and for containers this should be
                  * left to our container manager, too. */
                 if (!is_local_root) {
                         uint64_t weight;
 
                         if (has_io) {
                                 uint64_t io_weight;
 
                                 io_weight = cgroup_context_io_weight(c, state);
                                 weight = cgroup_weight_io_to_blkio(cgroup_context_io_weight(c, state));
 
                                 log_cgroup_compat(u, "Applying [Startup]IOWeight=%" PRIu64 " as [Startup]BlockIOWeight=%" PRIu64,
                                                   io_weight, weight);
                         } else if (has_blockio)
                                 weight = cgroup_context_blkio_weight(c, state);
                         else
                                 weight = CGROUP_BLKIO_WEIGHT_DEFAULT;
 
                         set_blkio_weight(u, weight);
 
                         if (has_io)
                                 LIST_FOREACH(device_weights, w, c->io_device_weights) {
                                         weight = cgroup_weight_io_to_blkio(w->weight);
 
                                         log_cgroup_compat(u, "Applying IODeviceWeight=%" PRIu64 " as BlockIODeviceWeight=%" PRIu64 " for %s",
                                                           w->weight, weight, w->path);
 
                                         cgroup_apply_blkio_device_weight(u, w->path, weight);
                                 }
                         else if (has_blockio)
                                 LIST_FOREACH(device_weights, w, c->blockio_device_weights)
                                         cgroup_apply_blkio_device_weight(u, w->path, w->weight);
                 }
 
                 /* The bandwidth limits are something that make sense to be applied to the host's root but not container
                  * roots, as there we want the container manager to handle it */
                 if (is_host_root || !is_local_root) {
                         if (has_io)
                                 LIST_FOREACH(device_limits, l, c->io_device_limits) {
                                         log_cgroup_compat(u, "Applying IO{Read|Write}Bandwidth=%" PRIu64 " %" PRIu64 " as BlockIO{Read|Write}BandwidthMax= for %s",
                                                           l->limits[CGROUP_IO_RBPS_MAX], l->limits[CGROUP_IO_WBPS_MAX], l->path);
 
                                         cgroup_apply_blkio_device_limit(u, l->path, l->limits[CGROUP_IO_RBPS_MAX], l->limits[CGROUP_IO_WBPS_MAX]);
                                 }
                         else if (has_blockio)
                                 LIST_FOREACH(device_bandwidths, b, c->blockio_device_bandwidths)
                                         cgroup_apply_blkio_device_limit(u, b->path, b->rbps, b->wbps);
                 }
         }
 
         /* In unified mode 'memory' attributes do not exist on the root cgroup. In legacy mode 'memory.limit_in_bytes'
          * exists on the root cgroup, but any writes to it are refused with EINVAL. And if we run in a container we
          * want to leave control to the container manager (and if proper cgroup v2 delegation is used we couldn't even
          * write to this if we wanted to.) */
         if ((apply_mask & CGROUP_MASK_MEMORY) && !is_local_root) {
 
                 if (cg_all_unified() > 0) {
                         uint64_t max, swap_max = CGROUP_LIMIT_MAX;
 
                         if (unit_has_unified_memory_config(u)) {
                                 max = c->memory_max;
                                 swap_max = c->memory_swap_max;
                         } else {
                                 max = c->memory_limit;
 
                                 if (max != CGROUP_LIMIT_MAX)
                                         log_cgroup_compat(u, "Applying MemoryLimit=%" PRIu64 " as MemoryMax=", max);
                         }
 
                         cgroup_apply_unified_memory_limit(u, "memory.min", unit_get_ancestor_memory_min(u));
                         cgroup_apply_unified_memory_limit(u, "memory.low", unit_get_ancestor_memory_low(u));
                         cgroup_apply_unified_memory_limit(u, "memory.high", c->memory_high);
                         cgroup_apply_unified_memory_limit(u, "memory.max", max);
                         cgroup_apply_unified_memory_limit(u, "memory.swap.max", swap_max);
 
                         (void) set_attribute_and_warn(u, "memory", "memory.oom.group", one_zero(c->memory_oom_group));
 
                 } else {
                         char buf[DECIMAL_STR_MAX(uint64_t) + 1];
                         uint64_t val;
 
                         if (unit_has_unified_memory_config(u)) {
                                 val = c->memory_max;
                                 log_cgroup_compat(u, "Applying MemoryMax=%" PRIi64 " as MemoryLimit=", val);
                         } else
                                 val = c->memory_limit;
 
                         if (val == CGROUP_LIMIT_MAX)
                                 strncpy(buf, "-1\n", sizeof(buf));
                         else
                                 xsprintf(buf, "%" PRIu64 "\n", val);
 
                         (void) set_attribute_and_warn(u, "memory", "memory.limit_in_bytes", buf);
                 }
         }
 
         /* On cgroup v2 we can apply BPF everywhere. On cgroup v1 we apply it everywhere except for the root of
          * containers, where we leave this to the manager */
         if ((apply_mask & (CGROUP_MASK_DEVICES | CGROUP_MASK_BPF_DEVICES)) &&
             (is_host_root || cg_all_unified() > 0 || !is_local_root))
                 (void) cgroup_apply_devices(u);
 
         if (apply_mask & CGROUP_MASK_PIDS) {
 
                 if (is_host_root) {
                         /* So, the "pids" controller does not expose anything on the root cgroup, in order not to
                          * replicate knobs exposed elsewhere needlessly. We abstract this away here however, and when
                          * the knobs of the root cgroup are modified propagate this to the relevant sysctls. There's a
                          * non-obvious asymmetry however: unlike the cgroup properties we don't really want to take
                          * exclusive ownership of the sysctls, but we still want to honour things if the user sets
                          * limits. Hence we employ sort of a one-way strategy: when the user sets a bounded limit
                          * through us it counts. When the user afterwards unsets it again (i.e. sets it to unbounded)
                          * it also counts. But if the user never set a limit through us (i.e. we are the default of
                          * "unbounded") we leave things unmodified. For this we manage a global boolean that we turn on
                          * the first time we set a limit. Note that this boolean is flushed out on manager reload,
                          * which is desirable so that there's an official way to release control of the sysctl from
                          * systemd: set the limit to unbounded and reload. */
 
                         if (tasks_max_isset(&c->tasks_max)) {
                                 u->manager->sysctl_pid_max_changed = true;
                                 r = procfs_tasks_set_limit(tasks_max_resolve(&c->tasks_max));
                         } else if (u->manager->sysctl_pid_max_changed)
                                 r = procfs_tasks_set_limit(TASKS_MAX);
                         else
                                 r = 0;
                         if (r < 0)
                                 log_unit_full_errno(u, LOG_LEVEL_CGROUP_WRITE(r), r,
                                                     "Failed to write to tasks limit sysctls: %m");
                 }
 
                 /* The attribute itself is not available on the host root cgroup, and in the container case we want to
                  * leave it for the container manager. */
                 if (!is_local_root) {
                         if (tasks_max_isset(&c->tasks_max)) {
                                 char buf[DECIMAL_STR_MAX(uint64_t) + 1];
 
                                 xsprintf(buf, "%" PRIu64 "\n", tasks_max_resolve(&c->tasks_max));
                                 (void) set_attribute_and_warn(u, "pids", "pids.max", buf);
                         } else
                                 (void) set_attribute_and_warn(u, "pids", "pids.max", "max\n");
                 }
         }
 
         if (apply_mask & CGROUP_MASK_BPF_FIREWALL)
                 cgroup_apply_firewall(u);
 
         if (apply_mask & CGROUP_MASK_BPF_FOREIGN)
                 cgroup_apply_bpf_foreign_program(u);
 
         if (apply_mask & CGROUP_MASK_BPF_SOCKET_BIND)
                 cgroup_apply_socket_bind(u);
 
         if (apply_mask & CGROUP_MASK_BPF_RESTRICT_NETWORK_INTERFACES)
                 cgroup_apply_restrict_network_interfaces(u);
-
-        cgroup_apply_nft_set(u);
 }
 
 static bool unit_get_needs_bpf_firewall(Unit *u) {
@@ -2835,42 +2785,40 @@ bool unit_maybe_release_cgroup(Unit *u) {
 void unit_prune_cgroup(Unit *u) {
         int r;
         bool is_root_slice;
 
         assert(u);
 
         /* Removes the cgroup, if empty and possible, and stops watching it. */
 
         if (!u->cgroup_path)
                 return;
 
         (void) unit_get_cpu_usage(u, NULL); /* Cache the last CPU usage value before we destroy the cgroup */
 
 #if BPF_FRAMEWORK
         (void) lsm_bpf_cleanup(u); /* Remove cgroup from the global LSM BPF map */
 #endif
 
-        cgroup_delete_nft_set(u);
-
         is_root_slice = unit_has_name(u, SPECIAL_ROOT_SLICE);
 
         r = cg_trim_everywhere(u->manager->cgroup_supported, u->cgroup_path, !is_root_slice);
         if (r < 0)
                 /* One reason we could have failed here is, that the cgroup still contains a process.
                  * However, if the cgroup becomes removable at a later time, it might be removed when
                  * the containing slice is stopped. So even if we failed now, this unit shouldn't assume
                  * that the cgroup is still realized the next time it is started. Do not return early
                  * on error, continue cleanup. */
                 log_unit_full_errno(u, r == -EBUSY ? LOG_DEBUG : LOG_WARNING, r, "Failed to destroy cgroup %s, ignoring: %m", empty_to_root(u->cgroup_path));
 
         if (is_root_slice)
                 return;
 
         if (!unit_maybe_release_cgroup(u)) /* Returns true if the cgroup was released */
                 return;
 
         u->cgroup_realized = false;
         u->cgroup_realized_mask = 0;
         u->cgroup_enabled_mask = 0;
 
         u->bpf_device_control_installed = bpf_program_free(u->bpf_device_control_installed);
 }
diff --git a/src/core/cgroup.h b/src/core/cgroup.h
index 6ac28d7ca7..4413eeaaa0 100644
--- a/src/core/cgroup.h
+++ b/src/core/cgroup.h
@@ -1,12 +1,11 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 #pragma once
 
 #include <stdbool.h>
 
 #include "bpf-lsm.h"
 #include "cgroup-util.h"
 #include "cpu-set-util.h"
-#include "firewall-util.h"
 #include "list.h"
 #include "time-util.h"
 
@@ -114,90 +113,87 @@ struct CGroupSocketBindItem {
 struct CGroupContext {
         bool cpu_accounting;
         bool io_accounting;
         bool blockio_accounting;
         bool memory_accounting;
         bool tasks_accounting;
         bool ip_accounting;
 
         /* Configures the memory.oom.group attribute (on unified) */
         bool memory_oom_group;
 
         bool delegate;
         CGroupMask delegate_controllers;
         CGroupMask disable_controllers;
 
         /* For unified hierarchy */
         uint64_t cpu_weight;
         uint64_t startup_cpu_weight;
         usec_t cpu_quota_per_sec_usec;
         usec_t cpu_quota_period_usec;
 
         CPUSet cpuset_cpus;
         CPUSet startup_cpuset_cpus;
         CPUSet cpuset_mems;
         CPUSet startup_cpuset_mems;
 
         uint64_t io_weight;
         uint64_t startup_io_weight;
         LIST_HEAD(CGroupIODeviceWeight, io_device_weights);
         LIST_HEAD(CGroupIODeviceLimit, io_device_limits);
         LIST_HEAD(CGroupIODeviceLatency, io_device_latencies);
 
         uint64_t default_memory_min;
         uint64_t default_memory_low;
         uint64_t memory_min;
         uint64_t memory_low;
         uint64_t memory_high;
         uint64_t memory_max;
         uint64_t memory_swap_max;
 
         bool default_memory_min_set:1;
         bool default_memory_low_set:1;
         bool memory_min_set:1;
         bool memory_low_set:1;
 
         Set *ip_address_allow;
         Set *ip_address_deny;
         /* These two flags indicate that redundant entries have been removed from
          * ip_address_allow/ip_address_deny, i.e. in_addr_prefixes_reduce() has already been called. */
         bool ip_address_allow_reduced;
         bool ip_address_deny_reduced;
 
         char **ip_filters_ingress;
         char **ip_filters_egress;
         LIST_HEAD(CGroupBPFForeignProgram, bpf_foreign_programs);
 
         Set *restrict_network_interfaces;
         bool restrict_network_interfaces_is_allow_list;
 
         /* For legacy hierarchies */
         uint64_t cpu_shares;
         uint64_t startup_cpu_shares;
 
         uint64_t blockio_weight;
         uint64_t startup_blockio_weight;
         LIST_HEAD(CGroupBlockIODeviceWeight, blockio_device_weights);
         LIST_HEAD(CGroupBlockIODeviceBandwidth, blockio_device_bandwidths);
 
         uint64_t memory_limit;
 
         CGroupDevicePolicy device_policy;
         LIST_HEAD(CGroupDeviceAllow, device_allow);
 
         LIST_HEAD(CGroupSocketBindItem, socket_bind_allow);
         LIST_HEAD(CGroupSocketBindItem, socket_bind_deny);
 
         /* Common */
         TasksMax tasks_max;
 
         /* Settings for systemd-oomd */
         ManagedOOMMode moom_swap;
         ManagedOOMMode moom_mem_pressure;
         uint32_t moom_mem_pressure_limit; /* Normalized to 2^32-1 == 100% */
         ManagedOOMPreference moom_preference;
-
-        NFTSetContext *nft_set_context;
-        size_t n_nft_set_contexts;
 };
 
 /* Used when querying IP accounting data */
diff --git a/src/core/dbus-cgroup.c b/src/core/dbus-cgroup.c
index 82072da9e4..607370d7bf 100644
--- a/src/core/dbus-cgroup.c
+++ b/src/core/dbus-cgroup.c
@@ -1,25 +1,24 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include <arpa/inet.h>
 
 #include "af-list.h"
 #include "alloc-util.h"
 #include "bpf-firewall.h"
 #include "bpf-foreign.h"
 #include "bus-get-properties.h"
 #include "cgroup-util.h"
 #include "cgroup.h"
 #include "core-varlink.h"
 #include "dbus-cgroup.h"
 #include "dbus-util.h"
 #include "errno-util.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "firewall-util.h"
 #include "in-addr-prefix-util.h"
 #include "ip-protocol-list.h"
 #include "limits-util.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "percent-util.h"
 #include "socket-util.h"
@@ -444,94 +443,63 @@ static int property_get_restrict_network_interfaces(
         return sd_bus_message_close_container(reply);
 }
 
-static int property_get_cgroup_nft_set(
-                sd_bus *bus,
-                const char *path,
-                const char *interface,
-                const char *property,
-                sd_bus_message *reply,
-                void *userdata,
-                sd_bus_error *error) {
-        int r;
-        CGroupContext *c = userdata;
-
-        assert(bus);
-        assert(reply);
-        assert(c);
-
-        r = sd_bus_message_open_container(reply, 'a', "(iss)");
-        if (r < 0)
-                return r;
-
-        for (size_t i = 0; i < c->n_nft_set_contexts; i++) {
-                NFTSetContext *s = &c->nft_set_context[i];
-
-                r = sd_bus_message_append(reply, "(iss)", s->nfproto, s->table, s->set);
-                if (r < 0)
-                        return r;
-        }
-
-        return sd_bus_message_close_container(reply);
-}
-
 const sd_bus_vtable bus_cgroup_vtable[] = {
         SD_BUS_VTABLE_START(0),
         SD_BUS_PROPERTY("Delegate", "b", bus_property_get_bool, offsetof(CGroupContext, delegate), 0),
         SD_BUS_PROPERTY("DelegateControllers", "as", property_get_delegate_controllers, 0, 0),
         SD_BUS_PROPERTY("CPUAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, cpu_accounting), 0),
         SD_BUS_PROPERTY("CPUWeight", "t", NULL, offsetof(CGroupContext, cpu_weight), 0),
         SD_BUS_PROPERTY("StartupCPUWeight", "t", NULL, offsetof(CGroupContext, startup_cpu_weight), 0),
         SD_BUS_PROPERTY("CPUShares", "t", NULL, offsetof(CGroupContext, cpu_shares), 0),
         SD_BUS_PROPERTY("StartupCPUShares", "t", NULL, offsetof(CGroupContext, startup_cpu_shares), 0),
         SD_BUS_PROPERTY("CPUQuotaPerSecUSec", "t", bus_property_get_usec, offsetof(CGroupContext, cpu_quota_per_sec_usec), 0),
         SD_BUS_PROPERTY("CPUQuotaPeriodUSec", "t", bus_property_get_usec, offsetof(CGroupContext, cpu_quota_period_usec), 0),
         SD_BUS_PROPERTY("AllowedCPUs", "ay", property_get_cpuset, offsetof(CGroupContext, cpuset_cpus), 0),
         SD_BUS_PROPERTY("StartupAllowedCPUs", "ay", property_get_cpuset, offsetof(CGroupContext, startup_cpuset_cpus), 0),
         SD_BUS_PROPERTY("AllowedMemoryNodes", "ay", property_get_cpuset, offsetof(CGroupContext, cpuset_mems), 0),
         SD_BUS_PROPERTY("StartupAllowedMemoryNodes", "ay", property_get_cpuset, offsetof(CGroupContext, startup_cpuset_mems), 0),
         SD_BUS_PROPERTY("IOAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, io_accounting), 0),
         SD_BUS_PROPERTY("IOWeight", "t", NULL, offsetof(CGroupContext, io_weight), 0),
         SD_BUS_PROPERTY("StartupIOWeight", "t", NULL, offsetof(CGroupContext, startup_io_weight), 0),
         SD_BUS_PROPERTY("IODeviceWeight", "a(st)", property_get_io_device_weight, 0, 0),
         SD_BUS_PROPERTY("IOReadBandwidthMax", "a(st)", property_get_io_device_limits, 0, 0),
         SD_BUS_PROPERTY("IOWriteBandwidthMax", "a(st)", property_get_io_device_limits, 0, 0),
         SD_BUS_PROPERTY("IOReadIOPSMax", "a(st)", property_get_io_device_limits, 0, 0),
         SD_BUS_PROPERTY("IOWriteIOPSMax", "a(st)", property_get_io_device_limits, 0, 0),
         SD_BUS_PROPERTY("IODeviceLatencyTargetUSec", "a(st)", property_get_io_device_latency, 0, 0),
         SD_BUS_PROPERTY("BlockIOAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, blockio_accounting), 0),
         SD_BUS_PROPERTY("BlockIOWeight", "t", NULL, offsetof(CGroupContext, blockio_weight), 0),
         SD_BUS_PROPERTY("StartupBlockIOWeight", "t", NULL, offsetof(CGroupContext, startup_blockio_weight), 0),
         SD_BUS_PROPERTY("BlockIODeviceWeight", "a(st)", property_get_blockio_device_weight, 0, 0),
         SD_BUS_PROPERTY("BlockIOReadBandwidth", "a(st)", property_get_blockio_device_bandwidths, 0, 0),
         SD_BUS_PROPERTY("BlockIOWriteBandwidth", "a(st)", property_get_blockio_device_bandwidths, 0, 0),
         SD_BUS_PROPERTY("MemoryAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, memory_accounting), 0),
         SD_BUS_PROPERTY("DefaultMemoryLow", "t", NULL, offsetof(CGroupContext, default_memory_low), 0),
         SD_BUS_PROPERTY("DefaultMemoryMin", "t", NULL, offsetof(CGroupContext, default_memory_min), 0),
         SD_BUS_PROPERTY("MemoryMin", "t", NULL, offsetof(CGroupContext, memory_min), 0),
         SD_BUS_PROPERTY("MemoryLow", "t", NULL, offsetof(CGroupContext, memory_low), 0),
         SD_BUS_PROPERTY("MemoryHigh", "t", NULL, offsetof(CGroupContext, memory_high), 0),
         SD_BUS_PROPERTY("MemoryMax", "t", NULL, offsetof(CGroupContext, memory_max), 0),
         SD_BUS_PROPERTY("MemorySwapMax", "t", NULL, offsetof(CGroupContext, memory_swap_max), 0),
         SD_BUS_PROPERTY("MemoryLimit", "t", NULL, offsetof(CGroupContext, memory_limit), 0),
         SD_BUS_PROPERTY("DevicePolicy", "s", property_get_cgroup_device_policy, offsetof(CGroupContext, device_policy), 0),
         SD_BUS_PROPERTY("DeviceAllow", "a(ss)", property_get_device_allow, 0, 0),
         SD_BUS_PROPERTY("TasksAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, tasks_accounting), 0),
         SD_BUS_PROPERTY("TasksMax", "t", bus_property_get_tasks_max, offsetof(CGroupContext, tasks_max), 0),
         SD_BUS_PROPERTY("IPAccounting", "b", bus_property_get_bool, offsetof(CGroupContext, ip_accounting), 0),
         SD_BUS_PROPERTY("IPAddressAllow", "a(iayu)", property_get_ip_address_access, offsetof(CGroupContext, ip_address_allow), 0),
         SD_BUS_PROPERTY("IPAddressDeny", "a(iayu)", property_get_ip_address_access, offsetof(CGroupContext, ip_address_deny), 0),
         SD_BUS_PROPERTY("IPIngressFilterPath", "as", NULL, offsetof(CGroupContext, ip_filters_ingress), 0),
         SD_BUS_PROPERTY("IPEgressFilterPath", "as", NULL, offsetof(CGroupContext, ip_filters_egress), 0),
         SD_BUS_PROPERTY("DisableControllers", "as", property_get_cgroup_mask, offsetof(CGroupContext, disable_controllers), 0),
         SD_BUS_PROPERTY("ManagedOOMSwap", "s", property_get_managed_oom_mode, offsetof(CGroupContext, moom_swap), 0),
         SD_BUS_PROPERTY("ManagedOOMMemoryPressure", "s", property_get_managed_oom_mode, offsetof(CGroupContext, moom_mem_pressure), 0),
         SD_BUS_PROPERTY("ManagedOOMMemoryPressureLimit", "u", NULL, offsetof(CGroupContext, moom_mem_pressure_limit), 0),
         SD_BUS_PROPERTY("ManagedOOMPreference", "s", property_get_managed_oom_preference, offsetof(CGroupContext, moom_preference), 0),
         SD_BUS_PROPERTY("BPFProgram", "a(ss)", property_get_bpf_foreign_program, 0, 0),
         SD_BUS_PROPERTY("SocketBindAllow", "a(iiqq)", property_get_socket_bind, offsetof(CGroupContext, socket_bind_allow), 0),
         SD_BUS_PROPERTY("SocketBindDeny", "a(iiqq)", property_get_socket_bind, offsetof(CGroupContext, socket_bind_deny), 0),
         SD_BUS_PROPERTY("RestrictNetworkInterfaces", "(bas)", property_get_restrict_network_interfaces, 0, 0),
-        SD_BUS_PROPERTY("ControlGroupNFTSet", "a(iss)", property_get_cgroup_nft_set, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_VTABLE_END
 };
 
@@ -1007,1136 +975,1083 @@ static int bus_cgroup_set_tasks_max_scale(
 int bus_cgroup_set_property(
                 Unit *u,
                 CGroupContext *c,
                 const char *name,
                 sd_bus_message *message,
                 UnitWriteFlags flags,
                 sd_bus_error *error) {
 
         CGroupIOLimitType iol_type;
         int r;
 
         assert(u);
         assert(c);
         assert(name);
         assert(message);
 
         flags |= UNIT_PRIVATE;
 
         if (streq(name, "CPUAccounting"))
                 return bus_cgroup_set_boolean(u, name, &c->cpu_accounting, get_cpu_accounting_mask(), message, flags, error);
 
         if (streq(name, "CPUWeight"))
                 return bus_cgroup_set_cpu_weight(u, name, &c->cpu_weight, message, flags, error);
 
         if (streq(name, "StartupCPUWeight"))
                 return bus_cgroup_set_cpu_weight(u, name, &c->startup_cpu_weight, message, flags, error);
 
         if (streq(name, "CPUShares"))
                 return bus_cgroup_set_cpu_shares(u, name, &c->cpu_shares, message, flags, error);
 
         if (streq(name, "StartupCPUShares"))
                 return bus_cgroup_set_cpu_shares(u, name, &c->startup_cpu_shares, message, flags, error);
 
         if (streq(name, "IOAccounting"))
                 return bus_cgroup_set_boolean(u, name, &c->io_accounting, CGROUP_MASK_IO, message, flags, error);
 
         if (streq(name, "IOWeight"))
                 return bus_cgroup_set_io_weight(u, name, &c->io_weight, message, flags, error);
 
         if (streq(name, "StartupIOWeight"))
                 return bus_cgroup_set_io_weight(u, name, &c->startup_io_weight, message, flags, error);
 
         if (streq(name, "BlockIOAccounting"))
                 return bus_cgroup_set_boolean(u, name, &c->blockio_accounting, CGROUP_MASK_BLKIO, message, flags, error);
 
         if (streq(name, "BlockIOWeight"))
                 return bus_cgroup_set_blockio_weight(u, name, &c->blockio_weight, message, flags, error);
 
         if (streq(name, "StartupBlockIOWeight"))
                 return bus_cgroup_set_blockio_weight(u, name, &c->startup_blockio_weight, message, flags, error);
 
         if (streq(name, "MemoryAccounting"))
                 return bus_cgroup_set_boolean(u, name, &c->memory_accounting, CGROUP_MASK_MEMORY, message, flags, error);
 
         if (streq(name, "MemoryMin")) {
                 r = bus_cgroup_set_memory_protection(u, name, &c->memory_min, message, flags, error);
                 if (r > 0)
                         c->memory_min_set = true;
                 return r;
         }
 
         if (streq(name, "MemoryLow")) {
                 r = bus_cgroup_set_memory_protection(u, name, &c->memory_low, message, flags, error);
                 if (r > 0)
                         c->memory_low_set = true;
                 return r;
         }
 
         if (streq(name, "DefaultMemoryMin")) {
                 r = bus_cgroup_set_memory_protection(u, name, &c->default_memory_min, message, flags, error);
                 if (r > 0)
                         c->default_memory_min_set = true;
                 return r;
         }
 
         if (streq(name, "DefaultMemoryLow")) {
                 r = bus_cgroup_set_memory_protection(u, name, &c->default_memory_low, message, flags, error);
                 if (r > 0)
                         c->default_memory_low_set = true;
                 return r;
         }
 
         if (streq(name, "MemoryHigh"))
                 return bus_cgroup_set_memory(u, name, &c->memory_high, message, flags, error);
 
         if (streq(name, "MemorySwapMax"))
                 return bus_cgroup_set_swap(u, name, &c->memory_swap_max, message, flags, error);
 
         if (streq(name, "MemoryMax"))
                 return bus_cgroup_set_memory(u, name, &c->memory_max, message, flags, error);
 
         if (streq(name, "MemoryLimit"))
                 return bus_cgroup_set_memory(u, name, &c->memory_limit, message, flags, error);
 
         if (streq(name, "MemoryMinScale")) {
                 r = bus_cgroup_set_memory_protection_scale(u, name, &c->memory_min, message, flags, error);
                 if (r > 0)
                         c->memory_min_set = true;
                 return r;
         }
 
         if (streq(name, "MemoryLowScale")) {
                 r = bus_cgroup_set_memory_protection_scale(u, name, &c->memory_low, message, flags, error);
                 if (r > 0)
                         c->memory_low_set = true;
                 return r;
         }
 
         if (streq(name, "DefaultMemoryMinScale")) {
                 r = bus_cgroup_set_memory_protection_scale(u, name, &c->default_memory_min, message, flags, error);
                 if (r > 0)
                         c->default_memory_min_set = true;
                 return r;
         }
 
         if (streq(name, "DefaultMemoryLowScale")) {
                 r = bus_cgroup_set_memory_protection_scale(u, name, &c->default_memory_low, message, flags, error);
                 if (r > 0)
                         c->default_memory_low_set = true;
                 return r;
         }
 
         if (streq(name, "MemoryHighScale"))
                 return bus_cgroup_set_memory_scale(u, name, &c->memory_high, message, flags, error);
 
         if (streq(name, "MemorySwapMaxScale"))
                 return bus_cgroup_set_swap_scale(u, name, &c->memory_swap_max, message, flags, error);
 
         if (streq(name, "MemoryMaxScale"))
                 return bus_cgroup_set_memory_scale(u, name, &c->memory_max, message, flags, error);
 
         if (streq(name, "MemoryLimitScale"))
                 return bus_cgroup_set_memory_scale(u, name, &c->memory_limit, message, flags, error);
 
         if (streq(name, "TasksAccounting"))
                 return bus_cgroup_set_boolean(u, name, &c->tasks_accounting, CGROUP_MASK_PIDS, message, flags, error);
 
         if (streq(name, "TasksMax"))
                 return bus_cgroup_set_tasks_max(u, name, &c->tasks_max, message, flags, error);
 
         if (streq(name, "TasksMaxScale"))
                 return bus_cgroup_set_tasks_max_scale(u, name, &c->tasks_max, message, flags, error);
 
         if (streq(name, "CPUQuotaPerSecUSec")) {
                 uint64_t u64;
 
                 r = sd_bus_message_read(message, "t", &u64);
                 if (r < 0)
                         return r;
 
                 if (u64 <= 0)
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "CPUQuotaPerSecUSec= value out of range");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->cpu_quota_per_sec_usec = u64;
                         u->warned_clamping_cpu_quota_period = false;
                         unit_invalidate_cgroup(u, CGROUP_MASK_CPU);
 
                         if (c->cpu_quota_per_sec_usec == USEC_INFINITY)
                                 unit_write_setting(u, flags, "CPUQuota", "CPUQuota=");
                         else
                                 /* config_parse_cpu_quota() requires an integer, so truncating division is used on
                                  * purpose here. */
                                 unit_write_settingf(u, flags, "CPUQuota",
                                                     "CPUQuota=%0.f%%",
                                                     (double) (c->cpu_quota_per_sec_usec / 10000));
                 }
 
                 return 1;
 
         } else if (streq(name, "CPUQuotaPeriodUSec")) {
                 uint64_t u64;
 
                 r = sd_bus_message_read(message, "t", &u64);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->cpu_quota_period_usec = u64;
                         u->warned_clamping_cpu_quota_period = false;
                         unit_invalidate_cgroup(u, CGROUP_MASK_CPU);
                         if (c->cpu_quota_period_usec == USEC_INFINITY)
                                 unit_write_setting(u, flags, "CPUQuotaPeriodSec", "CPUQuotaPeriodSec=");
                         else
                                 unit_write_settingf(u, flags, "CPUQuotaPeriodSec",
                                                     "CPUQuotaPeriodSec=%s",
                                                     FORMAT_TIMESPAN(c->cpu_quota_period_usec, 1));
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "AllowedCPUs", "StartupAllowedCPUs", "AllowedMemoryNodes", "StartupAllowedMemoryNodes")) {
                 const void *a;
                 size_t n;
                 _cleanup_(cpu_set_reset) CPUSet new_set = {};
 
                 r = sd_bus_message_read_array(message, 'y', &a, &n);
                 if (r < 0)
                         return r;
 
                 r = cpu_set_from_dbus(a, n, &new_set);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *setstr = NULL;
                         CPUSet *set = NULL;
 
                         setstr = cpu_set_to_range_string(&new_set);
                         if (!setstr)
                                 return -ENOMEM;
 
                         if (streq(name, "AllowedCPUs"))
                                 set = &c->cpuset_cpus;
                         else if (streq(name, "StartupAllowedCPUs"))
                                 set = &c->startup_cpuset_cpus;
                         else if (streq(name, "AllowedMemoryNodes"))
                                 set = &c->cpuset_mems;
                         else if (streq(name, "StartupAllowedMemoryNodes"))
                                 set = &c->startup_cpuset_mems;
 
                         assert(set);
 
                         cpu_set_reset(set);
                         *set = new_set;
                         new_set = (CPUSet) {};
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_CPUSET);
                         unit_write_settingf(u, flags, name, "%s=%s", name, setstr);
                 }
 
                 return 1;
 
         } else if ((iol_type = cgroup_io_limit_type_from_string(name)) >= 0) {
                 const char *path;
                 unsigned n = 0;
                 uint64_t u64;
 
                 r = sd_bus_message_enter_container(message, 'a', "(st)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(st)", &path, &u64)) > 0) {
 
                         if (!path_is_normalized(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path '%s' specified in %s= is not normalized.", name, path);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupIODeviceLimit *a = NULL;
 
                                 LIST_FOREACH(device_limits, b, c->io_device_limits)
                                         if (path_equal(path, b->path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         CGroupIOLimitType type;
 
                                         a = new0(CGroupIODeviceLimit, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
 
                                         for (type = 0; type < _CGROUP_IO_LIMIT_TYPE_MAX; type++)
                                                 a->limits[type] = cgroup_io_limit_defaults[type];
 
                                         LIST_PREPEND(device_limits, c->io_device_limits, a);
                                 }
 
                                 a->limits[iol_type] = u64;
                         }
 
                         n++;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 LIST_FOREACH(device_limits, a, c->io_device_limits)
                                         a->limits[iol_type] = cgroup_io_limit_defaults[iol_type];
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_IO);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fprintf(f, "%s=\n", name);
                         LIST_FOREACH(device_limits, a, c->io_device_limits)
                                 if (a->limits[iol_type] != cgroup_io_limit_defaults[iol_type])
                                         fprintf(f, "%s=%s %" PRIu64 "\n", name, a->path, a->limits[iol_type]);
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (streq(name, "IODeviceWeight")) {
                 const char *path;
                 uint64_t weight;
                 unsigned n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(st)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(st)", &path, &weight)) > 0) {
 
                         if (!path_is_normalized(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path '%s' specified in %s= is not normalized.", name, path);
 
                         if (!CGROUP_WEIGHT_IS_OK(weight) || weight == CGROUP_WEIGHT_INVALID)
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "IODeviceWeight= value out of range");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupIODeviceWeight *a = NULL;
 
                                 LIST_FOREACH(device_weights, b, c->io_device_weights)
                                         if (path_equal(b->path, path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         a = new0(CGroupIODeviceWeight, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
                                         LIST_PREPEND(device_weights, c->io_device_weights, a);
                                 }
 
                                 a->weight = weight;
                         }
 
                         n++;
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 while (c->io_device_weights)
                                         cgroup_context_free_io_device_weight(c, c->io_device_weights);
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_IO);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fputs("IODeviceWeight=\n", f);
                         LIST_FOREACH(device_weights, a, c->io_device_weights)
                                 fprintf(f, "IODeviceWeight=%s %" PRIu64 "\n", a->path, a->weight);
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (streq(name, "IODeviceLatencyTargetUSec")) {
                 const char *path;
                 uint64_t target;
                 unsigned n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(st)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(st)", &path, &target)) > 0) {
 
                         if (!path_is_normalized(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path '%s' specified in %s= is not normalized.", name, path);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupIODeviceLatency *a = NULL;
 
                                 LIST_FOREACH(device_latencies, b, c->io_device_latencies)
                                         if (path_equal(b->path, path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         a = new0(CGroupIODeviceLatency, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
                                         LIST_PREPEND(device_latencies, c->io_device_latencies, a);
                                 }
 
                                 a->target_usec = target;
                         }
 
                         n++;
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 while (c->io_device_latencies)
                                         cgroup_context_free_io_device_latency(c, c->io_device_latencies);
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_IO);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fputs("IODeviceLatencyTargetSec=\n", f);
                         LIST_FOREACH(device_latencies, a, c->io_device_latencies)
                                 fprintf(f, "IODeviceLatencyTargetSec=%s %s\n",
                                         a->path, FORMAT_TIMESPAN(a->target_usec, 1));
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "BlockIOReadBandwidth", "BlockIOWriteBandwidth")) {
                 const char *path;
                 bool read = true;
                 unsigned n = 0;
                 uint64_t u64;
 
                 if (streq(name, "BlockIOWriteBandwidth"))
                         read = false;
 
                 r = sd_bus_message_enter_container(message, 'a', "(st)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(st)", &path, &u64)) > 0) {
 
                         if (!path_is_normalized(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path '%s' specified in %s= is not normalized.", name, path);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupBlockIODeviceBandwidth *a = NULL;
 
                                 LIST_FOREACH(device_bandwidths, b, c->blockio_device_bandwidths)
                                         if (path_equal(path, b->path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         a = new0(CGroupBlockIODeviceBandwidth, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->rbps = CGROUP_LIMIT_MAX;
                                         a->wbps = CGROUP_LIMIT_MAX;
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
 
                                         LIST_PREPEND(device_bandwidths, c->blockio_device_bandwidths, a);
                                 }
 
                                 if (read)
                                         a->rbps = u64;
                                 else
                                         a->wbps = u64;
                         }
 
                         n++;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 LIST_FOREACH(device_bandwidths, a, c->blockio_device_bandwidths) {
                                         if (read)
                                                 a->rbps = CGROUP_LIMIT_MAX;
                                         else
                                                 a->wbps = CGROUP_LIMIT_MAX;
                                 }
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_BLKIO);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         if (read) {
                                 fputs("BlockIOReadBandwidth=\n", f);
                                 LIST_FOREACH(device_bandwidths, a, c->blockio_device_bandwidths)
                                         if (a->rbps != CGROUP_LIMIT_MAX)
                                                 fprintf(f, "BlockIOReadBandwidth=%s %" PRIu64 "\n", a->path, a->rbps);
                         } else {
                                 fputs("BlockIOWriteBandwidth=\n", f);
                                 LIST_FOREACH(device_bandwidths, a, c->blockio_device_bandwidths)
                                         if (a->wbps != CGROUP_LIMIT_MAX)
                                                 fprintf(f, "BlockIOWriteBandwidth=%s %" PRIu64 "\n", a->path, a->wbps);
                         }
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
 
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (streq(name, "BlockIODeviceWeight")) {
                 const char *path;
                 uint64_t weight;
                 unsigned n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(st)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(st)", &path, &weight)) > 0) {
 
                         if (!path_is_normalized(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path '%s' specified in %s= is not normalized.", name, path);
 
                         if (!CGROUP_BLKIO_WEIGHT_IS_OK(weight) || weight == CGROUP_BLKIO_WEIGHT_INVALID)
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "BlockIODeviceWeight= out of range");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupBlockIODeviceWeight *a = NULL;
 
                                 LIST_FOREACH(device_weights, b, c->blockio_device_weights)
                                         if (path_equal(b->path, path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         a = new0(CGroupBlockIODeviceWeight, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
                                         LIST_PREPEND(device_weights, c->blockio_device_weights, a);
                                 }
 
                                 a->weight = weight;
                         }
 
                         n++;
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 while (c->blockio_device_weights)
                                         cgroup_context_free_blockio_device_weight(c, c->blockio_device_weights);
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_BLKIO);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fputs("BlockIODeviceWeight=\n", f);
                         LIST_FOREACH(device_weights, a, c->blockio_device_weights)
                                 fprintf(f, "BlockIODeviceWeight=%s %" PRIu64 "\n", a->path, a->weight);
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
 
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (streq(name, "DevicePolicy")) {
                 const char *policy;
                 CGroupDevicePolicy p;
 
                 r = sd_bus_message_read(message, "s", &policy);
                 if (r < 0)
                         return r;
 
                 p = cgroup_device_policy_from_string(policy);
                 if (p < 0)
                         return p;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->device_policy = p;
                         unit_invalidate_cgroup(u, CGROUP_MASK_DEVICES);
                         unit_write_settingf(u, flags, name, "DevicePolicy=%s", policy);
                 }
 
                 return 1;
 
         } else if (streq(name, "DeviceAllow")) {
                 const char *path, *rwm;
                 unsigned n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(ss)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(ss)", &path, &rwm)) > 0) {
 
                         if (!valid_device_allow_pattern(path) || strpbrk(path, WHITESPACE))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "DeviceAllow= requires device node or pattern");
 
                         if (isempty(rwm))
                                 rwm = "rwm";
                         else if (!in_charset(rwm, "rwm"))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "DeviceAllow= requires combination of rwm flags");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 CGroupDeviceAllow *a = NULL;
 
                                 LIST_FOREACH(device_allow, b, c->device_allow)
                                         if (path_equal(b->path, path)) {
                                                 a = b;
                                                 break;
                                         }
 
                                 if (!a) {
                                         a = new0(CGroupDeviceAllow, 1);
                                         if (!a)
                                                 return -ENOMEM;
 
                                         a->path = strdup(path);
                                         if (!a->path) {
                                                 free(a);
                                                 return -ENOMEM;
                                         }
 
                                         LIST_PREPEND(device_allow, c->device_allow, a);
                                 }
 
                                 a->r = strchr(rwm, 'r');
                                 a->w = strchr(rwm, 'w');
                                 a->m = strchr(rwm, 'm');
                         }
 
                         n++;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 while (c->device_allow)
                                         cgroup_context_free_device_allow(c, c->device_allow);
 
                         unit_invalidate_cgroup(u, CGROUP_MASK_DEVICES);
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fputs("DeviceAllow=\n", f);
                         LIST_FOREACH(device_allow, a, c->device_allow)
                                 fprintf(f, "DeviceAllow=%s %s%s%s\n", a->path, a->r ? "r" : "", a->w ? "w" : "", a->m ? "m" : "");
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
 
         } else if (streq(name, "IPAccounting")) {
                 int b;
 
                 r = sd_bus_message_read(message, "b", &b);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->ip_accounting = b;
 
                         unit_invalidate_cgroup_bpf(u);
                         unit_write_settingf(u, flags, name, "IPAccounting=%s", yes_no(b));
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "IPAddressAllow", "IPAddressDeny")) {
                 _cleanup_set_free_ Set *new_prefixes = NULL;
                 size_t n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(iayu)");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         const void *ap;
                         int32_t family;
                         uint32_t prefixlen;
                         size_t an;
 
                         r = sd_bus_message_enter_container(message, 'r', "iayu");
                         if (r < 0)
                                 return r;
                         if (r == 0)
                                 break;
 
                         r = sd_bus_message_read(message, "i", &family);
                         if (r < 0)
                                 return r;
 
                         if (!IN_SET(family, AF_INET, AF_INET6))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= expects IPv4 or IPv6 addresses only.", name);
 
                         r = sd_bus_message_read_array(message, 'y', &ap, &an);
                         if (r < 0)
                                 return r;
 
                         if (an != FAMILY_ADDRESS_SIZE(family))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "IP address has wrong size for family (%s, expected %zu, got %zu)",
                                                                af_to_name(family), FAMILY_ADDRESS_SIZE(family), an);
 
                         r = sd_bus_message_read(message, "u", &prefixlen);
                         if (r < 0)
                                 return r;
 
                         if (prefixlen > FAMILY_ADDRESS_SIZE(family)*8)
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Prefix length %" PRIu32 " too large for address family %s.", prefixlen, af_to_name(family));
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 struct in_addr_prefix prefix = {
                                         .family = family,
                                         .prefixlen = prefixlen,
                                 };
 
                                 memcpy(&prefix.address, ap, an);
 
                                 r = in_addr_prefix_add(&new_prefixes, &prefix);
                                 if (r < 0)
                                         return r;
                         }
 
                         r = sd_bus_message_exit_container(message);
                         if (r < 0)
                                 return r;
 
                         n++;
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
                         Set **prefixes;
                         bool *reduced;
 
                         unit_invalidate_cgroup_bpf(u);
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         prefixes = streq(name, "IPAddressAllow") ? &c->ip_address_allow : &c->ip_address_deny;
                         reduced = streq(name, "IPAddressAllow") ? &c->ip_address_allow_reduced : &c->ip_address_deny_reduced;
 
                         if (n == 0) {
                                 *reduced = true;
                                 *prefixes = set_free(*prefixes);
                                 fputs(name, f);
                                 fputs("=\n", f);
                         } else {
                                 *reduced = false;
 
                                 r = in_addr_prefixes_merge(prefixes, new_prefixes);
                                 if (r < 0)
                                         return r;
 
                                 const struct in_addr_prefix *p;
                                 SET_FOREACH(p, new_prefixes)
                                         fprintf(f, "%s=%s\n", name,
                                                 IN_ADDR_PREFIX_TO_STRING(p->family, &p->address, p->prefixlen));
                         }
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
 
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
         }
 
         if (STR_IN_SET(name, "ManagedOOMSwap", "ManagedOOMMemoryPressure")) {
                 ManagedOOMMode *cgroup_mode = streq(name, "ManagedOOMSwap") ? &c->moom_swap : &c->moom_mem_pressure;
                 ManagedOOMMode m;
                 const char *mode;
 
                 if (!UNIT_VTABLE(u)->can_set_managed_oom)
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Cannot set %s for this unit type", name);
 
                 r = sd_bus_message_read(message, "s", &mode);
                 if (r < 0)
                         return r;
 
                 m = managed_oom_mode_from_string(mode);
                 if (m < 0)
                         return -EINVAL;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         *cgroup_mode = m;
                         unit_write_settingf(u, flags, name, "%s=%s", name, mode);
                 }
 
                 (void) manager_varlink_send_managed_oom_update(u);
                 return 1;
         }
 
         if (streq(name, "ManagedOOMMemoryPressureLimit")) {
                 uint32_t v;
 
                 if (!UNIT_VTABLE(u)->can_set_managed_oom)
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Cannot set %s for this unit type", name);
 
                 r = sd_bus_message_read(message, "u", &v);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->moom_mem_pressure_limit = v;
                         unit_write_settingf(u, flags, name,
                                             "ManagedOOMMemoryPressureLimit=" PERMYRIAD_AS_PERCENT_FORMAT_STR,
                                             PERMYRIAD_AS_PERCENT_FORMAT_VAL(UINT32_SCALE_TO_PERMYRIAD(v)));
                 }
 
                 if (c->moom_mem_pressure == MANAGED_OOM_KILL)
                         (void) manager_varlink_send_managed_oom_update(u);
 
                 return 1;
         }
 
         if (streq(name, "ManagedOOMPreference")) {
                 ManagedOOMPreference p;
                 const char *pref;
 
                 r = sd_bus_message_read(message, "s", &pref);
                 if (r < 0)
                         return r;
 
                 p = managed_oom_preference_from_string(pref);
                 if (p < 0)
                         return p;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->moom_preference = p;
                         unit_write_settingf(u, flags, name, "ManagedOOMPreference=%s", pref);
                 }
 
                 return 1;
         }
         if (STR_IN_SET(name, "SocketBindAllow", "SocketBindDeny")) {
                 CGroupSocketBindItem **list;
                 uint16_t nr_ports, port_min;
                 size_t n = 0;
                 int32_t family, ip_protocol;
 
                 list = streq(name, "SocketBindAllow") ? &c->socket_bind_allow : &c->socket_bind_deny;
 
                 r = sd_bus_message_enter_container(message, 'a', "(iiqq)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(iiqq)", &family, &ip_protocol, &nr_ports, &port_min)) > 0) {
 
                         if (!IN_SET(family, AF_UNSPEC, AF_INET, AF_INET6))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= expects INET or INET6 family, if specified.", name);
 
                         if (!IN_SET(ip_protocol, 0, IPPROTO_TCP, IPPROTO_UDP))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= expects TCP or UDP protocol, if specified.", name);
 
                         if (port_min + (uint32_t) nr_ports > (1 << 16))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= expects maximum port value lesser than 65536.", name);
 
                         if (port_min == 0 && nr_ports != 0)
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= expects port range starting with positive value.", name);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ CGroupSocketBindItem *item = NULL;
 
                                 item = new(CGroupSocketBindItem, 1);
                                 if (!item)
                                         return log_oom();
 
                                 *item = (CGroupSocketBindItem) {
                                         .address_family = family,
                                         .ip_protocol = ip_protocol,
                                         .nr_ports = nr_ports,
                                         .port_min = port_min
                                 };
 
                                 LIST_PREPEND(socket_bind_items, *list, TAKE_PTR(item));
                         }
                         n++;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *buf = NULL;
                         _cleanup_fclose_ FILE *f = NULL;
                         size_t size = 0;
 
                         if (n == 0)
                                 cgroup_context_remove_socket_bind(list);
                         else {
                                 if ((u->manager->cgroup_supported & CGROUP_MASK_BPF_SOCKET_BIND) == 0)
                                         log_full(LOG_DEBUG,
                                                  "Unit %s configures source compiled BPF programs "
                                                  "but the local system does not support that.\n"
                                                  "Starting this unit will fail!", u->id);
                         }
 
                         f = open_memstream_unlocked(&buf, &size);
                         if (!f)
                                 return -ENOMEM;
 
                         fprintf(f, "%s:", name);
 
                         LIST_FOREACH(socket_bind_items, item, *list)
                                 cgroup_context_dump_socket_bind_item(item, f);
 
                         fputc('\n', f);
 
                         r = fflush_and_check(f);
                         if (r < 0)
                                 return r;
 
                         unit_write_setting(u, flags, name, buf);
                 }
 
                 return 1;
         }
         if (streq(name, "RestrictNetworkInterfaces")) {
                 int is_allow_list;
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_enter_container(message, 'r', "bas");
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read(message, "b", &is_allow_list);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
 
                         if (strv_isempty(l)) {
                                 c->restrict_network_interfaces_is_allow_list = false;
                                 c->restrict_network_interfaces = set_free(c->restrict_network_interfaces);
 
                                 unit_write_settingf(u, flags, name, "%s=", name);
                                 return 1;
                         }
 
                         if (set_isempty(c->restrict_network_interfaces))
                                 c->restrict_network_interfaces_is_allow_list = is_allow_list;
 
                         STRV_FOREACH(s, l) {
                                 if (!ifname_valid(*s)) {
                                         log_full(LOG_WARNING, "Invalid interface name, ignoring: %s", *s);
                                         continue;
                                 }
                                 if (c->restrict_network_interfaces_is_allow_list != (bool) is_allow_list)
                                         free(set_remove(c->restrict_network_interfaces, *s));
                                 else {
                                         r = set_put_strdup(&c->restrict_network_interfaces, *s);
                                         if (r < 0)
                                                 return log_oom();
                                 }
                         }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "%s=%s%s", name, is_allow_list ? "" : "~", joined);
                 }
 
                 return 1;
         }
 
         if (streq(name, "DisableControllers") || (u->transient && u->load_state == UNIT_STUB))
                 return bus_cgroup_set_transient_property(u, c, name, message, flags, error);
 
-        if (streq(name, "ControlGroupNFTSet")) {
-                int nfproto;
-                const char *table, *set;
-                bool empty = true;
-
-                r = sd_bus_message_enter_container(message, 'a', "(iss)");
-                if (r < 0)
-                        return r;
-
-                while ((r = sd_bus_message_read(message, "(iss)", &nfproto, &table, &set)) > 0) {
-                        const char *nfproto_name;
-
-                        nfproto_name = nfproto_to_string(nfproto);
-                        if (!nfproto_name)
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid protocol %d.", nfproto);
-
-                        if (nft_identifier_bad(table))
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid NFT table name %s.", table);
-
-                        if (nft_identifier_bad(set))
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid NFT set name %s.", set);
-
-                        if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
-                                r = nft_set_context_add(&c->nft_set_context, &c->n_nft_set_contexts, nfproto, table, set);
-                                if (r < 0)
-                                        return r;
-
-                                unit_write_settingf(
-                                                u, flags|UNIT_ESCAPE_SPECIFIERS, name,
-                                                "%s=%s:%s:%s",
-                                                name,
-                                                nfproto_name,
-                                                table,
-                                                set);
-                        }
-
-                        empty = false;
-                }
-                if (r < 0)
-                        return r;
-
-                r = sd_bus_message_exit_container(message);
-                if (r < 0)
-                        return r;
-
-                if (empty) {
-                        c->nft_set_context = nft_set_context_free_many(c->nft_set_context, &c->n_nft_set_contexts);
-                        unit_write_settingf(u, flags, name, "%s=", name);
-                }
-
-                return 1;
-        }
-
         return 0;
 }
diff --git a/src/core/dbus-execute.c b/src/core/dbus-execute.c
index 0b28d4f603..1a9e5da635 100644
--- a/src/core/dbus-execute.c
+++ b/src/core/dbus-execute.c
@@ -1,47 +1,46 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include <sys/mount.h>
 #include <sys/prctl.h>
 
 #if HAVE_SECCOMP
 #include <seccomp.h>
 #endif
 
 #include "af-list.h"
 #include "alloc-util.h"
 #include "bus-get-properties.h"
 #include "cap-list.h"
 #include "capability-util.h"
 #include "cpu-set-util.h"
 #include "creds-util.h"
 #include "dbus-execute.h"
 #include "dbus-util.h"
 #include "env-util.h"
 #include "errno-list.h"
 #include "escape.h"
 #include "execute.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "firewall-util.h"
 #include "hexdecoct.h"
 #include "io-util.h"
 #include "ioprio-util.h"
 #include "journal-file.h"
 #include "missing_ioprio.h"
 #include "mountpoint-util.h"
 #include "namespace.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "process-util.h"
 #include "rlimit-util.h"
 #if HAVE_SECCOMP
 #include "seccomp-util.h"
 #endif
 #include "securebits-util.h"
 #include "specifier.h"
 #include "stat-util.h"
 #include "strv.h"
 #include "syslog-util.h"
 #include "unit-printf.h"
 #include "user-util.h"
 #include "utf8.h"
@@ -1143,212 +1142,180 @@ static int bus_property_get_exec_dir_symlink(
         return sd_bus_message_close_container(reply);
 }
 
-static int property_get_dynamic_user_nft_set(
-                sd_bus *bus,
-                const char *path,
-                const char *interface,
-                const char *property,
-                sd_bus_message *reply,
-                void *userdata,
-                sd_bus_error *error) {
-
-        ExecContext *c = userdata;
-        int r;
-
-        assert(bus);
-        assert(reply);
-        assert(c);
-
-        r = sd_bus_message_open_container(reply, 'a', "(iss)");
-        if (r < 0)
-                return r;
-
-        for (size_t i = 0; i < c->n_dynamic_user_nft_set_contexts; i++) {
-                NFTSetContext *s = &c->dynamic_user_nft_set_context[i];
-
-                r = sd_bus_message_append(reply, "(iss)", s->nfproto, s->table, s->set);
-                if (r < 0)
-                        return r;
-        }
-
-        return sd_bus_message_close_container(reply);
-}
-
 const sd_bus_vtable bus_exec_vtable[] = {
         SD_BUS_VTABLE_START(0),
         SD_BUS_PROPERTY("Environment", "as", NULL, offsetof(ExecContext, environment), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("EnvironmentFiles", "a(sb)", property_get_environment_files, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PassEnvironment", "as", NULL, offsetof(ExecContext, pass_environment), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("UnsetEnvironment", "as", NULL, offsetof(ExecContext, unset_environment), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("UMask", "u", bus_property_get_mode, offsetof(ExecContext, umask), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitCPU", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_CPU]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitCPUSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_CPU]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitFSIZE", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_FSIZE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitFSIZESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_FSIZE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitDATA", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_DATA]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitDATASoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_DATA]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitSTACK", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_STACK]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitSTACKSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_STACK]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitCORE", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_CORE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitCORESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_CORE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRSS", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RSS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRSSSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RSS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNOFILE", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NOFILE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNOFILESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NOFILE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitAS", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_AS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitASSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_AS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNPROC", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NPROC]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNPROCSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NPROC]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitMEMLOCK", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_MEMLOCK]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitMEMLOCKSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_MEMLOCK]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitLOCKS", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_LOCKS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitLOCKSSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_LOCKS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitSIGPENDING", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_SIGPENDING]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitSIGPENDINGSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_SIGPENDING]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitMSGQUEUE", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_MSGQUEUE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitMSGQUEUESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_MSGQUEUE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNICE", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NICE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitNICESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_NICE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRTPRIO", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RTPRIO]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRTPRIOSoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RTPRIO]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRTTIME", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RTTIME]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LimitRTTIMESoft", "t", bus_property_get_rlimit, offsetof(ExecContext, rlimit[RLIMIT_RTTIME]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("WorkingDirectory", "s", property_get_working_directory, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootDirectory", "s", NULL, offsetof(ExecContext, root_directory), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootImage", "s", NULL, offsetof(ExecContext, root_image), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootImageOptions", "a(ss)", property_get_root_image_options, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootHash", "ay", property_get_root_hash, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootHashPath", "s", NULL, offsetof(ExecContext, root_hash_path), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootHashSignature", "ay", property_get_root_hash_sig, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootHashSignaturePath", "s", NULL, offsetof(ExecContext, root_hash_sig_path), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RootVerity", "s", NULL, offsetof(ExecContext, root_verity), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ExtensionDirectories", "as", NULL, offsetof(ExecContext, extension_directories), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ExtensionImages", "a(sba(ss))", property_get_extension_images, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("MountImages", "a(ssba(ss))", property_get_mount_images, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("OOMScoreAdjust", "i", property_get_oom_score_adjust, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CoredumpFilter", "t", property_get_coredump_filter, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("Nice", "i", property_get_nice, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IOSchedulingClass", "i", property_get_ioprio_class, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IOSchedulingPriority", "i", property_get_ioprio_priority, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CPUSchedulingPolicy", "i", property_get_cpu_sched_policy, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CPUSchedulingPriority", "i", property_get_cpu_sched_priority, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CPUAffinity", "ay", property_get_cpu_affinity, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CPUAffinityFromNUMA", "b", property_get_cpu_affinity_from_numa, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NUMAPolicy", "i", property_get_numa_policy, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NUMAMask", "ay", property_get_numa_mask, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TimerSlackNSec", "t", property_get_timer_slack_nsec, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CPUSchedulingResetOnFork", "b", bus_property_get_bool, offsetof(ExecContext, cpu_sched_reset_on_fork), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NonBlocking", "b", bus_property_get_bool, offsetof(ExecContext, non_blocking), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardInput", "s", property_get_exec_input, offsetof(ExecContext, std_input), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardInputFileDescriptorName", "s", property_get_stdio_fdname, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardInputData", "ay", property_get_input_data, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardOutput", "s", bus_property_get_exec_output, offsetof(ExecContext, std_output), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardOutputFileDescriptorName", "s", property_get_stdio_fdname, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardError", "s", bus_property_get_exec_output, offsetof(ExecContext, std_error), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StandardErrorFileDescriptorName", "s", property_get_stdio_fdname, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYPath", "s", NULL, offsetof(ExecContext, tty_path), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYReset", "b", bus_property_get_bool, offsetof(ExecContext, tty_reset), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYVHangup", "b", bus_property_get_bool, offsetof(ExecContext, tty_vhangup), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYVTDisallocate", "b", bus_property_get_bool, offsetof(ExecContext, tty_vt_disallocate), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYRows", "q", bus_property_get_unsigned, offsetof(ExecContext, tty_rows), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TTYColumns", "q", bus_property_get_unsigned, offsetof(ExecContext, tty_cols), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SyslogPriority", "i", bus_property_get_int, offsetof(ExecContext, syslog_priority), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SyslogIdentifier", "s", NULL, offsetof(ExecContext, syslog_identifier), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SyslogLevelPrefix", "b", bus_property_get_bool, offsetof(ExecContext, syslog_level_prefix), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SyslogLevel", "i", property_get_syslog_level, offsetof(ExecContext, syslog_priority), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SyslogFacility", "i", property_get_syslog_facility, offsetof(ExecContext, syslog_priority), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogLevelMax", "i", bus_property_get_int, offsetof(ExecContext, log_level_max), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogRateLimitIntervalUSec", "t", bus_property_get_usec, offsetof(ExecContext, log_ratelimit_interval_usec), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogRateLimitBurst", "u", bus_property_get_unsigned, offsetof(ExecContext, log_ratelimit_burst), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogExtraFields", "aay", property_get_log_extra_fields, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogNamespace", "s", NULL, offsetof(ExecContext, log_namespace), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SecureBits", "i", bus_property_get_int, offsetof(ExecContext, secure_bits), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CapabilityBoundingSet", "t", NULL, offsetof(ExecContext, capability_bounding_set), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("AmbientCapabilities", "t", NULL, offsetof(ExecContext, capability_ambient_set), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("User", "s", NULL, offsetof(ExecContext, user), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("Group", "s", NULL, offsetof(ExecContext, group), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("DynamicUser", "b", bus_property_get_bool, offsetof(ExecContext, dynamic_user), SD_BUS_VTABLE_PROPERTY_CONST),
-        SD_BUS_PROPERTY("DynamicUserNFTSet", "a(iss)", property_get_dynamic_user_nft_set, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RemoveIPC", "b", bus_property_get_bool, offsetof(ExecContext, remove_ipc), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SetCredential", "a(say)", property_get_set_credential, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SetCredentialEncrypted", "a(say)", property_get_set_credential, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LoadCredential", "a(ss)", property_get_load_credential, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LoadCredentialEncrypted", "a(ss)", property_get_load_credential, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SupplementaryGroups", "as", NULL, offsetof(ExecContext, supplementary_groups), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PAMName", "s", NULL, offsetof(ExecContext, pam_name), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ReadWritePaths", "as", NULL, offsetof(ExecContext, read_write_paths), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ReadOnlyPaths", "as", NULL, offsetof(ExecContext, read_only_paths), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("InaccessiblePaths", "as", NULL, offsetof(ExecContext, inaccessible_paths), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ExecPaths", "as", NULL, offsetof(ExecContext, exec_paths), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NoExecPaths", "as", NULL, offsetof(ExecContext, no_exec_paths), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ExecSearchPath", "as", NULL, offsetof(ExecContext, exec_search_path), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("MountFlags", "t", bus_property_get_ulong, offsetof(ExecContext, mount_flags), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateTmp", "b", bus_property_get_bool, offsetof(ExecContext, private_tmp), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateDevices", "b", bus_property_get_bool, offsetof(ExecContext, private_devices), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectClock", "b", bus_property_get_bool, offsetof(ExecContext, protect_clock), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectKernelTunables", "b", bus_property_get_bool, offsetof(ExecContext, protect_kernel_tunables), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectKernelModules", "b", bus_property_get_bool, offsetof(ExecContext, protect_kernel_modules), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectKernelLogs", "b", bus_property_get_bool, offsetof(ExecContext, protect_kernel_logs), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectControlGroups", "b", bus_property_get_bool, offsetof(ExecContext, protect_control_groups), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateNetwork", "b", bus_property_get_bool, offsetof(ExecContext, private_network), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateUsers", "b", bus_property_get_bool, offsetof(ExecContext, private_users), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateMounts", "b", bus_property_get_bool, offsetof(ExecContext, private_mounts), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("PrivateIPC", "b", bus_property_get_bool, offsetof(ExecContext, private_ipc), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectHome", "s", property_get_protect_home, offsetof(ExecContext, protect_home), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectSystem", "s", property_get_protect_system, offsetof(ExecContext, protect_system), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SameProcessGroup", "b", bus_property_get_bool, offsetof(ExecContext, same_pgrp), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("UtmpIdentifier", "s", NULL, offsetof(ExecContext, utmp_id), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("UtmpMode", "s", property_get_exec_utmp_mode, offsetof(ExecContext, utmp_mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SELinuxContext", "(bs)", property_get_selinux_context, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("AppArmorProfile", "(bs)", property_get_apparmor_profile, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SmackProcessLabel", "(bs)", property_get_smack_process_label, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IgnoreSIGPIPE", "b", bus_property_get_bool, offsetof(ExecContext, ignore_sigpipe), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NoNewPrivileges", "b", bus_property_get_bool, offsetof(ExecContext, no_new_privileges), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SystemCallFilter", "(bas)", property_get_syscall_filter, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SystemCallArchitectures", "as", property_get_syscall_archs, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SystemCallErrorNumber", "i", bus_property_get_int, offsetof(ExecContext, syscall_errno), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("SystemCallLog", "(bas)", property_get_syscall_log, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("Personality", "s", property_get_personality, offsetof(ExecContext, personality), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LockPersonality", "b", bus_property_get_bool, offsetof(ExecContext, lock_personality), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RestrictAddressFamilies", "(bas)", property_get_address_families, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RuntimeDirectorySymlink", "a(sst)", bus_property_get_exec_dir_symlink, offsetof(ExecContext, directories[EXEC_DIRECTORY_RUNTIME]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RuntimeDirectoryPreserve", "s", property_get_exec_preserve_mode, offsetof(ExecContext, runtime_directory_preserve_mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RuntimeDirectoryMode", "u", bus_property_get_mode, offsetof(ExecContext, directories[EXEC_DIRECTORY_RUNTIME].mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RuntimeDirectory", "as", bus_property_get_exec_dir, offsetof(ExecContext, directories[EXEC_DIRECTORY_RUNTIME]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StateDirectorySymlink", "a(sst)", bus_property_get_exec_dir_symlink, offsetof(ExecContext, directories[EXEC_DIRECTORY_STATE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StateDirectoryMode", "u", bus_property_get_mode, offsetof(ExecContext, directories[EXEC_DIRECTORY_STATE].mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("StateDirectory", "as", bus_property_get_exec_dir, offsetof(ExecContext, directories[EXEC_DIRECTORY_STATE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CacheDirectorySymlink", "a(sst)", bus_property_get_exec_dir_symlink, offsetof(ExecContext, directories[EXEC_DIRECTORY_CACHE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CacheDirectoryMode", "u", bus_property_get_mode, offsetof(ExecContext, directories[EXEC_DIRECTORY_CACHE].mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("CacheDirectory", "as", bus_property_get_exec_dir, offsetof(ExecContext, directories[EXEC_DIRECTORY_CACHE]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogsDirectorySymlink", "a(sst)", bus_property_get_exec_dir_symlink, offsetof(ExecContext, directories[EXEC_DIRECTORY_LOGS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogsDirectoryMode", "u", bus_property_get_mode, offsetof(ExecContext, directories[EXEC_DIRECTORY_LOGS].mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("LogsDirectory", "as", bus_property_get_exec_dir, offsetof(ExecContext, directories[EXEC_DIRECTORY_LOGS]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ConfigurationDirectoryMode", "u", bus_property_get_mode, offsetof(ExecContext, directories[EXEC_DIRECTORY_CONFIGURATION].mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ConfigurationDirectory", "as", bus_property_get_exec_dir, offsetof(ExecContext, directories[EXEC_DIRECTORY_CONFIGURATION]), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TimeoutCleanUSec", "t", bus_property_get_usec, offsetof(ExecContext, timeout_clean_usec), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("MemoryDenyWriteExecute", "b", bus_property_get_bool, offsetof(ExecContext, memory_deny_write_execute), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RestrictRealtime", "b", bus_property_get_bool, offsetof(ExecContext, restrict_realtime), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RestrictSUIDSGID", "b", bus_property_get_bool, offsetof(ExecContext, restrict_suid_sgid), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RestrictNamespaces", "t", bus_property_get_ulong, offsetof(ExecContext, restrict_namespaces), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("RestrictFileSystems", "(bas)", property_get_restrict_filesystems, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("BindPaths", "a(ssbt)", property_get_bind_paths, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("BindReadOnlyPaths", "a(ssbt)", property_get_bind_paths, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("TemporaryFileSystem", "a(ss)", property_get_temporary_filesystems, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("MountAPIVFS", "b", property_get_mount_apivfs, 0, SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("KeyringMode", "s", property_get_exec_keyring_mode, offsetof(ExecContext, keyring_mode), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectProc", "s", property_get_protect_proc, offsetof(ExecContext, protect_proc), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProcSubset", "s", property_get_proc_subset, offsetof(ExecContext, proc_subset), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("ProtectHostname", "b", bus_property_get_bool, offsetof(ExecContext, protect_hostname), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("NetworkNamespacePath", "s", NULL, offsetof(ExecContext, network_namespace_path), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IPCNamespacePath", "s", NULL, offsetof(ExecContext, ipc_namespace_path), SD_BUS_VTABLE_PROPERTY_CONST),
 
         /* Obsolete/redundant properties: */
         SD_BUS_PROPERTY("Capabilities", "s", property_get_empty_string, 0, SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN),
         SD_BUS_PROPERTY("ReadWriteDirectories", "as", NULL, offsetof(ExecContext, read_write_paths), SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN),
         SD_BUS_PROPERTY("ReadOnlyDirectories", "as", NULL, offsetof(ExecContext, read_only_paths), SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN),
         SD_BUS_PROPERTY("InaccessibleDirectories", "as", NULL, offsetof(ExecContext, inaccessible_paths), SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN),
         SD_BUS_PROPERTY("IOScheduling", "i", property_get_ioprio, 0, SD_BUS_VTABLE_PROPERTY_CONST|SD_BUS_VTABLE_HIDDEN),
 
         SD_BUS_VTABLE_END
 };
@@ -1695,2236 +1662,2184 @@ static BUS_DEFINE_SET_TRANSIENT_TO_STRING(mount_flags, "t", uint64_t, unsigned l
 int bus_exec_context_set_transient_property(
                 Unit *u,
                 ExecContext *c,
                 const char *name,
                 sd_bus_message *message,
                 UnitWriteFlags flags,
                 sd_bus_error *error) {
 
         const char *suffix;
         int r;
 
         assert(u);
         assert(c);
         assert(name);
         assert(message);
 
         flags |= UNIT_PRIVATE;
 
         if (streq(name, "User"))
                 return bus_set_transient_user_relaxed(u, name, &c->user, message, flags, error);
 
         if (streq(name, "Group"))
                 return bus_set_transient_user_relaxed(u, name, &c->group, message, flags, error);
 
         if (streq(name, "TTYPath"))
                 return bus_set_transient_path(u, name, &c->tty_path, message, flags, error);
 
         if (streq(name, "RootImage"))
                 return bus_set_transient_path(u, name, &c->root_image, message, flags, error);
 
         if (streq(name, "RootImageOptions")) {
                 _cleanup_(mount_options_free_allp) MountOptions *options = NULL;
                 _cleanup_free_ char *format_str = NULL;
 
                 r = bus_read_mount_options(message, error, &options, &format_str, " ");
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (LIST_IS_EMPTY(options)) {
                                 c->root_image_options = mount_options_free_all(c->root_image_options);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 LIST_JOIN(mount_options, c->root_image_options, options);
                                 unit_write_settingf(
                                                 u, flags|UNIT_ESCAPE_SPECIFIERS, name,
                                                 "%s=%s",
                                                 name,
                                                 format_str);
                         }
                 }
 
                 return 1;
         }
 
         if (streq(name, "RootHash")) {
                 const void *roothash_decoded;
                 size_t roothash_decoded_size;
 
                 r = sd_bus_message_read_array(message, 'y', &roothash_decoded, &roothash_decoded_size);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *encoded = NULL;
 
                         if (roothash_decoded_size == 0) {
                                 c->root_hash_path = mfree(c->root_hash_path);
                                 c->root_hash = mfree(c->root_hash);
                                 c->root_hash_size = 0;
 
                                 unit_write_settingf(u, flags, name, "RootHash=");
                         } else {
                                 _cleanup_free_ void *p = NULL;
 
                                 encoded = hexmem(roothash_decoded, roothash_decoded_size);
                                 if (!encoded)
                                         return -ENOMEM;
 
                                 p = memdup(roothash_decoded, roothash_decoded_size);
                                 if (!p)
                                         return -ENOMEM;
 
                                 free_and_replace(c->root_hash, p);
                                 c->root_hash_size = roothash_decoded_size;
                                 c->root_hash_path = mfree(c->root_hash_path);
 
                                 unit_write_settingf(u, flags, name, "RootHash=%s", encoded);
                         }
                 }
 
                 return 1;
         }
 
         if (streq(name, "RootHashPath")) {
                 c->root_hash_size = 0;
                 c->root_hash = mfree(c->root_hash);
 
                 return bus_set_transient_path(u, "RootHash", &c->root_hash_path, message, flags, error);
         }
 
         if (streq(name, "RootHashSignature")) {
                 const void *roothash_sig_decoded;
                 size_t roothash_sig_decoded_size;
 
                 r = sd_bus_message_read_array(message, 'y', &roothash_sig_decoded, &roothash_sig_decoded_size);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *encoded = NULL;
 
                         if (roothash_sig_decoded_size == 0) {
                                 c->root_hash_sig_path = mfree(c->root_hash_sig_path);
                                 c->root_hash_sig = mfree(c->root_hash_sig);
                                 c->root_hash_sig_size = 0;
 
                                 unit_write_settingf(u, flags, name, "RootHashSignature=");
                         } else {
                                 _cleanup_free_ void *p = NULL;
                                 ssize_t len;
 
                                 len = base64mem(roothash_sig_decoded, roothash_sig_decoded_size, &encoded);
                                 if (len < 0)
                                         return -ENOMEM;
 
                                 p = memdup(roothash_sig_decoded, roothash_sig_decoded_size);
                                 if (!p)
                                         return -ENOMEM;
 
                                 free_and_replace(c->root_hash_sig, p);
                                 c->root_hash_sig_size = roothash_sig_decoded_size;
                                 c->root_hash_sig_path = mfree(c->root_hash_sig_path);
 
                                 unit_write_settingf(u, flags, name, "RootHashSignature=base64:%s", encoded);
                         }
                 }
 
                 return 1;
         }
 
         if (streq(name, "RootHashSignaturePath")) {
                 c->root_hash_sig_size = 0;
                 c->root_hash_sig = mfree(c->root_hash_sig);
 
                 return bus_set_transient_path(u, "RootHashSignature", &c->root_hash_sig_path, message, flags, error);
         }
 
         if (streq(name, "RootVerity"))
                 return bus_set_transient_path(u, name, &c->root_verity, message, flags, error);
 
         if (streq(name, "RootDirectory"))
                 return bus_set_transient_path(u, name, &c->root_directory, message, flags, error);
 
         if (streq(name, "SyslogIdentifier"))
                 return bus_set_transient_string(u, name, &c->syslog_identifier, message, flags, error);
 
         if (streq(name, "LogLevelMax"))
                 return bus_set_transient_log_level(u, name, &c->log_level_max, message, flags, error);
 
         if (streq(name, "LogRateLimitIntervalUSec"))
                 return bus_set_transient_usec(u, name, &c->log_ratelimit_interval_usec, message, flags, error);
 
         if (streq(name, "LogRateLimitBurst"))
                 return bus_set_transient_unsigned(u, name, &c->log_ratelimit_burst, message, flags, error);
 
         if (streq(name, "Personality"))
                 return bus_set_transient_personality(u, name, &c->personality, message, flags, error);
 
         if (streq(name, "StandardInput"))
                 return bus_set_transient_std_input(u, name, &c->std_input, message, flags, error);
 
         if (streq(name, "StandardOutput"))
                 return bus_set_transient_std_output(u, name, &c->std_output, message, flags, error);
 
         if (streq(name, "StandardError"))
                 return bus_set_transient_std_output(u, name, &c->std_error, message, flags, error);
 
         if (streq(name, "IgnoreSIGPIPE"))
                 return bus_set_transient_bool(u, name, &c->ignore_sigpipe, message, flags, error);
 
         if (streq(name, "TTYVHangup"))
                 return bus_set_transient_bool(u, name, &c->tty_vhangup, message, flags, error);
 
         if (streq(name, "TTYReset"))
                 return bus_set_transient_bool(u, name, &c->tty_reset, message, flags, error);
 
         if (streq(name, "TTYVTDisallocate"))
                 return bus_set_transient_bool(u, name, &c->tty_vt_disallocate, message, flags, error);
 
         if (streq(name, "TTYRows"))
                 return bus_set_transient_unsigned(u, name, &c->tty_rows, message, flags, error);
 
         if (streq(name, "TTYColumns"))
                 return bus_set_transient_unsigned(u, name, &c->tty_cols, message, flags, error);
 
         if (streq(name, "PrivateTmp"))
                 return bus_set_transient_bool(u, name, &c->private_tmp, message, flags, error);
 
         if (streq(name, "PrivateDevices"))
                 return bus_set_transient_bool(u, name, &c->private_devices, message, flags, error);
 
         if (streq(name, "PrivateMounts"))
                 return bus_set_transient_bool(u, name, &c->private_mounts, message, flags, error);
 
         if (streq(name, "PrivateNetwork"))
                 return bus_set_transient_bool(u, name, &c->private_network, message, flags, error);
 
         if (streq(name, "PrivateIPC"))
                 return bus_set_transient_bool(u, name, &c->private_ipc, message, flags, error);
 
         if (streq(name, "PrivateUsers"))
                 return bus_set_transient_bool(u, name, &c->private_users, message, flags, error);
 
         if (streq(name, "NoNewPrivileges"))
                 return bus_set_transient_bool(u, name, &c->no_new_privileges, message, flags, error);
 
         if (streq(name, "SyslogLevelPrefix"))
                 return bus_set_transient_bool(u, name, &c->syslog_level_prefix, message, flags, error);
 
         if (streq(name, "MemoryDenyWriteExecute"))
                 return bus_set_transient_bool(u, name, &c->memory_deny_write_execute, message, flags, error);
 
         if (streq(name, "RestrictRealtime"))
                 return bus_set_transient_bool(u, name, &c->restrict_realtime, message, flags, error);
 
         if (streq(name, "RestrictSUIDSGID"))
                 return bus_set_transient_bool(u, name, &c->restrict_suid_sgid, message, flags, error);
 
         if (streq(name, "DynamicUser"))
                 return bus_set_transient_bool(u, name, &c->dynamic_user, message, flags, error);
 
         if (streq(name, "RemoveIPC"))
                 return bus_set_transient_bool(u, name, &c->remove_ipc, message, flags, error);
 
         if (streq(name, "ProtectKernelTunables"))
                 return bus_set_transient_bool(u, name, &c->protect_kernel_tunables, message, flags, error);
 
         if (streq(name, "ProtectKernelModules"))
                 return bus_set_transient_bool(u, name, &c->protect_kernel_modules, message, flags, error);
 
         if (streq(name, "ProtectKernelLogs"))
                 return bus_set_transient_bool(u, name, &c->protect_kernel_logs, message, flags, error);
 
         if (streq(name, "ProtectClock"))
                 return bus_set_transient_bool(u, name, &c->protect_clock, message, flags, error);
 
         if (streq(name, "ProtectControlGroups"))
                 return bus_set_transient_bool(u, name, &c->protect_control_groups, message, flags, error);
 
         if (streq(name, "CPUSchedulingResetOnFork"))
                 return bus_set_transient_bool(u, name, &c->cpu_sched_reset_on_fork, message, flags, error);
 
         if (streq(name, "NonBlocking"))
                 return bus_set_transient_bool(u, name, &c->non_blocking, message, flags, error);
 
         if (streq(name, "LockPersonality"))
                 return bus_set_transient_bool(u, name, &c->lock_personality, message, flags, error);
 
         if (streq(name, "ProtectHostname"))
                 return bus_set_transient_bool(u, name, &c->protect_hostname, message, flags, error);
 
         if (streq(name, "UtmpIdentifier"))
                 return bus_set_transient_string(u, name, &c->utmp_id, message, flags, error);
 
         if (streq(name, "UtmpMode"))
                 return bus_set_transient_utmp_mode(u, name, &c->utmp_mode, message, flags, error);
 
         if (streq(name, "PAMName"))
                 return bus_set_transient_string(u, name, &c->pam_name, message, flags, error);
 
         if (streq(name, "TimerSlackNSec"))
                 return bus_set_transient_nsec(u, name, &c->timer_slack_nsec, message, flags, error);
 
         if (streq(name, "ProtectSystem"))
                 return bus_set_transient_protect_system(u, name, &c->protect_system, message, flags, error);
 
         if (streq(name, "ProtectHome"))
                 return bus_set_transient_protect_home(u, name, &c->protect_home, message, flags, error);
 
         if (streq(name, "KeyringMode"))
                 return bus_set_transient_keyring_mode(u, name, &c->keyring_mode, message, flags, error);
 
         if (streq(name, "ProtectProc"))
                 return bus_set_transient_protect_proc(u, name, &c->protect_proc, message, flags, error);
 
         if (streq(name, "ProcSubset"))
                 return bus_set_transient_proc_subset(u, name, &c->proc_subset, message, flags, error);
 
         if (streq(name, "RuntimeDirectoryPreserve"))
                 return bus_set_transient_preserve_mode(u, name, &c->runtime_directory_preserve_mode, message, flags, error);
 
         if (streq(name, "UMask"))
                 return bus_set_transient_mode_t(u, name, &c->umask, message, flags, error);
 
         if (streq(name, "RuntimeDirectoryMode"))
                 return bus_set_transient_mode_t(u, name, &c->directories[EXEC_DIRECTORY_RUNTIME].mode, message, flags, error);
 
         if (streq(name, "StateDirectoryMode"))
                 return bus_set_transient_mode_t(u, name, &c->directories[EXEC_DIRECTORY_STATE].mode, message, flags, error);
 
         if (streq(name, "CacheDirectoryMode"))
                 return bus_set_transient_mode_t(u, name, &c->directories[EXEC_DIRECTORY_CACHE].mode, message, flags, error);
 
         if (streq(name, "LogsDirectoryMode"))
                 return bus_set_transient_mode_t(u, name, &c->directories[EXEC_DIRECTORY_LOGS].mode, message, flags, error);
 
         if (streq(name, "ConfigurationDirectoryMode"))
                 return bus_set_transient_mode_t(u, name, &c->directories[EXEC_DIRECTORY_CONFIGURATION].mode, message, flags, error);
 
         if (streq(name, "SELinuxContext"))
                 return bus_set_transient_string(u, name, &c->selinux_context, message, flags, error);
 
         if (streq(name, "SecureBits"))
                 return bus_set_transient_secure_bits(u, name, &c->secure_bits, message, flags, error);
 
         if (streq(name, "CapabilityBoundingSet"))
                 return bus_set_transient_capability(u, name, &c->capability_bounding_set, message, flags, error);
 
         if (streq(name, "AmbientCapabilities"))
                 return bus_set_transient_capability(u, name, &c->capability_ambient_set, message, flags, error);
 
         if (streq(name, "RestrictNamespaces"))
                 return bus_set_transient_namespace_flag(u, name, &c->restrict_namespaces, message, flags, error);
 
         if (streq(name, "RestrictFileSystems")) {
                 int allow_list;
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_enter_container(message, 'r', "bas");
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read(message, "b", &allow_list);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
                         FilesystemParseFlags invert_flag = allow_list ? 0 : FILESYSTEM_PARSE_INVERT;
 
                         if (strv_isempty(l)) {
                                 c->restrict_filesystems_allow_list = false;
                                 c->restrict_filesystems = set_free(c->restrict_filesystems);
 
                                 unit_write_setting(u, flags, name, "RestrictFileSystems=");
                                 return 1;
                         }
 
                         if (!c->restrict_filesystems)
                                 c->restrict_filesystems_allow_list = allow_list;
 
                         STRV_FOREACH(s, l) {
                                 r = lsm_bpf_parse_filesystem(
                                               *s,
                                               &c->restrict_filesystems,
                                               FILESYSTEM_PARSE_LOG|
                                               (invert_flag ? FILESYSTEM_PARSE_INVERT : 0)|
                                               (c->restrict_filesystems_allow_list ? FILESYSTEM_PARSE_ALLOW_LIST : 0),
                                               u->id, NULL, 0);
                                 if (r < 0)
                                         return r;
                         }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "%s=%s%s", name, allow_list ? "" : "~", joined);
                 }
 
                 return 1;
         }
 
         if (streq(name, "MountFlags"))
                 return bus_set_transient_mount_flags(u, name, &c->mount_flags, message, flags, error);
 
         if (streq(name, "NetworkNamespacePath"))
                 return bus_set_transient_path(u, name, &c->network_namespace_path, message, flags, error);
 
         if (streq(name, "IPCNamespacePath"))
                 return bus_set_transient_path(u, name, &c->ipc_namespace_path, message, flags, error);
 
         if (streq(name, "SupplementaryGroups")) {
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 STRV_FOREACH(p, l)
                         if (!isempty(*p) && !valid_user_group_name(*p, VALID_USER_ALLOW_NUMERIC|VALID_USER_RELAX|VALID_USER_WARN))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS,
                                                          "Invalid supplementary group names");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->supplementary_groups = strv_free(c->supplementary_groups);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 _cleanup_free_ char *joined = NULL;
 
                                 r = strv_extend_strv(&c->supplementary_groups, l, true);
                                 if (r < 0)
                                         return -ENOMEM;
 
                                 joined = strv_join(c->supplementary_groups, " ");
                                 if (!joined)
                                         return -ENOMEM;
 
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "%s=%s", name, joined);
                         }
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "SetCredential", "SetCredentialEncrypted")) {
                 bool isempty = true;
 
                 r = sd_bus_message_enter_container(message, 'a', "(say)");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         const char *id;
                         const void *p;
                         size_t sz;
 
                         r = sd_bus_message_enter_container(message, 'r', "say");
                         if (r < 0)
                                 return r;
                         if (r == 0)
                                 break;
 
                         r = sd_bus_message_read(message, "s", &id);
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_read_array(message, 'y', &p, &sz);
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_exit_container(message);
                         if (r < 0)
                                 return r;
 
                         if (!credential_name_valid(id))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Credential ID is invalid: %s", id);
 
                         isempty = false;
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ char *a = NULL, *b = NULL;
                                 _cleanup_free_ void *copy = NULL;
                                 ExecSetCredential *old;
 
                                 copy = memdup(p, sz);
                                 if (!copy)
                                         return -ENOMEM;
 
                                 old = hashmap_get(c->set_credentials, id);
                                 if (old) {
                                         free_and_replace(old->data, copy);
                                         old->size = sz;
                                         old->encrypted = streq(name, "SetCredentialEncrypted");
                                 } else {
                                         _cleanup_(exec_set_credential_freep) ExecSetCredential *sc = NULL;
 
                                         sc = new(ExecSetCredential, 1);
                                         if (!sc)
                                                 return -ENOMEM;
 
                                         *sc = (ExecSetCredential) {
                                                 .id = strdup(id),
                                                 .data = TAKE_PTR(copy),
                                                 .size = sz,
                                                 .encrypted = streq(name, "SetCredentialEncrypted"),
                                         };
 
                                         if (!sc->id)
                                                 return -ENOMEM;
 
                                         r = hashmap_ensure_put(&c->set_credentials, &exec_set_credential_hash_ops, sc->id, sc);
                                         if (r < 0)
                                                 return r;
 
                                         TAKE_PTR(sc);
                                 }
 
                                 a = specifier_escape(id);
                                 if (!a)
                                         return -ENOMEM;
 
                                 b = cescape_length(p, sz);
                                 if (!b)
                                         return -ENOMEM;
 
                                 (void) unit_write_settingf(u, flags, name, "%s=%s:%s", name, a, b);
                         }
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags) && isempty) {
                         c->set_credentials = hashmap_free(c->set_credentials);
                         (void) unit_write_settingf(u, flags, name, "%s=", name);
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "LoadCredential", "LoadCredentialEncrypted")) {
                 bool isempty = true;
 
                 r = sd_bus_message_enter_container(message, 'a', "(ss)");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         const char *id, *source;
 
                         r = sd_bus_message_read(message, "(ss)", &id, &source);
                         if (r < 0)
                                 return r;
                         if (r == 0)
                                 break;
 
                         if (!credential_name_valid(id))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Credential ID is invalid: %s", id);
 
                         if (!(path_is_absolute(source) ? path_is_normalized(source) : credential_name_valid(source)))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Credential source is invalid: %s", source);
 
                         isempty = false;
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ char *copy = NULL;
                                 ExecLoadCredential *old;
 
                                 copy = strdup(source);
                                 if (!copy)
                                         return -ENOMEM;
 
                                 old = hashmap_get(c->load_credentials, id);
                                 if (old) {
                                         free_and_replace(old->path, copy);
                                         old->encrypted = streq(name, "LoadCredentialEncrypted");
                                 } else {
                                         _cleanup_(exec_load_credential_freep) ExecLoadCredential *lc = NULL;
 
                                         lc = new(ExecLoadCredential, 1);
                                         if (!lc)
                                                 return -ENOMEM;
 
                                         *lc = (ExecLoadCredential) {
                                                 .id = strdup(id),
                                                 .path = TAKE_PTR(copy),
                                                 .encrypted = streq(name, "LoadCredentialEncrypted"),
                                         };
 
                                         if (!lc->id)
                                                 return -ENOMEM;
 
                                         r = hashmap_ensure_put(&c->load_credentials, &exec_load_credential_hash_ops, lc->id, lc);
                                         if (r < 0)
                                                 return r;
 
                                         TAKE_PTR(lc);
                                 }
 
                                 (void) unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "%s=%s:%s", name, id, source);
                         }
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags) && isempty) {
                         c->load_credentials = hashmap_free(c->load_credentials);
                         (void) unit_write_settingf(u, flags, name, "%s=", name);
                 }
 
                 return 1;
 
         } else if (streq(name, "SyslogLevel")) {
                 int32_t level;
 
                 r = sd_bus_message_read(message, "i", &level);
                 if (r < 0)
                         return r;
 
                 if (!log_level_is_valid(level))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Log level value out of range");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->syslog_priority = (c->syslog_priority & LOG_FACMASK) | level;
                         unit_write_settingf(u, flags, name, "SyslogLevel=%i", level);
                 }
 
                 return 1;
 
         } else if (streq(name, "SyslogFacility")) {
                 int32_t facility;
 
                 r = sd_bus_message_read(message, "i", &facility);
                 if (r < 0)
                         return r;
 
                 if (!log_facility_unshifted_is_valid(facility))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Log facility value out of range");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->syslog_priority = (facility << 3) | LOG_PRI(c->syslog_priority);
                         unit_write_settingf(u, flags, name, "SyslogFacility=%i", facility);
                 }
 
                 return 1;
 
         } else if (streq(name, "LogNamespace")) {
                 const char *n;
 
                 r = sd_bus_message_read(message, "s", &n);
                 if (r < 0)
                         return r;
 
                 if (!isempty(n) && !log_namespace_name_valid(n))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Log namespace name not valid");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
 
                         if (isempty(n)) {
                                 c->log_namespace = mfree(c->log_namespace);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 r = free_and_strdup(&c->log_namespace, n);
                                 if (r < 0)
                                         return r;
 
                                 unit_write_settingf(u, flags, name, "%s=%s", name, n);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "LogExtraFields")) {
                 size_t n = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "ay");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         _cleanup_free_ void *copy = NULL;
                         struct iovec *t;
                         const char *eq;
                         const void *p;
                         size_t sz;
 
                         /* Note that we expect a byte array for each field, instead of a string. That's because on the
                          * lower-level journal fields can actually contain binary data and are not restricted to text,
                          * and we should not "lose precision" in our types on the way. That said, I am pretty sure
                          * actually encoding binary data as unit metadata is not a good idea. Hence we actually refuse
                          * any actual binary data, and only accept UTF-8. This allows us to eventually lift this
                          * limitation, should a good, valid usecase arise. */
 
                         r = sd_bus_message_read_array(message, 'y', &p, &sz);
                         if (r < 0)
                                 return r;
                         if (r == 0)
                                 break;
 
                         if (memchr(p, 0, sz))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Journal field contains zero byte");
 
                         eq = memchr(p, '=', sz);
                         if (!eq)
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Journal field contains no '=' character");
                         if (!journal_field_valid(p, eq - (const char*) p, false))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Journal field invalid");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 t = reallocarray(c->log_extra_fields, c->n_log_extra_fields+1, sizeof(struct iovec));
                                 if (!t)
                                         return -ENOMEM;
                                 c->log_extra_fields = t;
                         }
 
                         copy = malloc(sz + 1);
                         if (!copy)
                                 return -ENOMEM;
 
                         memcpy(copy, p, sz);
                         ((uint8_t*) copy)[sz] = 0;
 
                         if (!utf8_is_valid(copy))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Journal field is not valid UTF-8");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 c->log_extra_fields[c->n_log_extra_fields++] = IOVEC_MAKE(copy, sz);
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS|UNIT_ESCAPE_C, name, "LogExtraFields=%s", (char*) copy);
 
                                 copy = NULL;
                         }
 
                         n++;
                 }
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags) && n == 0) {
                         exec_context_free_log_extra_fields(c);
                         unit_write_setting(u, flags, name, "LogExtraFields=");
                 }
 
                 return 1;
         }
 
 #if HAVE_SECCOMP
 
         if (streq(name, "SystemCallErrorNumber"))
                 return bus_set_transient_errno(u, name, &c->syscall_errno, message, flags, error);
 
         if (streq(name, "SystemCallFilter")) {
                 int allow_list;
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_enter_container(message, 'r', "bas");
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read(message, "b", &allow_list);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
                         SeccompParseFlags invert_flag = allow_list ? 0 : SECCOMP_PARSE_INVERT;
 
                         if (strv_isempty(l)) {
                                 c->syscall_allow_list = false;
                                 c->syscall_filter = hashmap_free(c->syscall_filter);
 
                                 unit_write_settingf(u, flags, name, "SystemCallFilter=");
                                 return 1;
                         }
 
                         if (!c->syscall_filter) {
                                 c->syscall_filter = hashmap_new(NULL);
                                 if (!c->syscall_filter)
                                         return log_oom();
 
                                 c->syscall_allow_list = allow_list;
 
                                 if (c->syscall_allow_list) {
                                         r = seccomp_parse_syscall_filter("@default",
                                                                          -1,
                                                                          c->syscall_filter,
                                                                          SECCOMP_PARSE_PERMISSIVE |
                                                                          SECCOMP_PARSE_ALLOW_LIST,
                                                                          u->id,
                                                                          NULL, 0);
                                         if (r < 0)
                                                 return r;
                                 }
                         }
 
                         STRV_FOREACH(s, l) {
                                 _cleanup_free_ char *n = NULL;
                                 int e;
 
                                 r = parse_syscall_and_errno(*s, &n, &e);
                                 if (r < 0)
                                         return r;
 
                                 if (allow_list && e >= 0)
                                         return -EINVAL;
 
                                 r = seccomp_parse_syscall_filter(n,
                                                                  e,
                                                                  c->syscall_filter,
                                                                  SECCOMP_PARSE_LOG | SECCOMP_PARSE_PERMISSIVE |
                                                                  invert_flag |
                                                                  (c->syscall_allow_list ? SECCOMP_PARSE_ALLOW_LIST : 0),
                                                                  u->id,
                                                                  NULL, 0);
                                 if (r < 0)
                                         return r;
                         }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "SystemCallFilter=%s%s", allow_list ? "" : "~", joined);
                 }
 
                 return 1;
 
         } else if (streq(name, "SystemCallLog")) {
                 int allow_list;
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_enter_container(message, 'r', "bas");
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read(message, "b", &allow_list);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
                         SeccompParseFlags invert_flag = allow_list ? 0 : SECCOMP_PARSE_INVERT;
 
                         if (strv_isempty(l)) {
                                 c->syscall_log_allow_list = false;
                                 c->syscall_log = hashmap_free(c->syscall_log);
 
                                 unit_write_settingf(u, flags, name, "SystemCallLog=");
                                 return 1;
                         }
 
                         if (!c->syscall_log) {
                                 c->syscall_log = hashmap_new(NULL);
                                 if (!c->syscall_log)
                                         return log_oom();
 
                                 c->syscall_log_allow_list = allow_list;
                         }
 
                         STRV_FOREACH(s, l) {
                                 r = seccomp_parse_syscall_filter(*s,
                                                                  -1, /* errno not used */
                                                                  c->syscall_log,
                                                                  SECCOMP_PARSE_LOG | SECCOMP_PARSE_PERMISSIVE |
                                                                  invert_flag |
                                                                  (c->syscall_log_allow_list ? SECCOMP_PARSE_ALLOW_LIST : 0),
                                                                  u->id,
                                                                  NULL, 0);
                                 if (r < 0)
                                         return r;
                         }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "SystemCallLog=%s%s", allow_list ? "" : "~", joined);
                 }
 
                 return 1;
 
         } else if (streq(name, "SystemCallArchitectures")) {
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
 
                         if (strv_isempty(l))
                                 c->syscall_archs = set_free(c->syscall_archs);
                         else
                                 STRV_FOREACH(s, l) {
                                         uint32_t a;
 
                                         r = seccomp_arch_from_string(*s, &a);
                                         if (r < 0)
                                                 return r;
 
                                         r = set_ensure_put(&c->syscall_archs, NULL, UINT32_TO_PTR(a + 1));
                                         if (r < 0)
                                                 return r;
                                 }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "%s=%s", name, joined);
                 }
 
                 return 1;
 
         } else if (streq(name, "RestrictAddressFamilies")) {
                 _cleanup_strv_free_ char **l = NULL;
                 int allow_list;
 
                 r = sd_bus_message_enter_container(message, 'r', "bas");
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read(message, "b", &allow_list);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *joined = NULL;
 
                         if (strv_isempty(l)) {
                                 c->address_families_allow_list = allow_list;
                                 c->address_families = set_free(c->address_families);
 
                                 unit_write_settingf(u, flags, name, "RestrictAddressFamilies=%s",
                                                     allow_list ? "none" : "");
                                 return 1;
                         }
 
                         if (!c->address_families) {
                                 c->address_families = set_new(NULL);
                                 if (!c->address_families)
                                         return log_oom();
 
                                 c->address_families_allow_list = allow_list;
                         }
 
                         STRV_FOREACH(s, l) {
                                 int af;
 
                                 af = af_from_name(*s);
                                 if (af < 0)
                                         return af;
 
                                 if (allow_list == c->address_families_allow_list) {
                                         r = set_put(c->address_families, INT_TO_PTR(af));
                                         if (r < 0)
                                                 return r;
                                 } else
                                         set_remove(c->address_families, INT_TO_PTR(af));
                         }
 
                         joined = strv_join(l, " ");
                         if (!joined)
                                 return -ENOMEM;
 
                         unit_write_settingf(u, flags, name, "RestrictAddressFamilies=%s%s", allow_list ? "" : "~", joined);
                 }
 
                 return 1;
         }
 #endif
         if (STR_IN_SET(name, "CPUAffinity", "NUMAMask")) {
                 const void *a;
                 size_t n;
                 bool affinity = streq(name, "CPUAffinity");
                 _cleanup_(cpu_set_reset) CPUSet set = {};
 
                 r = sd_bus_message_read_array(message, 'y', &a, &n);
                 if (r < 0)
                         return r;
 
                 r = cpu_set_from_dbus(a, n, &set);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (n == 0) {
                                 cpu_set_reset(affinity ? &c->cpu_set : &c->numa_policy.nodes);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 _cleanup_free_ char *str = NULL;
 
                                 str = cpu_set_to_string(&set);
                                 if (!str)
                                         return -ENOMEM;
 
                                 /* We forego any optimizations here, and always create the structure using
                                  * cpu_set_add_all(), because we don't want to care if the existing size we
                                  * got over dbus is appropriate. */
                                 r = cpu_set_add_all(affinity ? &c->cpu_set : &c->numa_policy.nodes, &set);
                                 if (r < 0)
                                         return r;
 
                                 unit_write_settingf(u, flags, name, "%s=%s", name, str);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "CPUAffinityFromNUMA")) {
                 int q;
 
                 r = sd_bus_message_read_basic(message, 'b', &q);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->cpu_affinity_from_numa = q;
                         unit_write_settingf(u, flags, name, "%s=%s", "CPUAffinity", "numa");
                 }
 
                 return 1;
 
         } else if (streq(name, "NUMAPolicy")) {
                 int32_t type;
 
                 r = sd_bus_message_read(message, "i", &type);
                 if (r < 0)
                         return r;
 
                 if (!mpol_is_valid(type))
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid NUMAPolicy value: %i", type);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags))
                         c->numa_policy.type = type;
 
                 return 1;
 
         } else if (streq(name, "Nice")) {
                 int32_t q;
 
                 r = sd_bus_message_read(message, "i", &q);
                 if (r < 0)
                         return r;
 
                 if (!nice_is_valid(q))
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid Nice value: %i", q);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->nice = q;
                         c->nice_set = true;
 
                         unit_write_settingf(u, flags, name, "Nice=%i", q);
                 }
 
                 return 1;
 
         } else if (streq(name, "CPUSchedulingPolicy")) {
                 int32_t q;
 
                 r = sd_bus_message_read(message, "i", &q);
                 if (r < 0)
                         return r;
 
                 if (!sched_policy_is_valid(q))
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid CPU scheduling policy: %i", q);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *s = NULL;
 
                         r = sched_policy_to_string_alloc(q, &s);
                         if (r < 0)
                                 return r;
 
                         c->cpu_sched_policy = q;
                         c->cpu_sched_priority = CLAMP(c->cpu_sched_priority, sched_get_priority_min(q), sched_get_priority_max(q));
                         c->cpu_sched_set = true;
 
                         unit_write_settingf(u, flags, name, "CPUSchedulingPolicy=%s", s);
                 }
 
                 return 1;
 
         } else if (streq(name, "CPUSchedulingPriority")) {
                 int32_t p, min, max;
 
                 r = sd_bus_message_read(message, "i", &p);
                 if (r < 0)
                         return r;
 
                 min = sched_get_priority_min(c->cpu_sched_policy);
                 max = sched_get_priority_max(c->cpu_sched_policy);
                 if (p < min || p > max)
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid CPU scheduling priority: %i", p);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->cpu_sched_priority = p;
                         c->cpu_sched_set = true;
 
                         unit_write_settingf(u, flags, name, "CPUSchedulingPriority=%i", p);
                 }
 
                 return 1;
 
         } else if (streq(name, "IOSchedulingClass")) {
                 int32_t q;
 
                 r = sd_bus_message_read(message, "i", &q);
                 if (r < 0)
                         return r;
 
                 if (!ioprio_class_is_valid(q))
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid IO scheduling class: %i", q);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *s = NULL;
 
                         r = ioprio_class_to_string_alloc(q, &s);
                         if (r < 0)
                                 return r;
 
                         c->ioprio = ioprio_normalize(ioprio_prio_value(q, ioprio_prio_data(c->ioprio)));
                         c->ioprio_set = true;
 
                         unit_write_settingf(u, flags, name, "IOSchedulingClass=%s", s);
                 }
 
                 return 1;
 
         } else if (streq(name, "IOSchedulingPriority")) {
                 int32_t p;
 
                 r = sd_bus_message_read(message, "i", &p);
                 if (r < 0)
                         return r;
 
                 if (!ioprio_priority_is_valid(p))
                         return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid IO scheduling priority: %i", p);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->ioprio = ioprio_normalize(ioprio_prio_value(ioprio_prio_class(c->ioprio), p));
                         c->ioprio_set = true;
 
                         unit_write_settingf(u, flags, name, "IOSchedulingPriority=%i", p);
                 }
 
                 return 1;
 
         } else if (streq(name, "MountAPIVFS")) {
                 bool b;
 
                 r = bus_set_transient_bool(u, name, &b, message, flags, error);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->mount_apivfs = b;
                         c->mount_apivfs_set = true;
                 }
 
                 return 1;
 
         } else if (streq(name, "WorkingDirectory")) {
                 const char *s;
                 bool missing_ok;
 
                 r = sd_bus_message_read(message, "s", &s);
                 if (r < 0)
                         return r;
 
                 if (s[0] == '-') {
                         missing_ok = true;
                         s++;
                 } else
                         missing_ok = false;
 
                 if (!isempty(s) && !streq(s, "~") && !path_is_absolute(s))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "WorkingDirectory= expects an absolute path or '~'");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (streq(s, "~")) {
                                 c->working_directory = mfree(c->working_directory);
                                 c->working_directory_home = true;
                         } else {
                                 r = free_and_strdup(&c->working_directory, empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 c->working_directory_home = false;
                         }
 
                         c->working_directory_missing_ok = missing_ok;
                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "WorkingDirectory=%s%s", missing_ok ? "-" : "", s);
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name,
                               "StandardInputFileDescriptorName", "StandardOutputFileDescriptorName", "StandardErrorFileDescriptorName")) {
                 const char *s;
 
                 r = sd_bus_message_read(message, "s", &s);
                 if (r < 0)
                         return r;
 
                 if (!isempty(s) && !fdname_is_valid(s))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid file descriptor name");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
 
                         if (streq(name, "StandardInputFileDescriptorName")) {
                                 r = free_and_strdup(c->stdio_fdname + STDIN_FILENO, empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 c->std_input = EXEC_INPUT_NAMED_FD;
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardInput=fd:%s", exec_context_fdname(c, STDIN_FILENO));
 
                         } else if (streq(name, "StandardOutputFileDescriptorName")) {
                                 r = free_and_strdup(c->stdio_fdname + STDOUT_FILENO, empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 c->std_output = EXEC_OUTPUT_NAMED_FD;
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardOutput=fd:%s", exec_context_fdname(c, STDOUT_FILENO));
 
                         } else {
                                 assert(streq(name, "StandardErrorFileDescriptorName"));
 
                                 r = free_and_strdup(&c->stdio_fdname[STDERR_FILENO], empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 c->std_error = EXEC_OUTPUT_NAMED_FD;
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardError=fd:%s", exec_context_fdname(c, STDERR_FILENO));
                         }
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name,
                               "StandardInputFile",
                               "StandardOutputFile", "StandardOutputFileToAppend", "StandardOutputFileToTruncate",
                               "StandardErrorFile", "StandardErrorFileToAppend", "StandardErrorFileToTruncate")) {
                 const char *s;
 
                 r = sd_bus_message_read(message, "s", &s);
                 if (r < 0)
                         return r;
 
                 if (!isempty(s)) {
                         if (!path_is_absolute(s))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path %s is not absolute", s);
                         if (!path_is_normalized(s))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path %s is not normalized", s);
                 }
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
 
                         if (streq(name, "StandardInputFile")) {
                                 r = free_and_strdup(&c->stdio_file[STDIN_FILENO], empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 c->std_input = EXEC_INPUT_FILE;
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardInput=file:%s", s);
 
                         } else if (STR_IN_SET(name, "StandardOutputFile", "StandardOutputFileToAppend", "StandardOutputFileToTruncate")) {
                                 r = free_and_strdup(&c->stdio_file[STDOUT_FILENO], empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 if (streq(name, "StandardOutputFile")) {
                                         c->std_output = EXEC_OUTPUT_FILE;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardOutput=file:%s", s);
                                 } else if (streq(name, "StandardOutputFileToAppend")) {
                                         c->std_output = EXEC_OUTPUT_FILE_APPEND;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardOutput=append:%s", s);
                                 } else {
                                         assert(streq(name, "StandardOutputFileToTruncate"));
                                         c->std_output = EXEC_OUTPUT_FILE_TRUNCATE;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardOutput=truncate:%s", s);
                                 }
                         } else {
                                 assert(STR_IN_SET(name, "StandardErrorFile", "StandardErrorFileToAppend", "StandardErrorFileToTruncate"));
 
                                 r = free_and_strdup(&c->stdio_file[STDERR_FILENO], empty_to_null(s));
                                 if (r < 0)
                                         return r;
 
                                 if (streq(name, "StandardErrorFile")) {
                                         c->std_error = EXEC_OUTPUT_FILE;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardError=file:%s", s);
                                 } else if (streq(name, "StandardErrorFileToAppend")) {
                                         c->std_error = EXEC_OUTPUT_FILE_APPEND;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardError=append:%s", s);
                                 } else {
                                         assert(streq(name, "StandardErrorFileToTruncate"));
                                         c->std_error = EXEC_OUTPUT_FILE_TRUNCATE;
                                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "StandardError=truncate:%s", s);
                                 }
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "StandardInputData")) {
                 const void *p;
                 size_t sz;
 
                 r = sd_bus_message_read_array(message, 'y', &p, &sz);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         _cleanup_free_ char *encoded = NULL;
 
                         if (sz == 0) {
                                 c->stdin_data = mfree(c->stdin_data);
                                 c->stdin_data_size = 0;
 
                                 unit_write_settingf(u, flags, name, "StandardInputData=");
                         } else {
                                 void *q;
                                 ssize_t n;
 
                                 if (c->stdin_data_size + sz < c->stdin_data_size || /* check for overflow */
                                     c->stdin_data_size + sz > EXEC_STDIN_DATA_MAX)
                                         return -E2BIG;
 
                                 n = base64mem(p, sz, &encoded);
                                 if (n < 0)
                                         return (int) n;
 
                                 q = realloc(c->stdin_data, c->stdin_data_size + sz);
                                 if (!q)
                                         return -ENOMEM;
 
                                 memcpy((uint8_t*) q + c->stdin_data_size, p, sz);
 
                                 c->stdin_data = q;
                                 c->stdin_data_size += sz;
 
                                 unit_write_settingf(u, flags, name, "StandardInputData=%s", encoded);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "Environment")) {
 
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 if (!strv_env_is_valid(l))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid environment block.");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->environment = strv_free(c->environment);
                                 unit_write_setting(u, flags, name, "Environment=");
                         } else {
                                 _cleanup_free_ char *joined = NULL;
                                 char **e;
 
                                 joined = unit_concat_strv(l, UNIT_ESCAPE_SPECIFIERS|UNIT_ESCAPE_C);
                                 if (!joined)
                                         return -ENOMEM;
 
                                 e = strv_env_merge(c->environment, l);
                                 if (!e)
                                         return -ENOMEM;
 
                                 strv_free_and_replace(c->environment, e);
                                 unit_write_settingf(u, flags, name, "Environment=%s", joined);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "UnsetEnvironment")) {
 
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 if (!strv_env_name_or_assignment_is_valid(l))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid UnsetEnvironment= list.");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->unset_environment = strv_free(c->unset_environment);
                                 unit_write_setting(u, flags, name, "UnsetEnvironment=");
                         } else {
                                 _cleanup_free_ char *joined = NULL;
                                 char **e;
 
                                 joined = unit_concat_strv(l, UNIT_ESCAPE_SPECIFIERS|UNIT_ESCAPE_C);
                                 if (!joined)
                                         return -ENOMEM;
 
                                 e = strv_env_merge(c->unset_environment, l);
                                 if (!e)
                                         return -ENOMEM;
 
                                 strv_free_and_replace(c->unset_environment, e);
                                 unit_write_settingf(u, flags, name, "UnsetEnvironment=%s", joined);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "OOMScoreAdjust")) {
                 int oa;
 
                 r = sd_bus_message_read(message, "i", &oa);
                 if (r < 0)
                         return r;
 
                 if (!oom_score_adjust_is_valid(oa))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "OOM score adjust value out of range");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->oom_score_adjust = oa;
                         c->oom_score_adjust_set = true;
                         unit_write_settingf(u, flags, name, "OOMScoreAdjust=%i", oa);
                 }
 
                 return 1;
 
         } else if (streq(name, "CoredumpFilter")) {
                 uint64_t f;
 
                 r = sd_bus_message_read(message, "t", &f);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         c->coredump_filter = f;
                         c->coredump_filter_set = true;
                         unit_write_settingf(u, flags, name, "CoredumpFilter=0x%"PRIx64, f);
                 }
 
                 return 1;
 
         } else if (streq(name, "EnvironmentFiles")) {
 
                 _cleanup_free_ char *joined = NULL;
                 _cleanup_fclose_ FILE *f = NULL;
                 _cleanup_strv_free_ char **l = NULL;
                 size_t size = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(sb)");
                 if (r < 0)
                         return r;
 
                 f = open_memstream_unlocked(&joined, &size);
                 if (!f)
                         return -ENOMEM;
 
                 fputs("EnvironmentFile=\n", f);
 
                 STRV_FOREACH(i, c->environment_files) {
                         _cleanup_free_ char *q = NULL;
 
                         q = specifier_escape(*i);
                         if (!q)
                                 return -ENOMEM;
 
                         fprintf(f, "EnvironmentFile=%s\n", q);
                 }
 
                 while ((r = sd_bus_message_enter_container(message, 'r', "sb")) > 0) {
                         const char *path;
                         int b;
 
                         r = sd_bus_message_read(message, "sb", &path, &b);
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_exit_container(message);
                         if (r < 0)
                                 return r;
 
                         if (!path_is_absolute(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Path %s is not absolute.", path);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ char *q = NULL, *buf = NULL;
 
                                 buf = strjoin(b ? "-" : "", path);
                                 if (!buf)
                                         return -ENOMEM;
 
                                 q = specifier_escape(buf);
                                 if (!q)
                                         return -ENOMEM;
 
                                 fprintf(f, "EnvironmentFile=%s\n", q);
 
                                 r = strv_consume(&l, TAKE_PTR(buf));
                                 if (r < 0)
                                         return r;
                         }
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 r = fflush_and_check(f);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->environment_files = strv_free(c->environment_files);
                                 unit_write_setting(u, flags, name, "EnvironmentFile=");
                         } else {
                                 r = strv_extend_strv(&c->environment_files, l, true);
                                 if (r < 0)
                                         return r;
 
                                 unit_write_setting(u, flags, name, joined);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "PassEnvironment")) {
 
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 if (!strv_env_name_is_valid(l))
                         return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid PassEnvironment= block.");
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->pass_environment = strv_free(c->pass_environment);
                                 unit_write_setting(u, flags, name, "PassEnvironment=");
                         } else {
                                 _cleanup_free_ char *joined = NULL;
 
                                 r = strv_extend_strv(&c->pass_environment, l, true);
                                 if (r < 0)
                                         return r;
 
                                 /* We write just the new settings out to file, with unresolved specifiers. */
                                 joined = unit_concat_strv(l, UNIT_ESCAPE_SPECIFIERS);
                                 if (!joined)
                                         return -ENOMEM;
 
                                 unit_write_settingf(u, flags, name, "PassEnvironment=%s", joined);
                         }
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "ReadWriteDirectories", "ReadOnlyDirectories", "InaccessibleDirectories",
                               "ReadWritePaths", "ReadOnlyPaths", "InaccessiblePaths", "ExecPaths", "NoExecPaths",
                               "ExtensionDirectories")) {
                 _cleanup_strv_free_ char **l = NULL;
                 char ***dirs;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 STRV_FOREACH(p, l) {
                         char *i = *p;
                         size_t offset;
 
                         offset = i[0] == '-';
                         offset += i[offset] == '+';
                         if (!path_is_absolute(i + offset))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid %s", name);
 
                         path_simplify(i + offset);
                 }
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (STR_IN_SET(name, "ReadWriteDirectories", "ReadWritePaths"))
                                 dirs = &c->read_write_paths;
                         else if (STR_IN_SET(name, "ReadOnlyDirectories", "ReadOnlyPaths"))
                                 dirs = &c->read_only_paths;
                         else if (streq(name, "ExecPaths"))
                                 dirs = &c->exec_paths;
                         else if (streq(name, "NoExecPaths"))
                                 dirs = &c->no_exec_paths;
                         else if (streq(name, "ExtensionDirectories"))
                                 dirs = &c->extension_directories;
                         else /* "InaccessiblePaths" */
                                 dirs = &c->inaccessible_paths;
 
                         if (strv_isempty(l)) {
                                 *dirs = strv_free(*dirs);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 _cleanup_free_ char *joined = NULL;
 
                                 joined = unit_concat_strv(l, UNIT_ESCAPE_SPECIFIERS);
                                 if (!joined)
                                         return -ENOMEM;
 
                                 r = strv_extend_strv(dirs, l, true);
                                 if (r < 0)
                                         return -ENOMEM;
 
                                 unit_write_settingf(u, flags, name, "%s=%s", name, joined);
                         }
                 }
 
                 return 1;
 
         } else if (streq(name, "ExecSearchPath")) {
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 STRV_FOREACH(p, l)
                         if (!path_is_absolute(*p) || !path_is_normalized(*p) || strchr(*p, ':'))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid %s", name);
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (strv_isempty(l)) {
                                 c->exec_search_path = strv_free(c->exec_search_path);
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "ExecSearchPath=");
                         } else {
                                 _cleanup_free_ char *joined = NULL;
                                 r = strv_extend_strv(&c->exec_search_path, l, true);
                                 if (r < 0)
                                         return -ENOMEM;
                                 joined = strv_join(c->exec_search_path, ":");
                                 if (!joined)
                                         return log_oom();
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "ExecSearchPath=%s", joined);
                         }
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "RuntimeDirectory", "StateDirectory", "CacheDirectory", "LogsDirectory", "ConfigurationDirectory")) {
                 _cleanup_strv_free_ char **l = NULL;
 
                 r = sd_bus_message_read_strv(message, &l);
                 if (r < 0)
                         return r;
 
                 STRV_FOREACH(p, l) {
                         if (!path_is_normalized(*p))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= path is not normalized: %s", name, *p);
 
                         if (path_is_absolute(*p))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= path is absolute: %s", name, *p);
 
                         if (path_startswith(*p, "private"))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "%s= path can't be 'private': %s", name, *p);
                 }
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         ExecDirectoryType i;
                         ExecDirectory *d;
 
                         assert_se((i = exec_directory_type_from_string(name)) >= 0);
                         d = c->directories + i;
 
                         if (strv_isempty(l)) {
                                 exec_directory_done(d);
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 _cleanup_free_ char *joined = NULL;
 
                                 STRV_FOREACH(source, l) {
                                         r = exec_directory_add(&d->items, &d->n_items, *source, NULL);
                                         if (r < 0)
                                                 return log_oom();
                                 }
 
                                 joined = unit_concat_strv(l, UNIT_ESCAPE_SPECIFIERS);
                                 if (!joined)
                                         return -ENOMEM;
 
                                 unit_write_settingf(u, flags, name, "%s=%s", name, joined);
                         }
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "AppArmorProfile", "SmackProcessLabel")) {
                 int ignore;
                 const char *s;
 
                 r = sd_bus_message_read(message, "(bs)", &ignore, &s);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         char **p;
                         bool *b;
 
                         if (streq(name, "AppArmorProfile")) {
                                 p = &c->apparmor_profile;
                                 b = &c->apparmor_profile_ignore;
                         } else { /* "SmackProcessLabel" */
                                 p = &c->smack_process_label;
                                 b = &c->smack_process_label_ignore;
                         }
 
                         if (isempty(s)) {
                                 *p = mfree(*p);
                                 *b = false;
                         } else {
                                 if (free_and_strdup(p, s) < 0)
                                         return -ENOMEM;
                                 *b = ignore;
                         }
 
                         unit_write_settingf(u, flags|UNIT_ESCAPE_SPECIFIERS, name, "%s=%s%s", name, ignore ? "-" : "", strempty(s));
                 }
 
                 return 1;
 
         } else if (STR_IN_SET(name, "BindPaths", "BindReadOnlyPaths")) {
                 char *source, *destination;
                 int ignore_enoent;
                 uint64_t mount_flags;
                 bool empty = true;
 
                 r = sd_bus_message_enter_container(message, 'a', "(ssbt)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(ssbt)", &source, &destination, &ignore_enoent, &mount_flags)) > 0) {
 
                         if (!path_is_absolute(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not absolute.", source);
                         if (!path_is_absolute(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is not absolute.", destination);
                         if (!IN_SET(mount_flags, 0, MS_REC))
                                 return sd_bus_error_set(error, SD_BUS_ERROR_INVALID_ARGS, "Unknown mount flags.");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 r = bind_mount_add(&c->bind_mounts, &c->n_bind_mounts,
                                                    &(BindMount) {
                                                            .source = source,
                                                            .destination = destination,
                                                            .read_only = !!strstr(name, "ReadOnly"),
                                                            .recursive = !!(mount_flags & MS_REC),
                                                            .ignore_enoent = ignore_enoent,
                                                    });
                                 if (r < 0)
                                         return r;
 
                                 unit_write_settingf(
                                                 u, flags|UNIT_ESCAPE_SPECIFIERS, name,
                                                 "%s=%s%s:%s:%s",
                                                 name,
                                                 ignore_enoent ? "-" : "",
                                                 source,
                                                 destination,
                                                 (mount_flags & MS_REC) ? "rbind" : "norbind");
                         }
 
                         empty = false;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (empty) {
                         bind_mount_free_many(c->bind_mounts, c->n_bind_mounts);
                         c->bind_mounts = NULL;
                         c->n_bind_mounts = 0;
 
                         unit_write_settingf(u, flags, name, "%s=", name);
                 }
 
                 return 1;
 
         } else if (streq(name, "TemporaryFileSystem")) {
                 const char *path, *options;
                 bool empty = true;
 
                 r = sd_bus_message_enter_container(message, 'a', "(ss)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(ss)", &path, &options)) > 0) {
 
                         if (!path_is_absolute(path))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Mount point %s is not absolute.", path);
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 r = temporary_filesystem_add(&c->temporary_filesystems, &c->n_temporary_filesystems, path, options);
                                 if (r < 0)
                                         return r;
 
                                 unit_write_settingf(
                                                 u, flags|UNIT_ESCAPE_SPECIFIERS, name,
                                                 "%s=%s:%s",
                                                 name,
                                                 path,
                                                 options);
                         }
 
                         empty = false;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (empty) {
                         temporary_filesystem_free_many(c->temporary_filesystems, c->n_temporary_filesystems);
                         c->temporary_filesystems = NULL;
                         c->n_temporary_filesystems = 0;
 
                         unit_write_settingf(u, flags, name, "%s=", name);
                 }
 
                 return 1;
 
-        } else if (streq(name, "DynamicUserNFTSet")) {
-                int nfproto;
-                const char *table, *set;
-                bool empty = true;
-
-                r = sd_bus_message_enter_container(message, 'a', "(iss)");
-                if (r < 0)
-                        return r;
-
-                while ((r = sd_bus_message_read(message, "(iss)", &nfproto, &table, &set)) > 0) {
-                        const char *nfproto_name;
-
-                        nfproto_name = nfproto_to_string(nfproto);
-                        if (!nfproto_name)
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid protocol %d.", nfproto);
-
-                        if (nft_identifier_bad(table))
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid NFT table name %s.", table);
-
-                        if (nft_identifier_bad(set))
-                                return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Invalid NFT set name %s.", set);
-
-                        if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
-                                r = nft_set_context_add(&c->dynamic_user_nft_set_context, &c->n_dynamic_user_nft_set_contexts, nfproto, table, set);
-                                if (r < 0)
-                                        return r;
-
-                                unit_write_settingf(
-                                                u, flags|UNIT_ESCAPE_SPECIFIERS, name,
-                                                "%s=%s:%s:%s",
-                                                name,
-                                                nfproto_name,
-                                                table,
-                                                set);
-                        }
-
-                        empty = false;
-                }
-                if (r < 0)
-                        return r;
-
-                r = sd_bus_message_exit_container(message);
-                if (r < 0)
-                        return r;
-
-                if (empty) {
-                        c->dynamic_user_nft_set_context = nft_set_context_free_many(c->dynamic_user_nft_set_context, &c->n_dynamic_user_nft_set_contexts);
-                        unit_write_settingf(u, flags, name, "%s=", name);
-                }
-
-                return 1;
-
         } else if ((suffix = startswith(name, "Limit"))) {
                 const char *soft = NULL;
                 int ri;
 
                 ri = rlimit_from_string(suffix);
                 if (ri < 0) {
                         soft = endswith(suffix, "Soft");
                         if (soft) {
                                 const char *n;
 
                                 n = strndupa_safe(suffix, soft - suffix);
                                 ri = rlimit_from_string(n);
                                 if (ri >= 0)
                                         name = strjoina("Limit", n);
                         }
                 }
 
                 if (ri >= 0) {
                         uint64_t rl;
                         rlim_t x;
 
                         r = sd_bus_message_read(message, "t", &rl);
                         if (r < 0)
                                 return r;
 
                         if (rl == UINT64_MAX)
                                 x = RLIM_INFINITY;
                         else {
                                 x = (rlim_t) rl;
 
                                 if ((uint64_t) x != rl)
                                         return -ERANGE;
                         }
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ char *f = NULL;
                                 struct rlimit nl;
 
                                 if (c->rlimit[ri]) {
                                         nl = *c->rlimit[ri];
 
                                         if (soft)
                                                 nl.rlim_cur = x;
                                         else
                                                 nl.rlim_max = x;
                                 } else
                                         /* When the resource limit is not initialized yet, then assign the value to both fields */
                                         nl = (struct rlimit) {
                                                 .rlim_cur = x,
                                                 .rlim_max = x,
                                         };
 
                                 r = rlimit_format(&nl, &f);
                                 if (r < 0)
                                         return r;
 
                                 if (c->rlimit[ri])
                                         *c->rlimit[ri] = nl;
                                 else {
                                         c->rlimit[ri] = newdup(struct rlimit, &nl, 1);
                                         if (!c->rlimit[ri])
                                                 return -ENOMEM;
                                 }
 
                                 unit_write_settingf(u, flags, name, "%s=%s", name, f);
                         }
 
                         return 1;
                 }
 
         } else if (streq(name, "MountImages")) {
                 _cleanup_free_ char *format_str = NULL;
                 MountImage *mount_images = NULL;
                 size_t n_mount_images = 0;
                 char *source, *destination;
                 int permissive;
 
                 r = sd_bus_message_enter_container(message, 'a', "(ssba(ss))");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         _cleanup_(mount_options_free_allp) MountOptions *options = NULL;
                         _cleanup_free_ char *source_escaped = NULL, *destination_escaped = NULL;
                         char *tuple;
 
                         r = sd_bus_message_enter_container(message, 'r', "ssba(ss)");
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_read(message, "ssb", &source, &destination, &permissive);
                         if (r <= 0)
                                 break;
 
                         if (!path_is_absolute(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not absolute.", source);
                         if (!path_is_normalized(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not normalized.", source);
                         if (!path_is_absolute(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is not absolute.", destination);
                         if (!path_is_normalized(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is not normalized.", destination);
 
                         /* Need to store them in the unit with the escapes, so that they can be parsed again */
                         source_escaped = shell_escape(source, ":");
                         if (!source_escaped)
                                 return -ENOMEM;
                         destination_escaped = shell_escape(destination, ":");
                         if (!destination_escaped)
                                 return -ENOMEM;
 
                         tuple = strjoin(format_str,
                                         format_str ? " " : "",
                                         permissive ? "-" : "",
                                         source_escaped,
                                         ":",
                                         destination_escaped);
                         if (!tuple)
                                 return -ENOMEM;
                         free_and_replace(format_str, tuple);
 
                         r = bus_read_mount_options(message, error, &options, &format_str, ":");
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_exit_container(message);
                         if (r < 0)
                                 return r;
 
                         r = mount_image_add(&mount_images, &n_mount_images,
                                             &(MountImage) {
                                                     .source = source,
                                                     .destination = destination,
                                                     .mount_options = options,
                                                     .ignore_enoent = permissive,
                                                     .type = MOUNT_IMAGE_DISCRETE,
                                             });
                         if (r < 0)
                                 return r;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (n_mount_images == 0) {
                                 c->mount_images = mount_image_free_many(c->mount_images, &c->n_mount_images);
 
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 for (size_t i = 0; i < n_mount_images; ++i) {
                                         r = mount_image_add(&c->mount_images, &c->n_mount_images, &mount_images[i]);
                                         if (r < 0)
                                                 return r;
                                 }
 
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_C|UNIT_ESCAPE_SPECIFIERS,
                                                     name,
                                                     "%s=%s",
                                                     name,
                                                     format_str);
                         }
                 }
 
                 mount_images = mount_image_free_many(mount_images, &n_mount_images);
 
                 return 1;
         } else if (streq(name, "ExtensionImages")) {
                 _cleanup_free_ char *format_str = NULL;
                 MountImage *extension_images = NULL;
                 size_t n_extension_images = 0;
 
                 r = sd_bus_message_enter_container(message, 'a', "(sba(ss))");
                 if (r < 0)
                         return r;
 
                 for (;;) {
                         _cleanup_(mount_options_free_allp) MountOptions *options = NULL;
                         _cleanup_free_ char *source_escaped = NULL;
                         char *source, *tuple;
                         int permissive;
 
                         r = sd_bus_message_enter_container(message, 'r', "sba(ss)");
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_read(message, "sb", &source, &permissive);
                         if (r <= 0)
                                 break;
 
                         if (!path_is_absolute(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not absolute.", source);
                         if (!path_is_normalized(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not normalized.", source);
 
                         /* Need to store them in the unit with the escapes, so that they can be parsed again */
                         source_escaped = shell_escape(source, ":");
                         if (!source_escaped)
                                 return -ENOMEM;
 
                         tuple = strjoin(format_str,
                                         format_str ? " " : "",
                                         permissive ? "-" : "",
                                         source_escaped);
                         if (!tuple)
                                 return -ENOMEM;
                         free_and_replace(format_str, tuple);
 
                         r = bus_read_mount_options(message, error, &options, &format_str, ":");
                         if (r < 0)
                                 return r;
 
                         r = sd_bus_message_exit_container(message);
                         if (r < 0)
                                 return r;
 
                         r = mount_image_add(&extension_images, &n_extension_images,
                                             &(MountImage) {
                                                     .source = source,
                                                     .mount_options = options,
                                                     .ignore_enoent = permissive,
                                                     .type = MOUNT_IMAGE_EXTENSION,
                                             });
                         if (r < 0)
                                 return r;
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                         if (n_extension_images == 0) {
                                 c->extension_images = mount_image_free_many(c->extension_images, &c->n_extension_images);
 
                                 unit_write_settingf(u, flags, name, "%s=", name);
                         } else {
                                 for (size_t i = 0; i < n_extension_images; ++i) {
                                         r = mount_image_add(&c->extension_images, &c->n_extension_images, &extension_images[i]);
                                         if (r < 0)
                                                 return r;
                                 }
 
                                 unit_write_settingf(u, flags|UNIT_ESCAPE_C|UNIT_ESCAPE_SPECIFIERS,
                                                     name,
                                                     "%s=%s",
                                                     name,
                                                     format_str);
                         }
                 }
 
                 extension_images = mount_image_free_many(extension_images, &n_extension_images);
 
                 return 1;
 
         } else if (STR_IN_SET(name, "StateDirectorySymlink", "RuntimeDirectorySymlink", "CacheDirectorySymlink", "LogsDirectorySymlink")) {
                 char *source, *destination;
                 ExecDirectory *directory;
                 uint64_t symlink_flags; /* No flags for now, reserved for future uses. */
                 ExecDirectoryType i;
 
                 assert_se((i = exec_directory_type_symlink_from_string(name)) >= 0);
                 directory = c->directories + i;
 
                 r = sd_bus_message_enter_container(message, 'a', "(sst)");
                 if (r < 0)
                         return r;
 
                 while ((r = sd_bus_message_read(message, "(sst)", &source, &destination, &symlink_flags)) > 0) {
                         if (!path_is_valid(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not valid.", source);
                         if (path_is_absolute(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is absolute.", source);
                         if (!path_is_normalized(source))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Source path %s is not normalized.", source);
                         if (!path_is_valid(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is not valid.", destination);
                         if (path_is_absolute(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is absolute.", destination);
                         if (!path_is_normalized(destination))
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Destination path %s is not normalized.", destination);
                         if (symlink_flags != 0)
                                 return sd_bus_error_setf(error, SD_BUS_ERROR_INVALID_ARGS, "Flags must be zero.");
 
                         if (!UNIT_WRITE_FLAGS_NOOP(flags)) {
                                 _cleanup_free_ char *destination_escaped = NULL, *source_escaped = NULL;
                                 ExecDirectoryItem *item = NULL;
 
                                 /* Adding new directories is supported from both *DirectorySymlink methods and the
                                  * older ones, so try to find an existing configuration first and create it if it's
                                  * not there yet. */
                                 for (size_t j = 0; j < directory->n_items; ++j)
                                         if (path_equal(source, directory->items[j].path)) {
                                                 item = &directory->items[j];
                                                 break;
                                         }
 
                                 if (item)
                                         r = strv_extend(&item->symlinks, destination);
                                 else
                                         r = exec_directory_add(&directory->items, &directory->n_items, source, STRV_MAKE(destination));
                                 if (r < 0)
                                         return r;
 
                                 /* Need to store them in the unit with the escapes, so that they can be parsed again */
                                 source_escaped = xescape(source, ":");
                                 destination_escaped = xescape(destination, ":");
                                 if (!source_escaped || !destination_escaped)
                                         return -ENOMEM;
 
                                 unit_write_settingf(
                                                 u, flags|UNIT_ESCAPE_SPECIFIERS, exec_directory_type_to_string(i),
                                                 "%s=%s:%s",
                                                 exec_directory_type_to_string(i),
                                                 source_escaped,
                                                 destination_escaped);
                         }
                 }
                 if (r < 0)
                         return r;
 
                 r = sd_bus_message_exit_container(message);
                 if (r < 0)
                         return r;
 
                 return 1;
 
         }
 
         return 0;
 }
diff --git a/src/core/execute.c b/src/core/execute.c
index f128a45f54..05fc00ca1c 100644
--- a/src/core/execute.c
+++ b/src/core/execute.c
@@ -4083,1111 +4083,1072 @@ static int add_shifted_fd(int *fds, size_t fds_size, size_t *n_fds, int fd, int
         return 1;
 }
 
-static void exec_op_dynamic_user_nft_set(bool add, const ExecContext *c, uid_t uid) {
-        int r;
-
-        assert(c);
-
-        for (size_t i = 0; i < c->n_dynamic_user_nft_set_contexts; i++) {
-                NFTSetContext *s = &c->dynamic_user_nft_set_context[i];
-                if (add)
-                        r = nft_set_element_add_uint32(s, uid);
-                else
-                        r = nft_set_element_del_uint32(s, uid);
-                if (r < 0)
-                        log_warning_errno(r, "%s NFT family %s table %s set %s UID " UID_FMT " failed, ignoring: %m",
-                                          add? "Adding" : "Deleting", nfproto_to_string(s->nfproto), s->table, s->set, uid);
-        }
-}
-
-static void exec_add_dynamic_user_nft_set(const ExecContext *c, uid_t uid) {
-        exec_op_dynamic_user_nft_set(true, c, uid);
-}
-
-void exec_delete_dynamic_user_nft_set(const ExecContext *c, DynamicUser *d) {
-        int r;
-        uid_t uid;
-
-        if (!d)
-                return;
-
-        r = dynamic_user_current(d, &uid);
-        if (r < 0) {
-                log_warning_errno(r, "Can't get current dynamic user, ignoring: %m");
-                return;
-        }
-
-        exec_op_dynamic_user_nft_set(false, c, uid);
-}
-
 static int exec_child(
                 Unit *unit,
                 const ExecCommand *command,
                 const ExecContext *context,
                 const ExecParameters *params,
                 ExecRuntime *runtime,
                 DynamicCreds *dcreds,
                 int socket_fd,
                 const int named_iofds[static 3],
                 int *fds,
                 size_t n_socket_fds,
                 size_t n_storage_fds,
                 char **files_env,
                 int user_lookup_fd,
                 int *exit_status) {
 
         _cleanup_strv_free_ char **our_env = NULL, **pass_env = NULL, **joined_exec_search_path = NULL, **accum_env = NULL, **replaced_argv = NULL;
         int r, ngids = 0, exec_fd;
         _cleanup_free_ gid_t *supplementary_gids = NULL;
         const char *username = NULL, *groupname = NULL;
         _cleanup_free_ char *home_buffer = NULL;
         const char *home = NULL, *shell = NULL;
         char **final_argv = NULL;
         dev_t journal_stream_dev = 0;
         ino_t journal_stream_ino = 0;
         bool userns_set_up = false;
         bool needs_sandboxing,          /* Do we need to set up full sandboxing? (i.e. all namespacing, all MAC stuff, caps, yadda yadda */
                 needs_setuid,           /* Do we need to do the actual setresuid()/setresgid() calls? */
                 needs_mount_namespace,  /* Do we need to set up a mount namespace for this kernel? */
                 needs_ambient_hack;     /* Do we need to apply the ambient capabilities hack? */
 #if HAVE_SELINUX
         _cleanup_free_ char *mac_selinux_context_net = NULL;
         bool use_selinux = false;
 #endif
 #if ENABLE_SMACK
         bool use_smack = false;
 #endif
 #if HAVE_APPARMOR
         bool use_apparmor = false;
 #endif
         uid_t saved_uid = getuid();
         gid_t saved_gid = getgid();
         uid_t uid = UID_INVALID;
         gid_t gid = GID_INVALID;
         size_t n_fds = n_socket_fds + n_storage_fds, /* fds to pass to the child */
                n_keep_fds; /* total number of fds not to close */
         int secure_bits;
         _cleanup_free_ gid_t *gids_after_pam = NULL;
         int ngids_after_pam = 0;
 
         assert(unit);
         assert(command);
         assert(context);
         assert(params);
         assert(exit_status);
 
         /* Explicitly test for CVE-2021-4034 inspired invocations */
         assert(command->path);
         assert(!strv_isempty(command->argv));
 
         rename_process_from_path(command->path);
 
         /* We reset exactly these signals, since they are the only ones we set to SIG_IGN in the main
          * daemon. All others we leave untouched because we set them to SIG_DFL or a valid handler initially,
          * both of which will be demoted to SIG_DFL. */
         (void) default_signals(SIGNALS_CRASH_HANDLER,
                                SIGNALS_IGNORE);
 
         if (context->ignore_sigpipe)
                 (void) ignore_signals(SIGPIPE);
 
         r = reset_signal_mask();
         if (r < 0) {
                 *exit_status = EXIT_SIGNAL_MASK;
                 return log_unit_error_errno(unit, r, "Failed to set process signal mask: %m");
         }
 
         if (params->idle_pipe)
                 do_idle_pipe_dance(params->idle_pipe);
 
         /* Close fds we don't need very early to make sure we don't block init reexecution because it cannot bind its
          * sockets. Among the fds we close are the logging fds, and we want to keep them closed, so that we don't have
          * any fds open we don't really want open during the transition. In order to make logging work, we switch the
          * log subsystem into open_when_needed mode, so that it reopens the logs on every single log call. */
 
         log_forget_fds();
         log_set_open_when_needed(true);
 
         /* In case anything used libc syslog(), close this here, too */
         closelog();
 
         int keep_fds[n_fds + 3];
         memcpy_safe(keep_fds, fds, n_fds * sizeof(int));
         n_keep_fds = n_fds;
 
         r = add_shifted_fd(keep_fds, ELEMENTSOF(keep_fds), &n_keep_fds, params->exec_fd, &exec_fd);
         if (r < 0) {
                 *exit_status = EXIT_FDS;
                 return log_unit_error_errno(unit, r, "Failed to shift fd and set FD_CLOEXEC: %m");
         }
 
 #if HAVE_LIBBPF
         if (unit->manager->restrict_fs) {
                 int bpf_map_fd = lsm_bpf_map_restrict_fs_fd(unit);
                 if (bpf_map_fd < 0) {
                         *exit_status = EXIT_FDS;
                         return log_unit_error_errno(unit, bpf_map_fd, "Failed to get restrict filesystems BPF map fd: %m");
                 }
 
                 r = add_shifted_fd(keep_fds, ELEMENTSOF(keep_fds), &n_keep_fds, bpf_map_fd, &bpf_map_fd);
                 if (r < 0) {
                         *exit_status = EXIT_FDS;
                         return log_unit_error_errno(unit, r, "Failed to shift fd and set FD_CLOEXEC: %m");
                 }
         }
 #endif
 
         r = close_remaining_fds(params, runtime, dcreds, user_lookup_fd, socket_fd, keep_fds, n_keep_fds);
         if (r < 0) {
                 *exit_status = EXIT_FDS;
                 return log_unit_error_errno(unit, r, "Failed to close unwanted file descriptors: %m");
         }
 
         if (!context->same_pgrp &&
             setsid() < 0) {
                 *exit_status = EXIT_SETSID;
                 return log_unit_error_errno(unit, errno, "Failed to create new process session: %m");
         }
 
         exec_context_tty_reset(context, params);
 
         if (unit_shall_confirm_spawn(unit)) {
                 _cleanup_free_ char *cmdline = NULL;
 
                 cmdline = quote_command_line(command->argv, SHELL_ESCAPE_EMPTY);
                 if (!cmdline) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
 
                 r = ask_for_confirmation(context, params->confirm_spawn, unit, cmdline);
                 if (r != CONFIRM_EXECUTE) {
                         if (r == CONFIRM_PRETEND_SUCCESS) {
                                 *exit_status = EXIT_SUCCESS;
                                 return 0;
                         }
                         *exit_status = EXIT_CONFIRM;
                         return log_unit_error_errno(unit, SYNTHETIC_ERRNO(ECANCELED),
                                                     "Execution cancelled by the user");
                 }
         }
 
         /* We are about to invoke NSS and PAM modules. Let's tell them what we are doing here, maybe they care. This is
          * used by nss-resolve to disable itself when we are about to start systemd-resolved, to avoid deadlocks. Note
          * that these env vars do not survive the execve(), which means they really only apply to the PAM and NSS
          * invocations themselves. Also note that while we'll only invoke NSS modules involved in user management they
          * might internally call into other NSS modules that are involved in hostname resolution, we never know. */
         if (setenv("SYSTEMD_ACTIVATION_UNIT", unit->id, true) != 0 ||
             setenv("SYSTEMD_ACTIVATION_SCOPE", MANAGER_IS_SYSTEM(unit->manager) ? "system" : "user", true) != 0) {
                 *exit_status = EXIT_MEMORY;
                 return log_unit_error_errno(unit, errno, "Failed to update environment: %m");
         }
 
         if (context->dynamic_user && dcreds) {
                 _cleanup_strv_free_ char **suggested_paths = NULL;
 
                 /* On top of that, make sure we bypass our own NSS module nss-systemd comprehensively for any NSS
                  * checks, if DynamicUser=1 is used, as we shouldn't create a feedback loop with ourselves here. */
                 if (putenv((char*) "SYSTEMD_NSS_DYNAMIC_BYPASS=1") != 0) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, errno, "Failed to update environment: %m");
                 }
 
                 r = compile_suggested_paths(context, params, &suggested_paths);
                 if (r < 0) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
 
                 r = dynamic_creds_realize(dcreds, suggested_paths, &uid, &gid);
                 if (r < 0) {
                         *exit_status = EXIT_USER;
                         if (r == -EILSEQ)
                                 return log_unit_error_errno(unit, SYNTHETIC_ERRNO(EOPNOTSUPP),
                                                             "Failed to update dynamic user credentials: User or group with specified name already exists.");
                         return log_unit_error_errno(unit, r, "Failed to update dynamic user credentials: %m");
                 }
 
                 if (!uid_is_valid(uid)) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, SYNTHETIC_ERRNO(ESRCH), "UID validation failed for \""UID_FMT"\"", uid);
                 }
 
                 if (!gid_is_valid(gid)) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, SYNTHETIC_ERRNO(ESRCH), "GID validation failed for \""GID_FMT"\"", gid);
                 }
 
                 if (dcreds->user)
                         username = dcreds->user->name;
 
-                exec_add_dynamic_user_nft_set(context, uid);
-
         } else {
                 r = get_fixed_user(context, &username, &uid, &gid, &home, &shell);
                 if (r < 0) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, r, "Failed to determine user credentials: %m");
                 }
 
                 r = get_fixed_group(context, &groupname, &gid);
                 if (r < 0) {
                         *exit_status = EXIT_GROUP;
                         return log_unit_error_errno(unit, r, "Failed to determine group credentials: %m");
                 }
         }
 
         /* Initialize user supplementary groups and get SupplementaryGroups= ones */
         r = get_supplementary_groups(context, username, groupname, gid,
                                      &supplementary_gids, &ngids);
         if (r < 0) {
                 *exit_status = EXIT_GROUP;
                 return log_unit_error_errno(unit, r, "Failed to determine supplementary groups: %m");
         }
 
         r = send_user_lookup(unit, user_lookup_fd, uid, gid);
         if (r < 0) {
                 *exit_status = EXIT_USER;
                 return log_unit_error_errno(unit, r, "Failed to send user credentials to PID1: %m");
         }
 
         user_lookup_fd = safe_close(user_lookup_fd);
 
         r = acquire_home(context, uid, &home, &home_buffer);
         if (r < 0) {
                 *exit_status = EXIT_CHDIR;
                 return log_unit_error_errno(unit, r, "Failed to determine $HOME for user: %m");
         }
 
         /* If a socket is connected to STDIN/STDOUT/STDERR, we
          * must sure to drop O_NONBLOCK */
         if (socket_fd >= 0)
                 (void) fd_nonblock(socket_fd, false);
 
         /* Journald will try to look-up our cgroup in order to populate _SYSTEMD_CGROUP and _SYSTEMD_UNIT fields.
          * Hence we need to migrate to the target cgroup from init.scope before connecting to journald */
         if (params->cgroup_path) {
                 _cleanup_free_ char *p = NULL;
 
                 r = exec_parameters_get_cgroup_path(params, &p);
                 if (r < 0) {
                         *exit_status = EXIT_CGROUP;
                         return log_unit_error_errno(unit, r, "Failed to acquire cgroup path: %m");
                 }
 
                 r = cg_attach_everywhere(params->cgroup_supported, p, 0, NULL, NULL);
                 if (r == -EUCLEAN) {
                         *exit_status = EXIT_CGROUP;
                         return log_unit_error_errno(unit, r, "Failed to attach process to cgroup %s "
                                                     "because the cgroup or one of its parents or "
                                                     "siblings is in the threaded mode: %m", p);
                 }
                 if (r < 0) {
                         *exit_status = EXIT_CGROUP;
                         return log_unit_error_errno(unit, r, "Failed to attach to cgroup %s: %m", p);
                 }
         }
 
         if (context->network_namespace_path && runtime && runtime->netns_storage_socket[0] >= 0) {
                 r = open_shareable_ns_path(runtime->netns_storage_socket, context->network_namespace_path, CLONE_NEWNET);
                 if (r < 0) {
                         *exit_status = EXIT_NETWORK;
                         return log_unit_error_errno(unit, r, "Failed to open network namespace path %s: %m", context->network_namespace_path);
                 }
         }
 
         if (context->ipc_namespace_path && runtime && runtime->ipcns_storage_socket[0] >= 0) {
                 r = open_shareable_ns_path(runtime->ipcns_storage_socket, context->ipc_namespace_path, CLONE_NEWIPC);
                 if (r < 0) {
                         *exit_status = EXIT_NAMESPACE;
                         return log_unit_error_errno(unit, r, "Failed to open IPC namespace path %s: %m", context->ipc_namespace_path);
                 }
         }
 
         r = setup_input(context, params, socket_fd, named_iofds);
         if (r < 0) {
                 *exit_status = EXIT_STDIN;
                 return log_unit_error_errno(unit, r, "Failed to set up standard input: %m");
         }
 
         r = setup_output(unit, context, params, STDOUT_FILENO, socket_fd, named_iofds, basename(command->path), uid, gid, &journal_stream_dev, &journal_stream_ino);
         if (r < 0) {
                 *exit_status = EXIT_STDOUT;
                 return log_unit_error_errno(unit, r, "Failed to set up standard output: %m");
         }
 
         r = setup_output(unit, context, params, STDERR_FILENO, socket_fd, named_iofds, basename(command->path), uid, gid, &journal_stream_dev, &journal_stream_ino);
         if (r < 0) {
                 *exit_status = EXIT_STDERR;
                 return log_unit_error_errno(unit, r, "Failed to set up standard error output: %m");
         }
 
         if (context->oom_score_adjust_set) {
                 /* When we can't make this change due to EPERM, then let's silently skip over it. User namespaces
                  * prohibit write access to this file, and we shouldn't trip up over that. */
                 r = set_oom_score_adjust(context->oom_score_adjust);
                 if (ERRNO_IS_PRIVILEGE(r))
                         log_unit_debug_errno(unit, r, "Failed to adjust OOM setting, assuming containerized execution, ignoring: %m");
                 else if (r < 0) {
                         *exit_status = EXIT_OOM_ADJUST;
                         return log_unit_error_errno(unit, r, "Failed to adjust OOM setting: %m");
                 }
         }
 
         if (context->coredump_filter_set) {
                 r = set_coredump_filter(context->coredump_filter);
                 if (ERRNO_IS_PRIVILEGE(r))
                         log_unit_debug_errno(unit, r, "Failed to adjust coredump_filter, ignoring: %m");
                 else if (r < 0)
                         return log_unit_error_errno(unit, r, "Failed to adjust coredump_filter: %m");
         }
 
         if (context->nice_set) {
                 r = setpriority_closest(context->nice);
                 if (r < 0)
                         return log_unit_error_errno(unit, r, "Failed to set up process scheduling priority (nice level): %m");
         }
 
         if (context->cpu_sched_set) {
                 struct sched_param param = {
                         .sched_priority = context->cpu_sched_priority,
                 };
 
                 r = sched_setscheduler(0,
                                        context->cpu_sched_policy |
                                        (context->cpu_sched_reset_on_fork ?
                                         SCHED_RESET_ON_FORK : 0),
                                        &param);
                 if (r < 0) {
                         *exit_status = EXIT_SETSCHEDULER;
                         return log_unit_error_errno(unit, errno, "Failed to set up CPU scheduling: %m");
                 }
         }
 
         if (context->cpu_affinity_from_numa || context->cpu_set.set) {
                 _cleanup_(cpu_set_reset) CPUSet converted_cpu_set = {};
                 const CPUSet *cpu_set;
 
                 if (context->cpu_affinity_from_numa) {
                         r = exec_context_cpu_affinity_from_numa(context, &converted_cpu_set);
                         if (r < 0) {
                                 *exit_status = EXIT_CPUAFFINITY;
                                 return log_unit_error_errno(unit, r, "Failed to derive CPU affinity mask from NUMA mask: %m");
                         }
 
                         cpu_set = &converted_cpu_set;
                 } else
                         cpu_set = &context->cpu_set;
 
                 if (sched_setaffinity(0, cpu_set->allocated, cpu_set->set) < 0) {
                         *exit_status = EXIT_CPUAFFINITY;
                         return log_unit_error_errno(unit, errno, "Failed to set up CPU affinity: %m");
                 }
         }
 
         if (mpol_is_valid(numa_policy_get_type(&context->numa_policy))) {
                 r = apply_numa_policy(&context->numa_policy);
                 if (r == -EOPNOTSUPP)
                         log_unit_debug_errno(unit, r, "NUMA support not available, ignoring.");
                 else if (r < 0) {
                         *exit_status = EXIT_NUMA_POLICY;
                         return log_unit_error_errno(unit, r, "Failed to set NUMA memory policy: %m");
                 }
         }
 
         if (context->ioprio_set)
                 if (ioprio_set(IOPRIO_WHO_PROCESS, 0, context->ioprio) < 0) {
                         *exit_status = EXIT_IOPRIO;
                         return log_unit_error_errno(unit, errno, "Failed to set up IO scheduling priority: %m");
                 }
 
         if (context->timer_slack_nsec != NSEC_INFINITY)
                 if (prctl(PR_SET_TIMERSLACK, context->timer_slack_nsec) < 0) {
                         *exit_status = EXIT_TIMERSLACK;
                         return log_unit_error_errno(unit, errno, "Failed to set up timer slack: %m");
                 }
 
         if (context->personality != PERSONALITY_INVALID) {
                 r = safe_personality(context->personality);
                 if (r < 0) {
                         *exit_status = EXIT_PERSONALITY;
                         return log_unit_error_errno(unit, r, "Failed to set up execution domain (personality): %m");
                 }
         }
 
         if (context->utmp_id) {
                 const char *line = context->tty_path ?
                         (path_startswith(context->tty_path, "/dev/") ?: context->tty_path) :
                         NULL;
                 utmp_put_init_process(context->utmp_id, getpid_cached(), getsid(0),
                                       line,
                                       context->utmp_mode == EXEC_UTMP_INIT  ? INIT_PROCESS :
                                       context->utmp_mode == EXEC_UTMP_LOGIN ? LOGIN_PROCESS :
                                       USER_PROCESS,
                                       username);
         }
 
         if (uid_is_valid(uid)) {
                 r = chown_terminal(STDIN_FILENO, uid);
                 if (r < 0) {
                         *exit_status = EXIT_STDIN;
                         return log_unit_error_errno(unit, r, "Failed to change ownership of terminal: %m");
                 }
         }
 
         /* If delegation is enabled we'll pass ownership of the cgroup to the user of the new process. On cgroup v1
          * this is only about systemd's own hierarchy, i.e. not the controller hierarchies, simply because that's not
          * safe. On cgroup v2 there's only one hierarchy anyway, and delegation is safe there, hence in that case only
          * touch a single hierarchy too. */
         if (params->cgroup_path && context->user && (params->flags & EXEC_CGROUP_DELEGATE)) {
                 r = cg_set_access(SYSTEMD_CGROUP_CONTROLLER, params->cgroup_path, uid, gid);
                 if (r < 0) {
                         *exit_status = EXIT_CGROUP;
                         return log_unit_error_errno(unit, r, "Failed to adjust control group access: %m");
                 }
         }
 
         needs_mount_namespace = exec_needs_mount_namespace(context, params, runtime);
 
         for (ExecDirectoryType dt = 0; dt < _EXEC_DIRECTORY_TYPE_MAX; dt++) {
                 r = setup_exec_directory(context, params, uid, gid, dt, needs_mount_namespace, exit_status);
                 if (r < 0)
                         return log_unit_error_errno(unit, r, "Failed to set up special execution directory in %s: %m", params->prefix[dt]);
         }
 
         if (FLAGS_SET(params->flags, EXEC_WRITE_CREDENTIALS)) {
                 r = setup_credentials(context, params, unit->id, uid);
                 if (r < 0) {
                         *exit_status = EXIT_CREDENTIALS;
                         return log_unit_error_errno(unit, r, "Failed to set up credentials: %m");
                 }
         }
 
         r = build_environment(
                         unit,
                         context,
                         params,
                         n_fds,
                         home,
                         username,
                         shell,
                         journal_stream_dev,
                         journal_stream_ino,
                         &our_env);
         if (r < 0) {
                 *exit_status = EXIT_MEMORY;
                 return log_oom();
         }
 
         r = build_pass_environment(context, &pass_env);
         if (r < 0) {
                 *exit_status = EXIT_MEMORY;
                 return log_oom();
         }
 
         /* The $PATH variable is set to the default path in params->environment. However, this is overridden
          * if user-specified fields have $PATH set. The intention is to also override $PATH if the unit does
          * not specify PATH but the unit has ExecSearchPath. */
         if (!strv_isempty(context->exec_search_path)) {
                 _cleanup_free_ char *joined = NULL;
 
                 joined = strv_join(context->exec_search_path, ":");
                 if (!joined) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
 
                 r = strv_env_assign(&joined_exec_search_path, "PATH", joined);
                 if (r < 0) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
         }
 
         accum_env = strv_env_merge(params->environment,
                                    our_env,
                                    joined_exec_search_path,
                                    pass_env,
                                    context->environment,
                                    files_env);
         if (!accum_env) {
                 *exit_status = EXIT_MEMORY;
                 return log_oom();
         }
         accum_env = strv_env_clean(accum_env);
 
         (void) umask(context->umask);
 
         r = setup_keyring(unit, context, params, uid, gid);
         if (r < 0) {
                 *exit_status = EXIT_KEYRING;
                 return log_unit_error_errno(unit, r, "Failed to set up kernel keyring: %m");
         }
 
         /* We need sandboxing if the caller asked us to apply it and the command isn't explicitly excepted
          * from it. */
         needs_sandboxing = (params->flags & EXEC_APPLY_SANDBOXING) && !(command->flags & EXEC_COMMAND_FULLY_PRIVILEGED);
 
         /* We need the ambient capability hack, if the caller asked us to apply it and the command is marked
          * for it, and the kernel doesn't actually support ambient caps. */
         needs_ambient_hack = (params->flags & EXEC_APPLY_SANDBOXING) && (command->flags & EXEC_COMMAND_AMBIENT_MAGIC) && !ambient_capabilities_supported();
 
         /* We need setresuid() if the caller asked us to apply sandboxing and the command isn't explicitly
          * excepted from either whole sandboxing or just setresuid() itself, and the ambient hack is not
          * desired. */
         if (needs_ambient_hack)
                 needs_setuid = false;
         else
                 needs_setuid = (params->flags & EXEC_APPLY_SANDBOXING) && !(command->flags & (EXEC_COMMAND_FULLY_PRIVILEGED|EXEC_COMMAND_NO_SETUID));
 
         if (needs_sandboxing) {
                 /* MAC enablement checks need to be done before a new mount ns is created, as they rely on
                  * /sys being present. The actual MAC context application will happen later, as late as
                  * possible, to avoid impacting our own code paths. */
 
 #if HAVE_SELINUX
                 use_selinux = mac_selinux_use();
 #endif
 #if ENABLE_SMACK
                 use_smack = mac_smack_use();
 #endif
 #if HAVE_APPARMOR
                 use_apparmor = mac_apparmor_use();
 #endif
         }
 
         if (needs_sandboxing) {
                 int which_failed;
 
                 /* Let's set the resource limits before we call into PAM, so that pam_limits wins over what
                  * is set here. (See below.) */
 
                 r = setrlimit_closest_all((const struct rlimit* const *) context->rlimit, &which_failed);
                 if (r < 0) {
                         *exit_status = EXIT_LIMITS;
                         return log_unit_error_errno(unit, r, "Failed to adjust resource limit RLIMIT_%s: %m", rlimit_to_string(which_failed));
                 }
         }
 
         if (needs_setuid && context->pam_name && username) {
                 /* Let's call into PAM after we set up our own idea of resource limits to that pam_limits
                  * wins here. (See above.) */
 
                 /* All fds passed in the fds array will be closed in the pam child process. */
                 r = setup_pam(context->pam_name, username, uid, gid, context->tty_path, &accum_env, fds, n_fds);
                 if (r < 0) {
                         *exit_status = EXIT_PAM;
                         return log_unit_error_errno(unit, r, "Failed to set up PAM session: %m");
                 }
 
                 ngids_after_pam = getgroups_alloc(&gids_after_pam);
                 if (ngids_after_pam < 0) {
                         *exit_status = EXIT_MEMORY;
                         return log_unit_error_errno(unit, ngids_after_pam, "Failed to obtain groups after setting up PAM: %m");
                 }
         }
 
         if (needs_sandboxing && context->private_users && !have_effective_cap(CAP_SYS_ADMIN)) {
                 /* If we're unprivileged, set up the user namespace first to enable use of the other namespaces.
                  * Users with CAP_SYS_ADMIN can set up user namespaces last because they will be able to
                  * set up the all of the other namespaces (i.e. network, mount, UTS) without a user namespace. */
 
                 userns_set_up = true;
                 r = setup_private_users(saved_uid, saved_gid, uid, gid);
                 if (r < 0) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, r, "Failed to set up user namespacing for unprivileged user: %m");
                 }
         }
 
         if ((context->private_network || context->network_namespace_path) && runtime && runtime->netns_storage_socket[0] >= 0) {
 
                 if (ns_type_supported(NAMESPACE_NET)) {
                         r = setup_shareable_ns(runtime->netns_storage_socket, CLONE_NEWNET);
                         if (r == -EPERM)
                                 log_unit_warning_errno(unit, r,
                                                        "PrivateNetwork=yes is configured, but network namespace setup failed, ignoring: %m");
                         else if (r < 0) {
                                 *exit_status = EXIT_NETWORK;
                                 return log_unit_error_errno(unit, r, "Failed to set up network namespacing: %m");
                         }
                 } else if (context->network_namespace_path) {
                         *exit_status = EXIT_NETWORK;
                         return log_unit_error_errno(unit, SYNTHETIC_ERRNO(EOPNOTSUPP),
                                                     "NetworkNamespacePath= is not supported, refusing.");
                 } else
                         log_unit_warning(unit, "PrivateNetwork=yes is configured, but the kernel does not support network namespaces, ignoring.");
         }
 
         if ((context->private_ipc || context->ipc_namespace_path) && runtime && runtime->ipcns_storage_socket[0] >= 0) {
 
                 if (ns_type_supported(NAMESPACE_IPC)) {
                         r = setup_shareable_ns(runtime->ipcns_storage_socket, CLONE_NEWIPC);
                         if (r == -EPERM)
                                 log_unit_warning_errno(unit, r,
                                                        "PrivateIPC=yes is configured, but IPC namespace setup failed, ignoring: %m");
                         else if (r < 0) {
                                 *exit_status = EXIT_NAMESPACE;
                                 return log_unit_error_errno(unit, r, "Failed to set up IPC namespacing: %m");
                         }
                 } else if (context->ipc_namespace_path) {
                         *exit_status = EXIT_NAMESPACE;
                         return log_unit_error_errno(unit, SYNTHETIC_ERRNO(EOPNOTSUPP),
                                                     "IPCNamespacePath= is not supported, refusing.");
                 } else
                         log_unit_warning(unit, "PrivateIPC=yes is configured, but the kernel does not support IPC namespaces, ignoring.");
         }
 
         if (needs_mount_namespace) {
                 _cleanup_free_ char *error_path = NULL;
 
                 r = apply_mount_namespace(unit, command->flags, context, params, runtime, &error_path);
                 if (r < 0) {
                         *exit_status = EXIT_NAMESPACE;
                         return log_unit_error_errno(unit, r, "Failed to set up mount namespacing%s%s: %m",
                                                     error_path ? ": " : "", strempty(error_path));
                 }
         }
 
         if (needs_sandboxing) {
                 r = apply_protect_hostname(unit, context, exit_status);
                 if (r < 0)
                         return r;
         }
 
         /* Drop groups as early as possible.
          * This needs to be done after PrivateDevices=y setup as device nodes should be owned by the host's root.
          * For non-root in a userns, devices will be owned by the user/group before the group change, and nobody. */
         if (needs_setuid) {
                 _cleanup_free_ gid_t *gids_to_enforce = NULL;
                 int ngids_to_enforce = 0;
 
                 ngids_to_enforce = merge_gid_lists(supplementary_gids,
                                                    ngids,
                                                    gids_after_pam,
                                                    ngids_after_pam,
                                                    &gids_to_enforce);
                 if (ngids_to_enforce < 0) {
                         *exit_status = EXIT_MEMORY;
                         return log_unit_error_errno(unit,
                                                     ngids_to_enforce,
                                                     "Failed to merge group lists. Group membership might be incorrect: %m");
                 }
 
                 r = enforce_groups(gid, gids_to_enforce, ngids_to_enforce);
                 if (r < 0) {
                         *exit_status = EXIT_GROUP;
                         return log_unit_error_errno(unit, r, "Changing group credentials failed: %m");
                 }
         }
 
         /* If the user namespace was not set up above, try to do it now.
          * It's preferred to set up the user namespace later (after all other namespaces) so as not to be
          * restricted by rules pertaining to combining user namspaces with other namespaces (e.g. in the
          * case of mount namespaces being less privileged when the mount point list is copied from a
          * different user namespace). */
 
         if (needs_sandboxing && context->private_users && !userns_set_up) {
                 r = setup_private_users(saved_uid, saved_gid, uid, gid);
                 if (r < 0) {
                         *exit_status = EXIT_USER;
                         return log_unit_error_errno(unit, r, "Failed to set up user namespacing: %m");
                 }
         }
 
         /* Now that the mount namespace has been set up and privileges adjusted, let's look for the thing we
          * shall execute. */
 
         _cleanup_free_ char *executable = NULL;
         _cleanup_close_ int executable_fd = -1;
         r = find_executable_full(command->path, /* root= */ NULL, context->exec_search_path, false, &executable, &executable_fd);
         if (r < 0) {
                 if (r != -ENOMEM && (command->flags & EXEC_COMMAND_IGNORE_FAILURE)) {
                         log_unit_struct_errno(unit, LOG_INFO, r,
                                               "MESSAGE_ID=" SD_MESSAGE_SPAWN_FAILED_STR,
                                               LOG_UNIT_INVOCATION_ID(unit),
                                               LOG_UNIT_MESSAGE(unit, "Executable %s missing, skipping: %m",
                                                                command->path),
                                               "EXECUTABLE=%s", command->path);
                         return 0;
                 }
 
                 *exit_status = EXIT_EXEC;
 
                 return log_unit_struct_errno(unit, LOG_INFO, r,
                                              "MESSAGE_ID=" SD_MESSAGE_SPAWN_FAILED_STR,
                                              LOG_UNIT_INVOCATION_ID(unit),
                                              LOG_UNIT_MESSAGE(unit, "Failed to locate executable %s: %m",
                                                               command->path),
                                              "EXECUTABLE=%s", command->path);
         }
 
         r = add_shifted_fd(keep_fds, ELEMENTSOF(keep_fds), &n_keep_fds, executable_fd, &executable_fd);
         if (r < 0) {
                 *exit_status = EXIT_FDS;
                 return log_unit_error_errno(unit, r, "Failed to shift fd and set FD_CLOEXEC: %m");
         }
 
 #if HAVE_SELINUX
         if (needs_sandboxing && use_selinux && params->selinux_context_net) {
                 int fd = -1;
 
                 if (socket_fd >= 0)
                         fd = socket_fd;
                 else if (params->n_socket_fds == 1)
                         /* If stdin is not connected to a socket but we are triggered by exactly one socket unit then we
                          * use context from that fd to compute the label. */
                         fd = params->fds[0];
 
                 if (fd >= 0) {
                         r = mac_selinux_get_child_mls_label(fd, executable, context->selinux_context, &mac_selinux_context_net);
                         if (r < 0) {
                                 if (!context->selinux_context_ignore) {
                                         *exit_status = EXIT_SELINUX_CONTEXT;
                                         return log_unit_error_errno(unit, r, "Failed to determine SELinux context: %m");
                                 }
                                 log_unit_debug_errno(unit, r, "Failed to determine SELinux context, ignoring: %m");
                         }
                 }
         }
 #endif
 
         /* We repeat the fd closing here, to make sure that nothing is leaked from the PAM modules. Note that we are
          * more aggressive this time since socket_fd and the netns and ipcns fds we don't need anymore. We do keep the exec_fd
          * however if we have it as we want to keep it open until the final execve(). */
 
         r = close_all_fds(keep_fds, n_keep_fds);
         if (r >= 0)
                 r = shift_fds(fds, n_fds);
         if (r >= 0)
                 r = flags_fds(fds, n_socket_fds, n_storage_fds, context->non_blocking);
         if (r < 0) {
                 *exit_status = EXIT_FDS;
                 return log_unit_error_errno(unit, r, "Failed to adjust passed file descriptors: %m");
         }
 
         /* At this point, the fds we want to pass to the program are all ready and set up, with O_CLOEXEC turned off
          * and at the right fd numbers. The are no other fds open, with one exception: the exec_fd if it is defined,
          * and it has O_CLOEXEC set, after all we want it to be closed by the execve(), so that our parent knows we
          * came this far. */
 
         secure_bits = context->secure_bits;
 
         if (needs_sandboxing) {
                 uint64_t bset;
 
                 /* Set the RTPRIO resource limit to 0, but only if nothing else was explicitly
                  * requested. (Note this is placed after the general resource limit initialization, see
                  * above, in order to take precedence.) */
                 if (context->restrict_realtime && !context->rlimit[RLIMIT_RTPRIO]) {
                         if (setrlimit(RLIMIT_RTPRIO, &RLIMIT_MAKE_CONST(0)) < 0) {
                                 *exit_status = EXIT_LIMITS;
                                 return log_unit_error_errno(unit, errno, "Failed to adjust RLIMIT_RTPRIO resource limit: %m");
                         }
                 }
 
 #if ENABLE_SMACK
                 /* LSM Smack needs the capability CAP_MAC_ADMIN to change the current execution security context of the
                  * process. This is the latest place before dropping capabilities. Other MAC context are set later. */
                 if (use_smack) {
                         r = setup_smack(context, executable_fd);
                         if (r < 0 && !context->smack_process_label_ignore) {
                                 *exit_status = EXIT_SMACK_PROCESS_LABEL;
                                 return log_unit_error_errno(unit, r, "Failed to set SMACK process label: %m");
                         }
                 }
 #endif
 
                 bset = context->capability_bounding_set;
                 /* If the ambient caps hack is enabled (which means the kernel can't do them, and the user asked for
                  * our magic fallback), then let's add some extra caps, so that the service can drop privs of its own,
                  * instead of us doing that */
                 if (needs_ambient_hack)
                         bset |= (UINT64_C(1) << CAP_SETPCAP) |
                                 (UINT64_C(1) << CAP_SETUID) |
                                 (UINT64_C(1) << CAP_SETGID);
 
                 if (!cap_test_all(bset)) {
                         r = capability_bounding_set_drop(bset, false);
                         if (r < 0) {
                                 *exit_status = EXIT_CAPABILITIES;
                                 return log_unit_error_errno(unit, r, "Failed to drop capabilities: %m");
                         }
                 }
 
                 /* Ambient capabilities are cleared during setresuid() (in enforce_user()) even with
                  * keep-caps set.
                  * To be able to raise the ambient capabilities after setresuid() they have to be
                  * added to the inherited set and keep caps has to be set (done in enforce_user()).
                  * After setresuid() the ambient capabilities can be raised as they are present in
                  * the permitted and inhertiable set. However it is possible that someone wants to
                  * set ambient capabilities without changing the user, so we also set the ambient
                  * capabilities here.
                  * The requested ambient capabilities are raised in the inheritable set if the
                  * second argument is true. */
                 if (!needs_ambient_hack) {
                         r = capability_ambient_set_apply(context->capability_ambient_set, true);
                         if (r < 0) {
                                 *exit_status = EXIT_CAPABILITIES;
                                 return log_unit_error_errno(unit, r, "Failed to apply ambient capabilities (before UID change): %m");
                         }
                 }
         }
 
         /* chroot to root directory first, before we lose the ability to chroot */
         r = apply_root_directory(context, params, needs_mount_namespace, exit_status);
         if (r < 0)
                 return log_unit_error_errno(unit, r, "Chrooting to the requested root directory failed: %m");
 
         if (needs_setuid) {
                 if (uid_is_valid(uid)) {
                         r = enforce_user(context, uid);
                         if (r < 0) {
                                 *exit_status = EXIT_USER;
                                 return log_unit_error_errno(unit, r, "Failed to change UID to " UID_FMT ": %m", uid);
                         }
 
                         if (!needs_ambient_hack &&
                             context->capability_ambient_set != 0) {
 
                                 /* Raise the ambient capabilities after user change. */
                                 r = capability_ambient_set_apply(context->capability_ambient_set, false);
                                 if (r < 0) {
                                         *exit_status = EXIT_CAPABILITIES;
                                         return log_unit_error_errno(unit, r, "Failed to apply ambient capabilities (after UID change): %m");
                                 }
                         }
                 }
         }
 
         /* Apply working directory here, because the working directory might be on NFS and only the user running
          * this service might have the correct privilege to change to the working directory */
         r = apply_working_directory(context, params, home, exit_status);
         if (r < 0)
                 return log_unit_error_errno(unit, r, "Changing to the requested working directory failed: %m");
 
         if (needs_sandboxing) {
                 /* Apply other MAC contexts late, but before seccomp syscall filtering, as those should really be last to
                  * influence our own codepaths as little as possible. Moreover, applying MAC contexts usually requires
                  * syscalls that are subject to seccomp filtering, hence should probably be applied before the syscalls
                  * are restricted. */
 
 #if HAVE_SELINUX
                 if (use_selinux) {
                         char *exec_context = mac_selinux_context_net ?: context->selinux_context;
 
                         if (exec_context) {
                                 r = setexeccon(exec_context);
                                 if (r < 0) {
                                         if (!context->selinux_context_ignore) {
                                                 *exit_status = EXIT_SELINUX_CONTEXT;
                                                 return log_unit_error_errno(unit, r, "Failed to change SELinux context to %s: %m", exec_context);
                                         }
                                         log_unit_debug_errno(unit, r, "Failed to change SELinux context to %s, ignoring: %m", exec_context);
                                 }
                         }
                 }
 #endif
 
 #if HAVE_APPARMOR
                 if (use_apparmor && context->apparmor_profile) {
                         r = aa_change_onexec(context->apparmor_profile);
                         if (r < 0 && !context->apparmor_profile_ignore) {
                                 *exit_status = EXIT_APPARMOR_PROFILE;
                                 return log_unit_error_errno(unit, errno, "Failed to prepare AppArmor profile change to %s: %m", context->apparmor_profile);
                         }
                 }
 #endif
 
                 /* PR_GET_SECUREBITS is not privileged, while PR_SET_SECUREBITS is. So to suppress potential EPERMs
                  * we'll try not to call PR_SET_SECUREBITS unless necessary. Setting securebits requires
                  * CAP_SETPCAP. */
                 if (prctl(PR_GET_SECUREBITS) != secure_bits) {
                         /* CAP_SETPCAP is required to set securebits. This capability is raised into the
                          * effective set here.
                          * The effective set is overwritten during execve  with the following  values:
                          * - ambient set (for non-root processes)
                          * - (inheritable | bounding) set for root processes)
                          *
                          * Hence there is no security impact to raise it in the effective set before execve
                          */
                         r = capability_gain_cap_setpcap(NULL);
                         if (r < 0) {
                                 *exit_status = EXIT_CAPABILITIES;
                                 return log_unit_error_errno(unit, r, "Failed to gain CAP_SETPCAP for setting secure bits");
                         }
                         if (prctl(PR_SET_SECUREBITS, secure_bits) < 0) {
                                 *exit_status = EXIT_SECUREBITS;
                                 return log_unit_error_errno(unit, errno, "Failed to set process secure bits: %m");
                         }
                 }
 
                 if (context_has_no_new_privileges(context))
                         if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {
                                 *exit_status = EXIT_NO_NEW_PRIVILEGES;
                                 return log_unit_error_errno(unit, errno, "Failed to disable new privileges: %m");
                         }
 
 #if HAVE_SECCOMP
                 r = apply_address_families(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_ADDRESS_FAMILIES;
                         return log_unit_error_errno(unit, r, "Failed to restrict address families: %m");
                 }
 
                 r = apply_memory_deny_write_execute(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to disable writing to executable memory: %m");
                 }
 
                 r = apply_restrict_realtime(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply realtime restrictions: %m");
                 }
 
                 r = apply_restrict_suid_sgid(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply SUID/SGID restrictions: %m");
                 }
 
                 r = apply_restrict_namespaces(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply namespace restrictions: %m");
                 }
 
                 r = apply_protect_sysctl(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply sysctl restrictions: %m");
                 }
 
                 r = apply_protect_kernel_modules(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply module loading restrictions: %m");
                 }
 
                 r = apply_protect_kernel_logs(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply kernel log restrictions: %m");
                 }
 
                 r = apply_protect_clock(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply clock restrictions: %m");
                 }
 
                 r = apply_private_devices(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to set up private devices: %m");
                 }
 
                 r = apply_syscall_archs(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply syscall architecture restrictions: %m");
                 }
 
                 r = apply_lock_personality(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to lock personalities: %m");
                 }
 
                 r = apply_syscall_log(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply system call log filters: %m");
                 }
 
                 /* This really should remain the last step before the execve(), to make sure our own code is unaffected
                  * by the filter as little as possible. */
                 r = apply_syscall_filter(unit, context, needs_ambient_hack);
                 if (r < 0) {
                         *exit_status = EXIT_SECCOMP;
                         return log_unit_error_errno(unit, r, "Failed to apply system call filters: %m");
                 }
 #endif
 
 #if HAVE_LIBBPF
                 r = apply_restrict_filesystems(unit, context);
                 if (r < 0) {
                         *exit_status = EXIT_BPF;
                         return log_unit_error_errno(unit, r, "Failed to restrict filesystems: %m");
                 }
 #endif
 
         }
 
         if (!strv_isempty(context->unset_environment)) {
                 char **ee = NULL;
 
                 ee = strv_env_delete(accum_env, 1, context->unset_environment);
                 if (!ee) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
 
                 strv_free_and_replace(accum_env, ee);
         }
 
         if (!FLAGS_SET(command->flags, EXEC_COMMAND_NO_ENV_EXPAND)) {
                 replaced_argv = replace_env_argv(command->argv, accum_env);
                 if (!replaced_argv) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
                 final_argv = replaced_argv;
         } else
                 final_argv = command->argv;
 
         if (DEBUG_LOGGING) {
                 _cleanup_free_ char *line = NULL;
 
                 line = quote_command_line(final_argv, SHELL_ESCAPE_EMPTY);
                 if (!line) {
                         *exit_status = EXIT_MEMORY;
                         return log_oom();
                 }
 
                 log_unit_struct(unit, LOG_DEBUG,
                                 "EXECUTABLE=%s", executable,
                                 LOG_UNIT_MESSAGE(unit, "Executing: %s", line));
         }
 
         if (exec_fd >= 0) {
                 uint8_t hot = 1;
 
                 /* We have finished with all our initializations. Let's now let the manager know that. From this point
                  * on, if the manager sees POLLHUP on the exec_fd, then execve() was successful. */
 
                 if (write(exec_fd, &hot, sizeof(hot)) < 0) {
                         *exit_status = EXIT_EXEC;
                         return log_unit_error_errno(unit, errno, "Failed to enable exec_fd: %m");
                 }
         }
 
         r = fexecve_or_execve(executable_fd, executable, final_argv, accum_env);
 
         if (exec_fd >= 0) {
                 uint8_t hot = 0;
 
                 /* The execve() failed. This means the exec_fd is still open. Which means we need to tell the manager
                  * that POLLHUP on it no longer means execve() succeeded. */
 
                 if (write(exec_fd, &hot, sizeof(hot)) < 0) {
                         *exit_status = EXIT_EXEC;
                         return log_unit_error_errno(unit, errno, "Failed to disable exec_fd: %m");
                 }
         }
 
         *exit_status = EXIT_EXEC;
         return log_unit_error_errno(unit, r, "Failed to execute %s: %m", executable);
 }
@@ -5355,89 +5316,87 @@ void exec_context_init(ExecContext *c) {
 void exec_context_done(ExecContext *c) {
         assert(c);
 
         c->environment = strv_free(c->environment);
         c->environment_files = strv_free(c->environment_files);
         c->pass_environment = strv_free(c->pass_environment);
         c->unset_environment = strv_free(c->unset_environment);
 
         rlimit_free_all(c->rlimit);
 
         for (size_t l = 0; l < 3; l++) {
                 c->stdio_fdname[l] = mfree(c->stdio_fdname[l]);
                 c->stdio_file[l] = mfree(c->stdio_file[l]);
         }
 
         c->working_directory = mfree(c->working_directory);
         c->root_directory = mfree(c->root_directory);
         c->root_image = mfree(c->root_image);
         c->root_image_options = mount_options_free_all(c->root_image_options);
         c->root_hash = mfree(c->root_hash);
         c->root_hash_size = 0;
         c->root_hash_path = mfree(c->root_hash_path);
         c->root_hash_sig = mfree(c->root_hash_sig);
         c->root_hash_sig_size = 0;
         c->root_hash_sig_path = mfree(c->root_hash_sig_path);
         c->root_verity = mfree(c->root_verity);
         c->extension_images = mount_image_free_many(c->extension_images, &c->n_extension_images);
         c->extension_directories = strv_free(c->extension_directories);
         c->tty_path = mfree(c->tty_path);
         c->syslog_identifier = mfree(c->syslog_identifier);
         c->user = mfree(c->user);
         c->group = mfree(c->group);
 
-        c->dynamic_user_nft_set_context = nft_set_context_free_many(c->dynamic_user_nft_set_context, &c->n_dynamic_user_nft_set_contexts);
-
         c->supplementary_groups = strv_free(c->supplementary_groups);
 
         c->pam_name = mfree(c->pam_name);
 
         c->read_only_paths = strv_free(c->read_only_paths);
         c->read_write_paths = strv_free(c->read_write_paths);
         c->inaccessible_paths = strv_free(c->inaccessible_paths);
         c->exec_paths = strv_free(c->exec_paths);
         c->no_exec_paths = strv_free(c->no_exec_paths);
         c->exec_search_path = strv_free(c->exec_search_path);
 
         bind_mount_free_many(c->bind_mounts, c->n_bind_mounts);
         c->bind_mounts = NULL;
         c->n_bind_mounts = 0;
         temporary_filesystem_free_many(c->temporary_filesystems, c->n_temporary_filesystems);
         c->temporary_filesystems = NULL;
         c->n_temporary_filesystems = 0;
         c->mount_images = mount_image_free_many(c->mount_images, &c->n_mount_images);
 
         cpu_set_reset(&c->cpu_set);
         numa_policy_reset(&c->numa_policy);
 
         c->utmp_id = mfree(c->utmp_id);
         c->selinux_context = mfree(c->selinux_context);
         c->apparmor_profile = mfree(c->apparmor_profile);
         c->smack_process_label = mfree(c->smack_process_label);
 
         c->restrict_filesystems = set_free(c->restrict_filesystems);
 
         c->syscall_filter = hashmap_free(c->syscall_filter);
         c->syscall_archs = set_free(c->syscall_archs);
         c->address_families = set_free(c->address_families);
 
         for (ExecDirectoryType t = 0; t < _EXEC_DIRECTORY_TYPE_MAX; t++)
                 exec_directory_done(&c->directories[t]);
 
         c->log_level_max = -1;
 
         exec_context_free_log_extra_fields(c);
 
         c->log_ratelimit_interval_usec = 0;
         c->log_ratelimit_burst = 0;
 
         c->stdin_data = mfree(c->stdin_data);
         c->stdin_data_size = 0;
 
         c->network_namespace_path = mfree(c->network_namespace_path);
         c->ipc_namespace_path = mfree(c->ipc_namespace_path);
 
         c->log_namespace = mfree(c->log_namespace);
 
         c->load_credentials = hashmap_free(c->load_credentials);
         c->set_credentials = hashmap_free(c->set_credentials);
 }
@@ -5759,479 +5718,474 @@ static void strv_dump(FILE* f, const char *prefix, const char *name, char **strv
 void exec_context_dump(const ExecContext *c, FILE* f, const char *prefix) {
         int r;
 
         assert(c);
         assert(f);
 
         prefix = strempty(prefix);
 
         fprintf(f,
                 "%sUMask: %04o\n"
                 "%sWorkingDirectory: %s\n"
                 "%sRootDirectory: %s\n"
                 "%sNonBlocking: %s\n"
                 "%sPrivateTmp: %s\n"
                 "%sPrivateDevices: %s\n"
                 "%sProtectKernelTunables: %s\n"
                 "%sProtectKernelModules: %s\n"
                 "%sProtectKernelLogs: %s\n"
                 "%sProtectClock: %s\n"
                 "%sProtectControlGroups: %s\n"
                 "%sPrivateNetwork: %s\n"
                 "%sPrivateUsers: %s\n"
                 "%sProtectHome: %s\n"
                 "%sProtectSystem: %s\n"
                 "%sMountAPIVFS: %s\n"
                 "%sIgnoreSIGPIPE: %s\n"
                 "%sMemoryDenyWriteExecute: %s\n"
                 "%sRestrictRealtime: %s\n"
                 "%sRestrictSUIDSGID: %s\n"
                 "%sKeyringMode: %s\n"
                 "%sProtectHostname: %s\n"
                 "%sProtectProc: %s\n"
                 "%sProcSubset: %s\n",
                 prefix, c->umask,
                 prefix, empty_to_root(c->working_directory),
                 prefix, empty_to_root(c->root_directory),
                 prefix, yes_no(c->non_blocking),
                 prefix, yes_no(c->private_tmp),
                 prefix, yes_no(c->private_devices),
                 prefix, yes_no(c->protect_kernel_tunables),
                 prefix, yes_no(c->protect_kernel_modules),
                 prefix, yes_no(c->protect_kernel_logs),
                 prefix, yes_no(c->protect_clock),
                 prefix, yes_no(c->protect_control_groups),
                 prefix, yes_no(c->private_network),
                 prefix, yes_no(c->private_users),
                 prefix, protect_home_to_string(c->protect_home),
                 prefix, protect_system_to_string(c->protect_system),
                 prefix, yes_no(exec_context_get_effective_mount_apivfs(c)),
                 prefix, yes_no(c->ignore_sigpipe),
                 prefix, yes_no(c->memory_deny_write_execute),
                 prefix, yes_no(c->restrict_realtime),
                 prefix, yes_no(c->restrict_suid_sgid),
                 prefix, exec_keyring_mode_to_string(c->keyring_mode),
                 prefix, yes_no(c->protect_hostname),
                 prefix, protect_proc_to_string(c->protect_proc),
                 prefix, proc_subset_to_string(c->proc_subset));
 
         if (c->root_image)
                 fprintf(f, "%sRootImage: %s\n", prefix, c->root_image);
 
         if (c->root_image_options) {
                 fprintf(f, "%sRootImageOptions:", prefix);
                 LIST_FOREACH(mount_options, o, c->root_image_options)
                         if (!isempty(o->options))
                                 fprintf(f, " %s:%s",
                                         partition_designator_to_string(o->partition_designator),
                                         o->options);
                 fprintf(f, "\n");
         }
 
         if (c->root_hash) {
                 _cleanup_free_ char *encoded = NULL;
                 encoded = hexmem(c->root_hash, c->root_hash_size);
                 if (encoded)
                         fprintf(f, "%sRootHash: %s\n", prefix, encoded);
         }
 
         if (c->root_hash_path)
                 fprintf(f, "%sRootHash: %s\n", prefix, c->root_hash_path);
 
         if (c->root_hash_sig) {
                 _cleanup_free_ char *encoded = NULL;
                 ssize_t len;
                 len = base64mem(c->root_hash_sig, c->root_hash_sig_size, &encoded);
                 if (len)
                         fprintf(f, "%sRootHashSignature: base64:%s\n", prefix, encoded);
         }
 
         if (c->root_hash_sig_path)
                 fprintf(f, "%sRootHashSignature: %s\n", prefix, c->root_hash_sig_path);
 
         if (c->root_verity)
                 fprintf(f, "%sRootVerity: %s\n", prefix, c->root_verity);
 
         STRV_FOREACH(e, c->environment)
                 fprintf(f, "%sEnvironment: %s\n", prefix, *e);
 
         STRV_FOREACH(e, c->environment_files)
                 fprintf(f, "%sEnvironmentFile: %s\n", prefix, *e);
 
         STRV_FOREACH(e, c->pass_environment)
                 fprintf(f, "%sPassEnvironment: %s\n", prefix, *e);
 
         STRV_FOREACH(e, c->unset_environment)
                 fprintf(f, "%sUnsetEnvironment: %s\n", prefix, *e);
 
         fprintf(f, "%sRuntimeDirectoryPreserve: %s\n", prefix, exec_preserve_mode_to_string(c->runtime_directory_preserve_mode));
 
         for (ExecDirectoryType dt = 0; dt < _EXEC_DIRECTORY_TYPE_MAX; dt++) {
                 fprintf(f, "%s%sMode: %04o\n", prefix, exec_directory_type_to_string(dt), c->directories[dt].mode);
 
                 for (size_t i = 0; i < c->directories[dt].n_items; i++) {
                         fprintf(f, "%s%s: %s\n", prefix, exec_directory_type_to_string(dt), c->directories[dt].items[i].path);
 
                         STRV_FOREACH(d, c->directories[dt].items[i].symlinks)
                                 fprintf(f, "%s%s: %s:%s\n", prefix, exec_directory_type_symlink_to_string(dt), c->directories[dt].items[i].path, *d);
                 }
         }
 
         fprintf(f, "%sTimeoutCleanSec: %s\n", prefix, FORMAT_TIMESPAN(c->timeout_clean_usec, USEC_PER_SEC));
 
         if (c->nice_set)
                 fprintf(f, "%sNice: %i\n", prefix, c->nice);
 
         if (c->oom_score_adjust_set)
                 fprintf(f, "%sOOMScoreAdjust: %i\n", prefix, c->oom_score_adjust);
 
         if (c->coredump_filter_set)
                 fprintf(f, "%sCoredumpFilter: 0x%"PRIx64"\n", prefix, c->coredump_filter);
 
         for (unsigned i = 0; i < RLIM_NLIMITS; i++)
                 if (c->rlimit[i]) {
                         fprintf(f, "%sLimit%s: " RLIM_FMT "\n",
                                 prefix, rlimit_to_string(i), c->rlimit[i]->rlim_max);
                         fprintf(f, "%sLimit%sSoft: " RLIM_FMT "\n",
                                 prefix, rlimit_to_string(i), c->rlimit[i]->rlim_cur);
                 }
 
         if (c->ioprio_set) {
                 _cleanup_free_ char *class_str = NULL;
 
                 r = ioprio_class_to_string_alloc(ioprio_prio_class(c->ioprio), &class_str);
                 if (r >= 0)
                         fprintf(f, "%sIOSchedulingClass: %s\n", prefix, class_str);
 
                 fprintf(f, "%sIOPriority: %d\n", prefix, ioprio_prio_data(c->ioprio));
         }
 
         if (c->cpu_sched_set) {
                 _cleanup_free_ char *policy_str = NULL;
 
                 r = sched_policy_to_string_alloc(c->cpu_sched_policy, &policy_str);
                 if (r >= 0)
                         fprintf(f, "%sCPUSchedulingPolicy: %s\n", prefix, policy_str);
 
                 fprintf(f,
                         "%sCPUSchedulingPriority: %i\n"
                         "%sCPUSchedulingResetOnFork: %s\n",
                         prefix, c->cpu_sched_priority,
                         prefix, yes_no(c->cpu_sched_reset_on_fork));
         }
 
         if (c->cpu_set.set) {
                 _cleanup_free_ char *affinity = NULL;
 
                 affinity = cpu_set_to_range_string(&c->cpu_set);
                 fprintf(f, "%sCPUAffinity: %s\n", prefix, affinity);
         }
 
         if (mpol_is_valid(numa_policy_get_type(&c->numa_policy))) {
                 _cleanup_free_ char *nodes = NULL;
 
                 nodes = cpu_set_to_range_string(&c->numa_policy.nodes);
                 fprintf(f, "%sNUMAPolicy: %s\n", prefix, mpol_to_string(numa_policy_get_type(&c->numa_policy)));
                 fprintf(f, "%sNUMAMask: %s\n", prefix, strnull(nodes));
         }
 
         if (c->timer_slack_nsec != NSEC_INFINITY)
                 fprintf(f, "%sTimerSlackNSec: "NSEC_FMT "\n", prefix, c->timer_slack_nsec);
 
         fprintf(f,
                 "%sStandardInput: %s\n"
                 "%sStandardOutput: %s\n"
                 "%sStandardError: %s\n",
                 prefix, exec_input_to_string(c->std_input),
                 prefix, exec_output_to_string(c->std_output),
                 prefix, exec_output_to_string(c->std_error));
 
         if (c->std_input == EXEC_INPUT_NAMED_FD)
                 fprintf(f, "%sStandardInputFileDescriptorName: %s\n", prefix, c->stdio_fdname[STDIN_FILENO]);
         if (c->std_output == EXEC_OUTPUT_NAMED_FD)
                 fprintf(f, "%sStandardOutputFileDescriptorName: %s\n", prefix, c->stdio_fdname[STDOUT_FILENO]);
         if (c->std_error == EXEC_OUTPUT_NAMED_FD)
                 fprintf(f, "%sStandardErrorFileDescriptorName: %s\n", prefix, c->stdio_fdname[STDERR_FILENO]);
 
         if (c->std_input == EXEC_INPUT_FILE)
                 fprintf(f, "%sStandardInputFile: %s\n", prefix, c->stdio_file[STDIN_FILENO]);
         if (c->std_output == EXEC_OUTPUT_FILE)
                 fprintf(f, "%sStandardOutputFile: %s\n", prefix, c->stdio_file[STDOUT_FILENO]);
         if (c->std_output == EXEC_OUTPUT_FILE_APPEND)
                 fprintf(f, "%sStandardOutputFileToAppend: %s\n", prefix, c->stdio_file[STDOUT_FILENO]);
         if (c->std_output == EXEC_OUTPUT_FILE_TRUNCATE)
                 fprintf(f, "%sStandardOutputFileToTruncate: %s\n", prefix, c->stdio_file[STDOUT_FILENO]);
         if (c->std_error == EXEC_OUTPUT_FILE)
                 fprintf(f, "%sStandardErrorFile: %s\n", prefix, c->stdio_file[STDERR_FILENO]);
         if (c->std_error == EXEC_OUTPUT_FILE_APPEND)
                 fprintf(f, "%sStandardErrorFileToAppend: %s\n", prefix, c->stdio_file[STDERR_FILENO]);
         if (c->std_error == EXEC_OUTPUT_FILE_TRUNCATE)
                 fprintf(f, "%sStandardErrorFileToTruncate: %s\n", prefix, c->stdio_file[STDERR_FILENO]);
 
         if (c->tty_path)
                 fprintf(f,
                         "%sTTYPath: %s\n"
                         "%sTTYReset: %s\n"
                         "%sTTYVHangup: %s\n"
                         "%sTTYVTDisallocate: %s\n"
                         "%sTTYRows: %u\n"
                         "%sTTYColumns: %u\n",
                         prefix, c->tty_path,
                         prefix, yes_no(c->tty_reset),
                         prefix, yes_no(c->tty_vhangup),
                         prefix, yes_no(c->tty_vt_disallocate),
                         prefix, c->tty_rows,
                         prefix, c->tty_cols);
 
         if (IN_SET(c->std_output,
                    EXEC_OUTPUT_KMSG,
                    EXEC_OUTPUT_JOURNAL,
                    EXEC_OUTPUT_KMSG_AND_CONSOLE,
                    EXEC_OUTPUT_JOURNAL_AND_CONSOLE) ||
             IN_SET(c->std_error,
                    EXEC_OUTPUT_KMSG,
                    EXEC_OUTPUT_JOURNAL,
                    EXEC_OUTPUT_KMSG_AND_CONSOLE,
                    EXEC_OUTPUT_JOURNAL_AND_CONSOLE)) {
 
                 _cleanup_free_ char *fac_str = NULL, *lvl_str = NULL;
 
                 r = log_facility_unshifted_to_string_alloc(c->syslog_priority >> 3, &fac_str);
                 if (r >= 0)
                         fprintf(f, "%sSyslogFacility: %s\n", prefix, fac_str);
 
                 r = log_level_to_string_alloc(LOG_PRI(c->syslog_priority), &lvl_str);
                 if (r >= 0)
                         fprintf(f, "%sSyslogLevel: %s\n", prefix, lvl_str);
         }
 
         if (c->log_level_max >= 0) {
                 _cleanup_free_ char *t = NULL;
 
                 (void) log_level_to_string_alloc(c->log_level_max, &t);
 
                 fprintf(f, "%sLogLevelMax: %s\n", prefix, strna(t));
         }
 
         if (c->log_ratelimit_interval_usec > 0)
                 fprintf(f,
                         "%sLogRateLimitIntervalSec: %s\n",
                         prefix, FORMAT_TIMESPAN(c->log_ratelimit_interval_usec, USEC_PER_SEC));
 
         if (c->log_ratelimit_burst > 0)
                 fprintf(f, "%sLogRateLimitBurst: %u\n", prefix, c->log_ratelimit_burst);
 
         for (size_t j = 0; j < c->n_log_extra_fields; j++) {
                 fprintf(f, "%sLogExtraFields: ", prefix);
                 fwrite(c->log_extra_fields[j].iov_base,
                        1, c->log_extra_fields[j].iov_len,
                        f);
                 fputc('\n', f);
         }
 
         if (c->log_namespace)
                 fprintf(f, "%sLogNamespace: %s\n", prefix, c->log_namespace);
 
         if (c->secure_bits) {
                 _cleanup_free_ char *str = NULL;
 
                 r = secure_bits_to_string_alloc(c->secure_bits, &str);
                 if (r >= 0)
                         fprintf(f, "%sSecure Bits: %s\n", prefix, str);
         }
 
         if (c->capability_bounding_set != CAP_ALL) {
                 _cleanup_free_ char *str = NULL;
 
                 r = capability_set_to_string_alloc(c->capability_bounding_set, &str);
                 if (r >= 0)
                         fprintf(f, "%sCapabilityBoundingSet: %s\n", prefix, str);
         }
 
         if (c->capability_ambient_set != 0) {
                 _cleanup_free_ char *str = NULL;
 
                 r = capability_set_to_string_alloc(c->capability_ambient_set, &str);
                 if (r >= 0)
                         fprintf(f, "%sAmbientCapabilities: %s\n", prefix, str);
         }
 
         if (c->user)
                 fprintf(f, "%sUser: %s\n", prefix, c->user);
         if (c->group)
                 fprintf(f, "%sGroup: %s\n", prefix, c->group);
 
         fprintf(f, "%sDynamicUser: %s\n", prefix, yes_no(c->dynamic_user));
-        for (size_t i = 0; i < c->n_dynamic_user_nft_set_contexts; i++)
-                fprintf(f, "%sDynamicUserNFTSet: %s:%s:%s\n", prefix,
-                        nfproto_to_string(c->dynamic_user_nft_set_context[i].nfproto),
-                        c->dynamic_user_nft_set_context[i].table,
-                        c->dynamic_user_nft_set_context[i].set);
 
         strv_dump(f, prefix, "SupplementaryGroups", c->supplementary_groups);
 
         if (c->pam_name)
                 fprintf(f, "%sPAMName: %s\n", prefix, c->pam_name);
 
         strv_dump(f, prefix, "ReadWritePaths", c->read_write_paths);
         strv_dump(f, prefix, "ReadOnlyPaths", c->read_only_paths);
         strv_dump(f, prefix, "InaccessiblePaths", c->inaccessible_paths);
         strv_dump(f, prefix, "ExecPaths", c->exec_paths);
         strv_dump(f, prefix, "NoExecPaths", c->no_exec_paths);
         strv_dump(f, prefix, "ExecSearchPath", c->exec_search_path);
 
         for (size_t i = 0; i < c->n_bind_mounts; i++)
                 fprintf(f, "%s%s: %s%s:%s:%s\n", prefix,
                         c->bind_mounts[i].read_only ? "BindReadOnlyPaths" : "BindPaths",
                         c->bind_mounts[i].ignore_enoent ? "-": "",
                         c->bind_mounts[i].source,
                         c->bind_mounts[i].destination,
                         c->bind_mounts[i].recursive ? "rbind" : "norbind");
 
         for (size_t i = 0; i < c->n_temporary_filesystems; i++) {
                 const TemporaryFileSystem *t = c->temporary_filesystems + i;
 
                 fprintf(f, "%sTemporaryFileSystem: %s%s%s\n", prefix,
                         t->path,
                         isempty(t->options) ? "" : ":",
                         strempty(t->options));
         }
 
         if (c->utmp_id)
                 fprintf(f,
                         "%sUtmpIdentifier: %s\n",
                         prefix, c->utmp_id);
 
         if (c->selinux_context)
                 fprintf(f,
                         "%sSELinuxContext: %s%s\n",
                         prefix, c->selinux_context_ignore ? "-" : "", c->selinux_context);
 
         if (c->apparmor_profile)
                 fprintf(f,
                         "%sAppArmorProfile: %s%s\n",
                         prefix, c->apparmor_profile_ignore ? "-" : "", c->apparmor_profile);
 
         if (c->smack_process_label)
                 fprintf(f,
                         "%sSmackProcessLabel: %s%s\n",
                         prefix, c->smack_process_label_ignore ? "-" : "", c->smack_process_label);
 
         if (c->personality != PERSONALITY_INVALID)
                 fprintf(f,
                         "%sPersonality: %s\n",
                         prefix, strna(personality_to_string(c->personality)));
 
         fprintf(f,
                 "%sLockPersonality: %s\n",
                 prefix, yes_no(c->lock_personality));
 
         if (c->syscall_filter) {
                 fprintf(f,
                         "%sSystemCallFilter: ",
                         prefix);
 
                 if (!c->syscall_allow_list)
                         fputc('~', f);
 
 #if HAVE_SECCOMP
                 void *id, *val;
                 bool first = true;
                 HASHMAP_FOREACH_KEY(val, id, c->syscall_filter) {
                         _cleanup_free_ char *name = NULL;
                         const char *errno_name = NULL;
                         int num = PTR_TO_INT(val);
 
                         if (first)
                                 first = false;
                         else
                                 fputc(' ', f);
 
                         name = seccomp_syscall_resolve_num_arch(SCMP_ARCH_NATIVE, PTR_TO_INT(id) - 1);
                         fputs(strna(name), f);
 
                         if (num >= 0) {
                                 errno_name = seccomp_errno_or_action_to_string(num);
                                 if (errno_name)
                                         fprintf(f, ":%s", errno_name);
                                 else
                                         fprintf(f, ":%d", num);
                         }
                 }
 #endif
 
                 fputc('\n', f);
         }
 
         if (c->syscall_archs) {
                 fprintf(f,
                         "%sSystemCallArchitectures:",
                         prefix);
 
 #if HAVE_SECCOMP
                 void *id;
                 SET_FOREACH(id, c->syscall_archs)
                         fprintf(f, " %s", strna(seccomp_arch_to_string(PTR_TO_UINT32(id) - 1)));
 #endif
                 fputc('\n', f);
         }
 
         if (exec_context_restrict_namespaces_set(c)) {
                 _cleanup_free_ char *s = NULL;
 
                 r = namespace_flags_to_string(c->restrict_namespaces, &s);
                 if (r >= 0)
                         fprintf(f, "%sRestrictNamespaces: %s\n",
                                 prefix, strna(s));
         }
 
 #if HAVE_LIBBPF
         if (exec_context_restrict_filesystems_set(c)) {
                 char *fs;
                 SET_FOREACH(fs, c->restrict_filesystems)
                         fprintf(f, "%sRestrictFileSystems: %s\n", prefix, fs);
         }
 #endif
 
         if (c->network_namespace_path)
                 fprintf(f,
                         "%sNetworkNamespacePath: %s\n",
                         prefix, c->network_namespace_path);
 
         if (c->syscall_errno > 0) {
                 fprintf(f, "%sSystemCallErrorNumber: ", prefix);
 
 #if HAVE_SECCOMP
                 const char *errno_name = seccomp_errno_or_action_to_string(c->syscall_errno);
                 if (errno_name)
                         fputs(errno_name, f);
                 else
                         fprintf(f, "%d", c->syscall_errno);
 #endif
                 fputc('\n', f);
         }
 
         for (size_t i = 0; i < c->n_mount_images; i++) {
                 fprintf(f, "%sMountImages: %s%s:%s", prefix,
                         c->mount_images[i].ignore_enoent ? "-": "",
                         c->mount_images[i].source,
                         c->mount_images[i].destination);
                 LIST_FOREACH(mount_options, o, c->mount_images[i].mount_options)
                         fprintf(f, ":%s:%s",
                                 partition_designator_to_string(o->partition_designator),
                                 strempty(o->options));
                 fprintf(f, "\n");
         }
 
         for (size_t i = 0; i < c->n_extension_images; i++) {
                 fprintf(f, "%sExtensionImages: %s%s", prefix,
                         c->extension_images[i].ignore_enoent ? "-": "",
                         c->extension_images[i].source);
                 LIST_FOREACH(mount_options, o, c->extension_images[i].mount_options)
                         fprintf(f, ":%s:%s",
                                 partition_designator_to_string(o->partition_designator),
                                 strempty(o->options));
                 fprintf(f, "\n");
         }
 
         strv_dump(f, prefix, "ExtensionDirectories", c->extension_directories);
 }
diff --git a/src/core/execute.h b/src/core/execute.h
index b3516c29fc..904e7943f3 100644
--- a/src/core/execute.h
+++ b/src/core/execute.h
@@ -9,22 +9,21 @@ typedef struct ExecParameters ExecParameters;
 typedef struct Manager Manager;
 
 #include <sched.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <sys/capability.h>
 
 #include "cgroup-util.h"
 #include "coredump-util.h"
 #include "cpu-set-util.h"
 #include "exec-util.h"
 #include "fdset.h"
-#include "firewall-util.h"
 #include "list.h"
 #include "missing_resource.h"
 #include "namespace.h"
 #include "nsflags.h"
 #include "numa-util.h"
 #include "path-util.h"
 #include "time-util.h"
 
 #define EXEC_STDIN_DATA_MAX (64U*1024U*1024U)
@@ -174,181 +173,178 @@ typedef struct ExecSetCredential {
 /* Encodes configuration parameters applied to invoked commands. Does not carry runtime data, but only configuration
  * changes sourced from unit files and suchlike. ExecContext objects are usually embedded into Unit objects, and do not
  * change after being loaded. */
 struct ExecContext {
         char **environment;
         char **environment_files;
         char **pass_environment;
         char **unset_environment;
 
         struct rlimit *rlimit[_RLIMIT_MAX];
         char *working_directory, *root_directory, *root_image, *root_verity, *root_hash_path, *root_hash_sig_path;
         void *root_hash, *root_hash_sig;
         size_t root_hash_size, root_hash_sig_size;
         LIST_HEAD(MountOptions, root_image_options);
         bool working_directory_missing_ok:1;
         bool working_directory_home:1;
 
         bool oom_score_adjust_set:1;
         bool coredump_filter_set:1;
         bool nice_set:1;
         bool ioprio_set:1;
         bool cpu_sched_set:1;
         bool mount_apivfs_set:1;
 
         /* This is not exposed to the user but available internally. We need it to make sure that whenever we
          * spawn /usr/bin/mount it is run in the same process group as us so that the autofs logic detects
          * that it belongs to us and we don't enter a trigger loop. */
         bool same_pgrp;
 
         bool cpu_sched_reset_on_fork;
         bool non_blocking;
 
         mode_t umask;
         int oom_score_adjust;
         int nice;
         int ioprio;
         int cpu_sched_policy;
         int cpu_sched_priority;
         uint64_t coredump_filter;
 
         CPUSet cpu_set;
         NUMAPolicy numa_policy;
         bool cpu_affinity_from_numa;
 
         ExecInput std_input;
         ExecOutput std_output;
         ExecOutput std_error;
         bool stdio_as_fds;
         char *stdio_fdname[3];
         char *stdio_file[3];
 
         void *stdin_data;
         size_t stdin_data_size;
 
         nsec_t timer_slack_nsec;
 
         char *tty_path;
 
         bool tty_reset;
         bool tty_vhangup;
         bool tty_vt_disallocate;
 
         unsigned tty_rows;
         unsigned tty_cols;
 
         bool ignore_sigpipe;
 
         ExecKeyringMode keyring_mode;
 
         /* Since resolving these names might involve socket
          * connections and we don't want to deadlock ourselves these
          * names are resolved on execution only and in the child
          * process. */
         char *user;
         char *group;
         char **supplementary_groups;
 
         char *pam_name;
 
         char *utmp_id;
         ExecUtmpMode utmp_mode;
 
         bool no_new_privileges;
 
         bool selinux_context_ignore;
         bool apparmor_profile_ignore;
         bool smack_process_label_ignore;
 
         char *selinux_context;
         char *apparmor_profile;
         char *smack_process_label;
 
         char **read_write_paths, **read_only_paths, **inaccessible_paths, **exec_paths, **no_exec_paths;
         char **exec_search_path;
         unsigned long mount_flags;
         BindMount *bind_mounts;
         size_t n_bind_mounts;
         TemporaryFileSystem *temporary_filesystems;
         size_t n_temporary_filesystems;
         MountImage *mount_images;
         size_t n_mount_images;
         MountImage *extension_images;
         size_t n_extension_images;
         char **extension_directories;
 
         uint64_t capability_bounding_set;
         uint64_t capability_ambient_set;
         int secure_bits;
 
         int syslog_priority;
         bool syslog_level_prefix;
         char *syslog_identifier;
 
         struct iovec* log_extra_fields;
         size_t n_log_extra_fields;
 
         usec_t log_ratelimit_interval_usec;
         unsigned log_ratelimit_burst;
 
         int log_level_max;
 
         char *log_namespace;
 
         ProtectProc protect_proc;  /* hidepid= */
         ProcSubset proc_subset;    /* subset= */
 
         bool private_tmp;
         bool private_network;
         bool private_devices;
         bool private_users;
         bool private_mounts;
         bool private_ipc;
         bool protect_kernel_tunables;
         bool protect_kernel_modules;
         bool protect_kernel_logs;
         bool protect_clock;
         bool protect_control_groups;
         ProtectSystem protect_system;
         ProtectHome protect_home;
         bool protect_hostname;
         bool mount_apivfs;
 
         bool dynamic_user;
-        size_t n_dynamic_user_nft_set_contexts;
-        NFTSetContext *dynamic_user_nft_set_context;
-
         bool remove_ipc;
 
         bool memory_deny_write_execute;
         bool restrict_realtime;
         bool restrict_suid_sgid;
 
         bool lock_personality;
         unsigned long personality;
 
         unsigned long restrict_namespaces; /* The CLONE_NEWxyz flags permitted to the unit's processes */
 
         Set *restrict_filesystems;
         bool restrict_filesystems_allow_list:1;
 
         Hashmap *syscall_filter;
         Set *syscall_archs;
         int syscall_errno;
         bool syscall_allow_list:1;
 
         Hashmap *syscall_log;
         bool syscall_log_allow_list:1; /* Log listed system calls */
 
         bool address_families_allow_list:1;
         Set *address_families;
 
         char *network_namespace_path;
         char *ipc_namespace_path;
 
         ExecDirectory directories[_EXEC_DIRECTORY_TYPE_MAX];
         ExecPreserveMode runtime_directory_preserve_mode;
         usec_t timeout_clean_usec;
 
         Hashmap *set_credentials; /* output id  ExecSetCredential */
         Hashmap *load_credentials; /* output id  ExecLoadCredential */
 };
@@ -526,5 +522,3 @@ const char* exec_resource_type_to_string(ExecDirectoryType i) _const_;
 ExecDirectoryType exec_resource_type_from_string(const char *s) _pure_;
 
 bool exec_needs_mount_namespace(const ExecContext *context, const ExecParameters *params, const ExecRuntime *runtime);
-
-void exec_delete_dynamic_user_nft_set(const ExecContext *c, DynamicUser *d);
diff --git a/src/core/load-fragment-gperf.gperf.in b/src/core/load-fragment-gperf.gperf.in
index facda69d0d..7817c20c0b 100644
--- a/src/core/load-fragment-gperf.gperf.in
+++ b/src/core/load-fragment-gperf.gperf.in
@@ -1,249 +1,247 @@
 {# SPDX-License-Identifier: LGPL-2.1-or-later #}
 
 {%- macro EXEC_CONTEXT_CONFIG_ITEMS(type) -%}
 {# Define the context options only once #}
 {{type}}.WorkingDirectory,                 config_parse_working_directory,              0,                                  offsetof({{type}}, exec_context)
 {{type}}.RootDirectory,                    config_parse_unit_path_printf,               true,                               offsetof({{type}}, exec_context.root_directory)
 {{type}}.RootImage,                        config_parse_unit_path_printf,               true,                               offsetof({{type}}, exec_context.root_image)
 {{type}}.RootImageOptions,                 config_parse_root_image_options,             0,                                  offsetof({{type}}, exec_context)
 {{type}}.RootHash,                         config_parse_exec_root_hash,                 0,                                  offsetof({{type}}, exec_context)
 {{type}}.RootHashSignature,                config_parse_exec_root_hash_sig,             0,                                  offsetof({{type}}, exec_context)
 {{type}}.RootVerity,                       config_parse_unit_path_printf,               true,                               offsetof({{type}}, exec_context.root_verity)
 {{type}}.ExtensionDirectories,             config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.extension_directories)
 {{type}}.ExtensionImages,                  config_parse_extension_images,               0,                                  offsetof({{type}}, exec_context)
 {{type}}.MountImages,                      config_parse_mount_images,                   0,                                  offsetof({{type}}, exec_context)
 {{type}}.User,                             config_parse_user_group_compat,              0,                                  offsetof({{type}}, exec_context.user)
 {{type}}.Group,                            config_parse_user_group_compat,              0,                                  offsetof({{type}}, exec_context.group)
 {{type}}.SupplementaryGroups,              config_parse_user_group_strv_compat,         0,                                  offsetof({{type}}, exec_context.supplementary_groups)
 {{type}}.Nice,                             config_parse_exec_nice,                      0,                                  offsetof({{type}}, exec_context)
 {{type}}.OOMScoreAdjust,                   config_parse_exec_oom_score_adjust,          0,                                  offsetof({{type}}, exec_context)
 {{type}}.CoredumpFilter,                   config_parse_exec_coredump_filter,           0,                                  offsetof({{type}}, exec_context)
 {{type}}.IOSchedulingClass,                config_parse_exec_io_class,                  0,                                  offsetof({{type}}, exec_context)
 {{type}}.IOSchedulingPriority,             config_parse_exec_io_priority,               0,                                  offsetof({{type}}, exec_context)
 {{type}}.CPUSchedulingPolicy,              config_parse_exec_cpu_sched_policy,          0,                                  offsetof({{type}}, exec_context)
 {{type}}.CPUSchedulingPriority,            config_parse_exec_cpu_sched_prio,            0,                                  offsetof({{type}}, exec_context)
 {{type}}.CPUSchedulingResetOnFork,         config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.cpu_sched_reset_on_fork)
 {{type}}.CPUAffinity,                      config_parse_exec_cpu_affinity,              0,                                  offsetof({{type}}, exec_context)
 {{type}}.NUMAPolicy,                       config_parse_numa_policy,                    0,                                  offsetof({{type}}, exec_context.numa_policy.type)
 {{type}}.NUMAMask,                         config_parse_numa_mask,                      0,                                  offsetof({{type}}, exec_context.numa_policy)
 {{type}}.UMask,                            config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.umask)
 {{type}}.Environment,                      config_parse_environ,                        0,                                  offsetof({{type}}, exec_context.environment)
 {{type}}.EnvironmentFile,                  config_parse_unit_env_file,                  0,                                  offsetof({{type}}, exec_context.environment_files)
 {{type}}.PassEnvironment,                  config_parse_pass_environ,                   0,                                  offsetof({{type}}, exec_context.pass_environment)
 {{type}}.UnsetEnvironment,                 config_parse_unset_environ,                  0,                                  offsetof({{type}}, exec_context.unset_environment)
 {{type}}.DynamicUser,                      config_parse_bool,                           true,                               offsetof({{type}}, exec_context.dynamic_user)
-{{type}}.DynamicUserNFTSet,                config_parse_dynamic_user_nft_set,           0,                                  offsetof({{type}}, exec_context)
 {{type}}.RemoveIPC,                        config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.remove_ipc)
 {{type}}.StandardInput,                    config_parse_exec_input,                     0,                                  offsetof({{type}}, exec_context)
 {{type}}.StandardOutput,                   config_parse_exec_output,                    0,                                  offsetof({{type}}, exec_context)
 {{type}}.StandardError,                    config_parse_exec_output,                    0,                                  offsetof({{type}}, exec_context)
 {{type}}.StandardInputText,                config_parse_exec_input_text,                0,                                  offsetof({{type}}, exec_context)
 {{type}}.StandardInputData,                config_parse_exec_input_data,                0,                                  offsetof({{type}}, exec_context)
 {{type}}.TTYPath,                          config_parse_unit_path_printf,               0,                                  offsetof({{type}}, exec_context.tty_path)
 {{type}}.TTYReset,                         config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.tty_reset)
 {{type}}.TTYVHangup,                       config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.tty_vhangup)
 {{type}}.TTYVTDisallocate,                 config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.tty_vt_disallocate)
 {{type}}.TTYRows,                          config_parse_tty_size,                       0,                                  offsetof({{type}}, exec_context.tty_rows)
 {{type}}.TTYColumns,                       config_parse_tty_size,                       0,                                  offsetof({{type}}, exec_context.tty_cols)
 {{type}}.SyslogIdentifier,                 config_parse_unit_string_printf,             0,                                  offsetof({{type}}, exec_context.syslog_identifier)
 {{type}}.SyslogFacility,                   config_parse_log_facility,                   0,                                  offsetof({{type}}, exec_context.syslog_priority)
 {{type}}.SyslogLevel,                      config_parse_log_level,                      0,                                  offsetof({{type}}, exec_context.syslog_priority)
 {{type}}.SyslogLevelPrefix,                config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.syslog_level_prefix)
 {{type}}.LogLevelMax,                      config_parse_log_level,                      0,                                  offsetof({{type}}, exec_context.log_level_max)
 {{type}}.LogRateLimitIntervalSec,          config_parse_sec,                            0,                                  offsetof({{type}}, exec_context.log_ratelimit_interval_usec)
 {{type}}.LogRateLimitBurst,                config_parse_unsigned,                       0,                                  offsetof({{type}}, exec_context.log_ratelimit_burst)
 {{type}}.LogExtraFields,                   config_parse_log_extra_fields,               0,                                  offsetof({{type}}, exec_context)
 {{type}}.Capabilities,                     config_parse_warn_compat,                    DISABLED_LEGACY,                    offsetof({{type}}, exec_context)
 {{type}}.SecureBits,                       config_parse_exec_secure_bits,               0,                                  offsetof({{type}}, exec_context.secure_bits)
 {{type}}.CapabilityBoundingSet,            config_parse_capability_set,                 0,                                  offsetof({{type}}, exec_context.capability_bounding_set)
 {{type}}.AmbientCapabilities,              config_parse_capability_set,                 0,                                  offsetof({{type}}, exec_context.capability_ambient_set)
 {{type}}.TimerSlackNSec,                   config_parse_nsec,                           0,                                  offsetof({{type}}, exec_context.timer_slack_nsec)
 {{type}}.NoNewPrivileges,                  config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.no_new_privileges)
 {{type}}.KeyringMode,                      config_parse_exec_keyring_mode,              0,                                  offsetof({{type}}, exec_context.keyring_mode)
 {{type}}.ProtectProc,                      config_parse_protect_proc,                   0,                                  offsetof({{type}}, exec_context.protect_proc)
 {{type}}.ProcSubset,                       config_parse_proc_subset,                    0,                                  offsetof({{type}}, exec_context.proc_subset)
 {% if HAVE_SECCOMP %}
 {{type}}.SystemCallFilter,                 config_parse_syscall_filter,                 0,                                  offsetof({{type}}, exec_context)
 {{type}}.SystemCallArchitectures,          config_parse_syscall_archs,                  0,                                  offsetof({{type}}, exec_context.syscall_archs)
 {{type}}.SystemCallErrorNumber,            config_parse_syscall_errno,                  0,                                  offsetof({{type}}, exec_context)
 {{type}}.SystemCallLog,                    config_parse_syscall_log,                    0,                                  offsetof({{type}}, exec_context)
 {{type}}.MemoryDenyWriteExecute,           config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.memory_deny_write_execute)
 {{type}}.RestrictNamespaces,               config_parse_restrict_namespaces,            0,                                  offsetof({{type}}, exec_context)
 {{type}}.RestrictRealtime,                 config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.restrict_realtime)
 {{type}}.RestrictSUIDSGID,                 config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.restrict_suid_sgid)
 {{type}}.RestrictAddressFamilies,          config_parse_address_families,               0,                                  offsetof({{type}}, exec_context)
 {{type}}.LockPersonality,                  config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.lock_personality)
 {% else %}
 {{type}}.SystemCallFilter,                 config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.SystemCallArchitectures,          config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.SystemCallErrorNumber,            config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.SystemCallLog,                    config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.MemoryDenyWriteExecute,           config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.RestrictNamespaces,               config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.RestrictRealtime,                 config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.RestrictSUIDSGID,                 config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.RestrictAddressFamilies,          config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {{type}}.LockPersonality,                  config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {% endif %}
 {{type}}.RestrictFileSystems,              config_parse_restrict_filesystems,           0,                                  offsetof({{type}}, exec_context)
 {{type}}.LimitCPU,                         config_parse_rlimit,                         RLIMIT_CPU,                         offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitFSIZE,                       config_parse_rlimit,                         RLIMIT_FSIZE,                       offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitDATA,                        config_parse_rlimit,                         RLIMIT_DATA,                        offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitSTACK,                       config_parse_rlimit,                         RLIMIT_STACK,                       offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitCORE,                        config_parse_rlimit,                         RLIMIT_CORE,                        offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitRSS,                         config_parse_rlimit,                         RLIMIT_RSS,                         offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitNOFILE,                      config_parse_rlimit,                         RLIMIT_NOFILE,                      offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitAS,                          config_parse_rlimit,                         RLIMIT_AS,                          offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitNPROC,                       config_parse_rlimit,                         RLIMIT_NPROC,                       offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitMEMLOCK,                     config_parse_rlimit,                         RLIMIT_MEMLOCK,                     offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitLOCKS,                       config_parse_rlimit,                         RLIMIT_LOCKS,                       offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitSIGPENDING,                  config_parse_rlimit,                         RLIMIT_SIGPENDING,                  offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitMSGQUEUE,                    config_parse_rlimit,                         RLIMIT_MSGQUEUE,                    offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitNICE,                        config_parse_rlimit,                         RLIMIT_NICE,                        offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitRTPRIO,                      config_parse_rlimit,                         RLIMIT_RTPRIO,                      offsetof({{type}}, exec_context.rlimit)
 {{type}}.LimitRTTIME,                      config_parse_rlimit,                         RLIMIT_RTTIME,                      offsetof({{type}}, exec_context.rlimit)
 {{type}}.ReadWriteDirectories,             config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.read_write_paths)
 {{type}}.ReadOnlyDirectories,              config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.read_only_paths)
 {{type}}.InaccessibleDirectories,          config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.inaccessible_paths)
 {{type}}.ReadWritePaths,                   config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.read_write_paths)
 {{type}}.ReadOnlyPaths,                    config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.read_only_paths)
 {{type}}.InaccessiblePaths,                config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.inaccessible_paths)
 {{type}}.ExecPaths,                        config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.exec_paths)
 {{type}}.NoExecPaths,                      config_parse_namespace_path_strv,            0,                                  offsetof({{type}}, exec_context.no_exec_paths)
 {{type}}.ExecSearchPath,                   config_parse_colon_separated_paths,          0,                                  offsetof({{type}}, exec_context.exec_search_path)
 {{type}}.BindPaths,                        config_parse_bind_paths,                     0,                                  offsetof({{type}}, exec_context)
 {{type}}.BindReadOnlyPaths,                config_parse_bind_paths,                     0,                                  offsetof({{type}}, exec_context)
 {{type}}.TemporaryFileSystem,              config_parse_temporary_filesystems,          0,                                  offsetof({{type}}, exec_context)
 {{type}}.PrivateTmp,                       config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_tmp)
 {{type}}.PrivateDevices,                   config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_devices)
 {{type}}.ProtectKernelTunables,            config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_kernel_tunables)
 {{type}}.ProtectKernelModules,             config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_kernel_modules)
 {{type}}.ProtectKernelLogs,                config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_kernel_logs)
 {{type}}.ProtectClock,                     config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_clock)
 {{type}}.ProtectControlGroups,             config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_control_groups)
 {{type}}.NetworkNamespacePath,             config_parse_unit_path_printf,               0,                                  offsetof({{type}}, exec_context.network_namespace_path)
 {{type}}.IPCNamespacePath,                 config_parse_unit_path_printf,               0,                                  offsetof({{type}}, exec_context.ipc_namespace_path)
 {{type}}.LogNamespace,                     config_parse_log_namespace,                  0,                                  offsetof({{type}}, exec_context)
 {{type}}.PrivateNetwork,                   config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_network)
 {{type}}.PrivateUsers,                     config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_users)
 {{type}}.PrivateMounts,                    config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_mounts)
 {{type}}.PrivateIPC,                       config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.private_ipc)
 {{type}}.ProtectSystem,                    config_parse_protect_system,                 0,                                  offsetof({{type}}, exec_context.protect_system)
 {{type}}.ProtectHome,                      config_parse_protect_home,                   0,                                  offsetof({{type}}, exec_context.protect_home)
 {{type}}.MountFlags,                       config_parse_exec_mount_flags,               0,                                  offsetof({{type}}, exec_context.mount_flags)
 {{type}}.MountAPIVFS,                      config_parse_exec_mount_apivfs,              0,                                  offsetof({{type}}, exec_context)
 {{type}}.Personality,                      config_parse_personality,                    0,                                  offsetof({{type}}, exec_context.personality)
 {{type}}.RuntimeDirectoryPreserve,         config_parse_runtime_preserve_mode,          0,                                  offsetof({{type}}, exec_context.runtime_directory_preserve_mode)
 {{type}}.RuntimeDirectoryMode,             config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_RUNTIME].mode)
 {{type}}.RuntimeDirectory,                 config_parse_exec_directories,               0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_RUNTIME])
 {{type}}.StateDirectoryMode,               config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_STATE].mode)
 {{type}}.StateDirectory,                   config_parse_exec_directories,               0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_STATE])
 {{type}}.CacheDirectoryMode,               config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_CACHE].mode)
 {{type}}.CacheDirectory,                   config_parse_exec_directories,               0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_CACHE])
 {{type}}.LogsDirectoryMode,                config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_LOGS].mode)
 {{type}}.LogsDirectory,                    config_parse_exec_directories,               0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_LOGS])
 {{type}}.ConfigurationDirectoryMode,       config_parse_mode,                           0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_CONFIGURATION].mode)
 {{type}}.ConfigurationDirectory,           config_parse_exec_directories,               0,                                  offsetof({{type}}, exec_context.directories[EXEC_DIRECTORY_CONFIGURATION])
 {{type}}.SetCredential,                    config_parse_set_credential,                 0,                                  offsetof({{type}}, exec_context)
 {{type}}.SetCredentialEncrypted,           config_parse_set_credential,                 1,                                  offsetof({{type}}, exec_context)
 {{type}}.LoadCredential,                   config_parse_load_credential,                0,                                  offsetof({{type}}, exec_context)
 {{type}}.LoadCredentialEncrypted,          config_parse_load_credential,                1,                                  offsetof({{type}}, exec_context)
 {{type}}.TimeoutCleanSec,                  config_parse_sec,                            0,                                  offsetof({{type}}, exec_context.timeout_clean_usec)
 {% if HAVE_PAM %}
 {{type}}.PAMName,                          config_parse_unit_string_printf,             0,                                  offsetof({{type}}, exec_context.pam_name)
 {% else %}
 {{type}}.PAMName,                          config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {% endif %}
 {{type}}.IgnoreSIGPIPE,                    config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.ignore_sigpipe)
 {{type}}.UtmpIdentifier,                   config_parse_unit_string_printf,             0,                                  offsetof({{type}}, exec_context.utmp_id)
 {{type}}.UtmpMode,                         config_parse_exec_utmp_mode,                 0,                                  offsetof({{type}}, exec_context.utmp_mode)
 {% if HAVE_SELINUX %}
 {{type}}.SELinuxContext,                   config_parse_exec_selinux_context,           0,                                  offsetof({{type}}, exec_context)
 {% else %}
 {{type}}.SELinuxContext,                   config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {% endif %}
 {% if HAVE_APPARMOR %}
 {{type}}.AppArmorProfile,                  config_parse_exec_apparmor_profile,          0,                                  offsetof({{type}}, exec_context)
 {% else %}
 {{type}}.AppArmorProfile,                  config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {% endif %}
 {% if ENABLE_SMACK %}
 {{type}}.SmackProcessLabel,                config_parse_exec_smack_process_label,       0,                                  offsetof({{type}}, exec_context)
 {% else %}
 {{type}}.SmackProcessLabel,                config_parse_warn_compat,                    DISABLED_CONFIGURATION,             0
 {% endif %}
 {{type}}.ProtectHostname,                  config_parse_bool,                           0,                                  offsetof({{type}}, exec_context.protect_hostname)
 {%- endmacro -%}
 
 {%- macro KILL_CONTEXT_CONFIG_ITEMS(type) -%}
 {{type}}.SendSIGKILL,                      config_parse_bool,                           0,                                  offsetof({{type}}, kill_context.send_sigkill)
 {{type}}.SendSIGHUP,                       config_parse_bool,                           0,                                  offsetof({{type}}, kill_context.send_sighup)
 {{type}}.KillMode,                         config_parse_kill_mode,                      0,                                  offsetof({{type}}, kill_context.kill_mode)
 {{type}}.KillSignal,                       config_parse_signal,                         0,                                  offsetof({{type}}, kill_context.kill_signal)
 {{type}}.RestartKillSignal,                config_parse_signal,                         0,                                  offsetof({{type}}, kill_context.restart_kill_signal)
 {{type}}.FinalKillSignal,                  config_parse_signal,                         0,                                  offsetof({{type}}, kill_context.final_kill_signal)
 {{type}}.WatchdogSignal,                   config_parse_signal,                         0,                                  offsetof({{type}}, kill_context.watchdog_signal)
 {%- endmacro -%}
 
 {%- macro CGROUP_CONTEXT_CONFIG_ITEMS(type) -%}
 {{type}}.Slice,                            config_parse_unit_slice,                     0,                                  0
 {{type}}.AllowedCPUs,                      config_parse_allowed_cpuset,                 0,                                  offsetof({{type}}, cgroup_context.cpuset_cpus)
 {{type}}.StartupAllowedCPUs,               config_parse_allowed_cpuset,                 0,                                  offsetof({{type}}, cgroup_context.startup_cpuset_cpus)
 {{type}}.AllowedMemoryNodes,               config_parse_allowed_cpuset,                 0,                                  offsetof({{type}}, cgroup_context.cpuset_mems)
 {{type}}.StartupAllowedMemoryNodes,        config_parse_allowed_cpuset,                 0,                                  offsetof({{type}}, cgroup_context.startup_cpuset_mems)
 {{type}}.CPUAccounting,                    config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.cpu_accounting)
 {{type}}.CPUWeight,                        config_parse_cg_weight,                      0,                                  offsetof({{type}}, cgroup_context.cpu_weight)
 {{type}}.StartupCPUWeight,                 config_parse_cg_weight,                      0,                                  offsetof({{type}}, cgroup_context.startup_cpu_weight)
 {{type}}.CPUShares,                        config_parse_cpu_shares,                     0,                                  offsetof({{type}}, cgroup_context.cpu_shares)
 {{type}}.StartupCPUShares,                 config_parse_cpu_shares,                     0,                                  offsetof({{type}}, cgroup_context.startup_cpu_shares)
 {{type}}.CPUQuota,                         config_parse_cpu_quota,                      0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.CPUQuotaPeriodSec,                config_parse_sec_def_infinity,               0,                                  offsetof({{type}}, cgroup_context.cpu_quota_period_usec)
 {{type}}.MemoryAccounting,                 config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.memory_accounting)
 {{type}}.MemoryMin,                        config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.DefaultMemoryMin,                 config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.DefaultMemoryLow,                 config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.MemoryLow,                        config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.MemoryHigh,                       config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.MemoryMax,                        config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.MemorySwapMax,                    config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.MemoryLimit,                      config_parse_memory_limit,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.DeviceAllow,                      config_parse_device_allow,                   0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.DevicePolicy,                     config_parse_device_policy,                  0,                                  offsetof({{type}}, cgroup_context.device_policy)
 {{type}}.IOAccounting,                     config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.io_accounting)
 {{type}}.IOWeight,                         config_parse_cg_weight,                      0,                                  offsetof({{type}}, cgroup_context.io_weight)
 {{type}}.StartupIOWeight,                  config_parse_cg_weight,                      0,                                  offsetof({{type}}, cgroup_context.startup_io_weight)
 {{type}}.IODeviceWeight,                   config_parse_io_device_weight,               0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IOReadBandwidthMax,               config_parse_io_limit,                       0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IOWriteBandwidthMax,              config_parse_io_limit,                       0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IOReadIOPSMax,                    config_parse_io_limit,                       0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IOWriteIOPSMax,                   config_parse_io_limit,                       0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IODeviceLatencyTargetSec,         config_parse_io_device_latency,              0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.BlockIOAccounting,                config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.blockio_accounting)
 {{type}}.BlockIOWeight,                    config_parse_blockio_weight,                 0,                                  offsetof({{type}}, cgroup_context.blockio_weight)
 {{type}}.StartupBlockIOWeight,             config_parse_blockio_weight,                 0,                                  offsetof({{type}}, cgroup_context.startup_blockio_weight)
 {{type}}.BlockIODeviceWeight,              config_parse_blockio_device_weight,          0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.BlockIOReadBandwidth,             config_parse_blockio_bandwidth,              0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.BlockIOWriteBandwidth,            config_parse_blockio_bandwidth,              0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.TasksAccounting,                  config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.tasks_accounting)
 {{type}}.TasksMax,                         config_parse_tasks_max,                      0,                                  offsetof({{type}}, cgroup_context.tasks_max)
 {{type}}.Delegate,                         config_parse_delegate,                       0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.DisableControllers,               config_parse_disable_controllers,            0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.IPAccounting,                     config_parse_bool,                           0,                                  offsetof({{type}}, cgroup_context.ip_accounting)
 {{type}}.IPAddressAllow,                   config_parse_in_addr_prefixes,               AF_UNSPEC,                          offsetof({{type}}, cgroup_context.ip_address_allow)
 {{type}}.IPAddressDeny,                    config_parse_in_addr_prefixes,               AF_UNSPEC,                          offsetof({{type}}, cgroup_context.ip_address_deny)
 {{type}}.IPIngressFilterPath,              config_parse_ip_filter_bpf_progs,            0,                                  offsetof({{type}}, cgroup_context.ip_filters_ingress)
 {{type}}.IPEgressFilterPath,               config_parse_ip_filter_bpf_progs,            0,                                  offsetof({{type}}, cgroup_context.ip_filters_egress)
 {{type}}.ManagedOOMSwap,                   config_parse_managed_oom_mode,               0,                                  offsetof({{type}}, cgroup_context.moom_swap)
 {{type}}.ManagedOOMMemoryPressure,         config_parse_managed_oom_mode,               0,                                  offsetof({{type}}, cgroup_context.moom_mem_pressure)
 {{type}}.ManagedOOMMemoryPressureLimit,    config_parse_managed_oom_mem_pressure_limit, 0,                                  offsetof({{type}}, cgroup_context.moom_mem_pressure_limit)
 {{type}}.ManagedOOMPreference,             config_parse_managed_oom_preference,         0,                                  offsetof({{type}}, cgroup_context.moom_preference)
 {{type}}.NetClass,                         config_parse_warn_compat,                    DISABLED_LEGACY,                    0
 {{type}}.BPFProgram,                       config_parse_bpf_foreign_program,            0,                                  offsetof({{type}}, cgroup_context)
 {{type}}.SocketBindAllow,                  config_parse_cgroup_socket_bind,             0,                                  offsetof({{type}}, cgroup_context.socket_bind_allow)
 {{type}}.SocketBindDeny,                   config_parse_cgroup_socket_bind,             0,                                  offsetof({{type}}, cgroup_context.socket_bind_deny)
 {{type}}.RestrictNetworkInterfaces,        config_parse_restrict_network_interfaces,    0,                                  offsetof({{type}}, cgroup_context)
-{{type}}.ControlGroupNFTSet,               config_parse_cgroup_nft_set,                 0,                                  offsetof({{type}}, cgroup_context)
 {%- endmacro -%}
 
 %{
 #if __GNUC__ >= 7
diff --git a/src/core/load-fragment.c b/src/core/load-fragment.c
index 8c136b1402..3ff6eae8fc 100644
--- a/src/core/load-fragment.c
+++ b/src/core/load-fragment.c
@@ -1,75 +1,73 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 /***
   Copyright  2012 Holger Hans Peter Freyther
 ***/
 
 #include <errno.h>
 #include <fcntl.h>
 #include <linux/fs.h>
 #include <linux/oom.h>
 #if HAVE_SECCOMP
 #include <seccomp.h>
 #endif
 #include <sched.h>
 #include <sys/resource.h>
 
 #include "sd-messages.h"
 
 #include "af-list.h"
 #include "all-units.h"
 #include "alloc-util.h"
 #include "bpf-firewall.h"
 #include "bpf-lsm.h"
 #include "bpf-program.h"
 #include "bpf-socket-bind.h"
 #include "bus-error.h"
 #include "bus-internal.h"
 #include "bus-util.h"
 #include "cap-list.h"
 #include "capability-util.h"
 #include "cgroup-setup.h"
 #include "conf-parser.h"
 #include "core-varlink.h"
 #include "cpu-set-util.h"
 #include "creds-util.h"
 #include "env-util.h"
 #include "errno-list.h"
 #include "escape.h"
-#include "execute.h"
 #include "fd-util.h"
 #include "fileio.h"
-#include "firewall-util.h"
 #include "fs-util.h"
 #include "hexdecoct.h"
 #include "io-util.h"
 #include "ioprio-util.h"
 #include "ip-protocol-list.h"
 #include "journal-file.h"
 #include "limits-util.h"
 #include "load-fragment.h"
 #include "log.h"
 #include "missing_ioprio.h"
 #include "mountpoint-util.h"
 #include "nulstr-util.h"
 #include "parse-helpers.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "percent-util.h"
 #include "process-util.h"
 #if HAVE_SECCOMP
 #include "seccomp-util.h"
 #endif
 #include "securebits-util.h"
 #include "signal-util.h"
 #include "socket-netlink.h"
 #include "specifier.h"
 #include "stat-util.h"
 #include "string-util.h"
 #include "strv.h"
 #include "syslog-util.h"
 #include "time-util.h"
 #include "unit-name.h"
 #include "unit-printf.h"
 #include "user-util.h"
 #include "utf8.h"
 #include "web-util.h"
@@ -6500,127 +6498,25 @@ int config_parse_watchdog_sec(
 int config_parse_tty_size(
                 const char *unit,
                 const char *filename,
                 unsigned line,
                 const char *section,
                 unsigned section_line,
                 const char *lvalue,
                 int ltype,
                 const char *rvalue,
                 void *data,
                 void *userdata) {
 
         unsigned *sz = data;
 
         assert(filename);
         assert(lvalue);
         assert(rvalue);
 
         if (isempty(rvalue)) {
                 *sz = UINT_MAX;
                 return 0;
         }
 
         return config_parse_unsigned(unit, filename, line, section, section_line, lvalue, ltype, rvalue, data, userdata);
 }
-
-static int config_parse_nft_set(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                NFTSetContext **c,
-                size_t *n,
-                Unit *u) {
-        _cleanup_free_ char *family_str = NULL, *table = NULL, *set = NULL, *table_resolved = NULL, *set_resolved = NULL;
-        int nfproto, r;
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(u);
-
-        if (isempty(rvalue)) {
-                /* Empty assignment resets the list */
-                *c = nft_set_context_free_many(*c, n);
-                return 0;
-        }
-
-        for (const char *p = rvalue;;) {
-                r = extract_many_words(&p, ":", EXTRACT_CUNESCAPE, &family_str, &table, &set, NULL);
-                if (r == -ENOMEM)
-                        return log_oom();
-                if (r == 0)
-                        break;
-                if (r != 3) {
-                        log_syntax(unit, LOG_WARNING, filename, line, r, "Failed to parse NFT set, ignoring: %s", p);
-                        return 0;
-                }
-
-                nfproto = nfproto_from_string(family_str);
-                if (nfproto < 0) {
-                        log_syntax(unit, LOG_WARNING, filename, line, 0, "Unknown NFT protocol family, ignoring: %s", family_str);
-                        return 0;
-                }
-
-                r = unit_path_printf(u, table, &table_resolved);
-                if (r < 0) {
-                        log_syntax(unit, LOG_WARNING, filename, line, r, "Failed to resolve unit specifiers in '%s', ignoring: %m", table);
-                        return 0;
-                }
-
-                if (nft_identifier_bad(table_resolved))
-                        return log_syntax(unit, LOG_WARNING, filename, line, 0, "Invalid table name %s, ignoring", table);
-
-                r = unit_path_printf(u, set, &set_resolved);
-                if (r < 0) {
-                        log_syntax(unit, LOG_WARNING, filename, line, r, "Failed to resolve unit specifiers in '%s', ignoring: %m", set);
-                        return 0;
-                }
-
-                if (nft_identifier_bad(set_resolved))
-                        return log_syntax(unit, LOG_WARNING, filename, line, 0, "Invalid set name %s, ignoring", set);
-
-                r = nft_set_context_add(c, n, nfproto, table_resolved, set_resolved);
-                if (r < 0)
-                        return log_oom();
-        }
-
-        return 0;
-}
-
-int config_parse_cgroup_nft_set(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        CGroupContext *c = data;
-        Unit *u = userdata;
-
-        return config_parse_nft_set(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &c->nft_set_context, &c->n_nft_set_contexts, u);
-}
-
-int config_parse_dynamic_user_nft_set(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        ExecContext *c = data;
-        Unit *u = userdata;
-
-        return config_parse_nft_set(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &c->dynamic_user_nft_set_context, &c->n_dynamic_user_nft_set_contexts, u);
-}
diff --git a/src/core/load-fragment.h b/src/core/load-fragment.h
index c250e46846..26b8de28f7 100644
--- a/src/core/load-fragment.h
+++ b/src/core/load-fragment.h
@@ -150,8 +150,6 @@ CONFIG_PARSER_PROTOTYPE(config_parse_cgroup_socket_bind);
 CONFIG_PARSER_PROTOTYPE(config_parse_restrict_network_interfaces);
 CONFIG_PARSER_PROTOTYPE(config_parse_watchdog_sec);
 CONFIG_PARSER_PROTOTYPE(config_parse_tty_size);
-CONFIG_PARSER_PROTOTYPE(config_parse_cgroup_nft_set);
-CONFIG_PARSER_PROTOTYPE(config_parse_dynamic_user_nft_set);
 
 /* gperf prototypes */
 const struct ConfigPerfItem* load_fragment_gperf_lookup(const char *key, GPERF_LEN_TYPE length);
diff --git a/src/core/service.c b/src/core/service.c
index f8d751e32f..5f1a218bb5 100644
--- a/src/core/service.c
+++ b/src/core/service.c
@@ -1802,94 +1802,91 @@ static bool service_will_restart(Unit *u) {
 static void service_enter_dead(Service *s, ServiceResult f, bool allow_restart) {
         ServiceState end_state;
         int r;
 
         assert(s);
 
         /* If there's a stop job queued before we enter the DEAD state, we shouldn't act on Restart=, in order to not
          * undo what has already been enqueued. */
         if (unit_stop_pending(UNIT(s)))
                 allow_restart = false;
 
         if (s->result == SERVICE_SUCCESS)
                 s->result = f;
 
         if (s->result == SERVICE_SUCCESS) {
                 unit_log_success(UNIT(s));
                 end_state = SERVICE_DEAD;
         } else if (s->result == SERVICE_SKIP_CONDITION) {
                 unit_log_skip(UNIT(s), service_result_to_string(s->result));
                 end_state = SERVICE_DEAD;
         } else {
                 unit_log_failure(UNIT(s), service_result_to_string(s->result));
                 end_state = SERVICE_FAILED;
         }
         unit_warn_leftover_processes(UNIT(s), unit_log_leftover_process_stop);
 
         if (!allow_restart)
                 log_unit_debug(UNIT(s), "Service restart not allowed.");
         else {
                 const char *reason;
                 bool shall_restart;
 
                 shall_restart = service_shall_restart(s, &reason);
                 log_unit_debug(UNIT(s), "Service will %srestart (%s)",
                                         shall_restart ? "" : "not ",
                                         reason);
                 if (shall_restart)
                         s->will_auto_restart = true;
         }
 
         /* Make sure service_release_resources() doesn't destroy our FD store, while we are changing through
          * SERVICE_FAILED/SERVICE_DEAD before entering into SERVICE_AUTO_RESTART. */
         s->n_keep_fd_store ++;
 
         service_set_state(s, end_state);
 
         if (s->will_auto_restart) {
                 s->will_auto_restart = false;
 
                 r = service_arm_timer(s, usec_add(now(CLOCK_MONOTONIC), s->restart_usec));
                 if (r < 0) {
                         s->n_keep_fd_store--;
                         goto fail;
                 }
 
                 service_set_state(s, SERVICE_AUTO_RESTART);
         } else
                 /* If we shan't restart, then flush out the restart counter. But don't do that immediately, so that the
                  * user can still introspect the counter. Do so on the next start. */
                 s->flush_n_restarts = true;
 
         /* The new state is in effect, let's decrease the fd store ref counter again. Let's also re-add us to the GC
          * queue, so that the fd store is possibly gc'ed again */
         s->n_keep_fd_store--;
         unit_add_to_gc_queue(UNIT(s));
 
         /* The next restart might not be a manual stop, hence reset the flag indicating manual stops */
         s->forbid_restart = false;
 
         /* We want fresh tmpdirs in case service is started again immediately */
         s->exec_runtime = exec_runtime_unref(s->exec_runtime, true);
 
         /* Also, remove the runtime directory */
         unit_destroy_runtime_data(UNIT(s), &s->exec_context);
 
         /* Get rid of the IPC bits of the user */
         unit_unref_uid_gid(UNIT(s), true);
 
-        /* Delete DynamicUserNFTSet= */
-        exec_delete_dynamic_user_nft_set(&s->exec_context, s->dynamic_creds.user);
-
         /* Release the user, and destroy it if we are the only remaining owner */
         dynamic_creds_destroy(&s->dynamic_creds);
 
         /* Try to delete the pid file. At this point it will be
          * out-of-date, and some software might be confused by it, so
          * let's remove it. */
         if (s->pid_file)
                 (void) unlink(s->pid_file);
 
         /* Reset TTY ownership if necessary */
         exec_context_revert_tty(&s->exec_context);
 
         return;
diff --git a/src/network/networkd-address.c b/src/network/networkd-address.c
index fb9273934e..2bedbe4275 100644
--- a/src/network/networkd-address.c
+++ b/src/network/networkd-address.c
@@ -120,27 +120,25 @@ static int address_new_static(Network *network, const char *filename, unsigned s
 Address *address_free(Address *address) {
         if (!address)
                 return NULL;
 
         if (address->network) {
                 assert(address->section);
                 ordered_hashmap_remove(address->network->addresses_by_section, address->section);
         }
 
         if (address->link) {
                 set_remove(address->link->addresses, address);
 
                 if (address->family == AF_INET6 &&
                     in6_addr_equal(&address->in_addr.in6, &address->link->ipv6ll_address))
                         memzero(&address->link->ipv6ll_address, sizeof(struct in6_addr));
         }
 
         sd_ipv4acd_unref(address->acd);
 
         config_section_free(address->section);
         free(address->label);
         set_free(address->netlabels);
-        nft_set_context_free_many(address->ipv4_nft_set_context, &address->n_ipv4_nft_set_contexts);
-        nft_set_context_free_many(address->ipv6_nft_set_context, &address->n_ipv6_nft_set_contexts);
         return mfree(address);
 }
 
@@ -452,91 +450,6 @@ static int address_set_masquerade(Address *address, bool add) {
         return 0;
 }
 
-static void address_add_nft_set_context(const Address *address, const NFTSetContext *nft_set_context, size_t n_nft_set_contexts) {
-        int r;
-
-        assert(address);
-
-        for (size_t i = 0; i < n_nft_set_contexts; i++) {
-                r = nft_set_element_add_in_addr(&nft_set_context[i], address->family,
-                                                &address->in_addr, address->prefixlen);
-                if (r < 0)
-                        log_warning_errno(r, "Adding NFT family %s table %s set %s for IP address %s failed, ignoring",
-                                          nfproto_to_string(nft_set_context[i].nfproto),
-                                          nft_set_context[i].table,
-                                          nft_set_context[i].set,
-                                          IN_ADDR_PREFIX_TO_STRING(address->family, &address->in_addr, address->prefixlen));
-        }
-}
-
-static void address_del_nft_set_context(const Address *address, const NFTSetContext *nft_set_context, size_t n_nft_set_contexts) {
-        int r;
-
-        assert(address);
-
-        for (size_t i = 0; i < n_nft_set_contexts; i++) {
-                r = nft_set_element_del_in_addr(&nft_set_context[i], address->family,
-                                                &address->in_addr, address->prefixlen);
-                if (r < 0)
-                        log_warning_errno(r, "Deleting NFT family %s table %s set %s for IP address %s failed, ignoring",
-                                          nfproto_to_string(nft_set_context[i].nfproto),
-                                          nft_set_context[i].table,
-                                          nft_set_context[i].set,
-                                          IN_ADDR_PREFIX_TO_STRING(address->family, &address->in_addr, address->prefixlen));               }
-}
-
-static void address_add_nft_set(const Address *address) {
-        assert(address);
-        assert(address->link);
-
-        if (!address->link->network || !IN_SET(address->family, AF_INET, AF_INET6))
-                return;
-
-        switch (address->source) {
-        case NETWORK_CONFIG_SOURCE_DHCP4:
-                return address_add_nft_set_context(address, address->link->network->dhcp_nft_set_context, address->link->network->n_dhcp_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_DHCP6:
-                return address_add_nft_set_context(address, address->link->network->dhcp6_nft_set_context, address->link->network->n_dhcp6_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_DHCP_PD:
-                return address_add_nft_set_context(address, address->link->network->dhcp_pd_nft_set_context, address->link->network->n_dhcp_pd_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_NDISC:
-                return address_add_nft_set_context(address, address->link->network->ndisc_nft_set_context, address->link->network->n_ndisc_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_STATIC:
-                if (address->family == AF_INET)
-                        return address_add_nft_set_context(address, address->ipv4_nft_set_context, address->n_ipv4_nft_set_contexts);
-                else
-                        return address_add_nft_set_context(address, address->ipv6_nft_set_context, address->n_ipv6_nft_set_contexts);
-        default:
-                return;
-        }
-}
-
-static void address_del_nft_set(const Address *address) {
-        assert(address);
-        assert(address->link);
-
-        if (!address->link->network || !IN_SET(address->family, AF_INET, AF_INET6))
-                return;
-
-        switch (address->source) {
-        case NETWORK_CONFIG_SOURCE_DHCP4:
-                return address_del_nft_set_context(address, address->link->network->dhcp_nft_set_context, address->link->network->n_dhcp_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_DHCP6:
-                return address_del_nft_set_context(address, address->link->network->dhcp6_nft_set_context, address->link->network->n_dhcp6_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_DHCP_PD:
-                return address_del_nft_set_context(address, address->link->network->dhcp_pd_nft_set_context, address->link->network->n_dhcp_pd_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_NDISC:
-                return address_del_nft_set_context(address, address->link->network->ndisc_nft_set_context, address->link->network->n_ndisc_nft_set_contexts);
-        case NETWORK_CONFIG_SOURCE_STATIC:
-                if (address->family == AF_INET)
-                        return address_del_nft_set_context(address, address->ipv4_nft_set_context, address->n_ipv4_nft_set_contexts);
-                else
-                        return address_del_nft_set_context(address, address->ipv6_nft_set_context, address->n_ipv6_nft_set_contexts);
-        default:
-                return;
-        }
-}
-
 static int address_add(Link *link, Address *address) {
         int r;
 
@@ -556,42 +469,40 @@ static int address_add(Link *link, Address *address) {
 static int address_update(Address *address) {
         Link *link;
         int r;
 
         assert(address);
         assert(address->link);
 
         link = address->link;
 
         if (address_is_ready(address) &&
             address->family == AF_INET6 &&
             in6_addr_is_link_local(&address->in_addr.in6) &&
             in6_addr_is_null(&link->ipv6ll_address)) {
 
                 link->ipv6ll_address = address->in_addr.in6;
 
                 r = link_ipv6ll_gained(link);
                 if (r < 0)
                         return r;
         }
 
         if (IN_SET(link->state, LINK_STATE_FAILED, LINK_STATE_LINGER))
                 return 0;
 
         r = address_set_masquerade(address, true);
         if (r < 0)
                 return log_link_warning_errno(link, r, "Could not enable IP masquerading: %m");
 
         address_add_netlabel(address);
 
-        address_add_nft_set(address);
-
         if (address_is_ready(address) && address->callback) {
                 r = address->callback(address);
                 if (r < 0)
                         return r;
         }
 
         link_update_operstate(link, true);
         link_check_ready(link);
         return 0;
 }
@@ -599,29 +510,27 @@ static int address_update(Address *address) {
 static int address_drop(Address *address) {
         Link *link;
         bool ready;
         int r;
 
         assert(address);
         assert(address->link);
 
         ready = address_is_ready(address);
         link = address->link;
 
         r = address_set_masquerade(address, false);
         if (r < 0)
                 log_link_warning_errno(link, r, "Failed to disable IP masquerading, ignoring: %m");
 
-        address_del_nft_set(address);
-
         address_del_netlabel(address);
 
         if (address->state == 0)
                 address_free(address);
 
         link_update_operstate(link, true);
 
         if (link && !ready)
                 link_check_ready(link);
 
         return 0;
 }
@@ -2134,109 +2043,41 @@ static int address_section_verify(Address *address) {
 int network_drop_invalid_addresses(Network *network) {
         _cleanup_set_free_ Set *addresses = NULL;
         Address *address;
         int r;
 
         assert(network);
 
         ORDERED_HASHMAP_FOREACH(address, network->addresses_by_section) {
                 Address *dup;
 
                 if (address_section_verify(address) < 0) {
                         /* Drop invalid [Address] sections or Address= settings in [Network].
                          * Note that address_free() will drop the address from addresses_by_section. */
                         address_free(address);
                         continue;
                 }
 
                 /* Always use the setting specified later. So, remove the previously assigned setting. */
                 dup = set_remove(addresses, address);
                 if (dup) {
                         log_warning("%s: Duplicated address %s is specified at line %u and %u, "
                                     "dropping the address setting specified at line %u.",
                                     dup->section->filename,
                                     IN_ADDR_PREFIX_TO_STRING(address->family, &address->in_addr, address->prefixlen),
                                     address->section->line,
                                     dup->section->line, dup->section->line);
                         /* address_free() will drop the address from addresses_by_section. */
                         address_free(dup);
                 }
 
                 /* Use address_kernel_hash_ops here. The function address_kernel_compare_func() matches
                  * how kernel compares addresses, and is more lenient than address_compare_func().
                  * Hence, the logic of dedup here is stricter than when address_hash_ops is used. */
                 r = set_ensure_put(&addresses, &address_kernel_hash_ops, address);
                 if (r < 0)
                         return log_oom();
                 assert(r > 0);
         }
 
         return 0;
 }
-
-int config_parse_address_ipv4_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-        _cleanup_(address_free_or_set_invalidp) Address *n = NULL;
-        int r;
-
-        assert(filename);
-        assert(section);
-        assert(lvalue);
-        assert(rvalue);
-        assert(data);
-        assert(network);
-
-        r = address_new_static(network, filename, section_line, &n);
-        if (r == -ENOMEM)
-                return log_oom();
-        if (r < 0) {
-                log_syntax(unit, LOG_WARNING, filename, line, r,
-                           "Failed to allocate new address, ignoring assignment: %m");
-                return 0;
-        }
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &n->ipv4_nft_set_context, &n->n_ipv4_nft_set_contexts);
-}
-
-int config_parse_address_ipv6_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-        _cleanup_(address_free_or_set_invalidp) Address *n = NULL;
-        int r;
-
-        assert(filename);
-        assert(section);
-        assert(lvalue);
-        assert(rvalue);
-        assert(data);
-        assert(network);
-
-        r = address_new_static(network, filename, section_line, &n);
-        if (r == -ENOMEM)
-                return log_oom();
-        if (r < 0) {
-                log_syntax(unit, LOG_WARNING, filename, line, r,
-                           "Failed to allocate new address, ignoring assignment: %m");
-                return 0;
-        }
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &n->ipv6_nft_set_context, &n->n_ipv6_nft_set_contexts);
-}
diff --git a/src/network/networkd-address.h b/src/network/networkd-address.h
index c7746f931c..e5770155fa 100644
--- a/src/network/networkd-address.h
+++ b/src/network/networkd-address.h
@@ -1,15 +1,14 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 #pragma once
 
 #include <inttypes.h>
 #include <stdbool.h>
 #include <stdio.h>
 
 #include "sd-ipv4acd.h"
 
 #include "conf-parser.h"
-#include "firewall-util.h"
 #include "in-addr-util.h"
 #include "networkd-link.h"
 #include "networkd-util.h"
 #include "time-util.h"
@@ -29,45 +28,42 @@ typedef int (*address_netlink_handler_t)(
 struct Address {
         Link *link;
         Network *network;
         ConfigSection *section;
         NetworkConfigSource source;
         NetworkConfigState state;
         union in_addr_union provider; /* DHCP server or router address */
 
         int family;
         unsigned char prefixlen;
         unsigned char scope;
         uint32_t flags;
         uint32_t route_metric; /* route metric for prefix route */
         char *label;
 
         int set_broadcast;
         struct in_addr broadcast;
 
         union in_addr_union in_addr;
         union in_addr_union in_addr_peer;
 
         /* These are absolute points in time, and NOT timespans/durations.
          * Must be specified with clock_boottime_or_monotonic(). */
         usec_t lifetime_valid_usec;
         usec_t lifetime_preferred_usec;
 
         bool scope_set:1;
         bool ip_masquerade_done:1;
 
         /* duplicate_address_detection is only used by static or IPv4 dynamic addresses.
          * To control DAD for IPv6 dynamic addresses, set IFA_F_NODAD to flags. */
         AddressFamily duplicate_address_detection;
         sd_ipv4acd *acd;
 
         /* Called when address become ready */
         address_ready_callback_t callback;
 
         /* NetLabel */
         Set *netlabels;
-
-        NFTSetContext *ipv4_nft_set_context, *ipv6_nft_set_context;
-        size_t n_ipv4_nft_set_contexts, n_ipv6_nft_set_contexts;
 };
 
 const char* format_lifetime(char *buf, size_t l, usec_t lifetime_usec) _warn_unused_result_;
@@ -143,5 +139,3 @@ CONFIG_PARSER_PROTOTYPE(config_parse_address_scope);
 CONFIG_PARSER_PROTOTYPE(config_parse_address_route_metric);
 CONFIG_PARSER_PROTOTYPE(config_parse_duplicate_address_detection);
 CONFIG_PARSER_PROTOTYPE(config_parse_address_netlabel);
-CONFIG_PARSER_PROTOTYPE(config_parse_address_ipv4_nft_set_context);
-CONFIG_PARSER_PROTOTYPE(config_parse_address_ipv6_nft_set_context);
diff --git a/src/network/networkd-network-gperf.gperf b/src/network/networkd-network-gperf.gperf
index faa9aa61b4..ef5cec1b52 100644
--- a/src/network/networkd-network-gperf.gperf
+++ b/src/network/networkd-network-gperf.gperf
@@ -158,8 +158,6 @@ Address.DuplicateAddressDetection,           config_parse_duplicate_address_dete
 Address.Scope,                               config_parse_address_scope,                               0,                             0
 Address.RouteMetric,                         config_parse_address_route_metric,                        0,                             0
 Address.NetLabel,                            config_parse_address_netlabel,                            0,                             0
-Address.IPv4NFTSet,                          config_parse_address_ipv4_nft_set_context,                0,                             0
-Address.IPv6NFTSet,                          config_parse_address_ipv6_nft_set_context,                0,                             0
 IPv6AddressLabel.Prefix,                     config_parse_address_label_prefix,                        0,                             0
 IPv6AddressLabel.Label,                      config_parse_address_label,                               0,                             0
 Neighbor.Address,                            config_parse_neighbor_address,                            0,                             0
@@ -248,7 +246,6 @@ DHCPv4.RouteMTUBytes,                        config_parse_mtu,
 DHCPv4.FallbackLeaseLifetimeSec,             config_parse_dhcp_fallback_lease_lifetime,                0,                             0
 DHCPv4.Use6RD,                               config_parse_bool,                                        0,                             offsetof(Network, dhcp_use_6rd)
 DHCPv4.NetLabel,                             config_parse_netlabel,                                    0,                             offsetof(Network, dhcp_netlabels)
-DHCPv4.NFTSet,                               config_parse_dhcp_nft_set_context,                        0,                             0
 DHCPv6.UseAddress,                           config_parse_bool,                                        0,                             offsetof(Network, dhcp6_use_address)
 DHCPv6.UseDelegatedPrefix,                   config_parse_bool,                                        0,                             offsetof(Network, dhcp6_use_pd_prefix)
 DHCPv6.UseDNS,                               config_parse_dhcp_use_dns,                                AF_INET6,                      0
@@ -267,7 +264,6 @@ DHCPv6.IAID,                                 config_parse_iaid,
 DHCPv6.DUIDType,                             config_parse_duid_type,                                   0,                             offsetof(Network, dhcp6_duid)
 DHCPv6.DUIDRawData,                          config_parse_duid_rawdata,                                0,                             offsetof(Network, dhcp6_duid)
 DHCPv6.NetLabel,                             config_parse_netlabel,                                    0,                             offsetof(Network, dhcp6_netlabels)
-DHCPv6.NFTSet,                               config_parse_dhcp6_nft_set_context,                       0,                             0
 IPv6AcceptRA.UseGateway,                     config_parse_bool,                                        0,                             offsetof(Network, ipv6_accept_ra_use_gateway)
 IPv6AcceptRA.UseRoutePrefix,                 config_parse_bool,                                        0,                             offsetof(Network, ipv6_accept_ra_use_route_prefix)
 IPv6AcceptRA.UseAutonomousPrefix,            config_parse_bool,                                        0,                             offsetof(Network, ipv6_accept_ra_use_autonomous_prefix)
@@ -286,7 +282,6 @@ IPv6AcceptRA.RouteAllowList,                 config_parse_in_addr_prefixes,
 IPv6AcceptRA.RouteDenyList,                  config_parse_in_addr_prefixes,                            AF_INET6,                      offsetof(Network, ndisc_deny_listed_route_prefix)
 IPv6AcceptRA.Token,                          config_parse_address_generation_type,                     0,                             offsetof(Network, ndisc_tokens)
 IPv6AcceptRA.NetLabel,                       config_parse_netlabel,                                    0,                             offsetof(Network, ndisc_netlabels)
-IPv6AcceptRA.NFTSet,                         config_parse_ndisc_nft_set_context,                       0,                             0
 DHCPServer.ServerAddress,                    config_parse_dhcp_server_address,                         0,                             0
 DHCPServer.UplinkInterface,                  config_parse_uplink,                                      0,                             0
 DHCPServer.RelayTarget,                      config_parse_in_addr_non_null,                            AF_INET,                       offsetof(Network, dhcp_server_relay_target)
@@ -354,7 +349,6 @@ DHCPPrefixDelegation.ManageTemporaryAddress, config_parse_bool,
 DHCPPrefixDelegation.Token,                  config_parse_address_generation_type,                     0,                             offsetof(Network, dhcp_pd_tokens)
 DHCPPrefixDelegation.RouteMetric,            config_parse_uint32,                                      0,                             offsetof(Network, dhcp_pd_route_metric)
 DHCPPrefixDelegation.NetLabel,               config_parse_netlabel,                                    0,                             offsetof(Network, dhcp_pd_netlabels)
-DHCPPrefixDelegation.NFTSet,                 config_parse_dhcp_pd_nft_set_context,                     0,                             0
 IPv6SendRA.RouterLifetimeSec,                config_parse_router_lifetime,                             0,                             offsetof(Network, router_lifetime_usec)
 IPv6SendRA.Managed,                          config_parse_bool,                                        0,                             offsetof(Network, router_managed)
 IPv6SendRA.OtherInformation,                 config_parse_bool,                                        0,                             offsetof(Network, router_other_information)
diff --git a/src/network/networkd-network.c b/src/network/networkd-network.c
index 494e87e126..a6660d72b9 100644
--- a/src/network/networkd-network.c
+++ b/src/network/networkd-network.c
@@ -663,105 +663,101 @@ int manager_build_dhcp_pd_subnet_ids(Manager *manager) {
 static Network *network_free(Network *network) {
         if (!network)
                 return NULL;
 
         free(network->filename);
         hashmap_free(network->stats_by_path);
 
         net_match_clear(&network->match);
         condition_free_list(network->conditions);
 
         free(network->dhcp_server_relay_agent_circuit_id);
         free(network->dhcp_server_relay_agent_remote_id);
         free(network->dhcp_server_boot_server_name);
         free(network->dhcp_server_boot_filename);
 
         free(network->description);
         free(network->dhcp_vendor_class_identifier);
         free(network->dhcp_mudurl);
         strv_free(network->dhcp_user_class);
         free(network->dhcp_hostname);
         free(network->dhcp_label);
         set_free(network->dhcp_deny_listed_ip);
         set_free(network->dhcp_allow_listed_ip);
         set_free(network->dhcp_request_options);
         set_free(network->dhcp6_request_options);
         free(network->dhcp6_mudurl);
         strv_free(network->dhcp6_user_class);
         strv_free(network->dhcp6_vendor_class);
         set_free(network->dhcp_netlabels);
         set_free(network->dhcp6_netlabels);
-        nft_set_context_free_many(network->dhcp_nft_set_context, &network->n_dhcp_nft_set_contexts);
-        nft_set_context_free_many(network->dhcp6_nft_set_context, &network->n_dhcp6_nft_set_contexts);
 
         strv_free(network->ntp);
         for (unsigned i = 0; i < network->n_dns; i++)
                 in_addr_full_free(network->dns[i]);
         free(network->dns);
         ordered_set_free(network->search_domains);
         ordered_set_free(network->route_domains);
         strv_free(network->bind_carrier);
 
         ordered_set_free(network->router_search_domains);
         free(network->router_dns);
         set_free(network->ndisc_deny_listed_router);
         set_free(network->ndisc_allow_listed_router);
         set_free(network->ndisc_deny_listed_prefix);
         set_free(network->ndisc_allow_listed_prefix);
         set_free(network->ndisc_deny_listed_route_prefix);
         set_free(network->ndisc_allow_listed_route_prefix);
 
         free(network->batadv_name);
         free(network->bridge_name);
         free(network->bond_name);
         free(network->vrf_name);
         hashmap_free_free_key(network->stacked_netdev_names);
         netdev_unref(network->bridge);
         netdev_unref(network->bond);
         netdev_unref(network->vrf);
         hashmap_free_with_destructor(network->stacked_netdevs, netdev_unref);
 
         set_free_free(network->ipv6_proxy_ndp_addresses);
         ordered_hashmap_free_with_destructor(network->addresses_by_section, address_free);
         hashmap_free_with_destructor(network->routes_by_section, route_free);
         hashmap_free_with_destructor(network->nexthops_by_section, nexthop_free);
         hashmap_free_with_destructor(network->bridge_fdb_entries_by_section, bridge_fdb_free);
         hashmap_free_with_destructor(network->bridge_mdb_entries_by_section, bridge_mdb_free);
         hashmap_free_with_destructor(network->neighbors_by_section, neighbor_free);
         hashmap_free_with_destructor(network->address_labels_by_section, address_label_free);
         hashmap_free_with_destructor(network->prefixes_by_section, prefix_free);
         hashmap_free_with_destructor(network->route_prefixes_by_section, route_prefix_free);
         hashmap_free_with_destructor(network->rules_by_section, routing_policy_rule_free);
         hashmap_free_with_destructor(network->dhcp_static_leases_by_section, dhcp_static_lease_free);
         ordered_hashmap_free_with_destructor(network->sr_iov_by_section, sr_iov_free);
         hashmap_free_with_destructor(network->qdiscs_by_section, qdisc_free);
         hashmap_free_with_destructor(network->tclasses_by_section, tclass_free);
 
         free(network->name);
 
         free(network->dhcp_server_timezone);
         free(network->dhcp_server_uplink_name);
         free(network->router_uplink_name);
         free(network->dhcp_pd_uplink_name);
 
         for (sd_dhcp_lease_server_type_t t = 0; t < _SD_DHCP_LEASE_SERVER_TYPE_MAX; t++)
                 free(network->dhcp_server_emit[t].addresses);
 
         set_free_free(network->dnssec_negative_trust_anchors);
 
         free(network->lldp_mudurl);
 
         ordered_hashmap_free(network->dhcp_client_send_options);
         ordered_hashmap_free(network->dhcp_client_send_vendor_options);
         ordered_hashmap_free(network->dhcp_server_send_options);
         ordered_hashmap_free(network->dhcp_server_send_vendor_options);
         ordered_hashmap_free(network->dhcp6_client_send_options);
         ordered_hashmap_free(network->dhcp6_client_send_vendor_options);
         set_free(network->dhcp_pd_tokens);
         set_free(network->ndisc_tokens);
         set_free(network->dhcp_pd_netlabels);
         set_free(network->ndisc_netlabels);
-        nft_set_context_free_many(network->dhcp_pd_nft_set_context, &network->n_dhcp_pd_nft_set_contexts);
-        nft_set_context_free_many(network->ndisc_nft_set_context, &network->n_ndisc_nft_set_contexts);
 
         return mfree(network);
 }
@@ -1306,90 +1302,6 @@ int config_parse_ignore_carrier_loss(
         return 0;
 }
 
-int config_parse_dhcp_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(network);
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &network->dhcp_nft_set_context, &network->n_dhcp_nft_set_contexts);
-}
-
-int config_parse_dhcp6_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(network);
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &network->dhcp6_nft_set_context, &network->n_dhcp6_nft_set_contexts);
-}
-
-int config_parse_dhcp_pd_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(network);
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &network->dhcp_pd_nft_set_context, &network->n_dhcp_pd_nft_set_contexts);
-}
-
-int config_parse_ndisc_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                void *data,
-                void *userdata) {
-        Network *network = userdata;
-
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(network);
-
-        return config_parse_nft_set_context(unit, filename, line, section, section_line, lvalue, ltype, rvalue, &network->ndisc_nft_set_context, &network->n_ndisc_nft_set_contexts);
-}
-
 DEFINE_CONFIG_PARSE_ENUM(config_parse_required_family_for_online, link_required_address_family, AddressFamily,
                          "Failed to parse RequiredFamilyForOnline= setting");
 
diff --git a/src/network/networkd-network.h b/src/network/networkd-network.h
index 6d0748aedc..96cd316e01 100644
--- a/src/network/networkd-network.h
+++ b/src/network/networkd-network.h
@@ -1,30 +1,29 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 #pragma once
 
 #include <linux/nl80211.h>
 
 #include "sd-bus.h"
 #include "sd-device.h"
 #include "sd-lldp-tx.h"
 
 #include "bridge.h"
 #include "condition.h"
 #include "conf-parser.h"
-#include "firewall-util.h"
 #include "hashmap.h"
 #include "ipoib.h"
 #include "net-condition.h"
 #include "netdev.h"
 #include "networkd-bridge-vlan.h"
 #include "networkd-dhcp-common.h"
 #include "networkd-dhcp4.h"
 #include "networkd-dhcp6.h"
 #include "networkd-ipv6ll.h"
 #include "networkd-lldp-rx.h"
 #include "networkd-ndisc.h"
 #include "networkd-radv.h"
 #include "networkd-sysctl.h"
 #include "networkd-util.h"
 #include "ordered-set.h"
 #include "resolve-util.h"
 #include "socket-netlink.h"
@@ -62,308 +61,300 @@ typedef struct NetworkDHCPServerEmitAddress {
 struct Network {
         Manager *manager;
 
         unsigned n_ref;
 
         char *name;
         char *filename;
         Hashmap *stats_by_path;
         char *description;
 
         /* [Match] section */
         NetMatch match;
         LIST_HEAD(Condition, conditions);
 
         /* Master or stacked netdevs */
         bool keep_master;
         NetDev *batadv;
         NetDev *bridge;
         NetDev *bond;
         NetDev *vrf;
         NetDev *xfrm;
         Hashmap *stacked_netdevs;
         char *batadv_name;
         char *bridge_name;
         char *bond_name;
         char *vrf_name;
         Hashmap *stacked_netdev_names;
 
         /* [Link] section */
         struct hw_addr_data hw_addr;
         uint32_t mtu;
         int32_t group;
         int arp;
         int multicast;
         int allmulticast;
         int promiscuous;
         bool unmanaged;
         int required_for_online; /* Is this network required to be considered online? */
         LinkOperationalStateRange required_operstate_for_online;
         AddressFamily required_family_for_online;
         ActivationPolicy activation_policy;
 
         /* misc settings */
         bool configure_without_carrier;
         bool ignore_carrier_loss_set;
         usec_t ignore_carrier_loss_usec; /* timespan */
         KeepConfiguration keep_configuration;
         char **bind_carrier;
         bool default_route_on_device;
         AddressFamily ip_masquerade;
 
         /* DHCP Client Support */
         AddressFamily dhcp;
         DHCPClientIdentifier dhcp_client_identifier;
         DUID dhcp_duid;
         uint32_t dhcp_iaid;
         bool dhcp_iaid_set;
         char *dhcp_vendor_class_identifier;
         char *dhcp_mudurl;
         char **dhcp_user_class;
         char *dhcp_hostname;
         char *dhcp_label;
         uint64_t dhcp_max_attempts;
         uint32_t dhcp_route_metric;
         bool dhcp_route_metric_set;
         uint32_t dhcp_route_table;
         bool dhcp_route_table_set;
         uint32_t dhcp_fallback_lease_lifetime;
         uint32_t dhcp_route_mtu;
         uint16_t dhcp_client_port;
         int dhcp_critical;
         int dhcp_ip_service_type;
         bool dhcp_anonymize;
         bool dhcp_send_hostname;
         int dhcp_broadcast;
         bool dhcp_use_dns;
         bool dhcp_use_dns_set;
         bool dhcp_routes_to_dns;
         bool dhcp_use_ntp;
         bool dhcp_use_ntp_set;
         bool dhcp_routes_to_ntp;
         bool dhcp_use_sip;
         bool dhcp_use_mtu;
         bool dhcp_use_routes;
         int dhcp_use_gateway;
         bool dhcp_use_timezone;
         bool dhcp_use_hostname;
         bool dhcp_use_6rd;
         bool dhcp_send_release;
         bool dhcp_send_decline;
         DHCPUseDomains dhcp_use_domains;
         bool dhcp_use_domains_set;
         Set *dhcp_deny_listed_ip;
         Set *dhcp_allow_listed_ip;
         Set *dhcp_request_options;
         OrderedHashmap *dhcp_client_send_options;
         OrderedHashmap *dhcp_client_send_vendor_options;
         Set *dhcp_netlabels;
-        NFTSetContext *dhcp_nft_set_context;
-        size_t n_dhcp_nft_set_contexts;
 
         /* DHCPv6 Client support */
         bool dhcp6_use_address;
         bool dhcp6_use_pd_prefix;
         bool dhcp6_use_dns;
         bool dhcp6_use_dns_set;
         bool dhcp6_use_hostname;
         bool dhcp6_use_ntp;
         bool dhcp6_use_ntp_set;
         DHCPUseDomains dhcp6_use_domains;
         bool dhcp6_use_domains_set;
         uint32_t dhcp6_iaid;
         bool dhcp6_iaid_set;
         bool dhcp6_iaid_set_explicitly;
         DUID dhcp6_duid;
         uint8_t dhcp6_pd_prefix_length;
         struct in6_addr dhcp6_pd_prefix_hint;
         char *dhcp6_mudurl;
         char **dhcp6_user_class;
         char **dhcp6_vendor_class;
         DHCP6ClientStartMode dhcp6_client_start_mode;
         OrderedHashmap *dhcp6_client_send_options;
         OrderedHashmap *dhcp6_client_send_vendor_options;
         Set *dhcp6_request_options;
         Set *dhcp6_netlabels;
-        NFTSetContext *dhcp6_nft_set_context;
-        size_t n_dhcp6_nft_set_contexts;
 
         /* DHCP Server Support */
         bool dhcp_server;
         bool dhcp_server_bind_to_interface;
         unsigned char dhcp_server_address_prefixlen;
         struct in_addr dhcp_server_address;
         int dhcp_server_uplink_index;
         char *dhcp_server_uplink_name;
         struct in_addr dhcp_server_relay_target;
         char *dhcp_server_relay_agent_circuit_id;
         char *dhcp_server_relay_agent_remote_id;
         NetworkDHCPServerEmitAddress dhcp_server_emit[_SD_DHCP_LEASE_SERVER_TYPE_MAX];
         bool dhcp_server_emit_router;
         struct in_addr dhcp_server_router;
         bool dhcp_server_emit_timezone;
         char *dhcp_server_timezone;
         usec_t dhcp_server_default_lease_time_usec, dhcp_server_max_lease_time_usec;
         uint32_t dhcp_server_pool_offset;
         uint32_t dhcp_server_pool_size;
         OrderedHashmap *dhcp_server_send_options;
         OrderedHashmap *dhcp_server_send_vendor_options;
         struct in_addr dhcp_server_boot_server_address;
         char *dhcp_server_boot_server_name;
         char *dhcp_server_boot_filename;
 
         /* link-local addressing support */
         AddressFamily link_local;
         IPv6LinkLocalAddressGenMode ipv6ll_address_gen_mode;
         struct in6_addr ipv6ll_stable_secret;
         bool ipv4ll_route;
 
         /* IPv6 RA support */
         RADVPrefixDelegation router_prefix_delegation;
         usec_t router_lifetime_usec;
         uint8_t router_preference;
         bool router_managed;
         bool router_other_information;
         bool router_emit_dns;
         bool router_emit_domains;
         usec_t router_dns_lifetime_usec;
         struct in6_addr *router_dns;
         unsigned n_router_dns;
         OrderedSet *router_search_domains;
         int router_uplink_index;
         char *router_uplink_name;
 
         /* DHCP Prefix Delegation support */
         int dhcp_pd;
         bool dhcp_pd_announce;
         bool dhcp_pd_assign;
         bool dhcp_pd_manage_temporary_address;
         int64_t dhcp_pd_subnet_id;
         uint32_t dhcp_pd_route_metric;
         Set *dhcp_pd_tokens;
         int dhcp_pd_uplink_index;
         char *dhcp_pd_uplink_name;
         Set *dhcp_pd_netlabels;
-        NFTSetContext *dhcp_pd_nft_set_context;
-        size_t n_dhcp_pd_nft_set_contexts;
 
         /* Bridge Support */
         int use_bpdu;
         int hairpin;
         int isolated;
         int fast_leave;
         int allow_port_to_be_root;
         int unicast_flood;
         int multicast_flood;
         int multicast_to_unicast;
         int neighbor_suppression;
         int learning;
         int bridge_proxy_arp;
         int bridge_proxy_arp_wifi;
         uint32_t cost;
         uint16_t priority;
         MulticastRouter multicast_router;
 
         /* Bridge VLAN */
         bool use_br_vlan;
         uint16_t pvid;
         uint32_t br_vid_bitmap[BRIDGE_VLAN_BITMAP_LEN];
         uint32_t br_untagged_bitmap[BRIDGE_VLAN_BITMAP_LEN];
 
         /* CAN support */
         uint32_t can_bitrate;
         unsigned can_sample_point;
         nsec_t can_time_quanta_ns;
         uint32_t can_propagation_segment;
         uint32_t can_phase_buffer_segment_1;
         uint32_t can_phase_buffer_segment_2;
         uint32_t can_sync_jump_width;
         uint32_t can_data_bitrate;
         unsigned can_data_sample_point;
         nsec_t can_data_time_quanta_ns;
         uint32_t can_data_propagation_segment;
         uint32_t can_data_phase_buffer_segment_1;
         uint32_t can_data_phase_buffer_segment_2;
         uint32_t can_data_sync_jump_width;
         usec_t can_restart_us;
         uint32_t can_control_mode_mask;
         uint32_t can_control_mode_flags;
         uint16_t can_termination;
         bool can_termination_set;
 
         /* IPoIB support */
         IPoIBMode ipoib_mode;
         int ipoib_umcast;
 
         /* sysctl settings */
         AddressFamily ip_forward;
         int ipv4_accept_local;
         int ipv4_route_localnet;
         int ipv6_dad_transmits;
         int ipv6_hop_limit;
         int proxy_arp;
         uint32_t ipv6_mtu;
         IPv6PrivacyExtensions ipv6_privacy_extensions;
         int ipv6_proxy_ndp;
         Set *ipv6_proxy_ndp_addresses;
 
         /* IPv6 accept RA */
         int ipv6_accept_ra;
         bool ipv6_accept_ra_use_dns;
         bool ipv6_accept_ra_use_gateway;
         bool ipv6_accept_ra_use_route_prefix;
         bool ipv6_accept_ra_use_autonomous_prefix;
         bool ipv6_accept_ra_use_onlink_prefix;
         bool ipv6_accept_ra_use_mtu;
         bool active_slave;
         bool primary_slave;
         DHCPUseDomains ipv6_accept_ra_use_domains;
         IPv6AcceptRAStartDHCP6Client ipv6_accept_ra_start_dhcp6_client;
         uint32_t ipv6_accept_ra_route_table;
         bool ipv6_accept_ra_route_table_set;
         uint32_t ipv6_accept_ra_route_metric;
         bool ipv6_accept_ra_route_metric_set;
         Set *ndisc_deny_listed_router;
         Set *ndisc_allow_listed_router;
         Set *ndisc_deny_listed_prefix;
         Set *ndisc_allow_listed_prefix;
         Set *ndisc_deny_listed_route_prefix;
         Set *ndisc_allow_listed_route_prefix;
         Set *ndisc_tokens;
         Set *ndisc_netlabels;
-        NFTSetContext *ndisc_nft_set_context;
-        size_t n_ndisc_nft_set_contexts;
 
         /* LLDP support */
         LLDPMode lldp_mode; /* LLDP reception */
         sd_lldp_multicast_mode_t lldp_multicast_mode; /* LLDP transmission */
         char *lldp_mudurl;  /* LLDP MUD URL */
 
         OrderedHashmap *addresses_by_section;
         Hashmap *routes_by_section;
         Hashmap *nexthops_by_section;
         Hashmap *bridge_fdb_entries_by_section;
         Hashmap *bridge_mdb_entries_by_section;
         Hashmap *neighbors_by_section;
         Hashmap *address_labels_by_section;
         Hashmap *prefixes_by_section;
         Hashmap *route_prefixes_by_section;
         Hashmap *rules_by_section;
         Hashmap *dhcp_static_leases_by_section;
         Hashmap *qdiscs_by_section;
         Hashmap *tclasses_by_section;
         OrderedHashmap *sr_iov_by_section;
 
         /* All kinds of DNS configuration */
         struct in_addr_full **dns;
         unsigned n_dns;
         OrderedSet *search_domains, *route_domains;
         int dns_default_route;
         ResolveSupport llmnr;
         ResolveSupport mdns;
         DnssecMode dnssec_mode;
         DnsOverTlsMode dns_over_tls_mode;
         Set *dnssec_negative_trust_anchors;
 
         /* NTP */
         char **ntp;
 };
@@ -397,10 +388,6 @@ CONFIG_PARSER_PROTOTYPE(config_parse_keep_configuration);
 CONFIG_PARSER_PROTOTYPE(config_parse_activation_policy);
 CONFIG_PARSER_PROTOTYPE(config_parse_link_group);
 CONFIG_PARSER_PROTOTYPE(config_parse_ignore_carrier_loss);
-CONFIG_PARSER_PROTOTYPE(config_parse_dhcp_nft_set_context);
-CONFIG_PARSER_PROTOTYPE(config_parse_dhcp6_nft_set_context);
-CONFIG_PARSER_PROTOTYPE(config_parse_dhcp_pd_nft_set_context);
-CONFIG_PARSER_PROTOTYPE(config_parse_ndisc_nft_set_context);
 
 const struct ConfigPerfItem* network_network_gperf_lookup(const char *key, GPERF_LEN_TYPE length);
 
diff --git a/src/shared/bus-unit-util.c b/src/shared/bus-unit-util.c
index 1ffdcf384f..a326ca30a9 100644
--- a/src/shared/bus-unit-util.c
+++ b/src/shared/bus-unit-util.c
@@ -1,52 +1,51 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include "af-list.h"
 #include "alloc-util.h"
 #include "bus-error.h"
 #include "bus-unit-util.h"
 #include "bus-util.h"
 #include "cap-list.h"
 #include "cgroup-setup.h"
 #include "cgroup-util.h"
 #include "condition.h"
 #include "coredump-util.h"
 #include "cpu-set-util.h"
 #include "dissect-image.h"
 #include "escape.h"
 #include "exec-util.h"
 #include "exit-status.h"
 #include "fileio.h"
-#include "firewall-util.h"
 #include "hexdecoct.h"
 #include "hostname-util.h"
 #include "in-addr-util.h"
 #include "ioprio-util.h"
 #include "ip-protocol-list.h"
 #include "libmount-util.h"
 #include "locale-util.h"
 #include "log.h"
 #include "macro.h"
 #include "missing_fs.h"
 #include "mountpoint-util.h"
 #include "nsflags.h"
 #include "numa-util.h"
 #include "parse-helpers.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "percent-util.h"
 #include "process-util.h"
 #include "rlimit-util.h"
 #if HAVE_SECCOMP
 #include "seccomp-util.h"
 #endif
 #include "securebits-util.h"
 #include "signal-util.h"
 #include "socket-util.h"
 #include "sort-util.h"
 #include "stdio-util.h"
 #include "string-util.h"
 #include "syslog-util.h"
 #include "terminal-util.h"
 #include "unit-def.h"
 #include "user-util.h"
 #include "utf8.h"
@@ -435,551 +434,463 @@ static int bus_append_ip_address_access(sd_bus_message *m, int family, const uni
         return sd_bus_message_close_container(m);
 }
 
-static int bus_append_nft_set(sd_bus_message *m, const char *field, const char *eq) {
-        int r;
-
-        assert(m);
-
-        if (isempty(eq)) {
-                r = sd_bus_message_append(m, "(sv)", field, "a(iss)", 0);
-                if (r < 0)
-                        return bus_log_create_error(r);
-
-                return 1;
-        }
-
-        r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        r = sd_bus_message_open_container(m, 'v', "a(iss)");
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        r = sd_bus_message_open_container(m, 'a', "(iss)");
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        for (;;) {
-                _cleanup_free_ char *word = NULL;
-                int family;
-
-                r = extract_first_word(&eq, &word, ":", 0);
-                if (r == -ENOMEM)
-                        return log_oom();
-                if (r < 0)
-                        return log_error_errno(r, "Failed to parse %s: %m", field);
-                if (isempty(word)) {
-                        log_error("Failed to parse %s", field);
-                        return 0;
-                }
-
-                family = nfproto_from_string(word);
-                if (family < 0)
-                        return log_error_errno(family, "Failed to parse %s: %m", field);
-
-                r = extract_first_word(&eq, &word, ":", EXTRACT_CUNESCAPE|EXTRACT_UNESCAPE_SEPARATORS);
-                if (r == -ENOMEM)
-                        return log_oom();
-                if (r < 0)
-                        return log_error_errno(r, "Failed to parse %s: %m", field);
-                if (isempty(word) || isempty(eq)) {
-                        log_error("Failed to parse %s", field);
-                        return 0;
-                }
-
-                _cleanup_free_ char *unescaped = NULL;
-                ssize_t l;
-
-                l = cunescape(eq, 0, &unescaped);
-                if (l < 0)
-                        return log_error_errno(l, "Failed to unescape %s= value: %s", field, eq);
-
-                r = sd_bus_message_append(m, "(iss)", family, word, eq);
-
-                r = sd_bus_message_close_container(m);
-                if (r < 0)
-                        return bus_log_create_error(r);
-        }
-        r = sd_bus_message_close_container(m);
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        r = sd_bus_message_close_container(m);
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        r = sd_bus_message_close_container(m);
-        if (r < 0)
-                return bus_log_create_error(r);
-
-        return 1;
-}
-
 static int bus_append_cgroup_property(sd_bus_message *m, const char *field, const char *eq) {
         int r;
 
         if (STR_IN_SET(field, "DevicePolicy",
                               "Slice",
                               "ManagedOOMSwap",
                               "ManagedOOMMemoryPressure",
                               "ManagedOOMPreference"))
                 return bus_append_string(m, field, eq);
 
         if (STR_IN_SET(field, "ManagedOOMMemoryPressureLimit")) {
                 r = parse_permyriad(eq);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse %s value: %s", field, eq);
 
                 /* Pass around scaled to 2^32-1 == 100% */
                 r = sd_bus_message_append(m, "(sv)", field, "u", UINT32_SCALE_FROM_PERMYRIAD(r));
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "CPUAccounting",
                               "MemoryAccounting",
                               "IOAccounting",
                               "BlockIOAccounting",
                               "TasksAccounting",
                               "IPAccounting"))
                 return bus_append_parse_boolean(m, field, eq);
 
         if (STR_IN_SET(field, "CPUWeight",
                               "StartupCPUWeight",
                               "IOWeight",
                               "StartupIOWeight"))
                 return bus_append_cg_weight_parse(m, field, eq);
 
         if (STR_IN_SET(field, "CPUShares",
                               "StartupCPUShares"))
                 return bus_append_cg_cpu_shares_parse(m, field, eq);
 
         if (STR_IN_SET(field, "AllowedCPUs",
                               "StartupAllowedCPUs",
                               "AllowedMemoryNodes",
                               "StartupAllowedMemoryNodes")) {
                 _cleanup_(cpu_set_reset) CPUSet cpuset = {};
                 _cleanup_free_ uint8_t *array = NULL;
                 size_t allocated;
 
                 r = parse_cpu_set(eq, &cpuset);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse %s value: %s", field, eq);
 
                 r = cpu_set_to_dbus(&cpuset, &array, &allocated);
                 if (r < 0)
                         return log_error_errno(r, "Failed to serialize CPUSet: %m");
 
                 return bus_append_byte_array(m, field, array, allocated);
         }
 
         if (STR_IN_SET(field, "BlockIOWeight",
                               "StartupBlockIOWeight"))
                 return bus_append_cg_blkio_weight_parse(m, field, eq);
 
         if (streq(field, "DisableControllers"))
                 return bus_append_strv(m, "DisableControllers", eq, EXTRACT_UNQUOTE);
 
         if (streq(field, "Delegate")) {
                 r = parse_boolean(eq);
                 if (r < 0)
                         return bus_append_strv(m, "DelegateControllers", eq, EXTRACT_UNQUOTE);
 
                 r = sd_bus_message_append(m, "(sv)", "Delegate", "b", r);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "MemoryMin",
                               "DefaultMemoryLow",
                               "DefaultMemoryMin",
                               "MemoryLow",
                               "MemoryHigh",
                               "MemoryMax",
                               "MemorySwapMax",
                               "MemoryLimit",
                               "TasksMax")) {
 
                 if (streq(eq, "infinity")) {
                         r = sd_bus_message_append(m, "(sv)", field, "t", CGROUP_LIMIT_MAX);
                         if (r < 0)
                                 return bus_log_create_error(r);
                         return 1;
                 } else if (isempty(eq)) {
                         uint64_t empty_value = STR_IN_SET(field,
                                                           "DefaultMemoryLow",
                                                           "DefaultMemoryMin",
                                                           "MemoryLow",
                                                           "MemoryMin") ?
                                                CGROUP_LIMIT_MIN :
                                                CGROUP_LIMIT_MAX;
 
                         r = sd_bus_message_append(m, "(sv)", field, "t", empty_value);
                         if (r < 0)
                                 return bus_log_create_error(r);
                         return 1;
                 }
 
                 r = parse_permyriad(eq);
                 if (r >= 0) {
                         char *n;
 
                         /* When this is a percentage we'll convert this into a relative value in the range 0UINT32_MAX
                          * and pass it in the MemoryLowScale property (and related ones). This way the physical memory
                          * size can be determined server-side. */
 
                         n = strjoina(field, "Scale");
                         r = sd_bus_message_append(m, "(sv)", n, "u", UINT32_SCALE_FROM_PERMYRIAD(r));
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         return 1;
                 }
 
                 if (streq(field, "TasksMax"))
                         return bus_append_safe_atou64(m, field, eq);
 
                 return bus_append_parse_size(m, field, eq, 1024);
         }
 
         if (streq(field, "CPUQuota")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", "CPUQuotaPerSecUSec", "t", USEC_INFINITY);
                 else {
                         r = parse_permyriad_unbounded(eq);
                         if (r == 0)
                                 return log_error_errno(SYNTHETIC_ERRNO(ERANGE),
                                                        "CPU quota too small.");
                         if (r < 0)
                                 return log_error_errno(r, "CPU quota '%s' invalid.", eq);
 
                         r = sd_bus_message_append(m, "(sv)", "CPUQuotaPerSecUSec", "t", (((uint64_t) r * USEC_PER_SEC) / 10000U));
                 }
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "CPUQuotaPeriodSec")) {
                 usec_t u = USEC_INFINITY;
 
                 r = parse_sec_def_infinity(eq, &u);
                 if (r < 0)
                         return log_error_errno(r, "CPU quota period '%s' invalid.", eq);
 
                 r = sd_bus_message_append(m, "(sv)", "CPUQuotaPeriodUSec", "t", u);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "DeviceAllow")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "a(ss)", 0);
                 else {
                         const char *path = eq, *rwm = NULL, *e;
 
                         e = strchr(eq, ' ');
                         if (e) {
                                 path = strndupa_safe(eq, e - eq);
                                 rwm = e+1;
                         }
 
                         r = sd_bus_message_append(m, "(sv)", field, "a(ss)", 1, path, strempty(rwm));
                 }
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (cgroup_io_limit_type_from_string(field) >= 0 || STR_IN_SET(field, "BlockIOReadBandwidth", "BlockIOWriteBandwidth")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "a(st)", 0);
                 else {
                         const char *path, *bandwidth, *e;
                         uint64_t bytes;
 
                         e = strchr(eq, ' ');
                         if (!e)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                        "Failed to parse %s value %s.",
                                                        field, eq);
 
                         path = strndupa_safe(eq, e - eq);
                         bandwidth = e+1;
 
                         if (streq(bandwidth, "infinity"))
                                 bytes = CGROUP_LIMIT_MAX;
                         else {
                                 r = parse_size(bandwidth, 1000, &bytes);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse byte value %s: %m", bandwidth);
                         }
 
                         r = sd_bus_message_append(m, "(sv)", field, "a(st)", 1, path, bytes);
                 }
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "IODeviceWeight",
                               "BlockIODeviceWeight")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "a(st)", 0);
                 else {
                         const char *path, *weight, *e;
                         uint64_t u;
 
                         e = strchr(eq, ' ');
                         if (!e)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                        "Failed to parse %s value %s.",
                                                        field, eq);
 
                         path = strndupa_safe(eq, e - eq);
                         weight = e+1;
 
                         r = safe_atou64(weight, &u);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s value %s: %m", field, weight);
 
                         r = sd_bus_message_append(m, "(sv)", field, "a(st)", 1, path, u);
                 }
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "IODeviceLatencyTargetSec")) {
                 const char *field_usec = "IODeviceLatencyTargetUSec";
 
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field_usec, "a(st)", USEC_INFINITY);
                 else {
                         const char *path, *target, *e;
                         usec_t usec;
 
                         e = strchr(eq, ' ');
                         if (!e)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                        "Failed to parse %s value %s.",
                                                        field, eq);
 
                         path = strndupa_safe(eq, e - eq);
                         target = e+1;
 
                         r = parse_sec(target, &usec);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s value %s: %m", field, target);
 
                         r = sd_bus_message_append(m, "(sv)", field_usec, "a(st)", 1, path, usec);
                 }
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "IPAddressAllow",
                               "IPAddressDeny")) {
                 unsigned char prefixlen;
                 union in_addr_union prefix = {};
                 int family;
 
                 if (isempty(eq)) {
                         r = sd_bus_message_append(m, "(sv)", field, "a(iayu)", 0);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         return 1;
                 }
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(iayu)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(iayu)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 if (streq(eq, "any")) {
                         /* "any" is a shortcut for 0.0.0.0/0 and ::/0 */
 
                         r = bus_append_ip_address_access(m, AF_INET, &prefix, 0);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = bus_append_ip_address_access(m, AF_INET6, &prefix, 0);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                 } else if (is_localhost(eq)) {
                         /* "localhost" is a shortcut for 127.0.0.0/8 and ::1/128 */
 
                         prefix.in.s_addr = htobe32(0x7f000000);
                         r = bus_append_ip_address_access(m, AF_INET, &prefix, 8);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         prefix.in6 = (struct in6_addr) IN6ADDR_LOOPBACK_INIT;
                         r = bus_append_ip_address_access(m, AF_INET6, &prefix, 128);
                         if (r < 0)
                                 return r;
 
                 } else if (streq(eq, "link-local")) {
                         /* "link-local" is a shortcut for 169.254.0.0/16 and fe80::/64 */
 
                         prefix.in.s_addr = htobe32((UINT32_C(169) << 24 | UINT32_C(254) << 16));
                         r = bus_append_ip_address_access(m, AF_INET, &prefix, 16);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         prefix.in6 = (struct in6_addr) {
                                 .s6_addr32[0] = htobe32(0xfe800000)
                         };
                         r = bus_append_ip_address_access(m, AF_INET6, &prefix, 64);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                 } else if (streq(eq, "multicast")) {
                         /* "multicast" is a shortcut for 224.0.0.0/4 and ff00::/8 */
 
                         prefix.in.s_addr = htobe32((UINT32_C(224) << 24));
                         r = bus_append_ip_address_access(m, AF_INET, &prefix, 4);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         prefix.in6 = (struct in6_addr) {
                                 .s6_addr32[0] = htobe32(0xff000000)
                         };
                         r = bus_append_ip_address_access(m, AF_INET6, &prefix, 8);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                 } else {
                         for (;;) {
                                 _cleanup_free_ char *word = NULL;
 
                                 r = extract_first_word(&eq, &word, NULL, 0);
                                 if (r == 0)
                                         break;
                                 if (r == -ENOMEM)
                                         return log_oom();
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse %s: %s", field, eq);
 
                                 r = in_addr_prefix_from_string_auto(word, &family, &prefix, &prefixlen);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse IP address prefix: %s", word);
 
                                 r = bus_append_ip_address_access(m, family, &prefix, prefixlen);
                                 if (r < 0)
                                         return bus_log_create_error(r);
                         }
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "IPIngressFilterPath",
                               "IPEgressFilterPath")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "as", 0);
                 else
                         r = sd_bus_message_append(m, "(sv)", field, "as", 1, eq);
 
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "BPFProgram")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "a(ss)", 0);
                 else {
                         _cleanup_free_ char *word = NULL;
 
                         r = extract_first_word(&eq, &word, ":", 0);
                         if (r == -ENOMEM)
                                 return log_oom();
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s: %m", field);
 
                         r = sd_bus_message_append(m, "(sv)", field, "a(ss)", 1, word, eq);
                 }
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "SocketBindAllow",
                               "SocketBindDeny")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", field, "a(iiqq)", 0);
                 else {
                         int32_t family, ip_protocol;
                         uint16_t nr_ports, port_min;
 
                         r = parse_socket_bind_item(eq, &family, &ip_protocol, &nr_ports, &port_min);
                         if (r == -ENOMEM)
                                 return log_oom();
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s", field);
 
                         r = sd_bus_message_append(
                                         m, "(sv)", field, "a(iiqq)", 1, family, ip_protocol, nr_ports, port_min);
                 }
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
-        if (streq(field, "ControlGroupNFTSet"))
-                return bus_append_nft_set(m, field, eq);
-
         return 0;
 }
 
@@ -1000,1146 +911,1143 @@ static int bus_append_automount_property(sd_bus_message *m, const char *field, c
 static int bus_append_execute_property(sd_bus_message *m, const char *field, const char *eq) {
         const char *suffix;
         int r;
 
         if (STR_IN_SET(field, "User",
                               "Group",
                               "UtmpIdentifier",
                               "UtmpMode",
                               "PAMName",
                               "TTYPath",
                               "WorkingDirectory",
                               "RootDirectory",
                               "SyslogIdentifier",
                               "ProtectSystem",
                               "ProtectHome",
                               "SELinuxContext",
                               "RootImage",
                               "RootVerity",
                               "RuntimeDirectoryPreserve",
                               "Personality",
                               "KeyringMode",
                               "ProtectProc",
                               "ProcSubset",
                               "NetworkNamespacePath",
                               "IPCNamespacePath",
                               "LogNamespace"))
                 return bus_append_string(m, field, eq);
 
         if (STR_IN_SET(field, "IgnoreSIGPIPE",
                               "TTYVHangup",
                               "TTYReset",
                               "TTYVTDisallocate",
                               "PrivateTmp",
                               "PrivateDevices",
                               "PrivateNetwork",
                               "PrivateUsers",
                               "PrivateMounts",
                               "PrivateIPC",
                               "NoNewPrivileges",
                               "SyslogLevelPrefix",
                               "MemoryDenyWriteExecute",
                               "RestrictRealtime",
                               "DynamicUser",
                               "RemoveIPC",
                               "ProtectKernelTunables",
                               "ProtectKernelModules",
                               "ProtectKernelLogs",
                               "ProtectClock",
                               "ProtectControlGroups",
                               "MountAPIVFS",
                               "CPUSchedulingResetOnFork",
                               "LockPersonality",
                               "ProtectHostname",
                               "RestrictSUIDSGID"))
                 return bus_append_parse_boolean(m, field, eq);
 
         if (STR_IN_SET(field, "ReadWriteDirectories",
                               "ReadOnlyDirectories",
                               "InaccessibleDirectories",
                               "ReadWritePaths",
                               "ReadOnlyPaths",
                               "InaccessiblePaths",
                               "ExecPaths",
                               "NoExecPaths",
                               "ExecSearchPath",
                               "ExtensionDirectories",
                               "ConfigurationDirectory",
                               "SupplementaryGroups",
                               "SystemCallArchitectures"))
                 return bus_append_strv(m, field, eq, EXTRACT_UNQUOTE);
 
         if (STR_IN_SET(field, "SyslogLevel",
                               "LogLevelMax"))
                 return bus_append_log_level_from_string(m, field, eq);
 
         if (streq(field, "SyslogFacility"))
                 return bus_append_log_facility_unshifted_from_string(m, field, eq);
 
         if (streq(field, "SecureBits"))
                 return bus_append_secure_bits_from_string(m, field, eq);
 
         if (streq(field, "CPUSchedulingPolicy"))
                 return bus_append_sched_policy_from_string(m, field, eq);
 
         if (STR_IN_SET(field, "CPUSchedulingPriority",
                               "OOMScoreAdjust"))
                 return bus_append_safe_atoi(m, field, eq);
 
         if (streq(field, "CoredumpFilter"))
                 return bus_append_coredump_filter_mask_from_string(m, field, eq);
 
         if (streq(field, "Nice"))
                 return bus_append_parse_nice(m, field, eq);
 
         if (streq(field, "SystemCallErrorNumber"))
                 return bus_append_seccomp_parse_errno_or_action(m, field, eq);
 
         if (streq(field, "IOSchedulingClass"))
                 return bus_append_ioprio_class_from_string(m, field, eq);
 
         if (streq(field, "IOSchedulingPriority"))
                 return bus_append_ioprio_parse_priority(m, field, eq);
 
         if (STR_IN_SET(field, "RuntimeDirectoryMode",
                               "StateDirectoryMode",
                               "CacheDirectoryMode",
                               "LogsDirectoryMode",
                               "ConfigurationDirectoryMode",
                               "UMask"))
                 return bus_append_parse_mode(m, field, eq);
 
         if (streq(field, "TimerSlackNSec"))
                 return bus_append_parse_nsec(m, field, eq);
 
         if (streq(field, "LogRateLimitIntervalSec"))
                 return bus_append_parse_sec_rename(m, field, eq);
 
         if (STR_IN_SET(field, "LogRateLimitBurst",
                               "TTYRows",
                               "TTYColumns"))
                 return bus_append_safe_atou(m, field, eq);
 
         if (streq(field, "MountFlags"))
                 return bus_append_mount_propagation_flags_from_string(m, field, eq);
 
         if (STR_IN_SET(field, "Environment",
                               "UnsetEnvironment",
                               "PassEnvironment"))
                 return bus_append_strv(m, field, eq, EXTRACT_UNQUOTE|EXTRACT_CUNESCAPE);
 
         if (streq(field, "EnvironmentFile")) {
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "(sv)", "EnvironmentFiles", "a(sb)", 0);
                 else
                         r = sd_bus_message_append(m, "(sv)", "EnvironmentFiles", "a(sb)", 1,
                                                   eq[0] == '-' ? eq + 1 : eq,
                                                   eq[0] == '-');
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "SetCredential", "SetCredentialEncrypted")) {
                 r = sd_bus_message_open_container(m, 'r', "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, 's', field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(say)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "a(say)", 0);
                 else {
                         _cleanup_free_ char *word = NULL;
                         const char *p = eq;
 
                         r = extract_first_word(&p, &word, ":", EXTRACT_DONT_COALESCE_SEPARATORS);
                         if (r == -ENOMEM)
                                 return log_oom();
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s= parameter: %s", field, eq);
                         if (r == 0 || !p)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Missing argument to %s=.", field);
 
                         r = sd_bus_message_open_container(m, 'a', "(say)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'r', "say");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_append(m, "s", word);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         if (streq(field, "SetCredentialEncrypted")) {
                                 _cleanup_free_ void *decoded = NULL;
                                 size_t decoded_size;
 
                                 r = unbase64mem(p, SIZE_MAX, &decoded, &decoded_size);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to base64 decode encrypted credential: %m");
 
                                 r = sd_bus_message_append_array(m, 'y', decoded, decoded_size);
                         } else {
                                 _cleanup_free_ char *unescaped = NULL;
                                 ssize_t l;
 
                                 l = cunescape(p, UNESCAPE_ACCEPT_NUL, &unescaped);
                                 if (l < 0)
                                         return log_error_errno(l, "Failed to unescape %s= value: %s", field, p);
 
                                 r = sd_bus_message_append_array(m, 'y', unescaped, l);
                         }
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                 }
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "LoadCredential", "LoadCredentialEncrypted")) {
                 r = sd_bus_message_open_container(m, 'r', "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, 's', field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(ss)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 if (isempty(eq))
                         r = sd_bus_message_append(m, "a(ss)", 0);
                 else {
                         _cleanup_free_ char *word = NULL;
                         const char *p = eq;
 
                         r = extract_first_word(&p, &word, ":", EXTRACT_DONT_COALESCE_SEPARATORS);
                         if (r == -ENOMEM)
                                 return log_oom();
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s= parameter: %s", field, eq);
                         if (r == 0)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Missing argument to %s=.", field);
 
                         if (isempty(p)) /* If only one field is specified, then this means "inherit from above" */
                                 p = eq;
 
                         r = sd_bus_message_append(m, "a(ss)", 1, word, p);
                 }
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "LogExtraFields")) {
                 r = sd_bus_message_open_container(m, 'r', "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, 's', "LogExtraFields");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "aay");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "ay");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_array(m, 'y', eq, strlen(eq));
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "StandardInput",
                               "StandardOutput",
                               "StandardError")) {
                 const char *n, *appended;
 
                 if ((n = startswith(eq, "fd:"))) {
                         appended = strjoina(field, "FileDescriptorName");
                         r = sd_bus_message_append(m, "(sv)", appended, "s", n);
                 } else if ((n = startswith(eq, "file:"))) {
                         appended = strjoina(field, "File");
                         r = sd_bus_message_append(m, "(sv)", appended, "s", n);
                 } else if ((n = startswith(eq, "append:"))) {
                         appended = strjoina(field, "FileToAppend");
                         r = sd_bus_message_append(m, "(sv)", appended, "s", n);
                 } else if ((n = startswith(eq, "truncate:"))) {
                         appended = strjoina(field, "FileToTruncate");
                         r = sd_bus_message_append(m, "(sv)", appended, "s", n);
                 } else
                         r = sd_bus_message_append(m, "(sv)", field, "s", eq);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "StandardInputText")) {
                 _cleanup_free_ char *unescaped = NULL;
                 ssize_t l;
 
                 l = cunescape(eq, 0, &unescaped);
                 if (l < 0)
                         return log_error_errno(l, "Failed to unescape text '%s': %m", eq);
 
                 if (!strextend(&unescaped, "\n"))
                         return log_oom();
 
                 /* Note that we don't expand specifiers here, but that should be OK, as this is a
                  * programmatic interface anyway */
 
                 return bus_append_byte_array(m, field, unescaped, l + 1);
         }
 
         if (streq(field, "StandardInputData")) {
                 _cleanup_free_ void *decoded = NULL;
                 size_t sz;
 
                 r = unbase64mem(eq, SIZE_MAX, &decoded, &sz);
                 if (r < 0)
                         return log_error_errno(r, "Failed to decode base64 data '%s': %m", eq);
 
                 return bus_append_byte_array(m, field, decoded, sz);
         }
 
         if ((suffix = startswith(field, "Limit"))) {
                 int rl;
 
                 rl = rlimit_from_string(suffix);
                 if (rl >= 0) {
                         const char *sn;
                         struct rlimit l;
 
                         r = rlimit_parse(rl, eq, &l);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse resource limit: %s", eq);
 
                         r = sd_bus_message_append(m, "(sv)", field, "t", l.rlim_max);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         sn = strjoina(field, "Soft");
                         r = sd_bus_message_append(m, "(sv)", sn, "t", l.rlim_cur);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         return 1;
                 }
         }
 
         if (STR_IN_SET(field, "AppArmorProfile",
                               "SmackProcessLabel")) {
                 int ignore = 0;
                 const char *s = eq;
 
                 if (eq[0] == '-') {
                         ignore = 1;
                         s = eq + 1;
                 }
 
                 r = sd_bus_message_append(m, "(sv)", field, "(bs)", ignore, s);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "CapabilityBoundingSet",
                               "AmbientCapabilities")) {
                 uint64_t sum = 0;
                 bool invert = false;
                 const char *p = eq;
 
                 if (*p == '~') {
                         invert = true;
                         p++;
                 }
 
                 r = capability_set_from_string(p, &sum);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse %s value %s: %m", field, eq);
 
                 sum = invert ? ~sum : sum;
 
                 r = sd_bus_message_append(m, "(sv)", field, "t", sum);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "CPUAffinity")) {
                 _cleanup_(cpu_set_reset) CPUSet cpuset = {};
                 _cleanup_free_ uint8_t *array = NULL;
                 size_t allocated;
 
                 if (eq && streq(eq, "numa")) {
                         r = sd_bus_message_append(m, "(sv)", "CPUAffinityFromNUMA", "b", true);
                         if (r < 0)
                                 return bus_log_create_error(r);
                         return r;
                 }
 
                 r = parse_cpu_set(eq, &cpuset);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse %s value: %s", field, eq);
 
                 r = cpu_set_to_dbus(&cpuset, &array, &allocated);
                 if (r < 0)
                         return log_error_errno(r, "Failed to serialize CPUAffinity: %m");
 
                 return bus_append_byte_array(m, field, array, allocated);
         }
 
         if (streq(field, "NUMAPolicy")) {
                 r = mpol_from_string(eq);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse %s value: %s", field, eq);
 
                 r = sd_bus_message_append(m, "(sv)", field, "i", (int32_t) r);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "NUMAMask")) {
                 _cleanup_(cpu_set_reset) CPUSet nodes = {};
                 _cleanup_free_ uint8_t *array = NULL;
                 size_t allocated;
 
                 if (eq && streq(eq, "all")) {
                         r = numa_mask_add_all(&nodes);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to create NUMA mask representing \"all\" NUMA nodes: %m");
                 } else {
                         r = parse_cpu_set(eq, &nodes);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s value: %s", field, eq);
                 }
 
                 r = cpu_set_to_dbus(&nodes, &array, &allocated);
                 if (r < 0)
                         return log_error_errno(r, "Failed to serialize NUMAMask: %m");
 
                 return bus_append_byte_array(m, field, array, allocated);
         }
 
         if (STR_IN_SET(field, "RestrictAddressFamilies",
                               "RestrictFileSystems",
                               "SystemCallFilter",
                               "SystemCallLog",
                               "RestrictNetworkInterfaces")) {
                 int allow_list = 1;
                 const char *p = eq;
 
                 if (*p == '~') {
                         allow_list = 0;
                         p++;
                 }
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "(bas)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'r', "bas");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, 'b', &allow_list);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "s");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 for (;;) {
                         _cleanup_free_ char *word = NULL;
 
                         r = extract_first_word(&p, &word, NULL, EXTRACT_UNQUOTE);
                         if (r == 0)
                                 break;
                         if (r == -ENOMEM)
                                 return log_oom();
                         if (r < 0)
                                 return log_error_errno(r, "Invalid syntax: %s", eq);
 
                         r = sd_bus_message_append_basic(m, 's', word);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "RestrictNamespaces")) {
                 bool invert = false;
                 unsigned long flags;
 
                 r = parse_boolean(eq);
                 if (r > 0)
                         flags = 0;
                 else if (r == 0)
                         flags = NAMESPACE_FLAGS_ALL;
                 else {
                         if (eq[0] == '~') {
                                 invert = true;
                                 eq++;
                         }
 
                         r = namespace_flags_from_string(eq, &flags);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse %s value %s.", field, eq);
                 }
 
                 if (invert)
                         flags = (~flags) & NAMESPACE_FLAGS_ALL;
 
                 r = sd_bus_message_append(m, "(sv)", field, "t", (uint64_t) flags);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "BindPaths",
                               "BindReadOnlyPaths")) {
                 const char *p = eq;
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(ssbt)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(ssbt)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 for (;;) {
                         _cleanup_free_ char *source = NULL, *destination = NULL;
                         char *s = NULL, *d = NULL;
                         bool ignore_enoent = false;
                         uint64_t flags = MS_REC;
 
                         r = extract_first_word(&p, &source, ":" WHITESPACE, EXTRACT_UNQUOTE|EXTRACT_DONT_COALESCE_SEPARATORS);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse argument: %m");
                         if (r == 0)
                                 break;
 
                         s = source;
                         if (s[0] == '-') {
                                 ignore_enoent = true;
                                 s++;
                         }
 
                         if (p && p[-1] == ':') {
                                 r = extract_first_word(&p, &destination, ":" WHITESPACE, EXTRACT_UNQUOTE|EXTRACT_DONT_COALESCE_SEPARATORS);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse argument: %m");
                                 if (r == 0)
                                         return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                                "Missing argument after ':': %s",
                                                                eq);
 
                                 d = destination;
 
                                 if (p && p[-1] == ':') {
                                         _cleanup_free_ char *options = NULL;
 
                                         r = extract_first_word(&p, &options, NULL, EXTRACT_UNQUOTE);
                                         if (r < 0)
                                                 return log_error_errno(r, "Failed to parse argument: %m");
 
                                         if (isempty(options) || streq(options, "rbind"))
                                                 flags = MS_REC;
                                         else if (streq(options, "norbind"))
                                                 flags = 0;
                                         else
                                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                                        "Unknown options: %s",
                                                                        eq);
                                 }
                         } else
                                 d = s;
 
                         r = sd_bus_message_append(m, "(ssbt)", s, d, ignore_enoent, flags);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "TemporaryFileSystem")) {
                 const char *p = eq;
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(ss)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(ss)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 for (;;) {
                         _cleanup_free_ char *word = NULL, *path = NULL;
                         const char *w;
 
                         r = extract_first_word(&p, &word, NULL, EXTRACT_UNQUOTE);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse argument: %m");
                         if (r == 0)
                                 break;
 
                         w = word;
                         r = extract_first_word(&w, &path, ":", EXTRACT_DONT_COALESCE_SEPARATORS);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse argument: %m");
                         if (r == 0)
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                        "Failed to parse argument: %s",
                                                        p);
 
                         r = sd_bus_message_append(m, "(ss)", path, w);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "RootHash")) {
                 _cleanup_free_ void *roothash_decoded = NULL;
                 size_t roothash_decoded_size = 0;
 
                 /* We have the path to a roothash to load and decode, eg: RootHash=/foo/bar.roothash */
                 if (path_is_absolute(eq))
                         return bus_append_string(m, "RootHashPath", eq);
 
                 /* We have a roothash to decode, eg: RootHash=012345789abcdef */
                 r = unhexmem(eq, strlen(eq), &roothash_decoded, &roothash_decoded_size);
                 if (r < 0)
                         return log_error_errno(r, "Failed to decode RootHash= '%s': %m", eq);
                 if (roothash_decoded_size < sizeof(sd_id128_t))
                         return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "RootHash= '%s' is too short: %m", eq);
 
                 return bus_append_byte_array(m, field, roothash_decoded, roothash_decoded_size);
         }
 
         if (streq(field, "RootHashSignature")) {
                 _cleanup_free_ void *roothash_sig_decoded = NULL;
                 char *value;
                 size_t roothash_sig_decoded_size = 0;
 
                 /* We have the path to a roothash signature to load and decode, eg: RootHash=/foo/bar.roothash.p7s */
                 if (path_is_absolute(eq))
                         return bus_append_string(m, "RootHashSignaturePath", eq);
 
                 if (!(value = startswith(eq, "base64:")))
                         return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Failed to decode RootHashSignature= '%s', not a path but doesn't start with 'base64:': %m", eq);
 
                 /* We have a roothash signature to decode, eg: RootHashSignature=base64:012345789abcdef */
                 r = unbase64mem(value, strlen(value), &roothash_sig_decoded, &roothash_sig_decoded_size);
                 if (r < 0)
                         return log_error_errno(r, "Failed to decode RootHashSignature= '%s': %m", eq);
 
                 return bus_append_byte_array(m, field, roothash_sig_decoded, roothash_sig_decoded_size);
         }
 
         if (streq(field, "RootImageOptions")) {
                 _cleanup_strv_free_ char **l = NULL;
                 const char *p = eq;
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(ss)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(ss)");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = strv_split_colon_pairs(&l, p);
                 if (r < 0)
                         return log_error_errno(r, "Failed to parse argument: %m");
 
                 STRV_FOREACH_PAIR(first, second, l) {
                         r = sd_bus_message_append(m, "(ss)",
                                                   !isempty(*second) ? *first : "root",
                                                   !isempty(*second) ? *second : *first);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "MountImages")) {
                 const char *p = eq;
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(ssba(ss))");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(ssba(ss))");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 for (;;) {
                         _cleanup_free_ char *first = NULL, *second = NULL, *tuple = NULL;
                         const char *q = NULL, *source = NULL;
                         bool permissive = false;
 
                         r = extract_first_word(&p, &tuple, NULL, EXTRACT_UNQUOTE|EXTRACT_RETAIN_ESCAPE);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse MountImages= property: %s", eq);
                         if (r == 0)
                                 break;
 
                         q = tuple;
                         r = extract_many_words(&q, ":", EXTRACT_CUNESCAPE|EXTRACT_UNESCAPE_SEPARATORS, &first, &second, NULL);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse MountImages= property: %s", eq);
                         if (r == 0)
                                 continue;
 
                         source = first;
                         if (source[0] == '-') {
                                 permissive = true;
                                 source++;
                         }
 
                         if (isempty(second))
                                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                                         "Missing argument after ':': %s",
                                                         eq);
 
                         r = sd_bus_message_open_container(m, 'r', "ssba(ss)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_append(m, "ssb", source, second, permissive);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'a', "(ss)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         for (;;) {
                                 _cleanup_free_ char *partition = NULL, *mount_options = NULL;
 
                                 r = extract_many_words(&q, ":", EXTRACT_CUNESCAPE|EXTRACT_UNESCAPE_SEPARATORS, &partition, &mount_options, NULL);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse MountImages= property: %s", eq);
                                 if (r == 0)
                                         break;
                                 /* Single set of options, applying to the root partition/single filesystem */
                                 if (r == 1) {
                                         r = sd_bus_message_append(m, "(ss)", "root", partition);
                                         if (r < 0)
                                                 return bus_log_create_error(r);
 
                                         break;
                                 }
 
                                 r = sd_bus_message_append(m, "(ss)", partition, mount_options);
                                 if (r < 0)
                                         return bus_log_create_error(r);
                         }
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (streq(field, "ExtensionImages")) {
                 const char *p = eq;
 
                 r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'v', "a(sba(ss))");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_open_container(m, 'a', "(sba(ss))");
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 for (;;) {
                         _cleanup_free_ char *source = NULL, *tuple = NULL;
                         const char *q = NULL, *s = NULL;
                         bool permissive = false;
 
                         r = extract_first_word(&p, &tuple, NULL, EXTRACT_UNQUOTE|EXTRACT_RETAIN_ESCAPE);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse ExtensionImages= property: %s", eq);
                         if (r == 0)
                                 break;
 
                         q = tuple;
                         r = extract_first_word(&q, &source, ":", EXTRACT_CUNESCAPE|EXTRACT_UNESCAPE_SEPARATORS);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse ExtensionImages= property: %s", eq);
                         if (r == 0)
                                 continue;
 
                         s = source;
                         if (s[0] == '-') {
                                 permissive = true;
                                 s++;
                         }
 
                         r = sd_bus_message_open_container(m, 'r', "sba(ss)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_append(m, "sb", s, permissive);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'a', "(ss)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         for (;;) {
                                 _cleanup_free_ char *partition = NULL, *mount_options = NULL;
 
                                 r = extract_many_words(&q, ":", EXTRACT_CUNESCAPE|EXTRACT_UNESCAPE_SEPARATORS, &partition, &mount_options, NULL);
                                 if (r < 0)
                                         return log_error_errno(r, "Failed to parse ExtensionImages= property: %s", eq);
                                 if (r == 0)
                                         break;
                                 /* Single set of options, applying to the root partition/single filesystem */
                                 if (r == 1) {
                                         r = sd_bus_message_append(m, "(ss)", "root", partition);
                                         if (r < 0)
                                                 return bus_log_create_error(r);
 
                                         break;
                                 }
 
                                 r = sd_bus_message_append(m, "(ss)", partition, mount_options);
                                 if (r < 0)
                                         return bus_log_create_error(r);
                         }
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 r = sd_bus_message_close_container(m);
                 if (r < 0)
                         return bus_log_create_error(r);
 
                 return 1;
         }
 
         if (STR_IN_SET(field, "StateDirectory", "RuntimeDirectory", "CacheDirectory", "LogsDirectory")) {
                 _cleanup_strv_free_ char **symlinks = NULL, **sources = NULL;
                 const char *p = eq;
 
                 /* Adding new directories is supported from both *DirectorySymlink methods and the
                  * older ones, so first parse the input, and if we are given a new-style src:dst
                  * tuple use the new method, else use the old one. */
 
                 for (;;) {
                         _cleanup_free_ char *tuple = NULL, *source = NULL, *destination = NULL;
 
                         r = extract_first_word(&p, &tuple, NULL, EXTRACT_UNQUOTE);
                         if (r < 0)
                                 return log_error_errno(r, "Failed to parse argument: %m");
                         if (r == 0)
                                 break;
 
                         const char *t = tuple;
                         r = extract_many_words(&t, ":", EXTRACT_UNQUOTE|EXTRACT_DONT_COALESCE_SEPARATORS, &source, &destination, NULL);
                         if (r <= 0)
                                 return log_error_errno(r ?: SYNTHETIC_ERRNO(EINVAL), "Failed to parse argument: %m");
 
                         path_simplify(source);
 
                         if (isempty(destination)) {
                                 r = strv_consume(&sources, TAKE_PTR(source));
                                 if (r < 0)
                                         return bus_log_create_error(r);
                         } else {
                                 path_simplify(destination);
 
                                 r = strv_consume_pair(&symlinks, TAKE_PTR(source), TAKE_PTR(destination));
                                 if (r < 0)
                                         return log_oom();
                         }
                 }
 
                 if (!strv_isempty(sources)) {
                         r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, field);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'v', "as");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_append_strv(m, sources);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 /* For State and Runtime directories we support an optional destination parameter, which
                  * will be used to create a symlink to the source. But it is new so we cannot change the
                  * old DBUS signatures, so append a new message type. */
                 if (!strv_isempty(symlinks)) {
                         const char *symlink_field;
 
                         r = sd_bus_message_open_container(m, SD_BUS_TYPE_STRUCT, "sv");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         if (streq(field, "StateDirectory"))
                                 symlink_field = "StateDirectorySymlink";
                         else if (streq(field, "RuntimeDirectory"))
                                 symlink_field = "RuntimeDirectorySymlink";
                         else if (streq(field, "CacheDirectory"))
                                 symlink_field = "CacheDirectorySymlink";
                         else if (streq(field, "LogsDirectory"))
                                 symlink_field = "LogsDirectorySymlink";
                         else
                                 assert_not_reached();
 
                         r = sd_bus_message_append_basic(m, SD_BUS_TYPE_STRING, symlink_field);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'v', "a(sst)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_open_container(m, 'a', "(sst)");
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         STRV_FOREACH_PAIR(source, destination, symlinks) {
                                 r = sd_bus_message_append(m, "(sst)", *source, *destination, 0);
                                 if (r < 0)
                                         return bus_log_create_error(r);
                         }
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
 
                         r = sd_bus_message_close_container(m);
                         if (r < 0)
                                 return bus_log_create_error(r);
                 }
 
                 return 1;
         }
 
-        if (STR_IN_SET(field, "DynamicUserNFTSet"))
-                return bus_append_nft_set(m, field, eq);
-
         return 0;
 }
 
diff --git a/src/shared/firewall-util-nft.c b/src/shared/firewall-util-nft.c
index 331aaf3f0b..2f98e791c2 100644
--- a/src/shared/firewall-util-nft.c
+++ b/src/shared/firewall-util-nft.c
@@ -1,32 +1,30 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
 #include <arpa/inet.h>
 #include <endian.h>
 #include <errno.h>
 #include <stddef.h>
 #include <string.h>
 #include <linux/netfilter/nf_tables.h>
 #include <linux/netfilter/nf_nat.h>
 #include <linux/netfilter_ipv4.h>
 #include <netinet/ip.h>
 #include <netinet/ip6.h>
 
 #include "sd-netlink.h"
 
 #include "alloc-util.h"
-#include "extract-word.h"
 #include "firewall-util.h"
 #include "firewall-util-private.h"
 #include "in-addr-util.h"
 #include "macro.h"
 #include "socket-util.h"
-#include "string-table.h"
 #include "time-util.h"
 
 #define NFT_SYSTEMD_DNAT_MAP_NAME "map_port_ipport"
 #define NFT_SYSTEMD_TABLE_NAME   "io.systemd.nat"
 #define NFT_SYSTEMD_MASQ_SET_NAME "masq_saddr"
 
 #define NFNL_DEFAULT_TIMEOUT_USECS (1ULL * USEC_PER_SEC)
 
 #define UDP_DPORT_OFFSET 2
@@ -850,52 +848,49 @@ static int nft_message_add_setelem_ip6range(
 
 #define NFT_MASQ_MSGS   3
 
-static int nft_set_element_op_in_addr(
-                sd_netlink *nfnl,
-                const char *table,
-                const char *set,
+static int fw_nftables_add_masquerade_internal(
+                FirewallContext *ctx,
                 bool add,
-                int nfproto,
                 int af,
                 const union in_addr_union *source,
                 unsigned int source_prefixlen) {
 
         sd_netlink_message *transaction[NFT_MASQ_MSGS] = {};
         size_t tsize;
         int r;
 
         if (!source || source_prefixlen == 0)
                 return -EINVAL;
 
         if (af == AF_INET6 && source_prefixlen < 8)
                 return -EINVAL;
 
-        r = sd_nfnl_message_batch_begin(nfnl, &transaction[0]);
+        r = sd_nfnl_message_batch_begin(ctx->nfnl, &transaction[0]);
         if (r < 0)
                 return r;
         tsize = 1;
         if (add)
-                r = sd_nfnl_nft_message_new_setelems_begin(nfnl, &transaction[tsize], nfproto, table, set);
+                r = sd_nfnl_nft_message_new_setelems_begin(ctx->nfnl, &transaction[tsize], af, NFT_SYSTEMD_TABLE_NAME, NFT_SYSTEMD_MASQ_SET_NAME);
         else
-                r = sd_nfnl_nft_message_del_setelems_begin(nfnl, &transaction[tsize], nfproto, table, set);
+                r = sd_nfnl_nft_message_del_setelems_begin(ctx->nfnl, &transaction[tsize], af, NFT_SYSTEMD_TABLE_NAME, NFT_SYSTEMD_MASQ_SET_NAME);
         if (r < 0)
                 goto out_unref;
 
         if (af == AF_INET)
                  r = nft_message_add_setelem_iprange(transaction[tsize], source, source_prefixlen);
         else
                  r = nft_message_add_setelem_ip6range(transaction[tsize], source, source_prefixlen);
         if (r < 0)
                 goto out_unref;
 
         ++tsize;
         assert(tsize < NFT_MASQ_MSGS);
-        r = sd_nfnl_message_batch_end(nfnl, &transaction[tsize]);
+        r = sd_nfnl_message_batch_end(ctx->nfnl, &transaction[tsize]);
         if (r < 0)
                 return r;
 
         ++tsize;
-        r = nfnl_netlink_sendv(nfnl, transaction, tsize);
+        r = nfnl_netlink_sendv(ctx->nfnl, transaction, tsize);
 
 out_unref:
         while (tsize > 0)
@@ -903,65 +898,6 @@ out_unref:
         return r < 0 ? r : 0;
 }
 
-static int nft_set_element_op_in_addr_open(
-                bool add,
-                const NFTSetContext *nft_set_context,
-                int af,
-                const union in_addr_union *address,
-                unsigned int prefixlen) {
-
-        _cleanup_(sd_netlink_unrefp) sd_netlink *nfnl = NULL;
-        const char *table, *set;
-        int r, nfproto;
-
-        assert(nft_set_context);
-        nfproto = nft_set_context->nfproto;
-        table = nft_set_context->table;
-        assert(table);
-        set = nft_set_context->set;
-        assert(set);
-
-        r = sd_nfnl_socket_open(&nfnl);
-        if (r < 0)
-                return r;
-
-        r = nft_set_element_op_in_addr(nfnl, table, set,
-                                       add, nfproto, af, address, prefixlen);
-
-        log_debug("%s NFT family %s table %s set %s IP address %s",
-                  add ? "Added" : "Deleted",
-                  nfproto_to_string(nfproto), table, set,
-                  IN_ADDR_PREFIX_TO_STRING(af, address, prefixlen));
-
-        return r;
-}
-
-int nft_set_element_add_in_addr(
-                const NFTSetContext *nft_set_context,
-                int af,
-                const union in_addr_union *address,
-                unsigned int prefixlen) {
-        return nft_set_element_op_in_addr_open(true, nft_set_context, af, address, prefixlen);
-}
-
-int nft_set_element_del_in_addr(
-                const NFTSetContext *nft_set_context,
-                int af,
-                const union in_addr_union *address,
-                unsigned int prefixlen) {
-        return nft_set_element_op_in_addr_open(false, nft_set_context, af, address, prefixlen);
-}
-
-static int fw_nftables_add_masquerade_internal(
-                FirewallContext *ctx,
-                bool add,
-                int af,
-                const union in_addr_union *source,
-                unsigned int source_prefixlen) {
-        return nft_set_element_op_in_addr(ctx->nfnl, NFT_SYSTEMD_TABLE_NAME, NFT_SYSTEMD_MASQ_SET_NAME,
-                                          add, af, af, source, source_prefixlen);
-}
-
 int fw_nftables_add_masquerade(
                 FirewallContext *ctx,
                 bool add,
@@ -1111,246 +1047,27 @@ out_unref:
 int fw_nftables_add_local_dnat(
                 FirewallContext *ctx,
                 bool add,
                 int af,
                 int protocol,
                 uint16_t local_port,
                 const union in_addr_union *remote,
                 uint16_t remote_port,
                 const union in_addr_union *previous_remote) {
 
         int r;
 
         if (!socket_ipv6_is_supported() && af == AF_INET6)
                 return -EOPNOTSUPP;
 
         r = fw_nftables_add_local_dnat_internal(ctx, add, af, protocol, local_port, remote, remote_port, previous_remote);
         if (r != -ENOENT)
                 return r;
 
         /* See comment in fw_nftables_add_masquerade(). */
         r = fw_nftables_init_family(ctx->nfnl, af);
         if (r < 0)
                 return r;
 
         /* table created anew; previous address already gone */
         return fw_nftables_add_local_dnat_internal(ctx, add, af, protocol, local_port, remote, remote_port, NULL);
 }
-
-static const char *const nfproto_table[] = {
-        [NFPROTO_ARP] = "arp",
-        [NFPROTO_BRIDGE] = "bridge",
-        [NFPROTO_INET] = "inet",
-        [NFPROTO_IPV4] = "ip",
-        [NFPROTO_IPV6] = "ip6",
-        [NFPROTO_NETDEV] = "netdev",
-};
-
-DEFINE_STRING_TABLE_LOOKUP(nfproto, int);
-
-#define NFT_SET_MSGS 3
-
-static int nft_set_element_op(bool add, const NFTSetContext *nft_set_context, void *element, size_t element_size) {
-        _cleanup_(sd_netlink_unrefp) sd_netlink *nfnl = NULL;
-        sd_netlink_message *transaction[NFT_SET_MSGS] = {};
-        _cleanup_free_ uint32_t *serial = NULL;
-        size_t tsize;
-        int r, nfproto;
-        const char *table, *set;
-
-        assert(nft_set_context);
-        nfproto = nft_set_context->nfproto;
-        table = nft_set_context->table;
-        assert(table);
-        set = nft_set_context->set;
-        assert(set);
-        assert(element);
-
-        r = sd_nfnl_socket_open(&nfnl);
-        if (r < 0)
-                return r;
-
-        r = sd_nfnl_message_batch_begin(nfnl, &transaction[0]);
-        if (r < 0)
-                return r;
-        tsize = 1;
-
-        if (add)
-                r = sd_nfnl_nft_message_new_setelems_begin(nfnl, &transaction[tsize], nfproto, table, set);
-        else
-                r = sd_nfnl_nft_message_del_setelems_begin(nfnl, &transaction[tsize], nfproto, table, set);
-        if (r < 0)
-                goto out_unref;
-
-        r = sd_nfnl_nft_message_add_setelem(transaction[tsize], 0, element, element_size, NULL, 0);
-        if (r < 0)
-                return r;
-
-        r = sd_nfnl_nft_message_add_setelem_end(transaction[tsize]);
-        if (r < 0)
-                return r;
-        ++tsize;
-        assert(tsize < ELEMENTSOF(transaction));
-        r = sd_nfnl_message_batch_end(nfnl, &transaction[tsize]);
-        if (r < 0)
-                return r;
-
-        ++tsize;
-        r = sd_netlink_sendv(nfnl, transaction, tsize, &serial);
-
-out_unref:
-        while (tsize > 0)
-                sd_netlink_message_unref(transaction[--tsize]);
-        return r < 0 ? r : 0;
-}
-
-int nft_set_element_add_uint32(const NFTSetContext *nft_set_context, uint32_t element) {
-        int r;
-
-        assert(nft_set_context);
-        r = nft_set_element_op(true, nft_set_context, &element, sizeof(element));
-        if (r == 0)
-                log_debug("Added NFT family %s table %s set %s element %d",
-                          nfproto_to_string(nft_set_context->nfproto), nft_set_context->table, nft_set_context->set, element);
-        return r;
-}
-
-int nft_set_element_del_uint32(const NFTSetContext *nft_set_context, uint32_t element) {
-        int r;
-
-        assert(nft_set_context);
-        r = nft_set_element_op(false, nft_set_context, &element, sizeof(element));
-        if (r == 0)
-                log_debug("Deleted NFT family %s table %s set %s element %d",
-                          nfproto_to_string(nft_set_context->nfproto), nft_set_context->table, nft_set_context->set, element);
-        return r;
-}
-
-int nft_set_element_add_uint64(const NFTSetContext *nft_set_context, uint64_t element) {
-        int r;
-
-        assert(nft_set_context);
-        r = nft_set_element_op(true, nft_set_context, &element, sizeof(element));
-        if (r == 0)
-                log_debug("Added NFT family %s table %s set %s element %"PRIu64,
-                          nfproto_to_string(nft_set_context->nfproto), nft_set_context->table, nft_set_context->set, element);
-        return r;
-}
-
-int nft_set_element_del_uint64(const NFTSetContext *nft_set_context, uint64_t element) {
-        int r;
-
-        assert(nft_set_context);
-        r = nft_set_element_op(false, nft_set_context, &element, sizeof(element));
-        if (r == 0)
-                log_debug("Deleted NFT family %s table %s set %s element %"PRIu64,
-                          nfproto_to_string(nft_set_context->nfproto), nft_set_context->table, nft_set_context->set, element);
-        return r;
-}
-
-NFTSetContext* nft_set_context_free_many(NFTSetContext *s, size_t *n) {
-        assert(n);
-        assert(s || *n == 0);
-
-        for (size_t i = 0; i < *n; i++) {
-                free(s[i].table);
-                free(s[i].set);
-        }
-
-        free(s);
-        *n = 0;
-        return NULL;
-}
-
-int nft_set_context_add(NFTSetContext **s, size_t *n, int nfproto, const char *table, const char *set) {
-        _cleanup_free_ char *table_dup = NULL, *set_dup = NULL;
-        assert(s);
-        assert(n);
-
-        table_dup = strdup(table);
-        if (!table_dup)
-                return -ENOMEM;
-
-        set_dup = strdup(set);
-        if (!set_dup)
-                return -ENOMEM;
-
-        NFTSetContext *c;
-        c = reallocarray(*s, *n + 1, sizeof(NFTSetContext));
-        if (!c)
-                return -ENOMEM;
-
-        *s = c;
-
-        c[(*n) ++] = (NFTSetContext) {
-                .nfproto = nfproto,
-                .table = TAKE_PTR(table_dup),
-                .set = TAKE_PTR(set_dup),
-        };
-
-        return 0;
-}
-
-int config_parse_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                NFTSetContext **nft_set_context,
-                size_t *n) {
-        _cleanup_free_ char *family_str = NULL, *table = NULL, *set = NULL;
-        int nfproto, r;
-
-        assert(filename);
-        assert(lvalue);
-        assert(rvalue);
-        assert(nft_set_context);
-
-        if (isempty(rvalue)) {
-                nft_set_context_free_many(*nft_set_context, n);
-
-                return 0;
-        }
-
-        for (const char *p = rvalue;;) {
-                r = extract_many_words(&p, ":" WHITESPACE, EXTRACT_CUNESCAPE, &family_str, &table, &set, NULL);
-                if (r == -ENOMEM)
-                        return log_oom();
-                if (r == 0)
-                        return 0;
-                if (r != 3) {
-                        log_syntax(unit, LOG_WARNING, filename, line, r, "Failed to parse IPvxNFT set, ignoring: %s", rvalue);
-                        return 0;
-                }
-
-                nfproto = nfproto_from_string(family_str);
-                if (nfproto < 0) {
-                        log_syntax(unit, LOG_WARNING, filename, line, 0, "Unknown NFT protocol family, ignoring: %s", family_str);
-                        return 0;
-                }
-
-                if (nft_identifier_bad(table))
-                        return log_syntax(unit, LOG_WARNING, filename, line, 0, "Invalid table name %s, ignoring", table);
-
-                if (nft_identifier_bad(set))
-                        return log_syntax(unit, LOG_WARNING, filename, line, 0, "Invalid set name %s, ignoring", set);
-
-                NFTSetContext *c;
-                c = reallocarray(*nft_set_context, *n + 1, sizeof(NFTSetContext));
-                if (!c)
-                        return -ENOMEM;
-
-                *nft_set_context = c;
-
-                c[(*n) ++] = (NFTSetContext) {
-                        .nfproto = nfproto,
-                        .table = TAKE_PTR(table),
-                        .set = TAKE_PTR(set),
-                };
-        }
-
-        return 0;
-}
diff --git a/src/shared/firewall-util.h b/src/shared/firewall-util.h
index 3cea144ab9..7725a5e58d 100644
--- a/src/shared/firewall-util.h
+++ b/src/shared/firewall-util.h
@@ -23,49 +23,9 @@ int fw_add_masquerade(
 int fw_add_local_dnat(
                 FirewallContext **ctx,
                 bool add,
                 int af,
                 int protocol,
                 uint16_t local_port,
                 const union in_addr_union *remote,
                 uint16_t remote_port,
                 const union in_addr_union *previous_remote);
-
-struct NFTSetContext {
-        int nfproto;
-        char *table;
-        char *set;
-};
-typedef struct NFTSetContext NFTSetContext;
-
-int nft_set_context_add(NFTSetContext **s, size_t *n, int nfproto, const char *table, const char *set);
-NFTSetContext* nft_set_context_free_many(NFTSetContext *s, size_t *n);
-int config_parse_nft_set_context(
-                const char *unit,
-                const char *filename,
-                unsigned line,
-                const char *section,
-                unsigned section_line,
-                const char *lvalue,
-                int ltype,
-                const char *rvalue,
-                NFTSetContext **nft_set_context,
-                size_t *n);
-
-const char *nfproto_to_string(int i) _const_;
-int nfproto_from_string(const char *s) _pure_;
-
-int nft_set_element_add_in_addr(
-                const NFTSetContext *nft_set_context,
-                int af,
-                const union in_addr_union *address,
-                unsigned int prefixlen);
-int nft_set_element_del_in_addr(
-                const NFTSetContext *nft_set_context,
-                int af,
-                const union in_addr_union *address,
-                unsigned int prefixlen);
-
-int nft_set_element_add_uint32(const NFTSetContext *nft_set_context, uint32_t element);
-int nft_set_element_del_uint32(const NFTSetContext *nft_set_context, uint32_t element);
-int nft_set_element_add_uint64(const NFTSetContext *nft_set_context, uint64_t element);
-int nft_set_element_del_uint64(const NFTSetContext *nft_set_context, uint64_t element);
diff --git a/src/test/meson.build b/src/test/meson.build
index 081d79feee..cc590f4f3d 100644
--- a/src/test/meson.build
+++ b/src/test/meson.build
@@ -43,640 +43,637 @@ test_dlopen_c = files('test-dlopen.c')
 tests += [
         [files('test-device-nodes.c')],
 
         [files('test-ether-addr-util.c')],
 
         [files('test-engine.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-manager.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-emergency-action.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-chown-rec.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-dlopen-so.c')],
 
         [files('test-job-type.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-ns.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes, '', 'manual'],
 
         [files('test-loopback.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-dns-domain.c')],
 
         [files('test-boot-timestamps.c'),
          [], [], [], 'ENABLE_EFI'],
 
         [files('test-unit-file.c')],
 
         [files('test-unit-name.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-load-fragment.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-serialize.c')],
 
         [files('test-unit-serialize.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-utf8.c')],
 
         [files('test-kbd-util.c')],
 
         [files('test-blockdev-util.c')],
 
         [files('test-dev-setup.c')],
 
         [files('test-capability.c'),
          [],
          [libcap]],
 
         [files('test-async.c'),
          [], [], [], '', 'timeout=120'],
 
         [files('test-locale-util.c')],
 
         [files('test-copy.c')],
 
         [files('test-recurse-dir.c')],
 
         [files('test-compress.c'),
          [libshared,
           libbasic_compress]],
 
         [files('test-compress-benchmark.c'),
          [libshared,
           libbasic_compress],
          [],
          [], '', 'timeout=90'],
 
         [files('test-data-fd-util.c')],
 
         [files('test-static-destruct.c')],
 
         [files('test-sigbus.c')],
 
         [files('test-condition.c')],
 
         [files('test-fdset.c')],
 
         [files('test-fstab-util.c')],
 
         [files('test-random-util.c'),
          [],
          [libm],
          [], '', 'timeout=120'],
 
         [files('test-format-table.c')],
 
         [files('test-format-util.c')],
 
         [files('test-ratelimit.c')],
 
         [files('test-util.c')],
 
         [files('test-macro.c')],
 
         [files('test-mkdir.c')],
 
         [files('test-json.c'),
          [],
          [libm]],
 
         [files('test-modhex.c')],
 
         [files('test-libmount.c'),
          [],
          [threads,
           libmount]],
 
         [files('test-mount-util.c')],
 
         [files('test-mountpoint-util.c')],
 
         [files('test-exec-util.c')],
 
         [files('test-hexdecoct.c')],
 
         [files('test-alloc-util.c')],
 
         [files('test-xattr-util.c')],
 
         [files('test-io-util.c')],
 
         [files('test-glob-util.c')],
 
         [files('test-fs-util.c')],
 
         [files('test-install-file.c')],
 
         [files('test-umask-util.c')],
 
         [files('test-proc-cmdline.c')],
 
         [files('test-fd-util.c'),
          [],
          [libseccomp]],
 
         [files('test-web-util.c')],
 
         [files('test-cpu-set-util.c')],
 
         [files('test-stat-util.c')],
 
         [files('test-devnum-util.c')],
 
         [files('test-os-util.c')],
 
         [files('test-libcrypt-util.c'),
          [], [libcrypt], [], '', 'timeout=120'],
 
         [files('test-escape.c')],
 
         [files('test-exit-status.c')],
 
         [files('test-specifier.c')],
 
         [files('test-string-util.c')],
 
         [files('test-extract-word.c')],
 
         [files('test-parse-argument.c')],
 
         [files('test-parse-helpers.c')],
 
         [files('test-parse-util.c'),
          [],
          [libm]],
 
         [files('test-sysctl-util.c')],
 
         [files('test-import-util.c')],
 
         [files('test-uid-alloc-range.c')],
 
         [files('test-user-util.c')],
 
         [files('test-hostname-setup.c')],
 
         [files('test-hostname-util.c')],
 
         [files('test-process-util.c')],
 
         [files('test-terminal-util.c')],
 
         [files('test-path-lookup.c')],
 
         [files('test-pretty-print.c')],
 
         [files('test-uid-range.c')],
 
         [files('test-cap-list.c') +
          generated_gperf_headers,
          [],
          [libcap]],
 
         [files('test-socket-util.c')],
 
         [files('test-socket-netlink.c')],
 
         [files('test-in-addr-util.c')],
 
         [files('test-in-addr-prefix-util.c')],
 
         [files('test-barrier.c')],
 
         [files('test-tmpfiles.c')],
 
         [files('test-namespace.c'),
          [libcore,
           libshared],
          [threads,
           libblkid],
          core_includes],
 
         [files('test-verbs.c')],
 
         [files('test-install-root.c')],
 
         [files('test-acl-util.c'),
          [], [], [], 'HAVE_ACL'],
 
         [files('test-seccomp.c'),
          [],
          [libseccomp],
          [], 'HAVE_SECCOMP'],
 
         [files('test-rlimit-util.c')],
 
         [files('test-ask-password-api.c'),
          [], [], [], '', 'manual'],
 
         [files('test-signal-util.c')],
 
         [files('test-loop-block.c'),
          [libcore,
           libshared],
          [threads,
           libblkid],
          core_includes, '', '', [], false],
 
         [files('test-selinux.c')],
 
         [files('test-sizeof.c'),
          [libbasic]],
 
         [files('test-bpf-devices.c'),
          [libcore,
           libshared],
          [libmount,
           threads,
           librt,
           libseccomp,
           libselinux,
           libblkid],
          core_includes],
 
         [files('test-bpf-firewall.c'),
          [libcore,
           libshared],
          [libmount,
           threads,
           librt,
           libseccomp,
           libselinux,
           libblkid],
          core_includes],
 
         [files('test-bpf-foreign-programs.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-bpf-lsm.c'),
          [libcore,
           libshared],
          [libmount,
           threads,
           librt,
           libseccomp,
           libselinux,
           libblkid],
          core_includes],
 
         [files('test-watch-pid.c'),
          [libcore,
           libshared],
          [libmount,
           threads,
           librt,
           libseccomp,
           libselinux,
           libblkid],
          core_includes],
 
         [files('test-hashmap.c',
                'test-hashmap-plain.c') +
          [test_hashmap_ordered_c],
          [], [], [], '', 'timeout=180'],
 
         [files('test-set.c')],
 
         [files('test-ordered-set.c')],
 
         [files('test-set-disable-mempool.c'),
          [],
          [threads]],
 
         [files('test-hash-funcs.c')],
 
         [files('test-bitmap.c')],
 
         [files('test-xml.c')],
 
         [files('test-list.c')],
 
         [files('test-procfs-util.c')],
 
         [files('test-unaligned.c')],
 
         [files('test-tables.c'),
          [libcore,
           libjournal_core,
           libudevd_core,
           libshared],
          [threads,
           libseccomp,
           libmount,
           libxz,
           liblz4,
           libblkid,
           libselinux],
          [core_includes, journal_includes, udev_includes]],
 
         [files('test-prioq.c')],
 
         [files('test-fileio.c')],
 
         [files('test-time-util.c')],
 
         [files('test-clock.c')],
 
         [files('test-tmpfile-util.c')],
 
         [files('test-architecture.c')],
 
         [files('test-gpt.c')],
 
         [files('test-log.c')],
 
         [files('test-ipcrm.c'),
          [], [], [], '', 'unsafe'],
 
         [files('test-btrfs.c'),
          [], [], [], '', 'manual'],
 
         [files('test-firewall-util.c')],
 
         [files('test-net-naming-scheme.c')],
 
         [files('test-netlink-manual.c'),
          [],
          [libkmod],
          [], 'HAVE_KMOD', 'manual'],
 
         [files('test-ellipsize.c')],
 
         [files('test-date.c')],
 
         [files('test-sbat.c'),
          [], [], [], 'HAVE_GNU_EFI', '',
          ['-I@0@'.format(efi_config_h_dir)]],
 
         [files('test-sleep.c')],
 
         [files('test-tpm2.c')],
 
         [files('test-replace-var.c')],
 
         [files('test-calendarspec.c')],
 
         [files('test-strip-tab-ansi.c')],
 
         [files('test-coredump-util.c')],
 
         [files('test-daemon.c')],
 
         [files('test-cgroup.c')],
 
         [files('test-cgroup-cpu.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-cgroup-unit-default.c'),
          [libcore,
           libshared],
          [],
          core_includes],
 
         [files('test-cgroup-mask.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-varlink.c'),
          [],
          [threads]],
 
         [files('test-cgroup-util.c')],
 
         [files('test-cgroup-setup.c')],
 
         [files('test-env-file.c')],
 
         [files('test-env-util.c')],
 
         [files('test-strbuf.c')],
 
         [files('test-bootspec.c')],
 
         [files('test-strv.c')],
 
         [files('test-path-util.c')],
 
         [files('test-rm-rf.c')],
 
         [files('test-chase-symlinks.c'),
          [], [], [], '', 'manual'],
 
         [files('test-path.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes, '', 'timeout=120'],
 
         [files('test-execute.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes, '', 'timeout=360'],
 
         [files('test-siphash24.c')],
 
         [files('test-strxcpyx.c')],
 
         [files('test-install.c'),
          [libcore,
           libshared],
          [],
          core_includes, '', 'manual'],
 
         [files('test-watchdog.c'),
          [], [], [], '', 'unsafe'],
 
         [files('test-sched-prio.c'),
          [libcore,
           libshared],
          [threads,
           librt,
           libseccomp,
           libselinux,
           libmount,
           libblkid],
          core_includes],
 
         [files('test-conf-files.c')],
 
         [files('test-conf-parser.c')],
 
         [files('test-af-list.c') +
          generated_gperf_headers],
 
         [files('test-arphrd-util.c') +
          generated_gperf_headers],
 
         [files('test-errno-list.c') +
          generated_gperf_headers],
 
         [files('test-ip-protocol-list.c') +
          shared_generated_gperf_headers],
 
         [files('test-journal-importer.c')],
 
         [files('test-utmp.c')],
 
         [files('test-udev.c'),
          [libudevd_core,
           libshared],
          [threads,
           librt,
           libblkid,
           libkmod,
           libacl,
           libselinux],
          udev_includes, '', 'manual'],
 
         [files('test-udev-util.c')],
 
         [files('test-id128.c')],
 
         [files('test-cryptolib.c'),
          [libshared],
          [lib_openssl_or_gcrypt],
          [], 'HAVE_OPENSSL_OR_GCRYPT'],
 
         [files('test-nss-hosts.c',
                'nss-test-util.c',
                'nss-test-util.h'),
          [],
          [libdl],
          [], 'ENABLE_NSS', 'timeout=120'],
 
         [files('test-nss-users.c',
                'nss-test-util.c',
                'nss-test-util.h'),
          [],
          [libdl],
          [], 'ENABLE_NSS'],
 
         [files('test-bus-util.c')],
 
         [files('test-percent-util.c')],
 
         [files('test-sd-hwdb.c')],
 
         [files('test-sd-path.c')],
 
         [files('test-local-addresses.c')],
 
         [files('test-psi-util.c')],
 
         [files('test-qrcode-util.c'),
          [],
          [libdl]],
 
         [files('test-nscd-flush.c'),
          [], [], [], 'ENABLE_NSCD', 'manual'],
 
         [files('test-hmac.c')],
 
         [files('test-sha256.c')],
-
-        [files('test-nft-set.c'),
-         [], [], [], '', 'manual'],
 ]
 
 ############################################################
 
 # define some tests here, because the link_with deps were not defined earlier
diff --git a/src/test/test-nft-set.c b/src/test/test-nft-set.c
deleted file mode 100644
index df5322b4b2..0000000000
--- a/src/test/test-nft-set.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: LGPL-2.1-or-later */
-
-#include <assert.h>
-#include <unistd.h>
-
-#include "firewall-util.h"
-#include "in-addr-util.h"
-#include "log.h"
-#include "parse-util.h"
-#include "string-util.h"
-#include "tests.h"
-
-int main(int argc, char **argv) {
-        int r;
-
-        assert_se(argc == 7);
-
-        test_setup_logging(LOG_DEBUG);
-
-        if (getuid() != 0)
-                return log_tests_skipped("not root");
-
-        int nfproto;
-        nfproto = nfproto_from_string(argv[2]);
-        assert_se(nfproto > 0);
-
-        const NFTSetContext nft_set_context = {
-                .nfproto = nfproto,
-                .table = argv[3],
-                .set = argv[4],
-        };
-
-        if (streq(argv[5], "uint32")) {
-                uint32_t element;
-                r = safe_atou32(argv[6], &element);
-                assert_se(r == 0);
-
-                if (streq(argv[1], "add"))
-                        r = nft_set_element_add_uint32(&nft_set_context, element);
-                else
-                        r = nft_set_element_del_uint32(&nft_set_context, element);
-                assert_se(r == 0);
-        } else if (streq(argv[5], "uint64")) {
-                uint64_t element;
-                r = safe_atou64(argv[6], &element);
-                assert_se(r == 0);
-
-                if (streq(argv[1], "add"))
-                        r = nft_set_element_add_uint64(&nft_set_context, element);
-                else
-                        r = nft_set_element_del_uint64(&nft_set_context, element);
-                assert_se(r == 0);
-        } else {
-                union in_addr_union addr;
-                int af;
-                unsigned char prefixlen;
-
-                r = in_addr_prefix_from_string_auto(argv[6], &af, &addr, &prefixlen);
-                assert_se(r == 0);
-
-                if (streq(argv[1], "add"))
-                        r = nft_set_element_add_in_addr(&nft_set_context, af, &addr, prefixlen);
-                else
-                        r = nft_set_element_del_in_addr(&nft_set_context, af, &addr, prefixlen);
-                assert_se(r == 0);
-        }
-
-        return 0;
-}
diff --git a/test/fuzz/fuzz-network-parser/directives b/test/fuzz/fuzz-network-parser/directives
index 803f0d1969..0b850cdfcf 100644
--- a/test/fuzz/fuzz-network-parser/directives
+++ b/test/fuzz/fuzz-network-parser/directives
@@ -132,7 +132,6 @@ RouteMTUBytes=
 FallbackLeaseLifetimeSec=
 Use6RD=
 NetLabel=
-NFTSet=
 [DHCPv6]
 UseAddress=
 UseDelegatedPrefix=
@@ -155,7 +154,6 @@ IAID=
 DUIDType=
 DUIDRawData=
 NetLabel=
-NFTSet=
 [DHCPv6PrefixDelegation]
 SubnetId=
 Announce=
@@ -173,7 +171,6 @@ ManageTemporaryAddress=
 Token=
 RouteMetric=
 NetLabel=
-NFTSet=
 [Route]
 Destination=
 Protocol=
@@ -260,8 +257,6 @@ DHCPv6PrefixDelegation=
 DHCPPrefixDelegation=
 BatmanAdvanced=
 IPoIB=
-IPv4NFTSet=
-IPv6NFTSet=
 [IPv6Prefix]
 Prefix=
 OnLink=
@@ -353,7 +348,6 @@ Managed=
 OtherInformation=
 UplinkInterface=
 NetLabel=
-NFTSet=
 [IPv6PrefixDelegation]
 RouterPreference=
 DNSLifetimeSec=
diff --git a/test/fuzz/fuzz-unit-file/directives.mount b/test/fuzz/fuzz-unit-file/directives.mount
index 16d2138a04..0a44328e5c 100644
--- a/test/fuzz/fuzz-unit-file/directives.mount
+++ b/test/fuzz/fuzz-unit-file/directives.mount
@@ -28,7 +28,6 @@ Capabilities=
 CapabilityBoundingSet=
 ConfigurationDirectory=
 ConfigurationDirectoryMode=
-ControlGroupNFTSet=
 CoredumpFilter=
 DefaultMemoryLow=
 DefaultMemoryMin=
@@ -38,7 +37,6 @@ DevicePolicy=
 DirectoryMode=
 DisableControllers=
 DynamicUser=
-DynamicUserNFTSet=
 Environment=
 EnvironmentFile=
 ExecPaths=
diff --git a/test/fuzz/fuzz-unit-file/directives.scope b/test/fuzz/fuzz-unit-file/directives.scope
index c4d579065a..4552d0b403 100644
--- a/test/fuzz/fuzz-unit-file/directives.scope
+++ b/test/fuzz/fuzz-unit-file/directives.scope
@@ -8,7 +8,6 @@ BlockIODeviceWeight=
 BlockIOReadBandwidth=
 BlockIOWeight=
 BlockIOWriteBandwidth=
-ControlGroupNFTSet=
 CPUAccounting=
 CPUQuota=
 CPUQuotaPeriodSec=
diff --git a/test/fuzz/fuzz-unit-file/directives.service b/test/fuzz/fuzz-unit-file/directives.service
index 511c2f6b4f..3c33d947fe 100644
--- a/test/fuzz/fuzz-unit-file/directives.service
+++ b/test/fuzz/fuzz-unit-file/directives.service
@@ -72,7 +72,6 @@ ConditionSecurity=
 ConditionUser=
 ConditionVirtualization=
 Conflicts=
-ControlGroupNFTSet=
 DefaultDependencies=
 Description=
 Documentation=
@@ -160,7 +159,6 @@ DeviceAllow=
 DevicePolicy=
 DisableControllers=
 DynamicUser=
-DynamicUserNFTSet=
 Environment=
 EnvironmentFile=
 ExecCondition=
diff --git a/test/fuzz/fuzz-unit-file/directives.slice b/test/fuzz/fuzz-unit-file/directives.slice
index 749f1795e3..ab77070c5e 100644
--- a/test/fuzz/fuzz-unit-file/directives.slice
+++ b/test/fuzz/fuzz-unit-file/directives.slice
@@ -8,7 +8,6 @@ BlockIODeviceWeight=
 BlockIOReadBandwidth=
 BlockIOWeight=
 BlockIOWriteBandwidth=
-ControlGroupNFTSet=
 CPUAccounting=
 CPUQuota=
 CPUQuotaPeriodSec=
diff --git a/test/fuzz/fuzz-unit-file/directives.socket b/test/fuzz/fuzz-unit-file/directives.socket
index b9ad5e5f84..90358fc11a 100644
--- a/test/fuzz/fuzz-unit-file/directives.socket
+++ b/test/fuzz/fuzz-unit-file/directives.socket
@@ -33,7 +33,6 @@ Capabilities=
 CapabilityBoundingSet=
 ConfigurationDirectory=
 ConfigurationDirectoryMode=
-ControlGroupNFTSet=
 CoredumpFilter=
 DefaultMemoryLow=
 DefaultMemoryMin=
@@ -44,7 +43,6 @@ DevicePolicy=
 DirectoryMode=
 DisableControllers=
 DynamicUser=
-DynamicUserNFTSet=
 Environment=
 EnvironmentFile=
 ExecPaths=
diff --git a/test/fuzz/fuzz-unit-file/directives.swap b/test/fuzz/fuzz-unit-file/directives.swap
index 4721edce4b..5d057fa630 100644
--- a/test/fuzz/fuzz-unit-file/directives.swap
+++ b/test/fuzz/fuzz-unit-file/directives.swap
@@ -28,7 +28,6 @@ Capabilities=
 CapabilityBoundingSet=
 ConfigurationDirectory=
 ConfigurationDirectoryMode=
-ControlGroupNFTSet=
 CoredumpFilter=
 DefaultMemoryLow=
 DefaultMemoryMin=
@@ -37,7 +36,6 @@ DeviceAllow=
 DevicePolicy=
 DisableControllers=
 DynamicUser=
-DynamicUserNFTSet=
 Environment=
 EnvironmentFile=
 ExecPaths=
