commit e515daaa2259657319eb9f07181d02af24b4e7fe
Author: Marti Maria <marti.maria@littlecms.com>
Date:   Wed Aug 31 23:28:59 2022 +0200

    An old function was returning a wrong value
    
    It makes no sense that cmsChannelsOf() returns 3 when colorspace is bugus. Added a new function that returns -1 instead. Will document that in 2.15.
    It is in the API now, but not in docs.

diff --git a/Projects/VC2022/testbed/testbed.vcxproj b/Projects/VC2022/testbed/testbed.vcxproj
index c2b51ba..05cb6a6 100644
--- a/Projects/VC2022/testbed/testbed.vcxproj
+++ b/Projects/VC2022/testbed/testbed.vcxproj
@@ -1,296 +1,297 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|ARM64">
       <Configuration>Debug</Configuration>
       <Platform>ARM64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|x64">
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Release|ARM64">
       <Configuration>Release</Configuration>
       <Platform>ARM64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Release|Win32">
       <Configuration>Release</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Release|x64">
       <Configuration>Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{928A3A2B-46EF-4279-959C-513B3652FF0E}</ProjectGuid>
     <RootNamespace>testbed</RootNamespace>
     <Keyword>Win32Proj</Keyword>
     <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v143</PlatformToolset>
     <EnableASAN>true</EnableASAN>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <CharacterSet>Unicode</CharacterSet>
     <PlatformToolset>v143</PlatformToolset>
     <EnableASAN>false</EnableASAN>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup>
     <_ProjectFileVersion>10.0.21006.1</_ProjectFileVersion>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)_$(Platform)\</IntDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">$(Configuration)_$(Platform)\</IntDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)_$(Platform)\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">true</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\testbed\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\..\..\testbed\</OutDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)_$(Platform)\</IntDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">$(Configuration)_$(Platform)\</IntDir>
     <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)_$(Platform)\</IntDir>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">false</LinkIncremental>
     <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
     <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" />
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\testbed\</OutDir>
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\..\..\testbed\</OutDir>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MinimalRebuild>true</MinimalRebuild>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <TargetMachine>MachineX86</TargetMachine>
       <Profile>false</Profile>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <MinimalRebuild>true</MinimalRebuild>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <Profile>false</Profile>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
       <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <Profile>false</Profile>
     </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
       <Optimization>Full</Optimization>
       <IntrinsicFunctions>true</IntrinsicFunctions>
       <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
       <OmitFramePointers>true</OmitFramePointers>
       <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <CallingConvention>Cdecl</CallingConvention>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <BrowseInformation>false</BrowseInformation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <OptimizeReferences>true</OptimizeReferences>
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
       <TargetMachine>MachineX86</TargetMachine>
       <Profile>false</Profile>
     </Link>
     <Bscmake>
       <PreserveSbr>true</PreserveSbr>
     </Bscmake>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
     <ClCompile>
       <Optimization>Full</Optimization>
       <IntrinsicFunctions>true</IntrinsicFunctions>
       <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
       <OmitFramePointers>true</OmitFramePointers>
       <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <CallingConvention>Cdecl</CallingConvention>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
       <BrowseInformation>false</BrowseInformation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <OptimizeReferences>true</OptimizeReferences>
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
       <Profile>false</Profile>
     </Link>
     <Bscmake>
       <PreserveSbr>true</PreserveSbr>
     </Bscmake>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
       <Optimization>Full</Optimization>
       <IntrinsicFunctions>true</IntrinsicFunctions>
       <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
       <OmitFramePointers>true</OmitFramePointers>
       <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
       <AdditionalIncludeDirectories>../../../include;../../../src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
       <PrecompiledHeader>
       </PrecompiledHeader>
       <WarningLevel>Level3</WarningLevel>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
       <CallingConvention>Cdecl</CallingConvention>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <SubSystem>Console</SubSystem>
       <OptimizeReferences>true</OptimizeReferences>
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
       <Profile>false</Profile>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="..\..\..\testbed\fuzzer.c" />
     <ClCompile Include="..\..\..\testbed\testcms2.c" />
     <ClCompile Include="..\..\..\testbed\testplugin.c" />
     <ClCompile Include="..\..\..\testbed\zoo_icc.c" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\lcms2_static\lcms2_static.vcxproj">
       <Project>{71dede59-3f1e-486b-a899-4283000f76b5}</Project>
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
 </Project>
\ No newline at end of file
diff --git a/Projects/VC2022/testbed/testbed.vcxproj.filters b/Projects/VC2022/testbed/testbed.vcxproj.filters
index 993ee15..ece88ca 100644
--- a/Projects/VC2022/testbed/testbed.vcxproj.filters
+++ b/Projects/VC2022/testbed/testbed.vcxproj.filters
@@ -1,28 +1,31 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
     <Filter Include="Header Files">
       <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
       <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
     </Filter>
     <Filter Include="Resource Files">
       <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
       <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
     </Filter>
     <Filter Include="Source Files">
       <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
       <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
     </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\..\..\testbed\testcms2.c">
       <Filter>Source Files</Filter>
     </ClCompile>
     <ClCompile Include="..\..\..\testbed\testplugin.c">
       <Filter>Source Files</Filter>
     </ClCompile>
     <ClCompile Include="..\..\..\testbed\zoo_icc.c">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\..\testbed\fuzzer.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/include/lcms2.h b/include/lcms2.h
index 331a16f..b7dc886 100644
--- a/include/lcms2.h
+++ b/include/lcms2.h
@@ -1532,8 +1532,12 @@ CMSAPI cmsBool           CMSEXPORT cmsIsCLUT(cmsHPROFILE hProfile, cmsUInt32Numb
 CMSAPI cmsColorSpaceSignature   CMSEXPORT _cmsICCcolorSpace(int OurNotation);
 CMSAPI int                      CMSEXPORT _cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace);
 
+// Deprecated, use cmsChannelsOfColorSpace instead
 CMSAPI cmsUInt32Number   CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace);
 
+// Get number of channels of color space or -1 if color space is not listed/supported
+CMSAPI cmsInt32Number CMSEXPORT cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace);
+
 // Build a suitable formatter for the colorspace of this profile. nBytes=1 means 8 bits, nBytes=2 means 16 bits. 
 CMSAPI cmsUInt32Number   CMSEXPORT cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat);
 CMSAPI cmsUInt32Number   CMSEXPORT cmsFormatterForPCSOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat);
diff --git a/src/cmscnvrt.c b/src/cmscnvrt.c
index abac021..50e5a1e 100644
--- a/src/cmscnvrt.c
+++ b/src/cmscnvrt.c
@@ -511,132 +511,132 @@ static
 cmsPipeline* DefaultICCintents(cmsContext       ContextID,
                                cmsUInt32Number  nProfiles,
                                cmsUInt32Number  TheIntents[],
                                cmsHPROFILE      hProfiles[],
                                cmsBool          BPC[],
                                cmsFloat64Number AdaptationStates[],
                                cmsUInt32Number  dwFlags)
 {
     cmsPipeline* Lut = NULL;
     cmsPipeline* Result;
     cmsHPROFILE hProfile;
     cmsMAT3 m;
     cmsVEC3 off;
     cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut = cmsSigLabData, CurrentColorSpace;
     cmsProfileClassSignature ClassSig;
     cmsUInt32Number  i, Intent;
 
     // For safety
     if (nProfiles == 0) return NULL;
 
     // Allocate an empty LUT for holding the result. 0 as channel count means 'undefined'
     Result = cmsPipelineAlloc(ContextID, 0, 0);
     if (Result == NULL) return NULL;
 
     CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);
 
     for (i=0; i < nProfiles; i++) {
 
         cmsBool  lIsDeviceLink, lIsInput;
 
         hProfile      = hProfiles[i];
         ClassSig      = cmsGetDeviceClass(hProfile);
         lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );
 
         // First profile is used as input unless devicelink or abstract
         if ((i == 0) && !lIsDeviceLink) {
             lIsInput = TRUE;
         }
         else {
           // Else use profile in the input direction if current space is not PCS
         lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&
                         (CurrentColorSpace != cmsSigLabData);
         }
 
         Intent        = TheIntents[i];
 
         if (lIsInput || lIsDeviceLink) {
 
             ColorSpaceIn    = cmsGetColorSpace(hProfile);
             ColorSpaceOut   = cmsGetPCS(hProfile);
         }
         else {
 
             ColorSpaceIn    = cmsGetPCS(hProfile);
             ColorSpaceOut   = cmsGetColorSpace(hProfile);
         }
 
         if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {
 
             cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "ColorSpace mismatch");
             goto Error;
         }
 
         // If devicelink is found, then no custom intent is allowed and we can
         // read the LUT to be applied. Settings don't apply here.
         if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) {
 
             // Get the involved LUT from the profile
             Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
             if (Lut == NULL) goto Error;
 
             // What about abstract profiles?
              if (ClassSig == cmsSigAbstractClass && i > 0) {
                 if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
              }
              else {
                 _cmsMAT3identity(&m);
                 _cmsVEC3init(&off, 0, 0, 0);
              }
 
 
             if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
 
         }
         else {
 
             if (lIsInput) {
                 // Input direction means non-pcs connection, so proceed like devicelinks
                 Lut = _cmsReadInputLUT(hProfile, Intent);
                 if (Lut == NULL) goto Error;
             }
             else {
 
                 // Output direction means PCS connection. Intent may apply here
                 Lut = _cmsReadOutputLUT(hProfile, Intent);
                 if (Lut == NULL) goto Error;
 
 
                 if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
                 if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
 
             }
         }
 
         // Concatenate to the output LUT
         if (!cmsPipelineCat(Result, Lut))
             goto Error;
 
         cmsPipelineFree(Lut);
         Lut = NULL;
 
         // Update current space
         CurrentColorSpace = ColorSpaceOut;
     }
 
     // Check for non-negatives clip
     if (dwFlags & cmsFLAGS_NONEGATIVES) {
 
            if (ColorSpaceOut == cmsSigGrayData ||
                   ColorSpaceOut == cmsSigRgbData ||
                   ColorSpaceOut == cmsSigCmykData) {
 
-                  cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOf(ColorSpaceOut));
+                  cmsStage* clip = _cmsStageClipNegatives(Result->ContextID, cmsChannelsOfColorSpace(ColorSpaceOut));
                   if (clip == NULL) goto Error;
 
                   if (!cmsPipelineInsertStage(Result, cmsAT_END, clip))
                          goto Error;
            }
 
     }
 
     return Result;
diff --git a/src/cmsgmt.c b/src/cmsgmt.c
index ddcfb52..e6c27c1 100644
--- a/src/cmsgmt.c
+++ b/src/cmsgmt.c
@@ -287,127 +287,127 @@ int GamutSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Nu
 cmsPipeline* _cmsCreateGamutCheckPipeline(cmsContext ContextID,
                                           cmsHPROFILE hProfiles[],
                                           cmsBool  BPC[],
                                           cmsUInt32Number Intents[],
                                           cmsFloat64Number AdaptationStates[],
                                           cmsUInt32Number nGamutPCSposition,
                                           cmsHPROFILE hGamut)
 {
     cmsHPROFILE hLab;
     cmsPipeline* Gamut;
     cmsStage* CLUT;
     cmsUInt32Number dwFormat;
     GAMUTCHAIN Chain;
-    cmsUInt32Number nChannels, nGridpoints;
+    cmsUInt32Number nGridpoints;
+    cmsInt32Number nChannels;
     cmsColorSpaceSignature ColorSpace;
     cmsUInt32Number i;
     cmsHPROFILE ProfileList[256];
     cmsBool     BPCList[256];
     cmsFloat64Number AdaptationList[256];
     cmsUInt32Number IntentList[256];
 
     memset(&Chain, 0, sizeof(GAMUTCHAIN));
 
 
     if (nGamutPCSposition <= 0 || nGamutPCSposition > 255) {
         cmsSignalError(ContextID, cmsERROR_RANGE, "Wrong position of PCS. 1..255 expected, %d found.", nGamutPCSposition);
         return NULL;
     }
 
     hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
     if (hLab == NULL) return NULL;
 
 
     // The figure of merit. On matrix-shaper profiles, should be almost zero as
     // the conversion is pretty exact. On LUT based profiles, different resolutions
     // of input and output CLUT may result in differences.
 
     if (cmsIsMatrixShaper(hGamut)) {
 
         Chain.Threshold = 1.0;
     }
     else {
         Chain.Threshold = ERR_THRESHOLD;
     }
 
 
     // Create a copy of parameters
     for (i=0; i < nGamutPCSposition; i++) {
         ProfileList[i]    = hProfiles[i];
         BPCList[i]        = BPC[i];
         AdaptationList[i] = AdaptationStates[i];
         IntentList[i]     = Intents[i];
     }
 
     // Fill Lab identity
     ProfileList[nGamutPCSposition] = hLab;
     BPCList[nGamutPCSposition] = 0;
     AdaptationList[nGamutPCSposition] = 1.0;
     IntentList[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
 
 
     ColorSpace  = cmsGetColorSpace(hGamut);
-
-    nChannels   = cmsChannelsOf(ColorSpace);
+    nChannels   = cmsChannelsOfColorSpace(ColorSpace);
     nGridpoints = _cmsReasonableGridpointsByColorspace(ColorSpace, cmsFLAGS_HIGHRESPRECALC);
     dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
 
     // 16 bits to Lab double
     Chain.hInput = cmsCreateExtendedTransform(ContextID,
         nGamutPCSposition + 1,
         ProfileList,
         BPCList,
         IntentList,
         AdaptationList,
         NULL, 0,
         dwFormat, TYPE_Lab_DBL,
         cmsFLAGS_NOCACHE);
 
 
     // Does create the forward step. Lab double to device
     dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
     Chain.hForward = cmsCreateTransformTHR(ContextID,
         hLab, TYPE_Lab_DBL,
         hGamut, dwFormat,
         INTENT_RELATIVE_COLORIMETRIC,
         cmsFLAGS_NOCACHE);
 
     // Does create the backwards step
     Chain.hReverse = cmsCreateTransformTHR(ContextID, hGamut, dwFormat,
         hLab, TYPE_Lab_DBL,
         INTENT_RELATIVE_COLORIMETRIC,
         cmsFLAGS_NOCACHE);
 
 
     // All ok?
     if (Chain.hInput && Chain.hForward && Chain.hReverse) {
 
         // Go on, try to compute gamut LUT from PCS. This consist on a single channel containing
         // dE when doing a transform back and forth on the colorimetric intent.
 
         Gamut = cmsPipelineAlloc(ContextID, 3, 1);
         if (Gamut != NULL) {
 
             CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
             if (!cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT)) {
                 cmsPipelineFree(Gamut);
                 Gamut = NULL;
             } 
             else {
                 cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
             }
         }
     }
     else
         Gamut = NULL;   // Didn't work...
 
     // Free all needed stuff.
     if (Chain.hInput)   cmsDeleteTransform(Chain.hInput);
     if (Chain.hForward) cmsDeleteTransform(Chain.hForward);
     if (Chain.hReverse) cmsDeleteTransform(Chain.hReverse);
     if (hLab) cmsCloseProfile(hLab);
 
     // And return computed hull
     return Gamut;
 }
 
 // Total Area Coverage estimation ----------------------------------------------------------------
diff --git a/src/cmspack.c b/src/cmspack.c
index 955687c..5ab4525 100644
--- a/src/cmspack.c
+++ b/src/cmspack.c
@@ -3830,14 +3830,14 @@ cmsBool  _cmsFormatterIs8bit(cmsUInt32Number Type)
 // Build a suitable formatter for the colorspace of this profile
 cmsUInt32Number CMSEXPORT cmsFormatterForColorspaceOfProfile(cmsHPROFILE hProfile, cmsUInt32Number nBytes, cmsBool lIsFloat)
 {
 
     cmsColorSpaceSignature ColorSpace      = cmsGetColorSpace(hProfile);
     cmsUInt32Number        ColorSpaceBits  = (cmsUInt32Number) _cmsLCMScolorSpace(ColorSpace);
-    cmsUInt32Number        nOutputChans    = cmsChannelsOf(ColorSpace);
+    cmsInt32Number         nOutputChans    = cmsChannelsOfColorSpace(ColorSpace);
     cmsUInt32Number        Float           = lIsFloat ? 1U : 0;
 
     // Create a fake formatter for result
     return FLOAT_SH(Float) | COLORSPACE_SH(ColorSpaceBits) | BYTES_SH(nBytes) | CHANNELS_SH(nOutputChans);
 }
 
 // Build a suitable formatter for the colorspace of this profile
diff --git a/src/cmspcs.c b/src/cmspcs.c
index 3d6323a..a0f1952 100644
--- a/src/cmspcs.c
+++ b/src/cmspcs.c
@@ -874,67 +874,77 @@ int CMSEXPORT _cmsLCMScolorSpace(cmsColorSpaceSignature ProfileSpace)
 }
 
 
-cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)
+cmsInt32Number CMSEXPORT cmsChannelsOfColorSpace(cmsColorSpaceSignature ColorSpace)
 {
     switch (ColorSpace) {
 
     case cmsSigMCH1Data:
     case cmsSig1colorData:
     case cmsSigGrayData: return 1;
 
     case cmsSigMCH2Data:
     case cmsSig2colorData:  return 2;
 
     case cmsSigXYZData:
     case cmsSigLabData:
     case cmsSigLuvData:
     case cmsSigYCbCrData:
     case cmsSigYxyData:
     case cmsSigRgbData:
     case cmsSigHsvData:
     case cmsSigHlsData:
     case cmsSigCmyData:
     case cmsSigMCH3Data:
     case cmsSig3colorData:  return 3;
 
     case cmsSigLuvKData:
     case cmsSigCmykData:
     case cmsSigMCH4Data:
     case cmsSig4colorData:  return 4;
 
     case cmsSigMCH5Data:
     case cmsSig5colorData:  return 5;
 
     case cmsSigMCH6Data:
     case cmsSig6colorData:  return 6;
 
     case cmsSigMCH7Data:
     case cmsSig7colorData:  return  7;
 
     case cmsSigMCH8Data:
     case cmsSig8colorData:  return  8;
 
     case cmsSigMCH9Data:
     case cmsSig9colorData:  return  9;
 
     case cmsSigMCHAData:
     case cmsSig10colorData: return 10;
 
     case cmsSigMCHBData:
     case cmsSig11colorData: return 11;
 
     case cmsSigMCHCData:
     case cmsSig12colorData: return 12;
 
     case cmsSigMCHDData:
     case cmsSig13colorData: return 13;
 
     case cmsSigMCHEData:
     case cmsSig14colorData: return 14;
 
     case cmsSigMCHFData:
     case cmsSig15colorData: return 15;
 
-    default: return 3;
+    default: return -1;
     }
 }
+
+/**
+* DEPRECATED: Provided for compatibility only
+*/
+cmsUInt32Number CMSEXPORT cmsChannelsOf(cmsColorSpaceSignature ColorSpace)
+{
+    int n = cmsChannelsOfColorSpace(ColorSpace);
+    if (n < 0) return 3;
+    return (cmsUInt32Number)n;
+}
\ No newline at end of file
diff --git a/src/cmsvirt.c b/src/cmsvirt.c
index 4900a83..b8ef607 100644
--- a/src/cmsvirt.c
+++ b/src/cmsvirt.c
@@ -288,42 +288,42 @@ cmsHPROFILE CMSEXPORT cmsCreateGrayProfile(const cmsCIExyY* WhitePoint,
 cmsHPROFILE CMSEXPORT cmsCreateLinearizationDeviceLinkTHR(cmsContext ContextID,
                                                           cmsColorSpaceSignature ColorSpace,
                                                           cmsToneCurve* const TransferFunctions[])
 {
     cmsHPROFILE hICC;
     cmsPipeline* Pipeline;
-    cmsUInt32Number nChannels;
+    cmsInt32Number nChannels;
 
     hICC = cmsCreateProfilePlaceholder(ContextID);
     if (!hICC)
         return NULL;
 
     cmsSetProfileVersion(hICC, 4.4);
 
     cmsSetDeviceClass(hICC,      cmsSigLinkClass);
     cmsSetColorSpace(hICC,       ColorSpace);
     cmsSetPCS(hICC,              ColorSpace);
 
     cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
 
     // Set up channels
-    nChannels = cmsChannelsOf(ColorSpace);
+    nChannels = cmsChannelsOfColorSpace(ColorSpace);
 
     // Creates a Pipeline with prelinearization step only
     Pipeline = cmsPipelineAlloc(ContextID, nChannels, nChannels);
     if (Pipeline == NULL) goto Error;
 
 
     // Copy tables to Pipeline
     if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))
         goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"Linearization built-in")) goto Error;
     if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline)) goto Error;
     if (!SetSeqDescTag(hICC, "Linearization built-in")) goto Error;
 
     // Pipeline is already on virtual profile
     cmsPipelineFree(Pipeline);
 
     // Ok, done
     return hICC;
@@ -393,63 +393,63 @@ int InkLimitingSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUI
 cmsHPROFILE CMSEXPORT cmsCreateInkLimitingDeviceLinkTHR(cmsContext ContextID,
                                                      cmsColorSpaceSignature ColorSpace,
                                                      cmsFloat64Number Limit)
 {
     cmsHPROFILE hICC;
     cmsPipeline* LUT;
     cmsStage* CLUT;
-    cmsUInt32Number nChannels;
+    cmsInt32Number nChannels;
 
     if (ColorSpace != cmsSigCmykData) {
         cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "InkLimiting: Only CMYK currently supported");
         return NULL;
     }
 
     if (Limit < 0.0 || Limit > 400) {
 
         cmsSignalError(ContextID, cmsERROR_RANGE, "InkLimiting: Limit should be between 0..400");
         if (Limit < 0) Limit = 0;
         if (Limit > 400) Limit = 400;
 
     }
 
     hICC = cmsCreateProfilePlaceholder(ContextID);
     if (!hICC)                          // can't allocate
         return NULL;
 
     cmsSetProfileVersion(hICC, 4.4);
 
     cmsSetDeviceClass(hICC,      cmsSigLinkClass);
     cmsSetColorSpace(hICC,       ColorSpace);
     cmsSetPCS(hICC,              ColorSpace);
 
     cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
 
 
     // Creates a Pipeline with 3D grid only
     LUT = cmsPipelineAlloc(ContextID, 4, 4);
     if (LUT == NULL) goto Error;
 
 
     nChannels = cmsChannelsOf(ColorSpace);
 
     CLUT = cmsStageAllocCLut16bit(ContextID, 17, nChannels, nChannels, NULL);
     if (CLUT == NULL) goto Error;
 
     if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;
 
     if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||
         !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||
         !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))
         goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"ink-limiting built-in")) goto Error;
 
     if (!cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) LUT))  goto Error;
     if (!SetSeqDescTag(hICC, "ink-limiting built-in")) goto Error;
 
     // cmsPipeline is already on virtual profile
     cmsPipelineFree(LUT);
 
     // Ok, done
     return hICC;
@@ -945,43 +945,43 @@ static
 cmsHPROFILE CreateNamedColorDevicelink(cmsHTRANSFORM xform)
 {
     _cmsTRANSFORM* v = (_cmsTRANSFORM*) xform;
     cmsHPROFILE hICC = NULL;
     cmsUInt32Number i, nColors;
     cmsNAMEDCOLORLIST *nc2 = NULL, *Original = NULL;
 
     // Create an empty placeholder
     hICC = cmsCreateProfilePlaceholder(v->ContextID);
     if (hICC == NULL) return NULL;
 
     // Critical information
     cmsSetDeviceClass(hICC, cmsSigNamedColorClass);
     cmsSetColorSpace(hICC, v ->ExitColorSpace);
     cmsSetPCS(hICC, cmsSigLabData);
 
     // Tag profile with information
     if (!SetTextTags(hICC, L"Named color devicelink")) goto Error;
 
     Original = cmsGetNamedColorList(xform);
     if (Original == NULL) goto Error;
 
     nColors = cmsNamedColorCount(Original);
     nc2     = cmsDupNamedColorList(Original);
     if (nc2 == NULL) goto Error;
 
     // Colorant count now depends on the output space
     nc2 ->ColorantCount = cmsPipelineOutputChannels(v ->Lut);
 
     // Make sure we have proper formatters
     cmsChangeBuffersFormat(xform, TYPE_NAMED_COLOR_INDEX,
         FLOAT_SH(0) | COLORSPACE_SH(_cmsLCMScolorSpace(v ->ExitColorSpace))
-        | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOf(v ->ExitColorSpace)));
+        | BYTES_SH(2) | CHANNELS_SH(cmsChannelsOfColorSpace(v ->ExitColorSpace)));
 
     // Apply the transfor to colorants.
     for (i=0; i < nColors; i++) {
         cmsDoTransform(xform, &i, nc2 ->List[i].DeviceColorant, 1);
     }
 
     if (!cmsWriteTag(hICC, cmsSigNamedColor2Tag, (void*) nc2)) goto Error;
     cmsFreeNamedColorList(nc2);
 
     return hICC;
@@ -1061,151 +1061,152 @@ const cmsAllowedLUT* FindCombination(const cmsPipeline* Lut, cmsBool IsV4, cmsTa
 // Does convert a transform into a device link profile
 cmsHPROFILE CMSEXPORT cmsTransform2DeviceLink(cmsHTRANSFORM hTransform, cmsFloat64Number Version, cmsUInt32Number dwFlags)
 {
     cmsHPROFILE hProfile = NULL;
-    cmsUInt32Number FrmIn, FrmOut, ChansIn, ChansOut;
-    int ColorSpaceBitsIn, ColorSpaceBitsOut;
+	cmsUInt32Number FrmIn, FrmOut;
+	cmsInt32Number ChansIn, ChansOut;
+	int ColorSpaceBitsIn, ColorSpaceBitsOut;
     _cmsTRANSFORM* xform = (_cmsTRANSFORM*) hTransform;
     cmsPipeline* LUT = NULL;
     cmsStage* mpe;
     cmsContext ContextID = cmsGetTransformContextID(hTransform);
     const cmsAllowedLUT* AllowedLUT;
     cmsTagSignature DestinationTag;
     cmsProfileClassSignature deviceClass; 
 
     _cmsAssert(hTransform != NULL);
 
     // Get the first mpe to check for named color
     mpe = cmsPipelineGetPtrToFirstStage(xform ->Lut);
 
     // Check if is a named color transform
     if (mpe != NULL) {
 
         if (cmsStageType(mpe) == cmsSigNamedColorElemType) {
             return CreateNamedColorDevicelink(hTransform);
         }
     }
 
     // First thing to do is to get a copy of the transformation
     LUT = cmsPipelineDup(xform ->Lut);
     if (LUT == NULL) return NULL;
 
     // Time to fix the Lab2/Lab4 issue.
     if ((xform ->EntryColorSpace == cmsSigLabData) && (Version < 4.0)) {
 
         if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID)))
             goto Error;
     }
 
     // On the output side too. Note that due to V2/V4 PCS encoding on lab we cannot fix white misalignments
     if ((xform ->ExitColorSpace) == cmsSigLabData && (Version < 4.0)) {
 
         dwFlags |= cmsFLAGS_NOWHITEONWHITEFIXUP;
         if (!cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID)))
             goto Error;
     }
 
 
     hProfile = cmsCreateProfilePlaceholder(ContextID);
     if (!hProfile) goto Error;                    // can't allocate
 
     cmsSetProfileVersion(hProfile, Version);
 
     FixColorSpaces(hProfile, xform -> EntryColorSpace, xform -> ExitColorSpace, dwFlags);
 
     // Optimize the LUT and precalculate a devicelink
 
-    ChansIn  = cmsChannelsOf(xform -> EntryColorSpace);
-    ChansOut = cmsChannelsOf(xform -> ExitColorSpace);
+    ChansIn  = cmsChannelsOfColorSpace(xform -> EntryColorSpace);
+    ChansOut = cmsChannelsOfColorSpace(xform -> ExitColorSpace);
 
     ColorSpaceBitsIn  = _cmsLCMScolorSpace(xform -> EntryColorSpace);
     ColorSpaceBitsOut = _cmsLCMScolorSpace(xform -> ExitColorSpace);
 
     FrmIn  = COLORSPACE_SH(ColorSpaceBitsIn) | CHANNELS_SH(ChansIn)|BYTES_SH(2);
     FrmOut = COLORSPACE_SH(ColorSpaceBitsOut) | CHANNELS_SH(ChansOut)|BYTES_SH(2);
 
     deviceClass = cmsGetDeviceClass(hProfile);
 
      if (deviceClass == cmsSigOutputClass)
          DestinationTag = cmsSigBToA0Tag;
      else
          DestinationTag = cmsSigAToB0Tag;
 
     // Check if the profile/version can store the result
     if (dwFlags & cmsFLAGS_FORCE_CLUT)
         AllowedLUT = NULL;
     else
         AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
 
     if (AllowedLUT == NULL) {
 
         // Try to optimize
         _cmsOptimizePipeline(ContextID, &LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);
         AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
 
     }
 
     // If no way, then force CLUT that for sure can be written
     if (AllowedLUT == NULL) {
 
         cmsStage* FirstStage;
         cmsStage* LastStage;
 
         dwFlags |= cmsFLAGS_FORCE_CLUT;
         _cmsOptimizePipeline(ContextID, &LUT, xform ->RenderingIntent, &FrmIn, &FrmOut, &dwFlags);
 
         // Put identity curves if needed
         FirstStage = cmsPipelineGetPtrToFirstStage(LUT);
         if (FirstStage != NULL && FirstStage ->Type != cmsSigCurveSetElemType)
              if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn)))
                  goto Error;
 
         LastStage = cmsPipelineGetPtrToLastStage(LUT);
         if (LastStage != NULL && LastStage ->Type != cmsSigCurveSetElemType)
              if (!cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut)))
                  goto Error;
 
         AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
     }
 
     // Somethings is wrong...
     if (AllowedLUT == NULL) {
         goto Error;
     }
 
 
     if (dwFlags & cmsFLAGS_8BITS_DEVICELINK)
                      cmsPipelineSetSaveAs8bitsFlag(LUT, TRUE);
 
     // Tag profile with information
     if (!SetTextTags(hProfile, L"devicelink")) goto Error;
 
     // Store result
     if (!cmsWriteTag(hProfile, DestinationTag, LUT)) goto Error;
 
 
     if (xform -> InputColorant != NULL) {
            if (!cmsWriteTag(hProfile, cmsSigColorantTableTag, xform->InputColorant)) goto Error;
     }
 
     if (xform -> OutputColorant != NULL) {
            if (!cmsWriteTag(hProfile, cmsSigColorantTableOutTag, xform->OutputColorant)) goto Error;
     }
 
     if ((deviceClass == cmsSigLinkClass) && (xform ->Sequence != NULL)) {
         if (!_cmsWriteProfileSequence(hProfile, xform ->Sequence)) goto Error;
     }
 
     // Set the white point
     if (deviceClass == cmsSigInputClass) {
         if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->EntryWhitePoint)) goto Error;
     }
     else {
          if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->ExitWhitePoint)) goto Error;
     }
 
   
     // Per 7.2.15 in spec 4.3
     cmsSetHeaderRenderingIntent(hProfile, xform ->RenderingIntent);
 
     cmsPipelineFree(LUT);
     return hProfile;
diff --git a/src/cmsxform.c b/src/cmsxform.c
index 7f6636e..b790388 100644
--- a/src/cmsxform.c
+++ b/src/cmsxform.c
@@ -1073,151 +1073,151 @@ void SetWhitePoint(cmsCIEXYZ* wtPt, const cmsCIEXYZ* src)
 // New to lcms 2.0 -- have all parameters available.
 cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
                                                    cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],
                                                    cmsBool  BPC[],
                                                    cmsUInt32Number Intents[],
                                                    cmsFloat64Number AdaptationStates[],
                                                    cmsHPROFILE hGamutProfile,
                                                    cmsUInt32Number nGamutPCSposition,
                                                    cmsUInt32Number InputFormat,
                                                    cmsUInt32Number OutputFormat,
                                                    cmsUInt32Number dwFlags)
 {
     _cmsTRANSFORM* xform;    
     cmsColorSpaceSignature EntryColorSpace;
     cmsColorSpaceSignature ExitColorSpace;
     cmsPipeline* Lut;
     cmsUInt32Number LastIntent = Intents[nProfiles-1];
 
     // If it is a fake transform
     if (dwFlags & cmsFLAGS_NULLTRANSFORM)
     {
         return AllocEmptyTransform(ContextID, NULL, INTENT_PERCEPTUAL, &InputFormat, &OutputFormat, &dwFlags);
     }
 
     // If gamut check is requested, make sure we have a gamut profile
     if (dwFlags & cmsFLAGS_GAMUTCHECK) {
         if (hGamutProfile == NULL) dwFlags &= ~cmsFLAGS_GAMUTCHECK;
     }
 
     // On floating point transforms, inhibit cache
     if (_cmsFormatterIsFloat(InputFormat) || _cmsFormatterIsFloat(OutputFormat))
         dwFlags |= cmsFLAGS_NOCACHE;
 
     // Mark entry/exit spaces
     if (!GetXFormColorSpaces(nProfiles, hProfiles, &EntryColorSpace, &ExitColorSpace)) {
         cmsSignalError(ContextID, cmsERROR_NULL, "NULL input profiles on transform");
         return NULL;
     }
 
     // Check if proper colorspaces
     if (!IsProperColorSpace(EntryColorSpace, InputFormat)) {
         cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Wrong input color space on transform");
         return NULL;
     }
 
     if (!IsProperColorSpace(ExitColorSpace, OutputFormat)) {
         cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, "Wrong output color space on transform");
         return NULL;
     }
 
     // Check whatever the transform is 16 bits and involves linear RGB in first profile. If so, disable optimizations
     if (EntryColorSpace == cmsSigRgbData && T_BYTES(InputFormat) == 2 && !(dwFlags & cmsFLAGS_NOOPTIMIZE))
     {
         cmsFloat64Number gamma = cmsDetectRGBProfileGamma(hProfiles[0], 0.1);
 
         if (gamma > 0 && gamma < 1.6)
             dwFlags |= cmsFLAGS_NOOPTIMIZE;
     }
 
     // Create a pipeline with all transformations
     Lut = _cmsLinkProfiles(ContextID, nProfiles, Intents, hProfiles, BPC, AdaptationStates, dwFlags);
     if (Lut == NULL) {
         cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, "Couldn't link the profiles");
         return NULL;
     }
 
     // Check channel count
-    if ((cmsChannelsOf(EntryColorSpace) != cmsPipelineInputChannels(Lut)) ||
-        (cmsChannelsOf(ExitColorSpace)  != cmsPipelineOutputChannels(Lut))) {
+    if ((cmsChannelsOfColorSpace(EntryColorSpace) != (cmsInt32Number) cmsPipelineInputChannels(Lut)) ||
+        (cmsChannelsOfColorSpace(ExitColorSpace)  != (cmsInt32Number) cmsPipelineOutputChannels(Lut))) {
         cmsPipelineFree(Lut);
         cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, "Channel count doesn't match. Profile is corrupted");
         return NULL;
     }
 
 
     // All seems ok
     xform = AllocEmptyTransform(ContextID, Lut, LastIntent, &InputFormat, &OutputFormat, &dwFlags);
     if (xform == NULL) {
         return NULL;
     }
 
     // Keep values
     xform ->EntryColorSpace = EntryColorSpace;
     xform ->ExitColorSpace  = ExitColorSpace;
     xform ->RenderingIntent = Intents[nProfiles-1];
 
     // Take white points
     SetWhitePoint(&xform->EntryWhitePoint, (cmsCIEXYZ*) cmsReadTag(hProfiles[0], cmsSigMediaWhitePointTag));
     SetWhitePoint(&xform->ExitWhitePoint,  (cmsCIEXYZ*) cmsReadTag(hProfiles[nProfiles-1], cmsSigMediaWhitePointTag));
    
 
     // Create a gamut check LUT if requested
     if (hGamutProfile != NULL && (dwFlags & cmsFLAGS_GAMUTCHECK))
         xform ->GamutCheck  = _cmsCreateGamutCheckPipeline(ContextID, hProfiles,
                                                         BPC, Intents,
                                                         AdaptationStates,
                                                         nGamutPCSposition,
                                                         hGamutProfile);
 
 
     // Try to read input and output colorant table
     if (cmsIsTag(hProfiles[0], cmsSigColorantTableTag)) {
 
         // Input table can only come in this way.
         xform ->InputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[0], cmsSigColorantTableTag));
     }
 
     // Output is a little bit more complex.
     if (cmsGetDeviceClass(hProfiles[nProfiles-1]) == cmsSigLinkClass) {
 
         // This tag may exist only on devicelink profiles.
         if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag)) {
 
             // It may be NULL if error
             xform ->OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableOutTag));
         }
 
     } else {
 
         if (cmsIsTag(hProfiles[nProfiles-1], cmsSigColorantTableTag)) {
 
             xform -> OutputColorant = cmsDupNamedColorList((cmsNAMEDCOLORLIST*) cmsReadTag(hProfiles[nProfiles-1], cmsSigColorantTableTag));
         }
     }
 
     // Store the sequence of profiles
     if (dwFlags & cmsFLAGS_KEEP_SEQUENCE) {
         xform ->Sequence = _cmsCompileProfileSequence(ContextID, nProfiles, hProfiles);
     }
     else
         xform ->Sequence = NULL;
 
     // If this is a cached transform, init first value, which is zero (16 bits only)
     if (!(dwFlags & cmsFLAGS_NOCACHE)) {
 
         memset(&xform ->Cache.CacheIn, 0, sizeof(xform ->Cache.CacheIn));
 
         if (xform ->GamutCheck != NULL) {
             TransformOnePixelWithGamutCheck(xform, xform ->Cache.CacheIn, xform->Cache.CacheOut);
         }
         else {
 
             xform ->Lut ->Eval16Fn(xform ->Cache.CacheIn, xform->Cache.CacheOut, xform -> Lut->Data);
         }
 
     }
 
     return (cmsHTRANSFORM) xform;
 }
 
 // Multiprofile transforms: Gamut check is not available here, as it is unclear from which profile the gamut comes.
diff --git a/src/lcms2.def b/src/lcms2.def
index b03943c..f3e4779 100644
--- a/src/lcms2.def
+++ b/src/lcms2.def
@@ -19,6 +19,7 @@ cmsBuildTabulatedToneCurve16             =   cmsBuildTabulatedToneCurve16
 cmsBuildTabulatedToneCurveFloat          =   cmsBuildTabulatedToneCurveFloat
 _cmsCalloc                               =   _cmsCalloc
 cmsChannelsOf                            =    cmsChannelsOf
+cmsChannelsOfColorSpace                  =    cmsChannelsOfColorSpace
 cmsCIE2000DeltaE                         =    cmsCIE2000DeltaE
 cmsCIE94DeltaE                           =    cmsCIE94DeltaE
 cmsCIECAM02Done                          =    cmsCIECAM02Done
diff --git a/testbed/testcms2.c b/testbed/testcms2.c
index de753d2..0513e09 100644
--- a/testbed/testcms2.c
+++ b/testbed/testcms2.c
@@ -8163,76 +8163,76 @@ static
 int CheckForgedMPE(void) 
 {
     cmsUInt32Number i;
     cmsHPROFILE srcProfile;
     cmsHPROFILE dstProfile;
     cmsColorSpaceSignature srcCS;
     cmsUInt32Number nSrcComponents;
     cmsUInt32Number srcFormat;
     cmsUInt32Number intent = 0;
     cmsUInt32Number flags = 0;
     cmsHTRANSFORM hTransform;
     cmsUInt8Number output[4];
 
     srcProfile = cmsOpenProfileFromFile("bad_mpe.icc", "r");
     if (!srcProfile)
         return 0;
 
     dstProfile = cmsCreate_sRGBProfile();
     if (!dstProfile) {
         cmsCloseProfile(srcProfile);
         return 0;
     }
 
     srcCS = cmsGetColorSpace(srcProfile);
-    nSrcComponents = cmsChannelsOf(srcCS);
+    nSrcComponents = cmsChannelsOfColorSpace(srcCS);
     
     if (srcCS == cmsSigLabData) {
         srcFormat =
             COLORSPACE_SH(PT_Lab) | CHANNELS_SH(nSrcComponents) | BYTES_SH(0);
     }
     else {
         srcFormat =
             COLORSPACE_SH(PT_ANY) | CHANNELS_SH(nSrcComponents) | BYTES_SH(1);
     }
 
     cmsSetLogErrorHandler(ErrorReportingFunction);
 
     hTransform = cmsCreateTransform(srcProfile, srcFormat, dstProfile,
         TYPE_BGR_8, intent, flags);
     cmsCloseProfile(srcProfile);
     cmsCloseProfile(dstProfile);
 
     cmsSetLogErrorHandler(FatalErrorQuit);    
 
     // Should report error
     if (!TrappedError) return 0;
 
     TrappedError = FALSE;
 
     // Transform should NOT be created
     if (!hTransform) return 1;
     
     // Never should reach here
     if (T_BYTES(srcFormat) == 0) {  // 0 means double
         double input[128];
         for (i = 0; i < nSrcComponents; i++)
             input[i] = 0.5f;
         cmsDoTransform(hTransform, input, output, 1);
     }
     else {
         cmsUInt8Number input[128];
         for (i = 0; i < nSrcComponents; i++)
             input[i] = 128;
         cmsDoTransform(hTransform, input, output, 1);
     }
     cmsDeleteTransform(hTransform);
 
     return 0;
 }
 
 /**
 * What the self test is trying to do is creating a proofing transform
 * with gamut check, so we can getting the coverage of one profile of
 * another, i.e. to approximate the gamut intersection. e.g.
 * Thanks to Richard Hughes for providing the test
 */
@@ -9206,316 +9206,314 @@ static
 void PrintSupportedIntents(void)
 {
     cmsUInt32Number n, i;
     cmsUInt32Number Codes[200];
     char* Descriptions[200];
 
     n = cmsGetSupportedIntents(200, Codes, Descriptions);
 
     printf("Supported intents:\n");
     for (i=0; i < n; i++) {
         printf("\t%u - %s\n", Codes[i], Descriptions[i]);
     }
     printf("\n");
 }
 
-
-
 // ---------------------------------------------------------------------------------------
 
 int main(int argc, char* argv[])
 {
     cmsInt32Number Exhaustive = 0;
     cmsInt32Number DoSpeedTests = 1;
     cmsInt32Number DoCheckTests = 1;
     cmsInt32Number DoPluginTests = 1;
     cmsInt32Number DoZooTests = 0;
 
 #ifdef _MSC_VER
     _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
 #endif
 
     // First of all, check for the right header
     if (cmsGetEncodedCMMversion() != LCMS_VERSION) {
         Die("Oops, you are mixing header and shared lib!\nHeader version reports to be '%d' and shared lib '%d'\n", LCMS_VERSION, cmsGetEncodedCMMversion());
     }
 
     printf("LittleCMS %2.2f test bed %s %s\n\n", cmsGetEncodedCMMversion() / 1000.0, __DATE__, __TIME__);
 
     if ((argc == 2) && strcmp(argv[1], "--exhaustive") == 0) {
 
         Exhaustive = 1;
         printf("Running exhaustive tests (will take a while...)\n\n");
     }
     else
         if ((argc == 3) && strcmp(argv[1], "--chdir") == 0) {
             CHDIR(argv[2]);
         }
 
 #ifdef LCMS_FAST_EXTENSIONS
    printf("Installing fast float extension ...");   
    cmsPlugin(cmsFastFloatExtensions());
    printf("done.\n");
 #endif
 
 
     printf("Installing debug memory plug-in ... ");
     cmsPlugin(&DebugMemHandler);
     printf("done.\n");
 
     printf("Installing error logger ... ");
     cmsSetLogErrorHandler(FatalErrorQuit);
     printf("done.\n");
-           
+             
     PrintSupportedIntents();
     
     Check("Base types", CheckBaseTypes);
     Check("endianness", CheckEndianness);
     Check("quick floor", CheckQuickFloor);
     Check("quick floor word", CheckQuickFloorWord);
     Check("Fixed point 15.16 representation", CheckFixedPoint15_16);
     Check("Fixed point 8.8 representation", CheckFixedPoint8_8);
     Check("D50 roundtrip", CheckD50Roundtrip);
 
     // Create utility profiles
     if (DoCheckTests || DoSpeedTests)
         Check("Creation of test profiles", CreateTestProfiles);
 
     if (DoCheckTests) {
    
     // Forward 1D interpolation
     Check("1D interpolation in 2pt tables", Check1DLERP2);
     Check("1D interpolation in 3pt tables", Check1DLERP3);
     Check("1D interpolation in 4pt tables", Check1DLERP4);
     Check("1D interpolation in 6pt tables", Check1DLERP6);
     Check("1D interpolation in 18pt tables", Check1DLERP18);
     Check("1D interpolation in descending 2pt tables", Check1DLERP2Down);
     Check("1D interpolation in descending 3pt tables", Check1DLERP3Down);
     Check("1D interpolation in descending 6pt tables", Check1DLERP6Down);
     Check("1D interpolation in descending 18pt tables", Check1DLERP18Down);
 
     if (Exhaustive) {
 
         Check("1D interpolation in n tables", ExhaustiveCheck1DLERP);
         Check("1D interpolation in descending tables", ExhaustiveCheck1DLERPDown);
     }
 
     // Forward 3D interpolation
     Check("3D interpolation Tetrahedral (float) ", Check3DinterpolationFloatTetrahedral);
     Check("3D interpolation Trilinear (float) ", Check3DinterpolationFloatTrilinear);
     Check("3D interpolation Tetrahedral (16) ", Check3DinterpolationTetrahedral16);
     Check("3D interpolation Trilinear (16) ", Check3DinterpolationTrilinear16);
 
     if (Exhaustive) {
 
         Check("Exhaustive 3D interpolation Tetrahedral (float) ", ExaustiveCheck3DinterpolationFloatTetrahedral);
         Check("Exhaustive 3D interpolation Trilinear  (float) ", ExaustiveCheck3DinterpolationFloatTrilinear);
         Check("Exhaustive 3D interpolation Tetrahedral (16) ", ExhaustiveCheck3DinterpolationTetrahedral16);
         Check("Exhaustive 3D interpolation Trilinear (16) ", ExhaustiveCheck3DinterpolationTrilinear16);
     }
 
     Check("Reverse interpolation 3 -> 3", CheckReverseInterpolation3x3);
     Check("Reverse interpolation 4 -> 3", CheckReverseInterpolation4x3);
 
 
     // High dimensionality interpolation
 
     Check("3D interpolation", Check3Dinterp);
     Check("3D interpolation with granularity", Check3DinterpGranular);
     Check("4D interpolation", Check4Dinterp);
     Check("4D interpolation with granularity", Check4DinterpGranular);
     Check("5D interpolation with granularity", Check5DinterpGranular);
     Check("6D interpolation with granularity", Check6DinterpGranular);
     Check("7D interpolation with granularity", Check7DinterpGranular);
     Check("8D interpolation with granularity", Check8DinterpGranular);
 
     // Encoding of colorspaces
     Check("Lab to LCh and back (float only) ", CheckLab2LCh);
     Check("Lab to XYZ and back (float only) ", CheckLab2XYZ);
     Check("Lab to xyY and back (float only) ", CheckLab2xyY);
     Check("Lab V2 encoding", CheckLabV2encoding);
     Check("Lab V4 encoding", CheckLabV4encoding);
 
     // BlackBody
     Check("Blackbody radiator", CheckTemp2CHRM);
 
     // Tone curves
     Check("Linear gamma curves (16 bits)", CheckGammaCreation16);
     Check("Linear gamma curves (float)", CheckGammaCreationFlt);
 
     Check("Curve 1.8 (float)", CheckGamma18);
     Check("Curve 2.2 (float)", CheckGamma22);
     Check("Curve 3.0 (float)", CheckGamma30);
 
     Check("Curve 1.8 (table)", CheckGamma18Table);
     Check("Curve 2.2 (table)", CheckGamma22Table);
     Check("Curve 3.0 (table)", CheckGamma30Table);
 
     Check("Curve 1.8 (word table)", CheckGamma18TableWord);
     Check("Curve 2.2 (word table)", CheckGamma22TableWord);
     Check("Curve 3.0 (word table)", CheckGamma30TableWord);
 
     Check("Parametric curves", CheckParametricToneCurves);
 
     Check("Join curves", CheckJointCurves);
     Check("Join curves descending", CheckJointCurvesDescending);
     Check("Join curves degenerated", CheckReverseDegenerated);
     Check("Join curves sRGB (Float)", CheckJointFloatCurves_sRGB);
     Check("Join curves sRGB (16 bits)", CheckJoint16Curves_sRGB);
     Check("Join curves sigmoidal", CheckJointCurvesSShaped);
 
     // LUT basics
     Check("LUT creation & dup", CheckLUTcreation);
     Check("1 Stage LUT ", Check1StageLUT);
     Check("2 Stage LUT ", Check2StageLUT);
     Check("2 Stage LUT (16 bits)", Check2Stage16LUT);
     Check("3 Stage LUT ", Check3StageLUT);
     Check("3 Stage LUT (16 bits)", Check3Stage16LUT);
     Check("4 Stage LUT ", Check4StageLUT);
     Check("4 Stage LUT (16 bits)", Check4Stage16LUT);
     Check("5 Stage LUT ", Check5StageLUT);
     Check("5 Stage LUT (16 bits) ", Check5Stage16LUT);
     Check("6 Stage LUT ", Check6StageLUT);
     Check("6 Stage LUT (16 bits) ", Check6Stage16LUT);
 
     // LUT operation
     Check("Lab to Lab LUT (float only) ", CheckLab2LabLUT);
     Check("XYZ to XYZ LUT (float only) ", CheckXYZ2XYZLUT);
     Check("Lab to Lab MAT LUT (float only) ", CheckLab2LabMatLUT);
     Check("Named Color LUT", CheckNamedColorLUT);
     Check("Usual formatters", CheckFormatters16);
     Check("Floating point formatters", CheckFormattersFloat);
 
 #ifndef CMS_NO_HALF_SUPPORT 
     Check("HALF formatters", CheckFormattersHalf);
 #endif
     // ChangeBuffersFormat
     Check("ChangeBuffersFormat", CheckChangeBufferFormat);
 
     // MLU
     Check("Multilocalized Unicode", CheckMLU);
 
     // Named color
     Check("Named color lists", CheckNamedColorList);
     Check("Create named color profile", CreateNamedColorProfile);
 
 
     // Profile I/O (this one is huge!)
     Check("Profile creation", CheckProfileCreation);
     Check("Header version", CheckVersionHeaderWriting);
     Check("Multilocalized profile", CheckMultilocalizedProfile);
 
     // Error reporting
     Check("Error reporting on bad profiles", CheckErrReportingOnBadProfiles);
     Check("Error reporting on bad transforms", CheckErrReportingOnBadTransforms);
 
     // Transforms
     Check("Curves only transforms", CheckCurvesOnlyTransforms);
     Check("Float Lab->Lab transforms", CheckFloatLabTransforms);
     Check("Encoded Lab->Lab transforms", CheckEncodedLabTransforms);
     Check("Stored identities", CheckStoredIdentities);
 
     Check("Matrix-shaper transform (float)",   CheckMatrixShaperXFORMFloat);
     Check("Matrix-shaper transform (16 bits)", CheckMatrixShaperXFORM16);
     Check("Matrix-shaper transform (8 bits)",  CheckMatrixShaperXFORM8);
 
     Check("Primaries of sRGB", CheckRGBPrimaries);
 
     // Known values
     Check("Known values across matrix-shaper", Chack_sRGB_Float);
     Check("Gray input profile", CheckInputGray);
     Check("Gray Lab input profile", CheckLabInputGray);
     Check("Gray output profile", CheckOutputGray);
     Check("Gray Lab output profile", CheckLabOutputGray);
 
     Check("Matrix-shaper proofing transform (float)",   CheckProofingXFORMFloat);
     Check("Matrix-shaper proofing transform (16 bits)",  CheckProofingXFORM16);
 
     Check("Gamut check", CheckGamutCheck);
 
     Check("CMYK roundtrip on perceptual transform",   CheckCMYKRoundtrip);
 
     Check("CMYK perceptual transform",   CheckCMYKPerceptual);
     // Check("CMYK rel.col. transform",   CheckCMYKRelCol);
 
     Check("Black ink only preservation", CheckKOnlyBlackPreserving);
     Check("Black plane preservation", CheckKPlaneBlackPreserving);
 
 
     Check("Deciding curve types", CheckV4gamma);
 
     Check("Black point detection", CheckBlackPoint);
     Check("TAC detection", CheckTAC);
 
     Check("CGATS parser", CheckCGATS);
     Check("CGATS parser on junk", CheckCGATS2);
     Check("CGATS parser on overflow", CheckCGATS_Overflow);
     Check("PostScript generator", CheckPostScript);
     Check("Segment maxima GBD", CheckGBD);
     Check("MD5 digest", CheckMD5);
     Check("Linking", CheckLinking);
     Check("floating point tags on XYZ", CheckFloatXYZ);
     Check("RGB->Lab->RGB with alpha on FLT", ChecksRGB2LabFLT);
     Check("Parametric curve on Rec709", CheckParametricRec709);
     Check("Floating Point sampled curve with non-zero start", CheckFloatSamples);
     Check("Floating Point segmented curve with short sampled segment", CheckFloatSegments);
     Check("Read RAW tags", CheckReadRAW);
     Check("Check MetaTag", CheckMeta);
     Check("Null transform on floats", CheckFloatNULLxform);
     Check("Set free a tag", CheckRemoveTag);
     Check("Matrix simplification", CheckMatrixSimplify);
     Check("Planar 8 optimization", CheckPlanar8opt);
     Check("Swap endian feature", CheckSE);
     Check("Transform line stride RGB", CheckTransformLineStride);
     Check("Forged MPE profile", CheckForgedMPE);
     Check("Proofing intersection", CheckProofingIntersection);
     Check("Empty MLUC", CheckEmptyMLUC);
     Check("sRGB round-trips", Check_sRGB_Rountrips);
     Check("Gamma space detection", CheckGammaSpaceDetection);
     Check("Unbounded mode w/ integer output", CheckIntToFloatTransform);
     Check("Corrupted built-in by using cmsWriteRawTag", CheckInducedCorruption);
     }
 
     if (DoPluginTests)
     {
 
         Check("Context memory handling", CheckAllocContext);
         Check("Simple context functionality", CheckSimpleContext);
         Check("Alarm codes context", CheckAlarmColorsContext);
         Check("Adaptation state context", CheckAdaptationStateContext);
         Check("1D interpolation plugin", CheckInterp1DPlugin); 
         Check("3D interpolation plugin", CheckInterp3DPlugin); 
         Check("Parametric curve plugin", CheckParametricCurvePlugin);        
         Check("Formatters plugin",       CheckFormattersPlugin);        
         Check("Tag type plugin",         CheckTagTypePlugin);
         Check("MPE type plugin",         CheckMPEPlugin);       
         Check("Optimization plugin",     CheckOptimizationPlugin); 
         Check("Rendering intent plugin", CheckIntentPlugin);
         Check("Full transform plugin",   CheckTransformPlugin);
         Check("Mutex plugin",            CheckMutexPlugin);
        
     }
 
 
     if (DoSpeedTests)
         SpeedTest();
 
 
 #ifdef CMS_IS_WINDOWS_
     if (DoZooTests) 
          CheckProfileZOO();
 #endif
 
     DebugMemPrintTotals();
 
     cmsUnregisterPlugins();
 
     // Cleanup
     if (DoCheckTests || DoSpeedTests)
         RemoveTestProfiles();
 
    return TotalFail;
 }
 
 
 
 
diff --git a/utils/transicc/transicc.c b/utils/transicc/transicc.c
index 77787d6..5b1304c 100644
--- a/utils/transicc/transicc.c
+++ b/utils/transicc/transicc.c
@@ -310,107 +310,107 @@ static
 cmsNAMEDCOLORLIST* ComponentNames(cmsColorSpaceSignature space, cmsBool IsInput)
 {
     cmsNAMEDCOLORLIST* out;
     int i, n;
     char Buffer[cmsMAX_PATH];
 
     out = cmsAllocNamedColorList(0, 12, cmsMAXCHANNELS, "", "");
     if (out == NULL) return NULL;
 
     switch (space) {
 
     case cmsSigXYZData:
         SetRange(100, IsInput);
         cmsAppendNamedColor(out, "X", NULL, NULL);
         cmsAppendNamedColor(out, "Y", NULL, NULL);
         cmsAppendNamedColor(out, "Z", NULL, NULL);
         break;
 
     case cmsSigLabData:
         SetRange(1, IsInput);
         cmsAppendNamedColor(out, "L*", NULL, NULL);
         cmsAppendNamedColor(out, "a*", NULL, NULL);
         cmsAppendNamedColor(out, "b*", NULL, NULL);
         break;
 
     case cmsSigLuvData:
         SetRange(1, IsInput);
         cmsAppendNamedColor(out, "L", NULL, NULL);
         cmsAppendNamedColor(out, "u", NULL, NULL);
         cmsAppendNamedColor(out, "v", NULL, NULL);
         break;
 
     case cmsSigYCbCrData:
         SetRange(255, IsInput);
         cmsAppendNamedColor(out, "Y", NULL, NULL );
         cmsAppendNamedColor(out, "Cb", NULL, NULL);
         cmsAppendNamedColor(out, "Cr", NULL, NULL);
         break;
 
 
     case cmsSigYxyData:
         SetRange(1, IsInput);
         cmsAppendNamedColor(out, "Y", NULL, NULL);
         cmsAppendNamedColor(out, "x", NULL, NULL);
         cmsAppendNamedColor(out, "y", NULL, NULL);
         break;
 
     case cmsSigRgbData:
         SetRange(255, IsInput);
         cmsAppendNamedColor(out, "R", NULL, NULL);
         cmsAppendNamedColor(out, "G", NULL, NULL);
         cmsAppendNamedColor(out, "B", NULL, NULL);
         break;
 
     case cmsSigGrayData:
         SetRange(255, IsInput);
         cmsAppendNamedColor(out, "G", NULL, NULL);      
         break;
 
     case cmsSigHsvData:
         SetRange(255, IsInput);
         cmsAppendNamedColor(out, "H", NULL, NULL);
         cmsAppendNamedColor(out, "s", NULL, NULL);
         cmsAppendNamedColor(out, "v", NULL, NULL);
         break;
 
     case cmsSigHlsData:
         SetRange(255, IsInput);
         cmsAppendNamedColor(out, "H", NULL, NULL);
         cmsAppendNamedColor(out, "l", NULL, NULL);
         cmsAppendNamedColor(out, "s", NULL, NULL);
         break;
 
     case cmsSigCmykData:
         SetRange(1, IsInput);
         cmsAppendNamedColor(out, "C", NULL, NULL);
         cmsAppendNamedColor(out, "M", NULL, NULL);
         cmsAppendNamedColor(out, "Y", NULL, NULL);                     
         cmsAppendNamedColor(out, "K", NULL, NULL);
         break;
 
     case cmsSigCmyData:
         SetRange(1, IsInput);
         cmsAppendNamedColor(out, "C", NULL, NULL);
         cmsAppendNamedColor(out, "M", NULL, NULL);
         cmsAppendNamedColor(out, "Y", NULL, NULL);
         break;
 
     default:
 
         SetRange(1, IsInput);
 
-        n = cmsChannelsOf(space);
+        n = cmsChannelsOfColorSpace(space);
 
         for (i=0; i < n; i++) {
 
             sprintf(Buffer, "Channel #%d", i + 1);
             cmsAppendNamedColor(out, Buffer, NULL, NULL);
         }
     }
 
     return out;
 
 }
 
 
 // Creates all needed color transforms
@@ -662,42 +662,42 @@ static
 void PrintFloatResults(cmsFloat64Number Value[])
 {
     cmsUInt32Number i, n;
     char ChannelName[cmsMAX_PATH];
     cmsFloat64Number v;
 
-    n = cmsChannelsOf(OutputColorSpace);
+    n = cmsChannelsOfColorSpace(OutputColorSpace);
     for (i=0; i < n; i++) {
 
         if (OutputColorant != NULL) {
 
             cmsNamedColorInfo(OutputColorant, i, ChannelName, NULL, NULL, NULL, NULL);         
         }
         else {
             OutputRange = 1;
             sprintf(ChannelName, "Channel #%u", i + 1);
         }
 
         v = (cmsFloat64Number) Value[i]* OutputRange;
 
         if (lQuantize) 
             v = floor(v + 0.5);
 
         if (!lUnbounded) {
 
                if (v < 0)
                       v = 0;
                if (v > OutputRange)
                       v = OutputRange;
         }
 
         if (Verbose <= 0)
             printf("%.4f ", v);
         else
             printf("%s=%.4f ", ChannelName, v);
     }   
 
     printf("\n");
 }
 
 
 // Get a named-color index
@@ -731,36 +731,36 @@ static
 void TakeFloatValues(cmsFloat64Number Float[])
 {
     cmsUInt32Number i, n;
     char ChannelName[cmsMAX_PATH];
     char Buffer[4096];
 
     if (xisatty(stdin))
         fprintf(stderr, "\nEnter values, 'q' to quit\n");
 
     if (InputNamedColor) {
 
         // This is named color index, which is always cmsUInt16Number
         cmsUInt16Number index = GetIndex();
         memcpy(Float, &index, sizeof(cmsUInt16Number));
         return;
     }
 
-    n = cmsChannelsOf(InputColorSpace);
+    n = cmsChannelsOfColorSpace(InputColorSpace);
     for (i=0; i < n; i++) {
 
         if (InputColorant) {
             cmsNamedColorInfo(InputColorant, i, ChannelName, NULL, NULL, NULL, NULL);          
         }
         else {
             InputRange = 1;
             sprintf(ChannelName, "Channel #%u", i+1);
         }
 
         GetLine(Buffer, "%s? ", ChannelName);
 
         Float[i] = (cmsFloat64Number) atof(Buffer) / InputRange;
     }       
 
     if (xisatty(stdin))
         fprintf(stderr, "\n");
 }
@@ -791,43 +791,43 @@ static
 void PrintEncodedResults(cmsUInt16Number Encoded[])
 {
     cmsUInt32Number i, n;
     char ChannelName[cmsMAX_PATH];
     cmsUInt32Number v;
 
-    n = cmsChannelsOf(OutputColorSpace);
+    n = cmsChannelsOfColorSpace(OutputColorSpace);
     for (i=0; i < n; i++) {
 
         if (OutputColorant != NULL) {
 
             cmsNamedColorInfo(OutputColorant, i, ChannelName, NULL, NULL, NULL, NULL);          
         }
         else {          
             sprintf(ChannelName, "Channel #%u", i + 1);
         }
 
         if (Verbose > 0)
             printf("%s=", ChannelName);
 
         v = Encoded[i];
 
         if (InHexa) {
 
             if (Width16)
                 printf("0x%04X ", (int) floor(v + .5));
             else
                 printf("0x%02X ", (int) floor(v / 257. + .5));
 
         } else {
 
             if (Width16)
                 printf("%d ", (int) floor(v + .5));
             else
                 printf("%d ", (int) floor(v / 257. + .5));
         }
 
     }   
 
     printf("\n");
 }
 
 // Print XYZ/Lab values on verbose mode
@@ -874,118 +874,118 @@ static
 void TakeCGATSValues(int nPatch, cmsFloat64Number Float[])
 {
 
     // At first take the name if SAMPLE_ID is present
     if (cmsIT8GetPatchName(hIT8in, nPatch, CGATSPatch) == NULL) {
         FatalError("Sorry, I need 'SAMPLE_ID' on input CGATS to operate.");
     }
 
 
     // Special handling for named color profiles. 
     // Lookup the name in the names database (the transform)
 
     if (InputNamedColor) {
 
         const cmsNAMEDCOLORLIST* NamedColorList;
         int index;
 
         NamedColorList = cmsGetNamedColorList(hTrans);
         if (NamedColorList == NULL) 
             FatalError("Malformed named color profile");
 
         index = cmsNamedColorIndex(NamedColorList, CGATSPatch);
         if (index < 0) 
             FatalError("Named color '%s' not found in the profile", CGATSPatch); 
 
         Float[0] = index;
         return;
     }
 
     // Color is not a spot color, proceed.
 
     switch (InputColorSpace) {
 
         // Encoding should follow CGATS specification.
 
     case cmsSigXYZData:
         Float[0] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "XYZ_X") / 100.0;
         Float[1] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "XYZ_Y") / 100.0;
         Float[2] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "XYZ_Z") / 100.0;        
         break;
 
     case cmsSigLabData:
         Float[0] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "LAB_L");
         Float[1] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "LAB_A");
         Float[2] = cmsIT8GetDataDbl(hIT8in, CGATSPatch, "LAB_B");        
         break;
 
 
     case cmsSigRgbData:
         Float[0] = GetIT8Val("RGB_R", 255.0);
         Float[1] = GetIT8Val("RGB_G", 255.0);
         Float[2] = GetIT8Val("RGB_B", 255.0);
         break;
 
     case cmsSigGrayData:
         Float[0] = GetIT8Val("GRAY", 255.0);
         break;
 
     case cmsSigCmykData:
         Float[0] = GetIT8Val("CMYK_C", 1.0);
         Float[1] = GetIT8Val("CMYK_M", 1.0);
         Float[2] = GetIT8Val("CMYK_Y", 1.0);
         Float[3] = GetIT8Val("CMYK_K", 1.0);
         break;
 
     case cmsSigCmyData:                        
         Float[0] = GetIT8Val("CMY_C", 1.0);
         Float[1] = GetIT8Val("CMY_M", 1.0);
         Float[2] = GetIT8Val("CMY_Y", 1.0);
         break;
 
     case cmsSig1colorData:
     case cmsSig2colorData:
     case cmsSig3colorData:
     case cmsSig4colorData:
     case cmsSig5colorData:
     case cmsSig6colorData:
     case cmsSig7colorData:
     case cmsSig8colorData:
     case cmsSig9colorData:
     case cmsSig10colorData:
     case cmsSig11colorData:
     case cmsSig12colorData:
     case cmsSig13colorData:
     case cmsSig14colorData:
     case cmsSig15colorData:
         {
             cmsUInt32Number i, n;
 
-            n = cmsChannelsOf(InputColorSpace);
+            n = cmsChannelsOfColorSpace(InputColorSpace);
             for (i=0; i < n; i++) { 
 
                 char Buffer[255];
 
                 sprintf(Buffer, "%uCLR_%u", n, i+1);
                 Float[i] = GetIT8Val(Buffer, 100.0);
             }
 
         }
         break;
 
     default: 
         {
             cmsUInt32Number i, n;
 
-            n = cmsChannelsOf(InputColorSpace);
+            n = cmsChannelsOfColorSpace(InputColorSpace);
             for (i=0; i < n; i++) { 
 
                 char Buffer[255];
 
                 sprintf(Buffer, "CHAN_%u", i+1);
                 Float[i] = GetIT8Val(Buffer, 1.0);
             }
 
         }
     }
 
 }
@@ -1007,98 +1007,98 @@ static
 void PutCGATSValues(cmsFloat64Number Float[])
 {   
     cmsIT8SetData(hIT8out, CGATSPatch, "SAMPLE_ID", CGATSPatch);
     switch (OutputColorSpace) {
 
 
     // Encoding should follow CGATS specification.
 
     case cmsSigXYZData:
 
         SetCGATSfld("XYZ_X", Float[0] * 100.0);
         SetCGATSfld("XYZ_Y", Float[1] * 100.0);
         SetCGATSfld("XYZ_Z", Float[2] * 100.0);                    
         break;
 
     case cmsSigLabData:
 
         SetCGATSfld("LAB_L", Float[0]);
         SetCGATSfld("LAB_A", Float[1]);
         SetCGATSfld("LAB_B", Float[2]);                    
         break;
 
 
     case cmsSigRgbData:
         SetCGATSfld("RGB_R", Float[0] * 255.0);
         SetCGATSfld("RGB_G", Float[1] * 255.0);
         SetCGATSfld("RGB_B", Float[2] * 255.0);
         break;
 
     case cmsSigGrayData:
         SetCGATSfld("GRAY", Float[0] * 255.0);                    
         break;
 
     case cmsSigCmykData:
         SetCGATSfld("CMYK_C", Float[0]);
         SetCGATSfld("CMYK_M", Float[1]);
         SetCGATSfld("CMYK_Y", Float[2]);
         SetCGATSfld("CMYK_K", Float[3]);
         break;
 
     case cmsSigCmyData:
         SetCGATSfld("CMY_C", Float[0]);
         SetCGATSfld("CMY_M", Float[1]);
         SetCGATSfld("CMY_Y", Float[2]);                 
         break;
 
     case cmsSig1colorData:
     case cmsSig2colorData:
     case cmsSig3colorData:
     case cmsSig4colorData:
     case cmsSig5colorData:
     case cmsSig6colorData:
     case cmsSig7colorData:
     case cmsSig8colorData:
     case cmsSig9colorData:
     case cmsSig10colorData:
     case cmsSig11colorData:
     case cmsSig12colorData:
     case cmsSig13colorData:
     case cmsSig14colorData:
     case cmsSig15colorData:
         {
 
-            cmsUInt32Number i, n;
+            cmsInt32Number i, n;
 
-            n = cmsChannelsOf(InputColorSpace);
+            n = cmsChannelsOfColorSpace(InputColorSpace);
             for (i=0; i < n; i++) { 
 
                 char Buffer[255];
 
                 sprintf(Buffer, "%uCLR_%u", n, i+1);
 
                 SetCGATSfld(Buffer, Float[i] * 100.0);
             }
         }
         break;
 
     default: 
         {
 
-            cmsUInt32Number i, n;
+            cmsInt32Number i, n;
 
-            n = cmsChannelsOf(InputColorSpace);
+            n = cmsChannelsOfColorSpace(InputColorSpace);
             for (i=0; i < n; i++) { 
 
                 char Buffer[255];
 
                 sprintf(Buffer, "CHAN_%u", i+1);
 
                 SetCGATSfld(Buffer, Float[i]);
             }
         }
     }
 }
 
 
 
 // Create data format 
@@ -1106,113 +1106,113 @@ static
 void SetOutputDataFormat(void) 
 {
     cmsIT8DefineDblFormat(hIT8out, "%.4g");
     cmsIT8SetPropertyStr(hIT8out, "ORIGINATOR", "icctrans");
 
     if (IncludePart != NULL) 
         cmsIT8SetPropertyStr(hIT8out, ".INCLUDE", IncludePart);
 
     cmsIT8SetComment(hIT8out, "Data follows");
     cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_SETS", nMaxPatches);
 
 
     switch (OutputColorSpace) {
 
 
         // Encoding should follow CGATS specification.
 
     case cmsSigXYZData:
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 4);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "XYZ_X");
         cmsIT8SetDataFormat(hIT8out, 2, "XYZ_Y");
         cmsIT8SetDataFormat(hIT8out, 3, "XYZ_Z");
         break;
 
     case cmsSigLabData:
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 4);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "LAB_L");
         cmsIT8SetDataFormat(hIT8out, 2, "LAB_A");
         cmsIT8SetDataFormat(hIT8out, 3, "LAB_B");
         break;
 
 
     case cmsSigRgbData:
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 4);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "RGB_R");
         cmsIT8SetDataFormat(hIT8out, 2, "RGB_G");
         cmsIT8SetDataFormat(hIT8out, 3, "RGB_B");
         break;
 
     case cmsSigGrayData:                
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 2);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "GRAY");
         break;
 
     case cmsSigCmykData:
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 5);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "CMYK_C");
         cmsIT8SetDataFormat(hIT8out, 2, "CMYK_M");
         cmsIT8SetDataFormat(hIT8out, 3, "CMYK_Y");
         cmsIT8SetDataFormat(hIT8out, 4, "CMYK_K");
         break;
 
     case cmsSigCmyData:
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", 4);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
         cmsIT8SetDataFormat(hIT8out, 1, "CMY_C");
         cmsIT8SetDataFormat(hIT8out, 2, "CMY_M");
         cmsIT8SetDataFormat(hIT8out, 3, "CMY_Y");                   
         break;
 
     case cmsSig1colorData:
     case cmsSig2colorData:
     case cmsSig3colorData:
     case cmsSig4colorData:
     case cmsSig5colorData:
     case cmsSig6colorData:
     case cmsSig7colorData:
     case cmsSig8colorData:
     case cmsSig9colorData:
     case cmsSig10colorData:
     case cmsSig11colorData:
     case cmsSig12colorData:
     case cmsSig13colorData:
     case cmsSig14colorData:
     case cmsSig15colorData:
         {
             int i, n;
             char Buffer[255];
 
-            n = cmsChannelsOf(OutputColorSpace);
+            n = cmsChannelsOfColorSpace(OutputColorSpace);
             cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", n+1);
             cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
 
             for (i=1; i <= n; i++) {
                 sprintf(Buffer, "%dCLR_%d", n, i);
                 cmsIT8SetDataFormat(hIT8out, i, Buffer);
             }
         }
         break;
 
     default: {
 
         int i, n;
         char Buffer[255];
 
-        n = cmsChannelsOf(OutputColorSpace);
+        n = cmsChannelsOfColorSpace(OutputColorSpace);
         cmsIT8SetPropertyDbl(hIT8out, "NUMBER_OF_FIELDS", n+1);
         cmsIT8SetDataFormat(hIT8out, 0, "SAMPLE_ID");
 
         for (i=1; i <= n; i++) {
             sprintf(Buffer, "CHAN_%d", i);
             cmsIT8SetDataFormat(hIT8out, i, Buffer);
         }
     }
     }
 }
 
 // Open CGATS if specified
