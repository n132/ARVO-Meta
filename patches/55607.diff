commit a1837c354628e6ed368fb8085858a15a7c9a0db9
Author: Reini Urban <rurban@cpan.org>
Date:   Thu Feb 9 15:52:18 2023 +0100

    spec: add DWG_TABLE, fix dwg_decode_<TABLE> visibility
    
    the tables are non-static for r11 decoding, the DWG_OBJECT stays static

diff --git a/src/dec_macros.h b/src/dec_macros.h
index bc6e6da7..d6fd5110 100644
--- a/src/dec_macros.h
+++ b/src/dec_macros.h
@@ -1,1771 +1,1853 @@
 /*****************************************************************************/
 /*  LibreDWG - free implementation of the DWG file format                    */
 /*                                                                           */
 /*  Copyright (C) 2009-2019 Free Software Foundation, Inc.                   */
 /*                                                                           */
 /*  This library is free software, licensed under the terms of the GNU       */
 /*  General Public License as published by the Free Software Foundation,     */
 /*  either version 3 of the License, or (at your option) any later version.  */
 /*  You should have received a copy of the GNU General Public License        */
 /*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
 /*****************************************************************************/
 
 /*
  * dec_macros.h: decoding macros (for encode, print, free in the C files)
  * written by Felipe Castro
  * modified by Felipe Corrêa da Silva Sances
  * modified by Rodrigo Rodrigues da Silva
  * modified by Reini Urban
  * modified by Denis Pruchkovsky
  */
 
 #ifndef DEC_MACROS_H
 #define DEC_MACROS_H
 
 #include "config.h"
 #ifdef HAVE_CTYPE_H
 #  include <ctype.h>
 #endif
 
 #ifdef IN_DXF_H
 #  error in_dxf.h must be included after dec_macros.h because of FORMAT_BD
 #endif
 
 // needed by decode, decode_r2007 and decode_r11
 #define ACTION decode
 #define IS_DECODER
 
 // redeclare versions to be from, not target
 #include "importer.h"
 
 #undef LOG_POS
 #define LOG_POS                                                               \
   LOG_INSANE (" @%lu.%u", obj ? dat->byte - obj->address : dat->byte,         \
               dat->bit)                                                       \
   LOG_TRACE ("\n")
 #define LOG_POS_(level)                                                       \
   LOG_INSANE (" @%lu.%u", obj ? dat->byte - obj->address : dat->byte,         \
               dat->bit)                                                       \
   LOG (level, "\n")
 
 #define LOG_RPOS                                                              \
   LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                                \
   LOG_TRACE ("\n")
 #define LOG_RPOS_(level)                                                      \
   LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                                \
   LOG (level, "\n")
 #define LOG_HPOS                                                              \
   LOG_INSANE (" @%lu.%u",                                                     \
               obj && hdl_dat->byte > obj->address                             \
                   ? hdl_dat->byte - obj->address                              \
                   : hdl_dat->byte,                                            \
               hdl_dat->bit)                                                   \
   LOG_TRACE ("\n")
 #define LOG_HPOS_(level)                                                      \
   LOG_INSANE (" @%lu.%u",                                                     \
               obj && hdl_dat->byte > obj->address                             \
                   ? hdl_dat->byte - obj->address                              \
                   : hdl_dat->byte,                                            \
               hdl_dat->bit)                                                   \
   LOG (level, "\n")
 
 #define VALUE(value, type, dxf)                                               \
   LOG_TRACE (FORMAT_##type " [" #type " %d]\n", (BITCODE_##type)value, dxf)
 #define VALUE_RC(value, dxf) VALUE (value, RC, dxf)
 #define VALUE_BS(value, dxf) VALUE (value, BS, dxf)
 #define VALUE_BL(value, dxf) VALUE (value, BL, dxf)
 #define VALUE_RS(value, dxf) VALUE (value, RS, dxf)
 #define VALUE_RL(value, dxf) VALUE (value, RL, dxf)
 #define VALUE_RD(value, dxf) VALUE (value, RD, dxf)
 #define VALUE_BD(value, dxf) VALUE (value, BD, dxf)
 
 #define FIELDG(nam, type, dxf)                                                \
   {                                                                           \
     _obj->nam = bit_read_##type (dat);                                        \
     FIELD_G_TRACE (nam, type, dxf);                                           \
   }
 
 #define FIELD(nam, type)                                                      \
   {                                                                           \
     _obj->nam = bit_read_##type (dat);                                        \
     FIELD_TRACE (nam, type);                                                  \
   }
 #define SUB_FIELD(o, nam, type, dxf)                                          \
   {                                                                           \
     _obj->o.nam = bit_read_##type (dat);                                      \
     FIELD_G_TRACE (o.nam, type, dxf);                                         \
   }
 
 #define FIELD_CAST(nam, type, cast, dxf)                                      \
   {                                                                           \
     _obj->nam = (BITCODE_##cast)bit_read_##type (dat);                        \
     FIELD_G_TRACE (nam, type, dxf);                                           \
   }
 #define SUB_FIELD_CAST(o, nam, type, cast, dxf)                               \
   {                                                                           \
     _obj->o.nam = (BITCODE_##cast)bit_read_##type (dat);                      \
     FIELD_G_TRACE (o.nam, type, dxf);                                         \
   }
 
 #define FIELD_G_TRACE(nam, type, dxfgroup)                                    \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       char *s1 = strrplc (#nam, "[rcount1]", "[%d]");                         \
       if (s1)                                                                 \
         {                                                                     \
           char *s2 = strrplc (s1, "[rcount2]", "[%d]");                       \
           if (s2)                                                             \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s2, ": " FORMAT_##type " [" #type " %d]"),   \
                          rcount1, rcount2, _obj->nam, dxfgroup);              \
               GCC46_DIAG_RESTORE                                              \
               free (s2);                                                      \
               free (s1);                                                      \
             }                                                                 \
           else                                                                \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s1, ": " FORMAT_##type " [" #type " %d]"),   \
                          rcount1, _obj->nam, dxfgroup);                       \
               GCC46_DIAG_RESTORE                                              \
               free (s1);                                                      \
             }                                                                 \
         }                                                                     \
       else                                                                    \
         LOG_TRACE (#nam ": " FORMAT_##type " [" #type " %d]",                 \
                    (BITCODE_##type)_obj->nam, dxfgroup);                      \
       LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                            \
       LOG_TRACE ("\n")                                                        \
     }
 
 #define FIELD_TRACE(nam, type)                                                \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       char *s1 = strrplc (#nam, "[rcount1]", "[%d]");                         \
       if (s1)                                                                 \
         {                                                                     \
           char *s2 = strrplc (s1, "[rcount2]", "[%d]");                       \
           if (s2)                                                             \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s2, ": " FORMAT_##type " " #type "\n"),      \
                          rcount1, rcount2, _obj->nam)                         \
               GCC46_DIAG_RESTORE                                              \
               free (s2);                                                      \
               free (s1);                                                      \
             }                                                                 \
           else                                                                \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s1, ": " FORMAT_##type " " #type "\n"),      \
                          rcount1, _obj->nam)                                  \
               GCC46_DIAG_RESTORE                                              \
               free (s1);                                                      \
             }                                                                 \
         }                                                                     \
       else                                                                    \
         {                                                                     \
           LOG_TRACE (#nam ": " FORMAT_##type " [" #type "]\n", _obj->nam)     \
         }                                                                     \
     }
 #define LOG_TF(level, var, len)                                               \
   {                                                                           \
     if (var && (DWG_LOGLEVEL >= DWG_LOGLEVEL_##level || len <= 256))          \
       {                                                                       \
         for (int _i = 0; _i < (len); _i++)                                    \
           {                                                                   \
             LOG (level, "%02X", (unsigned char)((char *)var)[_i]);            \
           }                                                                   \
         LOG (level, "\n");                                                    \
       }                                                                       \
     if (var && (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE))                         \
       {                                                                       \
         for (int _i = 0; _i < (len); _i++)                                    \
           {                                                                   \
             unsigned char c = ((unsigned char *)var)[_i];                     \
             LOG_INSANE ("%-2c", isprint (c) ? c : ' ');                       \
           }                                                                   \
         LOG_INSANE ("\n");                                                    \
       }                                                                       \
   }
 #define LOG_TRACE_TF(var, len) LOG_TF (TRACE, var, len)
 #define LOG_INSANE_TF(var, len) LOG_TF (INSANE, var, len)
 
 #define FIELD_2PT_TRACE(nam, type, dxf)                                       \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       char *s1 = strrplc (#nam, "[rcount1]", "[%d]");                         \
       if (s1)                                                                 \
         {                                                                     \
           char *s2 = strrplc (s1, "[rcount2]", "[%d]");                       \
           if (s2)                                                             \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s2, ": (" FORMAT_BD ", " FORMAT_BD           \
                                      ") [" #type " %d]"),                     \
                          rcount1, rcount2, _obj->nam.x, _obj->nam.y, dxf)     \
               GCC46_DIAG_RESTORE                                              \
               free (s2);                                                      \
               free (s1);                                                      \
             }                                                                 \
           else                                                                \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s1, ": (" FORMAT_BD ", " FORMAT_BD           \
                                      ") [" #type " %d]"),                     \
                          rcount1, _obj->nam.x, _obj->nam.y, dxf)              \
               GCC46_DIAG_RESTORE                                              \
               free (s1);                                                      \
             }                                                                 \
         }                                                                     \
       else                                                                    \
         {                                                                     \
           LOG_TRACE (#nam ": (" FORMAT_BD ", " FORMAT_BD ") [" #type " %d]",  \
                      _obj->nam.x, _obj->nam.y, dxf)                           \
         }                                                                     \
       LOG_POS;                                                                \
     }
 #define FIELD_3PT_TRACE(nam, type, dxf)                                       \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       char *s1 = strrplc (#nam, "[rcount1]", "[%d]");                         \
       if (s1)                                                                 \
         {                                                                     \
           char *s2 = strrplc (s1, "[rcount2]", "[%d]");                       \
           if (s2)                                                             \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s2, ": (" FORMAT_BD ", " FORMAT_BD           \
                                      ", " FORMAT_BD ") [" #type " %d]"),      \
                          rcount1, rcount2, _obj->nam.x, _obj->nam.y,          \
                          _obj->nam.z, dxf)                                    \
               GCC46_DIAG_RESTORE                                              \
               free (s2);                                                      \
               free (s1);                                                      \
             }                                                                 \
           else                                                                \
             {                                                                 \
               GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \
               LOG_TRACE (strcat (s1, ": (" FORMAT_BD ", " FORMAT_BD           \
                                      ", " FORMAT_BD ") [" #type " %d]"),      \
                          rcount1, _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf) \
               GCC46_DIAG_RESTORE                                              \
               free (s1);                                                      \
             }                                                                 \
         }                                                                     \
       else                                                                    \
         {                                                                     \
           LOG_TRACE (#nam ": (" FORMAT_BD ", " FORMAT_BD ", " FORMAT_BD       \
                           ") [" #type " %d]",                                 \
                      _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf)              \
         }                                                                     \
       LOG_POS;                                                                \
     }
 
 #define FIELD_VALUE(nam) _obj->nam
 
 #define ANYCODE -1
 #define VALUE_HANDLE(ref, nam, code, dxf)                                     \
   {                                                                           \
     PRE (R_13b1)                                                              \
     {                                                                         \
       if (ref)                                                                \
         free (ref);                                                           \
       ref = dwg_decode_preR13_handleref (dat, code);                          \
       LOG_TRACE (#nam ": %hd [H(%s) %d]\n", (short)ref->r11_idx,              \
                  code == 2 ? "RSd" : "RC", dxf)                               \
     }                                                                         \
     LATER_VERSIONS                                                            \
     {                                                                         \
       unsigned long _pos = bit_position (hdl_dat);                            \
       if (code >= 0)                                                          \
         ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);       \
       else                                                                    \
         ref = dwg_decode_handleref (hdl_dat, obj, dwg);                       \
       if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                 \
         {                                                                     \
           if (ref)                                                            \
             {                                                                 \
               LOG_TRACE (#nam ": " FORMAT_REF " [H %d]", ARGS_REF (ref),      \
                          dxf);                                                \
               if (dwg_ref_object_silent (dwg, ref)                            \
                   && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                       \
                 {                                                             \
                   int alloced;                                                \
                   const char *u8 = dwg_ref_tblname (dwg, ref, &alloced);      \
                   if (u8 && *u8)                                              \
                     HANDLER (OUTPUT, " => %s %s", dwg_ref_objname (dwg, ref), \
                              u8);                                             \
                   if (u8 && alloced)                                          \
                     free ((void *)u8);                                        \
                 }                                                             \
             }                                                                 \
           else                                                                \
             {                                                                 \
               HANDLER (OUTPUT, #nam ": NULL %d [H %d]", code, dxf);           \
             }                                                                 \
           LOG_INSANE (" @%lu.%u", _pos / 8, (unsigned)(_pos % 8));            \
           HANDLER (OUTPUT, "\n");                                             \
         }                                                                     \
     }                                                                         \
   }
 #define FIELD_HANDLE(nam, code, dxf) VALUE_HANDLE (_obj->nam, nam, code, dxf)
 #define SUB_FIELD_HANDLE(o, nam, code, dxf)                                   \
   VALUE_HANDLE (_obj->o.nam, o.nam, code, dxf)
 #define VALUE_H(hdl, dxf)                                                     \
   {                                                                           \
     PRE (R_13b1) { error |= bit_read_H (dat, &hdl); }                         \
     else                                                                      \
     {                                                                         \
       error |= bit_read_H (hdl_dat, &hdl);                                    \
     }                                                                         \
     LOG_TRACE ("handle: " FORMAT_H " [H %d]\n", ARGS_H (hdl), dxf);           \
   }
 
 #define VALUE_HANDLE_N(ref, nam, vcount, code, dxf)                           \
   {                                                                           \
     PRE (R_13b1)                                                              \
     {                                                                         \
       ref = dwg_decode_preR13_handleref (dat, code);                          \
       LOG_TRACE (#nam "[%d]: " FORMAT_RS " [RS %d]\n", (int)vcount,           \
                  ref->r11_idx, dxf);                                          \
     }                                                                         \
     LATER_VERSIONS                                                            \
     {                                                                         \
       unsigned long pos = bit_position (hdl_dat);                             \
       if (code >= 0)                                                          \
         ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);       \
       else                                                                    \
         ref = dwg_decode_handleref (hdl_dat, obj, dwg);                       \
       if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                 \
         {                                                                     \
           if (ref)                                                            \
             {                                                                 \
               LOG_TRACE (#nam "[%d]: " FORMAT_REF " [H* %d]", (int)vcount,    \
                          ARGS_REF (ref), dxf);                                \
               if (dwg_ref_object_silent (dwg, ref)                            \
                   && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                       \
                 {                                                             \
                   int alloced;                                                \
                   const char *u8 = dwg_ref_tblname (dwg, ref, &alloced);      \
                   HANDLER (OUTPUT, " => %s %s", dwg_ref_objname (dwg, ref),   \
                            u8);                                               \
                   if (alloced)                                                \
                     free ((void *)u8);                                        \
                 }                                                             \
             }                                                                 \
           else                                                                \
             {                                                                 \
               LOG_TRACE (#nam "[%d]: NULL %d [H* %d]", (int)vcount, code,     \
                          dxf);                                                \
             }                                                                 \
           LOG_INSANE (" @%lu.%u", pos / 8, (unsigned)(pos % 8));              \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
     }                                                                         \
   }
 #define FIELD_HANDLE_N(nam, vcount, code, dxf)                                \
   VALUE_HANDLE_N (_obj->nam, nam, vcount, code, dxf)
 
 #define FIELD_DATAHANDLE(nam, code, dxf)                                      \
   {                                                                           \
     _obj->nam = dwg_decode_handleref (dat, obj, dwg);                         \
     if (_obj->nam)                                                            \
       {                                                                       \
         LOG_TRACE (#nam ": " FORMAT_H " [H %d]\n",                            \
                    ARGS_H (_obj->nam->handleref), dxf);                       \
       }                                                                       \
   }
 
 #define FIELD_B(nam, dxf) FIELDG (nam, B, dxf)
 #define FIELD_BB(nam, dxf) FIELDG (nam, BB, dxf)
 #define FIELD_3B(nam, dxf) FIELDG (nam, 3B, dxf)
 #define FIELD_BS(nam, dxf) FIELDG (nam, BS, dxf)
 #define FIELD_BL(nam, dxf) FIELDG (nam, BL, dxf)
 #define FIELD_BLL(nam, dxf) FIELDG (nam, BLL, dxf)
 #define FIELD_BD(nam, dxf)                                                    \
   {                                                                           \
     _obj->nam = bit_read_BD (dat);                                            \
     if (bit_isnan (_obj->nam))                                                \
       {                                                                       \
         FIELD_G_TRACE (nam, BD, dxf);                                         \
         LOG_ERROR ("Invalid BD " #nam);                                       \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     if (dxf >= 50 && dxf < 54)                                                \
       {                                                                       \
         LOG_TRACE (#nam ": " FORMAT_BD " [BD %d]  %gº\n", _obj->nam, dxf,     \
                    rad2deg (_obj->nam));                                      \
       }                                                                       \
     else                                                                      \
       {                                                                       \
         FIELD_G_TRACE (nam, BD, dxf);                                         \
       }                                                                       \
   }
 #define FIELD_BLx(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_BL (dat);                                            \
     LOG_TRACE (#nam ": 0x%x [BLx %d]\n", (uint32_t)_obj->nam, dxf);           \
   }
 #define FIELD_RLx(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_RL (dat);                                            \
     LOG_TRACE (#nam ": 0x%x [RLx %d]\n", (uint32_t)_obj->nam, dxf);           \
   }
 #define FIELD_BSx(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_BS (dat);                                            \
     LOG_TRACE (#nam ": 0x%x [BSx %d]\n", _obj->nam, dxf);                     \
   }
 #define FIELD_RSd(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = (BITCODE_RSd)bit_read_RS (dat);                               \
     LOG_TRACE (#nam ": " FORMAT_RSd " [RSd %d]\n", _obj->nam, dxf);           \
   }
 #define FIELD_BSd(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = (BITCODE_BSd)bit_read_BS (dat);                               \
     LOG_TRACE (#nam ": " FORMAT_BSd " [BSd %d]\n", _obj->nam, dxf);           \
   }
 #define SUB_FIELD_BSd(o, nam, dxf)                                            \
   {                                                                           \
     _obj->o.nam = (BITCODE_BSd)bit_read_BS (dat);                             \
     LOG_TRACE (#o "." #nam ": " FORMAT_BSd " [BSd %d]\n", _obj->o.nam, dxf);  \
   }
 #define FIELD_BLd(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_BL (dat);                                            \
     LOG_TRACE (#nam ": " FORMAT_BLd " [BLd %d]\n", _obj->nam, dxf);           \
   }
 #define FIELD_RLd(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = (BITCODE_RLd)bit_read_RL (dat);                               \
     LOG_TRACE (#nam ": " FORMAT_RLd " [RLd %d]\n", _obj->nam, dxf);           \
   }
 #define FIELD_RC(nam, dxf)                                                    \
   {                                                                           \
     _obj->nam = bit_read_RC (dat);                                            \
     LOG_TRACE (#nam ": " FORMAT_RC " [RC %d]", ((BITCODE_RC)_obj->nam), dxf); \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
   }
 #define FIELD_RCu(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_RC (dat);                                            \
     LOG_TRACE (#nam ": %u [RC %d]", (unsigned)((unsigned char)_obj->nam),     \
                dxf);                                                          \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
   }
 #define FIELD_RCx(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_RC (dat);                                            \
     LOG_TRACE (#nam ": 0x%x [RCx %d]\n", (unsigned)_obj->nam, dxf);           \
   }
 #define FIELD_RCd(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = (BITCODE_RCd)bit_read_RC (dat);                               \
     LOG_TRACE (#nam ": %d [RC %d]\n", (int)((signed char)_obj->nam), dxf);    \
   }
 #define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)
 #define FIELD_RSx(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_RS (dat);                                            \
     LOG_TRACE (#nam ": " FORMAT_RSx " [RSx %d]\n", _obj->nam, dxf);           \
   }
 #define FIELD_RD(nam, dxf)                                                    \
   {                                                                           \
     FIELDG (nam, RD, dxf);                                                    \
     if (bit_isnan (_obj->nam))                                                \
       {                                                                       \
         LOG_ERROR ("Invalid RD " #nam);                                       \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
   }
 #define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)
 #define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)
 #define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)
 #define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)
 /* preR13 we have no obj->address and obj->size yet, skip VECTOR_CHKCOUNT */
 // clang-format off
 #define FIELD_TF(nam, len, dxf)                                               \
   {                                                                           \
     SINCE (R_13b1) { _obj->nam = NULL; VECTOR_CHKCOUNT (nam, TF, len, dat) }  \
     _obj->nam = bit_read_TF (dat, (int)len);                                  \
     LOG_TRACE (#nam ": \"%s\" [TF %lu " #dxf "]", _obj->nam,                  \
                (unsigned long)len);                                           \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
     LOG_TRACE_TF (FIELD_VALUE (nam), (int)len);                              \
   }
 #define FIELD_TFv(nam, len, dxf)                                              \
   {                                                                           \
     /* if (_obj->nam) free (_obj->nam); // preR13 add_Document defaults */    \
     SINCE (R_13b1) { _obj->nam = NULL; VECTOR_CHKCOUNT (nam, TF, len, dat) }  \
     _obj->nam = (BITCODE_TV)bit_read_TF (dat, (int)len);                      \
     LOG_TRACE (#nam ": \"%s\" [TFv %lu " #dxf "]", _obj->nam,                 \
                (unsigned long)len);                                           \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
     LOG_TRACE_TF (FIELD_VALUE (nam), (int)len);                              \
   }
 #define FIELD_TFF(nam, len, dxf)                                              \
   {                                                                           \
     SINCE (R_13b1) { _VECTOR_CHKCOUNT_STATIC (nam, len, 8, dat) }             \
     bit_read_fixed (dat, _obj->nam, (int)len);                                \
     LOG_TRACE (#nam ": \"%.*s\" [TFF %d " #dxf "]", (int)len, _obj->nam, (int)len); \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
     LOG_TRACE_TF (FIELD_VALUE (nam), (int)len);                              \
   }
 #define FIELD_TFFx(nam, len, dxf)                                             \
   {                                                                           \
     SINCE (R_13b1) { _VECTOR_CHKCOUNT_STATIC (nam, len, 8, dat) }             \
     bit_read_fixed (dat, (BITCODE_RC*)_obj->nam, (int)len);                   \
     LOG_TRACE (#nam ": [TFFx %d " #dxf "]", (int)len);                        \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
     LOG_TRACE_TF ((BITCODE_RC*)_obj->nam, (int)len);                         \
   }
 #define FIELD_T16(nam, dxf) FIELDG (nam, T16, dxf)
 #define FIELD_TU16(nam, dxf)                                                  \
   {                                                                           \
     _obj->nam = bit_read_TU16 (dat);                                          \
     LOG_TRACE_TU (#nam, FIELD_VALUE (nam), dxf);                              \
   }
 #define FIELD_TU32(nam, dxf)                                                  \
   {                                                                           \
     _obj->nam = bit_read_TU32 (dat);                                          \
     if (dat->from_version < R_2007)                                           \
       {                                                                       \
         LOG_TRACE (#nam ": \"%s\" [TU32 %d]\n", _obj->nam, dxf)               \
       }                                                                       \
     else                                                                      \
       {                                                                       \
         LOG_TRACE_TU (#nam, FIELD_VALUE (nam), dxf)                           \
       }                                                                       \
   }
 #define FIELD_T32(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam = bit_read_T32 (dat);                                           \
     if (dat->from_version < R_2007)                                           \
       {                                                                       \
         LOG_TRACE (#nam ": \"%s\" [T32 %d]\n", _obj->nam, dxf);               \
       }                                                                       \
     else                                                                      \
       {                                                                       \
         LOG_TRACE_TU (#nam, FIELD_VALUE (nam), dxf)                           \
       }                                                                       \
   }
 #define FIELD_TV(nam, dxf)                                                    \
   {                                                                           \
     _obj->nam = bit_read_TV (dat);                                            \
     LOG_TRACE (#nam ": \"%s\" [TV %d]", _obj->nam, dxf);                      \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                              \
     LOG_TRACE ("\n")                                                          \
   }
 #define FIELD_TU(nam, dxf)                                                    \
   {                                                                           \
     _obj->nam = (BITCODE_TU)bit_read_TU (str_dat);                            \
     LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf);                  \
   }
 // clang-format on
 #define FIELD_T(nam, dxf)                                                     \
   {                                                                           \
     if (dat->from_version < R_2007)                                           \
       {                                                                       \
         _obj->nam = bit_read_TV (dat);                                        \
         LOG_TRACE (#nam ": \"%s\" [T %d]", _obj->nam, dxf)                    \
         LOG_POS;                                                              \
       }                                                                       \
     else                                                                      \
       {                                                                       \
         if (!obj || obj->has_strings) /* header_vars */                       \
           {                                                                   \
             _obj->nam = (BITCODE_T)bit_read_TU (str_dat);                     \
             LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf)           \
           }                                                                   \
         else                                                                  \
           {                                                                   \
             LOG_TRACE_TU (#nam, L"", dxf);                                    \
             LOG_INSANE (" !has_strings\n")                                    \
           }                                                                   \
       }                                                                       \
   }
 #define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf)
 #define FIELD_4BITS(nam, dxf)                                                 \
   {                                                                           \
     int _b = _obj->nam = bit_read_4BITS (dat);                                \
     LOG_TRACE (#nam ": b%d%d%d%d [4BITS %d]\n", _b & 8, _b & 4, _b & 2,       \
                _b & 1, dxf);                                                  \
   }
 
 #define FIELD_BE(nam, dxf)                                                    \
   {                                                                           \
     bit_read_BE (dat, &_obj->nam.x, &_obj->nam.y, &_obj->nam.z);              \
     if (_obj->nam.z != 1.0)                                                   \
       {                                                                       \
         LOG_TRACE (#nam ": (%f, %f, %f) [BE %d]\n", _obj->nam.x, _obj->nam.y, \
                    _obj->nam.z, dxf);                                         \
         LOG_POS;                                                              \
       }                                                                       \
   }
 #define TRACE_DD                                                              \
   {                                                                           \
     BITCODE_BB result;                                                        \
     BITCODE_RC byte;                                                          \
     if ((dat->byte * 8) + 8 + dat->bit > dat->size * 8)                       \
       {                                                                       \
         loglevel = dat->opts & DWG_OPTS_LOGLEVEL;                             \
         LOG_ERROR ("%s FIELD_DD buffer overflow at pos %lu.%u, size %lu,"     \
                    " advance by 8",                                           \
                    __FUNCTION__, dat->byte, dat->bit, dat->size);             \
       }                                                                       \
     byte = dat->chain[dat->byte];                                             \
     if (dat->bit < 7)                                                         \
       result = (byte & (0xc0 >> dat->bit)) >> (6 - dat->bit);                 \
     else                                                                      \
       {                                                                       \
         result = (byte & 0x01) << 1;                                          \
         if (dat->byte < dat->size - 1)                                        \
           {                                                                   \
             byte = dat->chain[dat->byte + 1];                                 \
             result |= (byte & 0x80) >> 7;                                     \
           }                                                                   \
       }                                                                       \
     LOG_HANDLE ("DD code %u\n", result)                                       \
   }
 #define FIELD_DD(nam, _default, dxf)                                          \
   {                                                                           \
     TRACE_DD                                                                  \
     FIELD_VALUE (nam) = bit_read_DD (dat, _default);                          \
     if (bit_isnan (_obj->nam))                                                \
       {                                                                       \
         LOG_ERROR ("Invalid DD " #nam);                                       \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
   }
 #define FIELD_2DD(nam, def, dxf)                                              \
   {                                                                           \
     FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                               \
     FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                          \
     FIELD_2PT_TRACE (nam, 2DD, dxf);                                          \
   }
 #define FIELD_3DD(nam, def, dxf)                                              \
   {                                                                           \
     FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                               \
     FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                          \
     FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                          \
     FIELD_3PT_TRACE (nam, 3DD, dxf);                                          \
   }
 #define FIELD_3RD(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam.x = bit_read_RD (dat);                                          \
     _obj->nam.y = bit_read_RD (dat);                                          \
     _obj->nam.z = bit_read_RD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \
         || bit_isnan (_obj->nam.z))                                           \
       {                                                                       \
         LOG_ERROR ("Invalid 3RD " #nam);                                      \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_3PT_TRACE (nam, 3RD, dxf);                                          \
   }
 #define FIELD_3BD(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam.x = bit_read_BD (dat);                                          \
     _obj->nam.y = bit_read_BD (dat);                                          \
     _obj->nam.z = bit_read_BD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \
         || bit_isnan (_obj->nam.z))                                           \
       {                                                                       \
         LOG_ERROR ("Invalid 3BD " #nam);                                      \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_3PT_TRACE (nam, 3BD, dxf);                                          \
   }
 #define FIELD_2RD(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam.x = bit_read_RD (dat);                                          \
     _obj->nam.y = bit_read_RD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \
       {                                                                       \
         LOG_ERROR ("Invalid 2RD " #nam);                                      \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_2PT_TRACE (nam, 2RD, dxf);                                          \
   }
 // FIXME: does this even exist? normal 2DPOINT is 2RD
 //   HATCH.deflines.pt0,offset LAYOUT.plot_origin,plot_window_{ll,ur},
 //   LAYOUT.paper_image_origin GEODATA.northdir, GEODATA.refpt0,1 .zero1, zero2
 //   BACKGROUND.offset,scale
 #define FIELD_2BD(nam, dxf)                                                   \
   {                                                                           \
     _obj->nam.x = bit_read_BD (dat);                                          \
     _obj->nam.y = bit_read_BD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \
       {                                                                       \
         LOG_ERROR ("Invalid 2BD " #nam);                                      \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_2PT_TRACE (nam, 2BD, dxf);                                          \
   }
 #define FIELD_2BD_1(nam, dxf)                                                 \
   {                                                                           \
     _obj->nam.x = bit_read_BD (dat);                                          \
     _obj->nam.y = bit_read_BD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \
       {                                                                       \
         LOG_ERROR ("Invalid 2BD_1 " #nam);                                    \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_2PT_TRACE (nam, 2BD_1, dxf);                                        \
   }
 // FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);
 #define FIELD_3BD_1(nam, dxf)                                                 \
   {                                                                           \
     _obj->nam.x = bit_read_BD (dat);                                          \
     _obj->nam.y = bit_read_BD (dat);                                          \
     _obj->nam.z = bit_read_BD (dat);                                          \
     if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \
         || bit_isnan (_obj->nam.z))                                           \
       {                                                                       \
         LOG_ERROR ("Invalid 3BD_1 " #nam);                                    \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     FIELD_3PT_TRACE (nam, 3BD_1, dxf);                                        \
   }
 //    FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);
 //    FIELDG(nam.z, BD, dxf+2); }
 #define FIELD_2DPOINT(nam, dxf) FIELD_2RD (nam, dxf)
 #define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)
 #define FIELD_3DVECTOR(nam, dxf) FIELD_3BD_1 (nam, dxf)
 #define FIELD_TIMEBLL(nam, dxf)                                               \
   {                                                                           \
     _obj->nam = bit_read_TIMEBLL (dat);                                       \
     if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \
       {                                                                       \
         struct tm tm;                                                         \
         char _buf[60] = "";                                                   \
         if (_obj->nam.days)                                                   \
           strftime (_buf, 60, STRFTIME_DATE, cvt_TIMEBLL (&tm, _obj->nam));   \
         else                                                                  \
           strftime (_buf, 60, STRFTIME_TIME, cvt_TIMEBLL (&tm, _obj->nam));   \
         LOG_TRACE (#nam ": [" FORMAT_BL ", " FORMAT_BL "] %s [TIMEBLL %d]",   \
                    _obj->nam.days, _obj->nam.ms, _buf, dxf);                  \
         LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                          \
         LOG_TRACE ("\n")                                                      \
       }                                                                       \
   }
 #define FIELD_TIMERLL(nam, dxf)                                               \
   {                                                                           \
     _obj->nam = bit_read_TIMERLL (dat);                                       \
     if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \
       {                                                                       \
         struct tm tm;                                                         \
         char _buf[60] = "";                                                   \
         if (_obj->nam.days)                                                   \
           strftime (_buf, 60, STRFTIME_DATE, cvt_TIMEBLL (&tm, _obj->nam));   \
         else                                                                  \
           strftime (_buf, 60, STRFTIME_TIME, cvt_TIMEBLL (&tm, _obj->nam));   \
         LOG_TRACE (#nam ": [" FORMAT_RL ", " FORMAT_RL "] %s [TIMERLL %d]",   \
                    _obj->nam.days, _obj->nam.ms, _buf, dxf);                  \
         LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                          \
         LOG_TRACE ("\n")                                                      \
       }                                                                       \
   }
 #define FIELD_CMC(color, dxf)                                                 \
   {                                                                           \
     error |= bit_read_CMC (dat, str_dat, &_obj->color);                       \
     LOG_TRACE (#color ".index: %d [CMC.BS %d]", _obj->color.index, dxf);      \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit);                             \
     LOG_TRACE ("\n");                                                         \
     if (dat->from_version >= R_2004)                                          \
       {                                                                       \
         LOG_TRACE (#color ".rgb: 0x%06x [CMC.BL %d]\n",                       \
                    (unsigned)_obj->color.rgb, dxf + 420 - 62);                \
         LOG_TRACE (#color ".method: 0x%x %s\n", _obj->color.method,           \
                    dwg_color_method_name (_obj->color.method));               \
         LOG_TRACE (#color ".flag: 0x%x [CMC.RC]\n",                           \
                    (unsigned)_obj->color.flag);                               \
         if (_obj->color.flag & 1)                                             \
           {                                                                   \
             LOG_TRACE (#color ".name: %s [CMC.%s]\n", _obj->color.name,       \
                        dat->from_version >= R_2007 ? "T" : "TV");             \
           }                                                                   \
         if (_obj->color.flag & 2)                                             \
           {                                                                   \
             LOG_TRACE (#color ".book_name: %s [CMC.%s\n",                     \
                        _obj->color.book_name,                                 \
                        dat->from_version >= R_2007 ? "T" : "TV");             \
           }                                                                   \
       }                                                                       \
   }
 #define SUB_FIELD_CMC(o, color, dxf)                                          \
   {                                                                           \
     error |= bit_read_CMC (dat, str_dat, &_obj->o.color);                     \
     LOG_TRACE (#o "." #color ".index: %d [CMC.BS %d]", _obj->o.color.index,   \
                dxf);                                                          \
     LOG_INSANE (" @%lu.%u", dat->byte, dat->bit);                             \
     LOG_TRACE ("\n");                                                         \
     if (dat->from_version >= R_2004)                                          \
       {                                                                       \
         LOG_TRACE (#o "." #color ".rgb: 0x%06x [CMC.BL %d]\n",                \
                    (unsigned)_obj->o.color.rgb, dxf + 420 - 62);              \
         LOG_TRACE (#color ".method: 0x%x %s\n", _obj->o.color.method,         \
                    dwg_color_method_name (_obj->o.color.method));             \
         LOG_TRACE (#o "." #color ".flag: 0x%x [CMC.RC]\n",                    \
                    (unsigned)_obj->o.color.flag);                             \
         if (_obj->o.color.flag & 1)                                           \
           {                                                                   \
             LOG_TRACE (#o "." #color ".name: %s [CMC.%s]\n",                  \
                        _obj->o.color.name,                                    \
                        dat->from_version >= R_2007 ? "T" : "TV");             \
           }                                                                   \
         if (_obj->o.color.flag & 2)                                           \
           {                                                                   \
             LOG_TRACE (#o "." #color ".book_name: %s [CMC.%s]\n",             \
                        _obj->o.color.book_name,                               \
                        dat->from_version >= R_2007 ? "T" : "TV");             \
           }                                                                   \
       }                                                                       \
   }
 // force truecolor
 #define FIELD_CMTC(name, dxf)                                                 \
   {                                                                           \
     Dwg_Version_Type _ver = dat->from_version;                                \
     if (dat->from_version < R_2004)                                           \
       dat->from_version = R_2004;                                             \
     FIELD_CMC (name, dxf);                                                    \
     dat->from_version = _ver;                                                 \
   }
 #define SUB_FIELD_CMTC(o, name, dxf)                                          \
   {                                                                           \
     Dwg_Version_Type _ver = dat->from_version;                                \
     if (dat->from_version < R_2004)                                           \
       dat->from_version = R_2004;                                             \
     SUB_FIELD_CMC (o, name, dxf);                                             \
     dat->from_version = _ver;                                                 \
   }
 #define FIELD_ENC(color, dxf)                                                 \
   {                                                                           \
     bit_read_ENC (dat, hdl_dat, str_dat, &_obj->color);                       \
     LOG_TRACE (#color ".index: %d [ENC.BS %d]\n", _obj->color.index, dxf);    \
     if (dat->from_version >= R_2004)                                          \
       {                                                                       \
         if (_obj->color.flag)                                                 \
           LOG_TRACE (#color ".flag: 0x%x\n", (unsigned)_obj->color.flag);     \
         if (_obj->color.flag & 0x20)                                          \
           LOG_TRACE (#color ".alpha: %d [ENC.BL %d]\n",                       \
                      (int)_obj->color.alpha, dxf + 440 - 62);                 \
         if (_obj->color.flag & 0x80)                                          \
           LOG_TRACE (#color ".rgb: 0x%06x [ENC.BL %d]\n",                     \
                      (unsigned)_obj->color.rgb, dxf + 420 - 62);              \
         if (_obj->color.flag & 0x40 && _obj->color.handle)                    \
           LOG_TRACE (#color ".handle: %X [ENC.H %d]\n",                       \
                      _obj->color.handle->handleref.value, dxf + 430 - 62);    \
       }                                                                       \
   }
 #define SUB_FIELD_ENC(o, color, dxf)                                          \
   {                                                                           \
     bit_read_ENC (dat, hdl_dat, str_dat, &_obj->o.color);                     \
     LOG_TRACE (#o "." #color ".index: %d [ENC.BS %d]\n", _obj->o.color.index, \
                dxf);                                                          \
     if (dat->from_version >= R_2004)                                          \
       {                                                                       \
         if (_obj->o.color.flag)                                               \
           LOG_TRACE (#o "." #color ".flag: 0x%x\n",                           \
                      (unsigned)_obj->o.color.flag);                           \
         if (_obj->o.color.flag & 0x20)                                        \
           LOG_TRACE (#o "." #color ".alpha: %d [ENC.BL %d]\n",                \
                      (unsigned)_obj->o.color.alpha, dxf + 440 - 62);          \
         if (_obj->o.color.flag & 0x80)                                        \
           LOG_TRACE (#o "." #color ".rgb: 0x%06x [ENC.BL %d]\n",              \
                      (unsigned)_obj->o.color.rgb, dxf + 420 - 62);            \
         if (_obj->o.color.flag & 0x40 && _obj->o.color.handle)                \
           LOG_TRACE (#o "." #color ".handle: %lX [ENC.H %d]\n",               \
                      _obj->o.color.handle->handleref.value, dxf + 430 - 62);  \
       }                                                                       \
   }
 
 #undef DEBUG_POS
 #undef DEBUG_HERE
 #undef DEBUG_POS_OBJ
 #undef DEBUG_HERE_OBJ
 #define DEBUG_POS_OBJ                                                         \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       LOG_TRACE ("DEBUG_POS @%u.%u (%lu) %lu\n", (unsigned int)dat->byte,     \
                  dat->bit, bit_position (dat),                                \
                  obj ? bit_position (dat) - obj->address * 8 : 0);            \
     }
 #define DEBUG_POS                                                             \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       LOG_TRACE ("DEBUG_POS @%u.%u (%lu)\n", (unsigned int)dat->byte,         \
                  dat->bit, bit_position (dat));                               \
     }
 #define _DEBUG_HERE(objsize)                                                  \
   if (dat->size < dat->byte)                                                  \
     return DWG_ERR_VALUEOUTOFBOUNDS;                                          \
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \
     {                                                                         \
       Bit_Chain here = *dat;                                                  \
       int oldloglevel = loglevel;                                             \
       BITCODE_TF tmp;                                                         \
       BITCODE_BB bb = 0;                                                      \
       BITCODE_RS rs;                                                          \
       BITCODE_RL rl;                                                          \
       double bd;                                                              \
       Dwg_Handle hdl;                                                         \
       rs = 24;                                                                \
       if (objsize && dat->byte + 24 > objsize)                                \
         rs = objsize - dat->byte;                                             \
       tmp = bit_read_TF (dat, rs);                                            \
       if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                \
         {                                                                     \
           bit_fprint_bits (OUTPUT, tmp, rs * 8);                              \
           HANDLER (OUTPUT, "\n");                                             \
         }                                                                     \
       LOG_TRACE_TF (tmp, rs);                                                 \
       free (tmp);                                                             \
       SINCE (R_13b1)                                                          \
       {                                                                       \
         *dat = here;                                                          \
         LOG_TRACE ("  B  :" FORMAT_B "\t", bit_read_B (dat));                 \
         *dat = here;                                                          \
         bb = bit_read_BB (dat) & 0x3;                                         \
         LOG_TRACE ("  BB :" FORMAT_BB "\n", bb);                              \
       }                                                                       \
       *dat = here;                                                            \
       rs = bit_read_RS (dat);                                                 \
       LOG_TRACE ("  RS :" FORMAT_RS " / 0x%04x (16)\n", rs, rs);              \
       SINCE (R_13b1)                                                          \
       {                                                                       \
         *dat = here;                                                          \
         rs = bit_read_BS (dat);                                               \
         LOG_TRACE ("  BS :" FORMAT_BS " / 0x%04x (%ld)\t", rs, rs,            \
                    bit_position (dat) - bit_position (&here));                \
       }                                                                       \
       SINCE (R_2007)                                                          \
       {                                                                       \
         *dat = here;                                                          \
         rs = bit_read_MS (dat);                                               \
         LOG_TRACE ("  MS :" FORMAT_RS " / 0x%04x (%ld)\n", rs, rs,            \
                    bit_position (dat) - bit_position (&here));                \
       }                                                                       \
       else LOG_TRACE ("\n");                                                  \
       *dat = here;                                                            \
       rl = bit_read_RL (dat);                                                 \
       LOG_TRACE ("  RL :" FORMAT_RL " / 0x%08x (32)\n", rl, rl);              \
       *dat = here;                                                            \
       LOG_TRACE ("  RD :" FORMAT_RD " (64)\n", bit_read_RD (dat));            \
       *dat = here;                                                            \
       SINCE (R_13b1)                                                          \
       {                                                                       \
         if (bb != 3)                                                          \
           {                                                                   \
             rl = bit_read_BL (dat);                                           \
             LOG_TRACE ("  BL :" FORMAT_BL " / 0x%08x (%ld)\n", rl, rl,        \
                        bit_position (dat) - bit_position (&here));            \
             *dat = here;                                                      \
             bd = bit_read_BD (dat);                                           \
             LOG_TRACE ("  BD :" FORMAT_BD " (%ld)\n", bd,                     \
                        bit_position (dat) - bit_position (&here));            \
             *dat = here;                                                      \
           }                                                                   \
       }                                                                       \
       if ((dat->chain[dat->byte] & 0xf) <= 4)                                 \
         {                                                                     \
           loglevel = 0;                                                       \
           if (!bit_read_H (dat, &hdl))                                        \
             {                                                                 \
               LOG_TRACE ("  H : " FORMAT_H " (%ld)\n", ARGS_H (hdl),          \
                          bit_position (dat) - bit_position (&here));          \
             }                                                                 \
           loglevel = oldloglevel;                                             \
         }                                                                     \
       *dat = here;                                                            \
     }
 #define DEBUG_HERE_OBJ                                                        \
   DEBUG_POS_OBJ                                                               \
   _DEBUG_HERE (obj->size)
 #define DEBUG_HERE                                                            \
   DEBUG_POS                                                                   \
   _DEBUG_HERE (0)
 
 // check for overflow into next object (invalid num_elems)
 #define AVAIL_BITS(dat)                                                       \
   (obj ? (long long)((obj->size * 8) - bit_position (dat) + 20) : 0xff00LL)
 #define TYPE_MAXELEMSIZE(type) dwg_bits_size[BITS_##type]
 #define VECTOR_CHKCOUNT(nam, type, size, dat)                                 \
   if ((long long)(size) > AVAIL_BITS (dat)                                    \
       || (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))      \
     {                                                                         \
       LOG_ERROR ("Invalid " #nam " size %ld. Need min. %u bits for " #type    \
                  ", have %lld for %s.",                                       \
                  (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \
                  AVAIL_BITS (dat), SAFEDXFNAME);                              \
       if (_obj->nam)                                                          \
         free (_obj->nam);                                                     \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 #define SUB_VECTOR_CHKCOUNT(o, nam, type, size, dat)                          \
   if ((long long)(size) > AVAIL_BITS (dat)                                    \
       || (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))      \
     {                                                                         \
       LOG_ERROR ("Invalid " #nam " size %ld. Need min. %u bits for " #type    \
                  ", have %lld for %s.",                                       \
                  (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \
                  AVAIL_BITS (dat), SAFEDXFNAME);                              \
       if (_obj->o.nam)                                                        \
         free (_obj->o.nam);                                                   \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 #define VECTOR_CHKCOUNT_LV(nam, type, size, dat)                              \
   if ((long long)(size) > AVAIL_BITS (dat)                                    \
       || (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))      \
     {                                                                         \
       LOG_ERROR ("Invalid " #nam " size %ld. Need min. %u bits for " #type    \
                  ", have %lld for %s. Set " #size " to 0.",                   \
                  (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \
                  AVAIL_BITS (dat), SAFEDXFNAME);                              \
       if (_obj->nam)                                                          \
         free (_obj->nam);                                                     \
       size = 0;                                                               \
       /* return DWG_ERR_VALUEOUTOFBOUNDS; */                                  \
     }
 // for static TFF types with a size field
 #define _VECTOR_CHKCOUNT(nam, size, maxelemsize, dat)                         \
   if ((long long)(size) > AVAIL_BITS (dat)                                    \
       || (long long)((size) * (maxelemsize)) > AVAIL_BITS (dat))              \
     {                                                                         \
       LOG_ERROR ("Invalid " #nam                                              \
                  " size %ld. Need min. %u bits, have %lld for %s. "           \
                  "Set " #size " to 0",                                        \
                  (long)(size), (unsigned)(size) * (maxelemsize),              \
                  AVAIL_BITS (dat), SAFEDXFNAME);                              \
       size = 0;                                                               \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 // for static TFF types with fixed size
 #define _VECTOR_CHKCOUNT_STATIC(nam, siz, maxelemsize, dat)                   \
   if ((long long)(8 * siz) > AVAIL_BITS (dat)                                 \
       || (long long)((siz) * (maxelemsize)) > AVAIL_BITS (dat)                \
       || dat->byte + (siz) > dat->size)                                       \
     {                                                                         \
       LOG_ERROR ("Invalid " #nam                                              \
                  " size %ld. Need min. %u bits, have %lld for %s.",           \
                  (long)(siz), (unsigned)(siz) * (maxelemsize),                \
                  AVAIL_BITS (dat), SAFEDXFNAME);                              \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 #define HANDLE_VECTOR_CHKCOUNT(nam, size)                                     \
   _VECTOR_CHKCOUNT (nam, size, TYPE_MAXELEMSIZE (HANDLE), hdl_dat)
 
 // FIELD_VECTOR_N(name, type, size):
 // reads data of the type indicated by 'type' 'size' times and stores
 // it all in the vector called 'name'.
 #define FIELD_VECTOR_N(name, type, size, dxf)                                 \
   if (size > 0)                                                               \
     {                                                                         \
       VECTOR_CHKCOUNT (name, type, size, dat)                                 \
       _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           _obj->name[vcount] = bit_read_##type (dat);                         \
           LOG_TRACE (#name "[%ld]: " FORMAT_##type " [" #type "]\n",          \
                      (long)vcount, _obj->name[vcount])                        \
         }                                                                     \
     }
 #define SUB_FIELD_VECTOR_N(o, name, type, size, dxf)                          \
   if (size > 0)                                                               \
     {                                                                         \
       SUB_VECTOR_CHKCOUNT (o, name, type, size, dat)                          \
       _obj->o.name                                                            \
           = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));         \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           _obj->o.name[vcount] = bit_read_##type (dat);                       \
           LOG_TRACE (#name "[%ld]: " FORMAT_##type " [" #type "]\n",          \
                      (long)vcount, _obj->o.name[vcount])                      \
         }                                                                     \
     }
 #define SUB_FIELD_VECTOR(o, name, sizefield, type, dxf)                       \
   if (_obj->o.sizefield > 0)                                                  \
     {                                                                         \
       SUB_VECTOR_CHKCOUNT (o, name, type, _obj->o.sizefield, dat)             \
       _obj->o.name = (BITCODE_##type *)calloc (_obj->o.sizefield,             \
                                                sizeof (BITCODE_##type));      \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->o.sizefield; vcount++)      \
         {                                                                     \
           _obj->o.name[vcount] = bit_read_##type (dat);                       \
           LOG_TRACE (#name "[%ld]: " FORMAT_##type " [" #type "]\n",          \
                      (long)vcount, _obj->o.name[vcount])                      \
         }                                                                     \
     }
 // inlined, with const size and without malloc
 #define FIELD_VECTOR_INL(name, type, size, dxf)                               \
   if (size > 0)                                                               \
     {                                                                         \
       _VECTOR_CHKCOUNT_STATIC (name, size, TYPE_MAXELEMSIZE (type), dat)      \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           _obj->name[vcount] = bit_read_##type (dat);                         \
           LOG_TRACE (#name "[%ld]: " FORMAT_##type " [" #type "]\n",          \
                      (long)vcount, _obj->name[vcount])                        \
         }                                                                     \
     }
 // inlined, with const size and without malloc
 #define SUB_FIELD_VECTOR_INL(o, name, type, size, dxf)                        \
   if (size > 0)                                                               \
     {                                                                         \
       _VECTOR_CHKCOUNT_STATIC (name, size, TYPE_MAXELEMSIZE (type), dat)      \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           _obj->name[vcount] = bit_read_##type (dat);                         \
           LOG_TRACE (#name "[%ld]: " FORMAT_##type " [" #type "]\n",          \
                      (long)vcount, _obj->o.name[vcount])                      \
         }                                                                     \
     }
 #define FIELD_VECTOR_T(name, type, size, dxf)                                 \
   if (_obj->size > 0)                                                         \
     {                                                                         \
       _VECTOR_CHKCOUNT (name, _obj->size,                                     \
                         dat->from_version >= R_2007 ? 18 : 2, dat)            \
       _obj->name = (char **)calloc (_obj->size, sizeof (char *));             \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \
         {                                                                     \
           PRE (R_2007)                                                        \
           {                                                                   \
             _obj->name[vcount] = bit_read_TV (dat);                           \
             LOG_TRACE (#name "[%d]: \"%s\" [TV %d]", (int)vcount,             \
                        _obj->name[vcount], dxf)                               \
             LOG_POS                                                           \
           }                                                                   \
           LATER_VERSIONS                                                      \
           {                                                                   \
             _obj->name[vcount] = (char *)bit_read_##type (dat);               \
             LOG_TRACE_TU_I (#name, vcount, _obj->name[vcount], type, dxf)     \
           }                                                                   \
         }                                                                     \
     }
 #define FIELD_VECTOR_N1(name, type, size, dxf)                                \
   if (size > 0)                                                               \
     {                                                                         \
       int _dxf = dxf;                                                         \
       VECTOR_CHKCOUNT (name, type, size, dat)                                 \
       _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           _obj->name[vcount] = bit_read_##type (dat);                         \
           LOG_TRACE (#name "[%d]: " FORMAT_##type " [" #type " %d]\n",        \
                      (int)vcount, _obj->name[vcount], _dxf++)                 \
         }                                                                     \
     }
 
 #define FIELD_VECTOR(name, type, size, dxf)                                   \
   FIELD_VECTOR_N (name, type, _obj->size, dxf)
 
 #define SUB_FIELD_VECTOR_TYPESIZE(o, name, size, typesize, dxf)               \
   if (_obj->o.size > 0)                                                       \
     {                                                                         \
       _obj->o.name = calloc (_obj->o.size, typesize);                         \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)           \
         {                                                                     \
           switch (typesize)                                                   \
             {                                                                 \
             case 0:                                                           \
               break;                                                          \
             case 1:                                                           \
               _obj->o.name[vcount] = bit_read_RC (dat);                       \
               break;                                                          \
             case 2:                                                           \
               _obj->o.name[vcount] = bit_read_RS (dat);                       \
               break;                                                          \
             case 4:                                                           \
               _obj->o.name[vcount] = bit_read_RL (dat);                       \
               break;                                                          \
             case 8:                                                           \
               _obj->o.name[vcount] = bit_read_RLL (dat);                      \
               break;                                                          \
             default:                                                          \
               LOG_ERROR ("Unknown FIELD_VECTOR_TYPE " #name " typesize %d",   \
                          typesize);                                           \
               break;                                                          \
             }                                                                 \
           LOG_TRACE (#name "[%u]: %d\n", vcount, (int)_obj->o.name[vcount])   \
         }                                                                     \
     }
 
 #define FIELD_2RD_VECTOR(name, size, dxf)                                     \
   VECTOR_CHKCOUNT_LV (name, 2RD, _obj->size, dat)                             \
   if (_obj->size > 0)                                                         \
     {                                                                         \
       _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \
         {                                                                     \
           FIELD_2RD (name[vcount], dxf);                                      \
         }                                                                     \
     }                                                                         \
   else                                                                        \
     return DWG_ERR_VALUEOUTOFBOUNDS;
 
 #define SUB_FIELD_2RD_VECTOR(o, name, size, dxf)                              \
   VECTOR_CHKCOUNT_LV (o.name, 2RD, _obj->o.size, dat)                         \
   if (_obj->o.size > 0)                                                       \
     {                                                                         \
       _obj->o.name                                                            \
           = (BITCODE_2RD *)calloc (_obj->o.size, sizeof (BITCODE_2RD));       \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)           \
         {                                                                     \
           SUB_FIELD_2RD (o, name[vcount], dxf);                               \
         }                                                                     \
     }                                                                         \
   else                                                                        \
     return DWG_ERR_VALUEOUTOFBOUNDS;
 
 #define FIELD_2DD_VECTOR(name, size, dxf)                                     \
   VECTOR_CHKCOUNT_LV (name, 2DD, _obj->size, dat)                             \
   if (_obj->size > 0)                                                         \
     {                                                                         \
       _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \
       FIELD_2RD (name[0], dxf);                                               \
       for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)             \
         {                                                                     \
           BITCODE_BB b2, b1 = bit_read_BB_noadv (dat);                        \
           FIELD_DD (name[vcount].x, FIELD_VALUE (name[vcount - 1].x), dxf);   \
           b2 = bit_read_BB_noadv (dat);                                       \
           FIELD_DD (name[vcount].y, FIELD_VALUE (name[vcount - 1].y),         \
                     dxf + 10);                                                \
           if (b1 == 3 && b2 == 3)                                             \
             LOG_TRACE (#name "[%ld]: (" FORMAT_BD ", " FORMAT_BD              \
                              ") [2DD %d]",                                    \
                        (long)vcount, _obj->name[vcount].x,                    \
                        _obj->name[vcount].y, dxf)                             \
           else                                                                \
             LOG_TRACE (#name "[%ld]: (" FORMAT_BD ", " FORMAT_BD              \
                              ") [2DD/%d%d %d]",                               \
                        (long)vcount, _obj->name[vcount].x,                    \
                        _obj->name[vcount].y, b1, b2, dxf)                     \
           LOG_INSANE (" @%lu.%u", dat->byte, dat->bit)                        \
           LOG_TRACE ("\n")                                                    \
         }                                                                     \
     }                                                                         \
   else                                                                        \
     return DWG_ERR_VALUEOUTOFBOUNDS;
 
 #define FIELD_3DPOINT_VECTOR(name, size, dxf)                                 \
   VECTOR_CHKCOUNT_LV (name, 3BD, _obj->size, dat)                             \
   if (_obj->size > 0)                                                         \
     {                                                                         \
       _obj->name                                                              \
           = (BITCODE_3DPOINT *)calloc (_obj->size, sizeof (BITCODE_3DPOINT)); \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \
         {                                                                     \
           FIELD_3DPOINT (name[vcount], dxf);                                  \
         }                                                                     \
     }
 #define SUB_FIELD_3BD_VECTOR(o, name, size, dxf)                              \
   VECTOR_CHKCOUNT_LV (o.name, 3BD, _obj->o.size, dat)                         \
   if (_obj->o.size > 0)                                                       \
     {                                                                         \
       _obj->o.name                                                            \
           = (BITCODE_3BD *)calloc (_obj->o.size, sizeof (BITCODE_3BD));       \
       for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)           \
         {                                                                     \
           SUB_FIELD_3BD (o, name[vcount], dxf);                               \
         }                                                                     \
     }                                                                         \
   else                                                                        \
     return DWG_ERR_VALUEOUTOFBOUNDS;
 
 // shortest handle: 8 bit
 #define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \
   if (size > 0)                                                               \
     {                                                                         \
       FIELD_VALUE (nam) = (BITCODE_H *)calloc (size, sizeof (BITCODE_H));     \
       for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \
         {                                                                     \
           FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                    \
         }                                                                     \
     }
 
 #define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \
   VECTOR_CHKCOUNT_LV (nam, HANDLE, FIELD_VALUE (sizefield), hdl_dat)          \
   HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)
 
 #define SUB_HANDLE_VECTOR(o, nam, sizefield, code, dxf)                       \
   if (_obj->o.sizefield > 0)                                                  \
     {                                                                         \
       BITCODE_BL _size = _obj->o.sizefield;                                   \
       HANDLE_VECTOR_CHKCOUNT (nam, _size)                                     \
       _obj->o.nam = (BITCODE_H *)calloc (_size, sizeof (BITCODE_H));          \
       for (vcount = 0; vcount < _size; vcount++)                              \
         {                                                                     \
           SUB_FIELD_HANDLE (o, nam[vcount], code, dxf);                       \
         }                                                                     \
     }
 
 // count 1 bytes, until non-1 bytes or a terminating zero
 #define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \
   FIELD_VALUE (num_inserts) = 0;                                              \
   vcount = 0;                                                                 \
   while ((vcount = (BITCODE_RC)bit_read_RC (dat)))                            \
     {                                                                         \
       FIELD_VALUE (num_inserts)++;                                            \
       LOG_INSANE ("num_inserts [RC " FORMAT_RL "]: %d\n",                     \
                   FIELD_VALUE (num_inserts), (unsigned char)vcount)           \
       if (vcount != 1)                                                        \
         {                                                                     \
           LOG_WARN ("num_inserts [RC " FORMAT_RL "]: %d != 1",                \
                     FIELD_VALUE (num_inserts), (unsigned char)vcount)         \
           bit_advance_position (dat, -8);                                     \
           break;                                                              \
         }                                                                     \
     }                                                                         \
   LOG_TRACE ("num_inserts: %d [RC* 0]\n", FIELD_VALUE (num_inserts))
 
 #define FIELD_XDATA(name, xdata_size)                                         \
   _obj->name = dwg_decode_xdata (dat, _obj, _obj->xdata_size)
 
 #define REACTORS(code)                                                        \
   if (obj->tio.object->num_reactors > 0)                                      \
     {                                                                         \
       HANDLE_VECTOR_CHKCOUNT (reactors, obj->tio.object->num_reactors)        \
       obj->tio.object->reactors = (BITCODE_H *)calloc (                       \
           obj->tio.object->num_reactors, sizeof (BITCODE_H));                 \
       for (vcount = 0; vcount < obj->tio.object->num_reactors; vcount++)      \
         {                                                                     \
           VALUE_HANDLE_N (obj->tio.object->reactors[vcount], reactors,        \
                           vcount, code, 330);                                 \
         }                                                                     \
     }
 
 #define ENT_REACTORS(code)                                                    \
   if (_ent->num_reactors > 0)                                                 \
     {                                                                         \
       HANDLE_VECTOR_CHKCOUNT (reactors, _ent->num_reactors)                   \
       _ent->reactors                                                          \
           = (BITCODE_H *)calloc (_ent->num_reactors, sizeof (BITCODE_H));     \
       for (vcount = 0; vcount < _ent->num_reactors; vcount++)                 \
         {                                                                     \
           VALUE_HANDLE_N (_ent->reactors[vcount], reactors, vcount, code,     \
                           330);                                               \
         }                                                                     \
     }
 
 #define XDICOBJHANDLE(code)                                                   \
   SINCE (R_2004)                                                              \
   {                                                                           \
     if (!obj->tio.object->is_xdic_missing)                                    \
       {                                                                       \
         VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \
                       360);                                                   \
         if (!obj->tio.object->xdicobjhandle)                                  \
           obj->tio.object->is_xdic_missing = 1;                               \
       }                                                                       \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     SINCE (R_13b1)                                                            \
     {                                                                         \
       VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \
                     360);                                                     \
     }                                                                         \
   }
 
 #define ENT_XDICOBJHANDLE(code)                                               \
   SINCE (R_2004)                                                              \
   {                                                                           \
     if (!_ent->is_xdic_missing)                                               \
       {                                                                       \
         VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);         \
       }                                                                       \
   }                                                                           \
   else                                                                        \
   {                                                                           \
     SINCE (R_13b1)                                                            \
     {                                                                         \
       VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);           \
     }                                                                         \
   }
 
 #define UNKNOWN_UNTIL(pos)                                                    \
   if (dat->byte < pos)                                                        \
     {                                                                         \
       int len = pos - dat->byte;                                              \
       BITCODE_TF unknown = bit_read_TF (dat, len);                            \
       LOG_TRACE ("unknown (%d): ", len);                                      \
       LOG_TRACE_TF (unknown, len);                                            \
       free (unknown);                                                         \
     }                                                                         \
   dat->byte = pos
 
 #define SECTION_STRING_STREAM                                                 \
   {                                                                           \
     Bit_Chain sav_dat = *dat;                                                 \
     dat = str_dat;
 
 // TODO: unused
 #define START_STRING_STREAM                                                   \
   obj->has_strings = bit_read_B (dat);                                        \
   if (obj->has_strings)                                                       \
     {                                                                         \
       Bit_Chain sav_dat = *dat;                                               \
       obj_string_stream (dat, obj, dat);
 
 #define END_STRING_STREAM                                                     \
   *dat = sav_dat;                                                             \
   }
 /* just checking. skip the has_strings bit. hdl_dat is already set */
 #define START_HANDLE_STREAM                                                   \
   {                                                                           \
     vcount = bit_position (dat);                                              \
     if (dat->from_version >= R_2007)                                          \
       vcount++; /* has_strings bit */                                         \
     if (obj->hdlpos != (unsigned long)vcount)                                 \
       {                                                                       \
         LOG_HANDLE (" handle stream: %+ld @%lu.%u %s (@%lu.%u "               \
                     " @%lu.%u)\n",                                            \
                     (long)obj->hdlpos - (long)vcount, dat->byte, dat->bit,    \
                     ((long)obj->hdlpos - (long)vcount) >= 8 ? "MISSING"       \
                     : ((long)obj->hdlpos < (long)vcount)    ? "OVERSHOOT"     \
                                                             : "",                \
                     obj->hdlpos / 8, (unsigned)obj->hdlpos % 8,               \
                     hdl_dat->byte, hdl_dat->bit);                             \
         bit_set_position (dat, obj->hdlpos);                                  \
       }                                                                       \
   }
 
 #define REPEAT_CHKCOUNT(name, times, type)                                    \
   if (AVAIL_BITS (dat) < 0)                                                   \
     {                                                                         \
       LOG_ERROR ("Invalid " #name " in %s. No bytes left.\n", SAFEDXFNAME);   \
       if (_obj->name)                                                         \
         {                                                                     \
           free (_obj->name);                                                  \
           _obj->name = NULL;                                                  \
         }                                                                     \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }                                                                         \
   LOG_INSANE ("REPEAT_CHKCOUNT %s." #name " x %ld: %lld > %lld?\n",           \
               SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \
               AVAIL_BITS (dat));                                              \
   if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \
     {                                                                         \
       LOG_ERROR ("Invalid %s." #name " x %ld\n", SAFEDXFNAME, (long)times);   \
       if (_obj->name)                                                         \
         {                                                                     \
           free (_obj->name);                                                  \
           _obj->name = NULL;                                                  \
         }                                                                     \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 #define REPEAT_CHKCOUNT_LVAL(name, times, type)                               \
   if (AVAIL_BITS (dat) < 0)                                                   \
     {                                                                         \
       LOG_ERROR ("Invalid %s." #name ". No bytes left.\n", SAFEDXFNAME);      \
       times = 0;                                                              \
       if (_obj->name)                                                         \
         {                                                                     \
           free (_obj->name);                                                  \
           _obj->name = NULL;                                                  \
         }                                                                     \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }                                                                         \
   LOG_INSANE ("REPEAT_CHKCOUNT_LVAL %s." #name " x %ld: %lld > %lld?\n",      \
               SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \
               AVAIL_BITS (dat));                                              \
   if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \
     {                                                                         \
       LOG_ERROR ("Invalid %s." #name " x %ld\n", SAFEDXFNAME, (long)times);   \
       times = 0;                                                              \
       if (_obj->name)                                                         \
         {                                                                     \
           free (_obj->name);                                                  \
           _obj->name = NULL;                                                  \
         }                                                                     \
       return DWG_ERR_VALUEOUTOFBOUNDS;                                        \
     }
 
 /* REPEAT names:
   _ adds idx
   C does no checks
   N does constant times (else _obj->times)
   F does not calloc/free
 */
 
 // unchecked with constant times
 #define REPEAT_CN(times, name, type)                                          \
   if (times > 0)                                                              \
     _obj->name = (type *)calloc (times, sizeof (type));                       \
   for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)
 // checked with constant times
 #define REPEAT_N(times, name, type)                                           \
   REPEAT_CHKCOUNT (name, times, type)                                         \
   if (times > 0)                                                              \
     _obj->name = (type *)calloc (times, sizeof (type));                       \
   for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)
 
 // checked with var. times
 #define _REPEAT(times, name, type, idx)                                       \
   REPEAT_CHKCOUNT_LVAL (name, _obj->times, type)                              \
   if (_obj->times > 0)                                                        \
     _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \
   for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)
 // unchecked with var. times
 #define _REPEAT_C(times, name, type, idx)                                     \
   if (_obj->times > 0)                                                        \
     _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \
   for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)
 // unchecked with constant times
 #define _REPEAT_CN(times, name, type, idx)                                    \
   if (times > 0)                                                              \
     _obj->name = (type *)calloc (times, sizeof (type));                       \
   if (_obj->name)                                                             \
     for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)
 // not allocating versions unchecked: _REPEAT_CNF
 // not allocating versions checked: _REPEAT_NF
 
 #define REPEAT(times, name, type) _REPEAT (times, name, type, 1)
 #define REPEAT2(times, name, type) _REPEAT (times, name, type, 2)
 #define REPEAT3(times, name, type) _REPEAT (times, name, type, 3)
 #define REPEAT4(times, name, type) _REPEAT (times, name, type, 4)
 
 #define REPEAT_C(times, name, type) _REPEAT_C (times, name, type, 1)
 #define REPEAT2_C(times, name, type) _REPEAT_C (times, name, type, 2)
 #define REPEAT3_C(times, name, type) _REPEAT_C (times, name, type, 3)
 #define REPEAT4_C(times, name, type) _REPEAT_C (times, name, type, 4)
 
 #define COMMON_ENTITY_HANDLE_DATA                                             \
   SINCE (R_13b1) { START_HANDLE_STREAM; }
 
 /** Add the empty entity or object with its three structs to the DWG.
     All fields are zero'd. TODO: some are initialized with default values, as
     defined in dwg.spec.
     Returns 0 or DWG_ERR_OUTOFMEM.
 */
 
 #define DWG_ENTITY(token)                                                     \
   EXPORT int dwg_setup_##token (Dwg_Object *obj)                              \
   {                                                                           \
     Dwg_Object_Entity *_ent;                                                  \
     Dwg_Entity_##token *_obj;                                                 \
     if (strEQc (#token, "DIMENSION_ANG2LN") && obj->parent->header.version < R_13b1) \
       LOG_INFO ("Add entity DIMENSION [%d] ", obj->index)                     \
     else                                                                      \
       LOG_INFO ("Add entity " #token " [%d] ", obj->index)                    \
     obj->parent->num_entities++;                                              \
     obj->supertype = DWG_SUPERTYPE_ENTITY;                                    \
     if (!(int)obj->fixedtype)                                                 \
       {                                                                       \
         obj->fixedtype = DWG_TYPE_##token;                                    \
       }                                                                       \
     if (!(int)obj->type && obj->fixedtype <= DWG_TYPE_LAYOUT)                 \
       {                                                                       \
         obj->type = DWG_TYPE_##token;                                         \
       }                                                                       \
     if (!obj->dxfname)                                                        \
       {                                                                       \
         if (strlen (#token) > 3 && !memcmp (#token, "_3D", 3))                \
           obj->name = obj->dxfname = (char *)&#token[1];                      \
         else if (strEQc (#token, "PROXY_ENTITY"))                             \
           {                                                                   \
             obj->dxfname = (char *)"ACAD_PROXY_ENTITY";                       \
             obj->name = (char *)#token;                                       \
           }                                                                   \
         else                                                                  \
           obj->name = obj->dxfname = (char *)#token;                          \
       }                                                                       \
     else if (!obj->name)                                                      \
       {                                                                       \
         if (strlen (#token) > 3 && !memcmp (#token, "_3D", 3))                \
           obj->name = (char *)&#token[1];                                     \
         else                                                                  \
           obj->name = (char *)#token;                                         \
       }                                                                       \
     if (obj->parent->opts & DWG_OPTS_IN)                                      \
       {                                                                       \
         obj->dxfname = strdup (obj->dxfname);                                 \
         if (obj->parent->opts & DWG_OPTS_INJSON)                              \
           obj->name = strdup (obj->name);                                     \
       }                                                                       \
     _ent = obj->tio.entity                                                    \
         = (Dwg_Object_Entity *)calloc (1, sizeof (Dwg_Object_Entity));        \
     if (!_ent)                                                                \
       return DWG_ERR_OUTOFMEM;                                                \
     _ent->tio.token                                                           \
         = (Dwg_Entity_##token *)calloc (1, sizeof (Dwg_Entity_##token));      \
     if (!_ent->tio.token)                                                     \
       return DWG_ERR_OUTOFMEM;                                                \
     _ent->dwg = obj->parent;                                                  \
     _ent->objid = obj->index; /* obj ptr itself might move */                 \
     _ent->tio.token->parent = obj->tio.entity;                                \
     return 0;                                                                 \
   }                                                                           \
                                                                               \
   static int dwg_decode_##token##_private (                                   \
       Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \
       Dwg_Object *restrict obj);                                              \
                                                                               \
   /**Call dwg_setup_##token and write the fields from the bitstream dat to    \
    * the entity or object. */                                                 \
   static int dwg_decode_##token (Bit_Chain *restrict dat,                     \
                                  Dwg_Object *restrict obj)                    \
   {                                                                           \
     int error = dwg_setup_##token (obj);                                      \
     Bit_Chain hdl_dat = *dat;                                                 \
     if (error)                                                                \
       return error;                                                           \
     SINCE (R_2007)                                                            \
     {                                                                         \
       Bit_Chain obj_dat = *dat, str_dat = *dat;                               \
       error                                                                   \
           = dwg_decode_##token##_private (&obj_dat, &hdl_dat, &str_dat, obj); \
     }                                                                         \
     else                                                                      \
     {                                                                         \
       error = dwg_decode_##token##_private (dat, &hdl_dat, dat, obj);         \
     }                                                                         \
     return error;                                                             \
   }                                                                           \
                                                                               \
-  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                   \
+  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \
   static int dwg_decode_##token##_private (                                   \
       Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \
       Dwg_Object *restrict obj)                                               \
   {                                                                           \
     BITCODE_BL vcount, rcount3, rcount4;                                      \
     int error = 0;                                                            \
     Dwg_Entity_##token *ent, *_obj;                                           \
     Dwg_Object_Entity *_ent;                                                  \
     Dwg_Data *dwg = obj->parent;                                              \
     LOG_INFO ("Decode entity " #token "\n")                                   \
     _ent = obj->tio.entity;                                                   \
     ent = obj->tio.entity->tio.token;                                         \
     _obj = ent;                                                               \
     _ent->dwg = dwg;                                                          \
     _ent->objid = obj->index; /* obj ptr itself might move */                 \
     _obj->parent = obj->tio.entity;                                           \
     SINCE (R_13b1)                                                            \
     {                                                                         \
       error = dwg_decode_entity (dat, hdl_dat, str_dat, _ent);                \
     }                                                                         \
     else                                                                      \
     {                                                                         \
       error = decode_entity_preR13 (dat, obj, _ent);                          \
     }                                                                         \
     if (error >= DWG_ERR_CRITICAL || dat->byte > dat->size)                   \
       return error;
 
 // Does size include the CRC?
 #define DWG_ENTITY_END                                                        \
   SINCE (R_13b1)                                                              \
   {                                                                           \
     unsigned long pos = obj_stream_position (dat, hdl_dat, str_dat);          \
     int64_t padding = (obj->size * 8) - pos;                                  \
     bit_set_position (dat, pos);                                              \
     if (padding)                                                              \
       LOG_HANDLE (" padding: %+ld %s\n", (long)padding,                       \
                   padding >= 8    ? "MISSING"                                 \
                   : (padding < 0) ? "OVERSHOOT"                               \
                                   : "");                                      \
   }                                                                           \
   return error & ~DWG_ERR_UNHANDLEDCLASS;                                     \
   }
 
 #define DWG_OBJECT(token)                                                     \
   EXPORT int dwg_setup_##token (Dwg_Object *obj)                              \
   {                                                                           \
     Dwg_Object_##token *_obj;                                                 \
     LOG_INFO ("Add object " #token " [%d] ", obj->index)                      \
     obj->supertype = DWG_SUPERTYPE_OBJECT;                                    \
     obj->tio.object                                                           \
         = (Dwg_Object_Object *)calloc (1, sizeof (Dwg_Object_Object));        \
     if (!obj->tio.object)                                                     \
       return DWG_ERR_OUTOFMEM;                                                \
     _obj = obj->tio.object->tio.token                                         \
         = (Dwg_Object_##token *)calloc (1, sizeof (Dwg_Object_##token));      \
     if (!_obj)                                                                \
       {                                                                       \
         free (obj->tio.object);                                               \
         obj->tio.object = NULL;                                               \
         obj->fixedtype = DWG_TYPE_FREED;                                      \
         return DWG_ERR_OUTOFMEM;                                              \
       }                                                                       \
     if (!(int)obj->fixedtype)                                                 \
       {                                                                       \
         obj->fixedtype = DWG_TYPE_##token;                                    \
         obj->name = (char *)#token;                                           \
       }                                                                       \
     if (!(int)obj->type && obj->fixedtype <= DWG_TYPE_LAYOUT)                 \
       {                                                                       \
         obj->type = DWG_TYPE_##token;                                         \
       }                                                                       \
     if (!obj->dxfname)                                                        \
       {                                                                       \
         if (strEQc (#token, "PLACEHOLDER"))                                   \
           obj->dxfname = (char *)"ACDBPLACEHOLDER";                           \
         else if (strEQc (#token, "PROXY_OBJECT"))                             \
           obj->dxfname = (char *)"ACAD_PROXY_OBJECT";                         \
         else                                                                  \
           obj->dxfname = (char *)#token;                                      \
       }                                                                       \
     if (obj->parent->opts & DWG_OPTS_IN)                                      \
       {                                                                       \
         obj->dxfname = strdup (obj->dxfname);                                 \
         if (obj->parent->opts & DWG_OPTS_INJSON)                              \
           obj->name = strdup (obj->name);                                     \
       }                                                                       \
     _obj->parent = obj->tio.object;                                           \
     obj->tio.object->dwg = obj->parent;                                       \
     obj->tio.object->objid = obj->index; /* obj ptr itself might move */      \
     return 0;                                                                 \
   }                                                                           \
   static int dwg_decode_##token##_private (                                   \
       Bit_Chain *obj_dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,             \
       Dwg_Object *restrict obj);                                              \
                                                                               \
-  int dwg_decode_##token (Bit_Chain *restrict dat,                            \
+  static int dwg_decode_##token (Bit_Chain *restrict dat,                     \
                           Dwg_Object *restrict obj)                           \
   {                                                                           \
     int error = dwg_setup_##token (obj);                                      \
     Bit_Chain hdl_dat = *dat;                                                 \
     if (error)                                                                \
       return error;                                                           \
     SINCE (R_2007)                                                            \
     {                                                                         \
       Bit_Chain obj_dat = *dat, str_dat = *dat;                               \
       error                                                                   \
           = dwg_decode_##token##_private (&obj_dat, &hdl_dat, &str_dat, obj); \
     }                                                                         \
     else                                                                      \
     {                                                                         \
       error = dwg_decode_##token##_private (dat, &hdl_dat, dat, obj);         \
     }                                                                         \
     return error;                                                             \
   }                                                                           \
                                                                               \
   GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \
   static int dwg_decode_##token##_private (                                   \
       Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \
       Dwg_Object *restrict obj)                                               \
   {                                                                           \
     BITCODE_BL vcount, rcount3, rcount4;                                      \
     int error = 0;                                                            \
     Dwg_Object_##token *_obj = NULL;                                          \
     Dwg_Data *dwg = obj->parent;                                              \
     LOG_INFO ("Decode object " #token "\n")                                   \
     if (strNE (#token, "TABLECONTENT") || obj->fixedtype != DWG_TYPE_TABLE)   \
       {                                                                       \
         _obj = obj->tio.object->tio.token;                                    \
         error = dwg_decode_object (dat, hdl_dat, str_dat, obj->tio.object);   \
         if (error >= DWG_ERR_CRITICAL || dat->byte > dat->size)               \
           return error;                                                       \
       }
 
 #define DWG_OBJECT_END DWG_ENTITY_END
 
+// only for exported BLOCK_HEADER, LAYER, STYLE, LTYPE, VIEW, UCS, VPORT,
+// APPID, DIMSTYLE, VX_TABLE_RECORD table records, needed for the r11 add API.
+#define DWG_TABLE(token)                                                      \
+  EXPORT int dwg_setup_##token (Dwg_Object *obj)                              \
+  {                                                                           \
+    Dwg_Object_##token *_obj;                                                 \
+    LOG_INFO ("Add table record " #token " [%d] ", obj->index)                \
+    obj->supertype = DWG_SUPERTYPE_OBJECT;                                    \
+    obj->tio.object                                                           \
+        = (Dwg_Object_Object *)calloc (1, sizeof (Dwg_Object_Object));        \
+    if (!obj->tio.object)                                                     \
+      return DWG_ERR_OUTOFMEM;                                                \
+    _obj = obj->tio.object->tio.token                                         \
+        = (Dwg_Object_##token *)calloc (1, sizeof (Dwg_Object_##token));      \
+    if (!_obj)                                                                \
+      {                                                                       \
+        free (obj->tio.object);                                               \
+        obj->tio.object = NULL;                                               \
+        obj->fixedtype = DWG_TYPE_FREED;                                      \
+        return DWG_ERR_OUTOFMEM;                                              \
+      }                                                                       \
+    if (!(int)obj->fixedtype)                                                 \
+      {                                                                       \
+        obj->fixedtype = DWG_TYPE_##token;                                    \
+        obj->name = (char *)#token;                                           \
+      }                                                                       \
+    if (!(int)obj->type && obj->fixedtype <= DWG_TYPE_LAYOUT)                 \
+      {                                                                       \
+        obj->type = DWG_TYPE_##token;                                         \
+      }                                                                       \
+    obj->dxfname = (char *)#token;                                            \
+    if (obj->parent->opts & DWG_OPTS_IN)                                      \
+      {                                                                       \
+        obj->dxfname = strdup (obj->dxfname);                                 \
+        if (obj->parent->opts & DWG_OPTS_INJSON)                              \
+          obj->name = strdup (obj->name);                                     \
+      }                                                                       \
+    _obj->parent = obj->tio.object;                                           \
+    obj->tio.object->dwg = obj->parent;                                       \
+    obj->tio.object->objid = obj->index; /* obj ptr itself might move */      \
+    return 0;                                                                 \
+  }                                                                           \
+  static int dwg_decode_##token##_private (                                   \
+      Bit_Chain *obj_dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,             \
+      Dwg_Object *restrict obj);                                              \
+                                                                              \
+  int dwg_decode_##token (Bit_Chain *restrict dat,                            \
+                          Dwg_Object *restrict obj)                           \
+  {                                                                           \
+    int error = dwg_setup_##token (obj);                                      \
+    Bit_Chain hdl_dat = *dat;                                                 \
+    if (error)                                                                \
+      return error;                                                           \
+    SINCE (R_2007)                                                            \
+    {                                                                         \
+      Bit_Chain obj_dat = *dat, str_dat = *dat;                               \
+      error                                                                   \
+          = dwg_decode_##token##_private (&obj_dat, &hdl_dat, &str_dat, obj); \
+    }                                                                         \
+    else                                                                      \
+    {                                                                         \
+      error = dwg_decode_##token##_private (dat, &hdl_dat, dat, obj);         \
+    }                                                                         \
+    return error;                                                             \
+  }                                                                           \
+                                                                              \
+  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \
+  static int dwg_decode_##token##_private (                                   \
+      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \
+      Dwg_Object *restrict obj)                                               \
+  {                                                                           \
+    BITCODE_BL vcount, rcount3, rcount4;                                      \
+    int error = 0;                                                            \
+    Dwg_Object_##token *_obj = NULL;                                          \
+    Dwg_Data *dwg = obj->parent;                                              \
+    LOG_INFO ("Decode table record " #token "\n")                             \
+    _obj = obj->tio.object->tio.token;                                        \
+    error = dwg_decode_object (dat, hdl_dat, str_dat, obj->tio.object);       \
+    if (error >= DWG_ERR_CRITICAL || dat->byte > dat->size)                   \
+      return error;
+
+
 #endif
diff --git a/src/decode.h b/src/decode.h
index 64b8fa6d..6bbaefeb 100644
--- a/src/decode.h
+++ b/src/decode.h
@@ -43,6 +43,17 @@ int dwg_decode_unknown (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
 Dwg_Object_Ref *dwg_find_objectref (const Dwg_Data *restrict dwg,
                                     const Dwg_Object *restrict obj);
 
+int dwg_decode_BLOCK_HEADER (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_LAYER (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_STYLE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_LTYPE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_VIEW (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_UCS (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_VPORT (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_APPID (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_DIMSTYLE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+int dwg_decode_VX_TABLE_RECORD (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
+
 // reused with the importers
 void decode_BACKGROUND_type (const Dwg_Object *obj);
 
diff --git a/src/decode_r11.c b/src/decode_r11.c
index 036e0ab5..da7c40ba 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -79,16 +79,6 @@ static unsigned int errors = 0;
 
 void dwg_set_next_hdl (Dwg_Data *dwg, unsigned long value);
 
-int dwg_decode_BLOCK_HEADER (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_LAYER (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_STYLE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_LTYPE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_VIEW (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_UCS (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_VPORT (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_APPID (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-int dwg_decode_DIMSTYLE (Bit_Chain *restrict dat, Dwg_Object *restrict obj);
-
 /*------------------------------------------------------------------------------
  * Private functions
  */
@@ -220,307 +210,310 @@ static int
 decode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,
                        Dwg_Data *restrict dwg)
 {
   Dwg_Section *tbl = &dwg->header.section[id];
   Bit_Chain *hdl_dat = dat;
   Dwg_Object *obj;
   int i;
   BITCODE_BL vcount;
   int error = 0;
   long unsigned int num = dwg->num_objects;
   long unsigned int pos = tbl->address;
   BITCODE_RC flag;
   BITCODE_TF name;
   BITCODE_RSd used = -1;
   unsigned long oldpos;
   BITCODE_RL real_start = tbl->address;
 
   LOG_TRACE ("\ncontents table %-8s [%2d]: size:%-4u num:%-3ld (0x%lx-0x%lx)\n\n",
              tbl->name, id, tbl->size, (long)tbl->number,
              (unsigned long)tbl->address,
              (unsigned long)(tbl->address
                              + ((unsigned long long)tbl->number * tbl->size)))
 
   // with sentinel in case of R11
   SINCE (R_11)
     real_start -= 16; // the sentinel size
 
   // report unknown data before table
   if (dat->byte != real_start)
     {
       LOG_WARN ("\n@0x%lx => start 0x%x", dat->byte, real_start);
       if (dat->byte < real_start)
         {
           UNKNOWN_UNTIL (real_start);
         }
     }
 
   SINCE (R_11)
     {
 #define DECODE_PRER13_SENTINEL(ID) \
-      error |= decode_preR13_sentinel(ID, #ID, dat, dwg)
+      error |= decode_preR13_sentinel (ID, #ID, dat, dwg)
 
       switch (id)
         {
         case SECTION_BLOCK:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_BLOCKS_BEGIN);
           break;
         case SECTION_LAYER:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_LAYERS_BEGIN);
           break;
         case SECTION_STYLE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_STYLES_BEGIN);
           break;
         case SECTION_LTYPE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_LINETYPES_BEGIN);
           break;
         case SECTION_VIEW:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VIEWS_BEGIN);
           break;
         case SECTION_UCS:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_UCS_BEGIN);
           break;
         case SECTION_VPORT:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VPORTS_BEGIN);
           break;
         case SECTION_APPID:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_APPIDS_BEGIN);
           break;
         case SECTION_DIMSTYLE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_DIMSTYLES_BEGIN);
           break;
         case SECTION_VX:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VXS_BEGIN);
           break;
         default:
           LOG_ERROR ("Internal error: Invalid section id %d", (int)id);
           return DWG_ERR_INTERNALERROR;
         }
     }
 
   oldpos = dat->byte;
   dat->byte = tbl->address;
   dat->bit = 0;
   if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)
     {
       LOG_ERROR ("Overlarge table num_entries %ld or size %ld for %-8s [%2d]",
                  (long)tbl->number, (long)tbl->size, tbl->name, id);
       dat->byte = oldpos;
       return DWG_ERR_INVALIDDWG;
     }
   tbl->objid_r11 = num;
   if (dwg->num_alloced_objects < dwg->num_objects + tbl->number)
     {
       dwg->num_alloced_objects = dwg->num_objects + tbl->number;
       dwg->object = (Dwg_Object *)realloc (
           dwg->object, dwg->num_alloced_objects * sizeof (Dwg_Object));
       dwg->dirty_refs = 1;
     }
 
 #  define NEW_OBJECT                                                          \
     dwg_add_object (dwg);                                                     \
     if (dat->byte > dat->size || (num + i) > dwg->num_objects)                \
       return DWG_ERR_INVALIDDWG;                                              \
     obj = &dwg->object[num++];                                                \
     obj->address = dat->byte;                                                 \
     obj->size = tbl->size
 
 #  define CHK_ENDPOS                                                          \
     SINCE (R_11)                                                              \
     {                                                                         \
       BITCODE_RS crc16 = bit_read_RS (dat);                                   \
       LOG_TRACE ("crc16: %04X\n", crc16);                                     \
     }                                                                         \
     pos = tbl->address + (long)((i + 1) * tbl->size);                         \
     if (pos != dat->byte)                                                     \
       {                                                                       \
         LOG_ERROR ("offset %ld", pos - dat->byte);                            \
         /*return DWG_ERR_SECTIONNOTFOUND;*/                                   \
       }                                                                       \
     LOG_TRACE ("\n")                                                          \
     dat->byte = pos
 
   switch (id)
     {
     case SECTION_BLOCK:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_BLOCK_HEADER (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     case SECTION_LAYER:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_LAYER (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // was a text STYLE table, became a STYLE object
     case SECTION_STYLE:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_STYLE (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     case SECTION_LTYPE:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_LTYPE (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     case SECTION_VIEW:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_VIEW (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // SINCE R_11
     case SECTION_UCS:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_UCS (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // SINCE R_11
     case SECTION_VPORT:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_VPORT (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // SINCE R_11
     case SECTION_APPID:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_APPID (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // SINCE R_11
     case SECTION_DIMSTYLE:
       for (i = 0; i < tbl->number; i++)
         {
           NEW_OBJECT;
           error |= dwg_decode_DIMSTYLE (dat, obj);
           CHK_ENDPOS;
         }
       break;
 
     // SINCE R_11
     case SECTION_VX:
+      for (i = 0; i < tbl->number; i++)
         {
-          for (i = 0; i < tbl->number; i++)
+#if 1
+          NEW_OBJECT;
+          error |= dwg_decode_VX_TABLE_RECORD (dat, obj);
+          CHK_ENDPOS;
+#else
+          //Dwg_Object *obj;
+          Dwg_Object_VX_TABLE_RECORD *_obj;
+          Dwg_Object *ctrl;
+          Dwg_Object_VX_CONTROL *_ctrl;
+          LOG_TRACE ("\n-- table entry VX_TABLE_RECORD [%d]: 0x%lx\n", i, pos);
+          flag = bit_read_RC (dat);
+          name = bit_read_TF (dat, 32);
+          _obj = dwg_add_VX (dwg, (const char *)name);
+          _obj->flag = flag;
+          LOG_TRACE ("name: \"%s\" [TF 32 2]\n", name);
+          LOG_TRACE ("flag: %u [RC 70]\n", flag);
+          //LOG_FLAG_VX
+          free (name);
+          obj = dwg_obj_generic_to_object (_obj, &error);
+          if (obj)
             {
-              Dwg_Object *obj;
-              Dwg_Object_VX_TABLE_RECORD *_obj;
-              Dwg_Object *ctrl;
-              Dwg_Object_VX_CONTROL *_ctrl;
-              LOG_TRACE ("\n-- table entry VX_TABLE_RECORD [%d]: 0x%lx\n", i, pos);
-              flag = bit_read_RC (dat);
-              name = bit_read_TF (dat, 32);
-              _obj = dwg_add_VX (dwg, (const char *)name);
-              _obj->flag = flag;
-              LOG_TRACE ("name: \"%s\" [TF 32 2]\n", name);
-              LOG_TRACE ("flag: %u [RC 70]\n", flag);
-              //LOG_FLAG_VX
-              free (name);
-              obj = dwg_obj_generic_to_object (_obj, &error);
-              if (obj)
-                {
-                  obj->size = tbl->size;
-                  obj->address = pos;
-                }
-              ctrl = dwg_get_first_object (dwg, DWG_TYPE_VX_CONTROL);
-              if (ctrl)
-                {
-                  _ctrl = ctrl->tio.object->tio.VX_CONTROL;
-                  _ctrl->entries[i]
-                      = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
-                }
-              SINCE (R_11)
-                FIELD_RSd (used, 0);
-              FIELD_RS (vport_entity_address, 0);
-              FIELD_RSd (unknown1, 0);
-              FIELD_RS (unknown2, 0);
-              CHK_ENDPOS;
+              obj->size = tbl->size;
+              obj->address = pos;
             }
+          ctrl = dwg_get_first_object (dwg, DWG_TYPE_VX_CONTROL);
+          if (ctrl)
+            {
+              _ctrl = ctrl->tio.object->tio.VX_CONTROL;
+              _ctrl->entries[i]
+                = dwg_add_handleref (dwg, 2, obj->handle.value, obj);
+            }
+          SINCE (R_11)
+            FIELD_RSd (used, 0);
+          FIELD_RS (vport_entity_address, 0);
+          FIELD_RSd (unknown1, 0);
+          FIELD_RS (unknown2, 0);
+          CHK_ENDPOS;
+#endif
         }
         break;
 
       case SECTION_HEADER_R11:
       default:
         LOG_ERROR ("Invalid table id %d", id);
         tbl->number = 0;
         break;
-      }
     }
 
   if (tbl->address && tbl->number && tbl->size)
     dat->byte = tbl->address + (tbl->number * tbl->size);
   else
     dat->byte = oldpos;
 
   SINCE (R_11)
     {
       switch (id)
         {
         case SECTION_BLOCK:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_BLOCKS_END);
           break;
         case SECTION_LAYER:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_LAYERS_END);
           break;
         case SECTION_STYLE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_STYLES_END);
           break;
         case SECTION_LTYPE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_LINETYPES_END);
           break;
         case SECTION_VIEW:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VIEWS_END);
           break;
         case SECTION_UCS:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_UCS_END);
           break;
         case SECTION_VPORT:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VPORTS_END);
           break;
         case SECTION_APPID:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_APPIDS_END);
           break;
         case SECTION_DIMSTYLE:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_DIMSTYLES_END);
           break;
         case SECTION_VX:
           DECODE_PRER13_SENTINEL (DWG_SENTINEL_R11_VXS_END);
           break;
         default:
           LOG_ERROR ("Internal error: Invalid section id %d", (int)id);
           return DWG_ERR_INTERNALERROR;
         }
     }
 #undef DECODE_PRER13_SENTINEL
 
   return error;
 }
@@ -568,198 +561,198 @@ EXPORT int
 decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   BITCODE_RL num_entities;
   BITCODE_RL block_entities_start = 0, block_entities_end = 0, block_entities_size = 0;
   BITCODE_RL extra_entities_start = 0, extra_entities_end = 0, extra_entities_size = 0;
   BITCODE_RS rs2;
   Dwg_Object *obj = NULL;
   int tbl_id;
   int error = 0;
   Bit_Chain dat_save = *dat;
 
   loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
 #ifndef USE_WRITE
   fprintf (stderr, "Cannot create pre-R13 documents with --disable-write\n");
   return DWG_ERR_INTERNALERROR;
 #else
   {
     int i;
     Dwg_Header *_obj = (Dwg_Header *)&dwg->header;
     Bit_Chain *hdl_dat = dat;
     dat->byte = 0x06;
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
   LOG_TRACE ("@0x%lx\n", dat->byte); // 0x14
 
   // setup all the new control objects
   error |= dwg_add_Document (dwg, 0);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   SINCE (R_2_0b)
   {
     // Block entities
     block_entities_start = dwg->header.block_entities_start;
     block_entities_size = dwg->header.block_entities_size;
     if (block_entities_size > 0xffffff)
       {
         block_entities_size &= 0xffffff;
         LOG_TRACE ("block_enties_size => " FORMAT_RLx "\n", block_entities_size);
       }
     block_entities_end = block_entities_start + block_entities_size;
 
     // Extra entities
     extra_entities_start = dwg->header.extra_entities_start;
     extra_entities_size = dwg->header.extra_entities_size;
     if (extra_entities_size > 0xffffff)
       {
         extra_entities_size &= 0xffffff;
         LOG_TRACE ("extra_enties_size => " FORMAT_RLx "\n", extra_entities_size);
       }
     extra_entities_end = extra_entities_start + extra_entities_size;
 
     tbl_id = 0;
     dwg->header.section[0].number = 0;
     dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;
     strcpy (dwg->header.section[0].name, "HEADER");
 
     // The 5 tables (num_sections always 5): 3 RS + 1 RL address
     LOG_INFO ("==========================================\n")
     dat_save = *dat;
     if (decode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg)
         || decode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg)
         || decode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg)
         || decode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg)
         || decode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg))
       return DWG_ERR_SECTIONNOTFOUND;
   }
   LOG_TRACE ("@0x%lx\n", dat->byte); // 0x5e
   if (dat->size < 0x1f0)             // AC1.50 0x1f9 74 vars
     {
       LOG_ERROR ("DWG too small %zu", (size_t)dat->size)
       return DWG_ERR_INVALIDDWG;
     }
 
-  LOG_INFO ("==========================================\n")
+  LOG_TRACE ("==========================================\n")
   error |= decode_preR13_header_variables (dat, dwg);
   LOG_TRACE ("@0x%lx\n", dat->byte);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   if (dat->byte + 2 >= dat->size)
     {
       LOG_ERROR ("post HEADER overflow")
       return error | DWG_ERR_CRITICAL;
     }
   SINCE (R_11)
   {
     // crc16 + DWG_SENTINEL_R11_ENTITIES_BEGIN
     BITCODE_RS crc, crcc;
     crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now
     crc = bit_read_RS (dat);
     LOG_TRACE ("crc: %04X [RSx] from 0-0x%lx\n", crc, dat->byte - 2);
     if (crc != crcc)
       {
         LOG_ERROR ("Header CRC mismatch %04X <=> %04X", crc, crcc);
         error |= DWG_ERR_WRONGCRC;
       }
   }
 
   PRE (R_10)
     num_entities = dwg->header_vars.numentities;
   else
     num_entities = 0;
   PRE (R_2_0b)
   {
     dwg->header.entities_start = dat->byte;
     dwg->header.entities_end = dwg->header_vars.dwg_size;
   }
 
   // entities
   error |= decode_preR13_entities (
       dwg->header.entities_start, dwg->header.entities_end, num_entities,
       dwg->header.entities_end - dwg->header.entities_start, dat, dwg, 0);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   PRE (R_2_0b)
   {
     // this has usually some slack at the end.
     return error;
   }
 
   dat_save = *dat;
   if (decode_preR13_section (SECTION_BLOCK, dat, dwg)
       || decode_preR13_section (SECTION_LAYER, dat, dwg)
       || decode_preR13_section (SECTION_STYLE, dat, dwg)
       || decode_preR13_section (SECTION_LTYPE, dat, dwg)
       || decode_preR13_section (SECTION_VIEW, dat, dwg))
     {
       *dat = dat_save;
       return DWG_ERR_SECTIONNOTFOUND;
     }
   if (dwg->header.num_sections >= SECTION_VPORT) // r10
     {
       dat_save = *dat;
       if (decode_preR13_section (SECTION_UCS, dat, dwg)
           || decode_preR13_section (SECTION_VPORT, dat, dwg))
         {
           *dat = dat_save;
           return DWG_ERR_SECTIONNOTFOUND;
         }
     }
   if (dwg->header.num_sections >= SECTION_APPID) // r10
     {
       dat_save = *dat;
       if (decode_preR13_section (SECTION_APPID, dat, dwg))
         {
           *dat = dat_save;
           return DWG_ERR_SECTIONNOTFOUND;
         }
     }
   if (dwg->header.num_sections >= SECTION_VX) // r11
     {
       dat_save = *dat;
       if (decode_preR13_section (SECTION_DIMSTYLE, dat, dwg)
           || decode_preR13_section (SECTION_VX, dat, dwg))
         {
           *dat = dat_save;
           return DWG_ERR_SECTIONNOTFOUND;
         }
     }
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // block entities
   error |= decode_preR13_entities (block_entities_start, block_entities_end, 0,
                                    block_entities_size, dat, dwg, 1);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // extra entities.
   error |= decode_preR13_entities (extra_entities_start, extra_entities_end, 0,
                                    extra_entities_size, dat, dwg, 2);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // aux header
   SINCE (R_11) {
     error |= decode_preR13_auxheader(dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
   }
 
   if (dat->byte < dat->size)
     {
       int len = dat->size - dat->byte;
       BITCODE_TF unknown = bit_read_TF (dat, len);
       LOG_TRACE ("unknown (%d):", len);
       LOG_TRACE_TF (unknown, len);
       free (unknown);
     }
 
   if (dwg->dirty_refs)
     dwg_resolve_objectrefs_silent (dwg);
   return 0;
 #endif // USE_WRITE
 }
diff --git a/src/dwg.spec b/src/dwg.spec
index 4db0c9b7..2e03ae84 100644
--- a/src/dwg.spec
+++ b/src/dwg.spec
@@ -3467,132 +3467,132 @@ DWG_OBJECT (BLOCK_CONTROL)
 DWG_OBJECT_END
 
 /* (49/T1) */
-DWG_OBJECT (BLOCK_HEADER)
+DWG_TABLE (BLOCK_HEADER)
 
   //DXF: the name must be from the block_entity!
   COMMON_TABLE_FLAGS (Block)
   DXF {
     // not allowed to be skipped, can be 0
     VALUE_HANDLE (_obj->layout, layout, 5, 340);
     if (FIELD_VALUE (preview_size))
       {
         FIELD_BINARY (preview, FIELD_VALUE (preview_size), 310);
       }
     if (FIELD_VALUE (num_inserts))
       {
         VALUE_TFF ("{BLKREFS", 102);
         HANDLE_VECTOR (inserts, num_inserts, 4, 331);
         VALUE_TFF ("}", 102);
       }
     // The DXF TABLE.BLOCK_RECORD only has this. More later in the BLOCKS section.
     return 0;
   }
 
   PRE (R_13b1)
   {
     FIELD_RLx (block_offset_r11, 0);
     DECODER_OR_ENCODER {
       if (_obj->block_offset_r11 >= 0x40000000)
         {
           BITCODE_RL off = _obj->block_offset_r11 & 0x3fffffff;
           LOG_TRACE ("abs. offset => " FORMAT_RLx "\n",
                      off + dwg->header.block_entities_start);
         }
       else
         {
           LOG_TRACE ("abs. offset => " FORMAT_RLx "\n",
                      _obj->block_offset_r11 + dwg->header.block_entities_start);
         }
     }
     if (obj->size == 38)
       FIELD_RC (unknown_r11, 0);
     SINCE (R_11)
     {
       FIELD_HANDLE (block_entity, 2, 0);
       FIELD_RC (flag2, 0);
       FIELD_RC (unknown_r11, 0);
     }
     FIELD_VALUE (anonymous)    = FIELD_VALUE (flag) & 1;
     FIELD_VALUE (hasattrs)     = FIELD_VALUE (flag) & 2;
     FIELD_VALUE (blkisxref)    = FIELD_VALUE (flag) & 4;
     FIELD_VALUE (xrefoverlaid) = FIELD_VALUE (flag) & 8;
   }
   SINCE (R_13b1) {
     FIELD_B (anonymous, 0); // bit 1
     FIELD_B (hasattrs, 0);  // bit 2
     FIELD_B (blkisxref, 0); // bit 4
     FIELD_B (xrefoverlaid, 0); // bit 8
   }
   SINCE (R_2000) {
     FIELD_B (loaded_bit, 0); // bit 32
   }
   SINCE (R_13b1) {
     FIELD_VALUE (flag) |= FIELD_VALUE (anonymous) |
                           FIELD_VALUE (hasattrs) << 1 |
                           FIELD_VALUE (blkisxref) << 2 |
                           FIELD_VALUE (xrefoverlaid) << 3;
   }
   SINCE (R_2004) { // but not in 2007
     FIELD_BL (num_owned, 0);
     if (FIELD_VALUE (num_owned) > 0xf00000)
       {
         LOG_WARN ("Unreasonable high num_owned value")
       }
   }
 
   SINCE (R_13b1) {
     FIELD_3DPOINT (base_pt, 10);
     FIELD_T (xref_pname, 1); // and 3
   }
 
   IF_FREE_OR_SINCE (R_2000)
     {
       FIELD_NUM_INSERTS (num_inserts, RL, 0);
       FIELD_T (description, 4);
 
 #ifndef IS_JSON
       FIELD_BL (preview_size, 0);
 #endif
       VALUEOUTOFBOUNDS (preview_size, 0xa00000)
       else
         {
           FIELD_BINARY (preview, FIELD_VALUE (preview_size), 310);
         }
     }
 
   SINCE (R_2007) // AC1020 aka R_2006
     {
       FIELD_BS (insert_units, 70);
       FIELD_B (explodable, 280);
       FIELD_RC (block_scaling, 281);
     }
 
   SINCE (R_13b1) {
     START_OBJECT_HANDLE_STREAM;
     FIELD_HANDLE (block_entity, 3, 0);
   }
 
   VERSIONS (R_13b1, R_2000)
     {
       if (!FIELD_VALUE (blkisxref) && !FIELD_VALUE (xrefoverlaid))
         {
           FIELD_HANDLE (first_entity, 4, 0);
           FIELD_HANDLE (last_entity, 4, 0);
         }
     }
   IF_FREE_OR_SINCE (R_2004)
     {
       if (FIELD_VALUE (num_owned) < 0xf00000) {
         HANDLE_VECTOR (entities, num_owned, 4, 0);
       }
     }
   IF_FREE_OR_SINCE (R_13b1) {
     FIELD_HANDLE (endblk_entity, 3, 0);
   }
   IF_FREE_OR_SINCE (R_2000)
     {
       if (FIELD_VALUE (num_inserts) && FIELD_VALUE (num_inserts) < 0xf00000) {
         HANDLE_VECTOR (inserts, num_inserts, 4, 0);
       }
       FIELD_HANDLE (layout, 5, 340);
     }
@@ -3609,106 +3609,106 @@ DWG_OBJECT (LAYER_CONTROL)
 DWG_OBJECT_END
 
 /* (51/T2) */
-DWG_OBJECT (LAYER)
+DWG_TABLE (LAYER)
 
   COMMON_TABLE_FLAGS (Layer);
   PRE (R_13b1) {
     FIELD_CMC (color, 62);
     FIELD_HANDLE (ltype, 2, 6);
     if (obj->size == 38)
       FIELD_CAST (flag0, RC, BS, 0);
 
     DECODER {
       FIELD_VALUE (on)            = FIELD_VALUE (color.index) >= 0;
       FIELD_VALUE (frozen)        = FIELD_VALUE (flag) & 1;
       FIELD_VALUE (frozen_in_new) = FIELD_VALUE (flag) & 2;
       FIELD_VALUE (locked)        = FIELD_VALUE (flag) & 4;
     }
   }
   VERSIONS (R_13b1, R_14) {
     FIELD_B (frozen, 0); // bit 1
     FIELD_B (on, 0);     // really: negate the color
     FIELD_B (frozen_in_new, 0);
     FIELD_B (locked, 0);
   }
   SINCE (R_2000) {
     // separate DXF flag 70 from the internal DWG flag0 bitmask
     int flag0 = FIELD_VALUE (flag0);
     FIELD_BSx (flag0, 0); // -> 70,290,370
     flag0 = FIELD_VALUE (flag0);
     // DWG: frozen (1), on (2), frozen by default (4),
     //      locked (8), plotting flag (16), and linewt (mask with 0x03E0)
     FIELD_VALUE (frozen) = flag0 & 1;
     FIELD_VALUE (on) = !(flag0 & 2);
     FIELD_VALUE (frozen_in_new) = (flag0 & 4) ? 1 : 0;
     FIELD_VALUE (locked) = (flag0 & 8) ? 1 : 0;
     FIELD_VALUE (plotflag) = (flag0 & 16) ? 1 : 0;
     FIELD_VALUE (linewt) = (flag0 & 0x03E0) >> 5;
     // DXF: frozen (1), frozen by default in new viewports (2),
     //      locked (4), is_xref_ref (16), is_xref_resolved (32), is_xref_dep (64).
     FIELD_VALUE (flag) |= FIELD_VALUE (frozen) |
       (FIELD_VALUE (frozen_in_new) << 1) |
       (FIELD_VALUE (locked) << 2) |
       (FIELD_VALUE (is_xref_ref) << 3) |
       ((FIELD_VALUE (is_xref_resolved) ? 1 : 0) << 4) |
       (FIELD_VALUE (is_xref_dep) << 5);
     JSON {
       FIELD_RC (linewt, 370);
     }
   }
   SINCE (R_13b1) {
     FIELD_CMC (color, 62);
   }
   VERSIONS (R_13b1, R_14) {
     DECODER { FIELD_VALUE (on) = FIELD_VALUE (color.index) >= 0; }
     // for DWG
     FIELD_VALUE (flag0) |= FIELD_VALUE (frozen) |
       (FIELD_VALUE (frozen_in_new) << 1) |
       (FIELD_VALUE (locked) << 2) |
       (FIELD_VALUE (color.index) < 0 ? 32 : 0);
     // for DXF
     FIELD_VALUE (flag) |= FIELD_VALUE (frozen) |
       (FIELD_VALUE (frozen_in_new) << 1) |
       (FIELD_VALUE (locked) << 2) |
       (FIELD_VALUE (color.index) < 0 ? 32 : 0);
   }
 
   START_OBJECT_HANDLE_STREAM;
   SINCE (R_2000) {
     FIELD_HANDLE (plotstyle, 5, 0);
   }
   SINCE (R_2007) {
     FIELD_HANDLE (material, 5, 0);
   }
   SINCE (R_13b1) {
     FIELD_HANDLE (ltype, 5, 6);
   }
   DXF {
     SINCE (R_2000) {
       if (_obj->name &&
           (bit_eq_T (dat, _obj->name, "Defpoints") ||
            bit_eq_T (dat, _obj->name, "DEFPOINTS")))
       {
         _obj->plotflag = 0;
         FIELD_B (plotflag, 290);
       } else {
         FIELD_B0 (plotflag, 290);
       }
     }
     SINCE (R_13b1) {
       int lw = dxf_cvt_lweight (FIELD_VALUE (linewt));
       KEY (linewt); VALUE_BSd (lw, 370);
     }
     SINCE (R_2000) {
       FIELD_HANDLE (plotstyle, 5, 390);
     }
     SINCE (R_2007) {
       DXF { FIELD_HANDLE (material, 5, 0); } // yet unstable class
       else {
         FIELD_HANDLE (material, 5, 347);
       }
     }
   }
   SINCE (R_2013) {
     FIELD_HANDLE (visualstyle, 5, 348);
   }
@@ -3724,72 +3724,72 @@ DWG_OBJECT (STYLE_CONTROL)
 DWG_OBJECT_END
 
 /* (53/T3) preR13+DXF: STYLE, documented as SHAPEFILE */
-DWG_OBJECT (STYLE)
+DWG_TABLE (STYLE)
 
   COMMON_TABLE_FLAGS (TextStyle)
 
   SINCE (R_13b1) {
     FIELD_B (is_shape, 0);        //wrong oda doc
     FIELD_B (is_vertical, 0);     //
     DECODER_OR_ENCODER {
       FIELD_VALUE (flag) |= (FIELD_VALUE (is_vertical) ? 4 : 0) +
                             (FIELD_VALUE (is_shape) ? 1 : 0);
       LOG_TRACE ("flag => %d [RC 70]\n", FIELD_VALUE (flag));
     }
   }
   PRE (R_13b1) {
     FIELD_RD (text_size, 40);
     FIELD_RD (width_factor, 41);
     FIELD_RD (oblique_angle, 50);
     FIELD_RC (generation, 71);
     LOG_TEXT_GENERATION
     FIELD_RD (last_height, 42);
     FIELD_TFv (font_file, 64, 3);
     SINCE (R_2_4)
       FIELD_TFv (bigfont_file, 64, 4);
     DECODER {
       FIELD_VALUE (is_shape)    = FIELD_VALUE (flag) & 4;
       FIELD_VALUE (is_vertical) = FIELD_VALUE (flag) & 1;
     }
   }
   LATER_VERSIONS {
     FIELD_BD (text_size, 40);
     FIELD_BD (width_factor, 41); // xScale
     FIELD_BD (oblique_angle, 50);
     FIELD_RC (generation, 71);
     LOG_TEXT_GENERATION
     FIELD_BD (last_height, 42);
     FIELD_T (font_file, 3);
     FIELD_T (bigfont_file, 4);
     //1001 1000 1071 mandatory r2007+ if .ttf
     //long truetype font’s pitch and family, charset, and italic and bold flags
 #ifdef IS_DXF
     {
       char _buf[256];
       char *s;
       // only print to DXF, if not in EED already
       if (FIELD_VALUE (font_file) && !dxf_has_STYLE_eed (dat, obj->tio.object))
         {
           if (IS_FROM_TU (dat)) {
             s = bit_convert_TU ((BITCODE_TU)FIELD_VALUE (font_file));
             strncpy (_buf, s, 255);
             free (s);
           }
           else {
             strncpy (_buf, FIELD_VALUE (font_file), 255);
           }
           _buf[255] = '\0';
           if ((s = strstr (_buf, ".ttf")) ||
               (s = strstr (_buf, ".TTF")))
             {
               *s = 0;
               VALUE_TFF ("ACAD", 1001);
               VALUE_TFF (_buf, 1000); // typeface
               VALUE_RL (34, 1071); // ttf_flags
             }
         }
     }
 #endif
 
     START_OBJECT_HANDLE_STREAM;
   }
@@ -3813,125 +3813,125 @@ DWG_OBJECT_END
 /* (57/T4)
  * Unstable, ACAD import errors
  */
-DWG_OBJECT (LTYPE)
+DWG_TABLE (LTYPE)
 
   COMMON_TABLE_FLAGS (Linetype)
 
   PRE (R_13b1) {
     FIELD_TFv (description, 48, 3);
   }
   LATER_VERSIONS {
     FIELD_T (description, 3);
     FIELD_BD (pattern_len, 0); // total length
   }
   FIELD_RC (alignment, 72);
   FIELD_RCu (num_dashes, 73);
   DXF { FIELD_BD (pattern_len, 40); }
   PRE (R_13b1)
   {
     FIELD_RD (pattern_len, 40);
 #ifndef IS_JSON
     FIELD_VECTOR_INL (dashes_r11, RD, 12, 49);
 #else
     FIELD_VECTOR_N (dashes_r11, RD, 12, 49);
 #endif
     PRE (R_11) {
       if (obj->size > 187) // !! encode,add
         FIELD_RC (unknown_r11, 0);
     }
   }
   SINCE (R_13b1)
   {
     REPEAT (num_dashes, dashes, Dwg_LTYPE_dash)
     REPEAT_BLOCK
       SUB_FIELD_BD (dashes[rcount1],length, 49);
       DXF {
         SUB_FIELD_BS (dashes[rcount1],shape_flag, 74);
         if (_obj->dashes[rcount1].shape_flag) // eg BATTING
           {
             SUB_FIELD_BS (dashes[rcount1],complex_shapecode, 75);
             SUB_FIELD_HANDLE (dashes[rcount1],style, 5, 340);
             SUB_FIELD_BD (dashes[rcount1],scale, 46);
             SUB_FIELD_BD (dashes[rcount1],rotation, 50); // absolute or relative
             SUB_FIELD_RD (dashes[rcount1],x_offset, 44);
             SUB_FIELD_RD (dashes[rcount1],y_offset, 45);
             if (_obj->dashes[rcount1].shape_flag & 2) // 10
               {
                 SUB_FIELD_T (dashes[rcount1],text, 9);
               }
           }
       } else {
         SUB_FIELD_BS (dashes[rcount1],complex_shapecode, 75);
         SUB_FIELD_HANDLE (dashes[rcount1],style, 5, 340);
         SUB_FIELD_RD (dashes[rcount1],x_offset, 44);
         SUB_FIELD_RD (dashes[rcount1],y_offset, 45);
         SUB_FIELD_BD (dashes[rcount1],scale, 46);
         SUB_FIELD_BD (dashes[rcount1],rotation, 50);
         SUB_FIELD_BS (dashes[rcount1],shape_flag, 74);
       }
       DECODER {
         if (FIELD_VALUE (dashes[rcount1].shape_flag) & 2)
           FIELD_VALUE (has_strings_area) = 1;
         PRE (R_13b1) {
           FIELD_VALUE (pattern_len) += FIELD_VALUE (dashes[rcount1].length);
         }
       }
       SET_PARENT_OBJ (dashes[rcount1]);
     END_REPEAT_BLOCK
     END_REPEAT (dashes);
     
     UNTIL (R_2004) {
       JSON {
         if (FIELD_VALUE (has_strings_area))
           FIELD_BINARY (strings_area, 256, 0);
       }
       FIELD_BINARY (strings_area, 256, 0);
       DECODER {
         unsigned int dash_i = 0;
         for (rcount1 = 0; _obj->strings_area && rcount1 < _obj->num_dashes; rcount1++)
           {
             if (_obj->dashes[rcount1].shape_flag & 2)
               {
                 if (dash_i >= 256)
                   {
                     LOG_ERROR ("dashes[%u] overflow @%u", rcount1, dash_i)
                       break;
                   }
                 _obj->dashes[rcount1].text = (char*)&_obj->strings_area[dash_i];
                 LOG_TRACE ("dashes[%u] @%u\n", rcount1, dash_i)
                   dash_i += strnlen (_obj->dashes[rcount1].text, 256 - dash_i) + 1;
               }
           }
       }
     }
     LATER_VERSIONS { // r2007++
       if (FIELD_VALUE (has_strings_area)) {
         FIELD_BINARY (strings_area, 512, 0);
         DECODER {
           unsigned int dash_i = 0;
           for (rcount1 = 0; _obj->strings_area && rcount1 < _obj->num_dashes;
                rcount1++)
             {
               if (_obj->dashes[rcount1].shape_flag & 2)
                 {
                   if (dash_i >= 512)
                     {
                       LOG_ERROR ("dashes[%u] overflow @%u", rcount1, dash_i)
                         break;
                     }
                   _obj->dashes[rcount1].text
                     = (char *)&_obj->strings_area[dash_i];
                   LOG_TRACE ("dashes[%u] @%u\n", rcount1, dash_i)
                     dash_i
                     += (2
                         * bit_wcs2nlen ((BITCODE_TU)_obj->dashes[rcount1].text,
                                         256 - (dash_i / 2)))
                     + 2;
                 }
             }
         }
       }
     }
   } // r13
 
   START_OBJECT_HANDLE_STREAM;
@@ -3951,108 +3951,108 @@ DWG_OBJECT (VIEW_CONTROL)
 DWG_OBJECT_END
 
 /* (61/T5) */
-DWG_OBJECT (VIEW)
+DWG_TABLE (VIEW)
 
   COMMON_TABLE_FLAGS (View)
 
   // subclass AbstractViewTableRecord:
   PRE (R_13b1)
   {
     FIELD_RD (VIEWSIZE, 40);
     FIELD_2RD (VIEWCTR, 10);
     if (obj->size == 58)
       FIELD_RC (unknown_r11, 0);
     if (obj->size > 58)
       FIELD_RD (view_width, 41);
     if (obj->size > 66)
       FIELD_3RD (VIEWDIR, 11);
     if (obj->size > 89)
       FIELD_RS (flag_3d, 0);
     if (obj->size == 66 || obj->size == 92)
       FIELD_RC (unknown_r2, 0);
     SINCE (R_10) {
       FIELD_3RD (view_target, 12);
       FIELD_3RD (VIEWDIR, 0);
       FIELD_CAST (VIEWMODE, RS, 4BITS, 0);
       FIELD_RD (lens_length, 42); // defaults to 50.0
       FIELD_RD (front_clip_z, 43);
       FIELD_RD (back_clip_z, 44);
       FIELD_RD (twist_angle, 50);
       DXF {
         FIELD_CAST (VIEWMODE, RS, 4BITS, 71);
       }
     }
   }
   LATER_VERSIONS
   {
     FIELD_BD (VIEWSIZE, 40); // i.e view height
     FIELD_BD (view_width, 0);
     DECODER {
       FIELD_VALUE (aspect_ratio) = FIELD_VALUE (VIEWSIZE) == 0.0
         ? 0.0
         : FIELD_VALUE (view_width) / FIELD_VALUE (VIEWSIZE);
       LOG_TRACE ("aspect_ratio: %f (calc)\n", FIELD_VALUE (aspect_ratio))
     }
     JSON {
       FIELD_BD (aspect_ratio, 0);
     }
     // subclass ViInfo (shared with VPORT, but different DXF codes)
     FIELD_2RD (VIEWCTR, 10);
     DXF {
       FIELD_BD (view_width, 41);
       FIELD_3BD (VIEWDIR, 11);
     }
     FIELD_3BD (view_target, 12);
     FIELD_3BD (VIEWDIR, 0);
     FIELD_BD (twist_angle, 50);
     FIELD_BD (lens_length, 42);
     FIELD_BD (front_clip_z, 43);
     FIELD_BD (back_clip_z, 44);
     FIELD_4BITS (VIEWMODE, 71);
   }
   SINCE (R_2000) {
     FIELD_RC (render_mode, 281);
   }
   SINCE (R_2007) {
     IF_ENCODE_FROM_EARLIER {
       FIELD_VALUE (use_default_lights) = 1;
       FIELD_VALUE (default_lightning_type) = 1;
       FIELD_VALUE (ambient_color.index) = 250;
       //TODO FIELD_VALUE (ambient_color.rgb) = ?;
     }
     FIELD_HANDLE0 (background, 4, 332);
     FIELD_HANDLE0 (visualstyle, 5, 348);
     FIELD_B (use_default_lights, 292);
     FIELD_RC (default_lightning_type, 282);
     FIELD_BD (brightness, 141);
     FIELD_BD (contrast, 142);
     FIELD_CMC (ambient_color, 63);
     FIELD_HANDLE0 (sun, 3, 361);
   }
   // end of ViInfo
 
   // subclass ViewTableRecord:
   SINCE (R_13b1) {
     FIELD_B (is_pspace, 0);
     FIELD_VALUE (flag) |= FIELD_VALUE (is_pspace);
   }
   SINCE (R_2000) {
     FIELD_B (associated_ucs, 72);
     if (FIELD_VALUE (associated_ucs)) {
       FIELD_3BD (ucsorg, 110);
       FIELD_3BD (ucsxdir, 111);
       FIELD_3BD (ucsydir, 112);
       FIELD_BD (ucs_elevation, 146);
       FIELD_BS (UCSORTHOVIEW, 79);
       FIELD_HANDLE (base_ucs, 5, 346);
       FIELD_HANDLE0 (named_ucs, 5, 345);
     }
   }
 
   SINCE (R_2007) {
     FIELD_B (is_camera_plottable, 73);
   }
   START_OBJECT_HANDLE_STREAM;
   SINCE (R_2007) {
     FIELD_HANDLE0 (livesection, 4, 334); // a SECTIONOBJECT?
   }
@@ -4069,43 +4069,43 @@ DWG_OBJECT (UCS_CONTROL)
 DWG_OBJECT_END
 
 /* (63/T6) */
-DWG_OBJECT (UCS)
+DWG_TABLE (UCS)
 
   COMMON_TABLE_FLAGS (UCS)
   PRE (R_13b1)
   {
     FIELD_3RD (ucsorg, 10);
     FIELD_3RD (ucsxdir, 11);
     FIELD_3RD (ucsydir, 12);
   }
   LATER_VERSIONS
   {
     FIELD_3BD (ucsorg, 10);
     FIELD_3BD (ucsxdir, 11);
     FIELD_3BD (ucsydir, 12);
   }
   SINCE (R_2000)
   {
     DXF {
       FIELD_BS (UCSORTHOVIEW, 79);
       FIELD_BD (ucs_elevation, 146);
       if (FIELD_VALUE (UCSORTHOVIEW)) {
         FIELD_HANDLE0 (base_ucs, 5, 346);
       }
     } else {
       FIELD_BD0 (ucs_elevation, 146);
       FIELD_BS (UCSORTHOVIEW, 79);
     }
     FIELD_HANDLE (base_ucs, 5, 0);
     FIELD_HANDLE (named_ucs, 5, 0);
 
     FIELD_BS (num_orthopts, 0);
     REPEAT (num_orthopts, orthopts, Dwg_UCS_orthopts)
     REPEAT_BLOCK
       SUB_FIELD_BS (orthopts[rcount1],type, 71);
       SUB_FIELD_3BD (orthopts[rcount1],pt, 13);
       SET_PARENT_OBJ (orthopts[rcount1]);
     END_REPEAT_BLOCK
     END_REPEAT (orthopts);
   }
   START_OBJECT_HANDLE_STREAM;
@@ -4121,185 +4121,185 @@ DWG_OBJECT (VPORT_CONTROL)
 DWG_OBJECT_END
 
 /* (65) */
-DWG_OBJECT (VPORT)
+DWG_TABLE (VPORT)
 
   COMMON_TABLE_FLAGS (Viewport)
 
   DXF { // has a different order of fields
 
     FIELD_2RD (lower_left, 10);
     FIELD_2RD (upper_right, 11);
     FIELD_2RD (VIEWCTR, 12);
     FIELD_2RD (SNAPBASE, 13);
     FIELD_2RD (SNAPUNIT, 14);
     FIELD_2RD (GRIDUNIT, 15);
     FIELD_3RD (VIEWDIR, 16);
     FIELD_3RD (view_target, 17);
     FIELD_RD (VIEWSIZE, 40);
     FIELD_RD (aspect_ratio, 41); // = view_width / VIEWSIZE
     FIELD_RD (lens_length, 42);
     FIELD_RD (front_clip_z, 43);
     FIELD_RD (back_clip_z, 44);
     FIELD_RD (SNAPANG, 50);
     FIELD_RD (view_twist, 51);
     FIELD_RS (UCSFOLLOW, 71);
     // FIELD_VALUE (VIEWMODE) |= (FIELD_VALUE (UCSFOLLOW) << 2);
     //VIEWMODE: UCSVP bit 0, ucs_at_origin bit 1, UCSFOLLOW bit 3
     FIELD_RS (circle_zoom, 72); // 1000
     FIELD_RS (FASTZOOM, 73);
     FIELD_RS (UCSICON, 74);
     FIELD_RS (SNAPMODE, 75);
     FIELD_RS (GRIDMODE, 76);
     FIELD_RS (SNAPSTYLE, 77);
     FIELD_RS (SNAPISOPAIR, 78);
 
     SINCE (R_2000) {
       FIELD_RS (render_mode, 281); // ODA has it as RC
       FIELD_RS (UCSVP, 65); // in DWG as bit 0 of VIEWMODE. ODA bug, documented as 71
       FIELD_3BD (ucsorg, 110);
       FIELD_3BD (ucsxdir, 111);
       FIELD_3BD (ucsydir, 112);
       FIELD_HANDLE0 (named_ucs, 5, 345);
       if (FIELD_VALUE (UCSORTHOVIEW))
         FIELD_HANDLE (base_ucs, 5, 346);
       FIELD_RS (UCSORTHOVIEW, 79);
       FIELD_RD (ucs_elevation, 146);
     }
     SINCE (R_2007) {
       FIELD_HANDLE0 (background, 4, 332);
       FIELD_HANDLE0 (visualstyle, 5, 348);
       FIELD_RS (grid_flags, 60);
       FIELD_RS (grid_major, 61);
       FIELD_B (use_default_lights, 292);
       FIELD_RC (default_lightning_type, 282);
       FIELD_RD (brightness, 141);
       FIELD_RD (contrast, 142);
       FIELD_CMC (ambient_color, 63);
       FIELD_HANDLE0 (sun, 5, 361);
     }
 
     //TODO convert back 1001 1070 xdata
     REACTORS (4);
     XDICOBJHANDLE (3);
 
   }
   /* end of DXF: now DWG */
   else {
 
     PRE (R_13b1) {
       FIELD_2RD (lower_left, 10);
       FIELD_2RD (upper_right, 11);
       FIELD_3RD (view_target, 17);
       FIELD_3RD (VIEWDIR, 16);
       FIELD_RD (view_twist, 51);
       FIELD_RD (VIEWSIZE, 40);
       FIELD_2RD (VIEWCTR, 12);
       FIELD_RD (aspect_ratio, 41);
       DECODER {
         FIELD_VALUE (view_width) = FIELD_VALUE (aspect_ratio) * FIELD_VALUE (VIEWSIZE);
         LOG_TRACE ("view_width: %f (calc)\n", FIELD_VALUE (view_width))
       }
       FIELD_RD (lens_length, 42);
       FIELD_RD (front_clip_z, 43);
       FIELD_RD (back_clip_z, 44);
       FIELD_RS (UCSFOLLOW, 71);
       FIELD_RS (circle_zoom, 72); //circle sides
       FIELD_RS (FASTZOOM, 73);
       FIELD_RS (UCSICON, 74);
       FIELD_RS (SNAPMODE, 75);
       FIELD_RS (GRIDMODE, 76);
       FIELD_RS (SNAPSTYLE, 77);
       FIELD_RS (SNAPISOPAIR, 78);
       FIELD_RD (SNAPANG, 50);
       FIELD_2RD (SNAPBASE, 13);
       FIELD_2RD (SNAPUNIT, 14);
       FIELD_2RD (GRIDUNIT, 15);
     }
     else // PRE (R_13
     {
       FIELD_BD (VIEWSIZE, 40);  // i.e view height
       FIELD_BD (view_width, 0); // -nan in example_2000
       DECODER {
         FIELD_VALUE (aspect_ratio) = FIELD_VALUE (VIEWSIZE) == 0.0
           ? 0.0
           : FIELD_VALUE (view_width) / FIELD_VALUE (VIEWSIZE);
         LOG_TRACE ("aspect_ratio: %f (calc)\n", FIELD_VALUE (aspect_ratio))
       }
       JSON {
         FIELD_BD (aspect_ratio, 0);
       }
       // subclass ViInfo (shared with VIEW, but different DXF codes)
       FIELD_2RD (VIEWCTR, 12);
       FIELD_3BD (view_target, 17);
       FIELD_3BD (VIEWDIR, 16);
       FIELD_BD (view_twist, 51);
       FIELD_BD (lens_length, 42);
       FIELD_BD (front_clip_z, 43);
       FIELD_BD (back_clip_z, 44);
       // UCSFOLLOW is bit 3 of 71, UCSVP bit 0, ucs_at_origin bit 1. below decoded again.
       FIELD_4BITS (VIEWMODE, 71);
       SINCE (R_2000) {
         FIELD_RC (render_mode, 281);
       }
       SINCE (R_2007) {
         IF_ENCODE_FROM_EARLIER {
           FIELD_VALUE (use_default_lights) = 1;
           FIELD_VALUE (default_lightning_type) = 1;
           FIELD_VALUE (ambient_color.index) = 250;
           //TODO FIELD_VALUE (ambient_color.rgb) = ?;
           //TODO FIELD_VALUE (ambient_color.byte) = ?; //+ name, book_name
         }
         VERSIONS (R_13b1, R_2004) {
           FIELD_HANDLE (sun, 3, 361);
         }
         SINCE (R_2007) {
           FIELD_HANDLE (background, 4, 332); //soft ptr
           FIELD_HANDLE (visualstyle, 5, 348); //hard ptr
           FIELD_HANDLE (sun, 3, 361); //hard owner
         }
         FIELD_B (use_default_lights, 292);
         FIELD_RC (default_lightning_type, 282);
         FIELD_BD (brightness, 141);
         FIELD_BD (contrast, 142);
         FIELD_CMC (ambient_color, 63); // +421, 431
       }
     
       FIELD_2RD (lower_left, 10);
       FIELD_2RD (upper_right, 11);
       FIELD_B (UCSFOLLOW, 0); // bit 3 of 71
       FIELD_BS (circle_zoom, 72);
       FIELD_B (FASTZOOM, 73);
       FIELD_BB (UCSICON, 74); // bits 0 and 1 of 71: uscicon_on, ucsicon_at_origin
       FIELD_B (GRIDMODE, 76);
       FIELD_2RD (GRIDUNIT, 15);
       FIELD_B (SNAPMODE, 75);
       FIELD_B (SNAPSTYLE, 77);
       FIELD_BS (SNAPISOPAIR, 78);
       if (dwg->header.dwg_version != 0x1a) { // AC1020/R_2006 only here
         FIELD_BD (SNAPANG, 50);
         FIELD_2RD (SNAPBASE, 13);
       }
       FIELD_2RD (SNAPUNIT, 14);
     
       SINCE (R_2000) {
         FIELD_B (ucs_at_origin, 0);
         FIELD_B (UCSVP, 71);
         FIELD_3BD (ucsorg, 110);
         FIELD_3BD (ucsxdir, 111);
         FIELD_3BD (ucsydir, 112);
         FIELD_BD (ucs_elevation, 146);
         FIELD_BS (UCSORTHOVIEW, 79);
       }
     
       SINCE (R_2007) {
         FIELD_BS (grid_flags, 60);
         FIELD_BS (grid_major, 61);
       }
     }
 
     START_OBJECT_HANDLE_STREAM;
     SINCE (R_2000) {
       FIELD_HANDLE0 (named_ucs, 5, 345);
       FIELD_HANDLE0 (base_ucs, 5, 346);
     }
   } // DWG
@@ -4316,14 +4316,14 @@ DWG_OBJECT (APPID_CONTROL)
 DWG_OBJECT_END
 
 /* (67/T8) Registered Apps */
-DWG_OBJECT (APPID)
+DWG_TABLE (APPID)
 
   COMMON_TABLE_FLAGS (RegApp)
   SINCE (R_13b1) {
     DXF {
       FIELD_RS0 (unknown, 71); // in DXF only with ADE_PROJECTION
     } else {
       FIELD_RC (unknown, 71);
     }
   }
   START_OBJECT_HANDLE_STREAM;
@@ -4347,269 +4347,269 @@ DWG_OBJECT (DIMSTYLE_CONTROL)
 DWG_OBJECT_END
 
 /* (69/T9) */
-DWG_OBJECT (DIMSTYLE)
+DWG_TABLE (DIMSTYLE)
 
   DXF {
     FIELD_VALUE (flag) = FIELD_VALUE (flag0);
   }
   COMMON_TABLE_FLAGS (DimStyle)
 
   PRE (R_13b1)
     {
       FIELD_RD (DIMSCALE, 40); // d42
       FIELD_RD (DIMASZ, 41);
       FIELD_RD (DIMEXO, 42);
       FIELD_RD (DIMDLI, 43);
       FIELD_RD (DIMEXE, 44);
       FIELD_RD (DIMRND, 45);
       FIELD_RD (DIMDLE, 46);
       FIELD_RD (DIMTP, 47);
       FIELD_RD (DIMTM, 48); // ok
       FIELD_RD (DIMTXT, 140);
       FIELD_RD (DIMCEN, 141); // ok
       FIELD_RD (DIMTSZ, 142);
       FIELD_RD (DIMALTF, 143);
       FIELD_RD (DIMLFAC, 144);
       FIELD_RD (DIMTVP, 145); // db2
       FIELD_RC (DIMTOL, 71);
       FIELD_RC (DIMLIM, 72);
       FIELD_RC (DIMTIH, 73);
       FIELD_RC (DIMTOH, 74);
       FIELD_RC (DIMSE1, 75);
       FIELD_RC (DIMSE2, 76);
       FIELD_CAST (DIMTAD, RC, RS, 77); // ok
       FIELD_CAST (DIMZIN, RC, BS, 78); // dc1
       FIELD_RC (DIMALT, 170);
       FIELD_CAST (DIMALTD, RC, BS, 171); // ok
       FIELD_RC (DIMTOFL, 172);           // ok
       FIELD_RC (DIMSAH, 173);            // ok
       FIELD_RC (DIMTIX, 174);            // ok
       FIELD_RC (DIMSOXD, 175);           // ok
       FIELD_TFv (DIMPOST, 16, 3);        // ok dc8
       FIELD_TFv (DIMAPOST, 16, 4);       // dd8
       FIELD_TFv (DIMBLK_T, 16, 5);       //?? unsupported by ODA
       FIELD_TFv (DIMBLK1_T, 16, 6);      //?? unsupported by ODA
       FIELD_TFv (DIMBLK2_T, 66, 7);      //?? unsupported by ODA
       // DEBUG_HERE; //e18
       // dat->byte += 50; //unknown: DIMSHO, DIMASO (global)
       FIELD_RS (DIMCLRD_N, 176); // e4a
       FIELD_RS (DIMCLRE_N, 177);
       FIELD_RS (DIMCLRT_N, 178); // e4e
       FIELD_RC (DIMUPT, 0);      //??
       FIELD_RD (DIMTFAC, 146);   // e51
       FIELD_RD (DIMGAP, 147);    // e59
     }
   VERSIONS (R_13b1, R_14)
     {
       DXF {
         FIELD_TV (DIMPOST, 3);
         FIELD_TV (DIMAPOST, 4);
         FIELD_TV (DIMBLK_T, 5);
         FIELD_TV (DIMBLK1_T, 6);
         FIELD_TV (DIMBLK2_T, 7);
         FIELD_BD (DIMSCALE, 40);
         FIELD_BD (DIMASZ, 41);
         FIELD_BD (DIMEXO, 42);
         FIELD_BD (DIMDLI, 43);
         FIELD_BD (DIMEXE, 44);
         FIELD_BD (DIMRND, 45);
         FIELD_BD (DIMDLE, 46);
         FIELD_BD (DIMTP, 47);
         FIELD_BD (DIMTM, 48);
       }
       FIELD_B (DIMTOL, 71);
       FIELD_B (DIMLIM, 72);
       FIELD_B (DIMTIH, 73);
       FIELD_B (DIMTOH, 74);
       FIELD_B (DIMSE1, 75);
       FIELD_B (DIMSE2, 76);
       FIELD_B (DIMALT, 170);
       FIELD_B (DIMTOFL, 172);
       FIELD_B (DIMSAH, 173);
       FIELD_B (DIMTIX, 174);
       FIELD_B (DIMSOXD, 175);
       FIELD_CAST (DIMALTD, RC, BS, 171);
       FIELD_CAST (DIMZIN, RC, BS, 78);
       FIELD_B (DIMSD1, 281);
       FIELD_B (DIMSD2, 282);
       FIELD_CAST (DIMTOLJ, RC, BS, 283);
       FIELD_CAST (DIMJUST, RC, BS, 280);
       FIELD_CAST (DIMFIT, RC, BS, 287);
       FIELD_B (DIMUPT, 288);
       FIELD_CAST (DIMTZIN, RC, BS, 284);
       FIELD_CAST (DIMMALTZ, RC, BS, 285);
       FIELD_CAST (DIMMALTTZ, RC, BS, 286);
       FIELD_CAST (DIMTAD, RC, BS, 77);
       FIELD_BS (DIMUNIT, 270);
       FIELD_BS (DIMAUNIT, 0);
       FIELD_BS (DIMDEC, 271);
       FIELD_BS (DIMTDEC, 272);
       FIELD_BS (DIMALTU, 273);
       FIELD_BS (DIMALTTD, 274);
       DXF {
         FIELD_HANDLE (DIMTXSTY, 5, 340);
         FIELD_BS (DIMAUNIT, 275);
       }
       FIELD_BD (DIMSCALE, 40);
       FIELD_BD (DIMASZ, 0);
       FIELD_BD (DIMEXO, 0);
       FIELD_BD (DIMDLI, 0);
       FIELD_BD (DIMEXE, 0);
       FIELD_BD (DIMRND, 0);
       FIELD_BD (DIMDLE, 0);
       FIELD_BD (DIMTP, 0);
       FIELD_BD (DIMTM, 0);
       FIELD_BD (DIMTXT, 140);
       FIELD_BD (DIMCEN, 141);
       FIELD_BD (DIMTSZ, 142);
       FIELD_BD (DIMALTF, 143);
       FIELD_BD (DIMLFAC, 144);
       FIELD_BD (DIMTVP, 145);
       FIELD_BD (DIMTFAC, 146);
       FIELD_BD (DIMGAP, 147);
       FIELD_TV (DIMPOST, 0);
       FIELD_TV (DIMAPOST, 0);
       FIELD_TV (DIMBLK_T, 0);
       FIELD_TV (DIMBLK1_T, 0);
       FIELD_TV (DIMBLK2_T, 0);
       FIELD_CMC (DIMCLRD, 176);
       FIELD_CMC (DIMCLRE, 177);
       FIELD_CMC (DIMCLRT, 178);
     }
   else FREE {
       FIELD_TV (DIMBLK_T, 5);
       FIELD_TV (DIMBLK1_T, 6);
       FIELD_TV (DIMBLK2_T, 7);
   }
   IF_FREE_OR_SINCE (R_2000)
     {
       FIELD_T0 (DIMPOST, 3); // name of dimtxtsty
       FIELD_T0 (DIMAPOST, 4)
       FIELD_BD1 (DIMSCALE, 40);
       FIELD_BD0 (DIMASZ, 41);
       FIELD_BD0 (DIMEXO, 42);
       FIELD_BD0 (DIMDLI, 43);
       FIELD_BD0 (DIMEXE, 44);
       FIELD_BD0 (DIMRND, 45);
       FIELD_BD0 (DIMDLE, 46);
       FIELD_BD0 (DIMTP, 47);
       FIELD_BD0 (DIMTM, 48);
     }
 
   SINCE (R_2007)
     {
       FIELD_BD0 (DIMFXL, 49);
       FIELD_BD0 (DIMJOGANG, 50);
       FIELD_BS0 (DIMTFILL, 69);
       FIELD_CMC0 (DIMTFILLCLR, 70);
       DXF {
         FIELD_BS0 (DIMARCSYM, 90);
         FIELD_B0 (DIMFXLON, 290);
       }
     }
 
   SINCE (R_2000)
     {
       FIELD_B0 (DIMTOL, 71);
       FIELD_B0 (DIMLIM, 72);
       FIELD_B (DIMTIH, 73);
       FIELD_B (DIMTOH, 74);
       FIELD_B0 (DIMSE1, 75);
       FIELD_B0 (DIMSE2, 76);
       FIELD_BS0 (DIMTAD, 77);
       FIELD_BS0 (DIMZIN, 78);
       FIELD_BS0 (DIMAZIN, 79);
     }
 
   SINCE (R_2007)
     {
       FIELD_BS (DIMARCSYM, 0);
     }
 
   IF_FREE_OR_SINCE (R_2000)
     {
       FIELD_BD0 (DIMTXT, 140);
       FIELD_BD0 (DIMCEN, 141);
       FIELD_BD0 (DIMTSZ, 142);
       FIELD_BD0 (DIMALTF, 143);
       FIELD_BD0 (DIMLFAC, 144);
       FIELD_BD0 (DIMTVP, 145);
       FIELD_BD0 (DIMTFAC, 146);
       FIELD_BD0 (DIMGAP, 147);
       FIELD_BD0 (DIMALTRND, 148);
       FIELD_B0 (DIMALT, 170);
       FIELD_BS0 (DIMALTD, 171);
       FIELD_B0 (DIMTOFL, 172);
       FIELD_B0 (DIMSAH, 173);
       FIELD_B0 (DIMTIX, 174);
       FIELD_B0 (DIMSOXD, 175);
       FIELD_CMC0 (DIMCLRD, 176);
       FIELD_CMC0 (DIMCLRE, 177);
       FIELD_CMC0 (DIMCLRT, 178);
       FIELD_BS0 (DIMADEC, 179);
       FIELD_BS0 (DIMDEC, 271);
       FIELD_BS0 (DIMTDEC, 272);
       FIELD_BS0 (DIMALTU, 273);
       FIELD_BS0 (DIMALTTD, 274);
       FIELD_BS0 (DIMAUNIT, 275);
 
       FIELD_BS0 (DIMFRAC, 276);
       FIELD_BS0 (DIMLUNIT, 277);
       FIELD_BS0 (DIMDSEP, 278);
       FIELD_BS0 (DIMTMOVE, 279);
 
       FIELD_BS0 (DIMJUST, 280);
       FIELD_B0 (DIMSD1, 281);
       FIELD_B0 (DIMSD2, 282);
       FIELD_BS (DIMTOLJ, 283);
       FIELD_BS0 (DIMTZIN, 284);
       FIELD_BS0 (DIMALTZ, 285);
       FIELD_BS0 (DIMALTTZ, 286);
       FIELD_B0 (DIMUPT, 288);
       FIELD_BS0 (DIMATFIT, 289);
       FIELD_HANDLE (DIMTXSTY, 5, 340);
     }
 
   SINCE (R_2007)
     {
       FIELD_B (DIMFXLON, 0);
     }
 
   IF_FREE_OR_SINCE (R_2010)
     {
       FIELD_B (DIMTXTDIRECTION, 295);
       FIELD_BD (DIMALTMZF, 0); // undocumented
       FIELD_T (DIMALTMZS, 0); // undocumented
       FIELD_BD (DIMMZF, 0); // undocumented
       FIELD_T (DIMMZS, 0); // undocumented
     }
 
   SINCE (R_2000)
     {
       FIELD_BSd (DIMLWD, 371);
       FIELD_BSd (DIMLWE, 372);
     }
 
   SINCE (R_13b1)
   {
     FIELD_B (flag0, 0); // Bit 0 of 70
     FIELD_VALUE (flag) |= FIELD_VALUE (flag0); //dimtofl?
 
     START_OBJECT_HANDLE_STREAM;
     UNTIL (R_14) {
       FIELD_HANDLE (DIMTXSTY, 5, 0); // 2000+ already before
     }
   }
   IF_FREE_OR_SINCE (R_2000)
     {
       FIELD_HANDLE (DIMLDRBLK, 5, 341); /* Leader arrow (DIMLDRBLK)*/
       FIELD_HANDLE (DIMBLK, 5, 342);  /* Arrow */
       FIELD_HANDLE (DIMBLK1, 5, 343); /* Arrow 1 */
       FIELD_HANDLE (DIMBLK2, 5, 344); /* Arrow 2 */
     }
   IF_FREE_OR_SINCE (R_2007)
     {
       FIELD_HANDLE (DIMLTYPE, 5, 345);
       FIELD_HANDLE (DIMLTEX1, 5, 346);
       FIELD_HANDLE (DIMLTEX2, 5, 347);
     }
@@ -4628,23 +4628,23 @@ DWG_OBJECT_END
 
 /* (71/T10)
 */
-DWG_OBJECT (VX_TABLE_RECORD)
+DWG_TABLE (VX_TABLE_RECORD)
 
   COMMON_TABLE_FLAGS (VX)
   PRE (R_13b1)
     {
       SINCE (R_11)
         FIELD_RSd (used, 0);
       FIELD_RS (vport_entity_address, 0);
       FIELD_RSd (unknown1, 0);
       FIELD_RS (unknown2, 0);
     }
   LATER_VERSIONS
     {
       FIELD_B (is_on, 290); // bit 1 of 70
       FIELD_VALUE (flag) |= FIELD_VALUE (is_on) << 1;
 
       START_OBJECT_HANDLE_STREAM;
       FIELD_HANDLE (viewport, 4, 338);
       FIELD_HANDLE (prev_entry, 5, 340);
     }
diff --git a/src/spec.h b/src/spec.h
index 32d3129c..6087ae29 100644
--- a/src/spec.h
+++ b/src/spec.h
@@ -1,1180 +1,1182 @@
 /*****************************************************************************/
 /*  LibreDWG - free implementation of the DWG file format                    */
 /*                                                                           */
 /*  Copyright (C) 2018-2020 Free Software Foundation, Inc.                   */
 /*                                                                           */
 /*  This library is free software, licensed under the terms of the GNU       */
 /*  General Public License as published by the Free Software Foundation,     */
 /*  either version 3 of the License, or (at your option) any later version.  */
 /*  You should have received a copy of the GNU General Public License        */
 /*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
 /*****************************************************************************/
 
 #ifndef SPEC_H
 #  define SPEC_H
 
 #  undef _GNU_SOURCE
 #  define _GNU_SOURCE
 #  include <string.h>
 #  include "decode.h"
 
 #  define DECODER if (0)
 #  define ENCODER if (0)
 #  define PRINT if (0)
 /* DECODER_ENCODER_OR_JSON really, or just NOT_DXF */
 #  define DECODER_OR_ENCODER if (0)
 #  define DXF_OR_PRINT if (0)
 #  define DXF if (0)
 #  define JSON if (0)
 #  define FREE if (0)
 #  define IF_FREE_OR_SINCE(x) SINCE (x)
 #  define IF_FREE_OR_VERSIONS(x, y) VERSIONS (x, y)
 #  ifndef IF_ENCODE_FROM_EARLIER
 #    define IF_ENCODE_FROM_EARLIER if (0)
 #    define IF_ENCODE_FROM_EARLIER_OR_DXF if (0)
 #    define IF_ENCODE_FROM_PRE_R13 if (0)
 #    define IF_ENCODE_FROM_PRE_R2000 if (0)
 #  endif
 #  ifndef IF_ENCODE_SINCE_R13
 #    define IF_ENCODE_SINCE_R13 if (0)
 #  endif
 #  define IF_IS_ENCODER 0
 #  define IF_IS_DECODER 0
 #  define IF_IS_DXF 0
 #  define IF_IS_FREE 0
 
 #  ifndef ACTION
 #    error ACTION define missing: decode, encode, dxf, json, ...
 #  endif
 #  define _DWG_FUNC_N(ACTION, name) dwg_##ACTION##_##name
 #  define DWG_FUNC_N(ACTION, name) _DWG_FUNC_N (ACTION, name)
 #  define _DWG_PRIVATE_N(ACTION, name) dwg_##ACTION##_##name##_private
 #  define DWG_PRIVATE_N(ACTION, name) _DWG_PRIVATE_N (ACTION, name)
 
 #  define SET_PARENT(field, obj)
 #  define SET_PARENT_OBJ(field)
 #  define SET_PARENT_FIELD(field, what_parent, obj)
 
 #  ifndef ISFIRST
 #    define ISFIRST
 #    define SETFIRST
 #    define CLEARFIRST
 #  endif
 
 // for compile-time range checks with n=3,10,1000,5000,10000,20000,100000
 //#  define LOG2_APPROX(n) (size_t)((-0.344845 * (n) * (n)) + (2.024658 * (n))
 //- 1.674873) #  define _IN_RANGE     (sizeof (_obj->field) >= LOG2_APPROX
 //(maxvalue) / 8)
 #  define _IN_RANGE(var, n)                                                   \
     ((sizeof (var) == 1 && n <= 0xff) || (sizeof (var) == 2 && n <= 0xffff)   \
      || (sizeof (var) >= 4))
 
 #  ifndef IS_FREE
 #    define VALUEOUTOFBOUNDS(field, maxvalue)                                 \
       if (_IN_RANGE (_obj->field, maxvalue) && _obj->field > maxvalue)        \
         {                                                                     \
           LOG_ERROR ("Invalid %s." #field " %lu", obj->name,                  \
                      (unsigned long)_obj->field);                             \
           _obj->field = 0;                                                    \
           return DWG_ERR_VALUEOUTOFBOUNDS;                                    \
         }
 #    define SUB_VALUEOUTOFBOUNDS(o, field, maxvalue)                          \
       if (_IN_RANGE (_obj->o.field, maxvalue) && _obj->o.field > maxvalue)    \
         {                                                                     \
           LOG_ERROR ("Invalid %s." #field " %lu", obj->name,                  \
                      (unsigned long)_obj->o.field);                           \
           _obj->o.field = 0;                                                  \
           return DWG_ERR_VALUEOUTOFBOUNDS;                                    \
         }
 #  else
 #    define VALUEOUTOFBOUNDS(field, maxvalue)                                 \
       if (_IN_RANGE (_obj->field, maxvalue) && _obj->field > maxvalue)        \
         {                                                                     \
           return DWG_ERR_VALUEOUTOFBOUNDS;                                    \
         }
 #    define SUB_VALUEOUTOFBOUNDS(o, field, maxvalue)                          \
       if (_IN_RANGE (_obj->o.field, maxvalue) && _obj->o.field > maxvalue)    \
         {                                                                     \
           return DWG_ERR_VALUEOUTOFBOUNDS;                                    \
         }
 #  endif
 
 #endif /* SPEC_H */
 
 #ifndef VALUE_HANDLE
 #  define VALUE_HANDLE(value, nam, handle_code, dxf)
 #endif
 #ifndef VALUE_B
 #  define VALUE_B(value, dxf)
 #endif
 #ifndef VALUE_TV
 #  define VALUE_TV(value, dxf)
 #endif
 #ifndef VALUE_TF
 #  define VALUE_TF(value, dxf)
 #endif
 #ifndef VALUE_TFF
 #  define VALUE_TFF(value, dxf)
 #endif
 #ifndef VALUE_3BD
 #  define VALUE_3BD(value, dxf)
 #endif
 #ifndef VALUE_2RD
 #  define VALUE_2RD(value, dxf)
 #endif
 #ifndef VALUE_2BD
 #  define VALUE_2BD(value, dxf) VALUE_2RD (value, dxf)
 #endif
 #ifndef VALUE_3RD
 #  define VALUE_3RD(value, dxf) VALUE_3BD (value, dxf)
 #endif
 #ifndef VALUE_BS
 #  define VALUE_BS(value, dxf)
 #endif
 #ifndef VALUE_BSd
 #  define VALUE_BSd(value, dxf)
 #endif
 #ifndef VALUE_RSd
 #  define VALUE_RSd(value, dxf)
 #endif
 #ifndef VALUE_BL
 #  define VALUE_BL(value, dxf)
 #endif
 #ifndef KEY
 #  define KEY(nam)
 #endif
 #ifndef BLOCK_NAME
 #  define BLOCK_NAME(nam, dxf) FIELD_T (nam, dxf)
 #endif
 // sub fields
 #ifndef FIELDG
 #  define FIELDG(nam, type, dxf) FIELD (nam, type)
 #endif
 #ifndef SUB_FIELD_BSd
 #  define SUB_FIELD_BSd(o, nam, dxf) FIELD_BSd (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_BSx
 #  define SUB_FIELD_BSx(o, nam, dxf) FIELD_BSx (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_RSx
 #  define SUB_FIELD_RSx(o, nam, dxf) FIELD_RSx (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_TU
 #  define SUB_FIELD_TU(o, nam, dxf) FIELD_TU (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_T
 #  define SUB_FIELD_T(o, nam, dxf) FIELD_T (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_TV
 #  define SUB_FIELD_TV(o, nam, dxf) FIELD_TV (o.nam, dxf)
 #endif
 #ifndef SUB_FIELD_TF
 #  define SUB_FIELD_TF(o, nam, len, dxf) FIELD_TF (o.nam, _obj->o.len, dxf)
 #endif
 #ifndef SUB_FIELD_BL
 #  define SUB_FIELD_B(o, nam, dxf) FIELDG (o.nam, B, dxf)
 #  define SUB_FIELD_BB(o, nam, dxf) FIELDG (o.nam, BB, dxf)
 #  define SUB_FIELD_3B(o, nam, dxf) FIELDG (o.nam, 3B, dxf)
 #  define SUB_FIELD_BS(o, nam, dxf) FIELDG (o.nam, BS, dxf)
 #  define SUB_FIELD_BL(o, nam, dxf) FIELDG (o.nam, BL, dxf)
 #  define SUB_FIELD_BLx(o, nam, dxf) FIELD_BLx (o.nam, dxf)
 #  define SUB_FIELD_BLd(o, nam, dxf) FIELD_BLd (o.nam, dxf)
 #  define SUB_FIELD_RC(o, nam, dxf) FIELDG (o.nam, RC, dxf)
 #  define SUB_FIELD_RS(o, nam, dxf) FIELDG (o.nam, RS, dxf)
 #  define SUB_FIELD_RL(o, nam, dxf) FIELDG (o.nam, RL, dxf)
 #  define SUB_FIELD_BLL(o, nam, dxf) FIELDG (o.nam, BLL, dxf)
 #  define SUB_FIELD_RLL(o, nam, dxf) FIELDG (o.nam, RLL, dxf)
 #  define SUB_FIELD_BD(o, nam, dxf) FIELD_BD (o.nam, dxf)
 #  define SUB_FIELD_RD(o, nam, dxf) FIELD_RD (o.nam, dxf)
 #  define SUB_FIELD_2RD(o, nam, dxf) FIELD_2RD (o.nam, dxf)
 #  define SUB_FIELD_2BD(o, nam, dxf) FIELD_2BD (o.nam, dxf)
 #  define SUB_FIELD_2BD_1(o, nam, dxf) FIELD_2BD_1 (o.nam, dxf)
 #  define SUB_FIELD_3RD(o, nam, dxf) FIELD_3RD (o.nam, dxf)
 #  define SUB_FIELD_3BD(o, nam, dxf) FIELD_3BD (o.nam, dxf)
 #  define SUB_FIELD_3BD_inl(o, nam, dxf) FIELD_3BD (o, dxf)
 #  define SUB_FIELD_3DPOINT(o, nam, dxf) FIELD_3BD (o.nam, dxf)
 //# define SUB_FIELD_ENC(o,nam,dxf1,dxf2) FIELD_ENC(o.nam, dxf1,dxf2)
 #endif
 #ifndef SUB_HANDLE_VECTOR
 #  define SUB_HANDLE_VECTOR(o, nam, sizefield, code, dxf)                     \
     if (_obj->o.sizefield && _obj->o.nam)                                     \
       {                                                                       \
         BITCODE_BL _size = _obj->o.sizefield;                                 \
         for (vcount = 0; vcount < _size; vcount++)                            \
           {                                                                   \
             SUB_FIELD_HANDLE (o, nam[vcount], code, dxf);                     \
           }                                                                   \
       }
 #endif
 
 #ifndef SUB_FIELD_VECTOR
 #  define SUB_FIELD_VECTOR(o, nam, sizefield, type, dxf)                      \
     if (_obj->o.sizefield && _obj->o.nam)                                     \
       {                                                                       \
         BITCODE_BL _size = _obj->o.sizefield;                                 \
         for (vcount = 0; vcount < _size; vcount++)                            \
           {                                                                   \
             SUB_FIELD (o, nam[vcount], type, dxf);                            \
           }                                                                   \
       }
 #endif
 #ifndef SUB_FIELD_VECTOR_N
 #  define SUB_FIELD_VECTOR_N(o, nam, type, size, dxf)                         \
     if (size > 0 && _obj->o.nam != NULL)                                      \
       {                                                                       \
         BITCODE_BL _size = (BITCODE_BL)size;                                  \
         for (vcount = 0; vcount < _size; vcount++)                            \
           {                                                                   \
             SUB_FIELD (o, nam[vcount], type, dxf);                            \
           }                                                                   \
       }
 #endif
 #ifndef FIELD_VECTOR_INL
 #  define FIELD_VECTOR_INL(nam, type, size, dxf)                              \
     FIELD_VECTOR_N (nam, type, size, dxf)
 #endif
 #ifndef SUB_FIELD_VECTOR_INL
 #  define SUB_FIELD_VECTOR_INL(o, nam, type, size, dxf)                       \
     SUB_FIELD_VECTOR_N (o, nam, type, size, dxf)
 #endif
 #ifndef SUB_FIELD_2RD_VECTOR
 #  define SUB_FIELD_2RD_VECTOR(o, name, size, dxf)                            \
     if (_obj->o.size > 0)                                                     \
       {                                                                       \
         for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)         \
           {                                                                   \
             SUB_FIELD_2RD (o, name[vcount], dxf);                             \
           }                                                                   \
       }
 #endif
 #ifndef SUB_FIELD_3BD_VECTOR
 #  define SUB_FIELD_3BD_VECTOR(o, name, size, dxf)                            \
     if (_obj->o.size > 0)                                                     \
       {                                                                       \
         for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)         \
           {                                                                   \
             SUB_FIELD_3BD (o, name[vcount], dxf);                             \
           }                                                                   \
       }
 #endif
 #ifndef FIELD_VECTOR_T1
 #  define FIELD_VECTOR_T1(nam, type, size, dxf)                               \
     FIELD_VECTOR_T (nam, type, size, dxf)
 #endif
 #ifndef SUB_FIELD_VECTOR_TYPESIZE
 #  define SUB_FIELD_VECTOR_TYPESIZE(o, nam, size, typesize, dxf)              \
     if (_obj->o.size && _obj->o.nam)                                          \
       {                                                                       \
         for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)         \
           {                                                                   \
             switch (typesize)                                                 \
               {                                                               \
               case 0:                                                         \
                 break;                                                        \
               case 1:                                                         \
                 SUB_FIELD (o, nam[vcount], RC, dxf);                          \
                 break;                                                        \
               case 2:                                                         \
                 SUB_FIELD (o, nam[vcount], RS, dxf);                          \
                 break;                                                        \
               case 4:                                                         \
                 SUB_FIELD (o, nam[vcount], RL, dxf);                          \
                 break;                                                        \
               case 8:                                                         \
                 SUB_FIELD (o, nam[vcount], RLL, dxf);                         \
                 break;                                                        \
               default:                                                        \
                 LOG_ERROR ("Unknown SUB_FIELD_VECTOR_TYPE " #nam              \
                            " typesize %d",                                    \
                            typesize);                                         \
                 break;                                                        \
               }                                                               \
           }                                                                   \
       }
 #endif
 
 // logging format overrides
 #ifndef FIELD_RLx
 #  define FIELD_RLx(name, dxf) FIELD_RL (name, dxf)
 #endif
 #ifndef FIELD_RSx
 #  define FIELD_RSx(name, dxf) FIELD_RS (name, dxf)
 #endif
 #ifndef FIELD_RCx
 #  define FIELD_RCx(name, dxf) FIELD_RC (name, dxf)
 #endif
 #ifndef FIELD_BLx
 #  define FIELD_BLx(name, dxf) FIELD_BL (name, dxf)
 #endif
 #ifndef FIELD_TFv
 #  define FIELD_TFv(name, len, dxf) FIELD_TV (name, dxf)
 #endif
 #ifndef FIELD_TFFx
 #  define FIELD_TFFx(name, len, dxf) FIELD_TFF (name, len, dxf)
 #endif
 #ifndef FIELD_TU32
 #  define FIELD_TU32(name, dxf) FIELD_TV (name, dxf)
 #endif
 #ifndef FIELD_RLd
 #  define FIELD_RLd(name, dxf) FIELD_RL (name, dxf)
 #endif
 #ifndef FIELD_BLd
 #  define FIELD_BLd(name, dxf) FIELD_BL (name, dxf)
 #endif
 #ifndef FIELD_BSx
 #  define FIELD_BSx(name, dxf) FIELD_BS (name, dxf)
 #endif
 #ifndef FIELD_BSd
 #  define FIELD_BSd(name, dxf) FIELD_BS (name, dxf)
 #endif
 #ifndef FIELD_RSd
 #  define FIELD_RSd(name, dxf) FIELD_RS (name, dxf)
 #endif
 #ifndef FIELD_RCu
 #  define FIELD_RCu(name, dxf) FIELD_RC (name, dxf)
 #endif
 #ifndef FIELD_RCd
 #  define FIELD_RCd(name, dxf) FIELD_RC (name, dxf)
 #endif
 #ifndef VALUE_BINARY
 #  define VALUE_BINARY(value, len, dxf)
 #endif
 #ifndef FIELD_BINARY
 #  define FIELD_BINARY(name, len, dxf) FIELD_TF (name, len, dxf)
 #endif
 // force truecolor
 #ifndef FIELD_CMTC
 #  define FIELD_CMTC(name, dxf)                                               \
     {                                                                         \
       Dwg_Version_Type _ver = dat->version;                                   \
       if (dat->version < R_2004)                                              \
         dat->version = R_2004;                                                \
       FIELD_CMC (name, dxf);                                                  \
       dat->version = _ver;                                                    \
     }
 #endif
 #ifndef SUB_FIELD_CMTC
 #  define SUB_FIELD_CMTC(o, name, dxf)                                        \
     {                                                                         \
       Dwg_Version_Type _ver = dat->version;                                   \
       if (dat->version < R_2004)                                              \
         dat->version = R_2004;                                                \
       SUB_FIELD_CMC (o, name, dxf);                                           \
       dat->version = _ver;                                                    \
     }
 #endif
 // on DXF skip if 0
 #ifndef FIELD_BD0
 #  define FIELD_2RD0(name, dxf) FIELD_2RD (name, dxf)
 #  define FIELD_RD0(name, dxf) FIELD_RD (name, dxf)
 #  define FIELD_RD1(name, dxf) FIELD_RD (name, dxf)
 #  define FIELD_BD0(name, dxf) FIELD_BD (name, dxf)
 #  define FIELD_BD1(name, dxf) FIELD_BD (name, dxf)
 #  define FIELD_BL0(name, dxf) FIELD_BL (name, dxf)
 #  define SUB_FIELD_BL0(o, name, dxf) SUB_FIELD_BL (o, name, dxf)
 #  define FIELD_B0(name, dxf) FIELD_B (name, dxf)
 #  define FIELD_BS0(name, dxf) FIELD_BS (name, dxf)
 #  define FIELD_BS1(name, dxf) FIELD_BS (name, dxf)
 #  define FIELD_RC0(name, dxf) FIELD_RC (name, dxf)
 #  define FIELD_RS0(name, dxf) FIELD_RS (name, dxf)
 #  define FIELD_RL0(name, dxf) FIELD_RL (name, dxf)
 #  define FIELD_BT0(name, dxf) FIELD_BT (name, dxf)
 #  define VALUE_T0(name, dxf) VALUE_T (name, dxf)
 #  define FIELD_TV0(name, dxf) FIELD_TV (name, dxf)
 #  define FIELD_T0(name, dxf) FIELD_T (name, dxf)
 #  define FIELD_CMC0(color, dxf) FIELD_CMC (color, dxf)
 #  define FIELD_HANDLE0(name, code, dxf) FIELD_HANDLE (name, code, dxf)
 #  define SUB_FIELD_HANDLE0(o, name, code, dxf)                               \
     SUB_FIELD_HANDLE (o, name, code, dxf)
 #endif
 #ifndef VALUE_TV0
 #  define VALUE_TV0(name, dxf) VALUE_TV (name, dxf)
 #endif
 
 #ifndef FIELD_2RD_1
 #  define FIELD_2RD_1(nam, dxf) FIELD_2RD (nam, dxf)
 #endif
 
 // double to text
 #ifndef FIELD_D2T
 #  define FIELD_D2T(name, dxf) FIELD_TV (name, dxf)
 #endif
 #ifndef LOG_TRACE_TF
 #  define LOG_TRACE_TF(var, len)
 #  define LOG_INSANE_TF(var, len)
 #endif
 #ifndef SUBCLASS
 #  define SUBCLASS(text)
 #endif
 #ifndef DXF_3DSOLID
 #  define DXF_3DSOLID
 #endif
 #ifndef JSON_3DSOLID
 #  define JSON_3DSOLID
 #endif
 #ifndef FIELD_2PT_TRACE
 #  define FIELD_2PT_TRACE(name, type, dxf)                                    \
     LOG_TRACE (#name ": (" FORMAT_BD ", " FORMAT_BD ") [" #type " %d]\n",     \
                _obj->name.x, _obj->name.y, dxf)
 #  define FIELD_3PT_TRACE(name, type, dxf)                                    \
     LOG_TRACE (#name ": (" FORMAT_BD ", " FORMAT_BD ", " FORMAT_BD            \
                      ") [" #type " %d]\n",                                    \
                _obj->name.x, _obj->name.y, _obj->name.z, dxf)
 #endif
 #ifndef FIELD_ENC
 #  define FIELD_ENC(a, b, c) FIELD_CMC (a, b, c)
 #endif
 #ifndef SUB_FIELD_ENC
 #  define SUB_FIELD_ENC(a, b, c, d) SUB_FIELD_CMC (a, b, c, d)
 #endif
 
 #ifdef IS_ENCODER
 #  undef ENCODER
 #  undef IF_IS_ENCODER
 #  define IF_IS_ENCODER 1
 #  define ENCODER if (1)
 #  undef DECODER_OR_ENCODER
 #  define DECODER_OR_ENCODER if (1)
 #endif
 
 #ifdef IS_DECODER
 #  undef DECODER
 #  undef IF_IS_DECODER
 #  undef DECODER_OR_ENCODER
 #  define IF_IS_DECODER 1
 #  define DECODER if (1)
 #  define DECODER_OR_ENCODER if (1)
 #  undef SET_PARENT
 #  undef SET_PARENT_OBJ
 #  undef SET_PARENT_FIELD
 #  define SET_PARENT(field, to) _obj->field.parent = to
 #  define SET_PARENT_OBJ(field) SET_PARENT (field, _obj)
 #  define SET_PARENT_FIELD(field, what_parent, to) _obj->field.what_parent = to
 #else
 #  define TRACE_DD
 #endif
 
 #if defined(IS_PRINT)
 #  undef PRINT
 #  define PRINT if (1)
 #  undef DXF_OR_PRINT
 #  define DXF_OR_PRINT if (1)
 #endif
 
 #if defined(IS_DXF)
 #  undef DXF
 #  define DXF if (1)
 #  undef DXF_OR_PRINT
 #  define DXF_OR_PRINT if (1)
 #  undef IF_IS_DXF
 #  define IF_IS_DXF 1
 #endif
 
 #if defined(IS_JSON)
 #  undef JSON
 #  define JSON if (1)
 #  undef DXF_OR_PRINT
 #  define DXF_OR_PRINT if (1)
 #  undef DECODER_OR_ENCODER
 #  define DECODER_OR_ENCODER if (1)
 #endif
 
 #if defined(IS_FREE)
 #  undef FREE
 #  define FREE if (1)
 #  undef IF_IS_FREE
 #  define IF_IS_FREE 1
 #  undef IF_FREE_OR_SINCE
 #  define IF_FREE_OR_SINCE(x) if (1)
 #  undef IF_FREE_OR_VERSIONS
 #  define IF_FREE_OR_VERSIONS(x, y) if (1)
 #else
 #  ifndef END_REPEAT
 #    define END_REPEAT(field)
 #  endif
 #endif
 
 #ifndef R11OPTS
 #  define R11OPTS(b) (_ent->opts_r11 & (b))
 #  define R11FLAG(b) (_ent->flag_r11 & (b))
 #  define R11EXTRA(b) (_ent->extra_r11 & (b))
 #endif
 
 #define DECODE_UNKNOWN_BITS                                                   \
   DECODER { dwg_decode_unknown (dat, (Dwg_Object *restrict)obj); }            \
   FREE { VALUE_TF (obj->unknown_bits, 0); }
 
 #ifndef START_OBJECT_HANDLE_STREAM
 #  define START_OBJECT_HANDLE_STREAM                                          \
     START_HANDLE_STREAM;                                                      \
     assert (obj->supertype == DWG_SUPERTYPE_OBJECT)
 #endif
 
 #ifndef CONTROL_HANDLE_STREAM
 #  define CONTROL_HANDLE_STREAM                                               \
     assert (obj->supertype == DWG_SUPERTYPE_OBJECT);                          \
     PRE (R_2007)                                                              \
     {                                                                         \
       hdl_dat->byte = dat->byte;                                              \
       hdl_dat->bit = dat->bit;                                                \
     }                                                                         \
     SINCE (R_13b1)                                                            \
     {                                                                         \
       VALUE_HANDLE (obj->tio.object->ownerhandle, ownerhandle, 4, 0);         \
       REACTORS (4)                                                            \
       XDICOBJHANDLE (3)                                                       \
     }
 #endif
 
 #ifndef LOG_FLAG_W
 #  define LOG_FLAG_W(token, w)                                                \
     if (_obj->flag & FLAG_##token##_##w)                                      \
       LOG_TRACE (#w " (%d) ", FLAG_##token##_##w)
 #  define LOG_FLAG_TABLE_W(w)                                                 \
     if (_obj->flag & FLAG_TABLE_##w)                                          \
       LOG_TRACE (#w " (%d) ", FLAG_TABLE_##w)
 #  define LOG_FLAG_TABLE_MAX(v)                                               \
     if (_obj->flag > v)                                                       \
       LOG_WARN ("Unknown flag (%d)", _obj->flag)
 #  define LOG_FLAG_TABLE_COMMON                                               \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_TABLE_MAX (127);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #  define LOG_FLAG_BLOCK_W(w)                                                 \
     if (_obj->flag & FLAG_BLOCK_##w)                                          \
     LOG_TRACE (#w " (%d) ", FLAG_BLOCK_##w)
 #  define LOG_FLAG_Block                                                      \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_W (BLOCK, ANONYMOUS);                                        \
         LOG_FLAG_W (BLOCK, HAS_ATTRIBS);                                      \
         LOG_FLAG_W (BLOCK, IS_EXT_REF);                                       \
         LOG_FLAG_W (BLOCK, IS_XREF_OVERLAY);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_TABLE_W (IS_REMOVED);                                        \
         LOG_FLAG_TABLE_MAX (255);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #  define LOG_FLAG_Layer                                                      \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_W (LAYER, FROZEN);                                           \
         LOG_FLAG_W (LAYER, FROZEN_IN_NEW);                                    \
         LOG_FLAG_W (LAYER, LOCKED);                                           \
         LOG_FLAG_W (LAYER, PLOTFLAG);                                         \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_TABLE_MAX (127);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #  define LOG_FLAG_TextStyle                                                  \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_W (STYLE, SHAPE);                                            \
         LOG_FLAG_W (STYLE, VERTICAL_TEXT);                                    \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_TABLE_MAX (127);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #  define LOG_FLAG_View                                                       \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_W (VIEW, PSPACE);                                            \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_TABLE_MAX (127);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #   define LOG_FLAG_Viewport                                                  \
     if (_obj->flag)                                                           \
       {                                                                       \
         LOG_TRACE ("      ");                                                 \
         LOG_FLAG_TABLE_W (IS_XREF_REF);                                       \
         LOG_FLAG_TABLE_W (IS_XREF_RESOLVED);                                  \
         LOG_FLAG_TABLE_W (IS_XREF_DEP);                                       \
         LOG_FLAG_W (VIEWPORT, DELETED);                                       \
         LOG_FLAG_TABLE_MAX (255);                                             \
         LOG_TRACE ("\n");                                                     \
       }
 #  define LOG_FLAG_RegApp LOG_FLAG_TABLE_COMMON
 #  define LOG_FLAG_DimStyle LOG_FLAG_TABLE_COMMON
 #  define LOG_FLAG_Linetype LOG_FLAG_TABLE_COMMON
 #  define LOG_FLAG_UCS LOG_FLAG_TABLE_COMMON
 #  define LOG_FLAG_VX LOG_FLAG_TABLE_COMMON
 #endif
 
 #ifndef COMMON_TABLE_FLAGS
 #  define COMMON_TABLE_FLAGS(acdbname)                                        \
     assert (obj->supertype == DWG_SUPERTYPE_OBJECT);                          \
     PRE (R_13b1)                                                              \
     {                                                                         \
       if (strcmp (#acdbname, "Layer") == 0)                                   \
         {                                                                     \
           FIELD_CAST (flag, RC, RS, 70);                                      \
         }                                                                     \
       else                                                                    \
         {                                                                     \
           FIELD_CAST (flag, RC, RC, 70);                                      \
         }                                                                     \
       DECODER_OR_ENCODER                                                      \
       {                                                                       \
         LOG_FLAG_##acdbname                                                   \
       }                                                                       \
       FIELD_TFv (name, 32, 2);                                                \
       VERSION (R_11)                                                          \
         FIELD_RSd (used, 0);                                                  \
     }                                                                         \
     LATER_VERSIONS                                                            \
     {                                                                         \
       FIELD_T (name, 2);                                                      \
       UNTIL (R_2004)                                                          \
       {                                                                       \
         FIELD_B (is_xref_ref, 0);       /* always 1, 70 bit 6 */              \
         FIELD_BS (is_xref_resolved, 0); /* 0 or 256 */                        \
         FIELD_B (is_xref_dep, 0);       /* 70 bit 4 */                        \
       }                                                                       \
       LATER_VERSIONS                                                          \
       {                                                                       \
         FIELD_VALUE (is_xref_ref) = 1;                                        \
         FIELD_BS (is_xref_resolved, 0); /* 0 or 256 */                        \
         if (FIELD_VALUE (is_xref_resolved) == 256)                            \
           FIELD_VALUE (is_xref_dep) = 1;                                      \
       }                                                                       \
       FIELD_HANDLE (xref, 5, 0); /* NULLHDL without is_xref_dep */            \
       FIELD_VALUE (flag)                                                      \
           |= FIELD_VALUE (is_xref_dep) << 4 | FIELD_VALUE (is_xref_ref) << 6; \
     }                                                                         \
     RESET_VER
 #endif
 
 #ifndef FIELD_VECTOR_N1
 #  define FIELD_VECTOR_N1(name, type, size, dxf)                              \
     FIELD_VECTOR_N (name, type, size, dxf)
 #endif
 
 #ifndef REPEAT_BLOCK
 #  define REPEAT_BLOCK {
 #  define END_REPEAT_BLOCK }
 #endif
 
 /* REPEAT names:
   _ adds idx
   C does no checks
   N does constant times (else _obj->times)
   F does not calloc/free
 */
 
 // unchecked with constant times
 #ifndef REPEAT
 #  define REPEAT_CN(times, name, type)                                        \
     if (_obj->name != NULL)                                                   \
       for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)
 // checked with constant times
 #  define REPEAT_N(times, name, type)                                         \
     if (dat->version >= R_2000 && (BITCODE_BL)times > 20000)                  \
       {                                                                       \
         LOG_ERROR ("Invalid %s." #name " rcount1 %ld", SAFEDXFNAME,           \
                    (long)times);                                              \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     if (_obj->name != NULL)                                                   \
       for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)
 
 // checked with var. times
 #  define _REPEAT(times, name, type, idx)                                     \
     if (dat->version >= R_2000 && (BITCODE_BL)_obj->times > 20000)            \
       {                                                                       \
         LOG_ERROR ("Invalid %s." #name " rcount" #idx " %ld", SAFEDXFNAME,    \
                    (long)_obj->times);                                        \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     if (_obj->times > 0 && _obj->name != NULL)                                \
       for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times;            \
            rcount##idx++)
 // unchecked with var. times
 #  ifndef _REPEAT_C
 #    define _REPEAT_C(times, name, type, idx)                                 \
       if (_obj->times > 0 && _obj->name != NULL)                              \
         for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times;          \
              rcount##idx++)
 #  endif
 #  define REPEAT(times, name, type) _REPEAT (times, name, type, 1)
 #  define REPEAT2(times, name, type) _REPEAT (times, name, type, 2)
 #  define REPEAT3(times, name, type) _REPEAT (times, name, type, 3)
 #  define REPEAT4(times, name, type) _REPEAT (times, name, type, 4)
 #  define REPEAT_C(times, name, type) _REPEAT_C (times, name, type, 1)
 #  define REPEAT2_C(times, name, type) _REPEAT_C (times, name, type, 2)
 #  define REPEAT3_C(times, name, type) _REPEAT_C (times, name, type, 3)
 #  define REPEAT4_C(times, name, type) _REPEAT_C (times, name, type, 4)
 #endif
 // unchecked with constant times
 #ifndef _REPEAT_CN
 #  define _REPEAT_CN(times, name, type, idx)                                  \
     if (_obj->name != NULL)                                                   \
       for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)
 #endif
 // not allocating versions:
 // unchecked
 #ifndef _REPEAT_CNF
 #  define _REPEAT_CNF(times, name, type, idx)                                 \
     if (_obj->name != NULL)                                                   \
       for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)
 #endif
 #ifndef _REPEAT_NF
 // checked
 #  define _REPEAT_NF(times, name, type, idx)                                  \
     if (dat->version >= R_2000 && times > 0x7ff)                              \
       {                                                                       \
         LOG_ERROR ("Invalid %s." #name " rcount" #idx " %ld", SAFEDXFNAME,    \
                    (long)times);                                              \
         return DWG_ERR_VALUEOUTOFBOUNDS;                                      \
       }                                                                       \
     if (_obj->name != NULL)                                                   \
       for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)
 #endif
 
 #define DWG_SUBCLASS_DECL(parenttype, subtype)                                \
   static int DWG_PRIVATE_N (ACTION, parenttype##_##subtype) (                 \
       Dwg_Object_##parenttype *restrict _obj, Bit_Chain * dat,                \
       Bit_Chain * hdl_dat, Bit_Chain * str_dat, Dwg_Object *restrict obj)
 
 #define DWG_SUBCLASS(parenttype, subtype)                                     \
   static int DWG_PRIVATE_N (ACTION, parenttype##_##subtype) (                 \
       Dwg_Object_##parenttype *restrict _obj, Bit_Chain * dat,                \
       Bit_Chain * hdl_dat, Bit_Chain * str_dat, Dwg_Object *restrict obj)     \
   {                                                                           \
     BITCODE_BL vcount, rcount3, rcount4;                                      \
     Dwg_Data *dwg = obj->parent;                                              \
     int error = 0;                                                            \
     subtype##_fields;                                                         \
     return error;                                                             \
   }
 
 #define CALL_SUBCLASS(_xobj, parenttype, subtype)                             \
   error |= DWG_PRIVATE_N (ACTION, parenttype##_##subtype) (                   \
       _xobj, dat, hdl_dat, str_dat, (Dwg_Object *)obj)
 // if the name is compile-time known
 #define CALL_ENTITY(name, xobj)                                               \
   error |= DWG_PRIVATE_N (ACTION, name) (dat, hdl_dat, str_dat,               \
                                          (Dwg_Object *)xobj)
 // TODO: dispatch on the type
 #define CALL_SUBENT(hdl, dxf)
 // error |= DWG_PRIVATE_N (ACTION, xobj->fixedtype) (dat, hdl_dat, str_dat,
 // (Dwg_Object *)xobj)
 #define CALL_SUBCURVE(hdl, curvetype)
 
 #ifndef UNKNOWN_UNTIL
 #  define UNKNOWN_UNTIL(pos)                                                  \
     LOG_TRACE ("unknown (%ld): ", pos - dat->byte);                           \
     dat->byte = pos
 #endif
 
 #define LOG_FLAG_MAX(value, w)                                                \
     if (value > w)                                                            \
         LOG_WARN ("Unknown flag (0x%x)", value & ~(w))
 
 #ifndef LOG_TEXT_GENERATION
 #  define LOG_TEXT_GENERATION_W(w)                                            \
     if (_obj->generation & TEXT_GENERATION_##w)                               \
       LOG_TRACE (#w "(0x%x) ", TEXT_GENERATION_##w)
 #  define LOG_TEXT_GENERATION                                                 \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->generation)                                                   \
         {                                                                     \
           LOG_TRACE ("            ");                                         \
           LOG_TEXT_GENERATION_W (BACKWARDS);                                  \
           LOG_TEXT_GENERATION_W (UPSIDE_DOWN);                                \
           LOG_FLAG_MAX (_obj->generation, 7);                                 \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_HORIZ_ALIGNMENT
 #  define LOG_HORIZ_ALIGNMENT_W(w)                                            \
     if (_obj->horiz_alignment == HORIZ_ALIGNMENT_##w)                         \
       LOG_TRACE (#w "(0x%x) ", HORIZ_ALIGNMENT_##w)
 #  define LOG_HORIZ_ALIGNMENT                                                 \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->horiz_alignment)                                              \
         {                                                                     \
           LOG_TRACE ("                 ");                                    \
           LOG_HORIZ_ALIGNMENT_W (LEFT);                                       \
           LOG_HORIZ_ALIGNMENT_W (CENTER);                                     \
           LOG_HORIZ_ALIGNMENT_W (RIGHT);                                      \
           LOG_HORIZ_ALIGNMENT_W (ALIGNED);                                    \
           LOG_HORIZ_ALIGNMENT_W (MIDDLE);                                     \
           LOG_HORIZ_ALIGNMENT_W (FIT);                                        \
           LOG_FLAG_MAX (_obj->horiz_alignment, HORIZ_ALIGNMENT_FIT);          \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_VERT_ALIGNMENT
 #  define LOG_VERT_ALIGNMENT_W(w)                                             \
     if (_obj->vert_alignment == VERT_ALIGNMENT_##w)                           \
     LOG_TRACE (#w "(0x%x) ", VERT_ALIGNMENT_##w)
 #  define LOG_VERT_ALIGNMENT                                                  \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->vert_alignment)                                               \
         {                                                                     \
           LOG_TRACE ("                ");                                     \
           LOG_VERT_ALIGNMENT_W (BASELINE);                                    \
           LOG_VERT_ALIGNMENT_W (BOTTOM);                                      \
           LOG_VERT_ALIGNMENT_W (MIDDLE);                                      \
           LOG_VERT_ALIGNMENT_W (TOP);                                         \
           LOG_FLAG_MAX (_obj->vert_alignment, VERT_ALIGNMENT_TOP);            \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_FLAG_ATTDEF
 #  define LOG_FLAG_ATTDEF_W(w)                                                \
     if (_obj->flags & FLAG_ATTDEF_##w)                                        \
     LOG_TRACE (#w "(0x%x) ", FLAG_ATTDEF_##w)
 #  define LOG_FLAG_ATTDEF                                                     \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->flags)                                                        \
         {                                                                     \
           LOG_TRACE ("       ");                                              \
           LOG_FLAG_ATTDEF_W (INVISIBLE);                                      \
           LOG_FLAG_ATTDEF_W (CONSTANT);                                       \
           LOG_FLAG_ATTDEF_W (VERIFY);                                         \
           LOG_FLAG_ATTDEF_W (PRESET);                                         \
           LOG_FLAG_MAX (_obj->flags, 15);                                     \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_FLAG_ATTRIB
 #  define LOG_FLAG_ATTRIB_W(w)                                                \
     if (_obj->flags & FLAG_ATTRIB_##w)                                        \
     LOG_TRACE (#w "(0x%x) ", FLAG_ATTRIB_##w)
 #  define LOG_FLAG_ATTRIB                                                     \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->flags)                                                        \
         {                                                                     \
           LOG_TRACE ("       ");                                              \
           LOG_FLAG_ATTRIB_W (INVISIBLE);                                      \
           LOG_FLAG_ATTRIB_W (CONSTANT);                                       \
           LOG_FLAG_ATTRIB_W (VERIFY);                                         \
           LOG_FLAG_ATTRIB_W (PRESET);                                         \
           LOG_FLAG_MAX (_obj->flags, 15);                                     \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_FLAG_LWPOLYLINE
 #  define LOG_FLAG_LWPOLYLINE_W(w)                                            \
     if (_obj->flag & FLAG_LWPOLYLINE_##w)                                     \
       LOG_TRACE (#w "(0x%x) ", FLAG_LWPOLYLINE_##w)
 #  define LOG_FLAG_LWPOLYLINE                                                 \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->flag)                                                         \
         {                                                                     \
           LOG_TRACE ("      ");                                               \
           LOG_FLAG_LWPOLYLINE_W (HAS_EXTRUSION);                              \
           LOG_FLAG_LWPOLYLINE_W (HAS_THICKNESS);                              \
           LOG_FLAG_LWPOLYLINE_W (HAS_CONSTWIDTH);                             \
           LOG_FLAG_LWPOLYLINE_W (HAS_ELEVATION);                              \
           LOG_FLAG_LWPOLYLINE_W (HAS_NUM_BULGES);                             \
           LOG_FLAG_LWPOLYLINE_W (HAS_NUM_WIDTHS);                             \
           LOG_FLAG_LWPOLYLINE_W (UNKNOWN_64);                                 \
           LOG_FLAG_LWPOLYLINE_W (PLINEGEN);                                   \
           LOG_FLAG_LWPOLYLINE_W (UNKNOWN_256);                                \
           LOG_FLAG_LWPOLYLINE_W (CLOSED);                                     \
           LOG_FLAG_LWPOLYLINE_W (VERTEXIDCOUNT);                              \
           LOG_FLAG_MAX (_obj->flag, 2047);                                    \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_FLAG_POLYLINE
 #  define LOG_FLAG_POLYLINE_W(w)                                              \
     if (_obj->flag & FLAG_POLYLINE_##w)                                       \
       LOG_TRACE (#w "(0x%x) ", FLAG_POLYLINE_##w)
 #  define LOG_FLAG_POLYLINE                                                   \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->flag)                                                         \
         {                                                                     \
           LOG_TRACE ("      ");                                               \
           LOG_FLAG_POLYLINE_W (CLOSED);                                       \
           LOG_FLAG_POLYLINE_W (CURVE_FIT);                                    \
           LOG_FLAG_POLYLINE_W (SPLINE_FIT);                                   \
           LOG_FLAG_POLYLINE_W (3D);                                           \
           LOG_FLAG_POLYLINE_W (MESH);                                         \
           LOG_FLAG_POLYLINE_W (MESH_CLOSED);                                  \
           LOG_FLAG_POLYLINE_W (PFACE_MESH);                                   \
           LOG_FLAG_POLYLINE_W (LT_PATTERN_CONTINUES);                         \
           LOG_FLAG_MAX (_obj->flag, 255);                                     \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_FLAG_VERTEX
 #  define LOG_FLAG_VERTEX_W(w)                                                \
     if (_obj->flag & FLAG_VERTEX_##w)                                         \
     LOG_TRACE (#w "(0x%x) ", FLAG_VERTEX_##w)
 #  define LOG_FLAG_VERTEX                                                     \
     DECODER_OR_ENCODER                                                        \
       {                                                                       \
       if (_obj->flag)                                                         \
         {                                                                     \
           LOG_TRACE ("      ");                                               \
           LOG_FLAG_VERTEX_W (EXTRA_VERTEX);                                   \
           LOG_FLAG_VERTEX_W (CURVE_FIT);                                      \
           LOG_FLAG_VERTEX_W (UNUSED_4);                                       \
           LOG_FLAG_VERTEX_W (SPLINE_FIT);                                     \
           LOG_FLAG_VERTEX_W (SPLINE_FRAME_CONTROL_POINT);                     \
           LOG_FLAG_VERTEX_W (3D);                                             \
           LOG_FLAG_VERTEX_W (MESH);                                           \
           LOG_FLAG_VERTEX_W (PFACE_MESH);                                     \
           LOG_FLAG_MAX (_obj->flag, 255);                                     \
           LOG_TRACE ("\n");                                                   \
         }                                                                     \
       }
 #endif
 
 #ifndef LOG_POLYLINE_CURVETYPE
 #  define LOG_POLYLINE_CURVETYPE_W(w)                                       \
     if (_obj->curve_type == POLYLINE_CURVETYPE_##w)                         \
       LOG_TRACE (#w "(0x%x) ", POLYLINE_CURVETYPE_##w)
 #  define LOG_POLYLINE_CURVETYPE                                            \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->curve_type)                                                 \
         {                                                                   \
           LOG_TRACE ("            ");                                       \
           LOG_POLYLINE_CURVETYPE_W (DEFAULT);                               \
           LOG_POLYLINE_CURVETYPE_W (QUADR_BSPLINE);                         \
           LOG_POLYLINE_CURVETYPE_W (CUBIC_BSPLINE);                         \
           LOG_POLYLINE_CURVETYPE_W (BEZIER_SURFACE);                        \
           LOG_FLAG_MAX (_obj->curve_type, 8);                               \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 
 #ifndef LOG_LEADER_PATHTYPE
 #  define LOG_LEADER_PATHTYPE_W(w)                                          \
     if (_obj->path_type == LEADER_PATHTYPE_##w)                             \
       LOG_TRACE (#w "(0x%x) ", LEADER_PATHTYPE_##w)
 #  define LOG_LEADER_PATHTYPE                                               \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->path_type)                                                  \
         {                                                                   \
           LOG_TRACE ("      ");                                             \
           LOG_LEADER_PATHTYPE_W (STRAIGHT);                                 \
           LOG_LEADER_PATHTYPE_W (SPLINE);                                   \
           LOG_LEADER_PATHTYPE_W (UNKNOWN);                                  \
           LOG_FLAG_MAX (_obj->path_type, 2);                                \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 
 #ifndef LOG_LEADER_ANNOTTYPE
 #  define LOG_LEADER_ANNOTTYPE_W(w)                                         \
     if (_obj->annot_type == LEADER_ANNOTTYPE_##w)                           \
       LOG_TRACE (#w "(0x%x) ", LEADER_ANNOTTYPE_##w)
 #  define LOG_LEADER_ANNOTTYPE                                              \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->annot_type)                                                 \
         {                                                                   \
           LOG_TRACE ("           ");                                        \
           LOG_LEADER_ANNOTTYPE_W (MTEXT);                                   \
           LOG_LEADER_ANNOTTYPE_W (TOLERANCE);                               \
           LOG_LEADER_ANNOTTYPE_W (INSERT);                                  \
           LOG_LEADER_ANNOTTYPE_W (NO_ANNOT);                                \
           LOG_FLAG_MAX (_obj->annot_type, 3);                               \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 
 #ifndef LOG_MLINE_FLAGS
 #  define LOG_MLINE_FLAGS_W(w)                                               \
     if (_obj->flags & MLINE_FLAGS_##w)                                       \
       LOG_TRACE (#w "(0x%x) ", MLINE_FLAGS_##w)
 #  define LOG_MLINE_FLAGS                                                    \
     DECODER_OR_ENCODER                                                       \
       {                                                                      \
       if (_obj->flags)                                                       \
         {                                                                    \
           LOG_TRACE ("     ");                                               \
           LOG_MLINE_FLAGS_W (HAS_VERTEX);                                    \
           LOG_MLINE_FLAGS_W (CLOSED);                                        \
           LOG_MLINE_FLAGS_W (SUPPRESS_START_CAPS);                           \
           LOG_MLINE_FLAGS_W (SUPPRESS_END_CAPS);                             \
           LOG_FLAG_MAX (_obj->flags, 15);                                    \
           LOG_TRACE ("\n");                                                  \
         }                                                                    \
       }
 #endif
 
 #ifndef LOG_MLINE_JUSTIFICATION
 #  define LOG_MLINE_JUSTIFICATION_W(w)                                      \
     if (_obj->justification == MLINE_JUSTIFICATION_##w)                     \
       LOG_TRACE (#w "(0x%x) ", MLINE_JUSTIFICATION_##w)
 #  define LOG_MLINE_JUSTIFICATION                                           \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->justification)                                              \
         {                                                                   \
           LOG_TRACE ("             ");                                      \
           LOG_MLINE_JUSTIFICATION_W (TOP);                                  \
           LOG_MLINE_JUSTIFICATION_W (MIDDLE);                               \
           LOG_MLINE_JUSTIFICATION_W (BOTTOM);                               \
           LOG_FLAG_MAX (_obj->justification, 3);                            \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 
 #ifndef LOG_SPLINE_SCENARIO
 #  define LOG_SPLINE_SCENARIO_W(w)                                          \
     if (_obj->scenario == SPLINE_SCENARIO_##w)                              \
       LOG_TRACE (#w "(0x%x) ", SPLINE_SCENARIO_##w)
 #  define LOG_SPLINE_SCENARIO                                               \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->scenario)                                                   \
         {                                                                   \
           LOG_TRACE ("         ");                                          \
           LOG_SPLINE_SCENARIO_W (SPLINE);                                   \
           LOG_SPLINE_SCENARIO_W (BEZIER);                                   \
           LOG_FLAG_MAX (_obj->scenario, 2);                                 \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 #ifndef LOG_SPLINE_SPLINEFLAGS
 #  define LOG_SPLINE_SPLINEFLAGS_W(w)                                       \
     if (_obj->splineflags & SPLINE_SPLINEFLAGS_##w)                         \
       LOG_TRACE (#w "(0x%x) ", SPLINE_SPLINEFLAGS_##w)
 #  define LOG_SPLINE_SPLINEFLAGS                                            \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->splineflags)                                                \
         {                                                                   \
           LOG_TRACE ("            ");                                       \
           LOG_SPLINE_SPLINEFLAGS_W (METHOD_FIT_POINTS);                     \
           LOG_SPLINE_SPLINEFLAGS_W (CV_FRAME_SHOW);                         \
           LOG_SPLINE_SPLINEFLAGS_W (CLOSED);                                \
           LOG_FLAG_MAX (_obj->splineflags, 7);                              \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 #ifndef LOG_SPLINE_KNOTPARAM
 #  define LOG_SPLINE_KNOTPARAM_W(w)                                         \
     if (_obj->knotparam == SPLINE_KNOTPARAM_##w)                            \
       LOG_TRACE (#w "(0x%x) ", SPLINE_KNOTPARAM_##w)
 #  define LOG_SPLINE_KNOTPARAM                                              \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->knotparam)                                                  \
         {                                                                   \
           LOG_TRACE ("          ");                                         \
           LOG_SPLINE_KNOTPARAM_W (CHORD);                                   \
           LOG_SPLINE_KNOTPARAM_W (SQUARE_ROOT);                             \
           LOG_SPLINE_KNOTPARAM_W (UNIFORM);                                 \
           LOG_SPLINE_KNOTPARAM_W (CUSTOM);                                  \
           LOG_FLAG_MAX (_obj->knotparam, 15);                               \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 
 #ifndef LOG_LIGHT_TYPE
 #  define LOG_LIGHT_TYPE_W(w)                                               \
     if (_obj->type == LIGHT_TYPE_##w)                                       \
       LOG_TRACE (#w "(0x%x) ", LIGHT_TYPE_##w)
 #  define LOG_LIGHT_TYPE                                                    \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
       if (_obj->type)                                                       \
         {                                                                   \
           LOG_TRACE ("      ");                                             \
           LOG_LIGHT_TYPE_W (DISTANT);                                       \
           LOG_LIGHT_TYPE_W (POINT);                                         \
           LOG_LIGHT_TYPE_W (SPOT);                                          \
           LOG_FLAG_MAX (_obj->type, 3);                                     \
           LOG_TRACE ("\n");                                                 \
         }                                                                   \
       }
 #endif
 #ifndef LOG_LIGHT_ATTENUATION_TYPE
 #  define LOG_LIGHT_ATTENUATION_W(w)                                        \
     if (_obj->attenuation_type == LIGHT_ATTENUATION_TYPE_##w)               \
       LOG_TRACE (#w "(0x%x) ", LIGHT_ATTENUATION_TYPE_##w)
 #  define LOG_LIGHT_ATTENUATION_TYPE                                        \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
         LOG_TRACE ("      ");                                               \
         LOG_LIGHT_ATTENUATION_W (NONE);                                     \
         LOG_LIGHT_ATTENUATION_W (INV_LINEAR);                               \
         LOG_LIGHT_ATTENUATION_W (INV_SQUARE);                               \
         LOG_FLAG_MAX (_obj->attenuation_type, 2);                           \
         LOG_TRACE ("\n");                                                   \
       }
 #endif
 #ifndef LOG_LIGHT_EXTLIGHT_SHAPE
 #  define LOG_EXTLIGHT_SHAPE_W(w)                                           \
     if (_obj->extlight_shape == LIGHT_EXTLIGHT_SHAPE_##w)                   \
       LOG_TRACE (#w "(0x%x) ", LIGHT_EXTLIGHT_SHAPE_##w)
 #  define LOG_LIGHT_EXTLIGHT_SHAPE                                          \
     DECODER_OR_ENCODER                                                      \
       {                                                                     \
           LOG_TRACE ("      ");                                             \
           LOG_EXTLIGHT_SHAPE_W (LINEAR);                                    \
           LOG_EXTLIGHT_SHAPE_W (RECT);                                      \
           LOG_EXTLIGHT_SHAPE_W (DISK);                                      \
           LOG_EXTLIGHT_SHAPE_W (CYLINDER);                                  \
           LOG_EXTLIGHT_SHAPE_W (SPHERE);                                    \
           LOG_FLAG_MAX (_obj->extlight_shape, 4);                           \
           LOG_TRACE ("\n");                                                 \
       }
 #endif
 
 #ifdef IS_DECODER
 #  define PRER13_SECTION_HDR(name) \
   if (decode_preR13_section_hdr (#name, SECTION_##name, dat, dwg)) \
     return DWG_ERR_SECTIONNOTFOUND
 #elif defined IS_ENCODER
 #  define PRER13_SECTION_HDR(name) \
     encode_preR13_section_hdr (#name, SECTION_##name, dat, dwg)
+#  define DWG_TABLE(token) DWG_OBJECT (token)
 #else
 #  define PRER13_SECTION_HDR(name)
+#  define DWG_TABLE(token) DWG_OBJECT (token)
 #endif
