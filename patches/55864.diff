commit 92b68f24426ba6cb4f4f52ada11ad9b9671b0b9f
Merge: 8a8439640d 36c2d1dbbb
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sat Mar 11 14:55:24 2023 -0800

    Merge branch 'V5-9-patches'
    
    * V5-9-patches:
      Change "#if HAVE_XXX" into "#ifdef HAVE_XXX"

diff --git a/agent/agent_handler.c b/agent/agent_handler.c
index 6296eb0e6b..fb39322bec 100644
--- a/agent/agent_handler.c
+++ b/agent/agent_handler.c
@@ -1,28 +1,28 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/bulk_to_next.h>
diff --git a/agent/agent_index.c b/agent/agent_index.c
index d4063855c5..aad79031a6 100644
--- a/agent/agent_index.c
+++ b/agent/agent_index.c
@@ -1,50 +1,50 @@
 /*
  * agent_index.c
  *
  * Maintain a registry of index allocations
  *      (Primarily required for AgentX support,
  *       but it could be more widely useable).
  */
 
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <signal.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <sys/types.h>
 #include <stdio.h>
 #include <fcntl.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_index.h>
 
 #include "snmpd.h"
 #include "agent_global_vars.h"
 #include "mibgroup/struct.h"
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 
 #ifdef USING_AGENTX_SUBAGENT_MODULE
 #include "agentx/subagent.h"
 #include "agentx/client.h"
 #endif
diff --git a/agent/agent_read_config.c b/agent/agent_read_config.c
index 93b1a92b36..b085ab08cc 100644
--- a/agent/agent_read_config.c
+++ b/agent/agent_read_config.c
@@ -1,113 +1,113 @@
 /*
  * agent_read_config.c
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #else
 #include <sys/types.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 #ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
 #ifdef HAVE_NETINET_IP6_H
 #include <netinet/ip6.h>
 #endif
 #endif
 #ifdef HAVE_SYS_QUEUE_H
 #include <sys/queue.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #ifdef HAVE_SYS_SOCKETVAR_H
 #ifndef dynix
 #include <sys/socketvar.h>
 #else
 #include <sys/param.h>
 #endif
 #endif
 #endif
 #ifdef HAVE_SYS_STREAM_H
 #   ifdef sysv5UnixWare7
 #      define _KMEMUSER 1   /* <sys/stream.h> needs this for queue_t */
 #   endif
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
 #ifdef HAVE_NETNETSNMP_ENABLE_IPV6_IP6_VAR_H
 #include <netinet6/ip6_var.h>
 #endif
 #endif
 #ifdef HAVE_NETINET_IN_PCB_H
 #include <netinet/in_pcb.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 #ifdef HAVE_GRP_H
 #include <grp.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "mibgroup/struct.h"
 #include <net-snmp/agent/agent_trap.h>
 #include "snmpd.h"
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 #include <net-snmp/agent/table_data.h>
 #include <net-snmp/agent/table_dataset.h>
 #include "agent_module_includes.h"
 #include "mib_module_includes.h"
diff --git a/agent/agent_registry.c b/agent/agent_registry.c
index e71d830142..ea5d7a1593 100644
--- a/agent/agent_registry.c
+++ b/agent/agent_registry.c
@@ -1,74 +1,74 @@
 /*
  * agent_registry.c
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup agent_registry Registry of MIB subtrees, modules, sessions, etc
  *     Maintain a registry of MIB subtrees, together with related information
  *     regarding MIB modules, sessions, etc
  *   @ingroup agent
  *
  * @{
  */
 
 #define IN_SNMP_VARS_C
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <signal.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <sys/types.h>
 #include <stdio.h>
 #include <fcntl.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_callbacks.h>
 
 #include "snmpd.h"
 #include "agent_global_vars.h"
 #include "mibgroup/struct.h"
 #include <net-snmp/agent/old_api.h>
 #include <net-snmp/agent/null.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 #include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/agent_registry.h>
 
 #ifdef USING_AGENTX_SUBAGENT_MODULE
 #include "agentx/subagent.h"
 #include "agentx/client.h"
 #endif
diff --git a/agent/agent_sysORTable.c b/agent/agent_sysORTable.c
index d959eaf545..c38e378a97 100644
--- a/agent/agent_sysORTable.c
+++ b/agent/agent_sysORTable.c
@@ -1,16 +1,16 @@
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stddef.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_sysORTable.h>
 #include <net-snmp/agent/sysORTable.h>
diff --git a/agent/agent_trap.c b/agent/agent_trap.c
index c955d3469e..57f031217c 100644
--- a/agent/agent_trap.c
+++ b/agent/agent_trap.c
@@ -1,76 +1,76 @@
 /*
  * agent_trap.c
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup agent_trap Trap generation routines for mib modules to use
  *  @ingroup agent
  *
  * @{
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/snmp_agent.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include "agent_global_vars.h"
 
 #include <net-snmp/agent/agent_module_config.h>
 #include <net-snmp/agent/mib_module_config.h>
 
 #ifdef USING_AGENTX_PROTOCOL_MODULE
 #include "agentx/protocol.h"
 #endif
 
 #ifdef USING_NOTIFICATION_SNMPNOTIFYTABLE_DATA_MODULE
 #include "mibgroup/notification/snmpNotifyTable_data.h"
 #endif
diff --git a/agent/auto_nlist.c b/agent/auto_nlist.c
index 2cdf3a85f9..42a98b9410 100644
--- a/agent/auto_nlist.c
+++ b/agent/auto_nlist.c
@@ -1,28 +1,28 @@
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef NETSNMP_CAN_USE_NLIST
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <netinet/in.h>
-#if HAVE_KVM_H
+#ifdef HAVE_KVM_H
 #include <kvm.h>
 #elif defined(HAVE_NLIST_H)
 #include <nlist.h>
 #endif
 
 #include <net-snmp/agent/auto_nlist.h>
 #include "autonlist.h"
 #include "kernel.h"
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/ds_agent.h>
@@ -146,75 +146,75 @@ static void
 init_nlist(struct nlist nl[])
 {
     int             ret;
-#if HAVE_KVM_OPENFILES
+#ifdef HAVE_KVM_OPENFILES
     kvm_t          *kernel;
     char            kvm_errbuf[4096];
 
     if ((kernel = kvm_openfiles(KERNEL_LOC, NULL, NULL, O_RDONLY, kvm_errbuf))
 	== NULL) {
         if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
             return;
 	} else {
             snmp_log_perror("kvm_openfiles");
             snmp_log(LOG_ERR, "kvm_openfiles: %s\n", kvm_errbuf);
             exit(1);
         }
     }
     if ((ret = kvm_nlist(kernel, nl)) == -1) {
         if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
             return;
 	} else {
             snmp_log_perror("kvm_nlist");
             exit(1);
         }
     }
     kvm_close(kernel);
 #else                           /* ! HAVE_KVM_OPENFILES */
 #if (defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)) && defined(HAVE_KNLIST)
     if (knlist(nl, 1, sizeof(struct nlist)) == -1) {
         DEBUGMSGTL(("auto_nlist:init_nlist", "knlist failed on symbol:  %s\n",
                     nl[0].n_name));
         if (errno == EFAULT) {
             nl[0].n_type = 0;
             nl[0].n_value = 0;
         } else {
             snmp_log_perror("knlist");
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				       NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 return;
 	    } else {
                 exit(1);
 	    }
         }
     }
 #else
     if ((ret = nlist(KERNEL_LOC, nl)) == -1) {
         if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
             return;
 	} else {
             snmp_log_perror("nlist");
             exit(1);
         }
     }
 #endif                          /*aix4 */
 #endif                          /* ! HAVE_KVM_OPENFILES */
     for (ret = 0; nl[ret].n_name != NULL; ret++) {
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         if (nl[ret].n_type == 0 && nl[ret].n_value != 0)
             nl[ret].n_type = 1;
 #endif
         if (nl[ret].n_type == 0) {
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 DEBUGMSGTL(("auto_nlist:init_nlist", "nlist err:  %s not found\n",
                             nl[ret].n_name));
 	    }
         } else {
             DEBUGMSGTL(("auto_nlist:init_nlist", "nlist: %s 0x%X\n", nl[ret].n_name,
                         (unsigned int) nl[ret].n_value));
         }
     }
 }
diff --git a/agent/helpers/cache_handler.c b/agent/helpers/cache_handler.c
index 2a3dab5d48..2c007a88da 100644
--- a/agent/helpers/cache_handler.c
+++ b/agent/helpers/cache_handler.c
@@ -1,28 +1,28 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/cache_handler.h>
diff --git a/agent/helpers/instance.c b/agent/helpers/instance.c
index 46af5501d5..b547a042e1 100644
--- a/agent/helpers/instance.c
+++ b/agent/helpers/instance.c
@@ -1,33 +1,33 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/instance.h>
 
 #include <stdlib.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/serialize.h>
 #include <net-snmp/agent/read_only.h>
diff --git a/agent/helpers/null.c b/agent/helpers/null.c
index 879ad16e03..1b4b4552d0 100644
--- a/agent/helpers/null.c
+++ b/agent/helpers/null.c
@@ -1,22 +1,22 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/null.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
diff --git a/agent/helpers/old_api.c b/agent/helpers/old_api.c
index 3ca2009efb..04351da98b 100644
--- a/agent/helpers/old_api.c
+++ b/agent/helpers/old_api.c
@@ -1,30 +1,30 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/old_api.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/agent_callbacks.h>
 
 #include <stddef.h>
 
 #define MIB_CLIENTS_ARE_EVIL 1
 
 #ifdef HAVE_DMALLOC_H
@@ -267,192 +267,192 @@ int
 netsnmp_old_api_helper(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
 {
 
-#if MIB_CLIENTS_ARE_EVIL
+#ifdef MIB_CLIENTS_ARE_EVIL
     oid             save[MAX_OID_LEN];
     size_t          savelen = 0;
 #endif
     struct variable compat_var, *cvp = &compat_var;
     int             exact = 1;
     int             status;
 
     struct variable *vp;
     netsnmp_old_api_cache *cacheptr;
     netsnmp_agent_session *oldasp = NULL;
     u_char         *access = NULL;
     WriteMethod    *write_method = NULL;
     size_t          len;
     size_t          tmp_len;
     oid             tmp_name[MAX_OID_LEN];
 
     vp = (struct variable *) handler->myvoid;
 
     snmp_call_callbacks(SNMP_CALLBACK_LIBRARY,
                         SNMP_CALLBACK_MIB_REQUEST_INFO,
                         reqinfo);
     /*
      * create old variable structure with right information 
      */
     memcpy(cvp->name, reginfo->rootoid,
            reginfo->rootoid_len * sizeof(oid));
     cvp->namelen = reginfo->rootoid_len;
     cvp->type = vp->type;
     cvp->magic = vp->magic;
     cvp->acl = vp->acl;
     cvp->findVar = vp->findVar;
 
     switch (reqinfo->mode) {
     case MODE_GETNEXT:
     case MODE_GETBULK:
         exact = 0;
     }
 
     for (; requests; requests = requests->next) {
 
-#if MIB_CLIENTS_ARE_EVIL
+#ifdef MIB_CLIENTS_ARE_EVIL
         savelen = requests->requestvb->name_length;
         memcpy(save, requests->requestvb->name, savelen * sizeof(oid));
 #endif
 
         switch (reqinfo->mode) {
         case MODE_GET:
         case MODE_GETNEXT:
 #ifndef NETSNMP_NO_WRITE_SUPPORT
         case MODE_SET_RESERVE1:
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
             /*
              * Actually call the old mib-module function 
              */
             if (vp && vp->findVar) {
                 tmp_len = requests->requestvb->name_length*sizeof(oid);
                 memcpy(tmp_name, requests->requestvb->name, tmp_len);
                 /** clear the rest of tmp_name to keep valgrind happy */
                 memset(&tmp_name[requests->requestvb->name_length], 0x0,
                        sizeof(tmp_name)-tmp_len);
                 tmp_len = requests->requestvb->name_length;
                 access = (*(vp->findVar)) (cvp, tmp_name, &tmp_len,
                                            exact, &len, &write_method);
                 snmp_set_var_objid( requests->requestvb, tmp_name, tmp_len );
             }
             else
                 access = NULL;
 
 #ifdef WWW_FIX
             if (IS_DELEGATED(cvp->type)) {
                 add_method = (AddVarMethod *) statP;
                 requests->delayed = 1;
                 have_delegated = 1;
                 continue;       /* WWW: This may not get to the right place */
             }
 #endif
 
             /*
              * WWW: end range checking 
              */
             if (access) {
                 /*
                  * result returned 
                  */
 #ifndef NETSNMP_NO_WRITE_SUPPORT
                 if (reqinfo->mode != MODE_SET_RESERVE1)
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
                     snmp_set_var_typed_value(requests->requestvb,
                                              cvp->type, access, len);
             } else {
                 /*
                  * no result returned 
                  */
-#if MIB_CLIENTS_ARE_EVIL
+#ifdef MIB_CLIENTS_ARE_EVIL
                 if (access == NULL) {
                     if (netsnmp_oid_equals(requests->requestvb->name,
                                          requests->requestvb->name_length,
                                          save, savelen) != 0) {
                         DEBUGMSGTL(("old_api", "evil_client: %s\n",
                                     reginfo->handlerName));
                         memcpy(requests->requestvb->name, save,
                                savelen * sizeof(oid));
                         requests->requestvb->name_length = savelen;
                     }
                 }
 #endif
             }
 
             /*
              * AAA: fall through for everything that is a set (see BBB) 
              */
 #ifndef NETSNMP_NO_WRITE_SUPPORT
             if (reqinfo->mode != MODE_SET_RESERVE1)
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
                 break;
 
             cacheptr = SNMP_MALLOC_TYPEDEF(netsnmp_old_api_cache);
             if (!cacheptr)
                 return netsnmp_set_request_error(reqinfo, requests,
                                                  SNMP_ERR_RESOURCEUNAVAILABLE);
             cacheptr->data = access;
             cacheptr->write_method = write_method;
             write_method = NULL;
             netsnmp_request_add_list_data(requests,
                                           netsnmp_create_data_list
                                           (OLD_API_NAME, cacheptr,
                                            &free_wrapper));
             /*
              * BBB: fall through for everything that is a set (see AAA) 
              */
 	    NETSNMP_FALLTHROUGH;
 
         default:
             /*
              * WWW: explicitly list the SET conditions 
              */
             /*
              * (the rest of the) SET contions 
              */
             cacheptr =
                 (netsnmp_old_api_cache *)
                 netsnmp_request_get_list_data(requests, OLD_API_NAME);
 
             if (cacheptr == NULL || cacheptr->write_method == NULL) {
                 /*
                  * WWW: try to set ourselves if possible? 
                  */
                 return netsnmp_set_request_error(reqinfo, requests,
                                                  SNMP_ERR_NOTWRITABLE);
             }
 
             oldasp = netsnmp_get_current_agent_session();
             set_current_agent_session(reqinfo->asp);
             status =
                 (*(cacheptr->write_method)) (reqinfo->mode,
                                              requests->requestvb->val.
                                              string,
                                              requests->requestvb->type,
                                              requests->requestvb->val_len,
                                              cacheptr->data,
                                              requests->requestvb->name,
                                              requests->requestvb->
                                              name_length);
             set_current_agent_session(oldasp);
 
             if (status != SNMP_ERR_NOERROR) {
                 netsnmp_set_request_error(reqinfo, requests, status);
             }
 
             /*
              * clean up is done by the automatic freeing of the
              * cache stored in the request. 
              */
 
             break;
         }
     }
     return SNMP_ERR_NOERROR;
 }
 
 /** @} */
 
 /*
  * don't use this! 
  */
diff --git a/agent/helpers/row_merge.c b/agent/helpers/row_merge.c
index f709b4bbc0..6fd1e17830 100644
--- a/agent/helpers/row_merge.c
+++ b/agent/helpers/row_merge.c
@@ -1,26 +1,26 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/row_merge.h>
 
 #include <stdint.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
diff --git a/agent/helpers/scalar.c b/agent/helpers/scalar.c
index 1c924f9a80..0278606c68 100644
--- a/agent/helpers/scalar.c
+++ b/agent/helpers/scalar.c
@@ -1,50 +1,50 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/scalar.h>
 
 #include <stdlib.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/instance.h>
 #include <net-snmp/agent/serialize.h>
 #include <net-snmp/agent/read_only.h>
 
 /** @defgroup scalar scalar
  *  Process scalars easily.
  *  @ingroup leaf
  *  @{
  */
 
 /**
  * Creates a scalar handler calling netsnmp_create_handler with a
  * handler name defaulted to "scalar" and access method, 
  * netsnmp_scalar_helper_handler.
  *
  * @return Returns a pointer to a netsnmp_mib_handler struct which contains
  *	the handler's name and the access method
  *
  * @see netsnmp_get_scalar_handler
  * @see netsnmp_register_scalar
  */
diff --git a/agent/helpers/scalar_group.c b/agent/helpers/scalar_group.c
index 6133c3c039..fc10f4be78 100644
--- a/agent/helpers/scalar_group.c
+++ b/agent/helpers/scalar_group.c
@@ -1,27 +1,27 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/scalar_group.h>
 
 #include <stdlib.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/instance.h>
 #include <net-snmp/agent/serialize.h>
diff --git a/agent/helpers/table.c b/agent/helpers/table.c
index c75f183e33..3a4740a4ed 100644
--- a/agent/helpers/table.c
+++ b/agent/helpers/table.c
@@ -35,11 +35,11 @@
 #ifndef NETSNMP_NO_WRITE_SUPPORT
 netsnmp_feature_require(oid_stash);
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/library/snmp_assert.h>
diff --git a/agent/helpers/table_array.c b/agent/helpers/table_array.c
index b0a6e6f4e6..2c044e284a 100644
--- a/agent/helpers/table_array.c
+++ b/agent/helpers/table_array.c
@@ -1,31 +1,31 @@
 /*
  * table_array.c
  * $Id$
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_array.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_assert.h>
diff --git a/agent/helpers/table_container.c b/agent/helpers/table_container.c
index 27e75ef3e1..fb4b157558 100644
--- a/agent/helpers/table_container.c
+++ b/agent/helpers/table_container.c
@@ -1,31 +1,31 @@
 /*
  * table_container.c
  * $Id$
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_container.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_assert.h>
diff --git a/agent/helpers/table_data.c b/agent/helpers/table_data.c
index b3d7e88c33..19c7285407 100644
--- a/agent/helpers/table_data.c
+++ b/agent/helpers/table_data.c
@@ -1,27 +1,27 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_data.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/read_only.h>
diff --git a/agent/helpers/table_dataset.c b/agent/helpers/table_dataset.c
index d93de8e062..c0c4393a76 100644
--- a/agent/helpers/table_dataset.c
+++ b/agent/helpers/table_dataset.c
@@ -1,25 +1,25 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_dataset.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
diff --git a/agent/helpers/table_iterator.c b/agent/helpers/table_iterator.c
index f69f9d2441..4cc2c1c80a 100644
--- a/agent/helpers/table_iterator.c
+++ b/agent/helpers/table_iterator.c
@@ -1,106 +1,106 @@
 /*
  * table_iterator.c 
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /** @defgroup table_iterator table_iterator
  *  The table iterator helper is designed to simplify the task of writing a table handler for the net-snmp agent when the data being accessed is not in an oid sorted form and must be accessed externally.
  *  @ingroup table
     Functionally, it is a specialized version of the more
     generic table helper but easies the burden of GETNEXT processing by
     manually looping through all the data indexes retrieved through
     function calls which should be supplied by the module that wishes
     help.  The module the table_iterator helps should, afterwards,
     never be called for the case of "MODE_GETNEXT" and only for the GET
     and SET related modes instead.
  
     The fundamental notion between the table iterator is that it
     allows your code to iterate over each "row" within your data
     storage mechanism, without requiring that it be sorted in a
     SNMP-index-compliant manner.  Through the get_first_data_point and
     get_next_data_point hooks, the table_iterator helper will
     repeatedly call your hooks to find the "proper" row of data that
     needs processing.  The following concepts are important:
 
       - A loop context is a pointer which indicates where in the
         current processing of a set of rows you currently are.  Allows
 	the get_*_data_point routines to move from one row to the next,
 	once the iterator handler has identified the appropriate row for
 	this request, the job of the loop context is done.  The
         most simple example would be a pointer to an integer which
         simply counts rows from 1 to X.  More commonly, it might be a
         pointer to a linked list node, or someother internal or
         external reference to a data set (file seek value, array
         pointer, ...).  If allocated during iteration, either the
         free_loop_context_at_end (preferably) or the free_loop_context
         pointers should be set.
 
       - A data context is something that your handler code can use
         in order to retrieve the rest of the data for the needed
         row.  This data can be accessed in your handler via
 	netsnmp_extract_iterator_context api with the netsnmp_request_info
 	structure that's passed in.
 	The important difference between a loop context and a
         data context is that multiple data contexts can be kept by the
         table_iterator helper, where as only one loop context will
         ever be held by the table_iterator helper.  If allocated
         during iteration the free_data_context pointer should be set
         to an appropriate function.
  
     The table iterator operates in a series of steps that call your
     code hooks from your netsnmp_iterator_info registration pointer.
  
       - the get_first_data_point hook is called at the beginning of
         processing.  It should set the variable list to a list of
         indexes for the given table.  It should also set the
         loop_context and maybe a data_context which you will get a
         pointer back to when it needs to call your code to retrieve
         actual data later.  The list of indexes should be returned
         after being update.
 
       - the get_next_data_point hook is then called repeatedly and is
         passed the loop context and the data context for it to update.
         The indexes, loop context and data context should all be
         updated if more data is available, otherwise they should be
         left alone and a NULL should be returned.  Ideally, it should
         update the loop context without the need to reallocate it.  If
         reallocation is necessary for every iterative step, then the
         free_loop_context function pointer should be set.  If not,
         then the free_loop_context_at_end pointer should be set, which
         is more efficient since a malloc/free will only be performed
         once for every iteration.
  *
  *  @{
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_iterator.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/serialize.h>
 #include <net-snmp/agent/stash_cache.h>
diff --git a/agent/helpers/table_row.c b/agent/helpers/table_row.c
index 8778ee0c09..b465750d5c 100644
--- a/agent/helpers/table_row.c
+++ b/agent/helpers/table_row.c
@@ -1,32 +1,32 @@
 /*
  * table_row.c
  *
  * Helper for registering single row slices of a shared table
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #define TABLE_ROW_DATA  "table_row"
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_container.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_assert.h>
diff --git a/agent/helpers/table_tdata.c b/agent/helpers/table_tdata.c
index e87a3c9f7b..8677967cd6 100644
--- a/agent/helpers/table_tdata.c
+++ b/agent/helpers/table_tdata.c
@@ -1,28 +1,28 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/table_tdata.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_container.h>
 #include <net-snmp/agent/read_only.h>
diff --git a/agent/kernel.c b/agent/kernel.c
index 311e39e757..285a603a77 100644
--- a/agent/kernel.c
+++ b/agent/kernel.c
@@ -1,47 +1,47 @@
 /***********************************************************************
    Net-SNMP - Simple Network Management Protocol agent library.
  ***********************************************************************/
 /** @file kernel.c
  *     Net-SNMP Kernel Data Access Library.
  *     Provides access to kernel virtual memory for systems that
  *     support it.
  * @author   See README file for a list of contributors
  */
 /* Copyrights:
  *     Copyright holders are listed in README file.
  *     Redistribution and use in source and binary forms, with or
  *     without modification, are permitted. License terms are specified
  *     in COPYING file distributed with the Net-SNMP package.
  */
 /***********************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
 #include <errno.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_KVM_H
 #include <kvm.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "kernel.h"
 #include <net-snmp/agent/ds_agent.h>
 
 #if defined(HAVE_KVM_H) && !defined(NETSNMP_NO_KMEM_USAGE)
@@ -56,43 +56,43 @@ int
 init_kmem(const char *file)
 {
     int res = TRUE;
 
-#if HAVE_KVM_OPENFILES
+#ifdef HAVE_KVM_OPENFILES
     char            err[4096];
 
     kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, err);
     if (!kd)
 #ifdef KVM_NO_FILES
 	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, err);
 #else
 	kd = kvm_openfiles(NULL, "/dev/null", NULL, O_RDONLY, err);
 #endif
     if (!kd && !netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                        NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
         snmp_log(LOG_CRIT, "init_kmem: kvm_openfiles failed: %s\n", err);
         res = FALSE;
     }
 #else
     kd = kvm_open(NULL, NULL, NULL, O_RDONLY, NULL);
     if (!kd && !netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				       NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
         snmp_log(LOG_CRIT, "init_kmem: kvm_open failed: %s\n",
                  strerror(errno));
         res = FALSE;
     }
 #endif                          /* HAVE_KVM_OPENFILES */
     return res;
 }
 
 /** Reads kernel memory.
  *  Seeks to the specified location in kmem, then
  *  does a read of given amount ob bytes into target buffer.
  *
  * @param off The location to seek.
  *
  * @param target The target buffer to read into.
  *
  * @param siz Number of bytes to read.
  *
  * @return gives 1 on success and 0 on failure.
  */
@@ -100,23 +100,23 @@ int
 klookup(unsigned long off, void *target, size_t siz)
 {
     int             result;
 
     if (kd == NULL)
         return 0;
     result = kvm_read(kd, off, target, siz);
     if (result != siz) {
-#if HAVE_KVM_OPENFILES
+#ifdef HAVE_KVM_OPENFILES
         snmp_log(LOG_ERR, "kvm_read(*, %lx, %p, %x) = %d: %s\n", off,
                  target, (unsigned) siz, result, kvm_geterr(kd));
 #else
         snmp_log(LOG_ERR, "kvm_read(*, %lx, %p, %d) = %d: ", off, target,
                  (unsigned) siz, result);
         snmp_log_perror("klookup");
 #endif
         return 0;
     }
     return 1;
 }
 
 /** Closes the kernel memory support.
  */
diff --git a/agent/mib_modules.c b/agent/mib_modules.c
index 095262e9a4..061d2b1046 100644
--- a/agent/mib_modules.c
+++ b/agent/mib_modules.c
@@ -1,44 +1,44 @@
 /*
  * wrapper to call all the mib module initialization functions 
  */
 
 #include <net-snmp/agent/mib_module_config.h>
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "m2m.h"
 #ifdef USING_IF_MIB_DATA_ACCESS_INTERFACE_MODULE
 #include <net-snmp/data_access/interface.h>
 #endif
 
 #include "mibgroup/struct.h"
 #include <net-snmp/agent/mib_modules.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 #include "mib_module_includes.h"
diff --git a/agent/mibgroup/Rmon/alarm.c b/agent/mibgroup/Rmon/alarm.c
index f5ef4ccc49..97763ae8c7 100644
--- a/agent/mibgroup/Rmon/alarm.c
+++ b/agent/mibgroup/Rmon/alarm.c
@@ -1,130 +1,130 @@
 /**************************************************************
  * Copyright (C) 2001 Alex Rozin, Optical Access
  * 
  *                     All Rights Reserved
  * 
  * Permission to use, copy, modify and distribute this software and its
  * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in
  * supporting documentation. 
  * 
  * ALEX ROZIN DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * ALEX ROZIN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE. 
  ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "alarm.h"
 #include "event.h"
     /*
      * Implementation headers 
      */
 #include "agutil_api.h"
 #include "row_api.h"
     /*
      * File scope definitions section 
      */
     /*
      * from MIB compilation 
      */
 #define alarmEntryFirstIndexBegin       11
 #define MMM_MAX				0xFFFFFFFFl
 #define IDalarmIndex                    1
 #define IDalarmInterval                 2
 #define IDalarmVariable                 3
 #define IDalarmSampleType               4
 #define IDalarmValue                    5
 #define IDalarmStartupAlarm             6
 #define IDalarmRisingThreshold          7
 #define IDalarmFallingThreshold         8
 #define IDalarmRisingEventIndex         9
 #define IDalarmFallingEventIndex        10
 #define IDalarmOwner                    11
 #define IDalarmStatus                   12
 #define MIN_alarmEventIndex             0
 #define MAX_alarmEventIndex             65535
      typedef enum {
          SAMPLE_TYPE_ABSOLUTE =
              1,
          SAMPLE_TYPE_DELTE
      } SAMPLE_TYPE_T;
 
      typedef enum {
          ALARM_NOTHING =
              0,
          ALARM_RISING,
          ALARM_FALLING,
          ALARM_BOTH
      } ALARM_TYPE_T;
 
      typedef struct {
          u_long
              interval;
          u_long
              timer_id;
          VAR_OID_T
              var_name;
          SAMPLE_TYPE_T
              sample_type;
          ALARM_TYPE_T
              startup_type;      /* RISING | FALLING | BOTH */
 
          u_long
              rising_threshold;
          u_long
              falling_threshold;
          u_long
              rising_event_index;
          u_long
              falling_event_index;
 
          u_long
              last_abs_value;
          u_long
              value;
          ALARM_TYPE_T
              prev_alarm;        /* NOTHING | RISING | FALLING */
      } CRTL_ENTRY_T;
 
 /*
  * Main section 
  */
 
      static TABLE_DEFINTION_T
          AlarmCtrlTable;
      static TABLE_DEFINTION_T *
          table_ptr = &
          AlarmCtrlTable;
 
 #if 0                           /* KUKU */
      static u_long
          kuku_sum =
          0,
          kuku_cnt =
          0;
 #endif
diff --git a/agent/mibgroup/Rmon/event.c b/agent/mibgroup/Rmon/event.c
index bd76eb810c..5fbb01fa3a 100644
--- a/agent/mibgroup/Rmon/event.c
+++ b/agent/mibgroup/Rmon/event.c
@@ -1,51 +1,51 @@
 /**************************************************************
  * Copyright (C) 2001 Alex Rozin, Optical Access
  *
  *                     All Rights Reserved
  *
  * Permission to use, copy, modify and distribute this software and its
  * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in
  * supporting documentation.
  *
  * ALEX ROZIN DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * ALEX ROZIN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "event.h"
 
 /*
  * Implementation headers 
  */
 #include "agutil_api.h"
 #include "row_api.h"
diff --git a/agent/mibgroup/Rmon/history.c b/agent/mibgroup/Rmon/history.c
index 16bdf59e7d..cee8c2a711 100644
--- a/agent/mibgroup/Rmon/history.c
+++ b/agent/mibgroup/Rmon/history.c
@@ -1,87 +1,87 @@
 /**************************************************************
  * Copyright (C) 2001 Alex Rozin, Optical Access 
  *
  *                     All Rights Reserved
  *
  * Permission to use, copy, modify and distribute this software and its
  * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in
  * supporting documentation.
  * 
  * ALEX ROZIN DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * ALEX ROZIN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "history.h"
 
 /*
  * Implementation headers 
  */
 #include "agutil_api.h"
 #include "row_api.h"
 
 /*
  * File scope definitions section 
  */
 
 #define historyControlEntryFirstIndexBegin      11
 
 #define CTRL_INDEX		3
 #define CTRL_DATASOURCE		4
 #define CTRL_BUCKETSREQUESTED	5
 #define CTRL_BUCKETSGRANTED	6
 #define CTRL_INTERVAL		7
 #define CTRL_OWNER		8
 #define CTRL_STATUS		9
 
 #define DATA_INDEX		3
 #define DATA_SAMPLEINDEX	4
 #define DATA_INTERVALSTART	5
 #define DATA_DROPEVENTS		6
 #define DATA_OCTETS		7
 #define DATA_PKTS		8
 #define DATA_BROADCASTPKTS	9
 #define DATA_MULTICASTPKTS	10
 #define DATA_CRCALIGNERRORS	11
 #define DATA_UNDERSIZEPKTS	12
 #define DATA_OVERSIZEPKTS	13
 #define DATA_FRAGMENTS		14
 #define DATA_JABBERS		15
 #define DATA_COLLISIONS		16
 #define DATA_UTILIZATION	17
 
 /*
  * defaults & limitations 
  */
 
 #define MAX_BUCKETS_IN_CRTL_ENTRY	50
 #define HIST_DEF_BUCK_REQ		50
 #define HIST_DEF_INTERVAL		1800
diff --git a/agent/mibgroup/Rmon/statistics.c b/agent/mibgroup/Rmon/statistics.c
index 8d89ae177d..bb2bcece51 100644
--- a/agent/mibgroup/Rmon/statistics.c
+++ b/agent/mibgroup/Rmon/statistics.c
@@ -1,129 +1,129 @@
 /**************************************************************
  * Copyright (C) 2001 Tali Rozin, Optical Access
  *
  *                     All Rights Reserved
  *
  * Permission to use, copy, modify and distribute this software and its
  * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in
  * supporting documentation.
  *
  * TALI ROZIN DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * ALEX ROZIN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_STDLIB
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "statistics.h"
         /*
          * Implementation headers 
          */
 #include "agutil_api.h"
 #include "row_api.h"
         /*
          * File scope definitions section 
          */
         /*
          * from MIB compilation 
          */
 #define MIB_DESCR	"EthStat"
 #define etherStatsEntryFirstIndexBegin	11
 #define IDetherStatsDroppedFrames        1
 #define IDetherStatsCreateTime           2
 #define IDetherStatsIndex                3
 #define IDetherStatsDataSource           4
 #define IDetherStatsDropEvents           5
 #define IDetherStatsOctets               6
 #define IDetherStatsPkts                 7
 #define IDetherStatsBroadcastPkts        8
 #define IDetherStatsMulticastPkts        9
 #define IDetherStatsCRCAlignErrors       10
 #define IDetherStatsUndersizePkts        11
 #define IDetherStatsOversizePkts         12
 #define IDetherStatsFragments            13
 #define IDetherStatsJabbers              14
 #define IDetherStatsCollisions           15
 #define IDetherStatsPkts64Octets         16
 #define IDetherStatsPkts65to127Octets    17
 #define IDetherStatsPkts128to255Octets   18
 #define IDetherStatsPkts256to511Octets   19
 #define IDetherStatsPkts512to1023Octets  20
 #define IDetherStatsPkts1024to1518Octets 21
 #define IDetherStatsOwner                22
 #define IDetherStatsStatus               23
 #define Leaf_etherStatsDataSource        2
 #define Leaf_etherStatsOwner             20
 #define Leaf_etherStatsStatus            21
 #define MIN_etherStatsIndex   1
 #define MAX_etherStatsIndex   65535
      typedef struct {
          VAR_OID_T
              data_source;
          u_long
              etherStatsCreateTime;
          ETH_STATS_T
              eth;
      } CRTL_ENTRY_T;
 
 /*
  * Main section 
  */
 
      static TABLE_DEFINTION_T
          StatCtrlTable;
      static TABLE_DEFINTION_T *
          table_ptr = &
          StatCtrlTable;
 
 /*
  * Control Table RowApi Callbacks 
  */
 
      int
      stat_Create(RMON_ENTRY_T * eptr)
 {                               /* create the body: alloc it and set defaults */
     CRTL_ENTRY_T   *body;
     static VAR_OID_T data_src_if_index_1 =
         { 11, {1, 3, 6, 1, 2, 1, 2, 2, 1, 1, 1} };
 
     eptr->body = AGMALLOC(sizeof(CRTL_ENTRY_T));
     if (!eptr->body)
         return -3;
     body = (CRTL_ENTRY_T *) eptr->body;
 
     /*
      * set defaults 
      */
     memcpy(&body->data_source, &data_src_if_index_1, sizeof(VAR_OID_T));
     body->data_source.objid[body->data_source.length - 1] =
         eptr->ctrl_index;
     eptr->owner = AGSTRDUP("Startup Mgmt");
     memset(&body->eth, 0, sizeof(ETH_STATS_T));
 
     return 0;
 }
diff --git a/agent/mibgroup/agentx/agentx_config.c b/agent/mibgroup/agentx/agentx_config.c
index 0fe9f986f1..44f00a23b7 100644
--- a/agent/mibgroup/agentx/agentx_config.c
+++ b/agent/mibgroup/agentx/agentx_config.c
@@ -1,22 +1,22 @@
 /*
  *  AgentX Configuration
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "snmpd.h"
 #include "agentx/agentx_config.h"
 #include "agentx/protocol.h"
diff --git a/agent/mibgroup/agentx/client.c b/agent/mibgroup/agentx/client.c
index 1818507bb9..528c964941 100644
--- a/agent/mibgroup/agentx/client.c
+++ b/agent/mibgroup/agentx/client.c
@@ -1,44 +1,44 @@
 /*
  *   AgentX utility routines
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <errno.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_index.h>
 #include "agent_global_vars.h"
 
 #include "agentx/protocol.h"
 #include "agentx/client.h"
 #include "agentx/subagent.h"
diff --git a/agent/mibgroup/agentx/master.c b/agent/mibgroup/agentx/master.c
index 8d79f85755..55ac7935e9 100644
--- a/agent/mibgroup/agentx/master.c
+++ b/agent/mibgroup/agentx/master.c
@@ -1,52 +1,52 @@
 /*
  *  AgentX master agent
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #include <errno.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
 #define SNMP_NEED_REQUEST_LIST
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "snmpd.h"
 #include "agentx/protocol.h"
 #include "agentx/master_admin.h"
diff --git a/agent/mibgroup/agentx/master_admin.c b/agent/mibgroup/agentx/master_admin.c
index b46ae71e0e..5392604d0a 100644
--- a/agent/mibgroup/agentx/master_admin.c
+++ b/agent/mibgroup/agentx/master_admin.c
@@ -1,46 +1,46 @@
 /*
  *  AgentX Administrative request handling
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "agent_global_vars.h"
 
 #include "agentx/protocol.h"
 #include "agentx/client.h"
 #include "agentx/subagent.h"
 #include "agentx/master_admin.h"
 
 #include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_sysORTable.h>
 #include "master.h"
diff --git a/agent/mibgroup/agentx/protocol.c b/agent/mibgroup/agentx/protocol.c
index a6d830e800..e1607ab9fd 100644
--- a/agent/mibgroup/agentx/protocol.c
+++ b/agent/mibgroup/agentx/protocol.c
@@ -1,48 +1,48 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <limits.h>
 #include <stdio.h>
 #include <errno.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "agentx/protocol.h"
diff --git a/agent/mibgroup/agentx/subagent.c b/agent/mibgroup/agentx/subagent.c
index 7a859ca6e2..3633ecaec9 100644
--- a/agent/mibgroup/agentx/subagent.c
+++ b/agent/mibgroup/agentx/subagent.c
@@ -1,48 +1,48 @@
 /*
  *  AgentX sub-agent
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/agent_index.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include "snmpd.h"
 #include "agent_global_vars.h"
 #include "agentx/protocol.h"
 #include "agentx/client.h"
 #include "agentx/agentx_config.h"
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/sysORTable.h>
 #include <net-snmp/agent/agent_sysORTable.h>
 
 #include "subagent.h"
diff --git a/agent/mibgroup/deliver/deliverByNotify.h b/agent/mibgroup/deliver/deliverByNotify.h
index 292c366e2f..b243cafa5a 100644
--- a/agent/mibgroup/deliver/deliverByNotify.h
+++ b/agent/mibgroup/deliver/deliverByNotify.h
@@ -1,13 +1,13 @@
 #ifndef DELIVERBYNOTIFY_H
 #define DELIVERBYNOTIFY_H 1
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
diff --git a/agent/mibgroup/disman/expression/expErrorTable.c b/agent/mibgroup/disman/expression/expErrorTable.c
index 5ef1ef684d..0231d64787 100644
--- a/agent/mibgroup/disman/expression/expErrorTable.c
+++ b/agent/mibgroup/disman/expression/expErrorTable.c
@@ -1,55 +1,55 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name: expErrorTable.c
  *File Description: expErrorTable MIB operation.
  *
  *Current Version:1.0
  *Author:JianShun Tong
  *Date:2004.8.20
  */
 
 
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "expErrorTable.h"
 #include "expExpressionTable.h"
 
 
 
 /*
  * expErrorTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/expression/expExpressionTable.c b/agent/mibgroup/disman/expression/expExpressionTable.c
index 858deb49d1..13a594a5a7 100644
--- a/agent/mibgroup/disman/expression/expExpressionTable.c
+++ b/agent/mibgroup/disman/expression/expExpressionTable.c
@@ -1,47 +1,47 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name: expExpressionTable.c
  *File Description: expExpressionTable MIB operation.
  *
  *Current Version:1.0
  *Author:JianShun Tong
  *Date:2004.8.20
  */
 
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "header_complex.h"
 #include "expErrorTable.h"
 #include "expExpressionTable.h"
 #include "expObjectTable.h"
 #include "expValueTable.h"
diff --git a/agent/mibgroup/disman/expression/expObjectTable.c b/agent/mibgroup/disman/expression/expObjectTable.c
index 936f1a540a..c38f23c024 100644
--- a/agent/mibgroup/disman/expression/expObjectTable.c
+++ b/agent/mibgroup/disman/expression/expObjectTable.c
@@ -1,38 +1,38 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name: expObjectTable.c
  *File Description: expObjectTable MIB operation.
  *
  *Current Version:1.0
  *Author:JianShun Tong
  *Date:2004.8.20
  */
 
 
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT
diff --git a/agent/mibgroup/disman/expression/expValueTable.c b/agent/mibgroup/disman/expression/expValueTable.c
index 2463bd4b34..1228a5f1cb 100644
--- a/agent/mibgroup/disman/expression/expValueTable.c
+++ b/agent/mibgroup/disman/expression/expValueTable.c
@@ -1,59 +1,59 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name: expValueTable.c
  *File Description: expValueTable MIB operation.
  *
  *Current Version:1.0
  *Author:JianShun Tong
  *Date:2004.8.20
  */
 
 
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <stdio.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "utilities/iquery.h"
 #include "header_complex.h"
 #include "expExpressionTable.h"
 #include "expValueTable.h"
 #include "expObjectTable.h"
 
 
 /*
  * expValueTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/mteObjectsTable.c b/agent/mibgroup/disman/mteObjectsTable.c
index 2c21000a6a..2eda68c7ab 100644
--- a/agent/mibgroup/disman/mteObjectsTable.c
+++ b/agent/mibgroup/disman/mteObjectsTable.c
@@ -1,21 +1,21 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT
diff --git a/agent/mibgroup/disman/mteTriggerBooleanTable.c b/agent/mibgroup/disman/mteTriggerBooleanTable.c
index 2d659c26dd..9a962ba296 100644
--- a/agent/mibgroup/disman/mteTriggerBooleanTable.c
+++ b/agent/mibgroup/disman/mteTriggerBooleanTable.c
@@ -1,37 +1,37 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "mteTriggerBooleanTable.h"
 #include "mteTriggerTable.h"
 
 
 /*
  * mteTriggerBooleanTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/mteTriggerDeltaTable.c b/agent/mibgroup/disman/mteTriggerDeltaTable.c
index c4757191de..f55dcd8a9f 100644
--- a/agent/mibgroup/disman/mteTriggerDeltaTable.c
+++ b/agent/mibgroup/disman/mteTriggerDeltaTable.c
@@ -1,37 +1,37 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "mteTriggerDeltaTable.h"
 #include "mteTriggerTable.h"
 
 
 /*
  * mteTriggerDeltaTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/mteTriggerExistenceTable.c b/agent/mibgroup/disman/mteTriggerExistenceTable.c
index fff4dbb81c..f69d604690 100644
--- a/agent/mibgroup/disman/mteTriggerExistenceTable.c
+++ b/agent/mibgroup/disman/mteTriggerExistenceTable.c
@@ -1,37 +1,37 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "mteTriggerExistenceTable.h"
 #include "mteTriggerTable.h"
 
 
 /*
  * mteTriggerExistenceTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/mteTriggerTable.c b/agent/mibgroup/disman/mteTriggerTable.c
index 5bd318ef1d..1db981ba95 100644
--- a/agent/mibgroup/disman/mteTriggerTable.c
+++ b/agent/mibgroup/disman/mteTriggerTable.c
@@ -1,22 +1,22 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
diff --git a/agent/mibgroup/disman/mteTriggerThresholdTable.c b/agent/mibgroup/disman/mteTriggerThresholdTable.c
index 0acec8c402..45f5004d7d 100644
--- a/agent/mibgroup/disman/mteTriggerThresholdTable.c
+++ b/agent/mibgroup/disman/mteTriggerThresholdTable.c
@@ -1,37 +1,37 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "mteTriggerThresholdTable.h"
 #include "mteTriggerTable.h"
 
 
 /*
  * mteTriggerThresholdTable_variables_oid:
  *   this is the top level oid that we want to register under.  This
  *   is essentially a prefix, with the suffix appearing in the
  *   variable below.
  */
diff --git a/agent/mibgroup/disman/nslookup/lookupCtlTable.c b/agent/mibgroup/disman/nslookup/lookupCtlTable.c
index 4318a73045..f2043d3c06 100644
--- a/agent/mibgroup/disman/nslookup/lookupCtlTable.c
+++ b/agent/mibgroup/disman/nslookup/lookupCtlTable.c
@@ -504,294 +504,294 @@ void
 run_lookup(struct lookupTable_data *item)
 {
     long            addressType;
     char           *address = NULL;
     size_t          addresslen;
     struct lookupResultsTable_data *current = NULL;
     struct lookupResultsTable_data *temp = NULL;
     int             i = 0, n = 1;
 
     struct timeval  tpstart, tpend;
     unsigned long   timeuse, timeuse4 = 0, timeuse6 = 0;
 
     if (item == NULL)
         return;
 
     addressType = (long) item->lookupCtlTargetAddressType;
     addresslen = (size_t) item->lookupCtlTargetAddressLen;
     address = (char *) malloc(addresslen + 1);
     memcpy(address, item->lookupCtlTargetAddress, addresslen + 1);
     address[addresslen] = '\0';
 
     if (addressType == INETADDRESSTYPE_IPV4) {
         struct in_addr addr_in;
         struct hostent *lookup;
 
         if (inet_pton(AF_INET, address, &addr_in) != 1) {
             DEBUGMSGTL(("lookupResultsTable", "Invalid argument: %s\n",
                         address));
             modify_lookupCtlRc(item, 99);
             return;
         }
 
         netsnmp_get_monotonic_clock(&tpstart);
         lookup = netsnmp_gethostbyaddr(&addr_in, sizeof(addr_in), AF_INET);
         netsnmp_get_monotonic_clock(&tpend);
         timeuse = 1000000 * (tpend.tv_sec - tpstart.tv_sec) +
             tpend.tv_usec - tpstart.tv_usec;
         timeuse /= 1000;
         modify_lookupCtlTime(item, timeuse);
         modify_lookupCtlOperStatus(item, 3L);
 
         if (lookup == NULL) {
             DEBUGMSGTL(("lookupCtlTable",
                         "Can't get a network host entry for ipv4 address: %s\n",
                         address));
             modify_lookupCtlRc(item, h_errno);
             return;
         } else {
             modify_lookupCtlRc(item, 0L);
             if (lookup->h_name != NULL) {
                 current = temp = add_result(item, n, INETADDRESSTYPE_DNS,
                             lookup->h_name, strlen(lookup->h_name));
                 n = n + 1;
             }
 
             i = 0;
             while (lookup->h_aliases[i]) {
                 temp = add_result(item, n, INETADDRESSTYPE_DNS,
                             lookup->h_aliases[i], strlen(lookup->h_aliases[i]));
                 if (current)
                     current->next = temp;
                 current = temp;
                 i = i + 1;
                 n = n + 1;
             }
         }
 
         if (item->ResultsTable != NULL)
             if (lookupResultsTable_add(item) != SNMPERR_SUCCESS)
                 DEBUGMSGTL(("lookupResultsTable",
                             "registered an entry error\n"));
         SNMP_FREE(address);
         return;
     }
 
     else if (addressType == INETADDRESSTYPE_DNS) {
         struct hostent *lookup;
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
         int             res;
         struct addrinfo *ais;
         struct addrinfo hints = { 0, AF_INET6, SOCK_DGRAM };
 #endif
 
         netsnmp_get_monotonic_clock(&tpstart);
         lookup = netsnmp_gethostbyname(address);
         netsnmp_get_monotonic_clock(&tpend);
         timeuse4 = 1000000 * (tpend.tv_sec - tpstart.tv_sec) +
             tpend.tv_usec - tpstart.tv_usec;
         if (lookup == NULL) {
             DEBUGMSGTL(("lookupCtlTable",
                         "Can't get a network host entry for %s\n",
                         address));
             modify_lookupCtlRc(item, h_errno);
         } else {
             while (lookup->h_addr_list[i]) {
                 char buf[64];
                 int buflen;
 
                 inet_ntop(lookup->h_addrtype, lookup->h_addr_list[i], buf, sizeof(buf));
                 buflen = strlen(buf);
                 switch (lookup->h_addrtype) {
                 case AF_INET:
                     temp = add_result(item, n, INETADDRESSTYPE_IPV4, buf, buflen);
                     break;
                 case AF_INET6:
                     temp = add_result(item, n, INETADDRESSTYPE_IPV6, buf, buflen);
                     break;
                 default:
                     snmp_log(LOG_ERR, "nslookup-mib/run_lookup: Unknown address type %d\n", lookup->h_addrtype);
                     temp = add_result(item, n, INETADDRESSTYPE_UNKNOWN, "", 0);
                     break;
                 }
                 DEBUGMSGTL(("lookupCtlTable", "Adding %d %s\n", n, buf));
 
                 if (n == 1)
                     item->ResultsTable = temp;
                 else
                     current->next = temp;
                 current = temp;
                 n = n + 1;
                 i = i + 1;
             }
         }
 
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
         netsnmp_get_monotonic_clock(&tpstart);
         res = netsnmp_getaddrinfo(address, NULL, &hints, &ais);
         netsnmp_get_monotonic_clock(&tpend);
         timeuse6 = 1000000 * (tpend.tv_sec - tpstart.tv_sec) +
             tpend.tv_usec - tpstart.tv_usec;
 
         if (res != 0) {
             DEBUGMSGTL(("lookupCtlTable",
                         "Can't get a ipv6 network host entry for %s\n",
                         address));
             modify_lookupCtlRc(item, res);
         } else {
             struct addrinfo *aip = ais;
             while (aip) {
                 char buf[64];
                 int buflen;
 
                 switch (aip->ai_family) {
                 case AF_INET:
                     inet_ntop(aip->ai_family,
                             &((struct sockaddr_in *)aip->ai_addr)->sin_addr,
                         buf, sizeof(buf));
                     buflen = strlen(buf);
                     temp = add_result(item, n, INETADDRESSTYPE_IPV4, buf, buflen);
                     break;
                 case AF_INET6:
                     inet_ntop(aip->ai_family,
                             &((struct sockaddr_in6 *)aip->ai_addr)->sin6_addr,
                         buf, sizeof(buf));
                     buflen = strlen(buf);
                     temp = add_result(item, n, INETADDRESSTYPE_IPV6, buf, buflen);
                     break;
                 default:
                     snmp_log(LOG_ERR, "nslookup-mib/run_lookup: Unknown address type %d\n", aip->ai_family);
                     temp = add_result(item, n, INETADDRESSTYPE_UNKNOWN, "", 0);
                     break;
                 }
                 DEBUGMSGTL(("lookupCtlTable", "Adding %d %s\n", n, buf));
 
                 if (n == 1)
                     item->ResultsTable = temp;
                 else
                     current->next = temp;
                 current = temp;
                 n = n + 1;
                 aip = aip->ai_next;
             }
             freeaddrinfo(ais);
         }
-#elif HAVE_GETHOSTBYNAME2
+#elif defined(HAVE_GETHOSTBYNAME2)
         netsnmp_get_monotonic_clock(&tpstart);
         lookup = gethostbyname2(address, AF_INET6);
         netsnmp_get_monotonic_clock(&tpend);
         timeuse6 = 1000000 * (tpend.tv_sec - tpstart.tv_sec) +
             tpend.tv_usec - tpstart.tv_usec;
 
         if (lookup == NULL) {
             DEBUGMSGTL(("lookupCtlTable",
                         "Can't get a ipv6 network host entry for %s\n",
                         address));
             modify_lookupCtlRc(item, h_errno);
         } else {
             i = 0;
             while (lookup->h_addr_list[i]) {
                 char buf[64];
                 int buflen;
 
                 inet_ntop(lookup->h_addrtype, lookup->h_addr_list[i],
                         buf, sizeof(buf));
                 buflen = strlen(buf);
                 switch (lookup->h_addrtype) {
                 case AF_INET:
                     temp = add_result(item, n, INETADDRESSTYPE_IPV4, buf, buflen);
                     break;
                 case AF_INET6:
                     temp = add_result(item, n, INETADDRESSTYPE_IPV6, buf, buflen);
                     break;
                 default:
                     snmp_log(LOG_ERR, "nslookup-mib/run_lookup: Unknown address type %d\n", lookup->h_addrtype);
                     temp = add_result(item, n, INETADDRESSTYPE_UNKNOWN, "", 0);
                     break;
                 }
                 DEBUGMSGTL(("lookupCtlTable", "Adding %d %s\n", n, buf));
 
                 if (n == 1)
                     item->ResultsTable = temp;
                 else
                     current->next = temp;
                 current = temp;
                 n = n + 1;
                 i = i + 1;
             }
         }
 #endif
 
         timeuse = timeuse4 + timeuse6;
         timeuse /= 1000;
         modify_lookupCtlTime(item, timeuse);
         modify_lookupCtlOperStatus(item, 3L);
 
         if (item->ResultsTable != NULL) {
             modify_lookupCtlRc(item, 0L);
             if (lookupResultsTable_add(item) != SNMPERR_SUCCESS)
                 DEBUGMSGTL(("lookupResultsTable",
                             "registered an entry error\n"));
         }
         SNMP_FREE(address);
         return;
     }
 
     else if (addressType == INETADDRESSTYPE_IPV6) {
         struct in6_addr addr_in6;
         struct hostent *lookup;
 
         if (inet_pton(AF_INET6, address, &addr_in6) == 1)
             DEBUGMSGTL(("lookupCtlTable", "success! \n"));
         else
             DEBUGMSGTL(("lookupCtlTable", "error! \n"));
 
         netsnmp_get_monotonic_clock(&tpstart);
         lookup = netsnmp_gethostbyaddr(&addr_in6, sizeof(addr_in6), AF_INET6);
         netsnmp_get_monotonic_clock(&tpend);
         timeuse = 1000000 * (tpend.tv_sec - tpstart.tv_sec) +
             tpend.tv_usec - tpstart.tv_usec;
         timeuse /= 1000;
         modify_lookupCtlTime(item, timeuse);
         modify_lookupCtlOperStatus(item, 3L);
 
         if (lookup == NULL) {
             DEBUGMSGTL(("lookupCtlTable",
                         "Can't get a network host entry for %s\n",
                         address));
             modify_lookupCtlRc(item, h_errno);
             return;
         } else {
             modify_lookupCtlRc(item, 0L);
             if (lookup->h_name != NULL) {
                 current = temp = add_result(item, n, INETADDRESSTYPE_DNS,
                             lookup->h_name, strlen(lookup->h_name));
                 n = n + 1;
             }
 
             i = 0;
             while (lookup->h_aliases[i]) {
                 current = temp = add_result(item, n, INETADDRESSTYPE_DNS,
                             lookup->h_aliases[i], strlen(lookup->h_aliases[i]));
                 current->next = temp;
                 current = temp;
                 i = i + 1;
                 n = n + 1;
             }
 
             if (item->ResultsTable != NULL)
                 current->next = NULL;
             else
                 current = NULL;
         }
 
         if (item->ResultsTable != NULL)
             if (lookupResultsTable_add(item) != SNMPERR_SUCCESS)
                 DEBUGMSGTL(("lookupResultsTable",
                             "registered an entry error\n"));
         SNMP_FREE(address);
         return;
     } else {
         SNMP_FREE(address);
         return;
     }
 }
diff --git a/agent/mibgroup/disman/ping/pingCtlTable.c b/agent/mibgroup/disman/ping/pingCtlTable.c
index 245e9c815b..4d8719ad47 100644
--- a/agent/mibgroup/disman/ping/pingCtlTable.c
+++ b/agent/mibgroup/disman/ping/pingCtlTable.c
@@ -1,47 +1,47 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name:pingCtlTable.c
  *File Description:Rows of the pingCtlTable MIB add , delete and read.Rows of lookupResultsTable
  *              MIB add and delete.Rows of pingProbeHistoryTable MIB add and delete. 
  *              The main function is also here.
  *
  *Current Version:1.0
  *Author:ChenJing
  *Date:2004.8.20
  */
 
 /*
  * This should always be included first before anything else 
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #include <netdb.h>
 #include <netinet/in.h>
 
 #include <linux/param.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <arpa/inet.h>
 
 #include "pingCtlTable.h"
 #include "pingResultsTable.h"
 #include "pingProbeHistoryTable.h"
 #include "header_complex.h"
@@ -1119,26 +1119,26 @@ struct addrinfo *
 Host_serv(const char *host, const char *serv, int family, int socktype)
 {
     int             n;
     struct addrinfo hints, *res;
 
     memset(&hints, '\0', sizeof(struct addrinfo));
     hints.ai_flags = AI_CANONNAME;      /* always return canonical name */
     hints.ai_family = family;   /* 0, AF_INET, AF_INET6, etc. */
     hints.ai_socktype = socktype;       /* 0, SOCK_STREAM, SOCK_DGRAM, etc. */
 
     if ((n = netsnmp_getaddrinfo(host, serv, &hints, &res)) != 0) {
-#if HAVE_GAI_STRERROR
+#ifdef HAVE_GAI_STRERROR
         snmp_log(LOG_ERR, "host_serv error for %s, %s: %s",
                  (host == NULL) ? "(no hostname)" : host,
                  (serv == NULL) ? "(no service name)" : serv,
                  gai_strerror(n));
 #else
         snmp_log(LOG_ERR, "host_serv error for %s, %s",
                  (host == NULL) ? "(no hostname)" : host,
                  (serv == NULL) ? "(no service name)" : serv);
 #endif
     }
 
     return (res);               /* return pointer to first on linked list */
 }
 #endif
diff --git a/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c b/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
index 1f62a3a1df..cc59a5ee12 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteHopsTable.c
@@ -1,36 +1,36 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name:traceRouteHopsTable.c
  *File Description:Rows of traceRouteHopsTable MIB read.
  *
  *Current Version:1.0
  *Author:ChenJing
  *Date:2004.8.20
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "traceRouteCtlTable.h"
 #include "traceRouteResultsTable.h"
 #include "traceRouteProbeHistoryTable.h"
 #include "traceRouteHopsTable.h"
 
 #include "header_complex.h"
diff --git a/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c b/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
index fb6fdcbdcc..f7e9a7e6c8 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteProbeHistoryTable.c
@@ -1,35 +1,35 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name:traceRouteProbeHistoryTable.c
  *File Description:Rows of traceRouteProbeHistoryTable MIB read.
  *
  *Current Version:1.0
  *Author:ChenJing
  *Date:2004.8.20
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "traceRouteCtlTable.h"
 #include "traceRouteResultsTable.h"
 #include "traceRouteProbeHistoryTable.h"
 #include "traceRouteHopsTable.h"
 
 #include "header_complex.h"
diff --git a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
index 8665f5def2..063a6aa30e 100644
--- a/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
+++ b/agent/mibgroup/disman/traceroute/traceRouteResultsTable.c
@@ -1,43 +1,43 @@
 /*
  *Copyright(c)2004,Cisco URP imburses and Network Information Center in Beijing University of Posts and Telecommunications researches.
  *
  *All right reserved
  *
  *File Name:traceRouteResultsTable.c
  *File Description:Rows of traceRouteResultsTable MIB read.
  *
  *Current Version:1.0
  *Author:ChenJing
  *Date:2004.8.20
  */
 
 /*
  * Note: this file originally auto-generated by mib2c using
  *        : mib2c.create-dataset.conf,v 5.3 2002/12/05 00:29:45 hardaker Exp $
  */
 
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "traceRouteResultsTable.h"
 #include "traceRouteCtlTable.h"
 #include "traceRouteProbeHistoryTable.h"
 #include "traceRouteHopsTable.h"
 #include "header_complex.h"
diff --git a/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c b/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
index 03f5411f4a..ce02419f58 100644
--- a/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
+++ b/agent/mibgroup/etherlike-mib/data_access/dot3stats_linux.c
@@ -1,27 +1,27 @@
 /*
  * standard Net-SNMP includes 
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/interface.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include "util_funcs.h"
 
 /*
  * include our parent header 
  */
 #include "etherlike-mib/dot3StatsTable/dot3StatsTable.h"
 #include "etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.h"
 #include "etherlike-mib/dot3StatsTable/ioctl_imp_common.h"
 
 /*
  * @retval  0 success
  * @retval -1 getifaddrs failed 
  * @retval -2 memory allocation failed
  */
diff --git a/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c b/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
index cb60f6bb04..5afce2b2c8 100644
--- a/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
+++ b/agent/mibgroup/etherlike-mib/dot3StatsTable/dot3StatsTable_data_access.c
@@ -1,61 +1,61 @@
 /*
  * Note: this file originally auto-generated by mib2c using
  *       version : 14170 $ of $ 
  *
  * $Id:$
  */
 /*
  * standard Net-SNMP includes 
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 /*
  * include our parent header 
  */
 #include "dot3StatsTable.h"
 #include "dot3StatsTable_data_access.h"
 
 #if defined(linux)
 #include "ioctl_imp_common.h"
 #endif
 
 /** @ingroup interface
  * @addtogroup data_access data_access: Routines to access data
  *
  * These routines are used to locate the data used to satisfy
  * requests.
  * 
  * @{
  */
 /**********************************************************************
  **********************************************************************
  ***
  *** Table dot3StatsTable
  ***
  **********************************************************************
  **********************************************************************/
 /*
  * EtherLike-MIB::dot3StatsTable is subid 2 of dot3.
  * Its status is Current.
  * OID: .1.3.6.1.2.1.10.7.2, length: 9
  */
 
 /**
  * initialization for dot3StatsTable data access
  *
  * This function is called during startup to allow you to
  * allocate any resources you need for the data table.
  *
  * @param dot3StatsTable_reg
  *        Pointer to dot3StatsTable_registration
  *
  * @retval MFD_SUCCESS : success.
  * @retval MFD_ERROR   : unrecoverable error.
  */
diff --git a/agent/mibgroup/examples/example.c b/agent/mibgroup/examples/example.c
index de3999f6b3..a9a5cfc8d4 100644
--- a/agent/mibgroup/examples/example.c
+++ b/agent/mibgroup/examples/example.c
@@ -1,39 +1,39 @@
 /*
  *  Template MIB group implementation - example.c
  *
  */
 
 /*
  * include important headers 
  */
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 /*
  * header_generic() comes from here 
  */
 #include "util_funcs/header_generic.h"
 
 /*
  * include our .h file 
  */
 #include "example.h"
 
 
    /*
     *  Certain objects can be set via configuration file directives.
     *  These variables hold the values for such objects, as they need to
     *   be accessible to both the config handlers, and the callback routine.
     */
 #define EXAMPLE_STR_LEN	300
 #define EXAMPLE_STR_DEFAULT	"life the universe and everything"
diff --git a/agent/mibgroup/examples/ucdDemoPublic.c b/agent/mibgroup/examples/ucdDemoPublic.c
index be11ad7972..90909712c5 100644
--- a/agent/mibgroup/examples/ucdDemoPublic.c
+++ b/agent/mibgroup/examples/ucdDemoPublic.c
@@ -1,34 +1,34 @@
 /*
  * ucdDemoPublic.c 
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/tools.h>
 
 #include "util_funcs/header_generic.h"
 #include "ucdDemoPublic.h"
 
 #define MYMAX 1024
 #define MAXUSERS 10
diff --git a/agent/mibgroup/hardware/fsys/fsys_getfsstats.c b/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
index a23b69c487..44e5196d0d 100644
--- a/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
+++ b/agent/mibgroup/hardware/fsys/fsys_getfsstats.c
@@ -1,36 +1,36 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "hardware/fsys/fsys.h"
 #include "hardware/fsys/hw_fsys.h"
 #include "hardware/fsys/hw_fsys_private.h"
 
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_STATVFS_H
+#ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 
 
     /*
      * Handle minor naming differences between statfs/statvfs
      */
 #if defined(_VFS_NAMELEN)
 #define NSFS_NAMELEN  _VFS_NAMELEN
 #else
 #define NSFS_NAMELEN  MNAMELEN
 #endif
 
 #if defined(HAVE_GETVFSSTAT) && defined(__NetBSD__)
 #define NSFS_GETFSSTAT  getvfsstat
 #define NSFS_STATFS     statvfs
 #define NSFS_FLAGS      f_flag
 #else
 #define NSFS_GETFSSTAT  getfsstat
 #define NSFS_STATFS     statfs
 #define NSFS_FLAGS      f_flags
 #endif
diff --git a/agent/mibgroup/hardware/fsys/fsys_mntctl.c b/agent/mibgroup/hardware/fsys/fsys_mntctl.c
index 79e40c4761..acdb252f81 100644
--- a/agent/mibgroup/hardware/fsys/fsys_mntctl.c
+++ b/agent/mibgroup/hardware/fsys/fsys_mntctl.c
@@ -1,19 +1,19 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "hardware/fsys/fsys.h"
 
 #include <stdio.h>
-#if HAVE_SYS_MNTCTL_H
+#ifdef HAVE_SYS_MNTCTL_H
 #include <sys/mntctl.h>
 #endif
-#if HAVE_SYS_VMOUNT_H
+#ifdef HAVE_SYS_VMOUNT_H
 #include <sys/vmount.h>
 #endif
-#if HAVE_SYS_STATFS_H
+#ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
-#if HAVE_SYS_STATVFS_H
+#ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 
diff --git a/agent/mibgroup/hardware/fsys/fsys_mntent.c b/agent/mibgroup/hardware/fsys/fsys_mntent.c
index c80e215a9d..ddc20cabec 100644
--- a/agent/mibgroup/hardware/fsys/fsys_mntent.c
+++ b/agent/mibgroup/hardware/fsys/fsys_mntent.c
@@ -1,71 +1,71 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "hardware/fsys/fsys.h"
 #include "hw_fsys.h"
 #include "hardware/fsys/hw_fsys_private.h"
 
 #include <stdio.h>
-#if HAVE_MNTENT_H
+#ifdef HAVE_MNTENT_H
 #include <mntent.h>
 #endif
 #ifdef HAVE_SYS_MNTTAB_H
 #include <sys/mnttab.h>
 #endif
-#if HAVE_SYS_VFS_H
+#ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_STATFS_H
+#ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
-#if HAVE_SYS_STATVFS_H
+#ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 #if defined(HAVE_PCRE_H)
 #include <pcre.h>
 #elif defined(HAVE_REGEX_H)
 #include <sys/types.h>
 #include <regex.h>
 #endif
 
 #ifdef solaris2
 #define _NETSNMP_GETMNTENT_TWO_ARGS 1
 #else
 #undef  _NETSNMP_GETMNTENT_TWO_ARGS 
 #endif
 
     /*
      * Handle naming differences between getmntent() APIs
      */
 #ifdef _NETSNMP_GETMNTENT_TWO_ARGS
     /* Two-argument form (Solaris) */
 #define NSFS_MNTENT   struct mnttab
 #define NSFS_PATH     mnt_mountp
 #define NSFS_DEV      mnt_special
 #define NSFS_TYPE     mnt_fstype
 
 #define NSFS_STATFS   statvfs
 #define NSFS_SIZE     f_frsize
 
 #else
     /* One-argument form (everything else?) */
 #define NSFS_MNTENT   struct mntent
 #define NSFS_PATH     mnt_dir
 #define NSFS_DEV      mnt_fsname
 #define NSFS_TYPE     mnt_type
 
 #define NSFS_STATFS   statfs
 #define NSFS_SIZE     f_bsize
 
 #endif
 
 /*
  * File systems to monitor and that are not covered by any hrFSTypes
  * enumeration.
  */
diff --git a/agent/mibgroup/hardware/memory/memory_darwin.c b/agent/mibgroup/hardware/memory/memory_darwin.c
index 226b68931c..ce538a44eb 100644
--- a/agent/mibgroup/hardware/memory/memory_darwin.c
+++ b/agent/mibgroup/hardware/memory/memory_darwin.c
@@ -21,94 +21,94 @@
 /*
  * Get the number of pages that are swapped out.
  * We think this is correct and are valid values
  * but not sure. Time will tell if it's correct.
  * Note: this routine is _expensive_!!! we run this
  * as little as possible by caching it's return so
  * it's not run on every poll.
  * Apple, please give us a better way! :)
  */
 int pages_swapped(void) {
      kern_return_t   error;
      processor_set_t *psets, pset;
      task_t          *tasks;
      unsigned        i, j, pcnt, tcnt;
      int             pid;
      mach_msg_type_number_t  count;
      vm_address_t        address;
      mach_port_t     object_name;
      vm_region_extended_info_data_t info;
      vm_size_t       size;
      mach_port_t mach_port;
      int   swapped_pages;
      int   swapped_pages_total = 0;
      char    errmsg[1024];
 
 
      mach_port = mach_host_self();
      error = host_processor_sets(mach_port, &psets, &pcnt);
      if (error != KERN_SUCCESS) {
         snmp_log(LOG_ERR, "Error in host_processor_sets(): %s\n", mach_error_string(error));
         return(0);
      }
 
      for (i = 0; i < pcnt; i++) {
         error = host_processor_set_priv(mach_port, psets[i], &pset);
         if (error != KERN_SUCCESS) {
             snprintf(errmsg, sizeof(errmsg),"Error in host_processor_set_priv(): %s\n", mach_error_string(error));
             snmp_log_perror(errmsg);
             return(0);
         }
 
         error = processor_set_tasks(pset, &tasks, &tcnt);
         if (error != KERN_SUCCESS) {
             snprintf(errmsg, sizeof(errmsg),"Error in processor_set_tasks(): %s\n", mach_error_string(error));
             snmp_log_perror(errmsg);
             return(0);
         }
 
         for (j = 0; j < tcnt; j++) {
             error = pid_for_task(tasks[j], &pid);
             if (error != KERN_SUCCESS) {
                 /* Not a process, or the process is gone. */
                 continue;
             }
 
             swapped_pages = 0;
             for (address = 0;; address += size) {
                 kern_return_t ret = KERN_FAILURE;
 
                 /* Get memory region. */
                 count = VM_REGION_EXTENDED_INFO_COUNT; 
-#if HAVE_VM_REGION_64
+#ifdef HAVE_VM_REGION_64
                 ret = vm_region_64(tasks[j], &address, &size,
                                  VM_REGION_EXTENDED_INFO, (void *)&info, &count,
                                  &object_name);
-#elif HAVE_VM_REGION
+#elif defined(HAVE_VM_REGION)
                 ret = vm_region(tasks[j], &address, &size,
                               VM_REGION_EXTENDED_INFO, (void *)&info, &count,
                               &object_name);
 #else
 #error How to query memory protection information?
 #endif
                 if (ret != KERN_SUCCESS) {
                     /* No more memory regions. */
                     break;
                 }
             
                 if(info.pages_swapped_out > 0) {
                     swapped_pages += info.pages_swapped_out;
                 } 
             }
            
             if(swapped_pages > 0) {
                 swapped_pages_total += swapped_pages; 
             }
 
             if (tasks[j] != mach_task_self()) {
                 mach_port_deallocate(mach_task_self(), tasks[j]);
             }  
         }
     }
 
     return(swapped_pages_total);
 }
diff --git a/agent/mibgroup/hardware/memory/memory_freebsd.c b/agent/mibgroup/hardware/memory/memory_freebsd.c
index 1e7477f7db..a8d76baf47 100644
--- a/agent/mibgroup/hardware/memory/memory_freebsd.c
+++ b/agent/mibgroup/hardware/memory/memory_freebsd.c
@@ -1,22 +1,22 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/hardware/memory.h>
 #include "../../../kernel.h"
 
 #include <unistd.h>
 #include <sys/param.h>
 #include <sys/fcntl.h>
 #include <sys/sysctl.h>
 #include <sys/vmmeter.h>
 #include <kvm.h>
 
-#if HAVE_SYS_VMPARAM_H
+#ifdef HAVE_SYS_VMPARAM_H
 #include <sys/vmparam.h>
 #else
 #include <vm/vm_param.h>
 #endif
 
 #define SUM_SYMBOL       "cnt"
 #define BUFSPACE_SYMBOL  "bufspace"
diff --git a/agent/mibgroup/hardware/memory/memory_irix.c b/agent/mibgroup/hardware/memory/memory_irix.c
index 377f007025..a396e00379 100644
--- a/agent/mibgroup/hardware/memory/memory_irix.c
+++ b/agent/mibgroup/hardware/memory/memory_irix.c
@@ -1,20 +1,20 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/memory.h>
 
-#if HAVE_SYS_SWAP_H
+#ifdef HAVE_SYS_SWAP_H
 #include <sys/swap.h>
 #endif
 
-#if HAVE_SYS_SYSGET_H
+#ifdef HAVE_SYS_SYSGET_H
 #include <sys/sysget.h>
 #endif
 
-#if HAVE_SYS_SYSMP_H
+#ifdef HAVE_SYS_SYSMP_H
 #include <sys/sysmp.h>
 #endif
 
     /*
      * Load the latest memory usage statistics
      */
diff --git a/agent/mibgroup/hardware/memory/memory_netbsd.c b/agent/mibgroup/hardware/memory/memory_netbsd.c
index 400c073026..f045ccb0f6 100644
--- a/agent/mibgroup/hardware/memory/memory_netbsd.c
+++ b/agent/mibgroup/hardware/memory/memory_netbsd.c
@@ -1,24 +1,24 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/memory.h>
 
 #include <unistd.h>
 #include <errno.h>
 #include <sys/sysctl.h>
-#if HAVE_SYS_VMMETER_H
+#ifdef HAVE_SYS_VMMETER_H
 #include <sys/vmmeter.h>
 #endif
 #include <sys/swap.h>
 
 #if defined(HAVE_UVM_UVM_PARAM_H) && defined(HAVE_UVM_UVM_EXTERN_H)
 #include <uvm/uvm_param.h>
 #include <uvm/uvm_extern.h>
 #elif defined(HAVE_VM_VM_PARAM_H) && defined(HAVE_VM_VM_EXTERN_H)
 #include <vm/vm_param.h>
 #include <vm/vm_extern.h>
 #else
 #error memory_netbsd1.c: Is this really a NetBSD system?
 #endif
 
 #ifdef SWAP_NSWAP
diff --git a/agent/mibgroup/header_complex.c b/agent/mibgroup/header_complex.c
index 95e7101925..fd848bb92d 100644
--- a/agent/mibgroup/header_complex.c
+++ b/agent/mibgroup/header_complex.c
@@ -1,21 +1,21 @@
 /*
  * header complex:  More complex storage and data sorting for mib modules 
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "header_complex.h"
 
 #include <net-snmp/net-snmp-features.h>
diff --git a/agent/mibgroup/host/data_access/hr_disk_bsd.c b/agent/mibgroup/host/data_access/hr_disk_bsd.c
index edc31bddfc..ff3bfd367e 100644
--- a/agent/mibgroup/host/data_access/hr_disk_bsd.c
+++ b/agent/mibgroup/host/data_access/hr_disk_bsd.c
@@ -1,14 +1,14 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/snmp_agent.h>
 #include <net-snmp/agent/snmp_vars.h>
 #define DKTYPENAMES
 #include <sys/disklabel.h>
 #include <sys/disk.h>
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
-#if HAVE_SYS_DKIO_H
+#ifdef HAVE_SYS_DKIO_H
 #include <sys/dkio.h>
 #endif
 #include "../hr_disk.h"
diff --git a/agent/mibgroup/host/data_access/hr_disk_linux.c b/agent/mibgroup/host/data_access/hr_disk_linux.c
index f49ce4cb9b..919962a737 100644
--- a/agent/mibgroup/host/data_access/hr_disk_linux.c
+++ b/agent/mibgroup/host/data_access/hr_disk_linux.c
@@ -1,18 +1,18 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/snmp_agent.h>
 #include <net-snmp/agent/snmp_vars.h>
 #include "../hr_disk.h"
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 #if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)
 #include <regex.h>
 #endif
 #include <linux/fs.h>
 #include <linux/hdreg.h>
 #include <sys/ioctl.h>
 
 #define MAX_NUMBER_DISK_TYPES 16
 
 #if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)
diff --git a/agent/mibgroup/host/data_access/hr_disk_solaris.c b/agent/mibgroup/host/data_access/hr_disk_solaris.c
index 437f065a11..79c788516c 100644
--- a/agent/mibgroup/host/data_access/hr_disk_solaris.c
+++ b/agent/mibgroup/host/data_access/hr_disk_solaris.c
@@ -1,9 +1,9 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/snmp_agent.h>
 #include <net-snmp/agent/snmp_vars.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/dkio.h>
 #include "../hr_disk.h"
diff --git a/agent/mibgroup/host/data_access/swinst_rpm.c b/agent/mibgroup/host/data_access/swinst_rpm.c
index dd0e487895..050edff307 100644
--- a/agent/mibgroup/host/data_access/swinst_rpm.c
+++ b/agent/mibgroup/host/data_access/swinst_rpm.c
@@ -97,104 +97,104 @@ int
 netsnmp_swinst_arch_load( netsnmp_container *container, u_int flags)
 {
     rpmts                 ts;
 
     rpmdbMatchIterator    mi;
     Header                h;
-#if HAVE_HEADERGET
+#ifdef HAVE_HEADERGET
     const char           *g;
     rpmtd                 td_name, td_version, td_release, td_group, td_time;
 #else
     char                 *n, *v, *r, *g;
     int32_t              *t;
 #endif
     time_t                install_time;
     size_t                date_len;
     int                   i = 1;
     netsnmp_swinst_entry *entry;
 
-#if HAVE_HEADERGET
+#ifdef HAVE_HEADERGET
     td_name = rpmtdNew();
     td_version = rpmtdNew();
     td_release = rpmtdNew();
     td_group = rpmtdNew();
     td_time = rpmtdNew();
 #endif
     ts = rpmtsCreate();
     rpmtsSetVSFlags( ts, (_RPMVSF_NOSIGNATURES|_RPMVSF_NODIGESTS));
 
     mi = rpmtsInitIterator( ts, RPMDBI_PACKAGES, NULL, 0);
     if (mi == NULL)
 	NETSNMP_LOGONCE((LOG_ERR, "rpmdbOpen() failed\n"));
 
     while (NULL != (h = rpmdbNextIterator( mi )))
     {
         const u_char *dt;
 
         entry = netsnmp_swinst_entry_create( i++ );
         if (NULL == entry)
             continue;   /* error already logged by function */
         CONTAINER_INSERT(container, entry);
 
         h = headerLink( h );
-#if HAVE_HEADERGET
+#ifdef HAVE_HEADERGET
         headerGet(h, RPMTAG_NAME, td_name, HEADERGET_EXT);
         headerGet(h, RPMTAG_VERSION, td_version, HEADERGET_EXT);
         headerGet(h, RPMTAG_RELEASE, td_release, HEADERGET_EXT);
         headerGet(h, RPMTAG_GROUP, td_group, HEADERGET_EXT);
         headerGet(h, RPMTAG_INSTALLTIME, td_time, HEADERGET_EXT);
         entry->swName_len = snprintf( entry->swName, sizeof(entry->swName),
                                       "%s-%s-%s", rpmtdGetString(td_name),
                                       rpmtdGetString(td_version),
                                       rpmtdGetString(td_release));
         install_time = rpmtdGetNumber(td_time);
         g = rpmtdGetString(td_group);
 #else
         headerGetEntry( h, RPMTAG_NAME,        NULL, (void**)&n, NULL);
         headerGetEntry( h, RPMTAG_VERSION,     NULL, (void**)&v, NULL);
         headerGetEntry( h, RPMTAG_RELEASE,     NULL, (void**)&r, NULL);
         headerGetEntry( h, RPMTAG_GROUP,       NULL, (void**)&g, NULL);
         headerGetEntry( h, RPMTAG_INSTALLTIME, NULL, (void**)&t, NULL);
         entry->swName_len = snprintf( entry->swName, sizeof(entry->swName),
                                       "%s-%s-%s", n, v, r);
         install_time = *t;
 #endif
         entry->swType = (g && NULL != strstr( g, "System Environment"))
                         ? 2      /* operatingSystem */
                         : 4;     /*  application    */
         if (entry->swName_len > sizeof(entry->swName))
             entry->swName_len = sizeof(entry->swName);
 
         dt = date_n_time( &install_time, &date_len );
         if (date_len != 8 && date_len != 11) {
             snmp_log(LOG_ERR, "Bogus length from date_n_time for %s", entry->swName);
             entry->swDate_len = 0;
         }
         else {
             entry->swDate_len = date_len;
             memcpy(entry->swDate, dt, entry->swDate_len);
         }
 
-#if HAVE_HEADERGET
+#ifdef HAVE_HEADERGET
         rpmtdFreeData(td_name);
         rpmtdFreeData(td_version);
         rpmtdFreeData(td_release);
         rpmtdFreeData(td_group);
         rpmtdFreeData(td_time);
 #endif
         headerFree( h );
     }
     rpmdbFreeIterator( mi );
     rpmtsFree( ts );
-#if HAVE_HEADERGET
+#ifdef HAVE_HEADERGET
     rpmtdFree(td_name);
     rpmtdFree(td_version);
     rpmtdFree(td_release);
     rpmtdFree(td_group);
     rpmtdFree(td_time);
 #endif
 
     DEBUGMSGTL(("swinst:load:arch", "loaded %d entries\n",
                 (int)CONTAINER_SIZE(container)));
 
     return 0;
 }
diff --git a/agent/mibgroup/host/data_access/swrun_kinfo.c b/agent/mibgroup/host/data_access/swrun_kinfo.c
index 4061ebcba8..54d9727c23 100644
--- a/agent/mibgroup/host/data_access/swrun_kinfo.c
+++ b/agent/mibgroup/host/data_access/swrun_kinfo.c
@@ -175,203 +175,203 @@ int
 netsnmp_arch_swrun_container_load( netsnmp_container *container, u_int flags)
 {
     struct SWRUN_TABLE  *proc_table;
     int                  nprocs, i, rc;
     char                 buf[BUFSIZ+1], **argv;
     netsnmp_swrun_entry *entry;
 
     if ( 0 == kd ) {
         DEBUGMSGTL(("swrun:load:arch"," Can't query kvm info\n"));
         return 1;     /* No handle for retrieving process table */
     }
 #if defined(openbsd5)
     proc_table = kvm_getprocs(kd, KERN_PROC_KTHREAD, 0, sizeof(struct kinfo_proc), &nprocs );
 #elif defined(HAVE_KVM_GETPROC2)
     proc_table = kvm_getproc2(kd, KERN_PROC_ALL, 0, sizeof(struct kinfo_proc2), &nprocs );
 #elif defined(KERN_PROC_PROC)
     proc_table = kvm_getprocs(kd, KERN_PROC_PROC, 0, &nprocs);
 #else
     proc_table = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nprocs);
 #endif
     for ( i=0 ; i<nprocs; i++ ) {
         if ( 0 == proc_table[i].SWRUN_K_STAT )
             continue;
         if ( -1 == proc_table[i].SWRUN_K_PID )
             continue;
 #ifdef SWRUN_K_TID
 	if ( 0 == proc_table[i].SWRUN_K_PPID )
 	    proc_table[i].SWRUN_K_PID = proc_table[i].SWRUN_K_TID;
 #endif
         entry = netsnmp_swrun_entry_create(proc_table[i].SWRUN_K_PID);
         if (NULL == entry)
             continue;   /* error already logged by function */
         rc = CONTAINER_INSERT(container, entry);
         if (rc < 0) {
             netsnmp_swrun_entry_free(entry);
             continue;
         }
 
         /*
          * There are two possible sources for the command being run:
          *   - SWRUN_K_COMM  (from the proc_table entry directly)
          *   - running kvm_getargv on the process entry.
          *
          * We'll use argv[0] (if set) for hrSWRunPath,
          *   since that might potentially contain the
          *   absolute path to the running binary.
          * We'll use SWRUN_K_COMM for hrSWRunName,
          *   and as an alternative for hrSWRunPath
          */
-#if HAVE_KVM_GETPROC2
+#ifdef HAVE_KVM_GETPROC2
         argv = kvm_getargv2( kd, &(proc_table[i]), 0);
 #else
         argv = kvm_getargv(  kd, &(proc_table[i]), BUFSIZ);
 #endif
 
         entry->hrSWRunName_len = sprintf(entry->hrSWRunName, "%.*s",
                                          (int)sizeof(entry->hrSWRunName) - 1,
                                          proc_table[i].SWRUN_K_COMM);
 
         if (argv && *argv) {
             entry->hrSWRunPath_len = sprintf(entry->hrSWRunPath, "%.*s",
                                              (int)sizeof(entry->hrSWRunPath)-1,
                                              argv[0]);
         } else {
             memcpy( entry->hrSWRunPath, entry->hrSWRunName,
                                         entry->hrSWRunName_len );
             entry->hrSWRunPath_len = entry->hrSWRunName_len;
         }
 
         /*
          * Stitch together the rest of argv[] to build hrSWRunParameters
          *
          * Note:
          *   We add a separating space before each argv[] parameter,
          *   *including* the first one.  So we need to skip this
          *   leading space (buf[0]) when setting hrSWRunParameters.
          * This is also why we cleared the first *two* characters
          *   in the buffer initially. If there were no command-line
          *   arguments, then buf[1] would still be a null string.
          */
         buf[0] = '\0';
         buf[1] = '\0';
         if (argv)
             argv++;    /* Skip argv[0] */
         while ( argv && *argv ) {
             strlcat(buf, " ", sizeof(buf));
             strlcat(buf, *argv, sizeof(buf));
             argv++;
         }
         if (strlen(buf) >= BUFSIZ-10)
             snmp_log(LOG_ERR, "params %lu/%d %s\n", strlen(buf), BUFSIZ, buf);
         entry->hrSWRunParameters_len =
             sprintf(entry->hrSWRunParameters, "%.*s",
                     (int)sizeof(entry->hrSWRunParameters) - 1, buf+1);
 
         entry->hrSWRunType = (P_SYSTEM & proc_table[i].SWRUN_K_FLAG) 
 #ifdef SWRUN_K_CLASS
                              ? ((PRI_ITHD == proc_table[i].SWRUN_K_CLASS)
                                 ? 3  /* device driver    */
                                 : 2  /* operating system */
                                )
                              : 4  /*  application     */
 #else
                              ? 2  /* operating system */
                              : 4  /*  application     */
 #endif
                              ;
 
 #ifdef netbsd5
         switch (proc_table[i].SWRUN_K_STAT) {
 	case LSONPROC:
         case LSRUN:   entry->hrSWRunStatus = HRSWRUNSTATUS_RUNNING;
                       break;
         case LSSLEEP: entry->hrSWRunStatus = HRSWRUNSTATUS_RUNNABLE;
                       break;
         case LSIDL:
 	case LSSUSPENDED:
         case LSSTOP:  entry->hrSWRunStatus = HRSWRUNSTATUS_NOTRUNNABLE;
                       break;
 #ifdef LSDEAD
 	case LSDEAD:
 #endif
         case LSZOMB:  entry->hrSWRunStatus = HRSWRUNSTATUS_INVALID;
 		      break;
         default:   
 		      entry->hrSWRunStatus = HRSWRUNSTATUS_INVALID;
 		      snmp_log(LOG_ERR, "Bad process status %c (0x%x)\n", proc_table[i].SWRUN_K_STAT, proc_table[i].SWRUN_K_STAT);
                       break;
         }
 #else
         switch (proc_table[i].SWRUN_K_STAT & 0xFF) {
         case SONPROC:
         case SRUN:    entry->hrSWRunStatus = HRSWRUNSTATUS_RUNNING;
                       break;
         case SSLEEP:
 	case SACTIVE:
         case SWAIT:   entry->hrSWRunStatus = HRSWRUNSTATUS_RUNNABLE;
                       break;
         case SIDL:
         case SSTOP:
         case SLOCK:   entry->hrSWRunStatus = HRSWRUNSTATUS_NOTRUNNABLE;
                       break;
 
         case SDEAD:
         case SZOMB:   entry->hrSWRunStatus = HRSWRUNSTATUS_INVALID;   /* i.e. "not loaded" */
                       break;
 
         default:      entry->hrSWRunStatus = HRSWRUNSTATUS_INVALID;   /* Actually invalid  */
 		      snmp_log(LOG_ERR, "Bad process status %c (0x%x)\n", proc_table[i].SWRUN_K_STAT, proc_table[i].SWRUN_K_STAT);
                       break;
         }
 #endif
         
 #if defined(freebsd5) && __FreeBSD_version >= 500014
          entry->hrSWRunPerfCPU  = (proc_table[i].ki_rusage.ru_utime.tv_sec*1000000 + proc_table[i].ki_rusage.ru_utime.tv_usec) / 10000;
 	 entry->hrSWRunPerfCPU += (proc_table[i].ki_rusage.ru_stime.tv_sec*1000000 + proc_table[i].ki_rusage.ru_stime.tv_usec) / 10000;
 	 entry->hrSWRunPerfCPU += (proc_table[i].ki_rusage_ch.ru_utime.tv_sec*1000000 + proc_table[i].ki_rusage_ch.ru_utime.tv_usec) / 10000;
 	 entry->hrSWRunPerfCPU += (proc_table[i].ki_rusage_ch.ru_stime.tv_sec*1000000 + proc_table[i].ki_rusage_ch.ru_stime.tv_usec) / 10000;
 	 entry->hrSWRunPerfMem  = proc_table[i].ki_rssize * (getpagesize()/1024);  /* in kB */
 #elif defined(HAVE_KVM_GETPROC2) || defined(openbsd5)
         /*
          * newer NetBSD, OpenBSD
          */
 	entry->hrSWRunPerfCPU = proc_table[i].p_rtime_sec*100;
 	entry->hrSWRunPerfCPU += proc_table[i].p_rtime_usec / 10000;
 
         entry->hrSWRunPerfMem  = proc_table[i].p_vm_rssize;
         entry->hrSWRunPerfMem *= (getpagesize() / 1024);
 #elif defined(dragonfly) && __DragonFly_version >= 190000
 	entry->hrSWRunPerfCPU  = proc_table[i].kp_lwp.kl_uticks;
 	entry->hrSWRunPerfCPU += proc_table[i].kp_lwp.kl_sticks;
 	entry->hrSWRunPerfCPU += proc_table[i].kp_lwp.kl_iticks;
 	entry->hrSWRunPerfCPU = entry->hrSWRunPerfCPU / 10000;
 
 	entry->hrSWRunPerfMem  = proc_table[i].kp_vm_map_size / 1024;
 #elif defined(dragonfly)
 	entry->hrSWRunPerfCPU  = proc_table[i].kp_eproc.e_uticks;
 	entry->hrSWRunPerfCPU += proc_table[i].kp_eproc.e_sticks;
 	entry->hrSWRunPerfCPU += proc_table[i].kp_eproc.e_iticks;
 
 	entry->hrSWRunPerfMem  = proc_table[i].kp_vm_map_size / 1024;
 
 #else
         /*
          * early FreeBSD, NetBSD, OpenBSD
          */
         entry->hrSWRunPerfCPU  = proc_table[i].kp_proc.p_uticks;
         entry->hrSWRunPerfCPU += proc_table[i].kp_proc.p_sticks;
         entry->hrSWRunPerfCPU += proc_table[i].kp_proc.p_iticks;
         entry->hrSWRunPerfMem  = proc_table[i].kp_eproc.e_vm.vm_rssize;
         entry->hrSWRunPerfMem *= (getpagesize() / 1024);
 #endif
     }
     /*
      * 'proc_table' is owned by the kvm library,
      *   so shouldn't be freed here.
      */
 
     DEBUGMSGTL(("swrun:load:arch","loaded %d entries\n",
                 (int)CONTAINER_SIZE(container)));
 
     return 0;
 }
diff --git a/agent/mibgroup/host/hr_device.c b/agent/mibgroup/host/hr_device.c
index 4a55e8e2b7..b8eccf9b18 100644
--- a/agent/mibgroup/host/hr_device.c
+++ b/agent/mibgroup/host/hr_device.c
@@ -1,31 +1,31 @@
 /*
  *  Host Resources MIB - Device group implementation - hr_device.c
  *
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include "host_res.h"
 #include "hr_device.h"
 
         /*********************
 	 *
 	 *  Kernel & interface information,
 	 *   and internal forward declarations
 	 *
 	 *********************/
@@ -234,76 +234,76 @@ var_hrdevice(struct variable *vp,
 really_try_next:
     dev_idx =
         header_hrdevice(vp, name, length, exact, var_len, write_method);
     if (dev_idx == MATCH_FAILED)
         return NULL;
 
     type = (dev_idx >> HRDEV_TYPE_SHIFT);
 
     switch (vp->magic) {
     case HRDEV_INDEX:
         long_return = dev_idx;
         return (u_char *) & long_return;
     case HRDEV_TYPE:
         device_type_id[device_type_len - 1] = type;
         *var_len = sizeof(device_type_id);
         return (u_char *) device_type_id;
     case HRDEV_DESCR:
         if ((device_descr[type] != NULL) &&
             (NULL!=(tmp_str=((*device_descr[type])(dev_idx))))) {
             strlcpy(string, tmp_str, sizeof(string));
         } else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
             goto try_next;
 #else
             sprintf(string, "a black box of some sort");
 #endif
         *var_len = strlen(string);
         return (u_char *) string;
     case HRDEV_ID:
         if (device_prodid[type] != NULL)
             oid_p = ((*device_prodid[type]) (dev_idx, var_len));
         else {
             oid_p = nullOid;
             *var_len = nullOidLen;
         }
         return NETSNMP_REMOVE_CONST(void *, oid_p);
     case HRDEV_STATUS:
         if (device_status[type] != NULL)
             long_return = ((*device_status[type]) (dev_idx));
         else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
             goto try_next;
 #else
             long_return = 2;    /* Assume running */
 #endif
         if ( !long_return )
             goto try_next;
         return (u_char *) & long_return;
     case HRDEV_ERRORS:
         if (device_errors[type] != NULL)
             long_return = (*device_errors[type]) (dev_idx);
         else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
             goto try_next;
 #else
             long_return = 0;    /* Assume OK */
 #endif
         return (u_char *) & long_return;
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_hrdevice\n",
                     vp->magic));
     }
 
   try_next:
     if (!exact)
         goto really_try_next;
 
     return NULL;
 }
 
 
         /*********************
 	 *
 	 *  Internal implementation functions
 	 *
 	 *********************/
diff --git a/agent/mibgroup/host/hr_network.c b/agent/mibgroup/host/hr_network.c
index cd3c56ec1e..fb574c2506 100644
--- a/agent/mibgroup/host/hr_network.c
+++ b/agent/mibgroup/host/hr_network.c
@@ -1,26 +1,26 @@
 /*
  *  Host Resources MIB - network device group implementation - hr_network.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/interface.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #ifdef hpux11
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
 #endif
 
 #include "host_res.h"
 #include "mibII/interfaces.h"
 #include "hr_network.h"
 
 #if !defined( solaris2 )
diff --git a/agent/mibgroup/host/hr_other.c b/agent/mibgroup/host/hr_other.c
index 9e4b16a267..265ccdd3df 100644
--- a/agent/mibgroup/host/hr_other.c
+++ b/agent/mibgroup/host/hr_other.c
@@ -1,14 +1,14 @@
 /*
  *  Host Resources MIB - other device implementation - hr_other.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include "host_res.h"
 #include "hr_other.h"
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
diff --git a/agent/mibgroup/host/hr_partition.c b/agent/mibgroup/host/hr_partition.c
index 83b34ac6d3..21dca4a7d2 100644
--- a/agent/mibgroup/host/hr_partition.c
+++ b/agent/mibgroup/host/hr_partition.c
@@ -1,42 +1,42 @@
 /*
  *  Host Resources MIB - partition device group implementation - hr_partition.c
  *
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <fcntl.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <errno.h>
 
 #include "host_res.h"
 #include "hr_partition.h"
 #include "hrh_filesys.h"
 #include "hr_disk.h"
 
 #include <sys/stat.h>
 
 #define HRP_MONOTONICALLY_INCREASING
 
         /*********************
 	 *
 	 *  Kernel & interface information,
 	 *   and internal forward declarations
 	 *
 	 *********************/
diff --git a/agent/mibgroup/host/hr_print.c b/agent/mibgroup/host/hr_print.c
index fc096bce05..553bcfb1ba 100644
--- a/agent/mibgroup/host/hr_print.c
+++ b/agent/mibgroup/host/hr_print.c
@@ -161,37 +161,37 @@ u_char         *
 var_hrprint(struct variable * vp,
             oid * name,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
     int             print_idx;
 
     print_idx =
         header_hrprint(vp, name, length, exact, var_len, write_method);
     if (print_idx == MATCH_FAILED)
         return NULL;
 
 
     switch (vp->magic) {
     case HRPRINT_STATUS:
         long_return = printer_detail_status(print_idx);
         return (u_char *) & long_return;
     case HRPRINT_ERROR:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #else
         long_return = 0;        /* Null string */
         return (u_char *) & long_return;
 #endif
     default:
         DEBUGMSGTL(("host/hr_print", "unknown sub-id %d in var_hrprint\n",
                     vp->magic));
     }
     return NULL;
 }
 
 
         /*********************
 	 *
 	 *  Internal implementation functions
 	 *
 	 *********************/
diff --git a/agent/mibgroup/host/hr_proc.c b/agent/mibgroup/host/hr_proc.c
index d5c130504f..119b748c33 100644
--- a/agent/mibgroup/host/hr_proc.c
+++ b/agent/mibgroup/host/hr_proc.c
@@ -1,33 +1,33 @@
 /*
  *  Host Resources MIB - proc processor group implementation - hr_proc.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 
 #include "host_res.h"
 #include "hr_proc.h"
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/agent_read_config.h>
 #include <net-snmp/agent/hardware/cpu.h>
 #include "ucd-snmp/loadave.h"
 
 #define HRPROC_MONOTONICALLY_INCREASING
 
         /*********************
 	 *
 	 *  Kernel & interface information,
 	 *   and internal forward declarations
 	 *
 	 *********************/
diff --git a/agent/mibgroup/host/hr_system.c b/agent/mibgroup/host/hr_system.c
index 7ca5468ffe..d140be0aae 100644
--- a/agent/mibgroup/host/hr_system.c
+++ b/agent/mibgroup/host/hr_system.c
@@ -1,80 +1,80 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  *  Host Resources MIB - system group implementation - hr_system.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/swrun.h>
 
 #include "host.h"
 #include "host_res.h"
 #include "hr_system.h"
 #include <net-snmp/agent/auto_nlist.h>
 
 #ifdef HAVE_SYS_PROC_H
 #include <sys/param.h>
 #include "sys/proc.h"
 #endif
 #ifndef mingw32
-#if HAVE_UTMPX_H
+#ifdef HAVE_UTMPX_H
 #include <utmpx.h>
 #else
 #include <utmp.h>
 #endif
 #endif /* mingw32 */
 #include <signal.h>
 #include <errno.h>
 
 #ifdef HAVE_LM_H
 #include <lm.h>
 #endif
 
 #ifdef linux
 #ifdef HAVE_LINUX_TASKS_H
 #include <linux/tasks.h>
 #else
 /*
  * If this file doesn't exist, then there is no hard limit on the number
  * of processes, so return 0 for hrSystemMaxProcesses.  
  */
 #define NR_TASKS	0
 #endif
 #endif
 
 #if defined(hpux10) || defined(hpux11)
 #include <sys/pstat.h>
 #endif
 
 #if defined(solaris2)
 #include <kstat.h>
 #include <sys/var.h>
 #include <time.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/openpromio.h>
 #endif
 
 #ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
@@ -115,7 +115,7 @@ static long     get_max_solaris_processes(void);
 static int      get_load_dev(void);
 static int      count_users(void);
 extern int      count_processes(void);
-#if USING_HOST_DATA_ACCESS_SWRUN_MODULE
+#ifdef USING_HOST_DATA_ACCESS_SWRUN_MODULE
 static int      count_kthreads = 1;
 
 static void parse_count_kthreads(const char *token, const char *line)
@@ -200,25 +200,25 @@ void
 init_hr_system(void)
 {
 #ifdef NPROC_SYMBOL
     auto_nlist(NPROC_SYMBOL, 0, 0);
 #endif
-#if USING_HOST_DATA_ACCESS_SWRUN_MODULE
+#ifdef USING_HOST_DATA_ACCESS_SWRUN_MODULE
     snmpd_register_const_config_handler("count_kthreads",
                                         parse_count_kthreads, NULL,
 					"0|1    0 to exclude kernel threads from hrSystemProcesses.0");
 #endif
 
     REGISTER_MIB("host/hr_system", hrsystem_variables, variable2,
                  hrsystem_variables_oid);
 } /* end init_hr_system */
 
 /*
  * header_hrsys(...
  * Arguments:
  * vp     IN      - pointer to variable entry that points here
  * name    IN/OUT  - IN/name requested, OUT/name found
  * length  IN/OUT  - length of IN/OUT oid's 
  * exact   IN      - TRUE if an exact match was requested
  * var_len OUT     - length of variable or 0 if function returned
  * write_method
  */
@@ -262,132 +262,132 @@ u_char         *
 var_hrsys(struct variable * vp,
           oid * name,
           size_t * length,
           int exact, size_t * var_len, WriteMethod ** write_method)
 {
     static char     string[129]; /* per MIB, max size is 128 */
 #if defined(solaris2)
     /* max size of nvram property */
     char bootparam[8192];
 #endif
     time_t          now;
 #ifdef linux
     FILE           *fp;
 #endif
 #if defined(NETSNMP_CAN_USE_SYSCTL) && defined(CTL_KERN) && defined(KERN_MAXPROC)
     static int      maxproc_mib[] = { CTL_KERN, KERN_MAXPROC };
     size_t          buf_size;
 #endif
 #if defined(hpux10) || defined(hpux11)
     struct pst_static pst_buf;
 #endif
 
     if (header_hrsys(vp, name, length, exact, var_len, write_method) ==
         MATCH_FAILED)
         return NULL;
 
     switch (vp->magic) {
     case HRSYS_UPTIME:
         long_return = get_uptime();
         return (u_char *) & long_return;
     case HRSYS_DATE:
 #if defined(HAVE_MKTIME) && defined(HAVE_STIME)
 #ifndef NETSNMP_NO_WRITE_SUPPORT 
         *write_method=ns_set_time;
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
 #endif
         time(&now);
         return (u_char *) date_n_time(&now, var_len);
     case HRSYS_LOAD_DEV:
         long_return = get_load_dev();
         return (u_char *) & long_return;
     case HRSYS_LOAD_PARAM:
 #ifdef linux
         if((fp = fopen("/proc/cmdline", "r")) != NULL) {
             NETSNMP_IGNORE_RESULT(fgets(string, sizeof(string), fp));
             fclose(fp);
         } else {
             return NULL;
         }
 #elif defined(solaris2)
 #ifndef NETSNMP_NO_WRITE_SUPPORT
         *write_method=set_solaris_bootcommand_parameter;
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
         if ( get_solaris_eeprom_parameter("boot-command",bootparam) ) {
             snmp_log(LOG_ERR,"unable to lookup boot-command from eeprom\n");
             return NULL;
         }
         strlcpy(string,bootparam,sizeof(string));
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         sprintf(string, "ask Dave");    /* XXX */
 #endif
         *var_len = strlen(string);
         return (u_char *) string;
     case HRSYS_USERS:
         long_return = count_users();
         return (u_char *) & long_return;
     case HRSYS_PROCS:
-#if USING_HOST_DATA_ACCESS_SWRUN_MODULE
+#ifdef USING_HOST_DATA_ACCESS_SWRUN_MODULE
         long_return = swrun_count_processes(count_kthreads);
-#elif USING_HOST_HR_SWRUN_MODULE
+#elif defined(USING_HOST_HR_SWRUN_MODULE)
         long_return = count_processes();
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;
 #endif
         return (u_char *) & long_return;
     case HRSYS_MAXPROCS:
 #if defined(NR_TASKS)
         long_return = NR_TASKS; /* <linux/tasks.h> */
 #elif defined(NETSNMP_CAN_USE_SYSCTL) && defined(CTL_KERN) && defined(KERN_MAXPROC)
 	{
 	    int nproc = 0;
 
 	    buf_size = sizeof(nproc);
 	    if (sysctl(maxproc_mib, 2, &nproc, &buf_size, NULL, 0) < 0)
 		return NULL;
 	    long_return = nproc;
 	}
 #elif defined(hpux10) || defined(hpux11)
         pstat_getstatic(&pst_buf, sizeof(struct pst_static), 1, 0);
         long_return = pst_buf.max_proc;
 #elif defined(solaris2)
         long_return = get_max_solaris_processes();
         if (long_return == -1)
             return NULL;
 #elif defined(NPROC_SYMBOL)
 	{
 	    int nproc = 0;
 
 	    auto_nlist(NPROC_SYMBOL, (char *) &nproc, sizeof(nproc));
 	    long_return = nproc;
 	}
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;
 #endif
         return (u_char *) & long_return;
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_hrsys\n",
                     vp->magic));
     }
     return NULL;
 } /* end var_hrsys */
 
 
         /*********************
 	 *
 	 *  Internal implementation functions
 	 *
 	 *********************/
 
 
 #if defined(solaris2)
 
 /* functions for malloc and freeing openpromio structure */
@@ -675,51 +675,51 @@ static int
 count_users(void)
 {
     int             total = 0;
 #ifndef WIN32
-#if HAVE_UTMPX_H
+#ifdef HAVE_UTMPX_H
 #define setutent setutxent
 #define pututline pututxline
 #define getutent getutxent
 #define endutent endutxent
     struct utmpx   *utmp_p;
 #else
     struct utmp    *utmp_p;
 #endif
 
     setutent();
     while ((utmp_p = getutent()) != NULL) {
 #ifndef UTMP_HAS_NO_TYPE
         if (utmp_p->ut_type != USER_PROCESS)
             continue;
 #endif
 #ifndef UTMP_HAS_NO_PID
             /* This block of code skips zombie user PIDs in the
                utmp/utmpx file that would otherwise be counted as a
                current user, but leaves updating the actual
                utmp/utmpx file to the system. */
             if (kill(utmp_p->ut_pid, 0) == -1 && errno == ESRCH) {
                 continue;
             }
 #endif
             ++total;
     }
     endutent();
 #else /* WIN32 */
    /* 
     * TODO - Error checking.
     */
 	LPWKSTA_INFO_102 wkinfo;
 	NET_API_STATUS nstatus;
 	
 	nstatus = NetWkstaGetInfo(NULL, 102, (LPBYTE*)&wkinfo);
 	if (nstatus != NERR_Success) {
 		return 0;
 	}
 	total = (int)wkinfo->wki102_logged_on_users;
 
 	NetApiBufferFree(wkinfo);	
 #endif /* WIN32 */
     return total;
 }
 
 #if defined(UTMP_FILE) && !HAVE_UTMPX_H
diff --git a/agent/mibgroup/host/hrh_filesys.c b/agent/mibgroup/host/hrh_filesys.c
index 147544f2dc..fcf9633eb0 100644
--- a/agent/mibgroup/host/hrh_filesys.c
+++ b/agent/mibgroup/host/hrh_filesys.c
@@ -1,62 +1,62 @@
 /*
  *  Host Resources MIB - File System device group implementation (HAL rewrite) - hrh_filesys.c
  *
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/memory.h>
 #include "hardware/fsys/fsys.h"
 #include "host_res.h"
 #include "hrh_filesys.h"
 #include "hrh_storage.h"
 #include "hr_disk.h"
 #include <net-snmp/utilities.h>
 
 #ifdef HAVE_MNTENT_H
 #include <mntent.h>
 #endif
 #ifdef HAVE_SYS_MNTENT_H
 #include <sys/mntent.h>
 #endif
 #ifdef HAVE_SYS_MNTTAB_H
 #include <sys/mnttab.h>
 #endif
 #ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 #ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
 
 #include <ctype.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
 #include <sys/mntctl.h>
 #include <sys/vmount.h>
 #include <sys/statfs.h>
 #endif
diff --git a/agent/mibgroup/host/hrh_storage.c b/agent/mibgroup/host/hrh_storage.c
index d2515efbd1..f1907e57fe 100644
--- a/agent/mibgroup/host/hrh_storage.c
+++ b/agent/mibgroup/host/hrh_storage.c
@@ -1,63 +1,63 @@
 /*
  *  Host Resources MIB - storage group implementation - hrh_storage.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/hardware/memory.h>
 #include "hardware/fsys/fsys.h"
 #include "host_res.h"
 #include "hrh_filesys.h"
 #include "hrh_storage.h"
 #include "hr_disk.h"
 #include <net-snmp/utilities.h>
 
 
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # ifdef WIN32
 #  include <windows.h>
 #  include <errno.h>
 # else
 #  include <sys/time.h>
 # endif
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/output_api.h>
 
 #include <net-snmp/agent/agent_read_config.h>
 #include <net-snmp/library/read_config.h>
 
 #define HRSTORE_MONOTONICALLY_INCREASING
 
         /*********************
 	 *
 	 *  Kernel & interface information,
 	 *   and internal forward declarations
 	 *
 	 *********************/
@@ -355,117 +355,117 @@ var_hrstore(struct variable *vp,
 really_try_next:
     ptr = header_hrstoreEntry(vp, name, length, exact, var_len, write_method,
                               &entry);
     if (ptr == NULL)
         return NULL;
 
     store_idx = name[ HRSTORE_ENTRY_NAME_LENGTH ];
     if (entry &&
         store_idx > NETSNMP_MEM_TYPE_MAX &&
         netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                NETSNMP_DS_AGENT_SKIPNFSINHOSTRESOURCES) &&
         Check_HR_FileSys_NFS(entry))
         return NULL;
     if (entry && Check_HR_FileSys_AutoFs(entry))
         return NULL;
     if (store_idx <= NETSNMP_MEM_TYPE_MAX ) {
         mem = (netsnmp_memory_info*)ptr;
     }
 
 
 
     switch (vp->magic) {
     case HRSTORE_INDEX:
         long_return = store_idx;
         return (u_char *) & long_return;
     case HRSTORE_TYPE:
         if (store_idx > NETSNMP_MEM_TYPE_MAX)
             if (entry->flags & NETSNMP_FS_FLAG_REMOTE && storageUseNFS)
                 storage_type_id[storage_type_len - 1] = 10;     /* Network Disk */
             else if (entry->flags & NETSNMP_FS_FLAG_REMOVE )
                 storage_type_id[storage_type_len - 1] = 5;      /* Removable Disk */
             else
                 storage_type_id[storage_type_len - 1] = 4;      /* Assume fixed */
         else
             switch (store_idx) {
             case NETSNMP_MEM_TYPE_PHYSMEM:
             case NETSNMP_MEM_TYPE_USERMEM:
                 storage_type_id[storage_type_len - 1] = 2;      /* RAM */
                 break;
             case NETSNMP_MEM_TYPE_VIRTMEM:
             case NETSNMP_MEM_TYPE_SWAP:
                 storage_type_id[storage_type_len - 1] = 3;      /* Virtual Mem */
                 break;
             default:
                 storage_type_id[storage_type_len - 1] = 1;      /* Other */
                 break;
             }
         *var_len = sizeof(storage_type_id);
         return (u_char *) storage_type_id;
     case HRSTORE_DESCR:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             strlcpy(string, entry->path, sizeof(string));
             *var_len = strlen(string);
             return (u_char *) string;
         } else {
             if ( !mem || !mem->descr )
                 goto try_next;
             *var_len = strlen(mem->descr);
             return (u_char *) mem->descr;
         }
     case HRSTORE_UNITS:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                        NETSNMP_DS_AGENT_REALSTORAGEUNITS))
                 long_return = entry->units & 0x7fffffff;
             else
                 long_return = entry->units_32;
         } else {
             if ( !mem || mem->units == -1 )
                 goto try_next;
             long_return = mem->units & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_SIZE:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                        NETSNMP_DS_AGENT_REALSTORAGEUNITS))
                 long_return = entry->size & 0x7fffffff;
             else
                 long_return = entry->size_32;
         } else {
             if ( !mem || mem->size == -1 )
                 goto try_next;
             long_return = mem->size & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_USED:
         if (store_idx > NETSNMP_MEM_TYPE_MAX) {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                        NETSNMP_DS_AGENT_REALSTORAGEUNITS))
                 long_return = entry->used & 0x7fffffff;
             else
                 long_return = entry->used_32;
         } else {
             if ( !mem || mem->size == -1 || mem->free == -1 )
                 goto try_next;
             long_return = (mem->size - mem->free) & 0x7fffffff;
         }
         return (u_char *) & long_return;
     case HRSTORE_FAILS:
         if (store_idx > NETSNMP_MEM_TYPE_MAX)
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
 	    goto try_next;
 #else
         long_return = 0;
 #endif
         else {
             if ( !mem || mem->other == -1 )
                 goto try_next;
             long_return = mem->other;
         }
         return (u_char *) & long_return;
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_hrstore\n",
                     vp->magic));
     }
     return NULL;
diff --git a/agent/mibgroup/if-mib/data_access/interface_linux.c b/agent/mibgroup/if-mib/data_access/interface_linux.c
index 5da422bb65..e3f4482d99 100644
--- a/agent/mibgroup/if-mib/data_access/interface_linux.c
+++ b/agent/mibgroup/if-mib/data_access/interface_linux.c
@@ -68,51 +68,51 @@ typedef __u16 u16;         /* ditto */
 typedef __u8 u8;           /* ditto */
 #endif
 #include <linux/ethtool.h>
 #endif /* HAVE_LINUX_ETHTOOL_H */
 
 #include "mibII/mibII_common.h"
 #include "if-mib/ifTable/ifTable_constants.h"
 #include "ip-mib/data_access/ipaddress_ioctl.h"
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #else
 #error "linux should have sys/ioctl header"
 #endif
 
 #include <net-snmp/data_access/interface.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include "if-mib/data_access/interface.h"
 #include "mibgroup/util_funcs.h"
 #include "interface_ioctl.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <errno.h>
 
 #include <linux/sockios.h>
 #include <linux/if_ether.h>
 
 #ifndef IF_NAMESIZE
 #define IF_NAMESIZE 16
 #endif
 
 #ifndef SIOCGMIIPHY
 #define SIOCGMIIPHY 0x8947
 #endif
 
 #ifndef SIOCGMIIREG
 #define SIOCGMIIREG 0x8948
 #endif
 
 #ifdef NETSNMP_ENABLE_IPV6
 #if defined(HAVE_LINUX_RTNETLINK_H)
 #include <linux/rtnetlink.h>
 #ifdef RTMGRP_IPV6_PREFIX
 #define SUPPORT_PREFIX_FLAGS 1
 #endif  /* RTMGRP_IPV6_PREFIX */
 #endif  /* HAVE_LINUX_RTNETLINK_H */
 #endif  /* NETSNMP_ENABLE_IPV6 */
diff --git a/agent/mibgroup/if-mib/data_access/interface_openbsd.c b/agent/mibgroup/if-mib/data_access/interface_openbsd.c
index c1ca83ec39..34e1d8414b 100644
--- a/agent/mibgroup/if-mib/data_access/interface_openbsd.c
+++ b/agent/mibgroup/if-mib/data_access/interface_openbsd.c
@@ -12,23 +12,23 @@
 netsnmp_feature_child_of(interface_arch_set_admin_status, interface_all);
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #else
 #error "linux should have sys/ioctl header"
 #endif
 
 #include <net-snmp/data_access/interface.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include "if-mib/data_access/interface.h"
 #include "interface_private.h"
 
 #include <sys/types.h>
 #include <sys/time.h>
 #include <net/if.h>
 #include <net/if_dl.h>
 #include <net/if_types.h>
 #include <net/if_media.h>
 
 #define starttime (*(const struct timeval*)netsnmp_get_agent_starttime())
diff --git a/agent/mibgroup/if-mib/data_access/interface_sysctl.c b/agent/mibgroup/if-mib/data_access/interface_sysctl.c
index ed7638a6f7..f9591d249e 100644
--- a/agent/mibgroup/if-mib/data_access/interface_sysctl.c
+++ b/agent/mibgroup/if-mib/data_access/interface_sysctl.c
@@ -1,32 +1,32 @@
 /*
  *  Interface MIB architecture support
  *
  *  Based on patch 1362403, submited by Rojer
  *
  * $Id$
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include "mibII/mibII_common.h"
 #include "if-mib/ifTable/ifTable_constants.h"
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #else
 #error "BSD should have sys/ioctl header"
 #endif
 
 #include <net-snmp/data_access/interface.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include "if-mib/data_access/interface.h"
 #include "interface_private.h"
 
 #include <sys/types.h>
 #include <sys/time.h>
 #include <net/if.h>
 #include <net/if_dl.h>
 #include <net/if_types.h>
 #include <net/if_media.h>
diff --git a/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c b/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
index cc525f6aa9..eeeecb9637 100644
--- a/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
+++ b/agent/mibgroup/ip-forward-mib/data_access/route_ioctl.c
@@ -1,88 +1,88 @@
 /*
  * Portions of this file are subject to copyright(s).  See the Net-SNMP's
  * COPYING file for more details and other copyrights that may apply.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_FILE_H
+#ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_SYS_MBUF_H
 #include <sys/mbuf.h>
 #endif
 
 
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
-#if HAVE_NET_ROUTE_H
+#ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <errno.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include <net-snmp/data_access/route.h>
 
 #include "ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.h"
 #include "route_ioctl.h"
 
 #ifdef cygwin
 #include <windows.h>
 #endif
 
 #ifndef HAVE_STRUCT_RTENTRY_RT_DST
 #   define rt_dst rt_nodes->rn_key
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_HASH
 #   define rt_hash rt_pad1
 #endif
 
 
 #ifdef linux
 #   define NETSNMP_ROUTE_WRITE_PROTOCOL PF_ROUTE
 #else
 #   define NETSNMP_ROUTE_WRITE_PROTOCOL 0
 #endif
 
 #ifdef irix6
 #define SIOCADDRT SIOCADDMULTI
 #define SIOCDELRT SIOCDELMULTI
 #endif
 
 #if defined SIOCADDRT && !defined(irix6)
diff --git a/agent/mibgroup/ip-mib/data_access/arp_netlink.c b/agent/mibgroup/ip-mib/data_access/arp_netlink.c
index 09c13f0806..8cab2efbd8 100644
--- a/agent/mibgroup/ip-mib/data_access/arp_netlink.c
+++ b/agent/mibgroup/ip-mib/data_access/arp_netlink.c
@@ -1,19 +1,19 @@
 /*
  *  Interface MIB architecture support
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/arp.h>
 #include <net-snmp/data_access/interface.h>
 
 #include <errno.h>
 #include <stdint.h>
 #include <sys/types.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <linux/types.h>
 #include <linux/rtnetlink.h>
diff --git a/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c b/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
index b9d875f897..12075f0a46 100644
--- a/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
+++ b/agent/mibgroup/ip-mib/data_access/systemstats_sysctl.c
@@ -1,55 +1,55 @@
 /*
  *  ipSystemStatsTable and ipIfStatsTable interface MIB architecture support
  *
  * $Id$
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipstats.h>
 #include <net-snmp/data_access/systemstats.h>
 
 #include "../ipSystemStatsTable/ipSystemStatsTable.h"
 #include "systemstats_private.h"
 
 #include <sys/types.h>
 #include <dirent.h>
 #include <ctype.h>
 
 #include <sys/param.h>
 #include <sys/sysctl.h>
 #include <sys/protosw.h>
 
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
 #ifdef NETSNMP_IFNET_NEEDS_KERNEL_STRUCTURES
 #define _KERNEL_STRUCTURES
 #endif
 #include <net/if.h>
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
 #include <netinet/ip_var.h>
-#if HAVE_NETINET_ICMP6_H
+#ifdef HAVE_NETINET_ICMP6_H
 #include <netinet/icmp6.h>
 #endif
-#if HAVE_NETINET6_IP6_VAR_H
+#ifdef HAVE_NETINET6_IP6_VAR_H
 #include <sys/queue.h>
 #include <netinet6/ip6_var.h>
 #endif
 #if !defined(freebsd7) && !defined(openbsd5)
 #include <netinet6/in6_var.h>
 #endif
 
 #ifdef darwin
 
 /* This struct is in netinet6/ip6_var.h which Apple for obscure reasons
  * do not distribute as part of /usr/include :-(
  */
@@ -561,126 +561,126 @@ static int
 _systemstats_v6_load_systemstats(netsnmp_container* container, u_int load_flags)
 {
     struct ip6stat ip6stat;
     int mib[] = { CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_STATS };
     size_t len = sizeof(ip6stat);
     netsnmp_systemstats_entry *entry = NULL;
 
     if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), &ip6stat, &len, NULL, 0) == -1) {
   	NETSNMP_LOGONCE((LOG_ERR, "Cannot sysctl(CTL_NET, AF_INET6, IPPROTO_IPV6, IPV6CTL_STATS)\n"));
 	return -1;
     }
     
     entry = netsnmp_access_systemstats_entry_create(2, 0,
             "ipSystemStatsTable.ipv6");
     if(NULL == entry)
         return -3;
     
     entry->stats.HCInReceives.low = ip6stat.ip6s_total & 0xffffffff;
     entry->stats.HCInReceives.high = ip6stat.ip6s_total >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINRECEIVES] = 1;
     /*
     entry->stats.HCInOctets.low = scan_val & 0xffffffff;
     entry->stats.HCInOctets.high = scan_val  >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINOCTETS] = 1;
     */
     entry->stats.InHdrErrors = ip6stat.ip6s_badoptions + ip6stat.ip6s_tooshort
                              + ip6stat.ip6s_toosmall + ip6stat.ip6s_badvers
 			     + ip6stat.ip6s_toomanyhdr;
-#if HAVE_STRUCT_IP6STAT_IP6S_EXTHDRTOOLONG
+#ifdef HAVE_STRUCT_IP6STAT_IP6S_EXTHDRTOOLONG
     entry->stats.InHdrErrors += ip6stat.ip6s_exthdrtoolong;
 #endif
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_INHDRERRORS] = 1;
     entry->stats.HCInNoRoutes.low = ip6stat.ip6s_cantforward & 0xffffffff;
     entry->stats.HCInNoRoutes.high = ip6stat.ip6s_cantforward >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINNOROUTES] = 1;
     /*
     entry->stats.inAddrErrors = 0;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_INADDRERRORS] = 1;
     entry->stats.InUnknownProtos = scan_val;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_INUNKNOWNPROTOS] = 1;
     entry->stats.InTruncatedPkts = scan_val  & 0xffffffff;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_INTRUNCATEDPKTS] = 1;
     */
     entry->stats.HCInForwDatagrams.low = ip6stat.ip6s_forward & 0xffffffff;
     entry->stats.HCInForwDatagrams.high = ip6stat.ip6s_forward >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINFORWDATAGRAMS] = 1;
     entry->stats.ReasmReqds = ip6stat.ip6s_fragments;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_REASMREQDS] = 1;
     entry->stats.ReasmOKs = ip6stat.ip6s_reassembled;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_REASMOKS] = 1;
     entry->stats.ReasmFails = ip6stat.ip6s_fragdropped + ip6stat.ip6s_fragtimeout;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_REASMFAILS] = 1;
     entry->stats.InDiscards = ip6stat.ip6s_fragdropped;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_INDISCARDS] = 1;
     entry->stats.HCInDelivers.low = ip6stat.ip6s_delivered  & 0xffffffff;
     entry->stats.HCInDelivers.high = ip6stat.ip6s_delivered >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINDELIVERS] = 1;
     entry->stats.HCOutRequests.low = ip6stat.ip6s_localout & 0xffffffff;
     entry->stats.HCOutRequests.high = ip6stat.ip6s_localout >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTREQUESTS] = 1;
     entry->stats.HCOutNoRoutes.low = ip6stat.ip6s_noroute & 0xffffffff;
     entry->stats.HCOutNoRoutes.high = ip6stat.ip6s_noroute >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTNOROUTES] = 1;
     entry->stats.HCOutForwDatagrams.low = ip6stat.ip6s_forward & 0xffffffff;
     entry->stats.HCOutForwDatagrams.high = ip6stat.ip6s_forward >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFORWDATAGRAMS] = 1;
     entry->stats.HCOutDiscards.low = ip6stat.ip6s_odropped & 0xffffffff;
     entry->stats.HCOutDiscards.high = ip6stat.ip6s_odropped >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTDISCARDS] = 1;
     entry->stats.HCOutFragReqds.low = (ip6stat.ip6s_fragmented + ip6stat.ip6s_cantfrag) & 0xffffffff;
     entry->stats.HCOutFragReqds.high = (ip6stat.ip6s_fragmented + ip6stat.ip6s_cantfrag) >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFRAGREQDS] = 1;
     entry->stats.HCOutFragOKs.low = ip6stat.ip6s_fragmented & 0xffffffff;
     entry->stats.HCOutFragOKs.high = ip6stat.ip6s_fragmented >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFRAGOKS] = 1;
     entry->stats.HCOutFragFails.low = ip6stat.ip6s_cantfrag & 0xffffffff;
     entry->stats.HCOutFragFails.high = ip6stat.ip6s_cantfrag >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFRAGFAILS] = 1;
     entry->stats.HCOutFragCreates.low = ip6stat.ip6s_ofragments & 0xffffffff;
     entry->stats.HCOutFragCreates.high = ip6stat.ip6s_ofragments >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTFRAGCREATES] = 1;
     /*
     entry->stats.HCOutTransmits.low = scan_val & 0xffffffff;
     entry->stats.HCOutTransmits.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTTRANSMITS] = 1;
     entry->stats.HCOutMcastOctets.low = scan_val & 0xffffffff;
     entry->stats.HCOutMcastOctets.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTMCASTOCTETS] = 1;
     entry->stats.HCInMcastPkts.low = scan_val  & 0xffffffff;
     entry->stats.HCInMcastPkts.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINMCASTPKTS] = 1;
     entry->stats.HCInMcastOctets.low = scan_val  & 0xffffffff;
     entry->stats.HCInMcastOctets.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINMCASTOCTETS] = 1;
     entry->stats.HCOutMcastPkts.low = scan_val & 0xffffffff;
     entry->stats.HCOutMcastPkts.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTMCASTPKTS] = 1;
     entry->stats.HCOutOctets.low = scan_val & 0xffffffff;
     entry->stats.HCOutOctets.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTOCTETS] = 1;
     entry->stats.HCInBcastPkts.low = scan_val  & 0xffffffff;
     entry->stats.HCInBcastPkts.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCINBCASTPKTS] = 1;
     entry->stats.HCOutBcastPkts.low = scan_val  & 0xffffffff;
     entry->stats.HCOutBcastPkts.high = scan_val >> 32;
     entry->stats.columnAvail[IPSYSTEMSTATSTABLE_HCOUTBCASTPKTS] = 1;
     */
 
     /*
      * add to container
      */
     if (CONTAINER_INSERT(container, entry) < 0) {
 	DEBUGMSGTL(("access:systemstats:container","error with systemstats_entry: insert into container failed.\n"));
 	netsnmp_access_systemstats_entry_free(entry);
     }
 
     return 1;
 }
 
 #define DEV_SNMP6_DIRNAME   "/proc/net/dev_snmp6"
 #define IFINDEX_LINE        "ifIndex"
 #define DEV_FILENAME_LEN    64
 
 /*
  * load ipIfStatsTable for ipv6 entries
  */
diff --git a/agent/mibgroup/mibII/data_access/at_hpux.c b/agent/mibgroup/mibII/data_access/at_hpux.c
index a820a2e87a..7396bc5687 100644
--- a/agent/mibgroup/mibII/data_access/at_hpux.c
+++ b/agent/mibgroup/mibII/data_access/at_hpux.c
@@ -1,95 +1,95 @@
 /*
  *  Template MIB group implementation - at.c
  *
  */
 
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/interface.h>
 #include "../at.h"
 #include "at_unix.h"
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NET_IF_H
+#ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
-#if HAVE_NET_IF_VAR_H
+#ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 
-#if HAVE_NETINET_IF_ETHER_H
+#ifdef HAVE_NETINET_IF_ETHER_H
 #include <netinet/if_ether.h>
 #endif
-#if HAVE_INET_MIB2_H
+#ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
-#if HAVE_NET_IF_DL_H
+#ifdef HAVE_NET_IF_DL_H
 #ifndef dynix
 #include <net/if_dl.h>
 #else
 #include <sys/net/if_dl.h>
 #endif
 #endif
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
-#if HAVE_NET_ROUTE_H
+#ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef solaris2
 #include "kernel_sunos5.h"
 #endif
 
 #ifdef hpux11
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
 #endif                          /* hpux11 */
diff --git a/agent/mibgroup/mibII/data_access/at_sysctl.c b/agent/mibgroup/mibII/data_access/at_sysctl.c
index 550a0c7dba..578c2889e4 100644
--- a/agent/mibgroup/mibII/data_access/at_sysctl.c
+++ b/agent/mibgroup/mibII/data_access/at_sysctl.c
@@ -1,41 +1,41 @@
 /*
  *  Template MIB group implementation - at.c
  *
  */
 
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/interface.h>
 #include "../at.h"
 #include "at_unix.h"
-#if HAVE_NET_IF_H
+#ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
-#if HAVE_NET_IF_DL_H
+#ifdef HAVE_NET_IF_DL_H
 #include <net/if_dl.h>
 #endif
-#if HAVE_NETINET_IF_ETHER_H
+#ifdef HAVE_NETINET_IF_ETHER_H
 #include <netinet/if_ether.h>
 #endif
-#if HAVE_NET_ROUTE_H
+#ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 
diff --git a/agent/mibgroup/mibII/data_access/at_unix.c b/agent/mibgroup/mibII/data_access/at_unix.c
index fcef1d4906..4f7d1ab01d 100644
--- a/agent/mibgroup/mibII/data_access/at_unix.c
+++ b/agent/mibgroup/mibII/data_access/at_unix.c
@@ -37,125 +37,125 @@ u_char         *
 var_atEntry(struct variable *vp,
             oid * name,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * Address Translation table object identifier is of form:
      * 1.3.6.1.2.1.3.1.1.1.interface.1.A.B.C.D,  where A.B.C.D is IP address.
      * Interface is at offset 10,
      * IPADDR starts at offset 12.
      *
      * IP Net to Media table object identifier is of form:
      * 1.3.6.1.2.1.4.22.1.1.1.interface.A.B.C.D,  where A.B.C.D is IP address.
      * Interface is at offset 10,
      * IPADDR starts at offset 11.
      */
     u_char         *cp;
     oid            *op;
     oid             lowest[16];
     oid             current[16];
     static char     PhysAddr[MAX_MAC_ADDR_LEN], LowPhysAddr[MAX_MAC_ADDR_LEN];
     static int      PhysAddrLen, LowPhysAddrLen;
     in_addr_t       Addr, LowAddr;
     int             foundone;
     static in_addr_t      addr_ret;
     u_short         ifIndex, lowIfIndex = 0;
     u_long          ifType, lowIfType = 0;
 
     int             oid_length;
 
     /*
      * fill in object part of name for current (less sizeof instance part)
      */
     memcpy(current, vp->name, vp->namelen * sizeof(oid));
 
     if (current[6] == 3) {      /* AT group oid */
         oid_length = 16;
     } else {                    /* IP NetToMedia group oid */
         oid_length = 15;
     }
 
     LowAddr = 0;                /* Don't have one yet */
     foundone = 0;
     ARP_Scan_Init();
     for (;;) {
         if (ARP_Scan_Next(&Addr, PhysAddr, &PhysAddrLen, &ifType, &ifIndex) == 0)
             break;
         current[10] = ifIndex;
 
         if (current[6] == 3) {  /* AT group oid */
             current[11] = 1;
             op = current + 12;
         } else {                /* IP NetToMedia group oid */
             op = current + 11;
         }
         cp = (u_char *) & Addr;
         *op++ = *cp++;
         *op++ = *cp++;
         *op++ = *cp++;
         *op++ = *cp++;
 
         if (exact) {
             if (snmp_oid_compare(current, oid_length, name, *length) == 0) {
                 memcpy((char *) lowest, (char *) current,
                        oid_length * sizeof(oid));
                 LowAddr = Addr;
                 foundone = 1;
                 lowIfIndex = ifIndex;
                 memcpy(LowPhysAddr, PhysAddr, sizeof(PhysAddr));
                 LowPhysAddrLen = PhysAddrLen;
                 lowIfType = ifType;
                 break;          /* no need to search further */
             }
         } else {
             if ((snmp_oid_compare(current, oid_length, name, *length) > 0)
                 && ((foundone == 0)
                     ||
                     (snmp_oid_compare
                      (current, oid_length, lowest, oid_length) < 0))) {
                 /*
                  * if new one is greater than input and closer to input than
                  * previous lowest, save this one as the "next" one.
                  */
                 memcpy(lowest, current, oid_length * sizeof(oid));
                 LowAddr = Addr;
                 foundone = 1;
                 lowIfIndex = ifIndex;
                 memcpy(LowPhysAddr, PhysAddr, sizeof(PhysAddr));
                 LowPhysAddrLen = PhysAddrLen;
                 lowIfType = ifType;
             }
         }
     }
     if (foundone == 0)
         return NULL;
 
     memcpy(name, lowest, oid_length * sizeof(oid));
     *length = oid_length;
     *write_method = NULL;
     switch (vp->magic) {
     case IPMEDIAIFINDEX:       /* also ATIFINDEX */
         *var_len = sizeof long_return;
         long_return = lowIfIndex ? lowIfIndex : 1;
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         if (lowIfIndex == 0)
             return NULL;
 #endif
         return (u_char *) & long_return;
     case IPMEDIAPHYSADDRESS:   /* also ATPHYSADDRESS */
         *var_len = LowPhysAddrLen;
         return (u_char *) LowPhysAddr;
     case IPMEDIANETADDRESS:    /* also ATNETADDRESS */
         *var_len = sizeof(addr_ret);
         addr_ret = LowAddr;
         return (u_char *) & addr_ret;
     case IPMEDIATYPE:
         *var_len = sizeof long_return;
         long_return = lowIfType;
         return (u_char *) & long_return;
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_atEntry\n",
                     vp->magic));
     }
     return NULL;
 }
diff --git a/agent/mibgroup/mibII/interfaces.c b/agent/mibgroup/mibII/interfaces.c
index ccb6429a7e..c85a147184 100644
--- a/agent/mibgroup/mibII/interfaces.c
+++ b/agent/mibgroup/mibII/interfaces.c
@@ -25,187 +25,187 @@
 netsnmp_feature_provide(interface_legacy);
 
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL) && !defined(NETSNMP_IFNET_NEEDS_KERNEL_LATE)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #include <sys/types.h>
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL) && defined(NETSNMP_IFNET_NEEDS_KERNEL_LATE)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifndef STREAM_NEEDS_KERNEL_ISLANDS
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #endif
-#if HAVE_SYS_SOCKETVAR_H
+#ifdef HAVE_SYS_SOCKETVAR_H
 #include <sys/socketvar.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_SYS_SOCKIO_H
+#ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
-#if HAVE_SYS_IOCTL_H
+#ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NET_IF_H
+#ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
-#if HAVE_NETINET_IN_VAR_H
+#ifdef HAVE_NETINET_IN_VAR_H
 #include <netinet/in_var.h>
 #endif
-#if HAVE_NET_IF_VAR_H
+#ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 #ifdef STREAM_NEEDS_KERNEL_ISLANDS
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #endif
-#if HAVE_NET_ROUTE_H
+#ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
-#if HAVE_NETINET_IN_SYSTM_H
+#ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
-#if HAVE_SYS_HASHING_H
+#ifdef HAVE_SYS_HASHING_H
 #include <sys/hashing.h>
 #endif
-#if HAVE_NETINET_IN_VAR_H
+#ifdef HAVE_NETINET_IN_VAR_H
 #include <netinet/in_var.h>
 #endif
-#if HAVE_NETINET_IP_H
+#ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
-#if HAVE_NETINET_IP6_H
+#ifdef HAVE_NETINET_IP6_H
 #include <netinet/ip6.h>
 #endif
 #endif
-#if HAVE_SYS_QUEUE_H
+#ifdef HAVE_SYS_QUEUE_H
 #include <sys/queue.h>
 #endif
-#if HAVE_NETINET_IP_VAR_H
+#ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
-#if HAVE_NETNETSNMP_ENABLE_IPV6_IP6_VAR_H
+#ifdef HAVE_NETNETSNMP_ENABLE_IPV6_IP6_VAR_H
 #include <netinet6/ip6_var.h>
 #endif
 #endif
-#if HAVE_NETINET_IN_PCB_H
+#ifdef HAVE_NETINET_IN_PCB_H
 #include <netinet/in_pcb.h>
 #endif
-#if HAVE_NETINET_IF_ETHER_H
+#ifdef HAVE_NETINET_IF_ETHER_H
 #include <netinet/if_ether.h>
 #endif
-#if HAVE_NET_IF_TYPES_H
+#ifdef HAVE_NET_IF_TYPES_H
 #include <net/if_types.h>
 #endif
-#if HAVE_NET_IF_DL_H
+#ifdef HAVE_NET_IF_DL_H
 #ifndef dynix
 #include <net/if_dl.h>
 #else
 #include <sys/net/if_dl.h>
 #endif
 #endif
-#if HAVE_INET_MIB2_H
+#ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
-#if HAVE_IOCTLS_H
+#ifdef HAVE_IOCTLS_H
 #include <ioctls.h>
 #endif
 
 #ifdef solaris2
 # include <errno.h>
 #include "kernel_sunos5.h"
 #else
 #include "kernel.h"
 #endif
 
 #ifdef hpux
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
 #endif                          /* hpux */
 
 #if defined(cygwin) || defined(mingw32)
 #include <windows.h>
 #endif
 
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 
 #if defined(freebsd3) || defined(freebsd4) || defined(freebsd5)
 #    define USE_SYSCTL_IFLIST
 #else
 # if defined(CTL_NET) && !defined(freebsd2) && !defined(netbsd1)
 #  ifdef PF_ROUTE
 #   ifdef NET_RT_IFLIST
 #    ifndef netbsd1
 #     define USE_SYSCTL_IFLIST
 #    endif
 #   endif
 #  endif
 # endif
 #endif                          /* defined(freebsd3) */
 #endif                          /* HAVE_SYS_SYSCTL_H */
 
-#if HAVE_OSRELDATE_H
+#ifdef HAVE_OSRELDATE_H
 #include <osreldate.h>
 #endif
 #ifdef NETSNMP_CAN_USE_SYSCTL
 #include <sys/sysctl.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/sysORTable.h>
 #include <net-snmp/data_access/interface.h>
 
 #include "interfaces.h"
 #include "struct.h"
 #include "util_funcs.h"
 #include "util_funcs/header_generic.h"
 
 /* if you want caching enabled for speed retrieval purposes, set this to 5?*/
 #define MINLOADFREQ 0                     /* min reload frequency in seconds */
 #ifdef linux
@@ -284,26 +284,26 @@ void
 init_interfaces(void)
 {
     /*
      * register ourselves with the agent to handle our mib tree 
      */
     REGISTER_MIB("mibII/interfaces", interfaces_variables, variable3,
                  interfaces_variables_oid);
     REGISTER_SYSOR_ENTRY(interfaces_module_oid,
                          "The MIB module to describe generic objects for network interface sub-layers");
 
 #ifndef USE_SYSCTL_IFLIST
-#if HAVE_NET_IF_MIB_H
+#ifdef HAVE_NET_IF_MIB_H
     init_interfaces_setup();
 #endif
 #endif
 #ifdef solaris2
     init_kernel_sunos5();
 #endif
 }
 
 #ifdef linux
 /*
  * if_type_from_name
  * Return interface type using the interface name as a clue.
  * Returns 1 to imply "other" type if name not recognized. 
  */
@@ -583,139 +583,139 @@ u_char         *
 var_ifEntry(struct variable *vp,
             oid * name,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
     int             interface;
     struct if_msghdr if_msg;
     static char     if_name[100];
     conf_if_list   *if_ptr;
     char           *cp;
 
     interface =
         header_ifEntry(vp, name, length, exact, var_len, write_method);
     if (interface == MATCH_FAILED)
         return NULL;
 
     if (Interface_Scan_By_Index(interface, &if_msg, if_name, NULL) != 0)
         return NULL;
     if_ptr = netsnmp_access_interface_entry_overrides_get(if_name);
 
     switch (vp->magic) {
     case NETSNMP_IFINDEX:
         long_return = interface;
         return (u_char *) & long_return;
     case NETSNMP_IFDESCR:
         cp = if_name;
         *var_len = strlen(if_name);
         return (u_char *) cp;
     case NETSNMP_IFTYPE:
         if (if_ptr)
             long_return = if_ptr->type;
         else
         long_return = (long) if_msg.ifm_data.ifi_type;
         return (u_char *) & long_return;
     case NETSNMP_IFMTU:
         long_return = (long) if_msg.ifm_data.ifi_mtu;
         return (u_char *) & long_return;
     case NETSNMP_IFSPEED:
         if (if_ptr)
             long_return = if_ptr->speed;
         else {
-#if HAVE_STRUCT_IFNET_IF_BAUDRATE_IFS_VALUE
+#ifdef HAVE_STRUCT_IFNET_IF_BAUDRATE_IFS_VALUE
         long_return = (u_long) if_msg.ifm_data.ifi_baudrate.ifs_value <<
             if_msg.ifm_data.ifi_baudrate.ifs_log2;
 #else
         long_return = (u_long) if_msg.ifm_data.ifi_baudrate;
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFPHYSADDRESS:
         /*
          * XXX 
          */
         return NULL;
     case NETSNMP_IFADMINSTATUS:
         long_return = if_msg.ifm_flags & IFF_UP ? 1 : 2;
         return (u_char *) & long_return;
     case NETSNMP_IFOPERSTATUS:
         long_return = if_msg.ifm_flags & IFF_RUNNING ? 1 : 2;
         return (u_char *) & long_return;
         /*
          * ifLastChange 
          */
     case NETSNMP_IFINOCTETS:
         long_return = (u_long) if_msg.ifm_data.ifi_ibytes;
         return (u_char *) & long_return;
     case NETSNMP_IFINUCASTPKTS:
         long_return =
             (u_long) if_msg.ifm_data.ifi_ipackets -
             if_msg.ifm_data.ifi_imcasts;
         return (u_char *) & long_return;
     case NETSNMP_IFINNUCASTPKTS:
         long_return = (u_long) if_msg.ifm_data.ifi_imcasts;
         return (u_char *) & long_return;
     case NETSNMP_IFINDISCARDS:
         long_return = (u_long) if_msg.ifm_data.ifi_iqdrops;
         return (u_char *) & long_return;
     case NETSNMP_IFINERRORS:
         long_return = (u_long) if_msg.ifm_data.ifi_ierrors;
         return (u_char *) & long_return;
     case NETSNMP_IFINUNKNOWNPROTOS:
         long_return = (u_long) if_msg.ifm_data.ifi_noproto;
         return (u_char *) & long_return;
     case NETSNMP_IFOUTOCTETS:
         long_return = (u_long) if_msg.ifm_data.ifi_obytes;
         return (u_char *) & long_return;
     case NETSNMP_IFOUTUCASTPKTS:
         long_return =
             (u_long) if_msg.ifm_data.ifi_opackets -
             if_msg.ifm_data.ifi_omcasts;
         return (u_char *) & long_return;
     case NETSNMP_IFOUTNUCASTPKTS:
         long_return = (u_long) if_msg.ifm_data.ifi_omcasts;
         return (u_char *) & long_return;
     case NETSNMP_IFOUTDISCARDS:
 #ifdef if_odrops
         long_return = (u_long) if_msg.ifm_data.ifi_odrops;
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTERRORS:
         long_return = (u_long) if_msg.ifm_data.ifi_oerrors;
         return (u_char *) & long_return;
     case NETSNMP_IFLASTCHANGE:
 #ifdef irix6
         long_return = 0;
 #else
         if (if_msg.ifm_data.ifi_lastchange.tv_sec == 0 &&
-#if STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
+#ifdef STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
             if_msg.ifm_data.ifi_lastchange.tv_nsec == 0
 #else
             if_msg.ifm_data.ifi_lastchange.tv_usec == 0
 #endif
            )
             long_return = 0;
         else if (if_msg.ifm_data.ifi_lastchange.tv_sec < starttime.tv_sec)
             long_return = 0;
         else {
             long_return = (u_long)
                 ((if_msg.ifm_data.ifi_lastchange.tv_sec -
                   starttime.tv_sec) * 100 +
                  (
-#if STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
+#ifdef STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
                   if_msg.ifm_data.ifi_lastchange.tv_nsec / 1000
 #else
                   if_msg.ifm_data.ifi_lastchange.tv_usec
 #endif
                   - starttime.tv_usec) / 10000);
         }
 #endif
         return (u_char *) & long_return;
     default:
         return 0;
     }
 }
@@ -773,280 +773,280 @@ u_char         *
 var_ifEntry(struct variable *vp,
             oid * name,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
     static struct ifnet ifnet;
     int             interface;
     static struct in_ifaddr in_ifaddr;
     static char     Name[16];
     char           *cp;
     conf_if_list   *if_ptr;
 
     interface =
         header_ifEntry(vp, name, length, exact, var_len, write_method);
     if (interface == MATCH_FAILED)
         return NULL;
 
     Interface_Scan_By_Index(interface, Name, &ifnet, &in_ifaddr);
     if_ptr = netsnmp_access_interface_entry_overrides_get(Name);
 
     switch (vp->magic) {
     case NETSNMP_IFINDEX:
         long_return = interface;
         return (u_char *) & long_return;
     case NETSNMP_IFDESCR:
         cp = Name;
         *var_len = strlen(cp);
         return (u_char *) cp;
     case NETSNMP_IFTYPE:
         if (if_ptr)
             long_return = if_ptr->type;
         else {
-#if HAVE_STRUCT_IFNET_IF_TYPE
+#ifdef HAVE_STRUCT_IFNET_IF_TYPE
             long_return = ifnet.if_type;
 #else
             long_return = 1;    /* OTHER */
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFMTU:{
             long_return = (long) ifnet.if_mtu;
             return (u_char *) & long_return;
         }
     case NETSNMP_IFSPEED:
         if (if_ptr)
             long_return = if_ptr->speed;
         else {
-#if HAVE_STRUCT_IFNET_IF_BAUDRATE
+#ifdef HAVE_STRUCT_IFNET_IF_BAUDRATE
             long_return = ifnet.if_baudrate;
-#elif HAVE_STRUCT_IFNET_IF_SPEED
+#elif defined(HAVE_STRUCT_IFNET_IF_SPEED)
             long_return = ifnet.if_speed;
 #elif HAVE_STRUCT_IFNET_IF_TYPE && defined(IFT_ETHER)
             if (ifnet.if_type == IFT_ETHER)
                 long_return = 10000000;
             if (ifnet.if_type == IFT_P10)
                 long_return = 10000000;
             if (ifnet.if_type == IFT_P80)
                 long_return = 80000000;
             if (ifnet.if_type == IFT_ISDNBASIC)
                 long_return = 64000;    /* EDSS1 only */
             if (ifnet.if_type == IFT_ISDNPRIMARY)
                 long_return = 64000 * 30;
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
             return NULL;
 #endif
             long_return = (u_long) 10000000;
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFPHYSADDRESS:
         Interface_Get_Ether_By_Index(interface, return_buf);
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
 	*var_len = 0;
 #else
         if ((return_buf[0] == 0) && (return_buf[1] == 0) &&
             (return_buf[2] == 0) && (return_buf[3] == 0) &&
             (return_buf[4] == 0) && (return_buf[5] == 0))
             *var_len = 0;
         else
             *var_len = 6;
 #endif
         return (u_char *) return_buf;
     case NETSNMP_IFADMINSTATUS:
         long_return = ifnet.if_flags & IFF_UP ? 1 : 2;
         return (u_char *) & long_return;
     case NETSNMP_IFOPERSTATUS:
         long_return = ifnet.if_flags & IFF_RUNNING ? 1 : 2;
         return (u_char *) & long_return;
     case NETSNMP_IFLASTCHANGE:
 #if defined(HAVE_STRUCT_IFNET_IF_LASTCHANGE_TV_SEC) && !(defined(freebsd2) && __FreeBSD_version < 199607)
         /*
          * XXX - SNMP's ifLastchange is time when op. status changed
          * FreeBSD's if_lastchange before the 2.1.5 release is the time when
          * a packet was last input or output.  In the 2.1.5 and later releases,
          * this is fixed, thus the 199607 comparison.
          */
         if (ifnet.if_lastchange.tv_sec == 0 &&
-#if STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
+#ifdef STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
             ifnet.if_lastchange.tv_nsec == 0
 #else
             ifnet.if_lastchange.tv_usec == 0
 #endif
             )
             long_return = 0;
         else if (ifnet.if_lastchange.tv_sec < starttime.tv_sec)
             long_return = 0;
         else {
             long_return = (u_long)
                 ((ifnet.if_lastchange.tv_sec - starttime.tv_sec) * 100
                  + (
-#if STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
+#ifdef STRUCT_IFNET_HAS_IF_LASTCHANGE_TV_NSEC
                    ifnet.if_lastchange.tv_nsec / 1000
 #else
                    ifnet.if_lastchange.tv_usec
 #endif
                    - starttime.tv_usec) / 10000);
         }
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;        /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINOCTETS:
 #ifdef HAVE_STRUCT_IFNET_IF_IBYTES
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_ibytes & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_ibytes;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) ifnet.if_ipackets * 308; /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINUCASTPKTS:
         {
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
             long_return = (u_long) ifnet.if_ipackets & 0xffffffff;
 #else
             long_return = (u_long) ifnet.if_ipackets;
 #endif
-#if HAVE_STRUCT_IFNET_IF_IMCASTS
+#ifdef HAVE_STRUCT_IFNET_IF_IMCASTS
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
             long_return -= (u_long) ifnet.if_imcasts & 0xffffffff;
 #else
             long_return -= (u_long) ifnet.if_imcasts;
 #endif
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFINNUCASTPKTS:
-#if HAVE_STRUCT_IFNET_IF_IMCASTS
+#ifdef HAVE_STRUCT_IFNET_IF_IMCASTS
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_imcasts & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_imcasts;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) 0;       /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINDISCARDS:
-#if HAVE_STRUCT_IFNET_IF_IQDROPS
+#ifdef HAVE_STRUCT_IFNET_IF_IQDROPS
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_iqdrops & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_iqdrops;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) 0;       /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINERRORS:
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_ierrors & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_ierrors;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINUNKNOWNPROTOS:
-#if HAVE_STRUCT_IFNET_IF_NOPROTO
+#ifdef HAVE_STRUCT_IFNET_IF_NOPROTO
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_noproto & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_noproto;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) 0;       /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTOCTETS:
 #ifdef HAVE_STRUCT_IFNET_IF_OBYTES
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_obytes & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_obytes;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) ifnet.if_opackets * 308; /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTUCASTPKTS:
         {
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
             long_return = (u_long) ifnet.if_opackets & 0xffffffff;
 #else
             long_return = (u_long) ifnet.if_opackets;
 #endif
-#if HAVE_STRUCT_IFNET_IF_OMCASTS
+#ifdef HAVE_STRUCT_IFNET_IF_OMCASTS
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
             long_return -= (u_long) ifnet.if_omcasts & 0xffffffff;
 #else
             long_return -= (u_long) ifnet.if_omcasts;
 #endif
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFOUTNUCASTPKTS:
-#if HAVE_STRUCT_IFNET_IF_OMCASTS
+#ifdef HAVE_STRUCT_IFNET_IF_OMCASTS
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = (u_long) ifnet.if_omcasts & 0xffffffff;
 #else
         long_return = (u_long) ifnet.if_omcasts;
 #endif
 #else
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = (u_long) 0;       /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTDISCARDS:
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = ifnet.if_snd.ifq_drops & 0xffffffff;
 #else
         long_return = ifnet.if_snd.ifq_drops;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTERRORS:
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = ifnet.if_oerrors & 0xffffffff;
 #else
         long_return = ifnet.if_oerrors;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTQLEN:
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
         long_return = ifnet.if_snd.ifq_len & 0xffffffff;
 #else
         long_return = ifnet.if_snd.ifq_len;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFSPECIFIC:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #else                           /* hpux */
@@ -1055,271 +1055,271 @@ u_char         *
 var_ifEntry(struct variable *vp,
             oid * name,
             size_t * length,
             int exact, size_t * var_len, WriteMethod ** write_method)
 {
 #if defined(hpux11)
     static nmapi_phystat ifnet;
 #else
     static struct ifnet ifnet;
 #endif
     register int    interface;
 #if !defined(hpux11)
     static struct in_ifaddr in_ifaddrVar;
 #endif
 #if defined(hpux11)
     static char     Name[MAX_PHYSADDR_LEN];
 #else
     static char     Name[16];
 #endif
     register char  *cp;
-#if HAVE_STRUCT_IFNET_IF_LASTCHANGE_TV_SEC
+#ifdef HAVE_STRUCT_IFNET_IF_LASTCHANGE_TV_SEC
     struct timeval  now;
 #endif
 #if !defined(hpux11)
     struct nmparms  hp_nmparms;
     static mib_ifEntry hp_ifEntry;
     int             hp_fd;
     int             hp_len = sizeof(hp_ifEntry);
 #endif
     conf_if_list   *if_ptr;
 
     interface =
         header_ifEntry(vp, name, length, exact, var_len, write_method);
     if (interface == MATCH_FAILED)
         return NULL;
 
 #if defined(hpux11)
     Interface_Scan_By_Index(interface, Name, &ifnet);
 #else
     Interface_Scan_By_Index(interface, Name, &ifnet, &in_ifaddrVar);
 #endif
 
 #if !defined(hpux11)
     /*
      * Additional information about the interfaces is available under
      * HP-UX through the network management interface '/dev/netman'
      */
     hp_ifEntry.ifIndex = interface;
     hp_nmparms.objid = ID_ifEntry;
     hp_nmparms.buffer = (char *) &hp_ifEntry;
     hp_nmparms.len = &hp_len;
     if ((hp_fd = open("/dev/netman", O_RDONLY)) != -1) {
         if (ioctl(hp_fd, NMIOGET, &hp_nmparms) != -1) {
             close(hp_fd);
         } else {
             close(hp_fd);
             hp_fd = -1;         /* failed */
         }
     }
 #endif
     if_ptr = netsnmp_access_interface_entry_overrides_get(Name);
 
     switch (vp->magic) {
     case NETSNMP_IFINDEX:
         long_return = interface;
         return (u_char *) & long_return;
     case NETSNMP_IFDESCR:
 #if defined(hpux11)
         cp = ifnet.if_entry.ifDescr;
 #else
         if (hp_fd != -1)
             cp = hp_ifEntry.ifDescr;
         else
             cp = Name;
 #endif
         *var_len = strlen(cp);
         return (u_char *) cp;
     case NETSNMP_IFTYPE:
         if (if_ptr)
             long_return = if_ptr->type;
         else {
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifType;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifType;
         else
             long_return = 1;    /* OTHER */
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFMTU:{
 #if defined(hpux11)
             long_return = (long) ifnet.if_entry.ifMtu;
 #else
             long_return = (long) ifnet.if_mtu;
 #endif
             return (u_char *) & long_return;
         }
     case NETSNMP_IFSPEED:
         if (if_ptr)
             long_return = if_ptr->speed;
         else {
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifSpeed;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifSpeed;
         else
             long_return = (u_long) 1;   /* OTHER */
 #endif
         }
         return (u_char *) & long_return;
     case NETSNMP_IFPHYSADDRESS:
 #if defined(hpux11)
         *var_len = ifnet.if_entry.ifPhysAddress.o_length;
         return (u_char *) ifnet.if_entry.ifPhysAddress.o_bytes;
 #else
         Interface_Get_Ether_By_Index(interface, return_buf);
         if ((return_buf[0] == 0) && (return_buf[1] == 0) &&
             (return_buf[2] == 0) && (return_buf[3] == 0) &&
             (return_buf[4] == 0) && (return_buf[5] == 0))
             *var_len = 0;
         else
             *var_len = 6;
         return (u_char *) return_buf;
 #endif
     case NETSNMP_IFADMINSTATUS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifAdmin;
 #else
         long_return = ifnet.if_flags & IFF_UP ? 1 : 2;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOPERSTATUS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOper;
 #else
         long_return = ifnet.if_flags & IFF_RUNNING ? 1 : 2;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFLASTCHANGE:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifLastChange;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifLastChange;
         else
             long_return = 0;    /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINOCTETS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInOctets;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifInOctets;
         else
             long_return = (u_long) ifnet.if_ipackets * 308;     /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINUCASTPKTS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInUcastPkts;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifInUcastPkts;
         else
             long_return = (u_long) ifnet.if_ipackets;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINNUCASTPKTS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInNUcastPkts;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifInNUcastPkts;
         else
             long_return = (u_long) 0;   /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINDISCARDS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInDiscards;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifInDiscards;
         else
             long_return = (u_long) 0;   /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINERRORS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInErrors;
 #else
         long_return = ifnet.if_ierrors;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFINUNKNOWNPROTOS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifInUnknownProtos;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifInUnknownProtos;
         else
             long_return = (u_long) 0;   /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTOCTETS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutOctets;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifOutOctets;
         else
             long_return = (u_long) ifnet.if_opackets * 308;     /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTUCASTPKTS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutUcastPkts;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifOutUcastPkts;
         else
             long_return = (u_long) ifnet.if_opackets;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTNUCASTPKTS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutNUcastPkts;
 #else
         if (hp_fd != -1)
             long_return = hp_ifEntry.ifOutNUcastPkts;
         else
             long_return = (u_long) 0;   /* XXX */
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTDISCARDS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutDiscards;
 #else
         long_return = ifnet.if_snd.ifq_drops;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTERRORS:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutErrors;
 #else
         long_return = ifnet.if_oerrors;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFOUTQLEN:
 #if defined(hpux11)
         long_return = ifnet.if_entry.ifOutQlen;
 #else
         long_return = ifnet.if_snd.ifq_len;
 #endif
         return (u_char *) & long_return;
     case NETSNMP_IFSPECIFIC:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ifEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #endif                          /* hpux */
 #else                           /* solaris2 */
@@ -2020,117 +2020,117 @@ int
 Interface_Scan_NextInt(int *Index,
                     char *Name,
                     struct ifnet *Retifnet, struct in_ifaddr *Retin_ifaddr)
 {
     struct ifnet    ifnet;
     struct in_ifaddr *ia, in_ifaddr;
     short           has_ipaddr = 0;
-#if !HAVE_STRUCT_IFNET_IF_XNAME
+#if !defined(HAVE_STRUCT_IFNET_IF_XNAME)
     register char  *cp;
 #endif
 
     while (ifnetaddr) {
         /*
          *      Get the "ifnet" structure and extract the device name
          */
         if (!NETSNMP_KLOOKUP(ifnetaddr, (char *) &ifnet, sizeof ifnet)) {
             DEBUGMSGTL(("mibII/interfaces:Interface_Scan_Next", "klookup failed\n"));
             break;
         }
-#if HAVE_STRUCT_IFNET_IF_XNAME
+#ifdef HAVE_STRUCT_IFNET_IF_XNAME
 #if defined(netbsd1) || defined(openbsd2)
         strlcpy(saveName, ifnet.if_xname, sizeof(saveName));
 #else
         if (!NETSNMP_KLOOKUP(ifnet.if_xname, (char *) saveName, sizeof saveName)) {
             DEBUGMSGTL(("mibII/interfaces:Interface_Scan_Next", "klookup failed\n"));
             break;
         }
 #endif
         saveName[sizeof(saveName) - 1] = '\0';
 #else
         if (!NETSNMP_KLOOKUP(ifnet.if_name, (char *) saveName, sizeof saveName)) {
             DEBUGMSGTL(("mibII/interfaces:Interface_Scan_Next", "klookup failed\n"));
             break;
         }
 
         saveName[sizeof(saveName) - 1] = '\0';
         cp = strchr(saveName, '\0');
 #ifdef NETSNMP_FEATURE_CHECKIN
         /* this exists here just so we don't copy ifdef logic elsewhere */
         netsnmp_feature_require(string_append_int);
 #endif
         string_append_int(cp, ifnet.if_unit);
 #endif
         if (1 || strcmp(saveName, "lo0") != 0) {        /* XXX */
             /*
              *  Try to find an address for this interface
              */
 
 #ifdef netbsd1
             ia = (struct in_ifaddr *) ifnet.if_addrlist.tqh_first;
 #elif defined(IFADDR_SYMBOL)
             auto_nlist(IFADDR_SYMBOL, (char *) &ia, sizeof(ia));
 #endif
             while (ia) {
                 if (!NETSNMP_KLOOKUP(ia, (char *) &in_ifaddr, sizeof(in_ifaddr))) {
                     DEBUGMSGTL(("mibII/interfaces:Interface_Scan_Next", "klookup failed\n"));
                     break;
                 }
                 {
 #ifdef netbsd1
 #define CP(x)	((char *)(x))
                     char           *cp;
                     struct sockaddr *sa;
                     cp = (CP(in_ifaddr.ia_ifa.ifa_addr) - CP(ia)) +
                         CP(&in_ifaddr);
                     sa = (struct sockaddr *) cp;
 
                     if (sa->sa_family == AF_INET)
 #endif
                         if (in_ifaddr.ia_ifp == ifnetaddr) {
                             has_ipaddr = 1;     /* this IF has IP-address */
                             break;
                         }
                 }
 #ifdef netbsd1
                 ia = (struct in_ifaddr *) in_ifaddr.ia_ifa.ifa_list.
                     tqe_next;
 #else
                 ia = in_ifaddr.ia_next;
 #endif
             }
 
 #if !defined(netbsd1) && !defined(freebsd2) && !defined(openbsd2) && !defined(HAVE_STRUCT_IFNET_IF_ADDRLIST)
             ifnet.if_addrlist = (struct ifaddr *) ia;   /* WRONG DATA TYPE; ONLY A FLAG */
 #endif
             /*
              * ifnet.if_addrlist = (struct ifaddr *)&ia->ia_ifa;   
              *
              * WRONG DATA TYPE; ONLY A FLAG 
              */
 
             if (Index)
                 *Index = ++saveIndex;
             if (Retifnet)
                 *Retifnet = ifnet;
             if (Retin_ifaddr && has_ipaddr)     /* assign the in_ifaddr only
                                                  * if the IF has IP-address */
                 *Retin_ifaddr = in_ifaddr;
             if (Name)
                 strcpy(Name, saveName);
             saveifnet = ifnet;
             saveifnetaddr = ifnetaddr;
             savein_ifaddr = in_ifaddr;
             ifnetaddr = ifnet.if_next;
 
             return (1);         /* DONE */
         }
         ifnetaddr = ifnet.if_next;
     }
     return (0);                 /* EOF */
 }
 
 #endif                          /* hpux11 */
 
 #endif                          /* sunV3 || linux */
 
 #if defined(hpux11)
diff --git a/agent/mibgroup/mibII/ip.c b/agent/mibgroup/mibII/ip.c
index f832d029de..d374477b06 100644
--- a/agent/mibgroup/mibII/ip.c
+++ b/agent/mibgroup/mibII/ip.c
@@ -281,435 +281,435 @@ int
 ip_handler(netsnmp_mib_handler          *handler,
            netsnmp_handler_registration *reginfo,
            netsnmp_agent_request_info   *reqinfo,
            netsnmp_request_info         *requests)
 {
     netsnmp_request_info  *request;
     netsnmp_variable_list *requestvb;
     long     ret_value;
     oid      subid;
     int      type = ASN_COUNTER;
 
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      */
 #ifdef _USE_PERFSTAT_PROTOCOL
     ip_load(NULL, NULL);
 #endif
 
 
     /*
      * 
      *
      */
     DEBUGMSGTL(("mibII/ip", "Handler - mode %s\n",
                     se_find_label_in_slist("agent_mode", reqinfo->mode)));
     switch (reqinfo->mode) {
     case MODE_GET:
         for (request=requests; request; request=request->next) {
             requestvb = request->requestvb;
             subid = requestvb->name[OID_LENGTH(ip_oid)];  /* XXX */
             DEBUGMSGTL(( "mibII/ip", "oid: "));
             DEBUGMSGOID(("mibII/ip", requestvb->name,
                                      requestvb->name_length));
             DEBUGMSG((   "mibII/ip", "\n"));
 
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_IPSTAT
     case IPFORWARDING:
         ret_value = ipstat.ipForwarding;
         type = ASN_INTEGER;
         break;
     case IPDEFAULTTTL:
         ret_value = ipstat.ipDefaultTTL;
         type = ASN_INTEGER;
         break;
     case IPINRECEIVES:
         ret_value = ipstat.ipInReceives & 0xffffffff;
         break;
     case IPINHDRERRORS:
         ret_value = ipstat.ipInHdrErrors;
         break;
     case IPINADDRERRORS:
         ret_value = ipstat.ipInAddrErrors;
         break;
     case IPFORWDATAGRAMS:
         ret_value = ipstat.ipForwDatagrams;
         break;
     case IPINUNKNOWNPROTOS:
         ret_value = ipstat.ipInUnknownProtos;
         break;
     case IPINDISCARDS:
         ret_value = ipstat.ipInDiscards;
         break;
     case IPINDELIVERS:
         ret_value = ipstat.ipInDelivers & 0xffffffff;
         break;
     case IPOUTREQUESTS:
         ret_value = ipstat.ipOutRequests & 0xffffffff;
         break;
     case IPOUTDISCARDS:
         ret_value = ipstat.ipOutDiscards;
         break;
     case IPOUTNOROUTES:
         ret_value = ipstat.ipOutNoRoutes;
         break;
     case IPREASMTIMEOUT:
         ret_value = ipstat.ipReasmTimeout;
         type = ASN_INTEGER;
         break;
     case IPREASMREQDS:
         ret_value = ipstat.ipReasmReqds;
         break;
     case IPREASMOKS:
         ret_value = ipstat.ipReasmOKs;
         break;
     case IPREASMFAILS:
         ret_value = ipstat.ipReasmFails;
         break;
     case IPFRAGOKS:
         ret_value = ipstat.ipFragOKs;
         break;
     case IPFRAGFAILS:
         ret_value = ipstat.ipFragFails;
         break;
     case IPFRAGCREATES:
         ret_value = ipstat.ipFragCreates;
         break;
     case IPROUTEDISCARDS:
         ret_value = ipstat.ipRoutingDiscards;
         break;
 
 #elif defined(USES_TRADITIONAL_IPSTAT) && !defined(_USE_PERFSTAT_PROTOCOL)
 #ifdef HAVE_SYS_TCPIPSTATS_H
     /*
      * This actually reads statistics for *all* the groups together,
      * so we need to isolate the IP-specific bits.  
      */
 #define	ipstat		ipstat.ipstat
 #endif
     case IPFORWARDING:
     case IPDEFAULTTTL:
         /* 
          * Query these two individually
          */
         ret_value = ip_load(NULL, (void *)subid);
         if (ret_value == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
 	}
         type = ASN_INTEGER;
         break;
     case IPINRECEIVES:
         ret_value = ipstat.ips_total & 0xffffffff;
         break;
     case IPINHDRERRORS:
         ret_value = ipstat.ips_badsum
             + ipstat.ips_tooshort
             + ipstat.ips_toosmall + ipstat.ips_badhlen + ipstat.ips_badlen;
         break;
     case IPINADDRERRORS:
         ret_value = ipstat.ips_cantforward;
         break;
     case IPFORWDATAGRAMS:
         ret_value = ipstat.ips_forward;
         break;
     case IPINUNKNOWNPROTOS:
-#if HAVE_STRUCT_IPSTAT_IPS_NOPROTO
+#ifdef HAVE_STRUCT_IPSTAT_IPS_NOPROTO
         ret_value = ipstat.ips_noproto;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPINDISCARDS:
-#if HAVE_STRUCT_IPSTAT_IPS_FRAGDROPPED
+#ifdef HAVE_STRUCT_IPSTAT_IPS_FRAGDROPPED
         ret_value = ipstat.ips_fragdropped;   /* ?? */
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPINDELIVERS:
-#if HAVE_STRUCT_IPSTAT_IPS_DELIVERED
+#ifdef HAVE_STRUCT_IPSTAT_IPS_DELIVERED
         ret_value = ipstat.ips_delivered & 0xffffffff;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPOUTREQUESTS:
-#if HAVE_STRUCT_IPSTAT_IPS_LOCALOUT
+#ifdef HAVE_STRUCT_IPSTAT_IPS_LOCALOUT
         ret_value = ipstat.ips_localout & 0xffffffff;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPOUTDISCARDS:
-#if HAVE_STRUCT_IPSTAT_IPS_ODROPPED
+#ifdef HAVE_STRUCT_IPSTAT_IPS_ODROPPED
         ret_value = ipstat.ips_odropped;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPOUTNOROUTES:
         /*
          * XXX: how to calculate this (counts dropped routes, not packets)?
          * ipstat.ips_cantforward isn't right, as it counts packets.
          * ipstat.ips_noroute is also incorrect.
          */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
     case IPREASMTIMEOUT:
         ret_value = netsnmp_arch_ip_scalars_ipReasmTimeout_get();
         type = ASN_INTEGER;
         break;
     case IPREASMREQDS:
         ret_value = ipstat.ips_fragments;
         break;
     case IPREASMOKS:
-#if HAVE_STRUCT_IPSTAT_IPS_REASSEMBLED
+#ifdef HAVE_STRUCT_IPSTAT_IPS_REASSEMBLED
         ret_value = ipstat.ips_reassembled;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPREASMFAILS:
         ret_value = ipstat.ips_fragdropped + ipstat.ips_fragtimeout;
         break;
     case IPFRAGOKS:
-#if HAVE_STRUCT_IPSTAT_IPS_FRAGMENTED
+#ifdef HAVE_STRUCT_IPSTAT_IPS_FRAGMENTED
         ret_value = ipstat.ips_fragments;
         break;
 #else            /* XXX */
         ret_value = ipstat.ips_fragments
             - (ipstat.ips_fragdropped + ipstat.ips_fragtimeout);
         break;
 #endif
     case IPFRAGFAILS:
-#if HAVE_STRUCT_IPSTAT_IPS_CANTFRAG
+#ifdef HAVE_STRUCT_IPSTAT_IPS_CANTFRAG
         ret_value = ipstat.ips_cantfrag;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPFRAGCREATES:
-#if HAVE_STRUCT_IPSTAT_IPS_OFRAGMENTS
+#ifdef HAVE_STRUCT_IPSTAT_IPS_OFRAGMENTS
         ret_value = ipstat.ips_ofragments;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
     case IPROUTEDISCARDS:
-#if HAVE_STRUCT_IPSTAT_IPS_NOROUTE
+#ifdef HAVE_STRUCT_IPSTAT_IPS_NOROUTE
         ret_value = ipstat.ips_noroute;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #undef ipstat
 #endif
 #elif defined(hpux11)
     case IPFORWARDING:
     case IPDEFAULTTTL:
     case IPREASMTIMEOUT:
         type = ASN_INTEGER;
     case IPINRECEIVES:
     case IPINHDRERRORS:
     case IPINADDRERRORS:
     case IPFORWDATAGRAMS:
     case IPINUNKNOWNPROTOS:
     case IPINDISCARDS:
     case IPINDELIVERS:
     case IPOUTREQUESTS:
     case IPOUTDISCARDS:
     case IPOUTNOROUTES:
     case IPREASMREQDS:
     case IPREASMOKS:
     case IPREASMFAILS:
     case IPFRAGOKS:
     case IPFRAGFAILS:
     case IPFRAGCREATES:
     case IPROUTEDISCARDS:
 	/*
 	 * This is a bit of a hack, to shoehorn the HP-UX 11
 	 * single-object retrieval approach into the caching
 	 * architecture.
 	 */
 	if (ip_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
 	}
         ret_value = ipstat;
         break;
 #elif defined (WIN32) || defined (cygwin)
     case IPFORWARDING:
         ipForwarding = ipstat.dwForwarding;
         ret_value    = ipstat.dwForwarding;
         type = ASN_INTEGER;
         break;
     case IPDEFAULTTTL:
         ipTTL     = ipstat.dwDefaultTTL;
         ret_value = ipstat.dwDefaultTTL;
         type = ASN_INTEGER;
         break;
     case IPINRECEIVES:
         ret_value = ipstat.dwInReceives;
         break;
     case IPINHDRERRORS:
         ret_value = ipstat.dwInHdrErrors;
         break;
     case IPINADDRERRORS:
         ret_value = ipstat.dwInAddrErrors;
         break;
     case IPFORWDATAGRAMS:
         ret_value = ipstat.dwForwDatagrams;
         break;
     case IPINUNKNOWNPROTOS:
         ret_value = ipstat.dwInUnknownProtos;
         break;
     case IPINDISCARDS:
         ret_value = ipstat.dwInDiscards;
         break;
     case IPINDELIVERS:
         ret_value = ipstat.dwInDelivers;
         break;
     case IPOUTREQUESTS:
         ret_value = ipstat.dwOutRequests;
         break;
     case IPOUTDISCARDS:
         ret_value = ipstat.dwOutDiscards;
         break;
     case IPOUTNOROUTES:
         ret_value = ipstat.dwOutNoRoutes;
         break;
     case IPREASMTIMEOUT:
         ret_value = ipstat.dwReasmTimeout;
         type = ASN_INTEGER;
         break;
     case IPREASMREQDS:
         ret_value = ipstat.dwReasmReqds;
         break;
     case IPREASMOKS:
         ret_value = ipstat.dwReasmOks;
         break;
     case IPREASMFAILS:
         ret_value = ipstat.dwReasmFails;
         break;
     case IPFRAGOKS:
         ret_value = ipstat.dwFragOks;
         break;
     case IPFRAGFAILS:
         ret_value = ipstat.dwFragFails;
         break;
     case IPFRAGCREATES:
         ret_value = ipstat.dwFragCreates;
         break;
     case IPROUTEDISCARDS:
         ret_value = ipstat.dwRoutingDiscards;
         break;
 #elif defined(_USE_PERFSTAT_PROTOCOL)
     case IPFORWARDING:
         ret_value    = 0;
         type = ASN_INTEGER;
         break;
     case IPDEFAULTTTL:
         ret_value = 0;
         type = ASN_INTEGER;
         break;
     case IPINRECEIVES:
         ret_value = ps_proto.u.ip.ipackets;
         break;
     case IPINHDRERRORS:
     case IPINADDRERRORS:
     case IPFORWDATAGRAMS:
         ret_value = 0;
         break;
     case IPINUNKNOWNPROTOS:
         ret_value = ps_proto.u.ip.ierrors;
         break;
     case IPINDISCARDS:
         ret_value = 0;
         break;
     case IPINDELIVERS:
     case IPOUTREQUESTS:
         ret_value = ps_proto.u.ip.opackets;
         break;
     case IPOUTDISCARDS:
     case IPOUTNOROUTES:
         ret_value = 0;
         break;
     case IPREASMTIMEOUT:
         ret_value = 0;
         type = ASN_INTEGER;
         break;
     case IPREASMREQDS:
     case IPREASMOKS:
     case IPREASMFAILS:
     case IPFRAGOKS:
     case IPFRAGFAILS:
     case IPFRAGCREATES:
         ret_value = 0;
         break;
     case IPROUTEDISCARDS:
         ret_value = ps_proto.u.ip.oerrors;
         break;
 #endif			/* USES_SNMP_DESIGNED_IPSTAT */
 
     case IPADDRTABLE:
     case IPROUTETABLE:
     case IPMEDIATABLE:
         /*
 	 * These are not actually valid scalar objects.
 	 * The relevant table registrations should take precedence,
 	 *   so skip these three subtrees, regardless of architecture.
 	 */
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 
 	    }
 	    snmp_set_var_typed_value(request->requestvb, (u_char)type,
 			             (u_char *)&ret_value, sizeof(ret_value));
 	}
         break;
 
     case MODE_GETNEXT:
     case MODE_GETBULK:
 #ifndef NETSNMP_NO_WRITE_SUPPORT
     case MODE_SET_RESERVE1:
 		/* XXX - Windows currently supports setting this */
     case MODE_SET_RESERVE2:
     case MODE_SET_ACTION:
     case MODE_SET_COMMIT:
     case MODE_SET_FREE:
     case MODE_SET_UNDO:
         snmp_log(LOG_WARNING, "mibII/ip: Unsupported mode (%d)\n",
                                reqinfo->mode);
         break;
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
     default:
         snmp_log(LOG_WARNING, "mibII/ip: Unrecognised mode (%d)\n",
                                reqinfo->mode);
         break;
     }
 
     return SNMP_ERR_NOERROR;
 }
 
 
 
         /*********************
 	 *
 	 *  Internal implementation functions
 	 *
 	 *********************/
 
 
 #ifdef hpux11
diff --git a/agent/mibgroup/mibII/ipAddr.c b/agent/mibgroup/mibII/ipAddr.c
index 35eb2dde2b..3a0323d0e5 100644
--- a/agent/mibgroup/mibII/ipAddr.c
+++ b/agent/mibgroup/mibII/ipAddr.c
@@ -1,124 +1,124 @@
 /*
  *  IP MIB group implementation - ip.c
  *
  */
 
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #ifdef irix6
 #define _STANDALONE 1
 #endif
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_SYS_SYSCTL_H
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 #include <sys/sysctl.h>
 #ifdef _I_DEFINED_KERNEL
 #define _KERNEL 1
 #endif
 #endif
 #ifdef HAVE_SYS_SYSMP_H
 #include <sys/sysmp.h>
 #endif
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #include <sys/tcpipstats.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 #ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 #ifdef HAVE_SYS_HASHING_H
 #include <sys/hashing.h>
 #endif
 #ifdef HAVE_NETINET_IN_VAR_H
 #include <netinet/in_var.h>
 #endif
 #ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 
 #if defined(MIB_IPCOUNTER_SYMBOL) || defined(hpux11)
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
 #endif                          /* MIB_IPCOUNTER_SYMBOL || hpux11 */
 
 #ifdef solaris2
 #include "kernel_sunos5.h"
 #else
 #include "kernel.h"
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/data_access/interface.h>
 
 #include "ip.h"
 #include "ipAddr.h"
 #include "interfaces.h"
 
 #if defined(cygwin) || defined(mingw32)
 #include <windows.h>
 #include <winerror.h>
 #endif
@@ -864,101 +864,101 @@ u_char         *
 var_ipAddrEntry(struct variable *vp,
                 oid * name,
                 size_t * length,
                 int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * object identifier is of form:
      * 1.3.6.1.2.1.4.20.1.?.A.B.C.D,  where A.B.C.D is IP address.
      * IPADDR starts at offset 10.
      */
     oid             lowest[14];
     oid             current[14], *op;
     u_char         *cp;
     int             lowinterface = -1;
     int             i;
     static in_addr_t	addr_ret;
     
     /*
      * fill in object part of name for current (less sizeof instance part) 
      */
     memcpy(current, vp->name, (int) vp->namelen * sizeof(oid));
 
     /*
      * Get interface table from kernel.
      */
     get_iflist();
 
     for (i = 0; i < nifs; i++) {
         op = &current[10];
         cp = (u_char *) & ifs[i].addr;
         *op++ = *cp++;
         *op++ = *cp++;
         *op++ = *cp++;
         *op++ = *cp++;
         if (exact) {
             if (snmp_oid_compare(current, 14, name, *length) == 0) {
                 memcpy(lowest, current, 14 * sizeof(oid));
                 lowinterface = i;
                 break;          /* no need to search further */
             }
         } else {
             if ((snmp_oid_compare(current, 14, name, *length) > 0) &&
                 (lowinterface < 0
                  || (snmp_oid_compare(current, 14, lowest, 14) < 0))) {
                 /*
                  * if new one is greater than input
                  * and closer to input than previous
                  * lowest, save this one as the "next"
                  * one.  
                  */
                 lowinterface = i;
                 memcpy(lowest, current, 14 * sizeof(oid));
             }
         }
     }
 
     if (lowinterface < 0)
         return NULL;
     i = lowinterface;
     memcpy(name, lowest, 14 * sizeof(oid));
     *length = 14;
     *write_method = 0;
     *var_len = sizeof(long_return);
     switch (vp->magic) {
     case IPADADDR:
         *var_len = sizeof(addr_ret);
         addr_ret = ifs[i].addr.s_addr;
         return (u_char *) & addr_ret;
 
     case IPADIFINDEX:
         long_return = ifs[i].index;
         return (u_char *) & long_return;
 
     case IPADNETMASK:
         *var_len = sizeof(addr_ret);
         addr_ret = ifs[i].mask.s_addr;
         return (u_char *) & addr_ret;
 
     case IPADBCASTADDR:
         long_return = ntohl(ifs[i].bcast.s_addr) & 1;
         return (u_char *) & long_return;
 
     case IPADREASMMAX:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #else
         long_return = -1;
         return (u_char *) & long_return;
 #endif
 
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipAddrEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #endif                          /* NETSNMP_CAN_USE_SYSCTL && IPCTL_STATS */
 
 #elif defined(HAVE_IPHLPAPI_H)  /* WIN32 cygwin */
 #include <iphlpapi.h>
diff --git a/agent/mibgroup/mibII/ipv6.c b/agent/mibgroup/mibII/ipv6.c
index 6db15a76e8..f8a2dc0c3c 100644
--- a/agent/mibgroup/mibII/ipv6.c
+++ b/agent/mibgroup/mibII/ipv6.c
@@ -1217,201 +1217,201 @@ u_char         *
 var_icmpv6Entry(register struct variable * vp,
                 oid * name,
                 size_t * length,
                 int exact, size_t * var_len, WriteMethod ** write_method)
 {
 #ifndef HAVE_IF_NAMEINDEX
     return NULL;
 #else
     int             interface;
     int             max;
 
     /* Reload list of interfaces */
     if (if_initialize() < 0)
         return NULL;
 
     max = if_maxifindex();
     if (max < 0)
         return NULL;
 
     if (header_ipv6_scan
         (vp, name, length, exact, var_len, write_method, 1, max)
         == MATCH_FAILED) {
         return NULL;
     }
     interface = name[*length - 1];
     DEBUGMSGTL(("mibII/ipv6", "interface: %d(%s)\n",
                 interface, if_getname(interface)));
     if (interface >= max)
         return NULL;
 
     switch (vp->magic) {
 #ifdef SIOCGIFSTAT_ICMP6
     case IPV6IFICMPINMSG:
     case IPV6IFICMPINERRORS:
     case IPV6IFICMPINDSTUNRCHS:
     case IPV6IFICMPINADMPROHS:
     case IPV6IFICMPINTIMEXCDS:
     case IPV6IFICMPINPARMPROBS:
     case IPV6IFICMPINPKTTOOBIGS:
     case IPV6IFICMPINECHOS:
     case IPV6IFICMPINECHOREPS:
     case IPV6IFICMPINRTRSLICITS:
     case IPV6IFICMPINRTRADVS:
     case IPV6IFICMPINNBRSLICITS:
     case IPV6IFICMPINNBRADVS:
     case IPV6IFICMPINREDIRECTS:
     case IPV6IFICMPINGRPMEQERYS:
     case IPV6IFICMPINGRPMERSPS:
     case IPV6IFICMPINGRPMEREDCS:
     case IPV6IFICMPOUTMSG:
     case IPV6IFICMPOUTERRORS:
     case IPV6IFICMPOUTDSTUNRCHS:
     case IPV6IFICMPOUTADMPROHS:
     case IPV6IFICMPOUTTIMEXCDS:
     case IPV6IFICMPOUTPARMPROBS:
     case IPV6IFICMPOUTPKTTOOBIGS:
     case IPV6IFICMPOUTECHOS:
     case IPV6IFICMPOUTECHOREPS:
     case IPV6IFICMPOUTRTRSLICITS:
     case IPV6IFICMPOUTRTRADVS:
     case IPV6IFICMPOUTNBRSLICITS:
     case IPV6IFICMPOUTNBRADVS:
     case IPV6IFICMPOUTREDIRECTS:
     case IPV6IFICMPOUTGRPMEQERYS:
     case IPV6IFICMPOUTGRPMERSPS:
     case IPV6IFICMPOUTGRPMEREDCS:
         {
             struct icmp6_ifstat *ifs6;
             struct in6_ifreq ifr;
             int             s;
 
             memset(&ifr, 0, sizeof(ifr));
             strlcpy(ifr.ifr_name, if_getname(interface), sizeof(ifr.ifr_name));
             if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
                 break;
             if (ioctl(s, SIOCGIFSTAT_ICMP6, (caddr_t) & ifr) < 0) {
                 close(s);
                 break;
             }
             close(s);
             ifs6 = &ifr.ifr_ifru.ifru_icmp6stat;
             switch (vp->magic) {
             case IPV6IFICMPINMSG:
                 long_return = ifs6->ifs6_in_msg;
                 break;
             case IPV6IFICMPINERRORS:
                 long_return = ifs6->ifs6_in_error;
                 break;
             case IPV6IFICMPINDSTUNRCHS:
                 long_return = ifs6->ifs6_in_dstunreach;
                 break;
             case IPV6IFICMPINADMPROHS:
                 long_return = ifs6->ifs6_in_adminprohib;
                 break;
             case IPV6IFICMPINTIMEXCDS:
                 long_return = ifs6->ifs6_in_timeexceed;
                 break;
             case IPV6IFICMPINPARMPROBS:
                 long_return = ifs6->ifs6_in_paramprob;
                 break;
             case IPV6IFICMPINPKTTOOBIGS:
                 long_return = ifs6->ifs6_in_pkttoobig;
                 break;
             case IPV6IFICMPINECHOS:
                 long_return = ifs6->ifs6_in_echo;
                 break;
             case IPV6IFICMPINECHOREPS:
                 long_return = ifs6->ifs6_in_echoreply;
                 break;
             case IPV6IFICMPINRTRSLICITS:
                 long_return = ifs6->ifs6_in_routersolicit;
                 break;
             case IPV6IFICMPINRTRADVS:
                 long_return = ifs6->ifs6_in_routeradvert;
                 break;
             case IPV6IFICMPINNBRSLICITS:
                 long_return = ifs6->ifs6_in_neighborsolicit;
                 break;
             case IPV6IFICMPINNBRADVS:
                 long_return = ifs6->ifs6_in_neighboradvert;
                 break;
             case IPV6IFICMPINREDIRECTS:
                 long_return = ifs6->ifs6_in_redirect;
                 break;
             case IPV6IFICMPINGRPMEQERYS:
                 long_return = ifs6->ifs6_in_mldquery;
                 break;
             case IPV6IFICMPINGRPMERSPS:
                 long_return = ifs6->ifs6_in_mldreport;
                 break;
             case IPV6IFICMPINGRPMEREDCS:
                 long_return = ifs6->ifs6_in_mlddone;
                 break;
             case IPV6IFICMPOUTMSG:
                 long_return = ifs6->ifs6_out_msg;
                 break;
             case IPV6IFICMPOUTERRORS:
                 long_return = ifs6->ifs6_out_error;
                 break;
             case IPV6IFICMPOUTDSTUNRCHS:
                 long_return = ifs6->ifs6_out_dstunreach;
                 break;
             case IPV6IFICMPOUTADMPROHS:
                 long_return = ifs6->ifs6_out_adminprohib;
                 break;
             case IPV6IFICMPOUTTIMEXCDS:
                 long_return = ifs6->ifs6_out_timeexceed;
                 break;
             case IPV6IFICMPOUTPARMPROBS:
                 long_return = ifs6->ifs6_out_paramprob;
                 break;
             case IPV6IFICMPOUTPKTTOOBIGS:
                 long_return = ifs6->ifs6_out_pkttoobig;
                 break;
             case IPV6IFICMPOUTECHOS:
                 long_return = ifs6->ifs6_out_echo;
                 break;
             case IPV6IFICMPOUTECHOREPS:
                 long_return = ifs6->ifs6_out_echoreply;
                 break;
             case IPV6IFICMPOUTRTRSLICITS:
                 long_return = ifs6->ifs6_out_routersolicit;
                 break;
             case IPV6IFICMPOUTRTRADVS:
                 long_return = ifs6->ifs6_out_routeradvert;
                 break;
             case IPV6IFICMPOUTNBRSLICITS:
                 long_return = ifs6->ifs6_out_neighborsolicit;
                 break;
             case IPV6IFICMPOUTNBRADVS:
                 long_return = ifs6->ifs6_out_neighboradvert;
                 break;
             case IPV6IFICMPOUTREDIRECTS:
                 long_return = ifs6->ifs6_out_redirect;
                 break;
             case IPV6IFICMPOUTGRPMEQERYS:
                 long_return = ifs6->ifs6_out_mldquery;
                 break;
             case IPV6IFICMPOUTGRPMERSPS:
                 long_return = ifs6->ifs6_out_mldreport;
                 break;
             case IPV6IFICMPOUTGRPMEREDCS:
                 long_return = ifs6->ifs6_out_mlddone;
                 break;
             default:
                 return NULL;
             }
             return (u_char *) & long_return;
         }
 #endif
     default:
         break;
     }
     return NULL;
 #endif
 }
 
-#if HAVE_KVM_GETFILES
+#ifdef HAVE_KVM_GETFILES
 
 u_char         *
 var_udp6(register struct variable * vp,
@@ -1771,200 +1771,200 @@ u_char         *
 var_tcp6(register struct variable * vp,
          oid * name,
          size_t * length,
          int exact, size_t * var_len, WriteMethod ** write_method)
 {
     oid             newname[MAX_OID_LEN];
     oid             savname[MAX_OID_LEN];
     int             result;
     int             i, j;
     caddr_t         p;
     static struct in6pcb in6pcb, savpcb;
     struct tcp6cb   tcp6cb;
     int             found, savnameLen;
     static int      tcp6statemap[TCP6_NSTATES];
     static int      initialized = 0;
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
     struct inpcbtable tcbtable;
     caddr_t	    first;
 #elif defined(freebsd3) || defined(darwin)
     char           *sysctl_buf;
     struct xinpgen *xig, *oxig;
 #endif
 
     if (!initialized) {
         tcp6statemap[TCP6S_CLOSED] = 1;
         tcp6statemap[TCP6S_LISTEN] = 2;
         tcp6statemap[TCP6S_SYN_SENT] = 3;
         tcp6statemap[TCP6S_SYN_RECEIVED] = 4;
         tcp6statemap[TCP6S_ESTABLISHED] = 5;
         tcp6statemap[TCP6S_CLOSE_WAIT] = 8;
         tcp6statemap[TCP6S_FIN_WAIT_1] = 6;
         tcp6statemap[TCP6S_CLOSING] = 10;
         tcp6statemap[TCP6S_LAST_ACK] = 9;
         tcp6statemap[TCP6S_FIN_WAIT_2] = 7;
         tcp6statemap[TCP6S_TIME_WAIT] = 11;
         initialized++;
     }
 
     DEBUGMSGTL(("mibII/ipv6", "var_tcp6: "));
     DEBUGMSGOID(("mibII/ipv6", name, *length));
     DEBUGMSG(("mibII/ipv6", " %d\n", exact));
 
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
     if (!auto_nlist("tcbtable", (char *) &tcbtable, sizeof(tcbtable)))
         return NULL;
     first = p = (caddr_t)tcbtable.inpt_queue.cqh_first;
 #elif !defined(freebsd3) && !defined(darwin)
     {
     static struct in6pcb tcb6;
 
     if (!auto_nlist("tcb6", (char *) &tcb6, sizeof(tcb6)))
         return NULL;
     p = (caddr_t) tcb6.in6p_next;
     }
 #else
     {
         const char     *tcblist = "net.inet.tcp.pcblist";
         const char     *pp = tcblist;
         size_t          len;
 
         if (sysctlbyname(tcblist, 0, &len, 0, 0) < 0)
             return NULL;
         if ((sysctl_buf = malloc(len)) == NULL)
             return NULL;
         tcblist = pp;
         if (sysctlbyname(tcblist, sysctl_buf, &len, 0, 0) < 0) {
             free(sysctl_buf);
             return NULL;
         }
         oxig = (struct xinpgen *) sysctl_buf;
         xig = (struct xinpgen *) ((char *) oxig + oxig->xig_len);
         p = (caddr_t) ((char *) xig); /* silence compiler warning */
     }
 #endif
     found = savnameLen = 0;
     memcpy((char *) newname, (char *) vp->name,
            (int) vp->namelen * sizeof(oid));
     DEBUGMSGTL(("mibII/ipv6", "start: p=%x\n", p));
     while (
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
               p &&  p != first
 #elif !defined(freebsd3) && !defined(darwin)
               p && (u_long) p != auto_nlist_value("tcb6")
 #else
               xig->xig_len > sizeof(struct xinpgen)
 #endif
         ) {
         DEBUGMSGTL(("mibII/ipv6", "looping: p=%x\n", p));
 
 #if !defined(freebsd3) && !defined(darwin)
         if (!NETSNMP_KLOOKUP(p, (char *) &in6pcb, sizeof(in6pcb))) {
             DEBUGMSGTL(("mibII/ipv6", "klookup fail for tcb6 at %x\n",
                         p));
             found = 0;
             break;
         }
 #else
         in6pcb = ((struct xinpcb *) xig)->xi_inp;
 #endif
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         if (in6pcb.in6p_af != AF_INET6)
             goto skip;
 #elif defined(INP_ISIPV6)
 	if (!INP_ISIPV6(&in6pcb))
 	    goto skip;
 #elif defined(freebsd3) || defined(darwin)
         if (0 == (in6pcb.inp_vflag & INP_IPV6))
             goto skip;
 #endif
         if (!NETSNMP_KLOOKUP(in6pcb.in6p_ppcb, (char *) &tcp6cb, sizeof(tcp6cb))) {
             DEBUGMSGTL(("mibII/ipv6", "klookup fail for tcb6.tcp6cb at %x\n",
                         in6pcb.in6p_ppcb));
             found = 0;
             break;
         }
         j = (int) vp->namelen;
         for (i = 0; i < sizeof(struct in6_addr); i++)
             newname[j++] = in6pcb.in6p_laddr.s6_addr[i];
         newname[j++] = ntohs(in6pcb.inp_lport);
         for (i = 0; i < sizeof(struct in6_addr); i++)
             newname[j++] = in6pcb.in6p_faddr.s6_addr[i];
         newname[j++] = ntohs(in6pcb.inp_fport);
         if (IN6_IS_ADDR_LINKLOCAL(&in6pcb.in6p_laddr))
             newname[j++] =
                 ntohs(*(uint16_t *) & in6pcb.in6p_laddr.s6_addr[2]);
         else
             newname[j++] = 0;
 
         DEBUGMSGTL(("mibII/ipv6", "var_tcp6 new: %d %d ",
                         (int) vp->namelen, j));
         DEBUGMSGOID(("mibII/ipv6", newname, j));
         DEBUGMSG(("mibII/ipv6", " %d\n", exact));
 
 #if 1                           /* this is very odd but sometimes happen, and cause infinite loop */
         if (ntohs(in6pcb.inp_lport) == 0)
             goto skip;
 #endif
 
         result = snmp_oid_compare(name, *length, newname, j);
         if (exact && (result == 0)) {
                 memcpy(&savpcb, &in6pcb, sizeof(savpcb));
                 savnameLen = j;
                 memcpy(savname, newname, j * sizeof(oid));
                 found++;
                 break;
         } else if (!exact && (result < 0)) {
             /*
              *  take the least greater one
              */
             if ((savnameLen == 0) ||
               (snmp_oid_compare(savname, savnameLen, newname, j) > 0)) {
                 memcpy(&savpcb, &in6pcb, sizeof(savpcb));
                 savnameLen = j;
                 memcpy(savname, newname, j * sizeof(oid));
                 found++;
             }
         }
 
       skip:
 #if defined(__NetBSD__) && __NetBSD_Version__ >= 106250000	/*1.6Y*/
         p = (caddr_t)in6pcb.in6p_queue.cqe_next;
 #elif !defined(freebsd3) && !defined(darwin)
         p = (caddr_t)in6pcb.in6p_next;
 #else
         xig = (struct xinpgen *) ((char *) xig + xig->xig_len);
 #endif
     }
 #if defined(freebsd3) || defined(darwin)
     free(sysctl_buf);
 #endif
     DEBUGMSGTL(("mibII/ipv6", "found=%d\n", found));
     if (!found)
         return NULL;
     *length = savnameLen;
     memcpy((char *) name, (char *) savname, *length * sizeof(oid));
     memcpy(&in6pcb, &savpcb, sizeof(savpcb));
     *write_method = 0;
     *var_len = sizeof(long);    /* default to 'long' results */
 
 /*
     DEBUGMSGTL(("mibII/ipv6", "var_tcp6 found: "));
     DEBUGMSGOID(("mibII/ipv6", name, *length));
     DEBUGMSG(("mibII/ipv6", " %d\n", exact));
 */
     DEBUGMSGTL(("mibII/ipv6", "magic=%d\n", vp->magic));
     switch (vp->magic) {
     case IPV6TCPCONNSTATE:
         long_return = tcp6statemap[in6pcb.t_state];
         return (u_char *) & long_return;
     default:
         break;
     }
     ERROR_MSG("");
     return NULL;
 }
 
-#elif HAVE_KVM_GETFILES
+#elif defined(HAVE_KVM_GETFILES)
 
 u_char         *
 var_tcp6(register struct variable * vp,
diff --git a/agent/mibgroup/mibII/kernel_linux.c b/agent/mibgroup/mibII/kernel_linux.c
index c4f8bcf551..ccdc880287 100644
--- a/agent/mibgroup/mibII/kernel_linux.c
+++ b/agent/mibgroup/mibII/kernel_linux.c
@@ -1,21 +1,21 @@
 /*
  *  Linux kernel interface
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #include <errno.h>
 #include <stddef.h>
 
 #include "kernel_linux.h"
diff --git a/agent/mibgroup/mibII/mibII_common.h b/agent/mibgroup/mibII/mibII_common.h
index 668b6b3266..dedf399d7b 100644
--- a/agent/mibgroup/mibII/mibII_common.h
+++ b/agent/mibgroup/mibII/mibII_common.h
@@ -1,117 +1,117 @@
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_SYS_SYSMP_H
 #include <sys/sysmp.h>
 #endif
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #include <sys/tcpipstats.h>
 #endif
 #if defined(NETSNMP_IFNET_NEEDS_KERNEL) && !defined(_KERNEL)
 #define _KERNEL 1
 #define _I_DEFINED_KERNEL
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 #include <net/if.h>
 #ifdef _I_DEFINED_KERNEL
 #define _KERNEL 1
 #endif
 #endif
 #ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
 #ifdef _I_DEFINED_KERNEL
 #undef _KERNEL
 #endif
 
 #ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 #ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #ifdef HAVE_SYS_QUEUE_H
 #include <sys/queue.h>
 #endif
 /* IRIX 6.5 build breaks on sys/socketvar.h because _KMEMUSER brings in 
    sys/pda.h which doesn't compile */
 #ifndef irix6
 #ifdef HAVE_SYS_SOCKETVAR_H
 #include <sys/socketvar.h>
 #endif
 #endif  /* irix6 */
 #ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
 #ifdef HAVE_NETNETSNMP_ENABLE_IPV6_IP6_VAR_H
 #include <netinet6/ip6_var.h>
 #endif
 #endif
 #ifdef HAVE_NETINET_IN_PCB_H
 #include <netinet/in_pcb.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 #ifdef HAVE_STDINT_H
 #include <stdint.h>
 #endif
 
 #ifdef solaris2
 #include "kernel_sunos5.h"
 #else
 #include "kernel.h"
 #endif
 #ifdef linux
 #include "kernel_linux.h"
 #endif
 #ifdef NETBSD_STATS_VIA_SYSCTL
 #include "kernel_netbsd.h"
 #endif
 #if defined(NETSNMP_CAN_USE_SYSCTL) /* && defined(ICMPCTL_STATS) */
 #include "kernel_sysctl.h"
 #endif
 
 	/* or MIB_xxxCOUNTER_SYMBOL || hpux11 */
 #ifdef hpux
 #include <sys/mib.h>
 #include <netinet/mib_kern.h>
 #endif
 
 #ifdef cygwin
 #include <windows.h>
 #endif
diff --git a/agent/mibgroup/mibII/mta_sendmail.c b/agent/mibgroup/mibII/mta_sendmail.c
index 23de6b4827..e25c73adc3 100644
--- a/agent/mibgroup/mibII/mta_sendmail.c
+++ b/agent/mibgroup/mibII/mta_sendmail.c
@@ -1,100 +1,100 @@
 /*
  *  MTA-MIB implementation for sendmail - mibII/mta_sendmail.c
  *  Christoph Mammitzsch <Christoph.Mammitzsch@tu-clausthal.de>
  *
  * todo: put queue directory into description?
  *
  *  13.02.2002:
  *    - support sendmail 8.12 queue groups
  *
  *
  *  05.04.2000:
  *
  *    - supports sendmail 8.10.0 statistics files now
  *    - function read_option has been removed
  *
  *  12.04.2000:
  *
  *    - renamed configuration tokens:
  *        sendmail config        -> sendmail_config
  *        sendmail stats         -> sendmail_stats
  *        sendmail queue         -> sendmail_queue
  *        sendmail index         -> sendmail_index
  *        sendmail statcachetime -> sendmail_stats_t
  *        sendmail dircacetime   -> sendmail_queue_t
  *
  *    - now using snmpd_register_config_handler instead of config_parse_dot_conf
  *
  *  15.04.2000:
  *
  *    - introduced new function print_error
  *    - changed open_sendmailst and read_sendmailcf to use the new function
  *    - changed calls to open_sendmailst and read_sendmailcf
  *    - added some error handling to calls to chdir(), close() and closedir()
  *
  */
 
 
 /** "include files" */
 #ifdef __lint
 # define NETSNMP_NO_DEBUGGING 1    /* keeps lint from complaining about the DEBUGMSG* macros */
 #endif
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "mta_sendmail.h"
 
 #include <sys/types.h>
 
 #include <stdio.h>
 
 #include <ctype.h>
 
 #ifdef HAVE_STRING_H
 # include <string.h>
 #else
 # include <strings.h>
 #endif
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 
 #ifdef HAVE_FCNTL_H
 # include <fcntl.h>
 #endif
 
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 
 #ifdef HAVE_SYS_STAT_H
 # include <sys/stat.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <errno.h>
 #include <stdarg.h>
 
  /**/
 /** "macros and variables for registering the OID tree" */
     /*
      * prefix for all OIDs 
      */
diff --git a/agent/mibgroup/mibII/route_headers.h b/agent/mibgroup/mibII/route_headers.h
index fd58019b8d..71287604df 100644
--- a/agent/mibgroup/mibII/route_headers.h
+++ b/agent/mibgroup/mibII/route_headers.h
@@ -1,181 +1,181 @@
 #if defined(NETSNMP_CAN_USE_SYSCTL)
 
 #include <stddef.h>
 #include <stdlib.h>
 #include <syslog.h>
 #include <time.h>
 
 #include <sys/types.h>
 #include <sys/param.h>
 #include <sys/queue.h>
 #include <sys/socket.h>
 #include <sys/sysctl.h>
-#if HAVE_SYS_TIME_H
+#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 
 #include <net/if_dl.h>
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #include <net/route.h>
 #include <netinet/in.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "ip.h"
 #include "kernel.h"
 #include "interfaces.h"
 
 #else /* !NETSNMP_CAN_USE_SYSCTL */
 
 #define GATEWAY                 /* MultiNet is always configured this way! */
 #include <stdio.h>
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 #ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
 #ifdef HAVE_SYS_MBUF_H
 #include <sys/mbuf.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
 #ifdef HAVE_SYS_HASHING_H
 #include <sys/hashing.h>
 #endif
 #ifdef HAVE_NETINET_IN_VAR_H
 #include <netinet/in_var.h>
 #endif
 #define KERNEL                  /* to get routehash and RTHASHSIZ */
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #undef	KERNEL
 #ifdef RTENTRY_4_4
 #ifndef HAVE_STRUCT_RTENTRY_RT_UNIT
 #define rt_unit rt_refcnt       /* Reuse this field for device # */
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_DST
 #define rt_dst rt_nodes->rn_key
 #endif
 #else                           /* RTENTRY_4_3 */
 #ifndef HAVE_STRUCT_RTENTRY_RT_DST
 #define rt_dst rt_nodes->rn_key
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_HASH
 #define rt_hash rt_pad1
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_REFCNT
 #ifndef hpux10
 #define rt_refcnt rt_pad2
 #endif
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_USE
 #define rt_use rt_pad3
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_UNIT
 #define rt_unit rt_refcnt       /* Reuse this field for device # */
 #endif
 #endif
 #ifndef NULL
 #define NULL 0
 #endif
 #ifdef HAVE_KVM_OPENFILES
 #include <fcntl.h>
 #endif
 #ifdef HAVE_KVM_H
 #include <kvm.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 #ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #ifdef HAVE_NET_IF_DL_H
 #ifndef dynix
 #include <net/if_dl.h>
 #else
 #include <sys/net/if_dl.h>
 #endif
 #endif
 
 #ifdef HAVE_NLIST_H
 #include <nlist.h>
 #endif
 
 #ifdef solaris2
 #include "kernel_sunos5.h"
 /* Solaris 2.6/7 need sys/stream.h (mblk_t) to include inet/ip.h */
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 /* Solaris 2.6 needs inet/common.h (u16) to include inet/ip.h */
 #ifdef HAVE_INET_COMMON_H
 #include <inet/common.h>
 #endif
 #ifdef HAVE_INET_IP_H
 #include <inet/ip.h>
 #endif /* HAVE_INET_IP_H */
 #endif
 
 #ifdef HAVE_SYS_SYSCTL_H
 # ifdef CTL_NET
 #  ifdef PF_ROUTE
 #   ifdef NET_RT_DUMP
 #    define USE_SYSCTL_ROUTE_DUMP
 #   endif
 #  endif
 # endif
 #endif
 
 #ifdef cygwin
 #include <windows.h>
 #endif
 
 #endif /* !NETSNMP_CAN_USE_SYSCTL */
diff --git a/agent/mibgroup/mibII/route_write.c b/agent/mibgroup/mibII/route_write.c
index cbecfe81c5..03a6ca6ef2 100644
--- a/agent/mibgroup/mibII/route_write.c
+++ b/agent/mibgroup/mibII/route_write.c
@@ -1,93 +1,93 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_FILE_H
+#ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_SYS_MBUF_H
 #include <sys/mbuf.h>
 #endif
 
 
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <errno.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "ip.h"
 #include "route_write.h"
 #include "var_route.h"
 
 #if defined(cygwin) || defined(mingw32)
 #include <windows.h>
 #include <winerror.h>
 #endif
 
 #if !defined (WIN32) && !defined (cygwin)
 
 #ifndef HAVE_STRUCT_RTENTRY_RT_DST
 #define rt_dst rt_nodes->rn_key
 #endif
 #ifndef HAVE_STRUCT_RTENTRY_RT_HASH
 #define rt_hash rt_pad1
 #endif
 
 #ifdef irix6
 #define SIOCADDRT SIOCADDMULTI
 #define SIOCDELRT SIOCDELMULTI
 #endif
 
 #ifdef linux
 #define NETSNMP_ROUTE_WRITE_PROTOCOL PF_ROUTE
 #else
 #define NETSNMP_ROUTE_WRITE_PROTOCOL 0
 #endif
diff --git a/agent/mibgroup/mibII/system_mib.c b/agent/mibgroup/mibII/system_mib.c
index b26e2decf2..3d686f283a 100644
--- a/agent/mibgroup/mibII/system_mib.c
+++ b/agent/mibgroup/mibII/system_mib.c
@@ -1,51 +1,51 @@
 /*
  *  System MIB group implementation - system.c
  *
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 
 #ifdef HAVE_UTSNAME_H
 #include <utsname.h>
 #else
 #ifdef HAVE_SYS_UTSNAME_H
 #include <sys/utsname.h>
 #endif
 #endif
 
 #if defined(cygwin) || defined(mingw32)
 #include <winerror.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/sysORTable.h>
 
 #include "util_funcs.h"
 #include "system_mib.h"
 #include "updates.h"
 #include "agent_global_vars.h"
@@ -214,11 +214,11 @@ static int
 handle_sysServices(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
 {
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
     if (reqinfo->mode == MODE_GET && !sysServicesConfiged)
         netsnmp_request_set_error(requests, SNMP_NOSUCHINSTANCE);
 #endif
     return SNMP_ERR_NOERROR;
 }
diff --git a/agent/mibgroup/mibII/tcp.c b/agent/mibgroup/mibII/tcp.c
index ac934e22bb..e9d47556f7 100644
--- a/agent/mibgroup/mibII/tcp.c
+++ b/agent/mibgroup/mibII/tcp.c
@@ -1,71 +1,71 @@
 
 /*
  *  TCP MIB group implementation - tcp.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include "mibII_common.h"
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #ifdef HAVE_SYS_PROTOSW_H
 #include <sys/protosw.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #if defined(osf4) || defined(osf5) || defined(aix4) || defined(hpux10)
 /*
  * these are undefed to remove a stupid warning on osf compilers
  * because they get redefined with a slightly different notation of the
  * same value.  -- Wes 
  */
 #undef TCP_NODELAY
 #undef TCP_MAXSEG
 #endif
 #ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
 #ifdef HAVE_NETINET_TCPIP_H
 #include <netinet/tcpip.h>
 #endif
 #ifdef HAVE_NETINET_TCP_TIMER_H
 #include <netinet/tcp_timer.h>
 #endif
 #ifdef HAVE_NETINET_TCP_VAR_H
 #include <netinet/tcp_var.h>
 #endif
 #ifdef HAVE_NETINET_TCP_FSM_H
 #include <netinet/tcp_fsm.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/sysORTable.h>
 
 #include "util_funcs/MIB_STATS_CACHE_TIMEOUT.h"
 #include "tcp.h"
 #include "tcpTable.h"
 
 #ifndef MIB_STATS_CACHE_TIMEOUT
 #define MIB_STATS_CACHE_TIMEOUT	5
 #endif
 #ifndef TCP_STATS_CACHE_TIMEOUT
 #define TCP_STATS_CACHE_TIMEOUT	MIB_STATS_CACHE_TIMEOUT
 #endif
 
 #if defined(HAVE_LIBPERFSTAT_H) && (defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)) && !defined(FIRST_PROTOCOL)
 #ifdef HAVE_SYS_PROTOSW_H
 #include <sys/protosw.h>
 #endif
 #include <libperfstat.h>
 #ifdef FIRST_PROTOCOL
diff --git a/agent/mibgroup/mibII/tcpTable.c b/agent/mibgroup/mibII/tcpTable.c
index 01dc1b691b..247d51d70c 100644
--- a/agent/mibgroup/mibII/tcpTable.c
+++ b/agent/mibgroup/mibII/tcpTable.c
@@ -79,41 +79,41 @@ typedef struct netsnmp_tcpConnEntry_s netsnmp_tcpConnEntry;
 struct netsnmp_tcpConnEntry_s {
     mib2_tcpConnEntry_t   entry;
     netsnmp_tcpConnEntry *inp_next;
 };
 #define	TCPTABLE_ENTRY_TYPE	netsnmp_tcpConnEntry
 #define	TCPTABLE_STATE		entry.tcpConnState 
 #define	TCPTABLE_LOCALADDRESS	entry.tcpConnLocalAddress 
 #define	TCPTABLE_LOCALPORT	entry.tcpConnLocalPort 
 #define	TCPTABLE_REMOTEADDRESS	entry.tcpConnRemAddress 
 #define	TCPTABLE_REMOTEPORT	entry.tcpConnRemPort 
 #define	TCPTABLE_IS_LINKED_LIST
 
 #elif defined(HAVE_IPHLPAPI_H)
 #include <iphlpapi.h>
 #define	TCPTABLE_ENTRY_TYPE	MIB_TCPROW
 #define	TCPTABLE_STATE		dwState 
 #define	TCPTABLE_LOCALADDRESS	dwLocalAddr
 #define	TCPTABLE_LOCALPORT	dwLocalPort 
 #define	TCPTABLE_REMOTEADDRESS	dwRemoteAddr 
 #define	TCPTABLE_REMOTEPORT	dwRemotePort 
 #define	TCPTABLE_IS_TABLE
 
 #elif defined(linux)
 #define	TCPTABLE_ENTRY_TYPE	struct inpcb 
 #define	TCPTABLE_STATE		inp_state 
 #define	TCPTABLE_LOCALADDRESS	inp_laddr.s_addr 
 #define	TCPTABLE_LOCALPORT	inp_lport
 #define	TCPTABLE_REMOTEADDRESS	inp_faddr.s_addr 
 #define	TCPTABLE_REMOTEPORT	inp_fport
 #define	TCPTABLE_IS_LINKED_LIST
 
-#elif HAVE_KVM_GETFILES
+#elif defined(HAVE_KVM_GETFILES)
 #define	TCPTABLE_ENTRY_TYPE	struct kinfo_file
 #define	TCPTABLE_STATE		t_state 
 #define	TCPTABLE_LOCALADDRESS	inp_laddru[0]
 #define	TCPTABLE_LOCALPORT	inp_lport
 #define	TCPTABLE_REMOTEADDRESS	inp_faddru[0]
 #define	TCPTABLE_REMOTEPORT	inp_fport
 #define	TCPTABLE_IS_TABLE
 
 #else			/* everything else */
diff --git a/agent/mibgroup/mibII/udp.c b/agent/mibgroup/mibII/udp.c
index 09b0112075..7b0f40f055 100644
--- a/agent/mibgroup/mibII/udp.c
+++ b/agent/mibgroup/mibII/udp.c
@@ -178,188 +178,188 @@ int
 udp_handler(netsnmp_mib_handler          *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info   *reqinfo,
             netsnmp_request_info         *requests)
 {
     netsnmp_request_info  *request;
     netsnmp_variable_list *requestvb;
     long     ret_value = -1;
     oid      subid;
     int      type = ASN_COUNTER;
 
     /*
      * The cached data should already have been loaded by the
      *    cache handler, higher up the handler chain.
      * But just to be safe, check this and load it manually if necessary
      */
 #if defined(_USE_PERFSTAT_PROTOCOL)
     udp_load(NULL, NULL);
 #endif
 
 
     /*
      * 
      *
      */
     DEBUGMSGTL(("mibII/udpScalar", "Handler - mode %s\n",
                     se_find_label_in_slist("agent_mode", reqinfo->mode)));
     switch (reqinfo->mode) {
     case MODE_GET:
         for (request=requests; request; request=request->next) {
             requestvb = request->requestvb;
             subid = requestvb->name[OID_LENGTH(udp_oid)];  /* XXX */
             DEBUGMSGTL(( "mibII/udpScalar", "oid: "));
             DEBUGMSGOID(("mibII/udpScalar", requestvb->name,
                                             requestvb->name_length));
             DEBUGMSG((   "mibII/udpScalar", "\n"));
 
             switch (subid) {
 #ifdef USES_SNMP_DESIGNED_UDPSTAT
     case UDPINDATAGRAMS:
         ret_value = udpstat.udpInDatagrams;
         break;
     case UDPNOPORTS:
 #ifdef solaris2
         ret_value = udp_load(NULL, (void *)UDPNOPORTS);
 	if (ret_value == -1) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
 	}
         break;
 #else
         ret_value = udpstat.udpNoPorts;
         break;
 #endif
     case UDPOUTDATAGRAMS:
         ret_value = udpstat.udpOutDatagrams;
         break;
     case UDPINERRORS:
         ret_value = udpstat.udpInErrors;
         break;
 #elif defined(USES_TRADITIONAL_UDPSTAT) && !defined(_USE_PERFSTAT_PROTOCOL)
 #ifdef HAVE_SYS_TCPIPSTATS_H
     /*
      * This actually reads statistics for *all* the groups together,
      * so we need to isolate the UDP-specific bits.  
      */
 #define udpstat          udpstat.udpstat
 #endif
     case UDPINDATAGRAMS:
-#if HAVE_STRUCT_UDPSTAT_UDPS_IPACKETS
+#ifdef HAVE_STRUCT_UDPSTAT_UDPS_IPACKETS
         ret_value = udpstat.udps_ipackets;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
 
     case UDPNOPORTS:
-#if HAVE_STRUCT_UDPSTAT_UDPS_NOPORT
+#ifdef HAVE_STRUCT_UDPSTAT_UDPS_NOPORT
         ret_value = udpstat.udps_noport;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
 
     case UDPOUTDATAGRAMS:
-#if HAVE_STRUCT_UDPSTAT_UDPS_OPACKETS
+#ifdef HAVE_STRUCT_UDPSTAT_UDPS_OPACKETS
         ret_value = udpstat.udps_opackets;
         break;
 #else
         netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
         continue;
 #endif
 
     case UDPINERRORS:
         ret_value = udpstat.udps_hdrops + udpstat.udps_badsum +
 #ifdef HAVE_STRUCT_UDPSTAT_UDPS_DISCARD
             udpstat.udps_discard +
 #endif
 #ifdef HAVE_STRUCT_UDPSTAT_UDPS_FULLSOCK
             udpstat.udps_fullsock +
 #endif
             udpstat.udps_badlen;
         break;
 #ifdef HAVE_SYS_TCPIPSTATS_H
 #undef udpstat
 #endif
 #elif defined(hpux11)
     case UDPINDATAGRAMS:
     case UDPNOPORTS:
     case UDPOUTDATAGRAMS:
     case UDPINERRORS:
 	/*
 	 * This is a bit of a hack, to shoehorn the HP-UX 11
 	 * single-object retrieval approach into the caching
 	 * architecture.
 	 */
 	if (udp_load(NULL, (void*)subid) == -1 ) {
             netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
             continue;
 	}
         ret_value = udpstat;
         break;
 #elif defined(WIN32)
     case UDPINDATAGRAMS:
         ret_value = udpstat.dwInDatagrams;
         break;
     case UDPNOPORTS:
         ret_value = udpstat.dwNoPorts;
         break;
     case UDPOUTDATAGRAMS:
         ret_value = udpstat.dwOutDatagrams;
         break;
     case UDPINERRORS:
         ret_value = udpstat.dwInErrors;
         break;
 #elif defined(_USE_PERFSTAT_PROTOCOL)
     case UDPINDATAGRAMS:
         ret_value = ps_proto.u.udp.ipackets;
         break;
     case UDPNOPORTS:
         ret_value = ps_proto.u.udp.no_socket;
         break;
     case UDPOUTDATAGRAMS:
         ret_value = ps_proto.u.udp.opackets;
         break;
     case UDPINERRORS:
         ret_value = ps_proto.u.udp.ierrors;
         break;
 #endif			/* USES_SNMP_DESIGNED_UDPSTAT */
 
 	    }
 	    snmp_set_var_typed_value(request->requestvb, (u_char)type,
 			             (u_char *)&ret_value, sizeof(ret_value));
 	}
         break;
 
     case MODE_GETNEXT:
     case MODE_GETBULK:
 #ifndef NETSNMP_NO_WRITE_SUPPORT
     case MODE_SET_RESERVE1:
     case MODE_SET_RESERVE2:
     case MODE_SET_ACTION:
     case MODE_SET_COMMIT:
     case MODE_SET_FREE:
     case MODE_SET_UNDO:
         snmp_log(LOG_WARNING, "mibII/udp: Unsupported mode (%d)\n",
                                reqinfo->mode);
         break;
 #endif /* !NETSNMP_NO_WRITE_SUPPORT */
     default:
         snmp_log(LOG_WARNING, "mibII/udp: Unrecognised mode (%d)\n",
                                reqinfo->mode);
         break;
     }
 
     return SNMP_ERR_NOERROR;
 }
 
 
         /*********************
 	 *
 	 *  Internal implementation functions
 	 *
 	 *********************/
 
 #ifdef hpux11
diff --git a/agent/mibgroup/mibII/vacm_conf.c b/agent/mibgroup/mibII/vacm_conf.c
index 96aeab4226..a611be86bc 100644
--- a/agent/mibgroup/mibII/vacm_conf.c
+++ b/agent/mibgroup/mibII/vacm_conf.c
@@ -1,60 +1,60 @@
 /*
  * SNMPv3 View-based Access Control Model
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/agent_callbacks.h>
 #include "vacm_conf.h"
 
 #include "snmpd.h"
 
 /**
  * Registers the VACM token handlers for inserting rows into the vacm tables.
  * These tokens will be recognised by both 'snmpd' and 'snmptrapd'.
  */
diff --git a/agent/mibgroup/mibII/vacm_context.c b/agent/mibgroup/mibII/vacm_context.c
index aab1688b8f..09d2bf0380 100644
--- a/agent/mibgroup/mibII/vacm_context.c
+++ b/agent/mibgroup/mibII/vacm_context.c
@@ -1,25 +1,25 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 
 #include "vacm_context.h"
diff --git a/agent/mibgroup/mibII/vacm_vars.c b/agent/mibgroup/mibII/vacm_vars.c
index 1d7212ac38..e99980de03 100644
--- a/agent/mibgroup/mibII/vacm_vars.c
+++ b/agent/mibgroup/mibII/vacm_vars.c
@@ -1,66 +1,66 @@
 /*
  * SNMPv3 View-based Access Control Model
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/sysORTable.h>
 #include "vacm_vars.h"
 #include "util_funcs/header_generic.h"
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
diff --git a/agent/mibgroup/mibII/var_route.c b/agent/mibgroup/mibII/var_route.c
index f985ce4d5d..24c95ce071 100644
--- a/agent/mibgroup/mibII/var_route.c
+++ b/agent/mibgroup/mibII/var_route.c
@@ -104,211 +104,211 @@ u_char         *
 var_ipRouteEntry(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * object identifier is of form:
      * 1.3.6.1.2.1.4.21.1.1.A.B.C.D,  where A.B.C.D is IP address.
      * IPADDR starts at offset 10.
      */
     struct rt_msghdr *rtp, *saveRtp = 0;
     register int    Save_Valid, result;
     static int      saveNameLen = 0, saveExact = 0;
     static oid      saveName[MAX_OID_LEN], Current[MAX_OID_LEN];
     u_char         *cp;
     u_char         *ap;
     oid            *op;
     static in_addr_t addr_ret;
 
     *write_method = NULL;  /* write_rte;  XXX:  SET support not really implemented */
 
 #if 0
   /** 
   ** this optimisation fails, if there is only a single route avail.
   ** it is a very special case, but better leave it out ...
   **/
 #if 0
     if (rtsize <= 1)
         Save_Valid = 0;
     else
 #endif                          /* 0 */
         /*
          *  OPTIMIZATION:
          *
          *  If the name was the same as the last name, with the possible
          *  exception of the [9]th token, then don't read the routing table
          *
          */
 
     if ((saveNameLen == *length) && (saveExact == exact)) {
         register int    temp = name[9];
         name[9] = 0;
         Save_Valid =
             (snmp_oid_compare(name, *length, saveName, saveNameLen) == 0);
         name[9] = temp;
     } else
         Save_Valid = 0;
 
     if (Save_Valid && saveRtp) {
         register int    temp = name[9]; /* Fix up 'lowest' found entry */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         name[9] = temp;
         *length = 14;
         rtp = saveRtp;
     } else {
 #endif                          /* 0 */
         /*
          * fill in object part of name for current (less sizeof instance part) 
          */
 
         memcpy((char *) Current, (char *) vp->name,
                (int) (vp->namelen) * sizeof(oid));
 
 #if 0
         /*
          *  Only reload if this is the start of a wildcard
          */
         if (*length < 14) {
             Route_Scan_Reload();
         }
 #else
         Route_Scan_Reload();
 #endif
         for (ap = all_routes; ap < all_routes_end; ap += rtp->rtm_msglen) {
             rtp = (struct rt_msghdr *) ap;
             if (rtp->rtm_type == 0)
                 break;
             if (rtp->rtm_version != RTM_VERSION) {
                 snmp_log(LOG_ERR,
                          "routing socket message version mismatch (%d instead of %d)\n",
                          rtp->rtm_version, RTM_VERSION);
                 break;
             }
             if (rtp->rtm_type != RTM_GET) {
                 snmp_log(LOG_ERR,
                          "routing socket returned message other than GET (%d)\n",
                          rtp->rtm_type);
                 continue;
             }
             if (!(rtp->rtm_addrs & RTA_DST))
                 continue;
             cp = (u_char *) get_in_address((struct sockaddr *) (rtp + 1),
                                            rtp->rtm_addrs, RTA_DST);
             if (cp == NULL)
                 return NULL;
 
             op = Current + 10;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
 
             result = snmp_oid_compare(name, *length, Current, 14);
             if ((exact && (result == 0)) || (!exact && (result < 0)))
                 break;
         }
         if (ap >= all_routes_end || rtp->rtm_type == 0)
             return 0;
         /*
          *  Save in the 'cache'
          */
         memcpy((char *) saveName, (char *) name,
                SNMP_MIN(*length, MAX_OID_LEN) * sizeof(oid));
         saveName[9] = '\0';
         saveNameLen = *length;
         saveExact = exact;
         saveRtp = rtp;
         /*
          *  Return the name
          */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         *length = 14;
 #if 0
     }
 #endif                          /* 0 */
 
     *var_len = sizeof(long_return);
 
     switch (vp->magic) {
     case IPROUTEDEST:
     	*var_len = sizeof(addr_ret);
         return (u_char *) get_in_address((struct sockaddr *) (rtp + 1),
                                          rtp->rtm_addrs, RTA_DST);
     case IPROUTEIFINDEX:
         long_return = (u_long) rtp->rtm_index;
         return (u_char *) & long_return;
     case IPROUTEMETRIC1:
         long_return = (rtp->rtm_flags & RTF_UP) ? 1 : 0;
         return (u_char *) & long_return;
     case IPROUTEMETRIC2:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC3:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC4:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC5:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTENEXTHOP:
     	*var_len = sizeof(addr_ret);
     	return (u_char *) get_in_address((struct sockaddr *) (rtp + 1),
                                          rtp->rtm_addrs, RTA_GATEWAY);
     case IPROUTETYPE:
         if (rtp->rtm_flags & RTF_UP) {
             if (rtp->rtm_flags & RTF_GATEWAY) {
                 long_return = 4;        /*  indirect(4)  */
             } else {
                 long_return = 3;        /*  direct(3)  */
             }
         } else {
             long_return = 2;    /*  invalid(2)  */
         }
         return (u_char *) & long_return;
     case IPROUTEPROTO:
         long_return = (rtp->rtm_flags & RTF_DYNAMIC)
             ? 10 : (rtp->rtm_flags & RTF_STATIC)
             ? 2 : (rtp->rtm_flags & RTF_DYNAMIC) ? 4 : 1;
         return (u_char *) & long_return;
     case IPROUTEAGE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;
         return (u_char *) & long_return;
     case IPROUTEMASK:
     	*var_len = sizeof(addr_ret);   	     
         if (rtp->rtm_flags & RTF_HOST) {
             addr_ret = 0x00000001;
             return (u_char *) & addr_ret;
         } else {
             return (u_char *) get_in_address((struct sockaddr *) (rtp + 1),
                                              rtp->rtm_addrs, RTA_NETMASK);
         }
     case IPROUTEINFO:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipRouteEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #else                           /* not USE_SYSCTL_ROUTE_DUMP */
 
 #ifdef hpux11
@@ -429,276 +429,276 @@ u_char         *
 var_ipRouteEntry(struct variable * vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * object identifier is of form:
      * 1.3.6.1.2.1.4.21.1.1.A.B.C.D,  where A.B.C.D is IP address.
      * IPADDR starts at offset 10.
      */
     register int    Save_Valid, result, RtIndex;
     static size_t   saveNameLen = 0;
     static int      saveExact = 0, saveRtIndex = 0;
     static oid      saveName[MAX_OID_LEN], Current[MAX_OID_LEN];
     u_char         *cp;
     oid            *op;
     static in_addr_t addr_ret;
 #ifdef NEED_KLGETSA
     struct sockaddr_in *sa;
 #endif
 #if !defined(linux) && !defined(hpux11)
     struct ifnet    rt_ifnet;
     struct in_ifaddr rt_ifnetaddr;
 #endif
 
     *write_method = NULL;  /* write_rte;  XXX:  SET support not really implemented */
 
     /** 
      ** this optimisation fails, if there is only a single route avail.
      ** it is a very special case, but better leave it out ...
      **/
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
     saveNameLen = 0;
 #endif
     if (rtsize <= 1)
         Save_Valid = 0;
     else
         /*
          *  OPTIMIZATION:
          *
          *  If the name was the same as the last name, with the possible
          *  exception of the [9]th token, then don't read the routing table
          *
          */
 
     if ((saveNameLen == *length) && (saveExact == exact)) {
         register int    temp = name[9];
         name[9] = 0;
         Save_Valid =
             (snmp_oid_compare(name, *length, saveName, saveNameLen) == 0);
         name[9] = temp;
     } else
         Save_Valid = 0;
 
     if (Save_Valid) {
         register int    temp = name[9]; /* Fix up 'lowest' found entry */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         name[9] = temp;
         *length = 14;
         RtIndex = saveRtIndex;
     } else {
         /*
          * fill in object part of name for current (less sizeof instance part) 
          */
 
         memcpy((char *) Current, (char *) vp->name,
                (int) (vp->namelen) * sizeof(oid));
 
 #if 0
         /*
          *  Only reload if this is the start of a wildcard
          */
         if (*length < 14) {
             Route_Scan_Reload();
         }
 #else
         Route_Scan_Reload();
 #endif
         for (RtIndex = 0; RtIndex < rtsize; RtIndex++) {
 #ifdef NEED_KLGETSA
             sa = klgetsa((struct sockaddr_in *) rthead[RtIndex]->rt_dst);
             cp = (u_char *) & (sa->sin_addr.s_addr);
 #elif defined(hpux11)
             cp = (u_char *) & rt[RtIndex].Dest;
 #else
             cp = (u_char *) &
                 (((struct sockaddr_in *) &(rthead[RtIndex]->rt_dst))->
                  sin_addr.s_addr);
 #endif
             op = Current + 10;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
 
             result = snmp_oid_compare(name, *length, Current, 14);
             if ((exact && (result == 0)) || (!exact && (result < 0)))
                 break;
         }
         if (RtIndex >= rtsize)
             return (NULL);
         /*
          *  Save in the 'cache'
          */
         memcpy((char *) saveName, (char *) name,
                SNMP_MIN(*length, MAX_OID_LEN) * sizeof(oid));
         saveName[9] = 0;
         saveNameLen = *length;
         saveExact = exact;
         saveRtIndex = RtIndex;
         /*
          *  Return the name
          */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         *length = 14;
     }
 
     *var_len = sizeof(long_return);
 
     switch (vp->magic) {
     case IPROUTEDEST:
         *var_len = sizeof(addr_ret);
 #ifdef NEED_KLGETSA
         sa = klgetsa((struct sockaddr_in *) rthead[RtIndex]->rt_dst);
         return (u_char *) & (sa->sin_addr.s_addr);
 #elif defined(hpux11)
         addr_ret = rt[RtIndex].Dest;
         return (u_char *) & addr_ret;
 #else
         return (u_char *) & ((struct sockaddr_in *) &rthead[RtIndex]->
                              rt_dst)->sin_addr.s_addr;
 #endif
     case IPROUTEIFINDEX:
 #ifdef hpux11
         long_return = rt[RtIndex].IfIndex;
 #else
         long_return = (u_long) rthead[RtIndex]->rt_unit;
 #endif
         return (u_char *) & long_return;
     case IPROUTEMETRIC1:
 #ifdef hpux11
         long_return = rt[RtIndex].Metric1;
 #else
         long_return = (rthead[RtIndex]->rt_flags & RTF_GATEWAY) ? 1 : 0;
 #endif
         return (u_char *) & long_return;
     case IPROUTEMETRIC2:
 #ifdef hpux11
         long_return = rt[RtIndex].Metric2;
         return (u_char *) & long_return;
 #elif defined(NETSNMP_NO_DUMMY_VALUES)
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC3:
 #ifdef hpux11
         long_return = rt[RtIndex].Metric3;
         return (u_char *) & long_return;
 #elif defined(NETSNMP_NO_DUMMY_VALUES)
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC4:
 #ifdef hpux11
         long_return = rt[RtIndex].Metric4;
         return (u_char *) & long_return;
 #elif defined(NETSNMP_NO_DUMMY_VALUES)
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC5:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = -1;
         return (u_char *) & long_return;
     case IPROUTENEXTHOP:
         *var_len = sizeof(addr_ret);
 #ifdef NEED_KLGETSA
         sa = klgetsa((struct sockaddr_in *) rthead[RtIndex]->rt_gateway);
         return (u_char *) & (sa->sin_addr.s_addr);
 #elif defined(hpux11)
         addr_ret = rt[RtIndex].NextHop;
         return (u_char *) & addr_ret;
 #else
         return (u_char *) & ((struct sockaddr_in *) &rthead[RtIndex]->
                              rt_gateway)->sin_addr.s_addr;
 #endif                          /* *bsd */
     case IPROUTETYPE:
 #ifdef hpux11
         long_return = rt[RtIndex].Type;
 #else
         if (rthead[RtIndex]->rt_flags & RTF_UP) {
             if (rthead[RtIndex]->rt_flags & RTF_GATEWAY) {
                 long_return = 4;        /*  indirect(4)  */
             } else {
                 long_return = 3;        /*  direct(3)  */
             }
         } else {
             long_return = 2;    /*  invalid(2)  */
         }
 #endif
         return (u_char *) & long_return;
     case IPROUTEPROTO:
 #ifdef hpux11
         long_return = rt[RtIndex].Proto;
 #else
         long_return = (rthead[RtIndex]->rt_flags & RTF_DYNAMIC) ? 4 : 2;
 #endif
         return (u_char *) & long_return;
     case IPROUTEAGE:
 #ifdef hpux11
         long_return = rt[RtIndex].Age;
         return (u_char *) & long_return;
 #elif defined(NETSNMP_NO_DUMMY_VALUES)
         return NULL;
 #endif
         long_return = 0;
         return (u_char *) & long_return;
     case IPROUTEMASK:
         *var_len = sizeof(addr_ret);
 #ifdef NEED_KLGETSA
         /*
          * XXX - Almost certainly not right
          * but I don't have a suitable system to test this on 
          */
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         addr_ret = 0;
 #elif defined(hpux11)
         addr_ret = rt[RtIndex].Mask;
         return (u_char *) & addr_ret;
 #else                           /* !NEED_KLGETSA && !hpux11 */
         if (((struct sockaddr_in *) &rthead[RtIndex]->rt_dst)->sin_addr.
             s_addr == 0)
             addr_ret = 0;    /* Default route */
         else {
 #ifndef linux
             if (!NETSNMP_KLOOKUP(rthead[RtIndex]->rt_ifp,
                     (char *) &rt_ifnet, sizeof(rt_ifnet))) {
                 DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
                 return NULL;
             }
             if (!NETSNMP_KLOOKUP(rt_ifnet.if_addrlist,
                     (char *) &rt_ifnetaddr, sizeof(rt_ifnetaddr))) {
                 DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
                 return NULL;
             }
 
             addr_ret = rt_ifnetaddr.ia_subnetmask;
 #else                           /* linux */
             cp = (u_char *) &
                 (((struct sockaddr_in *) &(rthead[RtIndex]->rt_dst))->
                  sin_addr.s_addr);
             return (u_char *) &
                 (((struct sockaddr_in *) &(rthead[RtIndex]->rt_genmask))->
                  sin_addr.s_addr);
 #endif                          /* linux */
         }
 #endif                          /* NEED_KLGETSA */
         return (u_char *) & addr_ret;
     case IPROUTEINFO:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipRouteEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #else                           /* solaris2 */
@@ -899,87 +899,87 @@ static void
 load_rtentries(struct radix_node *pt)
 {
     struct radix_node node;
     RTENTRY         rt;
     struct ifnet    ifnet;
     char            name[16], temp[16];
-#if !HAVE_STRUCT_IFNET_IF_XNAME
+#if !defined(HAVE_STRUCT_IFNET_IF_XNAME)
     register char  *cp;
 #endif
 
     if (!NETSNMP_KLOOKUP(pt, (char *) &node, sizeof(struct radix_node))) {
         DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
         return;
     }
     if (node.rn_b >= 0) {
         load_rtentries(node.rn_r);
         load_rtentries(node.rn_l);
     } else {
         if (node.rn_flags & RNF_ROOT) {
             /*
              * root node 
              */
             if (node.rn_dupedkey)
                 load_rtentries(node.rn_dupedkey);
             return;
         }
         /*
          * get the route 
          */
         if (!NETSNMP_KLOOKUP(pt, (char *) &rt, sizeof(RTENTRY))) {
             DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
             return;
         }
 
         if (rt.rt_ifp != 0) {
             if (!NETSNMP_KLOOKUP(rt.rt_ifp, (char *) &ifnet, sizeof(ifnet))) {
                 DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
                 return;
             }
-#if HAVE_STRUCT_IFNET_IF_XNAME
+#ifdef HAVE_STRUCT_IFNET_IF_XNAME
 #if defined(netbsd1) || defined(openbsd2)
             strlcpy(name, ifnet.if_xname, sizeof(name));
 #else
             if (!NETSNMP_KLOOKUP(ifnet.if_xname, name, sizeof name)) {
                 DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
                 return;
             }
 #endif
             name[sizeof(name) - 1] = '\0';
 #else
 #ifdef NETSNMP_FEATURE_CHECKIN
             /* this exists here just so we don't copy ifdef logic elsewhere */
             netsnmp_feature_require(string_append_int);
 #endif
             if (!NETSNMP_KLOOKUP(ifnet.if_name, name, sizeof name)) {
                 DEBUGMSGTL(("mibII/var_route", "klookup failed\n"));
                 return;
             }
             name[sizeof(name) - 1] = '\0';
             cp = (char *) strchr(name, '\0');
             string_append_int(cp, ifnet.if_unit);
 #endif
 #ifdef NETSNMP_FEATURE_CHECKIN
             netsnmp_feature_require(interface_legacy)
 #endif /* NETSNMP_FEATURE_CHECKIN */
             Interface_Scan_Init();
             rt.rt_unit = 0;
             while (Interface_Scan_Next
                    ((short *) &(rt.rt_unit), temp, NULL, NULL) != 0) {
                 if (strcmp(name, temp) == 0)
                     break;
             }
         }
-#if CHECK_RT_FLAGS
+#ifdef CHECK_RT_FLAGS
         if (((rt.rt_flags & RTF_CLONING) != RTF_CLONING)
             && ((rt.rt_flags & RTF_LLINFO) != RTF_LLINFO)) {
 #endif
             append_rtentry(&rt);
-#if CHECK_RT_FLAGS
+#ifdef CHECK_RT_FLAGS
         }
 #endif
 
         if (node.rn_dupedkey)
             load_rtentries(node.rn_dupedkey);
     }
 }
 #endif                          /* RTENTRY_4_4 && !hpux11 */
@@ -1653,219 +1653,219 @@ u_char         *
 var_ipRouteEntry(struct variable *vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * object identifier is of form:
      * 1.3.6.1.2.1.4.21.1.?.A.B.C.D,  where A.B.C.D is IP address.
      * IPADDR starts at offset 10.
      */
     register int    Save_Valid, result, RtIndex = 0;
     static int      saveNameLen = 0, saveExact = 0, saveRtIndex =
         0, rtsize = 0;
     static oid      saveName[MAX_OID_LEN], Current[MAX_OID_LEN];
     u_char         *cp;
     oid            *op;
     DWORD           status = NO_ERROR;
     DWORD           dwActualSize = 0;
     static PMIB_IPFORWARDTABLE pIpRtrTable = NULL;
     struct timeval  now;
     static time_t    Time_Of_Last_Reload;
     static in_addr_t addr_ret;
 
 
     /** 
      ** this optimisation fails, if there is only a single route avail.
      ** it is a very special case, but better leave it out ...
      **/
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
     saveNameLen = 0;
 #endif
     if (route_row == NULL) {
         /*
          * Free allocated memory in case of SET request's FREE phase 
          */
         route_row = (PMIB_IPFORWARDROW) malloc(sizeof(MIB_IPFORWARDROW));
     }
     netsnmp_get_monotonic_clock(&now);
     if ((rtsize <= 1) || (Time_Of_Last_Reload + 5 <= now.tv_sec))
         Save_Valid = 0;
     else
         /*
          *  OPTIMIZATION:
          *
          *  If the name was the same as the last name, with the possible
          *  exception of the [9]th token, then don't read the routing table
          *
          */
 
     if ((saveNameLen == (int) *length) && (saveExact == exact)) {
         register int    temp = name[9];
         name[9] = 0;
         Save_Valid =
             (snmp_oid_compare(name, *length, saveName, saveNameLen) == 0);
         name[9] = temp;
     } else
         Save_Valid = 0;
 
     if (Save_Valid) {
         register int    temp = name[9]; /* Fix up 'lowest' found entry */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         name[9] = temp;
         *length = 14;
         RtIndex = saveRtIndex;
     } else {
         /*
          * fill in object part of name for current(less sizeof instance part) 
          */
 
         memcpy((char *) Current, (char *) vp->name,
                (int) (vp->namelen) * sizeof(oid));
 
 
         if ((Time_Of_Last_Reload + 5 <= now.tv_sec)
             || (pIpRtrTable == NULL)) {
             if (pIpRtrTable != NULL)
                 free(pIpRtrTable);
             Time_Of_Last_Reload = now.tv_sec;
             /*
              * query for buffer size needed 
              */
             status = GetIpForwardTable(pIpRtrTable, &dwActualSize, TRUE);
             if (status == ERROR_INSUFFICIENT_BUFFER) {
                 pIpRtrTable = (PMIB_IPFORWARDTABLE) malloc(dwActualSize);
                 if (pIpRtrTable != NULL) {
                     /*
                      * Get the sorted IP Route Table 
                      */
                     status =
                         GetIpForwardTable(pIpRtrTable, &dwActualSize,
                                           TRUE);
                 }
             }
         }
         if (status == NO_ERROR) {
             rtsize = pIpRtrTable->dwNumEntries;
             for (RtIndex = 0; RtIndex < rtsize; RtIndex++) {
                 cp = (u_char *) & pIpRtrTable->table[RtIndex].
                     dwForwardDest;
                 op = Current + 10;
                 *op++ = *cp++;
                 *op++ = *cp++;
                 *op++ = *cp++;
                 *op++ = *cp++;
 
                 result = snmp_oid_compare(name, *length, Current, 14);
                 if ((exact && (result == 0)) || (!exact && (result < 0)))
                     break;
             }
         }
         if (RtIndex >= rtsize) {
             /*
              * for creation of new row, only ipNetToMediaTable case is considered 
              */
             if (*length == 14) {
                 u_char           dest_addr[4];
                 MIB_IPFORWARDROW temp_row;
 
                 create_flag = 1;
                 *write_method = write_rte;
                 dest_addr[0] = (u_char) name[10];
                 dest_addr[1] = (u_char) name[11];
                 dest_addr[2] = (u_char) name[12];
                 dest_addr[3] = (u_char) name[13];
                 memset(&temp_row, 0, sizeof(temp_row));
                 temp_row.dwForwardDest = *((DWORD *) dest_addr);
                 temp_row.dwForwardPolicy = 0;
                 temp_row.dwForwardProto = MIB_IPPROTO_NETMGMT;
                 *route_row = temp_row;
             }
             free(pIpRtrTable);
             pIpRtrTable = NULL;
             rtsize = 0;
             return (NULL);
         }
         create_flag = 0;
         /*
          *  Save in the 'cache'
          */
         memcpy((char *) saveName, (char *) name,
                SNMP_MIN(*length, MAX_OID_LEN) * sizeof(oid));
         saveName[9] = 0;
         saveNameLen = *length;
         saveExact = exact;
         saveRtIndex = RtIndex;
 
         /*
          *  Return the name
          */
         memcpy((char *) name, (char *) Current, 14 * sizeof(oid));
         *length = 14;
     }
     *var_len = sizeof(long_return);
     *route_row = pIpRtrTable->table[RtIndex];
 
     switch (vp->magic) {
     case IPROUTEDEST:
         *var_len = sizeof(addr_ret);
         *write_method = write_rte;
         addr_ret = pIpRtrTable->table[RtIndex].dwForwardDest;
         return (u_char *) & addr_ret;
     case IPROUTEIFINDEX:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardIfIndex;
         return (u_char *) & long_return;
     case IPROUTEMETRIC1:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardMetric1;
         return (u_char *) & long_return;
     case IPROUTEMETRIC2:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardMetric2;
         return (u_char *) & long_return;
     case IPROUTEMETRIC3:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardMetric3;
         return (u_char *) & long_return;
     case IPROUTEMETRIC4:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardMetric4;
         return (u_char *) & long_return;
     case IPROUTEMETRIC5:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardMetric5;
         return (u_char *) & long_return;
     case IPROUTENEXTHOP:
         *var_len = sizeof(addr_ret);
         *write_method = write_rte;
         addr_ret = pIpRtrTable->table[RtIndex].dwForwardNextHop;
         return (u_char *) & addr_ret;
     case IPROUTETYPE:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardType;
         return (u_char *) & long_return;
     case IPROUTEPROTO:
         long_return = pIpRtrTable->table[RtIndex].dwForwardProto;
         return (u_char *) & long_return;
     case IPROUTEAGE:
         *write_method = write_rte;
         long_return = pIpRtrTable->table[RtIndex].dwForwardAge;
         return (u_char *) & long_return;
     case IPROUTEMASK:
         *write_method = write_rte;
         *var_len = sizeof(addr_ret);
         addr_ret = pIpRtrTable->table[RtIndex].dwForwardMask;
         return (u_char *) & addr_ret;
     case IPROUTEINFO:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipRouteEntry\n",
                     vp->magic));
     }
     return NULL;
 }
 
 #endif                          /* WIN32 cygwin */
 
 #else                           /* NETSNMP_CAN_USE_SYSCTL */
@@ -2015,165 +2015,165 @@ u_char         *
 var_ipRouteEntry(struct variable * vp,
                  oid * name,
                  size_t * length,
                  int exact, size_t * var_len, WriteMethod ** write_method)
 {
     /*
      * object identifier is of form:
      * 1.3.6.1.2.1.4.21.1.1.A.B.C.D,  where A.B.C.D is IP address.
      * IPADDR starts at offset 10.
      */
     int             Save_Valid, result;
     u_char         *cp;
     oid            *op;
     struct snmprt  *rt;
     static struct snmprt *savert;
     static int      saveNameLen, saveExact;
     static oid      saveName[14], Current[14];
     static in_addr_t addr_ret;
     
     *write_method = NULL;  /* write_rte;  XXX:  SET support not really implemented */
 
 #if 0
     /*
      *      OPTIMIZATION:
      *
      *      If the name was the same as the last name, with the possible
      *      exception of the [9]th token, then don't read the routing table
      *
      */
 
     if ((saveNameLen == *length) && (saveExact == exact)) {
         int             temp = name[9];
         name[9] = 0;
         Save_Valid =
             !snmp_oid_compare(name, *length, saveName, saveNameLen);
         name[9] = temp;
     } else {
         Save_Valid = 0;
     }
 #else
     Save_Valid = 0;
 #endif
 
     if (Save_Valid) {
         int             temp = name[9];
         memcpy(name, Current, 14 * sizeof(oid));
         name[9] = temp;
         *length = 14;
         rt = savert;
     } else {
         /*
          * fill in object part of name for current
          * (less sizeof instance part) 
          */
 
         memcpy(Current, vp->name, SNMP_MIN(sizeof(Current), (int)(vp->namelen) * sizeof(oid)));
 
         suck_krt(0);
 
         for (rt = rthead.tqh_first; rt; rt = rt->link.tqe_next) {
             op = Current + 10;
             cp = (u_char *) & rt->dest;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
             *op++ = *cp++;
             result = snmp_oid_compare(name, *length, Current, 14);
             if ((exact && (result == 0))
                 || (!exact && (result < 0)))
                 break;
         }
         if (rt == NULL)
             return NULL;
 
         /*
          *  Save in the 'cache'
          */
         memcpy(saveName, name, SNMP_MIN(sizeof(saveName), *length * sizeof(oid)));
         saveName[9] = 0;
         saveNameLen = *length;
         saveExact = exact;
         savert = rt;
 
         /*
          *  Return the name
          */
         memcpy(name, Current, 14 * sizeof(oid));
         *length = 14;
     }
 
     *var_len = sizeof(long_return);
 
     switch (vp->magic) {
     case IPROUTEDEST:
         addr_ret = rt->dest.s_addr;
         *var_len = sizeof(addr_ret);
         return (u_char *) & addr_ret;
 
     case IPROUTEIFINDEX:
         long_return = rt->index;
         return (u_char *) & long_return;
 
     case IPROUTEMETRIC1:
         long_return = (rt->hdr->rtm_flags & RTF_GATEWAY) ? 1 : 0;
         return (u_char *) & long_return;
     case IPROUTEMETRIC2:
         long_return = rt->hdr->rtm_rmx.rmx_rtt;
         return (u_char *) & long_return;
     case IPROUTEMETRIC3:
         long_return = rt->hdr->rtm_rmx.rmx_rttvar;
         return (u_char *) & long_return;
     case IPROUTEMETRIC4:
         long_return = rt->hdr->rtm_rmx.rmx_ssthresh;
         return (u_char *) & long_return;
     case IPROUTEMETRIC5:
         long_return = rt->hdr->rtm_rmx.rmx_mtu;
         return (u_char *) & long_return;
 
     case IPROUTENEXTHOP:
         *var_len = sizeof(addr_ret);
         if (rt->gateway.s_addr == 0 && rt->ifa.s_addr == 0)
             addr_ret = 0;
         else if (rt->gateway.s_addr == 0)
             addr_ret = rt->ifa.s_addr;
         else
             addr_ret = rt->gateway.s_addr;
         return (u_char *) & addr_ret;
 
     case IPROUTETYPE:
         if (rt->hdr->rtm_flags & RTF_UP) {
             if (rt->hdr->rtm_flags & RTF_GATEWAY) {
                 long_return = 4;        /*  indirect(4)  */
             } else {
                 long_return = 3;        /*  direct(3)  */
             }
         } else {
             long_return = 2;    /*  invalid(2)  */
         }
         return (u_char *) & long_return;
 
     case IPROUTEPROTO:
         long_return = (rt->hdr->rtm_flags & RTF_DYNAMIC) ? 4 : 2;
         return (u_char *) & long_return;
 
     case IPROUTEAGE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_return = 0;
         return (u_char *) & long_return;
 
     case IPROUTEMASK:
         addr_ret = rt->netmask.s_addr;
         *var_len = sizeof(addr_ret);
         return (u_char *) & addr_ret;
 
     case IPROUTEINFO:
         *var_len = nullOidLen;
         return NETSNMP_REMOVE_CONST(void *, nullOid);
     default:
         DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_ipRouteEntry\n",
                     vp->magic));
     }
     return NULL;
 }
@@ -2207,39 +2207,39 @@ size_t
 snmp_socket_length(int family)
 {
     size_t          length;
 
     switch (family) {
 #ifndef cygwin
 #if !defined (WIN32) && !defined (cygwin)
 #ifdef AF_UNIX
     case AF_UNIX:
         length = sizeof(struct sockaddr_un);
         break;
 #endif                          /* AF_UNIX */
 #endif
 #endif
 
 #ifndef aix3
 #ifdef AF_LINK
     case AF_LINK:
 #ifdef _MAX_SA_LEN
         length = _MAX_SA_LEN;
-#elif SOCK_MAXADDRLEN
+#elif defined(SOCK_MAXADDRLEN)
         length = SOCK_MAXADDRLEN;
 #else
         length = sizeof(struct sockaddr_dl);
 #endif
         break;
 #endif                          /* AF_LINK */
 #endif
 
     case AF_INET:
         length = sizeof(struct sockaddr_in);
         break;
     default:
         length = sizeof(struct sockaddr);
         break;
     }
 
     return length;
 }
diff --git a/agent/mibgroup/mibincl.h b/agent/mibgroup/mibincl.h
index 769ba34a42..4ef3cd727f 100644
--- a/agent/mibgroup/mibincl.h
+++ b/agent/mibgroup/mibincl.h
@@ -1,48 +1,48 @@
 /*
  * mibincl.h
  */
 
 #include <stdio.h>
 #include <sys/types.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/agent/mib_module_config.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_client.h>
 
 #include <net-snmp/agent/snmp_vars.h>
 #include <net-snmp/agent/agent_read_config.h>
 #include <net-snmp/agent/agent_handler.h>
 #include <net-snmp/agent/agent_registry.h>
 #include <net-snmp/agent/var_struct.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/snmp_logging.h>
 #include <net-snmp/library/snmp_alarm.h>
 #include <net-snmp/library/read_config.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/library/callback.h>
 #define u_char unsigned char
 #define u_short unsigned short
diff --git a/agent/mibgroup/misc/ipfwacc.c b/agent/mibgroup/misc/ipfwacc.c
index 5b65fb9d31..622e9e8600 100644
--- a/agent/mibgroup/misc/ipfwacc.c
+++ b/agent/mibgroup/misc/ipfwacc.c
@@ -1,50 +1,50 @@
 /****************************************************************************
  * Module for ucd-snmpd reading IP Firewall accounting rules.               *
  * It reads "/proc/net/ip_acct". If the file has a wrong format it silently *
  * returns erroneous data but doesn't do anything harmfull. Based (on the   *
  * output of) mib2c, wombat.c, proc.c and the Linux kernel.                 *
  * Author: Cristian.Estan@net.utcluj.ro                                     *
  ***************************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "util_funcs/header_simple_table.h"
 #include "ipfwacc.h"
 
 /*
  * According to the 2.0.33 Linux kernel, assuming we use ipv4 any line from
  * * "/proc/net/ip_acct should fit into
  * * 8+1+8+2+8+1+8+1+16+1+8+1+4+1+2+1+2+1+20+20+10*(1+5)+2+2+2+2=182
  * * characters+ newline.
  */
 #define IPFWRULELEN 200
 
 #define IP_FW_F_ALL     0x0000  /* This is a universal packet firewall */
 #define IP_FW_F_TCP     0x0001  /* This is a TCP packet firewall      */
 #define IP_FW_F_UDP     0x0002  /* This is a UDP packet firewall      */
 #define IP_FW_F_ICMP    0x0003  /* This is a ICMP packet firewall     */
 #define IP_FW_F_KIND    0x0003  /* Mask to isolate firewall kind      */
 #define IP_FW_F_SRNG    0x0008  /* The first two src ports are a min  *
                                  * and max range (stored in host byte *
                                  * order).                            */
 #define IP_FW_F_DRNG    0x0010  /* The first two dst ports are a min  *
                                  * and max range (stored in host byte *
                                  * order).                            *
                                  * (ports[0] <= port <= ports[1])     */
 #define IP_FW_F_BIDIR   0x0040  /* For bidirectional firewalls        */
 #define IP_FW_F_ACCTIN  0x1000  /* Account incoming packets only.     */
 #define IP_FW_F_ACCTOUT 0x2000  /* Account outgoing packets only.     */
diff --git a/agent/mibgroup/notification/snmpNotifyFilterProfileTable.c b/agent/mibgroup/notification/snmpNotifyFilterProfileTable.c
index dfd2865a2a..713943dcfd 100644
--- a/agent/mibgroup/notification/snmpNotifyFilterProfileTable.c
+++ b/agent/mibgroup/notification/snmpNotifyFilterProfileTable.c
@@ -1,39 +1,39 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "snmpNotifyTable_data.h"
 #include "snmpNotifyFilterProfileTable.h"
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT
diff --git a/agent/mibgroup/notification/snmpNotifyFilterProfileTable_data.c b/agent/mibgroup/notification/snmpNotifyFilterProfileTable_data.c
index 26fe93bd63..0532312a35 100644
--- a/agent/mibgroup/notification/snmpNotifyFilterProfileTable_data.c
+++ b/agent/mibgroup/notification/snmpNotifyFilterProfileTable_data.c
@@ -1,42 +1,42 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 
 /*
  * This should always be included first before anything else
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 
 /*
  * minimal include directives
  */
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "header_complex.h"
 #include "snmpNotifyTable_data.h"
 #include "snmpNotifyFilterProfileTable_data.h"
 
 
 /*
  * global storage of our data, saved in and configured by header_complex()
  */
diff --git a/agent/mibgroup/notification/snmpNotifyTable.c b/agent/mibgroup/notification/snmpNotifyTable.c
index 47393d2087..05c701de5c 100644
--- a/agent/mibgroup/notification/snmpNotifyTable.c
+++ b/agent/mibgroup/notification/snmpNotifyTable.c
@@ -1,51 +1,51 @@
 /*
  * This file was generated by mib2c and is intended for use as
  * a mib module for the ucd-snmp snmpd agent. 
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 
 /*
  * This should always be included first before anything else 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 /*
  * minimal include directives 
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "agent_global_vars.h"
 #include "header_complex.h"
 #include "snmpNotifyTable.h"
 #include "snmpNotifyFilterProfileTable.h"
 #include "target/snmpTargetParamsEntry.h"
 #include "target/snmpTargetAddrEntry.h"
 #include "target/target.h"
 #include "snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable.h"
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/mib_module_config.h>
 #include "net-snmp/agent/sysORTable.h"
 
 #ifdef USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE
 #   include "notification-log-mib/notification_log.h"
 #endif
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT
diff --git a/agent/mibgroup/notification/snmpNotifyTable_data.c b/agent/mibgroup/notification/snmpNotifyTable_data.c
index b31ee37bd5..5e8ddda208 100644
--- a/agent/mibgroup/notification/snmpNotifyTable_data.c
+++ b/agent/mibgroup/notification/snmpNotifyTable_data.c
@@ -1,49 +1,49 @@
 /*
  * This file was created to separate data storage from  MIB implementation.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 
 /*
  * This should always be included first before anything else
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 /*
  * minimal include directives
  */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "agent_global_vars.h"
 #include "header_complex.h"
 #include "snmpNotifyTable_data.h"
 #include "notification/snmpNotifyFilterProfileTable_data.h"
 #include "target/snmpTargetParamsEntry_data.h"
 #include "target/snmpTargetAddrEntry_data.h"
 #include "target/target.h"
 #include "agentx/subagent.h"
 #include "snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_data_storage.h"
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/agent/agent_trap.h>
 #include <net-snmp/agent/mib_module_config.h>
 #include "net-snmp/agent/sysORTable.h"
 
 #ifdef USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE
 #   include "notification-log-mib/notification_log.h"
 #endif
diff --git a/agent/mibgroup/rmon-mib/data_access/etherstats_linux.c b/agent/mibgroup/rmon-mib/data_access/etherstats_linux.c
index 204a6ff742..ebad8ab0ff 100644
--- a/agent/mibgroup/rmon-mib/data_access/etherstats_linux.c
+++ b/agent/mibgroup/rmon-mib/data_access/etherstats_linux.c
@@ -1,23 +1,23 @@
 /*
  * standard Net-SNMP includes 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 /*
  * include our parent header 
  */
 #include "rmon-mib/etherStatsTable/etherStatsTable.h"
 #include "rmon-mib/etherStatsTable/etherStatsTable_data_access.h"
 #include "rmon-mib/etherStatsTable/ioctl_imp_common.h"
 
 /*
  * @retval  0 success
  * @retval -1 getifaddrs failed 
  * @retval -2 memory allocation failed
  */
diff --git a/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c b/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
index 5259645c35..7e41523366 100644
--- a/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
+++ b/agent/mibgroup/rmon-mib/etherStatsTable/etherStatsTable_data_access.c
@@ -1,60 +1,60 @@
 /*
  * Note: this file originally auto-generated by mib2c using
  *       version : 14170 $ of $ 
  *
  * $Id:$
  */
 /*
  * standard Net-SNMP includes 
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 /*
  * include our parent header 
  */
 #include "etherStatsTable.h"
 #include "etherStatsTable_data_access.h"
 
 #if defined(linux)
 #include "ioctl_imp_common.h"
 #endif
 
 /** @ingroup interface
  * @addtogroup data_access data_access: Routines to access data
  *
  * These routines are used to locate the data used to satisfy
  * requests.
  * 
  * @{
  */
 /**********************************************************************
  **********************************************************************
  ***
  *** Table etherStatsTable
  ***
  **********************************************************************
  **********************************************************************/
 /*
  * RMON-MIB::etherStatsTable is subid 1 of statistics.
  * Its status is Current.
  * OID: .1.3.6.1.2.1.16.1.1, length: 9
  */
 
 /**
  * initialization for etherStatsTable data access
  *
  * This function is called during startup to allow you to
  * allocate any resources you need for the data table.
  *
  * @param etherStatsTable_reg
  *        Pointer to etherStatsTable_registration
  *
  * @retval MFD_SUCCESS : success.
  * @retval MFD_ERROR   : unrecoverable error.
  */
diff --git a/agent/mibgroup/smux/smux.c b/agent/mibgroup/smux/smux.c
index d283f4f664..80ddeeb370 100644
--- a/agent/mibgroup/smux/smux.c
+++ b/agent/mibgroup/smux/smux.c
@@ -1,69 +1,69 @@
 /*
  * Smux module authored by Rohit Dube.
  * Rewritten by Nick Amato <naamato@merit.net>.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <sys/types.h>
 #include <ctype.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_ERR_H
 #include <err.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <errno.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <sys/stat.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_FILIO_H
 #include <sys/filio.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/tools.h>
 
 #include "smux.h"
 #include "snmpd.h"
diff --git a/agent/mibgroup/smux/snmp_bgp.c b/agent/mibgroup/smux/snmp_bgp.c
index a97ca35e32..cf3b0bd146 100644
--- a/agent/mibgroup/smux/snmp_bgp.c
+++ b/agent/mibgroup/smux/snmp_bgp.c
@@ -1,52 +1,52 @@
 /*
  * $Id$ 
  */
 
 /*
  * Smux module authored by Rohit Dube.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_ERR_H
+#ifdef HAVE_ERR_H
 #include <err.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <errno.h>
 #include <netdb.h>
 
 #include <sys/stat.h>
 #include <sys/socket.h>
-#if HAVE_SYS_FILIO_H
+#ifdef HAVE_SYS_FILIO_H
 #include <sys/filio.h>
 #endif
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "smux.h"
 #include "snmp_bgp.h"
diff --git a/agent/mibgroup/smux/snmp_ospf.c b/agent/mibgroup/smux/snmp_ospf.c
index 4b6d64051a..5d1f62a82c 100644
--- a/agent/mibgroup/smux/snmp_ospf.c
+++ b/agent/mibgroup/smux/snmp_ospf.c
@@ -1,52 +1,52 @@
 /*
  * $Id$ 
  */
 
 /*
  * Smux module authored by Rohit Dube.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_ERR_H
+#ifdef HAVE_ERR_H
 #include <err.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <errno.h>
 #include <netdb.h>
 
 #include <sys/stat.h>
 #include <sys/socket.h>
-#if HAVE_SYS_FILIO_H
+#ifdef HAVE_SYS_FILIO_H
 #include <sys/filio.h>
 #endif
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "smux.h"
 #include "snmp_ospf.h"
diff --git a/agent/mibgroup/smux/snmp_rip2.c b/agent/mibgroup/smux/snmp_rip2.c
index 9d49a3020c..c174a3e6fb 100644
--- a/agent/mibgroup/smux/snmp_rip2.c
+++ b/agent/mibgroup/smux/snmp_rip2.c
@@ -1,52 +1,52 @@
 /*
  * $Id$ 
  */
 
 /*
  * Smux module authored by Rohit Dube.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_ERR_H
+#ifdef HAVE_ERR_H
 #include <err.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <errno.h>
 #include <netdb.h>
 
 #include <sys/stat.h>
 #include <sys/socket.h>
-#if HAVE_SYS_FILIO_H
+#ifdef HAVE_SYS_FILIO_H
 #include <sys/filio.h>
 #endif
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "smux.h"
 #include "snmp_rip2.h"
diff --git a/agent/mibgroup/snmpv3/usmUser.c b/agent/mibgroup/snmpv3/usmUser.c
index 1761f4d3d8..c9b9454554 100644
--- a/agent/mibgroup/snmpv3/usmUser.c
+++ b/agent/mibgroup/snmpv3/usmUser.c
@@ -1,30 +1,30 @@
 /*
  * usmUser.c
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <stdlib.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "util_funcs/header_generic.h"
 #include "usmUser.h"
 
 #ifndef NETSNMP_NO_WRITE_SUPPORT 
diff --git a/agent/mibgroup/target/snmpTargetAddrEntry.c b/agent/mibgroup/target/snmpTargetAddrEntry.c
index 03adb2610e..bd87260dcd 100644
--- a/agent/mibgroup/target/snmpTargetAddrEntry.c
+++ b/agent/mibgroup/target/snmpTargetAddrEntry.c
@@ -1,30 +1,30 @@
 /*
  * snmpTargetAddrEntry MIB
  * 
  * This file was generated by mib2c and is intended for use as a mib module
  * for the ucd-snmp snmpd agent. Edited by Michael Baer
  * 
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stdlib.h>
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "snmpTargetAddrEntry.h"
 #include "snmpTargetAddrEntry_data.h"
 #include "util_funcs/header_generic.h"
 
 #define snmpTargetAddrOIDLen 11 /*This is base+column, 
                                  * i.e. everything but index */
diff --git a/agent/mibgroup/target/snmpTargetAddrEntry_data.c b/agent/mibgroup/target/snmpTargetAddrEntry_data.c
index 53dd7ce7c3..c16d531aee 100644
--- a/agent/mibgroup/target/snmpTargetAddrEntry_data.c
+++ b/agent/mibgroup/target/snmpTargetAddrEntry_data.c
@@ -1,26 +1,26 @@
 /*
  * snmpTargetAddrEntry MIB
  *
  * This file was created to separate notification data storage from
  * the MIB implementation.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stdlib.h>
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "snmpTargetAddrEntry_data.h"
 #include "util_funcs/header_generic.h"
diff --git a/agent/mibgroup/target/snmpTargetParamsEntry.c b/agent/mibgroup/target/snmpTargetParamsEntry.c
index a2f2e704a7..84c3e519e3 100644
--- a/agent/mibgroup/target/snmpTargetParamsEntry.c
+++ b/agent/mibgroup/target/snmpTargetParamsEntry.c
@@ -1,29 +1,29 @@
 /*
  * TargetParamTable MIB
  * 
  * This file was generated by mib2c and is intended for use as a mib module
  * for the ucd-snmp snmpd agent. Edited by Michael Baer 
  * 
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stdlib.h>
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "snmpTargetParamsEntry.h"
 #include "snmpTargetParamsEntry_data.h"
 
 #define snmpTargetParamsOIDLen 11       /*This is base+column, 
                                          * i.e. everything but index */
diff --git a/agent/mibgroup/target/snmpTargetParamsEntry_data.c b/agent/mibgroup/target/snmpTargetParamsEntry_data.c
index a128cd9066..54aecf3c2b 100644
--- a/agent/mibgroup/target/snmpTargetParamsEntry_data.c
+++ b/agent/mibgroup/target/snmpTargetParamsEntry_data.c
@@ -1,24 +1,24 @@
 /*
  * TargetParamTable data storage
  *
  * This file was created to separate data storage from the MIB implementation
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stdlib.h>
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "snmpTargetParamsEntry_data.h"
diff --git a/agent/mibgroup/target/target.c b/agent/mibgroup/target/target.c
index cc14292990..239b35a21b 100644
--- a/agent/mibgroup/target/target.c
+++ b/agent/mibgroup/target/target.c
@@ -1,33 +1,33 @@
 /*
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #if defined(NETSNMP_TRANSPORT_DTLSUDP_DOMAIN) || defined(NETSNMP_TRANSPORT_TLSTCP_DOMAIN)
 #include <openssl/ssl.h>
 #include <openssl/x509v3.h>
 #include <net-snmp/library/cert_util.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_TLSTCP_DOMAIN
 #include <net-snmp/library/snmpTLSTCPDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_DTLSUDP_DOMAIN
 #include <net-snmp/library/snmpDTLSUDPDomain.h>
 #endif
 
 #include "snmpTargetAddrEntry.h"
 #include "snmpTargetParamsEntry.h"
 #include "target.h"
diff --git a/agent/mibgroup/target/target_counters.c b/agent/mibgroup/target/target_counters.c
index 9725ddcb25..7c48052d6f 100644
--- a/agent/mibgroup/target/target_counters.c
+++ b/agent/mibgroup/target/target_counters.c
@@ -1,16 +1,16 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "target_counters.h"
 
 #include <net-snmp/agent/snmp_get_statistic.h>
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
index 4e2a41a122..dc51cf5cb8 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_freebsd4.c
@@ -1,27 +1,27 @@
 /*
  *  tcpConnTable MIB architecture support for FreeBSD/DragonFlyBSD
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/tcpConn.h>
 
 #include "tcp-mib/tcpConnectionTable/tcpConnectionTable_constants.h"
 #include "tcp-mib/data_access/tcpConn_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_TCP_H
+#ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
-#if HAVE_NETINET_TCP_TIMER_H
+#ifdef HAVE_NETINET_TCP_TIMER_H
 #include <netinet/tcp_timer.h>
 #endif
-#if HAVE_NETINET_TCPIP_H
+#ifdef HAVE_NETINET_TCPIP_H
 #include <netinet/tcpip.h>
 #endif
-#if HAVE_NETINET_TCP_VAR_H
+#ifdef HAVE_NETINET_TCP_VAR_H
 #include <netinet/tcp_var.h>
 #endif
 
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_netbsd.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_netbsd.c
index b4229ff9fd..9a80192b3a 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_netbsd.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_netbsd.c
@@ -1,27 +1,27 @@
 /*
  *  tcpConnTable MIB architecture support for NetBSD
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/tcpConn.h>
 
 #include "tcp-mib/tcpConnectionTable/tcpConnectionTable_constants.h"
 #include "tcp-mib/data_access/tcpConn_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_TCP_H
+#ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
-#if HAVE_NETINET_TCP_TIMER_H
+#ifdef HAVE_NETINET_TCP_TIMER_H
 #include <netinet/tcp_timer.h>
 #endif
-#if HAVE_NETINET_TCPIP_H
+#ifdef HAVE_NETINET_TCPIP_H
 #include <netinet/tcpip.h>
 #endif
-#if HAVE_NETINET_TCP_VAR_H
+#ifdef HAVE_NETINET_TCP_VAR_H
 #include <netinet/tcp_var.h>
 #endif
 
diff --git a/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c b/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
index 41a8c4c33a..56e2c3d981 100644
--- a/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
+++ b/agent/mibgroup/tcp-mib/data_access/tcpConn_openbsd.c
@@ -1,43 +1,43 @@
 /*
  *  tcpConnTable MIB architecture support for OpenBSD
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/tcpConn.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "tcp-mib/tcpConnectionTable/tcpConnectionTable_constants.h"
 #include "tcp-mib/data_access/tcpConn_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_TCP_H
+#ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
-#if HAVE_NETINET_TCP_TIMER_H
+#ifdef HAVE_NETINET_TCP_TIMER_H
 #include <netinet/tcp_timer.h>
 #endif
-#if HAVE_NETINET_TCPIP_H
+#ifdef HAVE_NETINET_TCPIP_H
 #include <netinet/tcpip.h>
 #endif
-#if HAVE_NETINET_TCP_VAR_H
+#ifdef HAVE_NETINET_TCP_VAR_H
 #include <netinet/tcp_var.h>
 #endif
 
-#if HAVE_KVM_GETFILES
+#ifdef HAVE_KVM_GETFILES
 #if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
 #undef HAVE_KVM_GETFILES
 #endif
 #endif
 
-#if HAVE_KVM_GETFILES
+#ifdef HAVE_KVM_GETFILES
 #include <kvm.h>
 #include <sys/sysctl.h>
 #define _KERNEL /* for DTYPE_SOCKET */
 #include <sys/file.h>
 #undef _KERNEL
 #endif
 
 #ifdef HAVE_KVM_GETFILES
diff --git a/agent/mibgroup/testhandler.c b/agent/mibgroup/testhandler.c
index dc902cb922..8bfda6903c 100644
--- a/agent/mibgroup/testhandler.c
+++ b/agent/mibgroup/testhandler.c
@@ -1,11 +1,11 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
diff --git a/agent/mibgroup/ucd-snmp/disk_hw.c b/agent/mibgroup/ucd-snmp/disk_hw.c
index 6e1ddc5b9f..ff976f1df2 100644
--- a/agent/mibgroup/ucd-snmp/disk_hw.c
+++ b/agent/mibgroup/ucd-snmp/disk_hw.c
@@ -1,45 +1,45 @@
 /*
  * disk_hw.c
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 
 #include <stdio.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #include <signal.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 #include <sys/time.h>
 #include <time.h>
 #else
-#if HAVE_SYS_TIME_H
+#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #else
 #include <time.h>
 #endif
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "hardware/fsys/fsys.h"
 
 #include "struct.h"
 #include "disk_hw.h"
 #include "util_funcs/header_simple_table.h"
-#if USING_UCD_SNMP_ERRORMIB_MODULE
+#ifdef USING_UCD_SNMP_ERRORMIB_MODULE
 #include "errormib.h"
 #else
 #define setPerrorstatus(x) snmp_log_perror(x)
 #endif
 
 #define MAX_INT_32 0x7fffffff
 #define MAX_UINT_32 0xffffffff
diff --git a/agent/mibgroup/ucd-snmp/diskio.c b/agent/mibgroup/ucd-snmp/diskio.c
index 24fbb3c416..21962fafbc 100644
--- a/agent/mibgroup/ucd-snmp/diskio.c
+++ b/agent/mibgroup/ucd-snmp/diskio.c
@@ -1,40 +1,40 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 /*
  * needed by util_funcs.h 
  */
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 /*
  * include our .h file 
  */
 #include "diskio.h"
 #include "diskio_darwin.h"
 #include "diskio_netbsd.h"
 #include "diskio_aix.h"
 #include "diskio_freebsd.h"
 #include "diskio_openbsd.h"
 #include "diskio_bsdi.h"
 #include "diskio_linux.h"
 #include "diskio_solaris.h"
diff --git a/agent/mibgroup/ucd-snmp/diskio_freebsd.c b/agent/mibgroup/ucd-snmp/diskio_freebsd.c
index 86dae16fc0..be5d9d62b7 100644
--- a/agent/mibgroup/ucd-snmp/diskio_freebsd.c
+++ b/agent/mibgroup/ucd-snmp/diskio_freebsd.c
@@ -1,31 +1,31 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <math.h>
 #include <sys/param.h>
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
 #include <sys/resource.h>       /* for CPUSTATES in devstat.h */
 #elif HAVE_SYS_DKSTAT_H
 #include <sys/dkstat.h>
 #endif
 #include <devstat.h>
 #include <net-snmp/utilities.h>
 #include "diskio.h"
 #include "diskio_freebsd.h"
 #include "util_funcs/header_simple_table.h"
 
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
   #define GETDEVS(x) devstat_getdevs(NULL, (x))
 #else
   #define GETDEVS(x) getdevs((x))
 #endif
 
 struct dev_la {
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         struct bintime prev;
 #else
         struct timeval prev;
 #endif
         double la1,la5,la15;
         char name[DEVSTAT_NAME_LEN+5];
 };
@@ -46,75 +46,75 @@ double devla_timeval_diff(struct timeval *t1, struct timeval *t2)
 void devla_getstats(unsigned int regno, void *dummy)
 {
     static struct statinfo *lastat = NULL;
     int i;
     double busy_time, busy_percent;
     static double expon1, expon5, expon15;
     char current_name[DEVSTAT_NAME_LEN+5];
 
     if (lastat == NULL) {
         lastat = malloc(sizeof(struct statinfo));
         if (lastat != NULL)
             lastat->dinfo = calloc(sizeof(struct devinfo), 1);
         if (lastat == NULL || lastat->dinfo == NULL) {
             SNMP_FREE(lastat);
             ERROR_MSG("Memory alloc failure - devla_getstats()\n");
             return;
         }
     }
 
     if ((GETDEVS(lastat)) == -1) {
         ERROR_MSG("can't do getdevs()\n");
         return;
     }
 
     if (ndevs != 0) {
         for (i=0; i < ndevs; i++) {
             snprintf(current_name, sizeof(current_name), "%s%d",
                      lastat->dinfo->devices[i].device_name,
                      lastat->dinfo->devices[i].unit_number);
             if (strcmp(current_name, devloads[i].name)) {
                 ndevs = 0;
                 free(devloads);
             }
         }
     }
 
     if (ndevs == 0) {
         ndevs = lastat->dinfo->numdevs;
         devloads = malloc(ndevs * sizeof(struct dev_la));
         memset(devloads, '\0', ndevs * sizeof(struct dev_la));
         for (i=0; i < ndevs; i++) {
             devloads[i].la1 = devloads[i].la5 = devloads[i].la15 = 0;
             memcpy(&devloads[i].prev, &lastat->dinfo->devices[i].busy_time,
                    sizeof(devloads[i].prev));
             snprintf(devloads[i].name, sizeof(devloads[i].name), "%s%d",
                      lastat->dinfo->devices[i].device_name,
                      lastat->dinfo->devices[i].unit_number);
         }
         expon1  = exp(-(((double)DISKIO_SAMPLE_INTERVAL) / ((double)60)));
         expon5  = exp(-(((double)DISKIO_SAMPLE_INTERVAL) / ((double)300)));
         expon15 = exp(-(((double)DISKIO_SAMPLE_INTERVAL) / ((double)900)));
     }
 
     for (i=0; i<ndevs; i++) {
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         busy_time = devstat_compute_etime(&lastat->dinfo->devices[i].busy_time,
                                           &devloads[i].prev);
 #else
         busy_time = devla_timeval_diff(&devloads[i].prev,
                                        &lastat->dinfo->devices[i].busy_time);
 #endif
         if (busy_time < 0)
             busy_time = 0;   /* Account for possible FP loss of precision near zero */
         busy_percent = busy_time * 100 / DISKIO_SAMPLE_INTERVAL;
         devloads[i].la1 = devloads[i].la1 * expon1 +
             busy_percent * (1 - expon1);
         /* fprintf(stderr, "(%d) %s: update la1=%.2lf%%\n", i, devloads[i].name, expon1); */
         devloads[i].la5 = devloads[i].la5 * expon5 +
             busy_percent * (1 - expon5);
         devloads[i].la15 = devloads[i].la15 * expon15 +
             busy_percent * (1 - expon15);
         memcpy(&devloads[i].prev, &lastat->dinfo->devices[i].busy_time,
                sizeof(devloads[i].prev));
     }
 }
@@ -166,95 +166,95 @@ u_char         *
 var_diskio(struct variable * vp,
            oid * name,
            size_t * length,
            int exact, size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
     static struct   counter64 c64_ret;
     long long       longlong_ret;
     unsigned int    indx;
 
     if (diskio_getstats() == 1) {
         return NULL;
     }
 
 
     if (header_simple_table
         (vp, name, length, exact, var_len, write_method, ndisk)) {
         return NULL;
     }
 
     indx = (unsigned int) (name[*length - 1] - 1);
 
     if (indx >= ndisk)
         return NULL;
 
     switch (vp->magic) {
     case DISKIO_INDEX:
         long_ret = (long) indx + 1;
         return (u_char *) & long_ret;
     case DISKIO_DEVICE:
         *var_len = strlen(stat->dinfo->devices[indx].device_name);
         return (u_char *) stat->dinfo->devices[indx].device_name;
     case DISKIO_NREAD:
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_READ] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].bytes_read;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_NWRITTEN:
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         long_ret = (signed long) stat->dinfo->devices[indx].bytes[DEVSTAT_WRITE] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].bytes_written;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_NREADX:
         *var_len = sizeof(struct counter64);
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         longlong_ret = stat->dinfo->devices[indx].bytes[DEVSTAT_READ];
 #else
         longlong_ret = stat->dinfo->devices[indx].bytes_read;
 #endif
         c64_ret.low = longlong_ret & 0xffffffff;
         c64_ret.high = longlong_ret >> 32;
         return (u_char *) & c64_ret;
     case DISKIO_NWRITTENX:
         *var_len = sizeof(struct counter64);
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         longlong_ret = stat->dinfo->devices[indx].bytes[DEVSTAT_WRITE];
 #else
         longlong_ret = stat->dinfo->devices[indx].bytes_written;
 #endif
         c64_ret.low = longlong_ret & 0xffffffff;
         c64_ret.high = longlong_ret >> 32;
         return (u_char *) & c64_ret;
     case DISKIO_READS:
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_READ] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].num_reads;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_WRITES:
-#if HAVE_DEVSTAT_GETDEVS
+#ifdef HAVE_DEVSTAT_GETDEVS
         long_ret = (signed long) stat->dinfo->devices[indx].operations[DEVSTAT_WRITE] & 0xFFFFFFFF;
 #else
         long_ret = (signed long) stat->dinfo->devices[indx].num_writes;
 #endif
         return (u_char *) & long_ret;
     case DISKIO_LA1:
 	long_ret = devloads[indx].la1;
 	return (u_char *) & long_ret;
     case DISKIO_LA5:
         long_ret = devloads[indx].la5;
         return (u_char *) & long_ret;
     case DISKIO_LA15:
         long_ret = devloads[indx].la15;
         return (u_char *) & long_ret;
 
     default:
         ERROR_MSG("diskio.c: don't know how to handle this request.");
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/diskio_linux.c b/agent/mibgroup/ucd-snmp/diskio_linux.c
index 9f5a882d87..c1062133dd 100644
--- a/agent/mibgroup/ucd-snmp/diskio_linux.c
+++ b/agent/mibgroup/ucd-snmp/diskio_linux.c
@@ -223,19 +223,19 @@ add_device(char *path, int addNewDisks)
 static void
 diskio_parse_config_disks(const char *token, char *cptr)
 {
-#if HAVE_FSTAB_H || HAVE_GETMNTENT || HAVE_STATFS
+#if defined(HAVE_FSTAB_H) || defined(HAVE_GETMNTENT) || defined(HAVE_STATFS)
     char            path[STRMAX];
 
     /*
      * read disk path (eg, /1 or /usr) 
      */
     copy_nword(cptr, path, sizeof(path));
 
     /* TODO: we may include regular expressions in future */
     /*
      * check if the disk already exists, if so then modify its
      * parameters. if it does not exist then add it
      */
     add_device(path, 1);
 #endif                      /* HAVE_FSTAB_H || HAVE_GETMNTENT || HAVE_STATFS */
 }
diff --git a/agent/mibgroup/ucd-snmp/dlmod.c b/agent/mibgroup/ucd-snmp/dlmod.c
index ed3dd5409d..9c6a584fd8 100644
--- a/agent/mibgroup/ucd-snmp/dlmod.c
+++ b/agent/mibgroup/ucd-snmp/dlmod.c
@@ -1,31 +1,31 @@
 /*
  *  Dynamic Loadable Agent Modules MIB (UCD-DLMOD-MIB) - dlmod.c
  *
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #if defined(WIN32)
 #include <windows.h>
 #else
 #include <dlfcn.h>
 #endif
 #include "dlmod.h"
 
 #ifndef SNMPDLMODPATH
 #define SNMPDLMODPATH "/usr/local/lib/snmp/dlmod"
 #endif
diff --git a/agent/mibgroup/ucd-snmp/errormib.c b/agent/mibgroup/ucd-snmp/errormib.c
index 29f21f29bd..04ea4b8003 100644
--- a/agent/mibgroup/ucd-snmp/errormib.c
+++ b/agent/mibgroup/ucd-snmp/errormib.c
@@ -1,118 +1,118 @@
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #include <signal.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_VMMETER_H
 #if !(defined(bsdi2) || defined(netbsd1))
 #include <sys/vmmeter.h>
 #endif
 #endif
 #ifdef HAVE_SYS_CONF_H
 #include <sys/conf.h>
 #endif
 #ifdef HAVE_ASM_PAGE_H
 #include <asm/page.h>
 #endif
 #ifdef HAVE_SYS_SWAP_H
 #include <sys/swap.h>
 #endif
 #ifdef HAVE_SYS_FS_H
 #include <sys/fs.h>
 #else
 #ifdef HAVE_UFS_FS_H
 #include <ufs/fs.h>
 #else
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #if !defined(dragonfly)
 #ifdef HAVE_SYS_VNODE_H
 #include <sys/vnode.h>
 #endif
 #endif
 #ifdef HAVE_UFS_UFS_QUOTA_H
 #include <ufs/ufs/quota.h>
 #endif
 #ifdef HAVE_UFS_UFS_INODE_H
 #include <ufs/ufs/inode.h>
 #endif
 #ifdef HAVE_UFS_FFS_FS_H
 #include <ufs/ffs/fs.h>
 #endif
 #endif
 #endif
 #ifdef HAVE_MTAB_H
 #include <mtab.h>
 #endif
 #include <errno.h>
 #ifdef HAVE_FSTAB_H
 #include <fstab.h>
 #endif
 #ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
 #ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 #ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
 #if (!defined(HAVE_STATVFS)) && defined(HAVE_STATFS)
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #define statvfs statfs
 #endif
 #ifdef HAVE_VM_VM_H
 #include <vm/vm.h>
 #endif
 #ifdef HAVE_VM_SWAP_PAGER_H
 #include <vm/swap_pager.h>
 #endif
 #ifdef HAVE_SYS_FIXPOINT_H
 #include <sys/fixpoint.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "struct.h"
 #include "errormib.h"
 #include "util_funcs/header_generic.h"
diff --git a/agent/mibgroup/ucd-snmp/extensible.c b/agent/mibgroup/ucd-snmp/extensible.c
index b161be5c97..2ba5c2ea10 100644
--- a/agent/mibgroup/ucd-snmp/extensible.c
+++ b/agent/mibgroup/ucd-snmp/extensible.c
@@ -1,112 +1,112 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #include <signal.h>
 #ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_VMMETER_H
 #if !(defined(bsdi2) || defined(netbsd1))
 #include <sys/vmmeter.h>
 #endif
 #endif
 #ifdef HAVE_SYS_CONF_H
 #include <sys/conf.h>
 #endif
 #ifdef HAVE_ASM_PAGE_H
 #include <asm/page.h>
 #endif
 #ifdef HAVE_SYS_SWAP_H
 #include <sys/swap.h>
 #endif
 #ifdef HAVE_SYS_FS_H
 #include <sys/fs.h>
 #else
 #ifdef HAVE_UFS_FS_H
 #include <ufs/fs.h>
 #else
 #ifdef HAVE_UFS_UFS_DINODE_H
 #include <ufs/ufs/dinode.h>
 #endif
 #ifdef HAVE_UFS_FFS_FS_H
 #include <ufs/ffs/fs.h>
 #endif
 #endif
 #endif
 #ifdef HAVE_MTAB_H
 #include <mtab.h>
 #endif
 #include <sys/stat.h>
 #include <errno.h>
 #ifdef HAVE_FSTAB_H
 #include <fstab.h>
 #endif
 #ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
 #ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 #ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
 #if (!defined(HAVE_STATVFS)) && defined(HAVE_STATFS)
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #define statvfs statfs
 #endif
 #ifdef HAVE_VM_VM_H
 #include <vm/vm.h>
 #endif
 #ifdef HAVE_VM_SWAP_PAGER_H
 #include <vm/swap_pager.h>
 #endif
 #ifdef HAVE_SYS_FIXPOINT_H
 #include <sys/fixpoint.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 #include <ctype.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/library/system.h>
 
 #include "struct.h"
 #include "extensible.h"
 #include "pass.h"
 #include "mibgroup/util_funcs.h"
 #include "utilities/execute.h"
 #include "util_funcs/header_simple_table.h"
diff --git a/agent/mibgroup/ucd-snmp/file.c b/agent/mibgroup/ucd-snmp/file.c
index 78e6adb351..9d1e5be144 100644
--- a/agent/mibgroup/ucd-snmp/file.c
+++ b/agent/mibgroup/ucd-snmp/file.c
@@ -1,39 +1,39 @@
 /* Portions of this file are subject to the following copyrights.  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "struct.h"
 #include "file.h"
 #include "util_funcs/header_simple_table.h"
 
 #define MAXFILE   20
diff --git a/agent/mibgroup/ucd-snmp/hpux.c b/agent/mibgroup/ucd-snmp/hpux.c
index 9c5f9f9bc7..64e6dd19af 100644
--- a/agent/mibgroup/ucd-snmp/hpux.c
+++ b/agent/mibgroup/ucd-snmp/hpux.c
@@ -1,22 +1,22 @@
 /*
  * HP specific stuff that OpenView recognizes 
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <signal.h>
-#if HAVE_MACHINE_PARAM_H
+#ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
-#if HAVE_SYS_VMMETER_H
+#ifdef HAVE_SYS_VMMETER_H
 #include <sys/vmmeter.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "hpux.h"
 #include "mibdefs.h"
diff --git a/agent/mibgroup/ucd-snmp/loadave.c b/agent/mibgroup/ucd-snmp/loadave.c
index 866b7a1015..9cfe2483dc 100644
--- a/agent/mibgroup/ucd-snmp/loadave.c
+++ b/agent/mibgroup/ucd-snmp/loadave.c
@@ -1,134 +1,134 @@
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #include <signal.h>
 #ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_VMMETER_H
 #if !(defined(bsdi2) || defined(netbsd1))
 #include <sys/vmmeter.h>
 #endif
 #endif
 #ifdef HAVE_SYS_CONF_H
 #include <sys/conf.h>
 #endif
 #ifdef HAVE_ASM_PAGE_H
 #include <asm/page.h>
 #endif
 #ifdef HAVE_SYS_SWAP_H
 #include <sys/swap.h>
 #endif
 #ifdef HAVE_SYS_FS_H
 #include <sys/fs.h>
 #else
 #ifdef HAVE_UFS_FS_H
 #include <ufs/fs.h>
 #else
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #if !defined(dragonfly)
 #ifdef HAVE_SYS_VNODE_H
 #include <sys/vnode.h>
 #endif
 #endif
 #ifdef HAVE_UFS_UFS_QUOTA_H
 #include <ufs/ufs/quota.h>
 #endif
 #ifdef HAVE_UFS_UFS_INODE_H
 #include <ufs/ufs/inode.h>
 #endif
 #ifdef HAVE_UFS_FFS_FS_H
 #include <ufs/ffs/fs.h>
 #endif
 #endif
 #endif
 #ifdef HAVE_MTAB_H
 #include <mtab.h>
 #endif
 #include <errno.h>
 #ifdef HAVE_FSTAB_H
 #include <fstab.h>
 #endif
 #ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
 #ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
 #ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
 #if (!defined(HAVE_STATVFS)) && defined(HAVE_STATFS)
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #define statvfs statfs
 #endif
 #ifdef HAVE_VM_VM_H
 #include <vm/vm.h>
 #endif
 #ifdef HAVE_VM_SWAP_PAGER_H
 #include <vm/swap_pager.h>
 #endif
 #ifdef HAVE_SYS_FIXPOINT_H
 #include <sys/fixpoint.h>
 #endif
 #ifdef HAVE_SYS_LOADAVG_H
 #include <sys/loadavg.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef dynix
 #include <sys/mc_vmparam.h>
 #endif
 #if defined(hpux10) || defined(hpux11)
 #include <sys/pstat.h>
 #endif
 #if defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
 #ifdef HAVE_SYS_PROTOSW_H
 #include <sys/protosw.h>
 #endif
 #include <libperfstat.h>
 #endif
 #ifdef HAVE_SYS_SYSGET_H
 #include <sys/sysget.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "struct.h"
 #include "loadave.h"
 #include "util_funcs/header_simple_table.h"
 #include "kernel.h"
diff --git a/agent/mibgroup/ucd-snmp/memory_aix4.c b/agent/mibgroup/ucd-snmp/memory_aix4.c
index 786e5eba79..7c74cfd68a 100644
--- a/agent/mibgroup/ucd-snmp/memory_aix4.c
+++ b/agent/mibgroup/ucd-snmp/memory_aix4.c
@@ -1,44 +1,44 @@
 /*
  * AIX4 memory statistics module for net-snmp
  *
  * Version 0.1 - Initial release - 05/Jun/2003
  *
  * Derived from memory_solaris2.c
  * Using libperfstat for statistics (Redbook SG24-6039)
  *
  * Ported to AIX by Michael Kukat <michael.kukat@to.com>
  * Thinking Objects Software GmbH
  * Lilienthalstrae 2
  * 70825 Stuttgart-Korntal
  * http://www.to.com/
  *
  * Thanks go to Jochen Kmietsch for the solaris2 support and
  * to DaimlerChrysler AG Stuttgart for making this port possible
  */
 
 #include <net-snmp/net-snmp-config.h>   /* local SNMP configuration details */
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <sys/types.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "util_funcs/header_generic.h" /* utility function declarations */
 #include "memory.h"             /* the module-specific header */
 #include "memory_aix4.h"    /* the module-specific header */
 
 #ifdef HAVE_SYS_PROTOSW_H
 #include <sys/protosw.h>
 #endif
 #include <libperfstat.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
 #define MAXSTRSIZE	80
diff --git a/agent/mibgroup/ucd-snmp/memory_darwin7.c b/agent/mibgroup/ucd-snmp/memory_darwin7.c
index 230c54dd1d..5169b249b5 100644
--- a/agent/mibgroup/ucd-snmp/memory_darwin7.c
+++ b/agent/mibgroup/ucd-snmp/memory_darwin7.c
@@ -195,227 +195,227 @@ static unsigned char *
 var_extensible_mem(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
     static char     errmsg[1024];
     /* the getting used swap routine takes awhile, so we
      * do not want to run it often, so we use a cache to
      * keep from updating it too often
      */
     static time_t   prev_time;
     time_t          cur_time = time((time_t *)NULL);
 
     int             mib[2];
 
     u_long          phys_mem;
     size_t          phys_mem_size = sizeof(phys_mem);
 
     int		    pagesize;
     size_t          pagesize_size = sizeof(pagesize);
 
     u_long	    pages_used;
 
     off_t	    swapFree;
     static off_t	    swapUsed;
     off_t	    swapSize;
    
     /* for host_statistics() */
     vm_statistics_data_t vm_stat;
     int count = HOST_VM_INFO_COUNT;
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     mib[0] = CTL_HW;
     mib[1] = HW_PHYSMEM;
     
     /*
      * Physical memory 
      */
     if(sysctl(mib, 2, &phys_mem, &phys_mem_size, NULL, 0) == -1)
 	    snmp_log_perror("sysctl: phys_mem");
 
     /*
      * Pagesize
      */
     mib[1] = HW_PAGESIZE;
     if(sysctl(mib, 2, &pagesize, &pagesize_size, NULL, 0) == -1)
 	    snmp_log_perror("sysctl: pagesize");
     /*
      * used memory
      */
     host_statistics(mach_host_self(),HOST_VM_INFO,&vm_stat,&count);
     pages_used = vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count;
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (pagesize >> 10))
 
     /*
      * swap info
      */
 
     swapSize = swapsize();
     /* if it's been less then 30 seconds since the
     * last run, don't call the pages_swapped() 
     * routine yet */
     if(cur_time > prev_time + 30) {
         swapUsed = (off_t) pages_swapped();
         prev_time = time((time_t *)NULL);
     }
     swapFree = swapSize - (swapUsed * pagesize);
 
     long_ret = 0;               /* set to 0 as default */
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 0;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "swap");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case MEMTOTALSWAP:
         long_ret = swapSize >> 10;
         return ((u_char *) (&long_ret));
     case MEMAVAILSWAP:         /* FREE swap memory */
 	    long_ret = swapFree >> 10;
         return ((u_char *) (&long_ret));
     case MEMTOTALREAL:
         long_ret = phys_mem >> 10;
         return ((u_char *) (&long_ret));
     case MEMAVAILREAL:         /* FREE real memory */
         long_ret = (phys_mem >> 10) - (ptok(pages_used));
         return ((u_char *) (&long_ret));
     case MEMSWAPMINIMUM:
 	long_ret = minimumswap;
 	return ((u_char *) (&long_ret));
         /*
          * these are not implemented 
          */
     case MEMTOTALSWAPTXT:
     case MEMUSEDSWAPTXT:
     case MEMTOTALREALTXT:
     case MEMUSEDREALTXT:
     case MEMTOTALFREE:
     case MEMSHARED:
     case MEMBUFFER:
     case MEMCACHED:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
 
     case ERRORFLAG:
         long_ret = (swapFree > minimumswap) ? 0 : 1;
         return ((u_char *) (&long_ret));
     case ERRORMSG:
         if (swapFree < minimumswap)
             sprintf(errmsg, "Running out of swap space (%qd)", swapFree);
         else
             errmsg[0] = 0;
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     }
     return NULL;
 }
 
 
 /* get the number of pages that are swapped out */
 /* we think this is correct and are valid values */
 /* but not sure. time will tell if it's correct */
 /* Note: this routine is _expensive_!!! we run this */
 /* as little as possible by caching it's return so */
 /* it's not run on every poll */
 /* Apple, please give us a better way! :) */
 int pages_swapped(void) {
      boolean_t       retval;
      kern_return_t   error;
      processor_set_t *psets, pset;
      task_t          *tasks;
      unsigned        i, j, pcnt, tcnt;
      int             pid;
      mach_msg_type_number_t  count;
      vm_address_t        address;
      mach_port_t     object_name;
      vm_region_extended_info_data_t info;
      vm_size_t       size;
      mach_port_t mach_port;
      int   swapped_pages;
      int   swapped_pages_total = 0;
      char    errmsg[1024];
 
 
      mach_port = mach_host_self();
      error = host_processor_sets(mach_port, &psets, &pcnt);
      if (error != KERN_SUCCESS) {
         sprintf(errmsg, "Error in host_processor_sets(): %s\n", mach_error_string(error));
         snmp_log_perror(errmsg);
         return(0);
      }
 
      for (i = 0; i < pcnt; i++) {
         error = host_processor_set_priv(mach_port, psets[i], &pset);
         if (error != KERN_SUCCESS) {
             sprintf(errmsg,"Error in host_processor_set_priv(): %s\n", mach_error_string(error));
             snmp_log_perror(errmsg);
             return(0);
         }
 
         error = processor_set_tasks(pset, &tasks, &tcnt);
         if (error != KERN_SUCCESS) {
             sprintf(errmsg,"Error in processor_set_tasks(): %s\n", mach_error_string(error));
             snmp_log_perror(errmsg);
             return(0);
         }
 
         for (j = 0; j < tcnt; j++) {
             error = pid_for_task(tasks[j], &pid);
             if (error != KERN_SUCCESS) {
                 /* Not a process, or the process is gone. */
                 continue;
             }
 
             swapped_pages = 0;
             for (address = 0;; address += size) {
                 kern_return_t ret = KERN_FAILURE;
 
                 /* Get memory region. */
                 count = VM_REGION_EXTENDED_INFO_COUNT;
-#if HAVE_VM_REGION_64
+#ifdef HAVE_VM_REGION_64
                 ret = vm_region64(tasks[j], &address, &size,
                                   VM_REGION_EXTENDED_INFO,
                                   (vm_region_extended_info_t)&info, &count,
                                   &object_name);
-#elif HAVE_VM_REGION
+#elif defined(HAVE_VM_REGION)
                 ret = vm_region(tasks[j], &address, &size,
                                 VM_REGION_EXTENDED_INFO,
                                 (vm_region_extended_info_t)&info, &count,
                                 &object_name);
 #error How to query memory protection information?
 #endif
                 if (ret != KERN_SUCCESS) {
                     /* No more memory regions. */
                     break;
                 }
             
                 if(info.pages_swapped_out > 0) {
                     swapped_pages += info.pages_swapped_out;
                 } 
             }
            
             if(swapped_pages > 0) {
                 swapped_pages_total += swapped_pages; 
             }
 
             if (tasks[j] != mach_task_self()) {
                 mach_port_deallocate(mach_task_self(), tasks[j]);
             }  
         }
     }
 
     return(swapped_pages_total);
 }
diff --git a/agent/mibgroup/ucd-snmp/memory_freebsd2.c b/agent/mibgroup/ucd-snmp/memory_freebsd2.c
index 22dde4c09e..927adcbea3 100644
--- a/agent/mibgroup/ucd-snmp/memory_freebsd2.c
+++ b/agent/mibgroup/ucd-snmp/memory_freebsd2.c
@@ -1,73 +1,73 @@
 /*
  * memory_freebsd2.c
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 
 /*
  * Ripped from /usr/scr/usr.bin/vmstat/vmstat.c (covering all bases) 
  */
 #include <sys/param.h>
 #include <sys/time.h>
 #ifdef dragonfly
 #include <sys/user.h>
 #else
 #include <sys/proc.h>
 #include <sys/dkstat.h>
 #endif
 #ifdef freebsd5
 #include <sys/bio.h>
 #endif
 #include <sys/buf.h>
 #include <sys/uio.h>
 #include <sys/namei.h>
 #include <sys/malloc.h>
 #include <sys/signal.h>
 #include <sys/fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/sysctl.h>
 #include <sys/vmmeter.h>
 
-#if HAVE_SYS_VMPARAM_H
+#ifdef HAVE_SYS_VMPARAM_H
 #include <sys/vmparam.h>
 #else
 #include <vm/vm_param.h>
 #endif
 
 #include <time.h>
 #include <nlist.h>
 #include <kvm.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
 #include <paths.h>
 #include <limits.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "util_funcs.h"
 #include "memory.h"
 #include "memory_freebsd2.h"
 
 /*
  * nlist symbols 
  */
 #define SUM_SYMBOL      "cnt"
 #ifndef openbsd2
 #define BUFSPACE_SYMBOL "bufspace"
 #endif
 
 /*
  * Default swap warning limit (kb) 
  */
 #define DEFAULTMINIMUMSWAP 16000
 
 /*
  * Swap warning limit 
  */
@@ -249,141 +249,141 @@ static unsigned char *
 var_extensible_mem(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
     static char     errmsg[1024];
 
 #ifdef dragonfly
     static struct vmstats mem;
     size_t        vmstats_size = sizeof(mem);
 #endif
     static struct vmmeter mem;
 #endif
     static struct vmtotal total;
 
     size_t          total_size = sizeof(total);
     int             total_mib[] = { CTL_VM, VM_METER };
 
     u_long          phys_mem;
     size_t          phys_mem_size = sizeof(phys_mem);
     int             phys_mem_mib[] = { CTL_HW, HW_PHYSMEM };
 
 #ifdef BUFSPACE_SYMBOL
     long            bufspace;
 #endif
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Memory info 
      */
 #ifdef dragonfly
     sysctlbyname("vm.vmstats", &vmstats, &vmstats_size, NULL, 0);
 #else
     auto_nlist(SUM_SYMBOL, (char *) &mem, sizeof(mem));
 #endif
     sysctl(total_mib, 2, &total, &total_size, NULL, 0);
 
     /*
      * Swap info 
      */
     swapmode();
     /*
      * getSwap(); 
      */
 
     /*
      * Physical memory 
      */
     sysctl(phys_mem_mib, 2, &phys_mem, &phys_mem_size, NULL, 0);
 
 #ifdef BUFSPACE_SYMBOL
     /*
      * Buffer space 
      */
     auto_nlist(BUFSPACE_SYMBOL, (char *) &bufspace, sizeof(bufspace));
 #endif
 
     long_ret = 0;               /* set to 0 as default */
 
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (mem.v_page_size >> 10))
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 0;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "swap");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case MEMTOTALSWAP:
         long_ret = swapTotal;
         return ((u_char *) (&long_ret));
     case MEMAVAILSWAP:         /* FREE swap memory */
         long_ret = swapFree;
         return ((u_char *) (&long_ret));
     case MEMTOTALREAL:
         long_ret = phys_mem >> 10;
         return ((u_char *) (&long_ret));
     case MEMAVAILREAL:         /* FREE real memory */
         long_ret = ptok(mem.v_free_count);
         return ((u_char *) (&long_ret));
 
         /*
          * these are not implemented 
          */
     case MEMTOTALSWAPTXT:
     case MEMUSEDSWAPTXT:
     case MEMTOTALREALTXT:
     case MEMUSEDREALTXT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
 
     case MEMTOTALFREE:
         long_ret = ptok((int) total.t_free);
         return ((u_char *) (&long_ret));
     case MEMSWAPMINIMUM:
         long_ret = minimumswap;
         return ((u_char *) (&long_ret));
     case MEMSHARED:
         long_ret = ptok(total.t_vmshr +
                         total.t_avmshr + total.t_rmshr + total.t_armshr);
         return ((u_char *) (&long_ret));
 #ifdef BUFSPACE_SYMBOL
     case MEMBUFFER:
         long_ret = bufspace >> 10;
         return ((u_char *) (&long_ret));
 #endif
 #ifndef openbsd2
     case MEMCACHED:
 #ifdef darwin
         long_ret = ptok(mem.v_lookups);
 #elif  defined(dragonfly)
         long_ret = ptok(mem.v_cache_count);
 #else
         long_ret = ptok(mem.v_cache_count) + ptok(mem.v_inactive_count);
 #endif
         return ((u_char *) (&long_ret));
 #endif
     case ERRORFLAG:
         long_ret = (swapFree > minimumswap) ? 0 : 1;
         return ((u_char *) (&long_ret));
     case ERRORMSG:
         if (swapFree < minimumswap)
             sprintf(errmsg, "Running out of swap space (%qd)", swapFree);
         else
             errmsg[0] = 0;
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/memory_hpux.c b/agent/mibgroup/ucd-snmp/memory_hpux.c
index c2b2478586..cbad70cb67 100644
--- a/agent/mibgroup/ucd-snmp/memory_hpux.c
+++ b/agent/mibgroup/ucd-snmp/memory_hpux.c
@@ -1,20 +1,20 @@
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <sys/types.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include "memory.h"             /* the module-specific header */
 #include "memory_hpux.h"        /* the module-specific header */
 
 #include <sys/pstat.h>
 
 #define MAXSTRSIZE	80
 #define DEFAULTMINIMUMSWAP 16000        /* kilobytes */
diff --git a/agent/mibgroup/ucd-snmp/memory_netbsd1.c b/agent/mibgroup/ucd-snmp/memory_netbsd1.c
index 4fec88cb92..6a8dddc529 100644
--- a/agent/mibgroup/ucd-snmp/memory_netbsd1.c
+++ b/agent/mibgroup/ucd-snmp/memory_netbsd1.c
@@ -158,109 +158,109 @@ unsigned char  *
 var_extensible_mem(struct variable *vp,
                    oid * name,
                    size_t * length,
                    int exact,
                    size_t * var_len, WriteMethod ** write_method)
 {
     static long     long_ret;
     static char     errmsg[1024];
 
     static struct uvmexp uvmexp;
     size_t          uvmexp_size = sizeof(uvmexp);
     int             uvmexp_mib[] = { CTL_VM, VM_UVMEXP };
     static struct vmtotal total;
     size_t          total_size = sizeof(total);
     int             total_mib[] = { CTL_VM, VM_METER };
 
     long            phys_mem;
     size_t          phys_mem_size = sizeof(phys_mem);
     int             phys_mem_mib[] = { CTL_HW, HW_PHYSMEM };
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Memory info 
      */
     if (sysctl(uvmexp_mib, 2, &uvmexp, &uvmexp_size, NULL, 0) == -1) {
         snmp_log(LOG_ERR, "sysctl VM_UVMEXP failed (errno %d)\n", errno);
         return NULL;
     }
     if (sysctl(total_mib, 2, &total, &total_size, NULL, 0) == -1) {
         snmp_log(LOG_ERR, "sysctl VM_METER failed (errno %d)\n", errno);
         return NULL;
     }
 
     /*
      * Physical memory 
      */
     if (sysctl(phys_mem_mib, 2, &phys_mem, &phys_mem_size, NULL, 0) == -1) {
         snmp_log(LOG_ERR, "sysctl HW_USERMEM failed (errno %d)\n", errno);
         return NULL;
     }
 
     long_ret = 0;               /* set to 0 as default */
 
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (uvmexp.pagesize >> 10))
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 0;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "swap");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case MEMTOTALSWAP:
         long_ret = ptok(uvmexp.swpages);
         return ((u_char *) (&long_ret));
     case MEMAVAILSWAP:         /* FREE swap memory */
         long_ret = ptok(uvmexp.swpages - uvmexp.swpginuse);
         return ((u_char *) (&long_ret));
     case MEMTOTALREAL:
         long_ret = phys_mem >> 10;
         return ((u_char *) (&long_ret));
     case MEMAVAILREAL:         /* FREE real memory */
         long_ret = ptok(uvmexp.free);
         return ((u_char *) (&long_ret));
 
         /*
          * these are not implemented 
          */
     case MEMTOTALSWAPTXT:
     case MEMUSEDSWAPTXT:
     case MEMTOTALREALTXT:
     case MEMUSEDREALTXT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
 
     case MEMTOTALFREE:
         long_ret = ptok((int) total.t_free);
         return ((u_char *) (&long_ret));
     case MEMSWAPMINIMUM:
         long_ret = minimumswap;
         return ((u_char *) (&long_ret));
     case MEMSHARED:
         return ((u_char *) (&long_ret));
     case MEMBUFFER:
         return NULL;
     case MEMCACHED:
         return NULL;
     case ERRORFLAG:
         long_ret = (swapFree > minimumswap) ? 0 : 1;
         return ((u_char *) (&long_ret));
     case ERRORMSG:
         if (swapFree < minimumswap)
             sprintf(errmsg, "Running out of swap space (%qd)", swapFree);
         else
             errmsg[0] = 0;
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/memory_solaris2.c b/agent/mibgroup/ucd-snmp/memory_solaris2.c
index 2d36278c92..8caa238c48 100644
--- a/agent/mibgroup/ucd-snmp/memory_solaris2.c
+++ b/agent/mibgroup/ucd-snmp/memory_solaris2.c
@@ -1,24 +1,24 @@
 #include <net-snmp/net-snmp-config.h>   /* local SNMP configuration details */
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <sys/types.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "util_funcs/header_generic.h" /* utility function declarations */
 #include "memory.h"             /* the module-specific header */
 #include "memory_solaris2.h"    /* the module-specific header */
 
 #include <kstat.h>
 #include <sys/stat.h>
 #include <sys/swap.h>
 #include <unistd.h>
 
 #define MAXSTRSIZE	80
diff --git a/agent/mibgroup/ucd-snmp/pass.c b/agent/mibgroup/ucd-snmp/pass.c
index 6411e0f20b..88e95d3e45 100644
--- a/agent/mibgroup/ucd-snmp/pass.c
+++ b/agent/mibgroup/ucd-snmp/pass.c
@@ -1,38 +1,38 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
 # include <sys/wait.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #ifdef WIN32
 #include <limits.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "struct.h"
 #include "pass.h"
 #include "pass_common.h"
 #include "extensible.h"
 #include "util_funcs.h"
diff --git a/agent/mibgroup/ucd-snmp/pass_common.c b/agent/mibgroup/ucd-snmp/pass_common.c
index 830f6389d8..4e0538077b 100644
--- a/agent/mibgroup/ucd-snmp/pass_common.c
+++ b/agent/mibgroup/ucd-snmp/pass_common.c
@@ -1,15 +1,15 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <ctype.h>
 #include <stddef.h>
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "mibgroup/util_funcs.h"
 #include "pass_common.h"
diff --git a/agent/mibgroup/ucd-snmp/pass_persist.c b/agent/mibgroup/ucd-snmp/pass_persist.c
index ea7e20ce87..15272d4ff8 100644
--- a/agent/mibgroup/ucd-snmp/pass_persist.c
+++ b/agent/mibgroup/ucd-snmp/pass_persist.c
@@ -1,43 +1,43 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
 # include <sys/wait.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #ifdef WIN32
 #include <limits.h>
 #endif
 
 #include <signal.h>
 #include <errno.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "struct.h"
 #include "pass_persist.h"
 #include "pass_common.h"
 #include "extensible.h"
 #include "util_funcs.h"
diff --git a/agent/mibgroup/ucd-snmp/proc.c b/agent/mibgroup/ucd-snmp/proc.c
index 9737a69ccf..f7c505a7a6 100644
--- a/agent/mibgroup/ucd-snmp/proc.c
+++ b/agent/mibgroup/ucd-snmp/proc.c
@@ -1,64 +1,64 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef solaris2
 #define _KMEMUSER               /* Needed by <sys/user.h> */
 #include <sys/types.h>          /* helps define struct rlimit */
 #endif
 
 #ifdef HAVE_IO_H                   /* win32 */
 #include <io.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <math.h>
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_PCRE_H
 #include <pcre.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "mibdefs.h"
 #include "struct.h"
 #include "proc.h"
 #ifdef USING_HOST_DATA_ACCESS_SWRUN_MODULE
 #include <net-snmp/data_access/swrun.h>
 #endif
 #ifdef USING_UCD_SNMP_ERRORMIB_MODULE
 #include "errormib.h"
 #else
 #define setPerrorstatus(x) snmp_log_perror(x)
 #endif
 #include "util_funcs.h"
 
 #define PROCMIN 3
 #define PROCMAX 4
 #define PROCCOUNT 5
diff --git a/agent/mibgroup/ucd-snmp/proxy.c b/agent/mibgroup/ucd-snmp/proxy.c
index 82ee8faefa..22ced58534 100644
--- a/agent/mibgroup/ucd-snmp/proxy.c
+++ b/agent/mibgroup/ucd-snmp/proxy.c
@@ -1,33 +1,33 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright @ 2009 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "proxy.h"
diff --git a/agent/mibgroup/ucd-snmp/versioninfo.c b/agent/mibgroup/ucd-snmp/versioninfo.c
index 4d727d13ce..ddf8c95665 100644
--- a/agent/mibgroup/ucd-snmp/versioninfo.c
+++ b/agent/mibgroup/ucd-snmp/versioninfo.c
@@ -1,29 +1,29 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
 #include "struct.h"
 #include "versioninfo.h"
 #include "util_funcs/header_generic.h"
 #include "util_funcs/restart.h"
 #include "util_funcs.h" /* clear_cache */
diff --git a/agent/mibgroup/ucd-snmp/vmstat_bsdi4.c b/agent/mibgroup/ucd-snmp/vmstat_bsdi4.c
index e35b6cd1ba..4abccb223d 100644
--- a/agent/mibgroup/ucd-snmp/vmstat_bsdi4.c
+++ b/agent/mibgroup/ucd-snmp/vmstat_bsdi4.c
@@ -136,153 +136,153 @@ unsigned char  *
 var_extensible_vmstat(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
 {
 
     int             loop;
 
     time_t          time_new = getuptime();
     static time_t   time_old;
     static time_t   time_diff;
 
     static long     cpu_old[CPUSTATES];
     static long     cpu_new[CPUSTATES];
     static long     cpu_diff[CPUSTATES];
     static long     cpu_total;
     long            cpu_sum;
     double          cpu_prc;
 
     static struct vmmeter mem_old, mem_new;
     int             mem_mib[] = { CTL_VM, VM_CNT };
     size_t          mem_size = sizeof(struct vmmeter);
     int             cpu_mib[] = { CTL_KERN, KERN_CPUSTATS };
     size_t          cpu_size = sizeof(struct cpustats);
 
     static long     long_ret;
     static char     errmsg[300];
 
     long_ret = 0;               /* set to 0 as default */
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Update structures (only if time has passed) 
      */
     if (time_new != time_old) {
         time_diff = time_new - time_old;
         time_old = time_new;
 
         /*
          * CPU usage 
          */
         sysctl(cpu_mib, 2, &cpu_new, &cpu_size, NULL, 0);
 
         cpu_total = 0;
 
         for (loop = 0; loop < CPUSTATES; loop++) {
             cpu_diff[loop] = cpu_new[loop] - cpu_old[loop];
             cpu_old[loop] = cpu_new[loop];
             cpu_total += cpu_diff[loop];
         }
 
         if (cpu_total == 0)
             cpu_total = 1;
 
         /*
          * Memory info 
          */
         mem_old = mem_new;
         sysctl(mem_mib, 2, &mem_new, &mem_size, NULL, 0);
     }
 
     /*
      * Rate macro 
      */
 #define rate(x) (((x)+ time_diff/2) / time_diff)
 
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (mem_new.v_page_size >> 10))
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 1;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "systemStats");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case SWAPIN:
         long_ret = ptok(mem_new.v_swpin - mem_old.v_swpin);
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case SWAPOUT:
         long_ret = ptok(mem_new.v_swpout - mem_old.v_swpout);
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case IOSENT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case IORECEIVE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case SYSINTERRUPTS:
         long_ret = rate(mem_new.v_intr - mem_old.v_intr);
         return ((u_char *) (&long_ret));
     case SYSCONTEXT:
         long_ret = rate(mem_new.v_swtch - mem_old.v_swtch);
         return ((u_char *) (&long_ret));
     case CPUUSER:
         cpu_sum = cpu_diff[CP_USER] + cpu_diff[CP_NICE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUSYSTEM:
         cpu_sum = cpu_diff[CP_SYS] + cpu_diff[CP_INTR];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUIDLE:
         cpu_sum = cpu_diff[CP_IDLE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPURAWUSER:
         long_ret = cpu_new[CP_USER];
         return ((u_char *) (&long_ret));
     case CPURAWNICE:
         long_ret = cpu_new[CP_NICE];
         return ((u_char *) (&long_ret));
     case CPURAWSYSTEM:
         long_ret = cpu_new[CP_SYS] + cpu_new[CP_INTR];
         return ((u_char *) (&long_ret));
     case CPURAWIDLE:
         long_ret = cpu_new[CP_IDLE];
         return ((u_char *) (&long_ret));
     case CPURAWKERNEL:
         long_ret = cpu_new[CP_SYS];
         return ((u_char *) (&long_ret));
     case CPURAWINTR:
         long_ret = cpu_new[CP_INTR];
         return ((u_char *) (&long_ret));
         /*
          * reserved for future use 
          */
         /*
          * case ERRORFLAG:
          * return((u_char *) (&long_ret));
          * case ERRORMSG:
          * return((u_char *) (&long_ret));
          */
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/vmstat_darwin7.c b/agent/mibgroup/ucd-snmp/vmstat_darwin7.c
index d96c55c677..87f77981be 100644
--- a/agent/mibgroup/ucd-snmp/vmstat_darwin7.c
+++ b/agent/mibgroup/ucd-snmp/vmstat_darwin7.c
@@ -1,68 +1,68 @@
 /*
  * vmstat_darwin7.c
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 /*
  * Ripped from /usr/scr/usr.bin/vmstat/vmstat.c (covering all bases) 
  */
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/proc.h>
 #include <sys/dkstat.h>
 #include <sys/buf.h>
 #include <sys/uio.h>
 #include <sys/malloc.h>
 #include <sys/signal.h>
 #include <sys/fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/sysctl.h>
 #include <sys/vmmeter.h>
 
-#if HAVE_SYS_VMPARAM_H
+#ifdef HAVE_SYS_VMPARAM_H
 #include <sys/vmparam.h>
 #else
 #include <vm/vm_param.h>
 #endif
 
 #include <time.h>
 #include <nlist.h>
 #include <kvm.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
 #include <paths.h>
 #include <limits.h>
 
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "util_funcs/header_generic.h"
 #include "vmstat.h"
 #include "vmstat_darwin7.h"
 
 
 /*
  * nlist symbols 
  */
 #define CPTIME_SYMBOL   "cp_time"
 #define SUM_SYMBOL      "cnt"
 #define INTRCNT_SYMBOL  "intrcnt"
 #define EINTRCNT_SYMBOL "eintrcnt"
 #define BOOTTIME_SYMBOL "boottime"
 
 /*
  * Number of interrupts 
  */
 #define INT_COUNT       10
 
 /*
  * CPU percentage 
  */
 #define CPU_PRC         100
@@ -157,168 +157,168 @@ unsigned char  *
 var_extensible_vmstat(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
 {
 
     int             loop;
 
     time_t          time_new = getuptime();
     static time_t   time_old;
     static time_t   time_diff;
 
 /*    static long     cpu_old[CPUSTATES];
     static long     cpu_new[CPUSTATES];
     static long     cpu_diff[CPUSTATES]; */
     static long     cpu_total;
     long            cpu_sum;
     double          cpu_prc;
 
     static struct vmmeter mem_old, mem_new;
 
     static long     long_ret;
     static char     errmsg[300];
 
     long_ret = 0;               /* set to 0 as default */
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Update structures (only if time has passed)
      * we only update every 30 seconds so that we don't
      * get strange results, especially with cpu information
      */    
     if (time_new > time_old + 30) {
         time_diff = time_new - time_old;
         time_old = time_new;
 
         /*
          * CPU usage 
          */
 /*        auto_nlist(CPTIME_SYMBOL, (char *) cpu_new, sizeof(cpu_new)); */
 
         cpu_total = 0;
 
 /*        for (loop = 0; loop < CPUSTATES; loop++) {
             cpu_diff[loop] = cpu_new[loop] - cpu_old[loop];
             cpu_old[loop] = cpu_new[loop];
             cpu_total += cpu_diff[loop];
         }
 	*/
 
         if (cpu_total == 0)
             cpu_total = 1;
 
         /*
          * Memory info 
          */
         mem_old = mem_new;
         auto_nlist(SUM_SYMBOL, (char *) &mem_new, sizeof(mem_new));
     }
 
     /*
      * Rate macro 
      */
 #define rate(x) (((x)+ time_diff/2) / time_diff)
 
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (mem_new.v_page_size >> 10))
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 1;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "systemStats");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case SWAPIN:
 #if defined(openbsd2) || defined(darwin)
         long_ret = ptok(mem_new.v_swpin - mem_old.v_swpin);
 #else
         long_ret = ptok(mem_new.v_swappgsin - mem_old.v_swappgsin +
                         mem_new.v_vnodepgsin - mem_old.v_vnodepgsin);
 #endif
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case SWAPOUT:
 #if defined(openbsd2) || defined(darwin)
         long_ret = ptok(mem_new.v_swpout - mem_old.v_swpout);
 #else
         long_ret = ptok(mem_new.v_swappgsout - mem_old.v_swappgsout +
                         mem_new.v_vnodepgsout - mem_old.v_vnodepgsout);
 #endif
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case IOSENT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case IORECEIVE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case SYSINTERRUPTS:
         long_ret = rate(mem_new.v_intr - mem_old.v_intr);
         return ((u_char *) (&long_ret));
     case SYSCONTEXT:
         long_ret = rate(mem_new.v_swtch - mem_old.v_swtch);
         return ((u_char *) (&long_ret));
     case CPUUSER:
 /*        cpu_sum = cpu_diff[CP_USER] + cpu_diff[CP_NICE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC; */
         return ((u_char *) (&long_ret));
     case CPUSYSTEM:
 /*        cpu_sum = cpu_diff[CP_SYS] + cpu_diff[CP_INTR];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC; */
         return ((u_char *) (&long_ret));
     case CPUIDLE:
 /*        cpu_sum = cpu_diff[CP_IDLE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC; */
         return ((u_char *) (&long_ret));
     case CPURAWUSER:
 /*        long_ret = cpu_new[CP_USER]; */
         return ((u_char *) (&long_ret));
     case CPURAWNICE:
 /*        long_ret = cpu_new[CP_NICE]; */
         return ((u_char *) (&long_ret));
     case CPURAWSYSTEM:
 /*        long_ret = cpu_new[CP_SYS] + cpu_new[CP_INTR]; */
         return ((u_char *) (&long_ret));
     case CPURAWIDLE:
 /*        long_ret = cpu_new[CP_IDLE]; */
         return ((u_char *) (&long_ret));
     case CPURAWKERNEL:
 /*        long_ret = cpu_new[CP_SYS]; */
         return ((u_char *) (&long_ret));
     case CPURAWINTR:
 /*        long_ret = cpu_new[CP_INTR]; */
         return ((u_char *) (&long_ret));
     case SYSRAWINTERRUPTS:
         long_ret = mem_new.v_intr;
         return ((u_char *) (&long_ret));
     case SYSRAWCONTEXT:
         long_ret = mem_new.v_swtch;
         return ((u_char *) (&long_ret));
         /*
          * reserved for future use 
          */
         /*
          * case ERRORFLAG:
          * return((u_char *) (&long_ret));
          * case ERRORMSG:
          * return((u_char *) (&long_ret));
          */
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/vmstat_freebsd2.c b/agent/mibgroup/ucd-snmp/vmstat_freebsd2.c
index 3de89b20b3..f8d9c0aa6c 100644
--- a/agent/mibgroup/ucd-snmp/vmstat_freebsd2.c
+++ b/agent/mibgroup/ucd-snmp/vmstat_freebsd2.c
@@ -1,82 +1,82 @@
 /*
  * vmstat_freebsd2.c
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 /*
  * Ripped from /usr/scr/usr.bin/vmstat/vmstat.c (covering all bases) 
  */
 #include <sys/param.h>
 #include <sys/time.h>
 #if defined(dragonfly)
 #include <sys/user.h>
 #else
 #include <sys/proc.h>
 #endif
 #if defined(freebsd5) && __FreeBSD_version >= 500101
 #include <sys/resource.h>
 #elif defined(dragonfly)
 #include <kinfo.h>
 #else
 #include <sys/dkstat.h>
 #endif
 #ifdef freebsd5
 #include <sys/bio.h>
 #endif
 #include <sys/buf.h>
 #include <sys/uio.h>
 #include <sys/namei.h>
 #include <sys/malloc.h>
 #include <sys/signal.h>
 #include <sys/fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/sysctl.h>
 #include <sys/vmmeter.h>
 
-#if HAVE_SYS_VMPARAM_H
+#ifdef HAVE_SYS_VMPARAM_H
 #include <sys/vmparam.h>
 #else
 #include <vm/vm_param.h>
 #endif
 
 #include <time.h>
 #include <nlist.h>
 #include <kvm.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
 #include <paths.h>
 #include <limits.h>
 
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "util_funcs/header_generic.h"
 #include "vmstat.h"
 #include "vmstat_freebsd2.h"
 
 
 /*
  * nlist symbols 
  */
 #define CPTIME_SYMBOL   "cp_time"
 #define SUM_SYMBOL      "cnt"
 #define INTRCNT_SYMBOL  "intrcnt"
 #define EINTRCNT_SYMBOL "eintrcnt"
 #define BOOTTIME_SYMBOL "boottime"
 
 /*
  * Number of interrupts 
  */
 #define INT_COUNT       10
 
 /*
  * CPU percentage 
  */
 #define CPU_PRC         100
@@ -171,230 +171,230 @@ unsigned char  *
 var_extensible_vmstat(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
 {
 
     int             loop;
 
     time_t          time_new = getuptime();
     static time_t   time_old;
     static time_t   time_diff;
 
 #if defined(dragonfly)
     static struct kinfo_cputime cpu_old, cpu_new, cpu_diff;
     static uint64_t cpu_total;
     uint64_t cpu_sum;
     static int pagesize;
 #else
     static long     cpu_old[CPUSTATES];
     static long     cpu_new[CPUSTATES];
     static long     cpu_diff[CPUSTATES];
     static long     cpu_total;
     long            cpu_sum;
 #endif
     double          cpu_prc;
 
     static struct vmmeter mem_old, mem_new;
 
     static long     long_ret;
     static char     errmsg[300];
 
 #if defined(dragonfly)
     if (pagesize == 0)
 	    pagesize = getpagesize() >> 10;
 #endif
 
     long_ret = 0;               /* set to 0 as default */
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Update structures (only if time has passed) 
      */
     if (time_new != time_old) {
         time_diff = time_new - time_old;
         time_old = time_new;
 
         /*
          * CPU usage 
          */
 
         cpu_total = 0;
 
 #if defined(dragonfly)
 	kinfo_get_sched_cputime(&cpu_new);
 #define CP_UPDATE(field) cpu_diff.field = cpu_new.field - cpu_old.field; cpu_total += cpu_diff.field;
 	CP_UPDATE(cp_user);
 	CP_UPDATE(cp_nice);
 	CP_UPDATE(cp_sys);
 	CP_UPDATE(cp_intr);
 	CP_UPDATE(cp_idle);
 	cpu_old = cpu_new;
 #undef CP_UPDATE
 #else
         auto_nlist(CPTIME_SYMBOL, (char *) cpu_new, sizeof(cpu_new));
 
         for (loop = 0; loop < CPUSTATES; loop++) {
             cpu_diff[loop] = cpu_new[loop] - cpu_old[loop];
             cpu_old[loop] = cpu_new[loop];
             cpu_total += cpu_diff[loop];
         }
 #endif
 
         if (cpu_total == 0)
             cpu_total = 1;
 
         /*
          * Memory info 
          */
         mem_old = mem_new;
         auto_nlist(SUM_SYMBOL, (char *) &mem_new, sizeof(mem_new));
     }
 
     /*
      * Rate macro 
      */
 #define rate(x) (((x)+ time_diff/2) / time_diff)
 
     /*
      * Page-to-kb macro 
      */
 #if defined(dragonfly)
 #define ptok(p) ((p) * pagesize)
 #else
 #define ptok(p) ((p) * (mem_new.v_page_size >> 10))
 #endif
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 1;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "systemStats");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case SWAPIN:
 #if defined(openbsd2) || defined(darwin)
         long_ret = ptok(mem_new.v_swpin - mem_old.v_swpin);
 #else
         long_ret = ptok(mem_new.v_swappgsin - mem_old.v_swappgsin +
                         mem_new.v_vnodepgsin - mem_old.v_vnodepgsin);
 #endif
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case SWAPOUT:
 #if defined(openbsd2) || defined(darwin)
         long_ret = ptok(mem_new.v_swpout - mem_old.v_swpout);
 #else
         long_ret = ptok(mem_new.v_swappgsout - mem_old.v_swappgsout +
                         mem_new.v_vnodepgsout - mem_old.v_vnodepgsout);
 #endif
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case IOSENT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case IORECEIVE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case SYSINTERRUPTS:
         long_ret = rate(mem_new.v_intr - mem_old.v_intr);
         return ((u_char *) (&long_ret));
     case SYSCONTEXT:
         long_ret = rate(mem_new.v_swtch - mem_old.v_swtch);
         return ((u_char *) (&long_ret));
     case CPUUSER:
 #if defined(dragonfly)
         cpu_sum = cpu_diff.cp_user  + cpu_diff.cp_nice;
 #else
         cpu_sum = cpu_diff[CP_USER] + cpu_diff[CP_NICE];
 #endif
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUSYSTEM:
 #if defined(dragonfly)
         cpu_sum = cpu_diff.cp_sys  + cpu_diff.cp_intr;
 #else
         cpu_sum = cpu_diff[CP_SYS] + cpu_diff[CP_INTR];
 #endif
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUIDLE:
 #if defined(dragonfly)
         cpu_sum = cpu_diff.cp_idle;
 #else
         cpu_sum = cpu_diff[CP_IDLE];
 #endif
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPURAWUSER:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_user;
 #else
         long_ret = cpu_new[CP_USER];
 #endif
         return ((u_char *) (&long_ret));
     case CPURAWNICE:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_nice;
 #else
         long_ret = cpu_new[CP_NICE];
 #endif
         return ((u_char *) (&long_ret));
     case CPURAWSYSTEM:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_sys  + cpu_new.cp_nice;
 #else
         long_ret = cpu_new[CP_SYS] + cpu_new[CP_INTR];
 #endif
         return ((u_char *) (&long_ret));
     case CPURAWIDLE:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_idle;
 #else
         long_ret = cpu_new[CP_IDLE];
 #endif
         return ((u_char *) (&long_ret));
     case CPURAWKERNEL:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_sys;
 #else
         long_ret = cpu_new[CP_SYS];
 #endif
         return ((u_char *) (&long_ret));
     case CPURAWINTR:
 #if defined(dragonfly)
         long_ret = cpu_new.cp_intr;
 #else
         long_ret = cpu_new[CP_INTR];
 #endif
         return ((u_char *) (&long_ret));
     case SYSRAWINTERRUPTS:
         long_ret = mem_new.v_intr;
         return ((u_char *) (&long_ret));
     case SYSRAWCONTEXT:
         long_ret = mem_new.v_swtch;
         return ((u_char *) (&long_ret));
         /*
          * reserved for future use 
          */
         /*
          * case ERRORFLAG:
          * return((u_char *) (&long_ret));
          * case ERRORMSG:
          * return((u_char *) (&long_ret));
          */
     }
     return NULL;
 }
diff --git a/agent/mibgroup/ucd-snmp/vmstat_linux.c b/agent/mibgroup/ucd-snmp/vmstat_linux.c
index 2708a09f0c..a2eeb8ccbc 100644
--- a/agent/mibgroup/ucd-snmp/vmstat_linux.c
+++ b/agent/mibgroup/ucd-snmp/vmstat_linux.c
@@ -1,113 +1,113 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #include <ctype.h>
 #include <signal.h>
-#if HAVE_MACHINE_PARAM_H
+#ifdef HAVE_MACHINE_PARAM_H
 #include <machine/param.h>
 #endif
-#if HAVE_SYS_VMMETER_H
+#ifdef HAVE_SYS_VMMETER_H
 #if !defined(bsdi2) && !defined(netbsd1)
 #include <sys/vmmeter.h>
 #endif
 #endif
-#if HAVE_SYS_CONF_H
+#ifdef HAVE_SYS_CONF_H
 #include <sys/conf.h>
 #endif
-#if HAVE_SYS_FS_H
+#ifdef HAVE_SYS_FS_H
 #include <sys/fs.h>
 #else
-#if HAVE_UFS_FS_H
+#ifdef HAVE_UFS_FS_H
 #include <ufs/fs.h>
 #else
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #ifdef HAVE_SYS_VNODE_H
 #include <sys/vnode.h>
 #endif
 #ifdef HAVE_UFS_UFS_QUOTA_H
 #include <ufs/ufs/quota.h>
 #endif
 #ifdef HAVE_UFS_UFS_INODE_H
 #include <ufs/ufs/inode.h>
 #endif
-#if HAVE_UFS_FFS_FS_H
+#ifdef HAVE_UFS_FFS_FS_H
 #include <ufs/ffs/fs.h>
 #endif
 #endif
 #endif
-#if HAVE_MTAB_H
+#ifdef HAVE_MTAB_H
 #include <mtab.h>
 #endif
 #include <sys/stat.h>
 #include <errno.h>
-#if HAVE_FSTAB_H
+#ifdef HAVE_FSTAB_H
 #include <fstab.h>
 #endif
-#if HAVE_SYS_STATVFS_H
+#ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
-#if HAVE_SYS_VFS_H
+#ifdef HAVE_SYS_VFS_H
 #include <sys/vfs.h>
 #endif
 #if (!defined(HAVE_STATVFS)) && defined(HAVE_STATFS)
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_MOUNT_H
+#ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #define statvfs statfs
 #endif
-#if HAVE_VM_SWAP_PAGER_H
+#ifdef HAVE_VM_SWAP_PAGER_H
 #include <vm/swap_pager.h>
 #endif
-#if HAVE_SYS_FIXPOINT_H
+#ifdef HAVE_SYS_FIXPOINT_H
 #include <sys/fixpoint.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <sys/utsname.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/auto_nlist.h>
 #include <net-snmp/agent/hardware/cpu.h>
 
 #include "mibdefs.h"
 #include "struct.h"
 #include "util_funcs/header_generic.h"
 #include "vmstat.h"
diff --git a/agent/mibgroup/ucd-snmp/vmstat_netbsd1.c b/agent/mibgroup/ucd-snmp/vmstat_netbsd1.c
index 9706c42a45..c06300fc07 100644
--- a/agent/mibgroup/ucd-snmp/vmstat_netbsd1.c
+++ b/agent/mibgroup/ucd-snmp/vmstat_netbsd1.c
@@ -146,177 +146,177 @@ unsigned char  *
 var_extensible_vmstat(struct variable *vp,
                       oid * name,
                       size_t * length,
                       int exact,
                       size_t * var_len, WriteMethod ** write_method)
 {
 
     int             loop;
 
     time_t          time_new = getuptime();
     static time_t   time_old;
     static time_t   time_diff;
 
 #if defined(KERN_CP_TIME)
     static uint64_t  cpu_old[CPUSTATES];
     static uint64_t  cpu_new[CPUSTATES];
     static uint64_t  cpu_diff[CPUSTATES];
     static uint64_t  cpu_total;
 #elif defined(KERN_CPTIME)
     static long     cpu_old[CPUSTATES];
     static long     cpu_new[CPUSTATES];
     static long     cpu_diff[CPUSTATES];
     static long     cpu_total;
 #else
     static long     cpu_old[CPUSTATES];
     static long     cpu_new[CPUSTATES];
     static long     cpu_diff[CPUSTATES];
     static long     cpu_total;
 #endif
     long            cpu_sum;
     double          cpu_prc;
 
     static struct uvmexp mem_old, mem_new;
     int             mem_mib[] = { CTL_VM, VM_UVMEXP };
     size_t          mem_size = sizeof(struct uvmexp);
 
     static long     long_ret;
     static char     errmsg[300];
 
     long_ret = 0;               /* set to 0 as default */
 
     if (header_generic(vp, name, length, exact, var_len, write_method))
         return (NULL);
 
     /*
      * Update structures (only if time has passed) 
      */
     if (time_new != time_old) {
 #ifdef KERN_CP_TIME
         int             mib[2] = { CTL_KERN, KERN_CP_TIME };
         size_t          ssize = sizeof(cpu_new);
 
         if (sysctl(mib, 2, cpu_new, &ssize, NULL, 0) < 0)
             memset(cpu_new, 0, sizeof(cpu_new));
 #elif defined(KERN_CPTIME)
         int             mib[2] = { CTL_KERN, KERN_CPTIME };
         size_t          ssize = sizeof(cpu_new);
 
         if (sysctl(mib, 2, cpu_new, &ssize, NULL, 0) < 0)
             memset(cpu_new, 0, sizeof(cpu_new));
 #else
         /*
          * CPU usage 
          */
         auto_nlist(CPTIME_SYMBOL, (char *) cpu_new, sizeof(cpu_new));
 #endif
 
         time_diff = time_new - time_old;
         time_old = time_new;
 
         cpu_total = 0;
 
         for (loop = 0; loop < CPUSTATES; loop++) {
             cpu_diff[loop] = cpu_new[loop] - cpu_old[loop];
             cpu_old[loop] = cpu_new[loop];
             cpu_total += cpu_diff[loop];
         }
 
         if (cpu_total == 0)
             cpu_total = 1;
 
         /*
          * Memory info 
          */
         mem_old = mem_new;
         sysctl(mem_mib, 2, &mem_new, &mem_size, NULL, 0);
     }
 
     /*
      * Rate macro 
      */
 #define rate(x) (((x)+ time_diff/2) / time_diff)
 
     /*
      * Page-to-kb macro 
      */
 #define ptok(p) ((p) * (mem_new.pagesize >> 10))
 
     switch (vp->magic) {
     case MIBINDEX:
         long_ret = 1;
         return ((u_char *) (&long_ret));
     case ERRORNAME:            /* dummy name */
         sprintf(errmsg, "systemStats");
         *var_len = strlen(errmsg);
         return ((u_char *) (errmsg));
     case SWAPIN:
         long_ret = ptok(mem_new.swapins - mem_old.swapins);
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case SWAPOUT:
         long_ret = ptok(mem_new.swapouts - mem_old.swapouts);
         long_ret = rate(long_ret);
         return ((u_char *) (&long_ret));
     case IOSENT:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case IORECEIVE:
-#if NETSNMP_NO_DUMMY_VALUES
+#ifdef NETSNMP_NO_DUMMY_VALUES
         return NULL;
 #endif
         long_ret = -1;
         return ((u_char *) (&long_ret));
     case SYSINTERRUPTS:
         long_ret = rate(mem_new.intrs - mem_old.intrs);
         return ((u_char *) (&long_ret));
     case SYSCONTEXT:
         long_ret = rate(mem_new.swtch - mem_old.swtch);
         return ((u_char *) (&long_ret));
     case CPUUSER:
         cpu_sum = cpu_diff[CP_USER] + cpu_diff[CP_NICE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUSYSTEM:
         cpu_sum = cpu_diff[CP_SYS] + cpu_diff[CP_INTR];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPUIDLE:
         cpu_sum = cpu_diff[CP_IDLE];
         cpu_prc = (float) cpu_sum / (float) cpu_total;
         long_ret = cpu_prc * CPU_PRC;
         return ((u_char *) (&long_ret));
     case CPURAWUSER:
         long_ret = cpu_new[CP_USER];
         return ((u_char *) (&long_ret));
     case CPURAWNICE:
         long_ret = cpu_new[CP_NICE];
         return ((u_char *) (&long_ret));
     case CPURAWSYSTEM:
         long_ret = cpu_new[CP_SYS] + cpu_new[CP_INTR];
         return ((u_char *) (&long_ret));
     case CPURAWIDLE:
         long_ret = cpu_new[CP_IDLE];
         return ((u_char *) (&long_ret));
     case CPURAWKERNEL:
         long_ret = cpu_new[CP_SYS];
         return ((u_char *) (&long_ret));
     case CPURAWINTR:
         long_ret = cpu_new[CP_INTR];
         return ((u_char *) (&long_ret));
         /*
          * reserved for future use 
          */
         /*
          * case ERRORFLAG:
          * return((u_char *) (&long_ret));
          * case ERRORMSG:
          * return((u_char *) (&long_ret));
          */
     }
     return NULL;
 }
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c b/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
index 53e17a9f11..814df69c3d 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_freebsd4.c
@@ -1,22 +1,22 @@
 /*
  *  UDP MIB architecture support for FreeBSD/DragonFlyBsd
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include <net-snmp/data_access/udp_endpoint.h>
 
 #include "udp-mib/udpEndpointTable/udpEndpointTable_constants.h"
 #include "udp-mib/data_access/udp_endpoint_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_UDP_H
+#ifdef HAVE_NETINET_UDP_H
 #include <netinet/udp.h>
 #endif
-#if HAVE_NETINET_UDP_VAR_H
+#ifdef HAVE_NETINET_UDP_VAR_H
 #include <netinet/udp_var.h>
 #endif
 
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_netbsd.c b/agent/mibgroup/udp-mib/data_access/udp_endpoint_netbsd.c
index f68314b776..62891e8da6 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_netbsd.c
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_netbsd.c
@@ -1,24 +1,24 @@
 /*
  *  udp_endpointTable MIB architecture support for NetBSD
  *
  * $Id: udp_endpoint_linux.c 18994 2010-06-16 13:13:25Z dts12 $
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include <net-snmp/data_access/udp_endpoint.h>
 
 #include "udp-mib/udpEndpointTable/udpEndpointTable_constants.h"
 #include "udp-mib/data_access/udp_endpoint_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_UDP_H
+#ifdef HAVE_NETINET_UDP_H
 #include <netinet/udp.h>
 #endif
-#if HAVE_NETINET_UDP_VAR_H
+#ifdef HAVE_NETINET_UDP_VAR_H
 #include <netinet/udp_var.h>
 #endif
 
diff --git a/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c b/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
index 727087acd5..ae1da66c75 100644
--- a/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
+++ b/agent/mibgroup/udp-mib/data_access/udp_endpoint_openbsd.c
@@ -1,38 +1,38 @@
 /*
  *  udp_endpointTable MIB architecture support for OpenBSD
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/data_access/ipaddress.h>
 #include <net-snmp/data_access/udp_endpoint.h>
 #include <net-snmp/agent/auto_nlist.h>
 
 #include "udp-mib/udpEndpointTable/udpEndpointTable_constants.h"
 #include "udp-mib/data_access/udp_endpoint_private.h"
 
 #include "mibII/mibII_common.h"
 
-#if HAVE_NETINET_UDP_H
+#ifdef HAVE_NETINET_UDP_H
 #include <netinet/udp.h>
 #endif
-#if HAVE_NETINET_UDP_VAR_H
+#ifdef HAVE_NETINET_UDP_VAR_H
 #include <netinet/udp_var.h>
 #endif
 
-#if HAVE_KVM_GETFILES
+#ifdef HAVE_KVM_GETFILES
 #if defined(HAVE_KVM_GETFILE2) || !defined(openbsd5)
 #undef HAVE_KVM_GETFILES
 #endif
 #endif
 
-#if HAVE_KVM_GETFILES
+#ifdef HAVE_KVM_GETFILES
 #include <kvm.h>
 #include <sys/sysctl.h>
 #define _KERNEL /* for DTYPE_SOCKET */
 #include <sys/file.h>
 #undef _KERNEL
 #endif
 
 #ifdef HAVE_KVM_GETFILES
diff --git a/agent/mibgroup/util_funcs.c b/agent/mibgroup/util_funcs.c
index 90bc63e567..0a03d73d11 100644
--- a/agent/mibgroup/util_funcs.c
+++ b/agent/mibgroup/util_funcs.c
@@ -1,93 +1,93 @@
 /*
  * util_funcs.c
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #ifdef HAVE_SPAWN_H
 #include <spawn.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #ifdef __alpha
 #ifndef _BSD
 #define _BSD
 #define _myBSD
 #endif
 #endif
 #ifdef HAVE_SYS_WAIT_H
 # include <sys/wait.h>
 #endif
 #ifdef __alpha
 #ifdef _myBSD
 #undef _BSD
 #undef _myBSD
 #endif
 #endif
 #ifndef WEXITSTATUS
 # define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
 #endif
 #ifndef WIFEXITED
 # define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #include <errno.h>
 #include <signal.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_BASETSD_H
 #include <basetsd.h>
 #define ssize_t SSIZE_T
 #endif
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #ifdef HAVE_LINUX_ETHTOOL_H
 #include <sys/ioctl.h>
 #include <linux/if.h>
 #include <linux/sockios.h>
 #ifdef HAVE_LINUX_ETHTOOL_NEEDS_U64
 #include <linux/types.h>
@@ -97,21 +97,21 @@ typedef __u16 u16;         /* ditto */
 typedef __u8 u8;           /* ditto */
 #endif
 #include <linux/ethtool.h>
 #endif /* HAVE_LINUX_ETHTOOL_H */
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/snmp_logging.h>
 #include <net-snmp/agent/netsnmp_close_fds.h>
 
 #include "struct.h"
 #include "util_funcs.h"
 #include "utilities/execute.h"
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include "limits.h"
 #endif
 #ifdef USING_UCD_SNMP_ERRORMIB_MODULE
 #include "ucd-snmp/errormib.h"
 #else
 #define setPerrorstatus(x) snmp_log_perror(x)
 #endif
@@ -150,37 +150,37 @@ make_tempfile(void)
 int
 shell_command(struct extensible *ex)
 {
-#if HAVE_SYSTEM
+#ifdef HAVE_SYSTEM
     const char     *ofname;
     char           *shellline = NULL;
     FILE           *shellout;
 
     ofname = make_tempfile();
     if (ofname == NULL) {
         ex->output[0] = 0;
         ex->result = 127;
         return ex->result;
     }
 
     if (asprintf(&shellline, "%s > %s", ex->command, ofname) >= 0) {
         ex->result = system(shellline);
         ex->result = WEXITSTATUS(ex->result);
         free(shellline);
     }
     shellout = fopen(ofname, "r");
     if (shellout != NULL) {
         if (fgets(ex->output, sizeof(ex->output), shellout) == NULL) {
             ex->output[0] = 0;
         }
         fclose(shellout);
     }
     unlink(ofname);
 #else
     ex->output[0] = 0;
     ex->result = 0;
 #endif
     return (ex->result);
 }
 #endif /* NETSNMP_FEATURE_REMOVE_SHELL_COMMAND */
 
 #define MAXOUTPUT 300
diff --git a/agent/mibgroup/util_funcs/Exit.c b/agent/mibgroup/util_funcs/Exit.c
index c848fd8bf2..540453bcd9 100644
--- a/agent/mibgroup/util_funcs/Exit.c
+++ b/agent/mibgroup/util_funcs/Exit.c
@@ -1,16 +1,16 @@
 /*
  * Portions of this file are copyrighted by:
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <net-snmp/library/snmp_logging.h>
 
 #include "Exit.h"
diff --git a/agent/mibgroup/util_funcs/get_pid_from_inode.h b/agent/mibgroup/util_funcs/get_pid_from_inode.h
index 69e6b65a5c..19c880c946 100644
--- a/agent/mibgroup/util_funcs/get_pid_from_inode.h
+++ b/agent/mibgroup/util_funcs/get_pid_from_inode.h
@@ -8,11 +8,11 @@
 #ifndef linux
 config_error(get_pid_from_inode is only suppored on linux)
 #endif
 
 #define _LARGEFILE64_SOURCE 1
 
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 
 #include <sys/types.h>
diff --git a/agent/mibgroup/util_funcs/restart.c b/agent/mibgroup/util_funcs/restart.c
index 0e8fbacb74..a8f9d4d5b2 100644
--- a/agent/mibgroup/util_funcs/restart.c
+++ b/agent/mibgroup/util_funcs/restart.c
@@ -1,27 +1,27 @@
 /*
  * util_funcs.c
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <signal.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmp_logging.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "restart.h"
 
 #ifdef USING_UCD_SNMP_ERRORMIB_MODULE
 #include "ucd-snmp/errormib.h"
 #else
 #define setPerrorstatus(x) snmp_log_perror(x)
 #endif
@@ -33,37 +33,37 @@ static RETSIGTYPE
 restart_doit(int a)
 {
     char * name = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
                                         NETSNMP_DS_LIB_APPTYPE);
     snmp_shutdown(name);
 
     /*  This signal handler may run with SIGALARM blocked.
      *  Since the signal mask is preserved accross execv(), we must
      *  make sure that SIGALARM is unblocked prior of execv'ing.
      *  Otherwise SIGALARM will be ignored in the next incarnation
      *  of snmpd, because the signal is blocked. And thus, the
      *  restart doesn't work anymore.
      *
      *  A quote from the sigprocmask() man page:
      *  The use of sigprocmask() is unspecified in a multithreaded process; see
      *  pthread_sigmask(3).
      */
-#if HAVE_SIGPROCMASK
+#ifdef HAVE_SIGPROCMASK
     {
         sigset_t empty_set;
 
         sigemptyset(&empty_set);
         sigprocmask(SIG_SETMASK, &empty_set, NULL);
     }
-#elif HAVE_SIGBLOCK
+#elif defined(HAVE_SIGBLOCK)
     sigsetmask(0);
 #endif
 
     /*
      * do the exec
      */
-#if HAVE_EXECV
+#ifdef HAVE_EXECV
     execv(argvrestartname, argvrestartp);
     setPerrorstatus(argvrestartname);
 #endif
 }
 #endif
diff --git a/agent/mibgroup/utilities/execute.c b/agent/mibgroup/utilities/execute.c
index 6350c0d369..98c0484d17 100644
--- a/agent/mibgroup/utilities/execute.c
+++ b/agent/mibgroup/utilities/execute.c
@@ -1,60 +1,60 @@
 /*
  * Utility routines to assist with the running of sub-commands
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 
 #include <errno.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <ucd-snmp/errormib.h>
 
 #include <net-snmp/agent/netsnmp_close_fds.h>
 
 #include "execute.h"
 #include "struct.h"
 
 #ifdef _MSC_VER
 #define popen  _popen
 #define pclose _pclose
 #endif
 
 
 /**
  * Run a shell command by calling system() or popen().
  *
  * @command: Shell command to run.
  * @input:   Data to send to stdin. May be NULL.
  * @output:  Buffer in which to store the output written to stdout. May be NULL.
  * @out_len: Size of the output buffer. The actual number of bytes written is
  *           stored in *@out_len.
  *
  * @return >= 0 if the command has been executed; -1 if the command could not
  *           be executed.
  */
@@ -62,104 +62,104 @@ int
 run_shell_command(const char *command, const char *input,
                   char *output, int *out_len)
 {
-#if HAVE_SYSTEM
+#ifdef HAVE_SYSTEM
     int         result;    /* and the return value of the command */
 
     if (!command)
         return -1;
 
     DEBUGMSGTL(("run_shell_command", "running %s\n", command));
     DEBUGMSGTL(("run:shell", "running '%s'\n", command));
 
     result = -1;
 
     /*
      * Set up the command and run it.
      */
     if (input) {
         if (output) {
             const char *ifname;
             const char *ofname;    /* Filename for output redirection */
             char        shellline[STRMAX];   /* The full command to run */
             FILE       *file;
 
             ifname = netsnmp_mktemp();
             if(NULL == ifname)
                 return -1;
             file = fopen(ifname, "w");
             if(NULL == file) {
                 snmp_log(LOG_ERR,"couldn't open temporary file %s\n", ifname);
                 unlink(ifname);
                 return -1;
             }
             fprintf(file, "%s", input);
             fclose( file );
 
             ofname = netsnmp_mktemp();
             if(NULL == ofname) {
                 if(ifname)
                     unlink(ifname);
                 return -1;
             }
             snprintf( shellline, sizeof(shellline), "(%s) < \"%s\" > \"%s\"",
                       command, ifname, ofname );
             result = system(shellline);
             /*
              * If output was requested, then retrieve & return it.
              * Tidy up, and return the result of the command.
              */
             if (out_len && *out_len != 0) {
                 int         fd;        /* For processing any output */
                 int         len = 0;
 
                 fd = open(ofname, O_RDONLY);
                 if(fd >= 0)
                     len = read(fd, output, *out_len - 1);
                 *out_len = len;
                 if (len >= 0)
                     output[len] = 0;
                 else
                     output[0] = 0;
                 if (fd >= 0)
                     close(fd);
             }
             unlink(ofname);
             unlink(ifname);
         } else {
             FILE       *file;
 
             file = popen(command, "w");
             if (file) {
                 fwrite(input, 1, strlen(input), file);
                 result = pclose(file);
             }
         }
     } else {
         if (output) {
             FILE* file;
 
             file = popen(command, "r");
             if (file) {
                 *out_len = fread(output, 1, *out_len - 1, file);
                 if (*out_len >= 0)
                     output[*out_len] = 0;
                 else
                     output[0] = 0;
                 result = pclose(file);
             }
         } else {
             result = system(command);
         }
     }
 
     return result;
 #else
     return -1;
 #endif
 }
 
 #ifdef HAVE_EXECV
 /*
  * Split the given command up into separate tokens,
  * ready to be passed to 'execv'
  */
diff --git a/agent/netsnmp_close_fds.c b/agent/netsnmp_close_fds.c
index b742224a23..b6253fbd59 100644
--- a/agent/netsnmp_close_fds.c
+++ b/agent/netsnmp_close_fds.c
@@ -1,18 +1,18 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/agent/netsnmp_close_fds.h>
 
 /**
  * Close all file descriptors larger than @fd.
  */
diff --git a/agent/snmp_agent.c b/agent/snmp_agent.c
index 5e772e1eae..37e44d9587 100644
--- a/agent/snmp_agent.c
+++ b/agent/snmp_agent.c
@@ -29,66 +29,66 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights 
  * reserved.  Use is subject to license terms specified in the 
  * COPYING file distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup snmp_agent net-snmp agent related processing 
  *  @ingroup agent
  *
  * @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <errno.h>
 
 #define SNMP_NEED_REQUEST_LIST
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/agent_callbacks.h>
 #include <net-snmp/library/large_fd_set.h>
 #include <net-snmp/library/snmp_assert.h>
 #include "agent_global_vars.h"
 
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 
 #ifdef NETSNMP_USE_LIBWRAP
 #include <tcpd.h>
diff --git a/agent/snmp_vars.c b/agent/snmp_vars.c
index a46e299b8a..4721c3ec87 100644
--- a/agent/snmp_vars.c
+++ b/agent/snmp_vars.c
@@ -37,124 +37,124 @@ OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 PERFORMANCE OF THIS SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  * additions, fixes and enhancements for Linux by Erik Schoenfelder
  * (schoenfr@ibr.cs.tu-bs.de) 1994/1995.
  * Linux additions taken from CMU to UCD stack by Jennifer Bray of Origin
  * (jbray@origin-at.co.uk) 1997
  */
 
 /*
  * XXXWWW merge todo: incl/excl range changes in differences between
  * 1.194 and 1.199 
  */
 
 #include <net-snmp/net-snmp-config.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <sys/types.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include <errno.h>
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 # include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_STREAM_H
 #   ifdef sysv5UnixWare7
 #      define _KMEMUSER 1 /* <sys/stream.h> needs this for queue_t */
 #   endif
 #include <sys/stream.h>
 #endif
 #ifdef HAVE_SYS_SOCKETVAR_H
 # include <sys/socketvar.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 #ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
 #ifdef HAVE_NETINET_IP6_H
 #include <netinet/ip6.h>
 #endif
 #endif
 #ifdef HAVE_SYS_QUEUE_H
 #include <sys/queue.h>
 #endif
 #ifdef HAVE_NET_ROUTE_H
 #include <net/route.h>
 #endif
 #ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
 #ifdef NETSNMP_ENABLE_IPV6
 #ifdef HAVE_NETNETSNMP_ENABLE_IPV6_IP6_VAR_H
 #include <netinet6/ip6_var.h>
 #endif
 #endif
 #ifdef HAVE_NETINET_IN_PCB_H
 #include <netinet/in_pcb.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/agent/mib_modules.h>
 #include <net-snmp/agent/agent_sysORTable.h>
 #include "agent_global_vars.h"
 #include "kernel.h"
 
 #include "mibgroup/struct.h"
 #include "snmpd.h"
 #include "agentx/agentx_config.h"
 #include "agentx/subagent.h"
 #include "net-snmp/agent/all_helpers.h"
 #include "agent_module_includes.h"
 #include "net-snmp/library/container.h"
 
 #if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
 #include <openssl/ssl.h>
 #include <openssl/x509v3.h>
 #include <net-snmp/library/cert_util.h>
 #endif
 
 #include "snmp_perl.h"
 
 #ifndef  MIN
 #define  MIN(a,b)                     (((a) < (b)) ? (a) : (b))
 #endif
diff --git a/agent/snmpd.c b/agent/snmpd.c
index 4199eab57d..b32069753b 100644
--- a/agent/snmpd.c
+++ b/agent/snmpd.c
@@ -1,166 +1,166 @@
 /*
  * snmpd.c
  */
 /** @defgroup agent The Net-SNMP agent
  * The snmp agent responds to SNMP queries from management stations
  */
 /* Portions of this file are subject to the following copyrights.  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Copyright 1988, 1989 by Carnegie Mellon University
  * 
  * All Rights Reserved
  * 
  * Permission to use, copy, modify, and distribute this software and its 
  * documentation for any purpose and without fee is hereby granted, 
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in 
  * supporting documentation, and that the name of CMU not be
  * used in advertising or publicity pertaining to distribution of the
  * software without specific, written prior permission.  
  * 
  * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * *****************************************************************
  */
 /*
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/types.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
 #include <errno.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
-#if HAVE_SYS_FILE_H
+#ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>
 #endif
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 #include <signal.h>
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_PROCESS_H
 #include <process.h>
 #endif
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 #ifdef HAVE_GRP_H
 #include <grp.h>
 #endif
 #ifdef HAVE_CRTDBG_H
 #include <crtdbg.h>
 #endif
 
 #ifndef PATH_MAX
 # ifdef _POSIX_PATH_MAX
 #  define PATH_MAX _POSIX_PATH_MAX
 # else
 #  define PATH_MAX 255
 # endif
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "agent_global_vars.h"
 
 #include <net-snmp/library/fd_event_manager.h>
 #include <net-snmp/library/large_fd_set.h>
 
 #include "m2m.h"
 #include <net-snmp/agent/agent_module_config.h>
 #include <net-snmp/agent/mib_module_config.h>
 
 #include "snmpd.h"
 
 #include <net-snmp/agent/mib_modules.h>
 
 #include <net-snmp/agent/agent_trap.h>
 
 #include <net-snmp/agent/netsnmp_close_fds.h>
 #include <net-snmp/agent/table.h>
 #include <net-snmp/agent/table_iterator.h>
 
 #include "../snmplib/snmp_syslog.h"
 
 #include "mibgroup/util_funcs/restart.h"
 
 /*
  * Include winservice.h to support Windows Service
  */
 #ifdef WIN32
 #include <windows.h>
 #include <tchar.h>
 #include <net-snmp/library/winservice.h>
 
 #define WIN32SERVICE
 
 #endif
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
@@ -213,82 +213,82 @@ static void
 usage(char *prog)
 {
 #ifdef WIN32SERVICE
     printf("\nUsage:  %s [-register] [-quiet] [OPTIONS] [LISTENING ADDRESSES]"
            "\n        %s [-unregister] [-quiet]", prog, prog);
 #else
     printf("\nUsage:  %s [OPTIONS] [LISTENING ADDRESSES]", prog);
 #endif
     printf("\n"
            "\n\tVersion:  %s\n%s"
            "\t\t\t  (config search path: %s)\n%s%s",
            netsnmp_get_version(),
            "\tWeb:      http://www.net-snmp.org/\n"
            "\tEmail:    net-snmp-coders@lists.sourceforge.net\n"
            "\n  -a\t\t\tlog addresses\n"
            "  -A\t\t\tappend to the logfile rather than truncating it\n"
            "  -c FILE[,...]\t\tread FILE(s) as configuration file(s)\n"
            "  -C\t\t\tdo not read the default configuration files\n",
            get_configuration_directory(),
            "  -d\t\t\tdump sent and received SNMP packets\n"
 #ifndef NETSNMP_DISABLE_DEBUGGING
            "  -D[TOKEN[,...]]\tturn on debugging output for the given TOKEN(s)\n"
 	   "\t\t\t  (try ALL for extremely verbose output)\n"
 	   "\t\t\t  Don't put space(s) between -D and TOKEN(s).\n"
 #endif
            "  -f\t\t\tdo not fork from the shell\n",
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
            "  -g GID\t\tchange to this numeric gid after opening\n"
 	   "\t\t\t  transport endpoints\n"
 #endif
            "  -h, --help\t\tdisplay this usage message\n"
            "  -H\t\t\tdisplay configuration file directives understood\n"
            "  -I [-]INITLIST\tlist of mib modules to initialize (or not)\n"
            "\t\t\t  (run snmpd with -Dmib_init for a list)\n"
            "  -L <LOGOPTS>\t\ttoggle options controlling where to log to\n");
     snmp_log_options_usage("\t", stdout);
     printf("  -m MIBLIST\t\tuse MIBLIST instead of the default MIB list\n"
            "  -M DIRLIST\t\tuse DIRLIST as the list of locations to look for MIBs\n"
            "\t\t\t  (default %s)\n%s%s",
 #ifndef NETSNMP_DISABLE_MIB_LOADING
            netsnmp_get_mib_directory(),
 #else
            "MIBs not loaded",
 #endif
            "  -p FILE\t\tstore process id in FILE\n"
            "  -q\t\t\tprint information in a more parsable format\n"
            "  -r\t\t\tdo not exit if files only accessible to root\n"
 	   "\t\t\t  cannot be opened\n"
 #ifdef WIN32SERVICE
            "  -register\t\tregister as a Windows service\n"
            "  \t\t\t  (followed by -quiet to prevent message popups)\n"
            "  \t\t\t  (followed by the startup parameter list)\n"
            "  \t\t\t  Note that some parameters are not relevant when running as a service\n"
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
            "  -u UID\t\tchange to this uid (numeric or textual) after\n"
 	   "\t\t\t  opening transport endpoints\n"
 #endif
 #ifdef WIN32SERVICE
            "  -unregister\t\tunregister as a Windows service\n"
            "  \t\t\t  (followed -quiet to prevent message popups)\n"
 #endif
            "  -v, --version\t\tdisplay version information\n"
            "  -V\t\t\tverbose display\n"
 #if defined(USING_AGENTX_SUBAGENT_MODULE)|| defined(USING_AGENTX_MASTER_MODULE)
            "  -x ADDRESS\t\tuse ADDRESS as AgentX address\n"
 #endif
 #ifdef USING_AGENTX_SUBAGENT_MODULE
            "  -X\t\t\trun as an AgentX subagent rather than as an\n"
 	   "\t\t\t  SNMP master agent\n"
 #endif
            ,
            "\nDeprecated options:\n"
            "  -l FILE\t\tuse -Lf <FILE> instead\n"
            "  -P\t\t\tuse -p instead\n"
            "  -s\t\t\tuse -Lsd instead\n"
            "  -S d|i|0-7\t\tuse -Ls <facility> instead\n"
            "\n"
            );
     SOCK_CLEANUP;
     exit(1);
 }
@@ -382,725 +382,725 @@ int
 main(int argc, char *argv[])
 #endif
 {
     static const char options[] = "aAc:CdD::fhHI:l:L:m:M:n:p:P:qrsS:UvV-:Y:"
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
         "g:u:"
 #endif
 #if defined(USING_AGENTX_SUBAGENT_MODULE)|| defined(USING_AGENTX_MASTER_MODULE)
         "x:"
 #endif
 #ifdef USING_AGENTX_SUBAGENT_MODULE
         "X"
 #endif
         ;
     int             arg, i, ret, exit_code = 1;
     int             dont_fork = 0, do_help = 0;
     int             log_set = 0;
     int             agent_mode = -1;
     char           *pid_file = NULL;
     char            option_compatability[] = "-Le";
 #ifndef WIN32
     int             prepared_sockets = 0;
 #endif
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     int fd;
     FILE           *PID;
 #endif
 
     SOCK_STARTUP;
 
 #ifndef NETSNMP_NO_SYSTEMD
     /* check if systemd has sockets for us and don't close them */
     prepared_sockets = netsnmp_sd_listen_fds(0);
 #endif /* NETSNMP_NO_SYSTEMD */
 #ifndef WIN32
     /*
      * close all non-standard file descriptors we may have
      * inherited from the shell.
      */
     if (!prepared_sockets)
         netsnmp_close_fds(2);
 #endif
     
     /*
      * register signals ASAP to prevent default action (usually core)
      * for signals during startup...
      */
 #ifdef SIGTERM
     DEBUGMSGTL(("signal", "registering SIGTERM signal handler\n"));
     signal(SIGTERM, SnmpdShutDown);
 #endif
 #ifdef SIGINT
     DEBUGMSGTL(("signal", "registering SIGINT signal handler\n"));
     signal(SIGINT, SnmpdShutDown);
 #endif
 #ifdef SIGHUP
     signal(SIGHUP, SIG_IGN);   /* do not terminate on early SIGHUP */
 #endif
 #ifdef SIGUSR1
     DEBUGMSGTL(("signal", "registering SIGUSR1 signal handler\n"));
     signal(SIGUSR1, SnmpdDump);
 #endif
 #ifdef SIGPIPE
     DEBUGMSGTL(("signal", "registering SIGPIPE signal handler\n"));
     signal(SIGPIPE, SIG_IGN);   /* 'Inline' failure of wayward readers */
 #endif
 #ifdef SIGXFSZ
     signal(SIGXFSZ, SnmpdCatchRandomSignal);
 #endif
 
 #ifdef NETSNMP_NO_ROOT_ACCESS
     /*
      * Default to no.  
      */
     netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 			   NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
 #endif
     /*
      * Default to NOT running an AgentX master.  
      */
     netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 			   NETSNMP_DS_AGENT_AGENTX_MASTER, 0);
     netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
                        NETSNMP_DS_AGENT_AGENTX_TIMEOUT, -1);
     netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
                        NETSNMP_DS_AGENT_AGENTX_RETRIES, -1);
 
     netsnmp_ds_set_int(NETSNMP_DS_APPLICATION_ID,
                        NETSNMP_DS_AGENT_CACHE_TIMEOUT, 5);
 
     /*
      * This is incredibly ugly, but it's probably the simplest way
      *  to handle the old '-L' option as well as the new '-Lx' style
      */
     for (i=0; i<argc; i++) {
         if (!strcmp(argv[i], "-L"))
             argv[i] = option_compatability;            
     }
 
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
 #ifdef WIN32
     snmp_log_syslogname(app_name_long);
 #else
     snmp_log_syslogname(app_name);
 #endif
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
                           NETSNMP_DS_LIB_APPTYPE, app_name);
 
     /*
      * Now process options normally.  
      */
     while ((arg = getopt(argc, argv, options)) != EOF) {
         switch (arg) {
         case '-':
             if (strcasecmp(optarg, "help") == 0) {
                 usage(argv[0]);
             }
             if (strcasecmp(optarg, "version") == 0) {
                 version();
                 exit_code = 0;
                 goto out;
             }
 
             handle_long_opt(optarg);
             break;
 
         case 'a':
             log_addresses++;
             break;
 
         case 'A':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
                                    NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
             break;
 
         case 'c':
             if (optarg != NULL) {
                 netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
 				      NETSNMP_DS_LIB_OPTIONALCONFIG, optarg);
             } else {
                 usage(argv[0]);
             }
             break;
 
         case 'C':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
 				   NETSNMP_DS_LIB_DONT_READ_CONFIGS, 1);
             break;
 
         case 'd':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
                                    NETSNMP_DS_LIB_DUMP_PACKET,
                                    ++snmp_dump_packet);
             break;
 
         case 'D':
 #ifdef NETSNMP_DISABLE_DEBUGGING
             fprintf(stderr, "Debugging not configured\n");
             goto out;
 #else
             debug_register_tokens(optarg);
             snmp_set_do_debugging(1);
 #endif
             break;
 
         case 'f':
             dont_fork = 1;
             break;
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
         case 'g':
             if (optarg != NULL) {
                 char           *ecp;
                 int             gid;
 
                 gid = strtoul(optarg, &ecp, 10);
 #if defined(HAVE_GETGRNAM) && defined(HAVE_PWD_H)
                 if (*ecp) {
                     struct group  *info;
 
                     info = getgrnam(optarg);
                     gid = info ? info->gr_gid : -1;
                     endgrent();
                 }
 #endif
                 if (gid < 0) {
                     fprintf(stderr, "Bad group id: %s\n", optarg);
                     goto out;
                 }
                 netsnmp_set_agent_group_id(gid);
             } else {
                 usage(argv[0]);
             }
             break;
 #endif
 
         case 'h':
             usage(argv[0]);
             break;
 
         case 'H':
             do_help = 1;
             break;
 
         case 'I':
             if (optarg != NULL) {
                 add_to_init_list(optarg);
             } else {
                 usage(argv[0]);
             }
             break;
 
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_FILE
         case 'l':
             printf("Warning: -l option is deprecated, use -Lf <file> instead\n");
             if (optarg != NULL) {
                 if (strlen(optarg) > PATH_MAX) {
                     fprintf(stderr,
                             "%s: logfile path too long (limit %d chars)\n",
                             argv[0], PATH_MAX);
                     goto out;
                 }
                 snmp_enable_filelog(optarg,
                                     netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
                                                            NETSNMP_DS_LIB_APPEND_LOGFILES));
                 log_set = 1;
             } else {
                 usage(argv[0]);
             }
             break;
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_FILE */
 
         case 'L':
 	    if  (snmp_log_options( optarg, argc, argv ) < 0 ) {
                 usage(argv[0]);
             }
             log_set = 1;
             break;
 
         case 'm':
             if (optarg != NULL) {
                 setenv("MIBS", optarg, 1);
             } else {
                 usage(argv[0]);
             }
             break;
 
         case 'M':
             if (optarg != NULL) {
                 setenv("MIBDIRS", optarg, 1);
             } else {
                 usage(argv[0]);
             }
             break;
 
         case 'n':
             if (optarg != NULL) {
                 app_name = optarg;
                 netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
                                       NETSNMP_DS_LIB_APPTYPE, app_name);
             } else {
                 usage(argv[0]);
             }
             break;
 
         case 'P':
             printf("Warning: -P option is deprecated, use -p instead\n");
 	    NETSNMP_FALLTHROUGH;
         case 'p':
             if (optarg != NULL) {
                 pid_file = optarg;
             } else {
                 usage(argv[0]);
             }
             break;
 
         case 'q':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
                                    NETSNMP_DS_LIB_QUICK_PRINT, 1);
             break;
 
         case 'r':
             netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_NO_ROOT_ACCESS);
             break;
 
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
         case 's':
             printf("Warning: -s option is deprecated, use -Lsd instead\n");
             snmp_enable_syslog();
             log_set = 1;
             break;
 
         case 'S':
             printf("Warning: -S option is deprecated, use -Ls <facility> instead\n");
             if (optarg != NULL) {
                 switch (*optarg) {
                 case 'd':
                 case 'D':
                     Facility = LOG_DAEMON;
                     break;
                 case 'i':
                 case 'I':
                     Facility = LOG_INFO;
                     break;
                 case '0':
                     Facility = LOG_LOCAL0;
                     break;
                 case '1':
                     Facility = LOG_LOCAL1;
                     break;
                 case '2':
                     Facility = LOG_LOCAL2;
                     break;
                 case '3':
                     Facility = LOG_LOCAL3;
                     break;
                 case '4':
                     Facility = LOG_LOCAL4;
                     break;
                 case '5':
                     Facility = LOG_LOCAL5;
                     break;
                 case '6':
                     Facility = LOG_LOCAL6;
                     break;
                 case '7':
                     Facility = LOG_LOCAL7;
                     break;
                 default:
                     fprintf(stderr, "invalid syslog facility: -S%c\n",*optarg);
                     usage(argv[0]);
                 }
                 snmp_enable_syslog_ident(snmp_log_syslogname(NULL), Facility);
                 log_set = 1;
             } else {
                 fprintf(stderr, "no syslog facility specified\n");
                 usage(argv[0]);
             }
             break;
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
 
         case 'U':
             netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_LEAVE_PIDFILE);
             break;
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
         case 'u':
             if (optarg != NULL) {
                 char           *ecp;
                 int             uid;
 
                 uid = strtoul(optarg, &ecp, 10);
 #if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
                 if (*ecp) {
                     struct passwd  *info;
 
                     info = getpwnam(optarg);
                     uid = info ? info->pw_uid : -1;
                     endpwent();
                 }
 #endif
                 if (uid < 0) {
                     fprintf(stderr, "Bad user id: %s\n", optarg);
                     goto out;
                 }
                 netsnmp_set_agent_user_id(uid);
             } else {
                 usage(argv[0]);
             }
             break;
 #endif
 
         case 'v':
             version();
             exit_code = 0;
             goto out;
 
         case 'V':
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_VERBOSE, 1);
             break;
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE)|| defined(USING_AGENTX_MASTER_MODULE)
         case 'x':
             if (optarg != NULL) {
                 netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_X_SOCKET, optarg);
             } else {
                 usage(argv[0]);
             }
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_AGENT_AGENTX_MASTER, 1);
             break;
 #endif
 
         case 'X':
 #if defined(USING_AGENTX_SUBAGENT_MODULE)
             agent_mode = SUB_AGENT;
 #else
             fprintf(stderr, "%s: Illegal argument -X:"
 		            "AgentX support not compiled in.\n", argv[0]);
             usage(argv[0]);
 #endif
             break;
 
         case 'Y':
             netsnmp_config_remember(optarg);
             break;
 
         default:
             usage(argv[0]);
             break;
         }
     }
 
     if (do_help) {
         netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
                                NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
         init_agent(app_name);        /* register our .conf handlers */
         init_mib_modules();
         init_snmp(app_name);
         fprintf(stderr, "Configuration directives understood:\n");
         read_config_print_usage("  ");
         exit_code = 0;
         goto out;
     }
 
     if (optind < argc) {
 #ifndef NETSNMP_NO_LISTEN_SUPPORT
         /*
          * There are optional transport addresses on the command line.  
          */
         DEBUGMSGTL(("snmpd/main", "optind %d, argc %d\n", optind, argc));
         for (i = optind; i < argc; i++) {
             char *c, *astring;
             if ((c = netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
 					   NETSNMP_DS_AGENT_PORTS))) {
                 astring = (char*)malloc(strlen(c) + 2 + strlen(argv[i]));
                 if (astring == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
                     goto out;
                 }
                 sprintf(astring, "%s,%s", c, argv[i]);
                 netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_PORTS, astring);
                 SNMP_FREE(astring);
             } else {
                 netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
 				      NETSNMP_DS_AGENT_PORTS, argv[i]);
             }
         }
         DEBUGMSGTL(("snmpd/main", "port spec: %s\n",
                     netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
 					  NETSNMP_DS_AGENT_PORTS)));
 #else /* NETSNMP_NO_LISTEN_SUPPORT */
         fprintf(stderr, "You specified ports to open; this agent was built to only send notifications\n");
         goto out;
 #endif /* NETSNMP_NO_LISTEN_SUPPORT */
     }
 
 #if defined(NETSNMP_DAEMONS_DEFAULT_LOG_SYSLOG)
     if (0 == log_set)
         snmp_enable_syslog();
 #else
 #ifdef NETSNMP_LOGFILE
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_FILE
     if (0 == log_set)
         snmp_enable_filelog(NETSNMP_LOGFILE,
                             netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
                                                    NETSNMP_DS_LIB_APPEND_LOGFILES));
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_FILE */
 #endif /* NETSNMP_LOGFILE */
 #endif /* ! NETSNMP_DEFAULT_LOG_SYSLOG */
 
 #ifdef USING_UTIL_FUNCS_RESTART_MODULE
     {
         /*
          * Initialize a argv set to the current for restarting the agent.
          */
         char *cptr, **argvptr;
 
         argvrestartp = (char **)malloc((argc + 2) * sizeof(char *));
         argvptr = argvrestartp;
         for (i = 0, ret = 1; i < argc; i++) {
             ret += strlen(argv[i]) + 1;
         }
         argvrestart = (char *) malloc(ret);
         argvrestartname = (char *) malloc(strlen(argv[0]) + 1);
         if (!argvrestartp || !argvrestart || !argvrestartname) {
             fprintf(stderr, "malloc failure processing argvrestart\n");
             goto out;
         }
         strcpy(argvrestartname, argv[0]);
 
         for (cptr = argvrestart, i = 0; i < argc; i++) {
             strcpy(cptr, argv[i]);
             *(argvptr++) = cptr;
             cptr += strlen(argv[i]) + 1;
         }
     }
 #endif /* USING_UTIL_FUNCS_RESTART_MODULE */
 
     if (agent_mode == -1) {
         if (strstr(argv[0], "agentxd") != NULL) {
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_ROLE, SUB_AGENT);
         } else {
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 				   NETSNMP_DS_AGENT_ROLE, MASTER_AGENT);
         }
     } else {
         netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 			       NETSNMP_DS_AGENT_ROLE, agent_mode);
     }
 
     if (init_agent(app_name) != 0) {
         snmp_log(LOG_ERR, "Agent initialization failed\n");
         goto out;
     }
     init_mib_modules();
 
     /*
      * start library 
      */
     init_snmp(app_name);
 
     if ((ret = init_master_agent()) != 0) {
         /*
          * Some error opening one of the specified agent transports.  
          */
         snmp_log(LOG_ERR, "Server Exiting with code 1\n");
         goto out;
     }
 
     /*
      * Initialize the world.  Detach from the shell.  Create initial user.  
      */
     if(!dont_fork) {
         int quit = ! netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                             NETSNMP_DS_AGENT_QUIT_IMMEDIATELY);
         ret = netsnmp_daemonize(quit,
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_STDIO
                                 snmp_stderrlog_status()
 #else /* NETSNMP_FEATURE_REMOVE_LOGGING_STDIO */
                                 0
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_STDIO */
             );
         /*
          * xxx-rks: do we care if fork fails? I think we should...
          */
         if(ret != 0) {
             snmp_log(LOG_ERR, "Server Exiting with code 1\n");
             goto out;
         }
     }
 
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     if (pid_file != NULL) {
         /*
          * unlink the pid_file, if it exists, prior to open.  Without
          * doing this the open will fail if the user specified pid_file
          * already exists.
          */
         unlink(pid_file);
         fd = open(pid_file, O_CREAT | O_EXCL | O_WRONLY, 0600);
         if (fd == -1) {
             snmp_log_perror(pid_file);
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                         NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 goto out;
             }
         } else {
             if ((PID = fdopen(fd, "w")) == NULL) {
                 close(fd);
                 snmp_log_perror(pid_file);
                 goto out;
             } else {
                 fprintf(PID, "%d\n", (int) getpid());
                 fclose(PID);
             }
         }
     }
 #endif
 
 #if defined(HAVE_UNISTD_H) && (defined(HAVE_CHOWN) || defined(HAVE_SETGID) || defined(HAVE_SETUID))
     {
     const char     *persistent_dir;
     int             uid, gid;
 
     persistent_dir = get_persistent_directory();
     mkdirhier( persistent_dir, NETSNMP_AGENT_DIRECTORY_MODE, 0 );
    
     uid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 			     NETSNMP_DS_AGENT_USERID);
     gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 			     NETSNMP_DS_AGENT_GROUPID);
     
 #ifdef HAVE_CHOWN
     if ( uid != 0 || gid != 0 )
         NETSNMP_IGNORE_RESULT(chown(persistent_dir, uid, gid));
 #endif
 
 #ifdef HAVE_SETGID
     if ((gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 				  NETSNMP_DS_AGENT_GROUPID)) > 0) {
         DEBUGMSGTL(("snmpd/main", "Changing gid to %d.\n", gid));
         if (setgid(gid) == -1
 #ifdef HAVE_SETGROUPS
             || setgroups(1, (gid_t *)&gid) == -1
 #endif
             ) {
             snmp_log_perror("setgid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 goto out;
             }
         }
     }
 #endif
 #ifdef HAVE_SETUID
     if ((uid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 				  NETSNMP_DS_AGENT_USERID)) > 0) {
-#if HAVE_GETPWNAM && HAVE_PWD_H && HAVE_INITGROUPS
+#ifdef HAVE_GETPWNAM && HAVE_PWD_H && HAVE_INITGROUPS
         struct passwd *info;
 
         /*
          * Set supplementary groups before changing UID
          *   (which probably involves giving up privileges)
          */
         info = getpwuid(uid);
         if (info) {
             DEBUGMSGTL(("snmpd/main", "Supplementary groups for %s.\n", info->pw_name));
             if (initgroups(info->pw_name, (gid != 0 ? (gid_t)gid : info->pw_gid)) == -1) {
                 snmp_log_perror("initgroups failed");
                 if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
                                             NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                     goto out;
                 }
             }
         }
         endpwent();
 #endif
         DEBUGMSGTL(("snmpd/main", "Changing uid to %d.\n", uid));
         if (setuid(uid) == -1) {
             snmp_log_perror("setuid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 goto out;
             }
         }
     }
 #endif
     }
 #endif
 
     /*
      * Store persistent data immediately in case we crash later.  
      */
     snmp_store(app_name);
 
 #ifdef SIGHUP
     DEBUGMSGTL(("signal", "registering SIGHUP signal handler\n"));
     signal(SIGHUP, SnmpdReconfig);
 #endif
 
     /*
      * Send coldstart trap if possible.  
      */
     send_easy_trap(0, 0);
 
     /*
      * We're up, log our version number.  
      */
     snmp_log(LOG_INFO, "NET-SNMP version %s\n", netsnmp_get_version());
 #ifdef WIN32SERVICE
     agent_status = AGENT_RUNNING;
 #endif
     netsnmp_addrcache_initialise();
 
     /*
      * Let systemd know we're up.
      */
 #ifndef NETSNMP_NO_SYSTEMD
     netsnmp_sd_notify(1, "READY=1\n");
     if (prepared_sockets)
         /*
          * Clear the environment variable, we already processed all the sockets
          * by now.
          */
         netsnmp_sd_listen_fds(1);
 #endif
 
     /*
      * Forever monitor the dest_port for incoming PDUs.  
      */
     DEBUGMSGTL(("snmpd/main", "We're up.  Starting to process data.\n"));
     if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				NETSNMP_DS_AGENT_QUIT_IMMEDIATELY))
         receive();
     DEBUGMSGTL(("snmpd/main", "sending shutdown trap\n"));
     SnmpTrapNodeDown();
     DEBUGMSGTL(("snmpd/main", "Bye...\n"));
     snmp_shutdown(app_name);
     shutdown_master_agent();
     shutdown_agent();
 
     if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 				NETSNMP_DS_AGENT_LEAVE_PIDFILE) &&
 	(pid_file != NULL)) {
         unlink(pid_file);
     }
 #ifdef WIN32SERVICE
     agent_status = AGENT_STOPPED;
 #endif
 
 #ifdef USING_UTIL_FUNCS_RESTART_MODULE
     SNMP_FREE(argvrestartname);
     SNMP_FREE(argvrestart);
     SNMP_FREE(argvrestartp);
 #endif /* USING_UTIL_FUNCS_RESTART_MODULE */
 
     exit_code = 0;
diff --git a/apps/encode_keychange.c b/apps/encode_keychange.c
index 8fde7091b0..59fd5468f2 100644
--- a/apps/encode_keychange.c
+++ b/apps/encode_keychange.c
@@ -1,47 +1,47 @@
 /*
  * encode_keychange.c
  *
  * Collect information to build a KeyChange encoding, per the textual
  * convention given in RFC 2274, Section 5.  Compute the value and
  * dump to stdout as a string of hex nibbles.
  *
  *
  * Passphrase material may come from many sources.  The following are
  * checked in order (see get_user_passphrases()):
  *      - Prompt always if -f is given.
  *      - Commandline arguments.
  *      - PASSPHRASE_FILE.
  *      - Prompts on stdout.   Use -P to turn off prompt tags.
  *
  *
  * FIX  Better name?
  * FIX  Change encode_keychange() to take random bits?
  * FIX  QUITFUN not quite appropriate here...
  * FIX  This is slow...
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
 #include <ctype.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include <stdlib.h>
 
 /*
  * Globals, &c...
  */
diff --git a/apps/snmpbulkget.c b/apps/snmpbulkget.c
index b42019c6e0..6e798871e0 100644
--- a/apps/snmpbulkget.c
+++ b/apps/snmpbulkget.c
@@ -24,43 +24,43 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 **********************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <net-snmp/utilities.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmpbulkwalk.c b/apps/snmpbulkwalk.c
index 5146986abd..0baa732b51 100644
--- a/apps/snmpbulkwalk.c
+++ b/apps/snmpbulkwalk.c
@@ -25,46 +25,46 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 **********************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define NETSNMP_DS_WALK_INCLUDE_REQUESTED		1
 #define NETSNMP_DS_WALK_PRINT_STATISTICS		2
 #define NETSNMP_DS_WALK_DONT_CHECK_LEXICOGRAPHIC	3
diff --git a/apps/snmpdelta.c b/apps/snmpdelta.c
index 9c9e20f4a9..0a5e0afd5a 100644
--- a/apps/snmpdelta.c
+++ b/apps/snmpdelta.c
@@ -1,71 +1,71 @@
 /*
  * snmpdelta.c - Monitor deltas of integer valued SNMP variables
  *
  */
 /**********************************************************************
  *
  *           Copyright 1996 by Carnegie Mellon University
  * 
  *                       All Rights Reserved
  * 
  * Permission to use, copy, modify, and distribute this software and its
  * documentation for any purpose and without fee is hereby granted,
  * provided that the above copyright notice appear in all copies and that
  * both that copyright notice and this permission notice appear in
  * supporting documentation, and that the name of CMU not be
  * used in advertising or publicity pertaining to distribution of the
  * software without specific, written prior permission.
  * 
  * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
  * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
  * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  * 
  **********************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define MAX_ARGS 256
 #define NETSNMP_DS_APP_DONT_FIX_PDUS 0
diff --git a/apps/snmpdf.c b/apps/snmpdf.c
index c2329067c0..8fb54c9fb0 100644
--- a/apps/snmpdf.c
+++ b/apps/snmpdf.c
@@ -29,48 +29,48 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmpget.c b/apps/snmpget.c
index e2a71f20a6..f370117b25 100644
--- a/apps/snmpget.c
+++ b/apps/snmpget.c
@@ -24,46 +24,46 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define NETSNMP_DS_APP_DONT_FIX_PDUS 0
diff --git a/apps/snmpgetnext.c b/apps/snmpgetnext.c
index d96d38d6a8..2b87beae87 100644
--- a/apps/snmpgetnext.c
+++ b/apps/snmpgetnext.c
@@ -24,44 +24,44 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define NETSNMP_DS_APP_DONT_FIX_PDUS 0
diff --git a/apps/snmpnetstat/if.c b/apps/snmpnetstat/if.c
index b53439bacf..b4d7f8f39e 100755
--- a/apps/snmpnetstat/if.c
+++ b/apps/snmpnetstat/if.c
@@ -1,59 +1,59 @@
 /*
  * $OpenBSD: if.c,v 1.42 2005/03/13 16:05:50 mpf Exp $
  */
 /*
  * $NetBSD: if.c,v 1.16.4.2 1996/06/07 21:46:46 thorpej Exp $
  */
 
 /*
  * Copyright (c) 1983, 1988, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <stdint.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifndef _XOPEN_SOURCE
 #define _XOPEN_SOURCE 1
 #endif
 #ifndef _XOPEN_SOURCE_EXTENDED
 #define _XOPEN_SOURCE_EXTENDED 1
 #endif
 #include <signal.h>
 
 #include "main.h"
 #include "netstat.h"
 
 #define	YES	1
 #define	NO	0
diff --git a/apps/snmpnetstat/inet.c b/apps/snmpnetstat/inet.c
index bcb727f727..7c1274a324 100644
--- a/apps/snmpnetstat/inet.c
+++ b/apps/snmpnetstat/inet.c
@@ -1,62 +1,62 @@
 /*
  * $OpenBSD: inet.c,v 1.92 2005/02/10 14:25:08 itojun Exp $
  */
 /*
  * $NetBSD: inet.c,v 1.14 1995/10/03 21:42:37 thorpej Exp $
  */
 
 /*
  * Copyright (c) 1983, 1988, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdint.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "main.h"
 #include "netstat.h"
diff --git a/apps/snmpnetstat/inet6.c b/apps/snmpnetstat/inet6.c
index 630e40c2b3..00767f9077 100644
--- a/apps/snmpnetstat/inet6.c
+++ b/apps/snmpnetstat/inet6.c
@@ -1,64 +1,64 @@
 /*
  * $OpenBSD: inet6.c,v 1.31 2004/11/17 01:47:20 itojun Exp $
  */
 /*
  * BSDI inet.c,v 2.3 1995/10/24 02:19:29 prb Exp
  */
 /*
  * Copyright (c) 1983, 1988, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "main.h"
 #include "netstat.h"
diff --git a/apps/snmpnetstat/inetx.c b/apps/snmpnetstat/inetx.c
index 8f78f4bd92..153b39c389 100644
--- a/apps/snmpnetstat/inetx.c
+++ b/apps/snmpnetstat/inetx.c
@@ -1,64 +1,64 @@
 /*
  * $OpenBSD: inet6.c,v 1.31 2004/11/17 01:47:20 itojun Exp $
  */
 /*
  * BSDI inet.c,v 2.3 1995/10/24 02:19:29 prb Exp
  */
 /*
  * Copyright (c) 1983, 1988, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "main.h"
 #include "netstat.h"
diff --git a/apps/snmpnetstat/main.c b/apps/snmpnetstat/main.c
index 6c02c36db6..594581f1f3 100644
--- a/apps/snmpnetstat/main.c
+++ b/apps/snmpnetstat/main.c
@@ -37,22 +37,22 @@
 #ifndef lint
 char            copyright[] = "@(#) Copyright (c) 1983, 1988, 1993\n\
 	Regents of the University of California.  All rights reserved.\n";
 #endif                          /* not lint */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/utilities.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include "main.h"
 #include "netstat.h"
 
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
diff --git a/apps/snmpnetstat/route.c b/apps/snmpnetstat/route.c
index 75226c0d7b..02cb15a11a 100644
--- a/apps/snmpnetstat/route.c
+++ b/apps/snmpnetstat/route.c
@@ -1,75 +1,75 @@
 /*
  * $OpenBSD: route.c,v 1.66 2004/11/17 01:47:20 itojun Exp $
  */
 /*
  * $NetBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $
  */
 
 /*
  * Copyright (c) 1983, 1988, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #ifndef INET
 #define INET
 #endif
 
 #include "main.h"
 #include "netstat.h"
 #include "ffs.h"
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
 
 #define SET_MASK 0x01
 #define SET_GWAY 0x02
 #define SET_IFNO 0x04
 #define SET_TYPE 0x08
 #define SET_PRTO 0x10
 #define SET_ALL  0x1f
diff --git a/apps/snmpnetstat/routex.c b/apps/snmpnetstat/routex.c
index 70fb0a69f6..0cce8757a2 100644
--- a/apps/snmpnetstat/routex.c
+++ b/apps/snmpnetstat/routex.c
@@ -1,90 +1,90 @@
 /*
  * $OpenBSD: route.c,v 1.66 2004/11/17 01:47:20 itojun Exp $
  */
 /*
  * $NetBSD: route.c,v 1.15 1996/05/07 02:55:06 thorpej Exp $
  */
 
 /*
  * Copyright (c) 1983, 1988, 1993
  *        The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 netsnmp_feature_require(sockaddr_size);
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #ifndef INET
 #define INET
 #endif
 
 #include "main.h"
 #include "netstat.h"
 #ifdef HAVE_WINSOCK_H
 #include "winstub.h"
 #endif
 
 /*
  * inetCidrRouteTable
  */
 #define SET_IFNO 0x01
 #define SET_TYPE 0x02
 #define SET_PRTO 0x04
 #define SET_AGE  0x08
 #define SET_AS   0x10
 #define SET_MET1 0x20
 #define SET_ALL  0x3f
 
 /*
  * ip6RouteTable
  */
 #define SET_HOP     0x40
 #define SET_INVALID 0x80
 #define SET_ALL6    0x67
 /*
  * not invalid, and only the columns that we fetch
  */
diff --git a/apps/snmpnetstat/winstub.c b/apps/snmpnetstat/winstub.c
index e88c5d612f..d0823b3667 100644
--- a/apps/snmpnetstat/winstub.c
+++ b/apps/snmpnetstat/winstub.c
@@ -1,41 +1,41 @@
 /*
  * cheap and dirty network database lookup functions
  */
 /*
  * uses local files only
  */
 /*
  * currently searches the protocols only
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #if (defined(WIN32) || defined(cygwin) || defined(aix4))
 
 #ifdef aix4
 #define _NO_PROTO               /* Hack, you say ? */
 #endif
 
 #include <stdio.h>
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NETDB_H
 #ifdef cygwin
 #define getnetent cygwin_getnetent
 #define getnetbyaddr cygwin_getnetbyaddr
 #endif
 #include <netdb.h>
 #ifdef cygwin
 #undef getnetent
 #undef getnetbyaddr
 #endif
 #endif
diff --git a/apps/snmpping.c b/apps/snmpping.c
index f7c922663d..64a0b795c1 100644
--- a/apps/snmpping.c
+++ b/apps/snmpping.c
@@ -1,78 +1,78 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply.
  */
 /*
  * Copyright (c) 2013, Arista Networks, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
  *
  * *  Redistributions of source code must retain the above copyright notice,
  *    this list of conditions and the following disclaimer.
  *
  * *  Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * *  Neither the name of Arista Networks, Inc. nor the names of its
  *    contributors may be used to endorse or promote products derived
  *    from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  * DAMAGE.
  */
 
 /* For getlogin() on MinGW */
 #define _POSIX
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <signal.h>
 
 #include <ctype.h>
 
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 
 #include <math.h>
 
 #include <net-snmp/net-snmp-includes.h>
 
 #include "inet_ntop.h"
 
 /* XXX */
 #define INETADDRESSTYPE_IPV4    1
 #define INETADDRESSTYPE_IPV6    2
 
 #define PINGCTLADMINSTATUS_ENABLED 1
 
 /* Target info */
diff --git a/apps/snmpps.c b/apps/snmpps.c
index ea9d4e801d..aafbb62c65 100644
--- a/apps/snmpps.c
+++ b/apps/snmpps.c
@@ -29,49 +29,49 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NCURSES_CURSES_H
 #include <ncurses/curses.h>
-#elif HAVE_CURSES_H
+#elif defined(HAVE_CURSES_H)
 #include <curses.h>
 #endif
 #include <signal.h>
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmpset.c b/apps/snmpset.c
index bcd70b483e..064b94b515 100644
--- a/apps/snmpset.c
+++ b/apps/snmpset.c
@@ -24,42 +24,42 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmpstatus.c b/apps/snmpstatus.c
index 24b295ff46..c13939bcc5 100644
--- a/apps/snmpstatus.c
+++ b/apps/snmpstatus.c
@@ -25,44 +25,44 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmptable.c b/apps/snmptable.c
index 896def18b1..6bf9c409d6 100644
--- a/apps/snmptable.c
+++ b/apps/snmptable.c
@@ -26,41 +26,41 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #include <stdio.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmptest.c b/apps/snmptest.c
index 308bbd8313..2b07de9ee0 100644
--- a/apps/snmptest.c
+++ b/apps/snmptest.c
@@ -26,42 +26,42 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmptls.c b/apps/snmptls.c
index 335638928c..bd53efe333 100644
--- a/apps/snmptls.c
+++ b/apps/snmptls.c
@@ -12,26 +12,26 @@ netsnmp_feature_require(tls_fingerprint_build);
 netsnmp_feature_require(row_create);
 
 #include <ctype.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <openssl/ssl.h>
 #include <openssl/x509.h>
 #include <net-snmp/library/cert_util.h>
 
 #include "tlstm-mib.h"
 #include "tlstm-mib/snmpTlstmAddrTable/snmpTlstmAddrTable.h"
 #include "tlstm-mib/snmpTlstmParamsTable/snmpTlstmParamsTable.h"
 #include "tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.h"
 
 
 
 /*
 #define COL_SNMPTLSTMCERTTOTSN_ID                       1
 #define COL_SNMPTLSTMCERTTOTSN_FINGERPRINT              2
 #define COL_SNMPTLSTMCERTTOTSN_MAPTYPE                  3
 #define COL_SNMPTLSTMCERTTOTSN_DATA                     4
 #define COL_SNMPTLSTMCERTTOTSN_STORAGETYPE              5
 #define COL_SNMPTLSTMCERTTOTSN_ROWSTATUS                6
 */
diff --git a/apps/snmptranslate.c b/apps/snmptranslate.c
index d7cbcaab86..d7773e779e 100644
--- a/apps/snmptranslate.c
+++ b/apps/snmptranslate.c
@@ -27,30 +27,30 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/mib_api.h>
diff --git a/apps/snmptrap.c b/apps/snmptrap.c
index 7c055e1398..d45fa0d3cf 100644
--- a/apps/snmptrap.c
+++ b/apps/snmptrap.c
@@ -24,44 +24,44 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #include <stdio.h>
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
diff --git a/apps/snmptrapd.c b/apps/snmptrapd.c
index 8792d035a5..da82cd5eed 100644
--- a/apps/snmptrapd.c
+++ b/apps/snmptrapd.c
@@ -24,119 +24,119 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #if !defined(mingw32) && defined(HAVE_SYS_TIME_H)
 # include <sys/time.h>
 # if TIME_WITH_SYS_TIME
 #  include <time.h>
 # endif
 #else
 # include <time.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #ifdef HAVE_PROCESS_H
 #include <process.h>
 #endif
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 #ifdef HAVE_GRP_H
 #include <grp.h>
 #endif
 #include <signal.h>
 #include <errno.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <net-snmp/library/fd_event_manager.h>
 #include <net-snmp/agent/netsnmp_close_fds.h>
 #include "../snmplib/snmp_syslog.h"
 #include "../agent_global_vars.h"
 #include "../agent/mibgroup/snmpv3/snmpEngine.h"
 #include "../agent/mibgroup/snmpv3/usmUser.h"
 #include "../agent/mibgroup/agent/nsVacmAccessTable.h"
 #include "../agent/mibgroup/agentx/subagent.h"
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_log.h"
 #include "snmptrapd_auth.h"
 #include "snmptrapd_sql.h"
 #include "notification-log-mib/notification_log.h"
 #include "tlstm-mib/snmpTlstmCertToTSNTable/snmpTlstmCertToTSNTable.h"
 #include "mibII/vacm_conf.h"
 #ifdef NETSNMP_EMBEDDED_PERL
 #include "snmp_perl.h"
 #endif
 
 /*
  * Include winservice.h to support Windows Service
  */
 #ifdef WIN32
 #include <windows.h>
 #include <tchar.h>
 #include <net-snmp/library/winservice.h>
 
 #define WIN32SERVICE
 
 #endif
 
 #ifdef NETSNMP_USE_LIBWRAP
 #include <tcpd.h>
 #endif
 
 #include <net-snmp/net-snmp-features.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
 
 #ifndef BSD4_3
 #define BSD4_2
 #endif
@@ -145,7 +145,7 @@ char           *logfile = NULL;
 static int      reconfig = 0;
 char            ddefault_port[] = "udp:162";	/* Default default port */
 char           *default_port = ddefault_port;
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     FILE           *PID;
     char           *pid_file = NULL;
 #endif
@@ -182,65 +182,65 @@ void
 usage(void)
 {
 #ifdef WIN32SERVICE
     fprintf(stderr, "\nUsage:  snmptrapd [-register] [-quiet] [OPTIONS] [LISTENING ADDRESSES]");
     fprintf(stderr, "\n        snmptrapd [-unregister] [-quiet]");
 #else
     fprintf(stderr, "Usage: snmptrapd [OPTIONS] [LISTENING ADDRESSES]\n");
 #endif
     fprintf(stderr, "\n\tNET-SNMP Version:  %s\n", netsnmp_get_version());
     fprintf(stderr, "\tWeb:      http://www.net-snmp.org/\n");
     fprintf(stderr, "\tEmail:    net-snmp-coders@lists.sourceforge.net\n");
     fprintf(stderr, "\n");
     fprintf(stderr, "  -a\t\t\tignore authentication failure traps\n");
     fprintf(stderr, "  -A\t\t\tappend to log file rather than truncating it\n");
     fprintf(stderr, "  -c FILE\t\tread FILE as a configuration file\n");
     fprintf(stderr,
             "  -C\t\t\tdo not read the default configuration files\n");
     fprintf(stderr, "  -d\t\t\tdump sent and received SNMP packets\n");
     fprintf(stderr, "  -D[TOKEN[,...]]\t\tturn on debugging output for the specified TOKENs\n\t\t\t   (ALL gives extremely verbose debugging output)\n");
     fprintf(stderr, "  -f\t\t\tdo not fork from the shell\n");
     fprintf(stderr,
             "  -F FORMAT\t\tuse specified format for logging to standard error\n");
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
     fprintf(stderr, "  -g GID\t\tchange to this numeric gid after opening\n"
 	   "\t\t\t  transport endpoints\n");
 #endif
     fprintf(stderr, "  -h, --help\t\tdisplay this usage message\n");
     fprintf(stderr,
             "  -H\t\t\tdisplay configuration file directives understood\n");
     fprintf(stderr,
             "  -m MIBLIST\t\tuse MIBLIST instead of the default MIB list\n");
     fprintf(stderr,
             "  -M DIRLIST\t\tuse DIRLIST as the list of locations\n\t\t\t  to look for MIBs\n");
     fprintf(stderr,
             "  -n\t\t\tuse numeric addresses instead of attempting\n\t\t\t  hostname lookups (no DNS)\n");
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     fprintf(stderr, "  -p FILE\t\tstore process id in FILE\n");
 #endif
 #ifdef WIN32SERVICE
     fprintf(stderr, "  -register\t\tregister as a Windows service\n");
     fprintf(stderr, "  \t\t\t  (followed by -quiet to prevent message popups)\n");
     fprintf(stderr, "  \t\t\t  (followed by the startup parameter list)\n");
     fprintf(stderr, "  \t\t\t  Note that some parameters are not relevant when running as a service\n");
 #endif
     fprintf(stderr, "  -t\t\t\tPrevent traps from being logged to syslog\n");
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
     fprintf(stderr, "  -u UID\t\tchange to this uid (numeric or textual) after\n"
 	   "\t\t\t  opening transport endpoints\n");
 #endif
 #ifdef WIN32SERVICE
     fprintf(stderr, "  -unregister\t\tunregister as a Windows service\n");
     fprintf(stderr, "  \t\t\t  (followed -quiet to prevent message popups)\n");
 #endif
     fprintf(stderr, "  -v, --version\t\tdisplay version information\n");
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     fprintf(stderr, "  -x ADDRESS\t\tuse ADDRESS as AgentX address\n");
     fprintf(stderr, "  -X\t\t\tdon't become a subagent\n");
 #endif
     fprintf(stderr,
             "  -O <OUTOPTS>\t\ttoggle options controlling output display\n");
     snmp_out_toggle_options_usage("\t\t\t", stderr);
     fprintf(stderr,
             "  -L <LOGOPTS>\t\ttoggle options controlling where to log to\n");
     snmp_log_options_usage("\t\t\t", stderr);
 }
@@ -594,741 +594,741 @@ SnmpTrapdMain(int argc, TCHAR * argv[])
 #else
 main(int argc, char *argv[])
 #endif
 {
     static const char options[] = "aAc:CdD::efF:g:hHI:L:m:M:no:O:Ptu:vx:X-:"
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
         "p:"
 #endif
         ;
     netsnmp_session *sess_list = NULL, *ss = NULL;
     netsnmp_transport *transport = NULL;
     int             arg, i = 0;
     int             exit_code = 1;
     char           *cp, *listen_ports = NULL;
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     int             agentx_subagent = 1;
 #endif
     netsnmp_trapd_handler *traph;
 #ifndef WIN32
     int             prepared_sockets = 0;
 #endif
 
 
 #ifndef NETSNMP_NO_SYSTEMD
     /* check if systemd has sockets for us and don't close them */
     prepared_sockets = netsnmp_sd_listen_fds(0);
 #endif
 #ifndef WIN32
     /*
      * close all non-standard file descriptors we may have
      * inherited from the shell.
      */
     if (!prepared_sockets)
         netsnmp_close_fds(2);
 #endif
     
 #ifdef SIGTERM
     signal(SIGTERM, term_handler);
 #endif
 #ifdef SIGHUP
     signal(SIGHUP, SIG_IGN);   /* do not terminate on early SIGHUP */
 #endif
 
 #ifdef SIGINT
     signal(SIGINT, term_handler);
 #endif
 #ifdef SIGPIPE
     signal(SIGPIPE, SIG_IGN);   /* 'Inline' failure of wayward readers */
 #endif
 
     /*
      * register our configuration handlers now so -H properly displays them 
      */
     snmptrapd_register_configs( );
 #ifdef NETSNMP_USE_MYSQL
     snmptrapd_register_sql_configs( );
 #endif
 #ifdef NETSNMP_SECMOD_USM
     init_usm_conf( "snmptrapd" );
 #endif /* NETSNMP_SECMOD_USM */
     register_config_handler("snmptrapd", "snmpTrapdAddr",
                             parse_trapd_address, free_trapd_address, "string");
 
     register_config_handler("snmptrapd", "doNotLogTraps",
                             parse_config_doNotLogTraps, NULL, "(1|yes|true|0|no|false)");
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     register_config_handler("snmptrapd", "pidFile",
                             parse_config_pidFile, NULL, "string");
 #endif
 #ifdef HAVE_UNISTD_H
     register_config_handler("snmptrapd", "agentuser",
                             parse_config_agentuser, NULL, "userid");
     register_config_handler("snmptrapd", "agentgroup",
                             parse_config_agentgroup, NULL, "groupid");
 #endif
 
     register_config_handler("snmptrapd", "doNotFork",
                             parse_config_doNotFork, NULL, "(1|yes|true|0|no|false)");
 
     register_config_handler("snmptrapd", "ignoreAuthFailure",
                             parse_config_ignoreAuthFailure, NULL, "(1|yes|true|0|no|false)");
 
     register_config_handler("snmptrapd", "outputOption",
                             parse_config_outputOption, NULL, "string");
 
     register_config_handler("snmptrapd", "addForwarderInfo",
                             parse_config_addForwarderInfo, NULL,
                             "(1|yes|true|0|no|false)");
 
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
 #ifdef WIN32
     snmp_log_syslogname(app_name_long);
 #else
     snmp_log_syslogname(app_name);
 #endif
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
 
     /*
      * Now process options normally.  
      */
 
     while ((arg = getopt(argc, argv, options)) != EOF) {
         switch (arg) {
         case '-':
             if (strcasecmp(optarg, "help") == 0 ||
                 strcasecmp(optarg, "version") == 0) {
                 version();
                 exit_code = 0;
                 goto out;
             }
 
             handle_long_opt(optarg);
             break;
 
         case 'a':
             dropauth = 1;
             break;
 
         case 'A':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID,
                                    NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
             break;
 
         case 'c':
             if (optarg != NULL) {
                 netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
 				      NETSNMP_DS_LIB_OPTIONALCONFIG, optarg);
             } else {
                 usage();
                 goto out;
             }
             break;
 
         case 'C':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
 				   NETSNMP_DS_LIB_DONT_READ_CONFIGS, 1);
             break;
 
         case 'd':
             netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, 
                                    NETSNMP_DS_LIB_DUMP_PACKET, 1);
             break;
 
         case 'D':
             debug_register_tokens(optarg);
             snmp_set_do_debugging(1);
             break;
 
         case 'f':
             dofork = 0;
             break;
 
         case 'F':
             if (optarg != NULL) {
                 if (( strncmp( optarg, "print",   5 ) == 0 ) ||
                     ( strncmp( optarg, "syslog",  6 ) == 0 ) ||
                     ( strncmp( optarg, "execute", 7 ) == 0 )) {
                     /* New style: "type=format" */
                     trap1_fmt_str_remember = strdup(optarg);
                     cp = strchr( trap1_fmt_str_remember, '=' );
                     if (cp)
                         *cp = ' ';
                 } else {
                     /* Old style: implicitly "print=format" */
                     trap1_fmt_str_remember = malloc(strlen(optarg) + 7);
                     sprintf( trap1_fmt_str_remember, "print %s", optarg );
                 }
             } else {
                 usage();
                 goto out;
             }
             break;
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
         case 'g':
             if (optarg != NULL) {
                 int gid;
                 char *ecp;
 
                 gid = strtoul(optarg, &ecp, 10);
 #if defined(HAVE_GETGRNAM) && defined(HAVE_PWD_H)
                 if (*ecp) {
                     struct group  *info;
 
                     info = getgrnam(optarg);
                     gid = info ? info->gr_gid : -1;
                     endgrent();
                 }
 #endif
                 if (gid < 0) {
                     fprintf(stderr, "Bad group id: %s\n", optarg);
                     goto out;
                 }
                 netsnmp_set_agent_group_id(gid);
             } else {
                 usage();
                 goto out;
             }
             break;
 #endif
 
         case 'h':
             usage();
             exit_code = 0;
             goto out;
 
         case 'H':
             init_agent("snmptrapd");
 #ifdef USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE
             init_notification_log();
 #endif
 #ifdef NETSNMP_EMBEDDED_PERL
             init_perl();
 #endif
             init_snmp("snmptrapd");
             fprintf(stderr, "Configuration directives understood:\n");
             read_config_print_usage("  ");
             exit_code = 0;
             goto out;
 
         case 'I':
             if (optarg != NULL) {
                 add_to_init_list(optarg);
             } else {
                 usage();
             }
             break;
 
 	case 'S':
             fprintf(stderr,
                     "Warning: -S option has been withdrawn; use -Ls <facility> instead\n");
             goto out;
 
         case 'm':
             if (optarg != NULL) {
                 setenv("MIBS", optarg, 1);
             } else {
                 usage();
                 goto out;
             }
             break;
 
         case 'M':
             if (optarg != NULL) {
                 setenv("MIBDIRS", optarg, 1);
             } else {
                 usage();
                 goto out;
             }
             break;
 
         case 'n':
             netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
 				   NETSNMP_DS_APP_NUMERIC_IP, 1);
             break;
 
         case 'o':
             fprintf(stderr,
                     "Warning: -o option has been withdrawn; use -Lf <file> instead\n");
             goto out;
 
         case 'O':
             cp = snmp_out_toggle_options(optarg);
             if (cp != NULL) {
                 fprintf(stderr, "Unknown output option passed to -O: %c\n",
 			*cp);
                 usage();
                 goto out;
             }
             break;
 
         case 'L':
 	    if  (snmp_log_options( optarg, argc, argv ) < 0 ) {
                 usage();
                 goto out;
             }
             break;
 
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
         case 'p':
             if (optarg != NULL) {
                 parse_config_pidFile(NULL, optarg);
             } else {
                 usage();
                 goto out;
             }
             break;
 #endif
 
         case 'P':
             fprintf(stderr,
                     "Warning: -P option has been withdrawn; use -f -Le instead\n");
             goto out;
 
         case 's':
             fprintf(stderr,
                     "Warning: -s option has been withdrawn; use -Lsd instead\n");
             goto out;
 
         case 't':
             SyslogTrap++;
             break;
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
         case 'u':
             if (optarg != NULL) {
                 int             uid;
                 char           *ecp;
 
                 uid = strtoul(optarg, &ecp, 10);
 #if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
                 if (*ecp) {
                     struct passwd  *info;
 
                     info = getpwnam(optarg);
                     uid = info ? info->pw_uid : -1;
                     endpwent();
                 }
 #endif
                 if (uid < 0) {
                     fprintf(stderr, "Bad user id: %s\n", optarg);
                     goto out;
                 }
                 netsnmp_set_agent_user_id(uid);
             } else {
                 usage();
                 goto out;
             }
             break;
 #endif
 
         case 'v':
             version();
             exit(0);
             break;
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
         case 'x':
             if (optarg != NULL) {
                 netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                       NETSNMP_DS_AGENT_X_SOCKET, optarg);
             } else {
                 usage();
                 goto out;
             }
             break;
 
          case 'X':
             agentx_subagent = 0;
             break;
 #endif
 
         default:
             fprintf(stderr, "invalid option: -%c\n", arg);
             usage();
             goto out;
             break;
         }
     }
 
     if (optind < argc) {
         /*
          * There are optional transport addresses on the command line.  
          */
         for (i = optind; i < argc; i++) {
             char *astring;
             if (listen_ports != NULL) {
                 astring = malloc(strlen(listen_ports) + 2 + strlen(argv[i]));
                 if (astring == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
                     goto out;
                 }
                 sprintf(astring, "%s,%s", listen_ports, argv[i]);
                 free(listen_ports);
                 listen_ports = astring;
             } else {
                 listen_ports = strdup(argv[i]);
                 if (listen_ports == NULL) {
                     fprintf(stderr, "malloc failure processing argv[%d]\n", i);
                     goto out;
                 }
             }
         }
     }
 
     SOCK_STARTUP;
 
     /*
      * I'm being lazy here, and not checking the
      * return value from these registration calls.
      * Don't try this at home, children!
      */
     if (0 == snmp_get_do_logging()) {
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
         traph = netsnmp_add_global_traphandler(NETSNMPTRAPD_PRE_HANDLER,
                                                syslog_handler);
         traph->authtypes = TRAP_AUTH_LOG;
         snmp_enable_syslog();
 #else /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_STDIO
         traph = netsnmp_add_global_traphandler(NETSNMPTRAPD_PRE_HANDLER,
                                                print_handler);
         traph->authtypes = TRAP_AUTH_LOG;
         snmp_enable_stderr();
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_STDIO */
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
     } else {
         traph = netsnmp_add_global_traphandler(NETSNMPTRAPD_PRE_HANDLER,
                                                print_handler);
         traph->authtypes = TRAP_AUTH_LOG;
     }
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     /*
      * we're an agentx subagent? 
      */
     if (agentx_subagent) {
         /*
          * make us a agentx client. 
          */
         netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
 			       NETSNMP_DS_AGENT_ROLE, 1);
     }
 #endif
 
     /*
      * don't fail if we can't do agentx (ie, socket not there, or not root) 
      */
     netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 			      NETSNMP_DS_AGENT_NO_ROOT_ACCESS);
     /*
      * ignore any warning messages.
      */
     netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 			      NETSNMP_DS_AGENT_NO_CONNECTION_WARNINGS);
 
     /*
      * initialize the agent library 
      */
     init_agent("snmptrapd");
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
 #ifdef NETSNMP_FEATURE_CHECKING
     netsnmp_feature_require(register_snmpEngine_scalars_context)
 #endif /* NETSNMP_FEATURE_CHECKING */
     /*
      * initialize local modules 
      */
     if (agentx_subagent) {
         subagent_init();
 #ifdef USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE
         /* register the notification log table */
         if (should_init("notificationLogMib")) {
             netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                               NETSNMP_DS_NOTIF_LOG_CTX,
                               "snmptrapd");
             traph = netsnmp_add_global_traphandler(NETSNMPTRAPD_POST_HANDLER,
                                                    notification_handler);
             traph->authtypes = TRAP_AUTH_LOG;
             init_notification_log();
         }
 #endif
 #ifdef USING_SNMPV3_SNMPENGINE_MODULE
         /*
          * register scalars from SNMP-FRAMEWORK-MIB::snmpEngineID group;
          * allows engineID probes via the master agent under the
          * snmptrapd context
          */
         register_snmpEngine_scalars_context("snmptrapd");
 #endif
     }
 #endif /* USING_AGENTX_SUBAGENT_MODULE && !NETSNMP_SNMPTRAPD_DISABLE_AGENTX */
 
     /* register our authorization handler */
     init_netsnmp_trapd_auth();
 
 #if defined(USING_AGENTX_SUBAGENT_MODULE) && !defined(NETSNMP_SNMPTRAPD_DISABLE_AGENTX)
     if (agentx_subagent) {
 #ifdef USING_SNMPV3_USMUSER_MODULE
 #ifdef NETSNMP_FEATURE_CHECKING
         netsnmp_feature_require(init_register_usmUser_context)
 #endif /* NETSNMP_FEATURE_CHECKING */
         /* register ourselves as having a USM user database */
         init_register_usmUser_context("snmptrapd");
 #endif
 #ifdef USING_AGENT_NSVACMACCESSTABLE_MODULE
         /* register net-snmp vacm extensions */
         init_register_nsVacm_context("snmptrapd");
 #endif
 #ifdef USING_TLSTM_MIB_SNMPTLSTMCERTTOTSNTABLE_MODULE
         init_snmpTlstmCertToTSNTable_context("snmptrapd");
 #endif
     }
 #endif
 
 #ifdef NETSNMP_EMBEDDED_PERL
     init_perl();
     {
         /* set the default path to load */
         char            init_file[SNMP_MAXBUF];
         snprintf(init_file, sizeof(init_file) - 1,
                  "%s/%s", SNMPSHAREPATH, "snmp_perl_trapd.pl");
         netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                               NETSNMP_DS_AGENT_PERL_INIT_FILE,
                               init_file);
     }
 #endif
 
     /*
      * Initialize the world.
      */
     init_snmp("snmptrapd");
 
 #ifdef SIGHUP
     signal(SIGHUP, hup_handler);
 #endif
 
     if (trap1_fmt_str_remember) {
         parse_format( NULL, trap1_fmt_str_remember );
     }
 
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 			       NETSNMP_DS_AGENT_QUIT_IMMEDIATELY)) {
         /*
          * just starting up to process specific configuration and then
          * shutting down immediately. 
          */
         netsnmp_running = 0;
     }
 
     /*
      * if no logging options on command line or in conf files, use syslog
      */
     if (0 == snmp_get_do_logging()) {
 #ifndef NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG
 #ifdef WIN32
         snmp_enable_syslog_ident(app_name_long, Facility);
 #else
         snmp_enable_syslog_ident(app_name, Facility);
 #endif        
 #endif /* NETSNMP_FEATURE_REMOVE_LOGGING_SYSLOG */
     }
 
     if (listen_ports)
         cp = listen_ports;
     else
         cp = default_port;
 
     while (cp != NULL) {
         char *sep = strchr(cp, ',');
 
         if (sep != NULL) {
             *sep = 0;
         }
 
         transport = netsnmp_transport_open_server("snmptrap", cp);
         if (transport == NULL) {
             snmp_log(LOG_ERR, "couldn't open %s -- errno %d (\"%s\")\n",
                      cp, errno, strerror(errno));
             snmptrapd_close_sessions(sess_list);
             goto sock_cleanup;
         } else {
             ss = snmptrapd_add_session(transport);
             if (ss == NULL) {
                 /*
                  * Shouldn't happen?  We have already opened the transport
                  * successfully so what could have gone wrong?  
                  */
                 snmptrapd_close_sessions(sess_list);
                 snmp_log(LOG_ERR, "couldn't open snmp - %s", strerror(errno));
                 goto sock_cleanup;
             } else {
                 ss->next = sess_list;
                 sess_list = ss;
             }
         }
 
         /*
          * Process next listen address, if there is one.  
          */
 
         if (sep != NULL) {
             *sep = ',';
             cp = sep + 1;
         } else {
             cp = NULL;
         }
     }
     SNMP_FREE(listen_ports); /* done with them */
 
 #ifdef NETSNMP_USE_MYSQL
     if( netsnmp_mysql_init() ) {
         fprintf(stderr, "MySQL initialization failed\n");
         goto sock_cleanup;
     }
 #endif
 
 #ifndef WIN32
     /*
      * fork the process to the background if we are not printing to stderr 
      */
     if (dofork && netsnmp_running) {
         int             fd;
 
 #ifdef HAVE_FORKALL
         switch (forkall()) {
 #else
         switch (fork()) {
 #endif
         case -1:
             fprintf(stderr, "bad fork - %s\n", strerror(errno));
             goto sock_cleanup;
 
         case 0:
             /*
              * become process group leader 
              */
             if (setsid() == -1) {
                 fprintf(stderr, "bad setsid - %s\n", strerror(errno));
                 goto sock_cleanup;
             }
 
             /*
              * if we are forked, we don't want to print out to stdout or stderr 
              */
             fd = open("/dev/null", O_RDWR);
             if (fd >= 0) {
                 dup2(fd, STDIN_FILENO);
                 dup2(fd, STDOUT_FILENO);
                 dup2(fd, STDERR_FILENO);
                 close(fd);
             }
             break;
 
         default:
             _exit(0);
         }
     }
 #endif                          /* WIN32 */
-#if HAVE_GETPID
+#ifdef HAVE_GETPID
     if (pid_file != NULL) {
         if ((PID = fopen(pid_file, "w")) == NULL) {
             snmp_log_perror("fopen");
             goto sock_cleanup;
         }
         fprintf(PID, "%d\n", (int) getpid());
         fclose(PID);
         free_config_pidFile();
     }
 #endif
 
     snmp_log(LOG_INFO, "NET-SNMP version %s\n", netsnmp_get_version());
 
     /*
      * ignore early sighup during startup
      */
     reconfig = 0;
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #ifdef HAVE_SETGID
     {
     int gid;
 
     if ((gid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 				  NETSNMP_DS_AGENT_GROUPID)) > 0) {
         DEBUGMSGTL(("snmptrapd/main", "Changing gid to %d.\n", gid));
         if (setgid(gid) == -1
 #ifdef HAVE_SETGROUPS
             || setgroups(1, (gid_t *)&gid) == -1
 #endif
             ) {
             snmp_log_perror("setgid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 goto sock_cleanup;
             }
         }
     }
     }
 #endif
 #ifdef HAVE_SETUID
     {
     int uid;
 
     if ((uid = netsnmp_ds_get_int(NETSNMP_DS_APPLICATION_ID, 
 				  NETSNMP_DS_AGENT_USERID)) > 0) {
         DEBUGMSGTL(("snmptrapd/main", "Changing uid to %d.\n", uid));
         if (setuid(uid) == -1) {
             snmp_log_perror("setuid failed");
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
 					NETSNMP_DS_AGENT_NO_ROOT_ACCESS)) {
                 goto sock_cleanup;
             }
         }
     }
     }
 #endif
 #endif
 
     /*
      * Let systemd know we're up.
      */
 #ifndef NETSNMP_NO_SYSTEMD
     netsnmp_sd_notify(1, "READY=1\n");
     if (prepared_sockets)
         /*
          * Clear the environment variable, we already processed all the sockets
          * by now.
          */
         netsnmp_sd_listen_fds(1);
 #endif
 
 #ifdef WIN32SERVICE
     trapd_status = SNMPTRAPD_RUNNING;
 #endif
 
     snmptrapd_main_loop();
 
     if (snmp_get_do_logging()) {
         struct tm      *tm;
         time_t          timer;
         time(&timer);
         tm = localtime(&timer);
         snmp_log(LOG_INFO,
                 "%.4d-%.2d-%.2d %.2d:%.2d:%.2d NET-SNMP version %s Stopped.\n",
                  tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
                  tm->tm_min, tm->tm_sec, netsnmp_get_version());
     }
     snmp_log(LOG_INFO, "Stopping snmptrapd\n");
     
 #ifdef NETSNMP_EMBEDDED_PERL
     shutdown_perl();
 #endif
     snmptrapd_close_sessions(sess_list);
     snmp_shutdown("snmptrapd");
 #ifdef WIN32SERVICE
     trapd_status = SNMPTRAPD_STOPPED;
 #endif
     snmp_disable_log();
 
     exit_code = 0;
diff --git a/apps/snmptrapd_auth.c b/apps/snmptrapd_auth.c
index 06b8488c9d..892fe499a6 100644
--- a/apps/snmptrapd_auth.c
+++ b/apps/snmptrapd_auth.c
@@ -1,39 +1,39 @@
 /*
  * snmptrapd_auth.c - authorize notifications for further processing
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  */
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_auth.h"
 #include "snmptrapd_ds.h"
 
 #include <net-snmp/agent/agent_module_config.h>
 #include <net-snmp/agent/mib_module_config.h>
 
 #ifdef USING_MIBII_VACM_CONF_MODULE
 #include "mibII/vacm_conf.h"
 #endif
 
 #include <net-snmp/agent/agent_trap.h>
 
 /**
  * initializes the snmptrapd authorization code registering needed
  * handlers and config parsers.
  */
diff --git a/apps/snmptrapd_handlers.c b/apps/snmptrapd_handlers.c
index cb3e8d7ada..2c42bc3e47 100644
--- a/apps/snmptrapd_handlers.c
+++ b/apps/snmptrapd_handlers.c
@@ -1,42 +1,42 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 
 #include <net-snmp/config_api.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/mib_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "utilities/execute.h"
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_auth.h"
 #include "snmptrapd_log.h"
 #include "notification-log-mib/notification_log.h"
diff --git a/apps/snmptrapd_log.c b/apps/snmptrapd_log.c
index 4dec636db1..d679cb5e02 100644
--- a/apps/snmptrapd_log.c
+++ b/apps/snmptrapd_log.c
@@ -24,81 +24,81 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
 #if !defined(mingw32) && defined(HAVE_SYS_TIME_H)
 # include <sys/time.h>
 # if TIME_WITH_SYS_TIME
 #  include <time.h>
 # endif
 #else
 # include <time.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_log.h"
 
 
 #ifndef BSD4_3
 #define BSD4_2
 #endif
 
 /*
  * These flags mark undefined values in the options structure 
  */
 #define UNDEF_CMD '*'
 #define UNDEF_PRECISION -1
 
 /*
  * This structure holds the options for a single format command 
  */
diff --git a/apps/snmptrapd_sql.c b/apps/snmptrapd_sql.c
index 0db942993f..1b2bcb34c0 100644
--- a/apps/snmptrapd_sql.c
+++ b/apps/snmptrapd_sql.c
@@ -1,63 +1,63 @@
 /*
  * File       : snmptrapd_sql
  * Author     : Robert Story
  *
  * Copyright © 2009 Science Logic, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * This file implements a handler for snmptrapd which will cache incoming
  * traps and then write them to a MySQL database.
  *
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef NETSNMP_USE_MYSQL
 
 /*
  * SQL includes
  */
 #undef PACKAGE_BUGREPORT
 #undef PACKAGE_NAME
 #undef PACKAGE_STRING
 #undef PACKAGE_TARNAME
 #undef PACKAGE_VERSION
 #if !defined(HAVE_MYSQL_INIT)
 #ifdef HAVE_MY_GLOBAL_H
 #include <my_global.h>
 #endif
 #ifdef HAVE_MY_SYS_H
 #include <my_sys.h>
 #endif
 #endif
 #include <mysql.h>
 #include <errmsg.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "snmptrapd_handlers.h"
 #include "snmptrapd_auth.h"
 #include "snmptrapd_log.h"
 #include "snmptrapd_sql.h"
@@ -372,68 +372,68 @@ static int
 netsnmp_mysql_connect(void)
 {
     char trap_stmt[] = "INSERT INTO notifications "
         "(date_time, host, auth, type, version, request_id, snmpTrapOID, transport, security_model, v3msgid, v3security_level, v3context_name, v3context_engine, v3security_name, v3security_engine) "
         "VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
     char vb_stmt[] = "INSERT INTO varbinds "
         "(trap_id, oid, type, value) VALUES (?,?,?,?)";
 
     /** initialize connection handler */
     if (_sql.connected)
         return 0;
 
     DEBUGMSGTL(("sql:connection","connecting\n"));
 
     if (_sql.conn) {
         mysql_close(_sql.conn);
         _sql.conn = NULL;
     }
 
     _sql.conn = mysql_init (NULL);
     if (_sql.conn == NULL) {
         netsnmp_sql_error("mysql_init() failed (out of memory?)");
         goto err;
     }
 
-#if HAVE_MYSQL_OPTIONS
+#ifdef HAVE_MYSQL_OPTIONS
     mysql_options(_sql.conn, MYSQL_READ_DEFAULT_GROUP, "snmptrapd");
 #endif
 
     /** connect to server */
     if (mysql_real_connect (_sql.conn, _sql.host_name, _sql.user_name,
                             _sql.password, _sql.db_name, _sql.port_num,
                             _sql.socket_name, _sql.flags) == NULL) {
         netsnmp_sql_error("mysql_real_connect() failed");
         goto err;
     }
     _sql.connected = 1;
 
     /** disable autocommit */
     if(0 != mysql_autocommit(_sql.conn, 0)) {
         netsnmp_sql_error("mysql_autocommit(0) failed");
         goto err;
     }
 
     netsnmp_assert((_sql.trap_stmt == NULL) && (_sql.vb_stmt == NULL));
 
     /** prepared statement for inserts */
     if (0 != netsnmp_mysql_bind(trap_stmt,sizeof(trap_stmt), &_sql.trap_stmt,
                                 _tbind))
         goto err;
 
     if (0 != netsnmp_mysql_bind(vb_stmt,sizeof(vb_stmt),&_sql.vb_stmt,
                                 _vbind)) {
         mysql_stmt_close(_sql.trap_stmt);
         _sql.trap_stmt = NULL;
         goto err;
     }
 
     return 0;
 
   err:
     if (_sql.connected)
         _sql.connected = 0;
 
     return -1;
 }
 
 /** one-time initialization for mysql */
@@ -441,163 +441,163 @@ int
 netsnmp_mysql_init(void)
 {
     netsnmp_trapd_handler *traph;
 
     DEBUGMSGTL(("sql:init","called\n"));
 
     /** negative or 0 interval disables sql logging */
     if (_sql.queue_interval <= 0) {
         DEBUGMSGTL(("sql:init",
                     "mysql not enabled (sqlSaveInterval is <= 0)\n"));
         return 0;
     }
 
     /** create queue for storing traps til they are written to the db */
     _sql.queue = netsnmp_container_find("fifo");
     if (NULL == _sql.queue) {
         snmp_log(LOG_ERR, "Could not allocate sql buf container\n");
         return -1;
     }
 
 #if defined(HAVE_MYSQL_INIT)
     mysql_init(NULL);
 #elif defined(HAVE_MY_INIT)
     MY_INIT("snmptrapd");
 #else
     my_init();
 #endif
 
 #if !defined(HAVE_MYSQL_OPTIONS)
     {
     int not_argc = 0, i;
     char *not_args[] = { NULL };
     char **not_argv = not_args;
 
     /** load .my.cnf values */
-#if HAVE_MY_LOAD_DEFAULTS
+#ifdef HAVE_MY_LOAD_DEFAULTS
     my_load_defaults ("my", _sql.groups, &not_argc, &not_argv, 0);
 #elif defined(HAVE_LOAD_DEFAULTS)
     load_defaults ("my", _sql.groups, &not_argc, &not_argv);
 #else
 #error Neither load_defaults() nor mysql_options() are available.
 #endif
 
     for (i = 0; i < not_argc; ++i) {
         if (NULL == not_argv[i])
             continue;
         if (strncmp(not_argv[i],"--password=",11) == 0)
             _sql.password = &not_argv[i][11];
         else if (strncmp(not_argv[i],"--host=",7) == 0)
             _sql.host_name = &not_argv[i][7];
         else if (strncmp(not_argv[i],"--user=",7) == 0)
             _sql.user_name = &not_argv[i][7];
         else if (strncmp(not_argv[i],"--port=",7) == 0)
             _sql.port_num = atoi(&not_argv[i][7]);
         else if (strncmp(not_argv[i],"--socket=",9) == 0)
             _sql.socket_name = &not_argv[i][9];
         else if (strncmp(not_argv[i],"--database=",11) == 0)
             _sql.db_name = &not_argv[i][11];
         else
             snmp_log(LOG_WARNING, "unknown argument[%d] %s\n", i, not_argv[i]);
     }
     }
 #endif /* !defined(HAVE_MYSQL_OPTIONS) */
 
     /** init bind structures */
     memset(_tbind, 0x0, sizeof(_tbind));
     memset(_vbind, 0x0, sizeof(_vbind));
 
     /** trap static bindings */
     _tbind[TBIND_HOST].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_HOST].length = &_tbind[TBIND_HOST].buffer_length;
 
     _tbind[TBIND_OID].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_OID].length = &_tbind[TBIND_OID].buffer_length;
 
     _tbind[TBIND_REQID].buffer_type = MYSQL_TYPE_LONG;
     _tbind[TBIND_REQID].is_unsigned = 1;
 
     _tbind[TBIND_VER].buffer_type = MYSQL_TYPE_SHORT;
     _tbind[TBIND_VER].is_unsigned = 1;
 
     _tbind[TBIND_TYPE].buffer_type = MYSQL_TYPE_SHORT;
     _tbind[TBIND_TYPE].is_unsigned = 1;
 
     _tbind[TBIND_DATE].buffer_type = MYSQL_TYPE_DATETIME;
 
     _tbind[TBIND_USER].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_USER].length = &_tbind[TBIND_USER].buffer_length;
 
     _tbind[TBIND_TRANSPORT].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_TRANSPORT].length = &_tbind[TBIND_TRANSPORT].buffer_length;
 
     _tbind[TBIND_SECURITY_MODEL].buffer_type = MYSQL_TYPE_SHORT;
     _tbind[TBIND_SECURITY_MODEL].is_unsigned = 1;
 
     _tbind[TBIND_v3_MSGID].buffer_type = MYSQL_TYPE_LONG;
     _tbind[TBIND_v3_MSGID].is_unsigned = 1;
     _tbind[TBIND_v3_SECURITY_LEVEL].buffer_type = MYSQL_TYPE_SHORT;
     _tbind[TBIND_v3_SECURITY_LEVEL].is_unsigned = 1;
     _tbind[TBIND_v3_CONTEXT_NAME].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_v3_CONTEXT_ENGINE].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_v3_SECURITY_NAME].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_v3_SECURITY_NAME].length =
         &_tbind[TBIND_v3_SECURITY_NAME].buffer_length;
     _tbind[TBIND_v3_CONTEXT_NAME].length =
         &_tbind[TBIND_v3_CONTEXT_NAME].buffer_length;
     _tbind[TBIND_v3_SECURITY_ENGINE].buffer_type = MYSQL_TYPE_STRING;
     _tbind[TBIND_v3_SECURITY_ENGINE].length =
         &_tbind[TBIND_v3_SECURITY_ENGINE].buffer_length;
     _tbind[TBIND_v3_CONTEXT_ENGINE].length =
         &_tbind[TBIND_v3_CONTEXT_ENGINE].buffer_length;
 
     _tbind[TBIND_v3_MSGID].is_null =
         _tbind[TBIND_v3_SECURITY_LEVEL].is_null =
         _tbind[TBIND_v3_CONTEXT_NAME].is_null =
         _tbind[TBIND_v3_CONTEXT_ENGINE].is_null =
         _tbind[TBIND_v3_SECURITY_NAME].is_null =
         _tbind[TBIND_v3_SECURITY_ENGINE].is_null = &_no_v3;
     
     /** variable static bindings */
     _vbind[VBIND_ID].buffer_type = MYSQL_TYPE_LONG;
     _vbind[VBIND_ID].is_unsigned = 1;
 
     _vbind[VBIND_OID].buffer_type = MYSQL_TYPE_STRING;
     _vbind[VBIND_OID].length = &_vbind[VBIND_OID].buffer_length;
 
     _vbind[VBIND_TYPE].buffer_type = MYSQL_TYPE_SHORT;
     _vbind[VBIND_TYPE].is_unsigned = 1;
 
 #ifdef NETSNMP_MYSQL_TRAP_VALUE_TEXT
     _vbind[VBIND_VAL].buffer_type = MYSQL_TYPE_STRING;
 #else
     _vbind[VBIND_VAL].buffer_type = MYSQL_TYPE_BLOB;
 #endif
     _vbind[VBIND_VAL].length = &_vbind[VBIND_VAL].buffer_length;
 
     /** try to connect; we'll try again later if we fail */
     (void) netsnmp_mysql_connect();
 
     /** register periodic queue save */
     _sql.alarm_id = snmp_alarm_register(_sql.queue_interval, /* seconds */
                                         1,                   /* repeat */
                                         _sql_process_queue,  /* function */
                                         NULL);               /* client args */
 
     /** add handler */
     traph = netsnmp_add_global_traphandler(NETSNMPTRAPD_PRE_HANDLER,
                                            mysql_handler);
     if (NULL == traph) {
         snmp_log(LOG_ERR, "Could not allocate sql trap handler\n");
         return -1;
     }
     traph->authtypes = TRAP_AUTH_LOG;
 
     atexit(netsnmp_mysql_cleanup);
     return 0;
 }
 
 /*
  * log CSV version of trap.
  * dontcare param is there so this function can be passed directly
  * to CONTAINER_FOR_EACH.
  */
diff --git a/apps/snmpusm.c b/apps/snmpusm.c
index fb921f2d6d..89b78f283b 100644
--- a/apps/snmpusm.c
+++ b/apps/snmpusm.c
@@ -1,78 +1,78 @@
 /*
  * snmpusm.c - send snmp SET requests to a network entity to change the
  *             usm user database
  *
  * XXX get engineID dynamically.
  * XXX read passwords from prompts
  * XXX customize responses with user names, etc.
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmp_openssl.h>
 #if defined(HAVE_OPENSSL_DH_H) && defined(HAVE_LIBCRYPTO)
 #include <openssl/dh.h>
 #endif /* HAVE_OPENSSL_DH_H && HAVE_LIBCRYPTO */
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #define CMD_PASSWD_NAME    "passwd"
 #define CMD_PASSWD         1
 #define CMD_CREATE_NAME    "create"
 #define CMD_CREATE         2
 #define CMD_DELETE_NAME    "delete"
 #define CMD_DELETE         3
 #define CMD_CLONEFROM_NAME "cloneFrom"
 #define CMD_CLONEFROM      4
 #define CMD_ACTIVATE_NAME  "activate"
 #define CMD_ACTIVATE       5
 #define CMD_DEACTIVATE_NAME "deactivate"
 #define CMD_DEACTIVATE     6
 #define CMD_CHANGEKEY_NAME  "changekey"
 #define CMD_CHANGEKEY      7
 
 #define CMD_NUM    7
diff --git a/apps/snmpvacm.c b/apps/snmpvacm.c
index 357b5c5b9b..c09193a85f 100644
--- a/apps/snmpvacm.c
+++ b/apps/snmpvacm.c
@@ -1,64 +1,64 @@
 /*
  * snmpvacm.c - send snmp SET requests to a network entity to change the
  *             vacm database
  *
  */
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define CMD_CREATESEC2GROUP_NAME    "createSec2Group"
 #define CMD_CREATESEC2GROUP         1
 #define CMD_DELETESEC2GROUP_NAME    "deleteSec2Group"
 #define CMD_DELETESEC2GROUP         2
 #define CMD_CREATEACCESS_NAME    	"createAccess"
 #define CMD_CREATEACCESS         	3
 #define CMD_DELETEACCESS_NAME 		"deleteAccess"
 #define CMD_DELETEACCESS      		4
 #define CMD_CREATEVIEW_NAME 		"createView"
 #define CMD_CREATEVIEW      		5
 #define CMD_DELETEVIEW_NAME 		"deleteView"
 #define CMD_DELETEVIEW      		6
 #define CMD_CREATEAUTH_NAME     	"createAuth"
 #define CMD_CREATEAUTH          	7
 #define CMD_DELETEAUTH_NAME 		"deleteAuth"
 #define CMD_DELETEAUTH      		8
 
 #define CMD_NUM    8
diff --git a/apps/snmpwalk.c b/apps/snmpwalk.c
index a637e558a5..0e0e14c3c6 100644
--- a/apps/snmpwalk.c
+++ b/apps/snmpwalk.c
@@ -25,48 +25,48 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #include <stdio.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
 #define NETSNMP_DS_WALK_INCLUDE_REQUESTED	        1
 #define NETSNMP_DS_WALK_PRINT_STATISTICS	        2
 #define NETSNMP_DS_WALK_DONT_CHECK_LEXICOGRAPHIC	3
 #define NETSNMP_DS_WALK_TIME_RESULTS     	        4
 #define NETSNMP_DS_WALK_DONT_GET_REQUESTED	        5
 #define NETSNMP_DS_WALK_TIME_RESULTS_SINGLE	        6
diff --git a/apps/sshtosnmp.c b/apps/sshtosnmp.c
index 20aed4b815..6e765bdd43 100644
--- a/apps/sshtosnmp.c
+++ b/apps/sshtosnmp.c
@@ -1,48 +1,48 @@
 /* Copyright 2009 SPARTA, Inc. All rights reserved
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  * This is merely a wrapper around stdin/out for sshd to call.  It
  * simply passes traffic to the running snmpd through a unix domain
  * socket after first passing any needed SSH Domain information.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_SYS_UN_H
+#ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
 
 #include <sys/select.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <stdio.h>
 
 #ifndef MAXPATHLEN
 #warning no system max path length detected
 #define MAXPATHLEN 2048
 #endif
 
 #define DEFAULT_SOCK_PATH "/var/net-snmp/sshdomainsocket"
 
 #define NETSNMP_SSHTOSNMP_VERSION_NUMBER 1
 
 
 
 /*
  * Extra debugging output for, um, debugging.
  */
 
 #undef DEBUGGING
 
 #define DEBUG(x) deb(x)
 #ifdef DEBUGGING
diff --git a/configure.d/config_os_headers b/configure.d/config_os_headers
index ccaa925d47..e073d42b02 100644
--- a/configure.d/config_os_headers
+++ b/configure.d/config_os_headers
@@ -130,26 +130,26 @@ fi
 #       requiring <sys/param.h>  (MAXPATHLEN)           (OpenBSD 3.4)
 #  Agent:
 #
 AC_CHECK_HEADERS(sys/swap.h,,,
     AC_INCLUDES_DEFAULT([])
     [
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
     ])
 
 #       requiring <sys/param.h>                         (FreeBSD)
 #
 AC_CHECK_HEADERS([malloc.h        osreldate.h                   ] dnl
                  [machine/types.h ] dnl
                  [sys/dkstat.h    sys/conf.h    sys/mbuf.h      ] dnl
                  [sys/mount.h     sys/proc.h    sys/queue.h     ] dnl
                  [sys/user.h                                    ],,,
     [[
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
     ]])
@@ -172,36 +172,36 @@ AC_CHECK_HEADERS([sys/sema.h])
 AC_CHECK_HEADERS(sys/hashing.h,,,
     AC_INCLUDES_DEFAULT([])
     [
-#if HAVE_SYS_SEMA_H
+#ifdef HAVE_SYS_SEMA_H
 #include <sys/sema.h>
 #endif
     ])
 
 #       requiring _KMEMUSER and <sys/types.h>           (BSDi3/IRIX)
 #  Agent:
 #
 AC_CHECK_HEADERS(sys/vnode.h,,,
     [
 #define _KMEMUSER 1
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
     ])
 
 #       requiring <machine/types.h>                     (NetBSD)
 #  Agent:
 #
 AC_CHECK_HEADERS(sys/disklabel.h,,,
     [[
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_MACHINE_TYPES_H
+#ifdef HAVE_MACHINE_TYPES_H
 #include <machine/types.h>
 #endif
     ]])
 
 #	QNX
@@ -210,47 +210,47 @@ AC_CHECK_HEADERS([nbutil.h])
 #       UFS headers
 #  Agent:
 #
 AC_CHECK_HEADERS([ufs/ufs/dinode.h ufs/ufs/quota.h ufs/ufs/inode.h ufs/ffs/fs.h],,,
     [[
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
-#if HAVE_UFS_UFS_DINODE_H
+#ifdef HAVE_UFS_UFS_DINODE_H
 #include <ufs/ufs/dinode.h>
 #endif
-#if HAVE_UFS_UFS_QUOTA_H
+#ifdef HAVE_UFS_UFS_QUOTA_H
 #include <ufs/ufs/quota.h>
 #endif
     ]])
 
 #       requiring <vm/vm.h>                             (BSDi2)
 #  Agent:
 #
 AC_CHECK_HEADERS(vm/swap_pager.h,,,
     [[
-#if HAVE_VM_VM_H
+#ifdef HAVE_VM_VM_H
 #include <vm/vm.h>
 #endif
     ]])
 
 #       netlink/rtnetlink                               (Linux)
 #  Agent:
 #
 AC_CHECK_HEADERS([linux/netlink.h  linux/rtnetlink.h],,,
     [[
-#if HAVE_ASM_TYPES_H
+#ifdef HAVE_ASM_TYPES_H
 #include <asm/types.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_LINUX_NETLINK_H
+#ifdef HAVE_LINUX_NETLINK_H
 #include <linux/netlink.h>
 #endif
     ]])
 
 #
 # Avoid that on MinGW any networking headers get included that are
 # incompatible with <winsock2.h> by only testing for certain headers if not
 # building for one of these two platforms.
 #
@@ -263,99 +263,99 @@ case x$with_socklib in
 AC_CHECK_HEADERS([sys/socket.h]dnl
                  [sys/un.h]dnl
                  [netinet/tcp_fsm.h]dnl
                  [sys/sockio.h]dnl
                  [sys/socketvar.h]dnl
                  [net/if_dl.h]dnl
                  [net/if_types.h]dnl
                  [arpa/inet.h]dnl
                  [net/if.h]dnl
                  [netinet/in.h]dnl
                  [netdb.h]dnl
                  [net/if_arp.h]dnl
                  [net/if_mib.h]dnl
                  [net/if_var.h]dnl
                  [netinet/if_ether.h]dnl
                  [netinet/in_systm.h]dnl
                  [netinet/in_var.h]dnl
                  [netinet/ip.h]dnl
                  [netinet/ip_icmp.h]dnl
                  [netinet/icmp_var.h]dnl
                  [netinet/ip_var.h]dnl
                  [netinet/tcp.h]dnl
                  [netinet/tcp_timer.h]dnl
                  [netinet/tcp_var.h]dnl
                  [netinet/tcpip.h]dnl
                  [netinet/udp.h]dnl
                  [netinet/udp_var.h]dnl
                  [net/route.h]dnl
                  [netinet/icmp6.h]dnl
                  [netinet/in_pcb.h]dnl
                  [netinet/ip6.h]dnl
                  [netinet6/in6_var.h]dnl
                  [netinet6/in6_pcb.h]dnl
                  [netinet6/ip6_var.h]dnl
                  [netinet6/nd6.h]dnl
                  [netinet6/tcp6.h]dnl
                  [netinet6/tcp6_fsm.h]dnl
                  [netinet6/tcp6_timer.h]dnl
                  [netinet6/tcp6_var.h]dnl
                  ,,,
     [[
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_TYPES_H
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
-#if HAVE_SYS_TIMEOUT_H
+#ifdef HAVE_SYS_TIMEOUT_H
 #include <sys/timeout.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_SYS_SOCKETVAR_H
+#ifdef HAVE_SYS_SOCKETVAR_H
 #include <sys/socketvar.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETINET_IN_SYSTM_H
+#ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET_IP_H
+#ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
-#if HAVE_NETINET_IP_H
+#ifdef HAVE_NETINET_IP_H
 #include <netinet/ip_icmp.h>
 #endif
-#if HAVE_NET_IF_H
+#ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
-#if HAVE_NET_IF_VAR_H
+#ifdef HAVE_NET_IF_VAR_H
 #include <net/if_var.h>
 #endif
-#if HAVE_NETINET_IP_VAR_H
+#ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
-#if HAVE_NETINET_IP_ICMP_H
+#ifdef HAVE_NETINET_IP_ICMP_H
 #include <netinet/ip_icmp.h>
 #endif
-#if HAVE_NETINET_TCP_H
+#ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
-#if HAVE_NETINET_UDP_H
+#ifdef HAVE_NETINET_UDP_H
 #include <netinet/udp.h>
 #endif
-#if HAVE_NETINET_TCP_TIMER_H
+#ifdef HAVE_NETINET_TCP_TIMER_H
 #include <netinet/tcp_timer.h>
 #endif
-#if HAVE_NETINET_IP6_H
+#ifdef HAVE_NETINET_IP6_H
 #include <netinet/ip6.h>
 #endif
-#if HAVE_NETINET_ICMP6_H
+#ifdef HAVE_NETINET_ICMP6_H
 #include <netinet/icmp6.h>
 #endif
     ]])
@@ -418,28 +418,28 @@ fi
 case $target_os in
     aix*)
         #       for CPU/memory statistics               (AIX)
         #  Agent:
         #
         AC_CHECK_HEADERS(libperfstat.h,
             NETSNMP_SEARCH_LIBS(perfstat_cpu_total, perfstat,
                 AC_DEFINE(HAVE_PERFSTAT, 1, [on aix, if you have perfstat]),
                 AC_MSG_ERROR([
 
 *** To monitor CPU/memory values in AIX you need to install
 *** libperfstat which can be found in bos.perf
 ]),,
                 LMIBLIBS),,
     [[
-#if HAVE_SYS_PROTOSW_H
+#ifdef HAVE_SYS_PROTOSW_H
 #include <sys/protosw.h>
 #endif
     ]])
         ;;
     hpux*)
         #       HP-UX agent needs open_mib       (XXX - not a header check!)
         #
         NETSNMP_SEARCH_LIBS(open_mib, nm,
             AC_DEFINE(HAVE_LIBNM, 1, [define if you have libnm]),,,LMIBLIBS)
         ;;
     *)
         ;;
diff --git a/configure.d/config_os_misc4 b/configure.d/config_os_misc4
index c6b06ad487..5b96c33136 100644
--- a/configure.d/config_os_misc4
+++ b/configure.d/config_os_misc4
@@ -165,24 +165,24 @@ if test $cross_compiling = yes; then
     AC_MSG_WARN([Can't check sysctl, manually define NETSNMP_CAN_USE_SYSCTL if platform support available])
 else
     AC_CACHE_CHECK([if sysctl can read kernel information],
         ac_cv_NETSNMP_CAN_USE_SYSCTL,
        [AC_TRY_RUN([
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
 #include <sys/types.h>
-#if HAVE_SYS_SYSCTL_H
+#ifdef HAVE_SYS_SYSCTL_H
 # include <sys/sysctl.h>
 #endif
 #include <stddef.h>
 #include <stdlib.h>
@@ -242,56 +242,56 @@ fi
 #   Check whether IP Route table is cached              (Solaris)
 #	    used in agent only
 #
 case $target_os in
   solaris*)
     #    Header checks                                  (Solaris 2.6/7)
     #
     AC_CHECK_HEADERS(inet/common.h)
     AC_CHECK_HEADERS(inet/ip.h,ac_inet_ip_h=yes,ac_inet_ip_h=no,
         AC_INCLUDES_DEFAULT([])
         [
 #ifdef HAVE_SYS_STREAM_H
 #include <sys/stream.h>
 #endif
-#if HAVE_INET_COMMON_H
+#ifdef HAVE_INET_COMMON_H
 #include <inet/common.h>
 #endif
         ])
     if test $ac_inet_ip_h = yes ; then
         AC_CACHE_CHECK([for mib2_ipRouteEntry_t in inet/mib2.h],
             ac_cv_mib2_ipRouteEntry_t,
            [AC_TRY_COMPILE([
-#if HAVE_INET_MIB2_H
+#ifdef HAVE_INET_MIB2_H
 #include <inet/mib2.h>
 #endif
                ],[
   mib2_ipRouteEntry_t testit;
   if(sizeof(testit))
     return(0);
                ],
                ac_cv_mib2_ipRouteEntry_t=yes,
                ac_cv_mib2_ipRouteEntry_t=no)])
 
         if test "x$ac_cv_mib2_ipRouteEntry_t" = "xyes" ; then
             AC_CACHE_CHECK([whether IRE_CACHE is defined in inet/ip.h],
                 ac_cv_ire_cache,
                [AC_TRY_COMPILE([
-#if HAVE_INET_IP_H
+#ifdef HAVE_INET_IP_H
 #include <inet/ip.h>
 #endif
                    ],[
   int testit=IRE_CACHE;
   if(testit)
     return(0);
                    ],
                    ac_cv_ire_cache=yes,
                    ac_cv_ire_cache=no)])
         else
             ac_cv_ire_cache=no
         fi
 
         if test "x$ac_cv_ire_cache" = "xyes" ; then
             AC_DEFINE(HAVE_DEFINED_IRE_CACHE,[],
                 [define to 1 if you have IRE_CACHE defined in <inet/ip.h> header file.])
         else
             AC_MSG_WARN([It seems that you have inet/ip.h, but IRE_CACHE is not defined. \
diff --git a/configure.d/config_os_struct_members b/configure.d/config_os_struct_members
index 27b3069e88..b84d3825f1 100644
--- a/configure.d/config_os_struct_members
+++ b/configure.d/config_os_struct_members
@@ -12,28 +12,28 @@
 #       struct arphd
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct arphd.at_next],,,[
     AC_INCLUDES_DEFAULT()
     [
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 #include <net/if.h>
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET_IF_ETHER_H
+#ifdef HAVE_NETINET_IF_ETHER_H
 #include <netinet/if_ether.h>
 #endif
     ]])
 
 #       struct des_ks_struct
 #         ('weak_key' indicates older version of OpenSSL)
 #   Library:
 #
@@ -48,14 +48,14 @@ fi
 #       struct dirent
 #         (see also AC_STRUCT_DIRENT_D_TYPE)
 #   Library:
 #
 AC_CHECK_MEMBERS([struct dirent.d_type],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
     ]])
 
 #       struct ethtool_cmd
 #
@@ -72,68 +72,68 @@ fi
 #       struct ipstat
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct ipstat.ips_cantfrag,
                   struct ipstat.ips_delivered,
                   struct ipstat.ips_fragdropped,
                   struct ipstat.ips_fragmented,
                   struct ipstat.ips_localout,
                   struct ipstat.ips_noproto,
                   struct ipstat.ips_noroute,
                   struct ipstat.ips_odropped,
                   struct ipstat.ips_ofragments,
                   struct ipstat.ips_reassembled],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET_IP_VAR_H
+#ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
     ]])
 #       struct ip6stat
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct ip6stat.ip6s_exthdrtoolong ],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET6_IP6_VAR_H
+#ifdef HAVE_NETINET6_IP6_VAR_H
 #include <netinet6/ip6_var.h>
 #endif
     ]])
 
 #
 #   Not-Used:
 AC_CHECK_MEMBERS([struct ipstat.ips_cantforward,
                   struct ipstat.ips_fragtimeout],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET_IP_VAR_H
+#ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
     ]])
 
 #       struct mbstat
 #   Not-Used:
 #
 AC_CHECK_MEMBERS([struct mbstat.m_clusters,
                   struct mbstat.m_clfree,
                   struct mbstat.m_mbufs],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_MBUF_H
+#ifdef HAVE_SYS_MBUF_H
 #include <sys/mbuf.h>
 #endif
     ]])
 
 #	struct uvmexp
 #
@@ -147,14 +147,14 @@ AC_CHECK_MEMBERS([struct uvmexp.pgswapin],,,[
 #       struct nlist
 #
 AC_CHECK_MEMBERS([struct nlist.n_value,
                   struct nlist64.n_value],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_NLIST_H
+#ifdef HAVE_NLIST_H
 #include <nlist.h>
 #endif
     ]])
 
 #       struct sigaction
 #   Agent:
 #
@@ -212,10 +212,10 @@ AC_CHECK_MEMBERS([struct sockaddr_in6.sin6_scope_id],,,[
 #       struct sockaddr_un
 #   Library:
 #
 AC_CHECK_SIZEOF([sockaddr_un.sun_path],,[
     AC_INCLUDES_DEFAULT
     [
-#if HAVE_SYS_UN_H
+#ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
 struct sockaddr_un sockaddr_un;
@@ -224,57 +224,57 @@ struct sockaddr_un sockaddr_un;
 #       struct statfs
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct statfs.f_favail,
                   struct statfs.f_ffree,
                   struct statfs.f_files,
                   struct statfs.f_flags,
                   struct statfs.f_frsize],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_SYS_STATFS_H
+#ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_MOUNT_H
 #include <sys/mount.h>
 #endif 
 #ifdef HAVE_NBUTIL_H
 #include <nbutil.h>
 #endif 
     ]])
 
 #       struct statvfs
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct statvfs.f_files,
                   struct statvfs.f_frsize,
                   struct statvfs.mnt_dir],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_SYS_STATFS_H
+#ifdef HAVE_SYS_STATFS_H
 #include <sys/statfs.h>
 #endif
-#if HAVE_SYS_STATVFS_H
+#ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
     ]])
 
 #       struct swdevt
 #   Not-Used:
 #
 AC_CHECK_MEMBERS([struct swdevt.sw_nblksenabled],,,[
     AC_INCLUDES_DEFAULT()
     [
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_SYS_CONF_H
+#ifdef HAVE_SYS_CONF_H
 #include <sys/conf.h>
 #endif
     ]])
 
 #       struct tcpstat
 #   Agent:
 #
@@ -301,44 +301,44 @@ AC_CHECK_MEMBERS([struct tcpstat.tcp_rcvmemdrop],,,[
 #       struct tm
 #   Library:
 #
 AC_CHECK_MEMBERS([struct tm.tm_gmtoff, struct tm.tm_isdst],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
     ]])
 
 AC_CHECK_DECLS([daylight,timezone],,,[
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 ])
 
 AC_MSG_CHECKING([whether timezone is a scalar])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 ]], [[
@@ -352,54 +352,54 @@ return &a[timezone] != NULL;
 #       struct timezone
 #   Library:
 #
 AC_CHECK_MEMBERS([struct timezone.tz_dsttime],,,[
     AC_INCLUDES_DEFAULT()
     [
 #ifdef HAVE_SYS_TIMEB_H
 # include <sys/timeb.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # ifdef HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
     ]])
 
 #       struct udpstat
 #   Agent:
 #
 AC_CHECK_MEMBERS([struct udpstat.udps_discard,
                   struct udpstat.udps_fullsock,
                   struct udpstat.udps_noport,
                   struct udpstat.udps_noportbcast,
                   struct udpstat.udps_ipackets,
                   struct udpstat.udps_opackets],,,[
     AC_INCLUDES_DEFAULT()
     [
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_NETINET_IP_VAR_H
+#ifdef HAVE_NETINET_IP_VAR_H
 #include <netinet/ip_var.h>
 #endif
-#if HAVE_NETINET_UDP_H
+#ifdef HAVE_NETINET_UDP_H
 #include <netinet/udp.h>
 #endif
-#if HAVE_NETINET_UDP_VAR_H
+#ifdef HAVE_NETINET_UDP_VAR_H
 #include <netinet/udp_var.h>
 #endif
     ]])
 
 
 
 ##
 #   ifnet-related checks:
 ##
 
 #       Does "struct ifnet" need _KERNEL defined?       (Irix)
 #
@@ -724,11 +724,11 @@ AC_DEFINE_UNQUOTED(RTENTRY,struct ${ac_cv_struct_rtentry},
 AC_MSG_CHECKING([syslog prioritynames])
 AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
-#if HAVE_SYSLOG_H
+#ifdef HAVE_SYSLOG_H
 #define SYSLOG_NAMES
 #include <syslog.h>
 #endif
 ]], [[
   char *test = prioritynames[0].c_name;
   printf("%s\n", test); /* so it's not unused */
 ]])], [
diff --git a/include/net-snmp/library/snmpAAL5PVCDomain.h b/include/net-snmp/library/snmpAAL5PVCDomain.h
index 35802201ce..2ac68d4064 100644
--- a/include/net-snmp/library/snmpAAL5PVCDomain.h
+++ b/include/net-snmp/library/snmpAAL5PVCDomain.h
@@ -6,16 +6,16 @@
 #ifdef __cplusplus
 extern          "C" {
 #endif
 
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
 #ifndef linux
     config_error(AAL5 PVC support unavailable for this platform -Linux only-);
 #endif
 
 #include <atm.h>
 
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/asn1.h>
diff --git a/include/net-snmp/library/snmpDTLSUDPDomain.h b/include/net-snmp/library/snmpDTLSUDPDomain.h
index 3640d935d4..f2e85ec477 100644
--- a/include/net-snmp/library/snmpDTLSUDPDomain.h
+++ b/include/net-snmp/library/snmpDTLSUDPDomain.h
@@ -1,7 +1,7 @@
 #ifndef _SNMPDTLSUDPDOMAIN_H
 #define _SNMPDTLSUDPDOMAIN_H
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
diff --git a/include/net-snmp/library/snmpIPXDomain.h b/include/net-snmp/library/snmpIPXDomain.h
index 67a2a450be..b51e298a29 100644
--- a/include/net-snmp/library/snmpIPXDomain.h
+++ b/include/net-snmp/library/snmpIPXDomain.h
@@ -4,13 +4,13 @@
 #ifdef __cplusplus
 extern          "C" {
 #endif
 
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/asn1.h>
-#if HAVE_NETIPX_IPX_H
+#ifdef HAVE_NETIPX_IPX_H
 #include <netipx/ipx.h>
 #endif
 
 #ifndef linux
     config_error(IPX support unavailable for this platform -Linux only-);
 #endif
diff --git a/include/net-snmp/library/snmpSSHDomain.h b/include/net-snmp/library/snmpSSHDomain.h
index 202c623e13..979d917875 100644
--- a/include/net-snmp/library/snmpSSHDomain.h
+++ b/include/net-snmp/library/snmpSSHDomain.h
@@ -5,11 +5,11 @@ config_require(IPv4Base)
 config_require(SocketBase)
 
 #ifdef NETSNMP_TRANSPORT_SSH_DOMAIN
 
 #include <net-snmp/library/snmp_transport.h>
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef __cplusplus
diff --git a/include/net-snmp/library/snmpTLSTCPDomain.h b/include/net-snmp/library/snmpTLSTCPDomain.h
index 2118b50b00..1dfa6b61b6 100644
--- a/include/net-snmp/library/snmpTLSTCPDomain.h
+++ b/include/net-snmp/library/snmpTLSTCPDomain.h
@@ -1,7 +1,7 @@
 #ifndef _SNMPTLSTCPDOMAIN_H
 #define _SNMPTLSTCPDOMAIN_H
 
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
diff --git a/include/net-snmp/library/snmpUDPsharedDomain.h b/include/net-snmp/library/snmpUDPsharedDomain.h
index 3df9c9a249..8f2e1a3177 100644
--- a/include/net-snmp/library/snmpUDPsharedDomain.h
+++ b/include/net-snmp/library/snmpUDPsharedDomain.h
@@ -1,17 +1,17 @@
 /* UDPshared base transport support functions
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #ifndef SNMPUDPsharedBASE_H
 #define SNMPUDPsharedBASE_H
 
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
diff --git a/include/net-snmp/library/snmpUnixDomain.h b/include/net-snmp/library/snmpUnixDomain.h
index 714e515826..519445e332 100644
--- a/include/net-snmp/library/snmpUnixDomain.h
+++ b/include/net-snmp/library/snmpUnixDomain.h
@@ -1,17 +1,17 @@
 #ifndef _SNMPUNIXDOMAIN_H
 #define _SNMPUNIXDOMAIN_H
 
 #ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
 
 #if defined(cygwin) || defined(mingw32) || defined(mingw32msvc)
     config_error(Unix domain protocol support unavailable for this platform)
 #endif
 
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_SYS_UN_H
+#ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
 
 #include <net-snmp/library/snmp_transport.h>
diff --git a/include/net-snmp/library/snmp_alarm.h b/include/net-snmp/library/snmp_alarm.h
index 0635375696..20cdbadc72 100644
--- a/include/net-snmp/library/snmp_alarm.h
+++ b/include/net-snmp/library/snmp_alarm.h
@@ -1,18 +1,18 @@
 #ifndef SNMP_ALARM_H
 #define SNMP_ALARM_H
 
 /*
  * For 'timeval'
  */
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #ifdef __cplusplus
diff --git a/include/net-snmp/net-snmp-includes.h b/include/net-snmp/net-snmp-includes.h
index 47a682724a..3e759d9121 100644
--- a/include/net-snmp/net-snmp-includes.h
+++ b/include/net-snmp/net-snmp-includes.h
@@ -1,40 +1,40 @@
 #ifndef NET_SNMP_INCLUDES_H
 #define NET_SNMP_INCLUDES_H
 
     /**
      *  Convenience header file to pull in the full
      *     Net-SNMP library API in one go, together with
      *     certain commonly-required system header files.
      */
 
 
 #ifndef NET_SNMP_CONFIG_H
 #error "Please include <net-snmp/net-snmp-config.h> before this file"
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
     /*
      *  The full Net-SNMP API
      */
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp-tc.h>
 #include <net-snmp/library/getopt.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/session_api.h>
 #include <net-snmp/pdu_api.h>
 #include <net-snmp/mib_api.h>
 #include <net-snmp/varbind_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/snmpv3_api.h>
 
 #endif                          /* NET_SNMP_INCLUDES_H */
diff --git a/include/net-snmp/system/dynix.h b/include/net-snmp/system/dynix.h
index c7930cfee1..35be47e845 100644
--- a/include/net-snmp/system/dynix.h
+++ b/include/net-snmp/system/dynix.h
@@ -1,103 +1,103 @@
 /*
  * dynix.h
  * 
  * Date Created: Sat Jan 12 10:50:50 BST 2002
  * Author:       Patrick Hess  <phess@hds.com>
  */
 
 #include <net-snmp/system/generic.h>
 
 /*
  * from s/sysv.h 
  */
 #define SYSV 1
 
 /*
  * to make these changes work... 
  */
 /*
  * maybe I should have used _SEQUENT_ in all this code..  dunno 
  */
 #define dynix dynix
 
 /*
  * Not enough alcohool in bloodstream [fmc] 
  */
 #ifdef NPROC_SYMBOL
 #undef NPROC_SYMBOL
 #endif
 /*
  * there might be a way to get NPROC...  this might work..  might not 
  */
 /*
  * #define NPROC_SYMBOL "procNPROC" 
  */
 #ifdef PROC_SYMBOL
 #undef PROC_SYMBOL
 #endif
 
 /*
  * These definitions date from early BSD-based headers,
  *   and are included in modern NetBSD and OpenBSD distributions.
  * As such, the relevant copyright probably resides with UCB.
  */
 #ifndef TCPTV_MIN
 #define TCPTV_MIN       (1*PR_SLOWHZ)   /* minimum allowable value */
 #endif
 #ifndef TCPTV_REXMTMAX
 #define TCPTV_REXMTMAX  (64*PR_SLOWHZ)  /* max allowable REXMT value */
 #endif
 
 /*
  * some of the system headers wanna include asm code...  let's not 
  */
 #define __NO_ASM_MACRO 1
 
 /*
  * Dynix doesn't seem to set this.  Guess I'll set it here 
  */
 #ifndef L_SET
 #define L_SET   SEEK_SET
 #endif
 
 
 /*
  * configure fails to detect these properly 
  */
 /*
  * lives in libnsl.so 
  */
 #define HAVE_GETHOSTNAME 1
 
 /*
  * outta place...  lives in /usr/include/sys 
  */
 #define  HAVE_NET_IF_DL_H 1
 
 /*
  * got this library...  dunno why configure didn't find it 
  */
 #define HAVE_LIBNSL 1
 
 /*
  * My Dynix box has nearly 400 filesystems and well over 50 disks 
  */
 /*
  * #define MAXDISKS 500  
  */
 
 /*
  * lives in libsocket.so 
  */
 #define HAVE_GETHOSTBYNAME 1
 
 /*
  * Might as well include this here, since a significant
  * number of files seem to need it.  DTS 
  */
-#if HAVE_SYS_SELECT_H
+#ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 
 /* define the extra mib modules that are supported */
 #define NETSNMP_INCLUDE_HOST_RESOURCES
diff --git a/include/net-snmp/utilities.h b/include/net-snmp/utilities.h
index 84569eb794..85a7c71236 100644
--- a/include/net-snmp/utilities.h
+++ b/include/net-snmp/utilities.h
@@ -1,60 +1,60 @@
 #ifndef NET_SNMP_UTILITIES_H
 #define NET_SNMP_UTILITIES_H
 
     /**
      *  Library API routines not specifically concerned with SNMP directly,
      *    but used more generally within the library, agent and other applications.
      *
      *  This also includes "standard" system routines, which are missing on
      *    particular O/S distributiones.
      */
 
 #ifndef NET_SNMP_CONFIG_H
 #error "Please include <net-snmp/net-snmp-config.h> before this file"
 #endif
 
 #include <net-snmp/types.h>
 
     /*
      *  For the initial release, this will just refer to the
      *  relevant UCD header files.
      *    In due course, the routines relevant to this area of the
      *  API will be identified, and listed here directly.
      *
      *  But for the time being, this header file is a placeholder,
      *  to allow application writers to adopt the new header file names.
      */
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_client.h>
-#if HAVE_GETOPT_H
+#ifdef HAVE_GETOPT_H
 #include <getopt.h>
 #else
 #include <net-snmp/library/getopt.h>
 #endif
 
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/asn1.h>      /* for counter64 */
 #include <net-snmp/library/int64.h>
 
 #include <net-snmp/library/mt_support.h>
 /*  #include <net-snmp/library/snmp_locking.h>  */
 #include <net-snmp/library/snmp_alarm.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/data_list.h>
 #include <net-snmp/library/oid_stash.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp-tc.h>
 #include <net-snmp/library/check_varbind.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/container_binary_array.h>
 #include <net-snmp/library/container_list_ssll.h>
 #include <net-snmp/library/container_iterator.h>
 
 #include <net-snmp/library/snmp_assert.h>
 
 #include <net-snmp/version.h>
 
 #endif                          /* NET_SNMP_UTILITIES_H */
diff --git a/snmplib/asn1.c b/snmplib/asn1.c
index e4cc0c8839..1ab0c7f6d1 100644
--- a/snmplib/asn1.c
+++ b/snmplib/asn1.c
@@ -37,202 +37,202 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /**
  * @defgroup asn1_packet_parse asn1 parsing and datatype manipulation routines.
  * @ingroup library
  *
  * @{
  * 
  * Note on 
  * 
  * Re-allocating reverse ASN.1 encoder functions.  Synopsis:
  *
  * \code
  *
  * u_char *buf = (u_char*)malloc(100);
  * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
  * size_t buf_len = 100, offset = 0;
  * long data = 12345;
  * int allow_realloc = 1;
  * 
  * if (asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
  *                            type, &data, sizeof(long)) == 0) {
  *     error;
  * }
  * 
  * \endcode
  *
  * NOTE WELL: after calling one of these functions with allow_realloc
  * non-zero, buf might have moved, buf_len might have grown and
  * offset will have increased by the size of the encoded data.
  * You should **NEVER** do something like this:
  * 
  * \code
  *
  * u_char *buf = (u_char *)malloc(100), *ptr;
  * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
  * size_t buf_len = 100, offset = 0;
  * long data1 = 1234, data2 = 5678;
  * int rc = 0, allow_realloc = 1;
  * 
  * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
  *                                type, &data1, sizeof(long));
  * ptr = buf[buf_len - offset];   / * points at encoding of data1 * /
  * if (rc == 0) {
  *      error;
  * }
  * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
  *                              type, &data2, sizeof(long));
  * make use of ptr here;
  * 
  * \endcode
  * 
  * ptr is **INVALID** at this point.  In general, you should store the
  * offset value and compute pointers when you need them:
  * 
  * 
  * \code
  *
  * u_char *buf = (u_char *)malloc(100), *ptr;
  * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
  * size_t buf_len = 100, offset = 0, ptr_offset;
  * long data1 = 1234, data2 = 5678;
  * int rc = 0, allow_realloc = 1;
  * 
  * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
  *                              type, &data1, sizeof(long));
  * ptr_offset = offset;
  * if (rc == 0) {
  *      error;
  * }
  * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
  *                              type, &data2, sizeof(long));
  * ptr = buf + buf_len - ptr_offset
  * make use of ptr here;
  * 
  * \endcode
  * 
  * 
  * Here, you can see that ptr will be a valid pointer even if the block of
  * memory has been moved, as it may well have been.  Plenty of examples of
  * usage all over asn1.c, snmp_api.c, snmpusm.c.
  * 
  * The other thing you should **NEVER** do is to pass a pointer to a buffer
  * on the stack as the first argument when allow_realloc is non-zero, unless
  * you really know what you are doing and your machine/compiler allows you to
  * free non-heap memory.  There are rumours that such things exist, but many
  * consider them no more than the wild tales of a fool.
  * 
  * Of course, you can pass allow_realloc as zero, to indicate that you do not
  * wish the packet buffer to be reallocated for some reason; perhaps because
  * it is on the stack.  This may be useful to emulate the functionality of
  * the old API:
  *
  * \code 
  * 
  * u_char my_static_buffer[100], *cp = NULL;
  * size_t my_static_buffer_len = 100;
  * float my_pi = (float)22/(float)7;
  * 
  * cp = asn_rbuild_float(my_static_buffer, &my_static_buffer_len,
  *                       ASN_OPAQUE_FLOAT, &my_pi, sizeof(float));
  * if (cp == NULL) {
  * error;
  * }
  * 
  * \endcode
  * 
  * IS EQUIVALENT TO:
  * 
  * \code
  * 
  * u_char my_static_buffer[100];
  * size_t my_static_buffer_len = 100, my_offset = 0;
  * float my_pi = (float)22/(float)7;
  * int rc = 0;
  * 
  * rc = asn_realloc_rbuild_float(&my_static_buffer, &my_static_buffer_len,
  *                               &my_offset, 0,
  *                               ASN_OPAQUE_FLOAT, &my_pi, sizeof(float));
  * if (rc == 0) {
  *   error;
  * }
  * \endcode
  * 
  */
 
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef KINETICS
 #include "gw.h"
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <sys/types.h>
 #include <stdio.h>
 #ifdef HAVE_STDINT_H
 #include <stdint.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef vms
 #include <in.h>
 #endif
 
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/int64.h>
 #include <net-snmp/library/mib.h>
 
 #ifndef NULL
 #define NULL	0
 #endif
 
 #include <net-snmp/library/snmp_api.h>
 
 #ifndef INT32_MAX
 #   define INT32_MAX 2147483647
 #endif
 
 #ifndef INT32_MIN
 #   define INT32_MIN (0 - INT32_MAX - 1)
 #endif
 
 
 #define CHECK_OVERFLOW_S(x,y) do {                                      \
         if (x > INT32_MAX) {                                            \
             DEBUGMSG(("asn","truncating signed value %ld to 32 bits (%d)\n",(long)(x),y)); \
             x &= 0xffffffff;                                            \
         } else if (x < INT32_MIN) {                                     \
             DEBUGMSG(("asn","truncating signed value %ld to 32 bits (%d)\n",(long)(x),y)); \
             x = 0 - (x & 0xffffffff);                                   \
         }                                                               \
     } while(0)
 
 #define CHECK_OVERFLOW_U(x,y) do {                                      \
         if (x > UINT32_MAX) {                                           \
             x &= 0xffffffff;                                            \
             DEBUGMSG(("asn","truncating unsigned value to 32 bits (%d)\n",y)); \
         }                                                               \
     } while(0)
 
 /**
  * @internal
  * output an error for a wrong size
  * 
  * @param str        error string
  * @param wrongsize  wrong size
  * @param rightsize  expected size
  */
diff --git a/snmplib/callback.c b/snmplib/callback.c
index c3dc2c7607..d6df375499 100644
--- a/snmplib/callback.c
+++ b/snmplib/callback.c
@@ -1,51 +1,51 @@
 /*
  * callback.c: A generic callback mechanism 
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup callback A generic callback mechanism 
  *  @ingroup library
  * 
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <sys/types.h>
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #if !defined(mingw32) && defined(HAVE_SYS_TIME_H)
 #include <sys/time.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_api.h>
diff --git a/snmplib/cert_util.c b/snmplib/cert_util.c
index 983bcaadb9..63837a5156 100644
--- a/snmplib/cert_util.c
+++ b/snmplib/cert_util.c
@@ -37,57 +37,57 @@ netsnmp_feature_child_of(cert_fingerprints, cert_util_all);
 netsnmp_feature_child_of(tls_fingerprint_build, cert_util_all);
 
 #endif /* NETSNMP_FEATURE_REQUIRE_CERT_UTIL */
 
 #ifndef NETSNMP_FEATURE_REMOVE_CERT_UTIL
 
 #include <ctype.h>
 
 #include <stddef.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_SYS_STAT_H
+#ifdef HAVE_SYS_STAT_H
 #   include <sys/stat.h>
 #endif
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/data_list.h>
 #include <net-snmp/library/file_utils.h>
 #include <net-snmp/library/dir_utils.h>
 #include <net-snmp/library/read_config.h>
 
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 #include <openssl/x509v3.h>
 #include <net-snmp/library/cert_util.h>
 #include <net-snmp/library/snmp_openssl.h>
 
 #ifndef NAME_MAX
 #define NAME_MAX 255
 #endif
 
 /*
  * bump this value whenever cert index format changes, so indexes
  * will be regenerated with new format.
  */
 #define CERT_INDEX_FORMAT  2
diff --git a/snmplib/container_binary_array.c b/snmplib/container_binary_array.c
index f1542aa16c..289a3bb62c 100644
--- a/snmplib/container_binary_array.c
+++ b/snmplib/container_binary_array.c
@@ -1,42 +1,42 @@
 /*
  * container_binary_array.c
  *
  * see comments in header file.
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/container_binary_array.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 #include "factory.h"
diff --git a/snmplib/container_iterator.c b/snmplib/container_iterator.c
index 6daac2a200..579e2b812b 100644
--- a/snmplib/container_iterator.c
+++ b/snmplib/container_iterator.c
@@ -1,30 +1,30 @@
 /*
  * $Id$
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include <net-snmp/library/container_iterator.h>
diff --git a/snmplib/container_list_ssll.c b/snmplib/container_list_ssll.c
index 3ad9ff6baa..ef3e8e7ed1 100644
--- a/snmplib/container_list_ssll.c
+++ b/snmplib/container_list_ssll.c
@@ -1,31 +1,31 @@
 /*
  * container_list_sl.c
  * $Id$
  *
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include <net-snmp/library/container_list_ssll.h>
 #include "factory.h"
diff --git a/snmplib/container_null.c b/snmplib/container_null.c
index 92e071eff9..18fc743e49 100644
--- a/snmplib/container_null.c
+++ b/snmplib/container_null.c
@@ -1,36 +1,36 @@
 /*
  * container_null.c
  * $Id$
  *
  * see comments in header file.
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/container_null.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 #include "factory.h"
diff --git a/snmplib/default_store.c b/snmplib/default_store.c
index 31d242e98a..2ddf42d8cf 100644
--- a/snmplib/default_store.c
+++ b/snmplib/default_store.c
@@ -1,156 +1,156 @@
 /*
  * default_store.c: storage space for defaults 
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup default_store storage space for defaults 
  *  @ingroup library
  *
        The purpose of the default storage is three-fold:
 
        1)     To create a global storage space without creating a
               whole  bunch  of globally accessible variables or a
               whole bunch of access functions to work  with  more
               privately restricted variables.
 
        2)     To provide a single location where the thread lock-
               ing needs to be implemented. At the  time  of  this
               writing,  however,  thread  locking  is  not yet in
               place.
 
        3)     To reduce the number of cross dependencies  between
               code  pieces that may or may not be linked together
               in the long run. This provides for a  single  loca-
               tion  in which configuration data, for example, can
               be stored for a separate section of code  that  may
               not be linked in to the application in question.
 
        The functions defined here implement these goals.
 
        Currently, three data types are supported: booleans, inte-
        gers, and strings. Each of these data types have  separate
        storage  spaces.  In  addition, the storage space for each
        data type is divided further  by  the  application  level.
        Currently,  there  are  two  storage  spaces. The first is
        reserved for  the  SNMP  library  itself.  The  second  is
        intended  for  use  in applications and is not modified or
        checked by the library, and, therefore, this is the  space
        usable by you.
            
        These definitions correspond with the "storid" argument to the API
        - \#define NETSNMP_DS_LIBRARY_ID     0
        - \#define NETSNMP_DS_APPLICATION_ID 1
        - \#define NETSNMP_DS_TOKEN_ID       2
 
        These definitions correspond with the "which" argument to the API,
        when the storeid argument is NETSNMP_DS_LIBRARY_ID
 
        library booleans
             
        - \#define NETSNMP_DS_LIB_MIB_ERRORS          0
        - \#define NETSNMP_DS_LIB_SAVE_MIB_DESCRS     1
        - \#define NETSNMP_DS_LIB_MIB_COMMENT_TERM    2
        - \#define NETSNMP_DS_LIB_MIB_PARSE_LABEL     3
        - \#define NETSNMP_DS_LIB_DUMP_PACKET         4
        - \#define NETSNMP_DS_LIB_LOG_TIMESTAMP       5
        - \#define NETSNMP_DS_LIB_DONT_READ_CONFIGS   6
        - \#define NETSNMP_DS_LIB_MIB_REPLACE         7 replace objects from latest module 
        - \#define NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM  8 print only numeric enum values
        - \#define NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS  9 print only numeric enum values 
        - \#define NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS 10 dont print oid indexes specially 
        - \#define NETSNMP_DS_LIB_ALARM_DONT_USE_SIG  11 don't use the alarm() signal 
        - \#define NETSNMP_DS_LIB_PRINT_FULL_OID      12 print fully qualified oids 
        - \#define NETSNMP_DS_LIB_QUICK_PRINT         13 print very brief output for parsing
        - \#define NETSNMP_DS_LIB_RANDOM_ACCESS       14 random access to oid labels
        - \#define NETSNMP_DS_LIB_REGEX_ACCESS        15 regex matching to oid labels
        - \#define NETSNMP_DS_LIB_DONT_CHECK_RANGE    16 don't check values for ranges on send
        - \#define NETSNMP_DS_LIB_NO_TOKEN_WARNINGS   17 no warn about unknown config tokens
        - \#define NETSNMP_DS_LIB_NUMERIC_TIMETICKS   18 print timeticks as a number 
        - \#define NETSNMP_DS_LIB_ESCAPE_QUOTES       19 shell escape quote marks in oids
        - \#define NETSNMP_DS_LIB_REVERSE_ENCODE      20 encode packets from back to front
        - \#define NETSNMP_DS_LIB_PRINT_BARE_VALUE    21 just print value (not OID = value)
        - \#define NETSNMP_DS_LIB_EXTENDED_INDEX      22 print extended index format [x1][x2]
        - \#define NETSNMP_DS_LIB_PRINT_HEX_TEXT      23 print ASCII text along with hex strings
        - \#define NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID 24 print OID's using the UCD-style prefix suppression
        - \#define NETSNMP_DS_LIB_READ_UCD_STYLE_OID  25 require top-level OIDs to be prefixed with a dot
        - \#define NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG 26 have the pre-mib parsing config tokens been processed
        - \#define NETSNMP_DS_LIB_HAVE_READ_CONFIG    27 have the config tokens been processed
        - \#define NETSNMP_DS_LIB_QUICKE_PRINT        28
        - \#define NETSNMP_DS_LIB_DONT_PRINT_UNITS    29 don't print UNITS suffix
        - \#define NETSNMP_DS_LIB_NO_DISPLAY_HINT     30 don't apply DISPLAY-HINTs
        - \#define NETSNMP_DS_LIB_16BIT_IDS           31 restrict requestIDs, etc to 16-bit values
        - \#define NETSNMP_DS_LIB_DONT_PERSIST_STATE  32 don't save/load any persistant state
        - \#define NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT   33 print a leading 0 on hex values <= 'f'
 
 
        library integers
 
        - \#define NETSNMP_DS_LIB_MIB_WARNINGS  0
        - \#define NETSNMP_DS_LIB_SECLEVEL      1
        - \#define NETSNMP_DS_LIB_SNMPVERSION   2
        - \#define NETSNMP_DS_LIB_DEFAULT_PORT  3
        - \#define NETSNMP_DS_LIB_OID_OUTPUT_FORMAT  4
        - \#define NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT 5
 
        library strings
 
        - \#define NETSNMP_DS_LIB_SECNAME           0
        - \#define NETSNMP_DS_LIB_CONTEXT           1
        - \#define NETSNMP_DS_LIB_PASSPHRASE        2
        - \#define NETSNMP_DS_LIB_AUTHPASSPHRASE    3
        - \#define NETSNMP_DS_LIB_PRIVPASSPHRASE    4
        - \#define NETSNMP_DS_LIB_OPTIONALCONFIG    5
        - \#define NETSNMP_DS_LIB_APPTYPE           6
        - \#define NETSNMP_DS_LIB_COMMUNITY         7
        - \#define NETSNMP_DS_LIB_PERSISTENT_DIR    8
        - \#define NETSNMP_DS_LIB_CONFIGURATION_DIR 9
        - \#define NETSNMP_DS_LIB_SECMODEL          10
        - \#define NETSNMP_DS_LIB_MIBDIRS           11
        - \#define NETSNMP_DS_LIB_OIDSUFFIX         12
        - \#define NETSNMP_DS_LIB_OIDPREFIX         13
        - \#define NETSNMP_DS_LIB_CLIENT_ADDR       14
        - \#define NETSNMP_DS_LIB_TEMP_FILE_PATTERN 15
        - \#define NETSNMP_DS_LIB_AUTHMASTERKEY     16
        - \#define NETSNMP_DS_LIB_PRIVMASTERKEY     17
        - \#define NETSNMP_DS_LIB_AUTHLOCALIZEDKEY  18
        - \#define NETSNMP_DS_LIB_PRIVLOCALIZEDKEY  19
 
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/library/default_store.h>    /* for "internal" definitions */
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
diff --git a/snmplib/dir_utils.c b/snmplib/dir_utils.c
index 00476ac385..0d67bf2ff3 100644
--- a/snmplib/dir_utils.c
+++ b/snmplib/dir_utils.c
@@ -1,45 +1,45 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #   include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #   include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #   include <string.h>
 #else
 #  include <strings.h>
 #endif
 
 #include <sys/types.h>
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
-#if HAVE_SYS_STAT_H
+#ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 # include <dirent.h>
 #endif
 
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/file_utils.h>
 #include <net-snmp/library/dir_utils.h>
diff --git a/snmplib/file_utils.c b/snmplib/file_utils.c
index 6e769f571d..ccedd228e8 100644
--- a/snmplib/file_utils.c
+++ b/snmplib/file_utils.c
@@ -1,38 +1,38 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #   include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #   include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #   include <string.h>
 #else
 #  include <strings.h>
 #endif
 
 #include <sys/types.h>
 
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #   include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_STAT_H
 #   include <sys/stat.h>
 #endif
 #ifdef HAVE_FCNTL_H
 #   include <fcntl.h>
 #endif
 
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/file_utils.h>
diff --git a/snmplib/gettimeofday.c b/snmplib/gettimeofday.c
index df5c0a04d4..6ae0843244 100644
--- a/snmplib/gettimeofday.c
+++ b/snmplib/gettimeofday.c
@@ -1,22 +1,22 @@
 /*
  * gettimeofday() replacement for MSVC.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/types.h>
 
 #ifdef HAVE_SYS_TIMEB_H
 # include <sys/timeb.h> /* _ftime() */
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/library/system.h>
diff --git a/snmplib/inet_ntop.c b/snmplib/inet_ntop.c
index 947ad53753..5037b2ab59 100644
--- a/snmplib/inet_ntop.c
+++ b/snmplib/inet_ntop.c
@@ -1,63 +1,63 @@
 /*	Id: inet_ntop.c,v 1.4 2001/04/17 07:53:47 lukem Exp 	*/
 /*	$NetBSD: inet_ntop.c,v 1.9 2000/01/22 22:19:16 mycroft Exp $	*/
 
 /* Copyright (c) 1996 by Internet Software Consortium.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef HAVE_ARPA_NAMESER_H
 #include <arpa/nameser.h>
 #endif
 
 #include <errno.h>
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/types.h>
 
 #include "inet_ntop.h"
 
 #ifndef EAFNOSUPPORT
 #define EAFNOSUPPORT            WSAEAFNOSUPPORT
 #endif
 
 #ifndef IN6ADDRSZ
 #define	IN6ADDRSZ	16
 #endif
 
 #ifndef INT16SZ
 #define	INT16SZ		2
 #endif
 
 #ifdef SPRINTF_CHAR
 # define SPRINTF(x) strlen(sprintf/**/x)
 #else
 # define SPRINTF(x) ((size_t)sprintf x)
 #endif
 
 /*
  * WARNING: Don't even consider trying to compile this on a system where
  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
  */
diff --git a/snmplib/inet_pton.c b/snmplib/inet_pton.c
index 60a40020d0..dc4e1e7d3a 100644
--- a/snmplib/inet_pton.c
+++ b/snmplib/inet_pton.c
@@ -1,62 +1,62 @@
 /*	Id: inet_pton.c,v 1.5 2001/04/13 15:24:35 lukem Exp 	*/
 /*	$NetBSD: inet_pton.c,v 1.16 2000/02/07 18:51:02 itojun Exp $	*/
 
 /* Copyright (c) 1996 by Internet Software Consortium.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  * SOFTWARE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <ctype.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef HAVE_ARPA_NAMESER_H
 #include <arpa/nameser.h>
 #endif
 
 #include <errno.h>
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/types.h>
 #include "inet_pton.h"
 
 #ifndef EAFNOSUPPORT
 #define EAFNOSUPPORT            WSAEAFNOSUPPORT
 #endif
 
 #ifndef IN6ADDRSZ
 #define	IN6ADDRSZ	16
 #endif
 
 #ifndef INT16SZ
 #define	INT16SZ		2
 #endif
 
 #ifndef INADDRSZ
 #define	INADDRSZ	4
 #endif
 
 /*
  * WARNING: Don't even consider trying to compile this on a system where
  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
  */
diff --git a/snmplib/int64.c b/snmplib/int64.c
index 964c2a719c..3b1f705e56 100644
--- a/snmplib/int64.c
+++ b/snmplib/int64.c
@@ -1,37 +1,37 @@
 /**
  * @file int64.c
  *
  * @brief Functions for 64-bit integer computations.
  *
  * 21-jan-1998: David Perkins <dperkins@dsperkins.com>
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/int64.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/snmp_logging.h>
 
 #include <net-snmp/net-snmp-features.h>
 
 /**
  * Divide an unsigned 64-bit integer by 10.
  *
  * @param[in]  u64   Number to be divided.
  * @param[out] pu64Q Quotient.
  * @param[out] puR   Remainder.
  */
diff --git a/snmplib/keytools.c b/snmplib/keytools.c
index fdd55fbb5d..b65df0bb3c 100644
--- a/snmplib/keytools.c
+++ b/snmplib/keytools.c
@@ -1,71 +1,71 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  * keytools.c
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <math.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
 #ifdef NETSNMP_USE_OPENSSL
 #	include <openssl/hmac.h>
 #else
 #ifdef NETSNMP_USE_INTERNAL_MD5
 #include <net-snmp/library/md5.h>
 #endif
 #endif
 #ifdef NETSNMP_USE_INTERNAL_CRYPTO
 #include <net-snmp/library/openssl_md5.h>
 #include <net-snmp/library/openssl_sha.h>
 #endif
 
 #ifdef NETSNMP_USE_PKCS11
 #include <security/cryptoki.h>
 #endif
 
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/keytools.h>
 
 #include <net-snmp/library/transform_oids.h>
 
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpusm.h>
@@ -112,239 +112,239 @@ int
 generate_Ku(const oid * hashtype, u_int hashtype_len,
             const u_char * P, size_t pplen, u_char * Ku, size_t * kulen)
 #if defined(NETSNMP_USE_INTERNAL_MD5) || defined(NETSNMP_USE_OPENSSL) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
 {
     int             rval = SNMPERR_SUCCESS,
         nbytes = USM_LENGTH_EXPANDED_PASSPHRASE, auth_type;
 #if !defined(NETSNMP_USE_OPENSSL) && \
     defined(NETSNMP_USE_INTERNAL_MD5) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
     int             ret;
 #endif
 
     u_int           i, pindex = 0;
 
     u_char          buf[USM_LENGTH_KU_HASHBLOCK], *bufp;
 
 #ifdef NETSNMP_USE_OPENSSL
     EVP_MD_CTX     *ctx = NULL;
     const EVP_MD   *hashfn = NULL;
 #elif defined(NETSNMP_USE_INTERNAL_CRYPTO)
     SHA_CTX csha1;
     MD5_CTX cmd5;
     char    cryptotype = 0;
 #define TYPE_MD5  1
 #define TYPE_SHA1 2
 #else
     MDstruct        MD;
 #endif
     /*
      * Sanity check.
      */
     if (!hashtype || !P || !Ku || !kulen || (*kulen <= 0)) {
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     if (pplen < USM_LENGTH_P_MIN) {
         snmp_log(LOG_ERR, "Error: passphrase chosen is below the length "
                  "requirements of the USM (min=%d).\n",USM_LENGTH_P_MIN);
         snmp_set_detail("The supplied password length is too short.");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     auth_type = sc_get_authtype(hashtype, hashtype_len);
     if (SNMPERR_GENERR == auth_type) {
         snmp_log(LOG_ERR, "Error: unknown authtype");
         snmp_set_detail("unknown authtype");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     /*
      * Setup for the transform type.
      */
 #ifdef NETSNMP_USE_OPENSSL
 
     if (*kulen < EVP_MAX_MD_SIZE) {
         snmp_log(LOG_ERR, "Internal Error: ku buffer too small (min=%d).\n",
                  EVP_MAX_MD_SIZE);
         snmp_set_detail("Internal Error: ku buffer too small.");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     /** get hash function */
     hashfn = sc_get_openssl_hashfn(auth_type);
     if (NULL == hashfn) {
         snmp_log(LOG_ERR, "Error: no hashfn for authtype");
         snmp_set_detail("no hashfn for authtype");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
 #if defined(HAVE_EVP_MD_CTX_NEW)
     ctx = EVP_MD_CTX_new();
 #elif defined(HAVE_EVP_MD_CTX_CREATE)
     ctx = EVP_MD_CTX_create();
 #elif defined(HAVE_VOID_EVP_MD_CTX_INIT)
     ctx = malloc(sizeof(*ctx));
     EVP_MD_CTX_init(ctx);
 #else
     ctx = malloc(sizeof(*ctx));
     if (!EVP_MD_CTX_init(ctx)) {
         rval = SNMPERR_GENERR;
         goto generate_Ku_quit;
     }
 #endif
     if (!EVP_DigestInit(ctx, hashfn)) {
         rval = SNMPERR_GENERR;
         goto generate_Ku_quit;
     }
 
 #elif defined(NETSNMP_USE_INTERNAL_CRYPTO)
 #ifndef NETSNMP_DISABLE_MD5
     if (NETSNMP_USMAUTH_HMACMD5 == auth_type) {
         if (!MD5_Init(&cmd5))
             return SNMPERR_GENERR;
         cryptotype = TYPE_MD5;
     } else
 #endif
            if (NETSNMP_USMAUTH_HMACSHA1 == auth_type) {
         if (!SHA1_Init(&csha1))
             return SNMPERR_GENERR;
         cryptotype = TYPE_SHA1;
     } else {
         return (SNMPERR_GENERR);
     }
 #else
     MDbegin(&MD);
 #endif                          /* NETSNMP_USE_OPENSSL */
 
     while (nbytes > 0) {
         bufp = buf;
         for (i = 0; i < USM_LENGTH_KU_HASHBLOCK; i++) {
             *bufp++ = P[pindex++ % pplen];
         }
 #ifdef NETSNMP_USE_OPENSSL
         EVP_DigestUpdate(ctx, buf, USM_LENGTH_KU_HASHBLOCK);
 #elif defined(NETSNMP_USE_INTERNAL_CRYPTO)
         if (TYPE_SHA1 == cryptotype) {
             rval = !SHA1_Update(&csha1, buf, USM_LENGTH_KU_HASHBLOCK);
         } else {
             rval = !MD5_Update(&cmd5, buf, USM_LENGTH_KU_HASHBLOCK);
         }
         if (rval != 0) {
             return SNMPERR_USM_ENCRYPTIONERROR;
         }
-#elif NETSNMP_USE_INTERNAL_MD5
+#elif defined(NETSNMP_USE_INTERNAL_MD5)
         if (MDupdate(&MD, buf, USM_LENGTH_KU_HASHBLOCK * 8)) {
             rval = SNMPERR_USM_ENCRYPTIONERROR;
             goto md5_fin;
         }
 #endif                          /* NETSNMP_USE_OPENSSL */
         nbytes -= USM_LENGTH_KU_HASHBLOCK;
     }
 
 #ifdef NETSNMP_USE_OPENSSL
     {
     unsigned int    tmp_len;
 
     tmp_len = *kulen;
     EVP_DigestFinal(ctx, (unsigned char *) Ku, &tmp_len);
     *kulen = tmp_len;
     /*
      * what about free() 
      */
     }
 #elif defined(NETSNMP_USE_INTERNAL_CRYPTO)
     if (TYPE_SHA1 == cryptotype) {
         SHA1_Final(Ku, &csha1);
     } else {
         MD5_Final(Ku, &cmd5);
     }
     ret = sc_get_properlength(hashtype, hashtype_len);
     if (ret == SNMPERR_GENERR)
         return SNMPERR_GENERR;
     *kulen = ret;
-#elif NETSNMP_USE_INTERNAL_MD5
+#elif defined(NETSNMP_USE_INTERNAL_MD5)
     if (MDupdate(&MD, buf, 0)) {
         rval = SNMPERR_USM_ENCRYPTIONERROR;
         goto md5_fin;
     }
     ret = sc_get_properlength(hashtype, hashtype_len);
     if (ret == SNMPERR_GENERR)
         return SNMPERR_GENERR;
     *kulen = ret;
     MDget(&MD, Ku, *kulen);
   md5_fin:
     memset(&MD, 0, sizeof(MD));
 #endif                          /* NETSNMP_USE_INTERNAL_MD5 */
 
 
 #ifdef NETSNMP_ENABLE_TESTING_CODE
     DEBUGMSGTL(("generate_Ku", "generating Ku (%s from %s): ",
                 usm_lookup_auth_str(auth_type), P));
     for (i = 0; i < *kulen; i++)
         DEBUGMSG(("generate_Ku", "%02x", Ku[i]));
     DEBUGMSG(("generate_Ku", "\n"));
 #endif                          /* NETSNMP_ENABLE_TESTING_CODE */
 
 
   generate_Ku_quit:
     memset(buf, 0, sizeof(buf));
 #ifdef NETSNMP_USE_OPENSSL
     if (ctx) {
 #if defined(HAVE_EVP_MD_CTX_FREE)
         EVP_MD_CTX_free(ctx);
 #elif defined(HAVE_EVP_MD_CTX_DESTROY)
         EVP_MD_CTX_destroy(ctx);
 #else
         EVP_MD_CTX_cleanup(ctx);
         free(ctx);
 #endif
     }
 #endif
     return rval;
 
 }                               /* end generate_Ku() */
-#elif NETSNMP_USE_PKCS11
+#elif defined(NETSNMP_USE_PKCS11)
 {
     int             rval = SNMPERR_SUCCESS, auth_type;;
 
     /*
      * Sanity check.
      */
     if (!hashtype || !P || !Ku || !kulen || (*kulen <= 0)) {
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     if (pplen < USM_LENGTH_P_MIN) {
         snmp_log(LOG_ERR, "Error: passphrase chosen is below the length "
                  "requirements of the USM (min=%d).\n",USM_LENGTH_P_MIN);
         snmp_set_detail("The supplied password length is too short.");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
     auth_type = sc_get_authtype(hashtype, hashtype_len);
     if (SNMPERR_GENERR == auth_type) {
         snmp_log(LOG_ERR, "Error: unknown authtype");
         snmp_set_detail("unknown authtype");
         QUITFUN(SNMPERR_GENERR, generate_Ku_quit);
     }
 
 
     /*
      * Setup for the transform type.
      */
 
 #ifndef NETSNMP_DISABLE_MD5
     if (NETSNMP_USMAUTH_HMACMD5 == auth_type)
         return pkcs_generate_Ku(CKM_MD5, P, pplen, Ku, kulen);
     else
 #endif
         if (NETSNMP_USMAUTH_HMACSHA1 == auth_type)
         return pkcs_generate_Ku(CKM_SHA_1, P, pplen, Ku, kulen);
     else {
         return (SNMPERR_GENERR);
     }
 
   generate_Ku_quit:
 
     return rval;
 }                               /* end generate_Ku() */
 #else
diff --git a/snmplib/lcd_time.c b/snmplib/lcd_time.c
index 39e9c22e68..aeda900c31 100644
--- a/snmplib/lcd_time.c
+++ b/snmplib/lcd_time.c
@@ -1,51 +1,51 @@
 /*
  * lcd_time.c
  *
  * XXX  Should etimelist entries with <0,0> time tuples be timed out?
  * XXX  Need a routine to free the memory?  (Perhaps at shutdown?)
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #include <stdio.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpusm.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/snmpv3.h>
 
 #include <net-snmp/library/transform_oids.h>
diff --git a/snmplib/md5.c b/snmplib/md5.c
index f07733246e..0f3741b29c 100644
--- a/snmplib/md5.c
+++ b/snmplib/md5.c
@@ -1,82 +1,82 @@
 /*
  * ** **************************************************************************
  * ** md5.c -- Implementation of MD5 Message Digest Algorithm                 **
  * ** Updated: 2/16/90 by Ronald L. Rivest                                    **
  * ** (C) 1990 RSA Data Security, Inc.                                        **
  * ** **************************************************************************
  */
 
 /*
  * ** To use MD5:
  * **   -- Include md5.h in your program
  * **   -- Declare an MDstruct MD to hold the state of the digest computation.
  * **   -- Initialize MD using MDbegin(&MD)
  * **   -- For each full block (64 bytes) X you wish to process, call
  * **          MDupdate(&MD,X,512)
  * **      (512 is the number of bits in a full block.)
  * **   -- For the last block (less than 64 bytes) you wish to process,
  * **          MDupdate(&MD,X,n)
  * **      where n is the number of bits in the partial block. A partial
  * **      block terminates the computation, so every MD computation should
  * **      terminate by processing a partial block, even if it has n = 0.
  * **   -- The message digest is available in MD.buffer[0] ... MD.buffer[3].
  * **      (Least-significant byte of each word should be output first.)
  * **   -- You can print out the digest using MDprint(&MD)
  */
 
 /*
  * Compile-time includes 
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifndef NETSNMP_DISABLE_MD5
 
 #include <stdio.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #include <sys/types.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/library/md5.h>
 
 /*
  * Compile-time declarations of MD5 ``magic constants''.
  */
 #define I0  0x67452301          /* Initial values for MD buffer */
 #define I1  0xefcdab89
 #define I2  0x98badcfe
 #define I3  0x10325476
 #define fs1  7                  /* round 1 shift amounts */
 #define fs2 12
 #define fs3 17
 #define fs4 22
 #define gs1  5                  /* round 2 shift amounts */
 #define gs2  9
 #define gs3 14
 #define gs4 20
 #define hs1  4                  /* round 3 shift amounts */
 #define hs2 11
 #define hs3 16
 #define hs4 23
 #define is1  6                  /* round 4 shift amounts */
 #define is2 10
 #define is3 15
 #define is4 21
 
 
 /*
  * Read four bytes starting from address p and interpret these four bytes
  * as a 32-bits little endian integer.
  */
diff --git a/snmplib/mib.c b/snmplib/mib.c
index f646bf6743..8dcec39cc5 100644
--- a/snmplib/mib.c
+++ b/snmplib/mib.c
@@ -33,66 +33,66 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <ctype.h>
 #include <sys/types.h>
 
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/parse.h>
 #include <net-snmp/library/int64.h>
 #include <net-snmp/library/snmp_client.h>
diff --git a/snmplib/parse.c b/snmplib/parse.c
index 7a2ab72b83..64f3d432f0 100644
--- a/snmplib/parse.c
+++ b/snmplib/parse.c
@@ -28,64 +28,64 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifndef NETSNMP_DISABLE_MIB_LOADING
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
-#if HAVE_SYS_STAT_H
+#ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)
 #include <regex.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/parse.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/tools.h>
diff --git a/snmplib/read_config.c b/snmplib/read_config.c
index 332eccdbb3..e2a09bf0ea 100644
--- a/snmplib/read_config.c
+++ b/snmplib/read_config.c
@@ -1,133 +1,133 @@
 /*
  * read_config.c
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /** @defgroup read_config parsing various configuration files at run time
  *  @ingroup library
  *
  * The read_config related functions are a fairly extensible  system  of
  * parsing various configuration files at the run time.
  *
  * The idea is that the calling application is able to register
  * handlers for certain tokens specified in certain types
  * of files.  The read_configs function can then be  called
  * to  look  for all the files that it has registrations for,
  * find the first word on each line, and pass  the  remainder
  * to the appropriately registered handler.
  *
  * For persistent configuration storage you will need to use the
  * read_config_read_data, read_config_store, and read_config_store_data
  * APIs in conjunction with first registering a
  * callback so when the agent shutsdown for whatever reason data is written
  * to your configuration files.  The following explains in more detail the
  * sequence to make this happen.
  *
  * This is the callback registration API, you need to call this API with
  * the appropriate parameters in order to configure persistent storage needs.
  *
  *        int snmp_register_callback(int major, int minor,
  *                                   SNMPCallback *new_callback,
  *                                   void *arg);
  *
  * You will need to set major to SNMP_CALLBACK_LIBRARY, minor to
  * SNMP_CALLBACK_STORE_DATA. arg is whatever you want.
  *
  * Your callback function's prototype is:
  * int     (SNMPCallback) (int majorID, int minorID, void *serverarg,
  *                        void *clientarg);
  *
  * The majorID, minorID and clientarg are what you passed in the callback
  * registration above.  When the callback is called you have to essentially
  * transfer all your state from memory to disk. You do this by generating
  * configuration lines into a buffer.  The lines are of the form token
  * followed by token parameters.
  * 
  * Finally storing is done using read_config_store(type, buffer);
  * type is the application name this can be obtained from:
  *
  * netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);
  *
  * Now, reading back the data: This is done by registering a config handler
  * for your token using the register_config_handler function. Your
  * handler will be invoked and you can parse in the data using the
  * read_config_read APIs.
  *
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #include <errno.h>
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 
-#if HAVE_DIRENT_H
+#ifdef HAVE_DIRENT_H
 #include <dirent.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/library/read_config.h>       /* for "internal" definitions */
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/parse.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/callback.h>
diff --git a/snmplib/scapi.c b/snmplib/scapi.c
index 9fa15b612a..5b220c08c8 100644
--- a/snmplib/scapi.c
+++ b/snmplib/scapi.c
@@ -1,58 +1,58 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  * scapi.c
  *
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include "memcheck.h"
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
@@ -544,38 +544,38 @@ int
 sc_init(void)
 {
     int             rval = SNMPERR_SUCCESS;
 
 #if !defined(NETSNMP_USE_OPENSSL)
 #if defined(NETSNMP_USE_INTERNAL_MD5) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
     struct timeval  tv;
 
     DEBUGTRACE;
 
     gettimeofday(&tv, (struct timezone *) 0);
 
     netsnmp_srandom((unsigned)(tv.tv_sec ^ tv.tv_usec));
-#elif NETSNMP_USE_PKCS11
+#elif defined(NETSNMP_USE_PKCS11)
     DEBUGTRACE;
     rval = pkcs_init();
 #else
     rval = SNMPERR_SC_NOT_CONFIGURED;
 #endif                           /* NETSNMP_USE_INTERNAL_MD5 */
     /*
      * XXX ogud: The only reason to do anything here with openssl is to 
      * * XXX ogud: seed random number generator 
      */
 #endif                          /* ifndef NETSNMP_USE_OPENSSL */
 
     return rval;
 }                               /* end sc_init() */
 
 /*******************************************************************-o-******
  * sc_random
  *
  * Parameters:
  *	*buf		Pre-allocated buffer.
  *	*buflen 	Size of buffer.
  *      
  * Returns:
  *	SNMPERR_SUCCESS			Success.
  */
diff --git a/snmplib/snmp-tc.c b/snmplib/snmp-tc.c
index f919134271..c844c5f616 100644
--- a/snmplib/snmp-tc.c
+++ b/snmplib/snmp-tc.c
@@ -1,35 +1,35 @@
 /*
  *  Host Resources MIB - utility functions - hr_utils.c
  *
  */
 
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <sys/types.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <ctype.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp-tc.h>   /* for "internal" definitions */
 #include <net-snmp/library/snmp_api.h>
@@ -211,65 +211,65 @@ time_t
 ctime_to_timet(const char *str)
 {
     struct tm       tm;
 
     if (strlen(str) < 24)
         return 0;
 
     /*
      * Month 
      */
     if (!strncmp(str + 4, "Jan", 3))
         tm.tm_mon = 0;
     else if (!strncmp(str + 4, "Feb", 3))
         tm.tm_mon = 1;
     else if (!strncmp(str + 4, "Mar", 3))
         tm.tm_mon = 2;
     else if (!strncmp(str + 4, "Apr", 3))
         tm.tm_mon = 3;
     else if (!strncmp(str + 4, "May", 3))
         tm.tm_mon = 4;
     else if (!strncmp(str + 4, "Jun", 3))
         tm.tm_mon = 5;
     else if (!strncmp(str + 4, "Jul", 3))
         tm.tm_mon = 6;
     else if (!strncmp(str + 4, "Aug", 3))
         tm.tm_mon = 7;
     else if (!strncmp(str + 4, "Sep", 3))
         tm.tm_mon = 8;
     else if (!strncmp(str + 4, "Oct", 3))
         tm.tm_mon = 9;
     else if (!strncmp(str + 4, "Nov", 3))
         tm.tm_mon = 10;
     else if (!strncmp(str + 4, "Dec", 3))
         tm.tm_mon = 11;
     else
         return 0;
 
     tm.tm_mday = atoi(str + 8);
     tm.tm_hour = atoi(str + 11);
     tm.tm_min = atoi(str + 14);
     tm.tm_sec = atoi(str + 17);
     tm.tm_year = atoi(str + 20) - 1900;
 
     /*
      *  Cope with timezone and DST
      */
 
 #ifdef HAVE_STRUCT_TM_TM_ISDST
-#if HAVE_DECL_DAYLIGHT
+#if HAVE_DECL_DAYLIGHT==1
     tm.tm_isdst = !!daylight;
 #else
     tm.tm_isdst = 0;
 #endif
 #if HAVE_DECL_TIMEZONE && defined(HAVE_SCALAR_TIMEZONE)
     tm.tm_sec -= timezone;
 #endif
 #endif
 
     return (mktime(&tm));
 }
 #endif /* NETSNMP_FEATURE_REMOVE_CTIME_TO_TIMET */
 
 /*
  * blatantly lifted from opensnmp 
  */
diff --git a/snmplib/snmp_alarm.c b/snmplib/snmp_alarm.c
index 90a745a5fb..51ed2a7a0e 100644
--- a/snmplib/snmp_alarm.c
+++ b/snmplib/snmp_alarm.c
@@ -1,54 +1,54 @@
 /*
  * snmp_alarm.c:
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup snmp_alarm  generic library based alarm timers for various parts of an application 
  *  @ingroup library
  * 
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <signal.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_alarm.h>
diff --git a/snmplib/snmp_api.c b/snmplib/snmp_api.c
index 28018fe9e7..624b9ca016 100644
--- a/snmplib/snmp_api.c
+++ b/snmplib/snmp_api.c
@@ -25,119 +25,119 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /** @defgroup library The Net-SNMP library
  *  @{
  */
 /*
  * snmp_api.c - API for access to snmp.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_NET_IF_DL_H
 #ifndef dynix
 #include <net/if_dl.h>
 #else
 #include <sys/net/if_dl.h>
 #endif
 #endif
 #include <errno.h>
 
-#if HAVE_LOCALE_H
+#ifdef HAVE_LOCALE_H
 #include <locale.h>
 #endif
 
 #define SNMP_NEED_REQUEST_LIST
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/agent/agent_callbacks.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp.h>      /* for xdump & {build,parse}_var_op */
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_client.h>
 #include <net-snmp/library/parse.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/int64.h>
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/large_fd_set.h>
 #ifdef NETSNMP_SECMOD_USM
 #include <net-snmp/library/snmpusm.h>
 #endif
 #ifdef NETSNMP_SECMOD_KSM
 #include <net-snmp/library/snmpksm.h>
 #endif
 #include <net-snmp/library/keytools.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/snmp_alarm.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmp_service.h>
 #include <net-snmp/library/vacm.h>
 #if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
 #include <openssl/ssl.h>
 #include <net-snmp/library/cert_util.h>
 #endif
diff --git a/snmplib/snmp_auth.c b/snmplib/snmp_auth.c
index f4ff2c76f2..af84687b1f 100644
--- a/snmplib/snmp_auth.c
+++ b/snmplib/snmp_auth.c
@@ -25,80 +25,80 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef KINETICS
 #include "gw.h"
 #include "fp4/cmdmacro.h"
 #endif
 
 #include <stdio.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #ifdef vms
 #include <in.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/md5.h>
 #include <net-snmp/library/scapi.h>
 
 /*
  * Globals.
  */
 
 #if !defined(NETSNMP_DISABLE_SNMPV1) || !defined(NETSNMP_DISABLE_SNMPV2C)
 /*******************************************************************-o-******
  * snmp_comstr_parse
  *
  * Parameters:
  *	*data		(I)   Message.
  *	*length		(I/O) Bytes left in message.
  *	*psid		(O)   Community string.
  *	*slen		(O)   Length of community string.
  *	*version	(O)   Message version.
  *      
  * Returns:
  *	Pointer to the remainder of data.
  *
  *
  * Parse the header of a community string-based message such as that found
  * in SNMPv1 and SNMPv2c.
  */
diff --git a/snmplib/snmp_client.c b/snmplib/snmp_client.c
index 59013bf4ef..30efa54213 100644
--- a/snmplib/snmp_client.c
+++ b/snmplib/snmp_client.c
@@ -28,82 +28,82 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /** @defgroup snmp_client various PDU processing routines
  *  @ingroup library
  * 
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <stdio.h>
 #include <errno.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #endif
 
 #include <net-snmp/types.h>
 
 #include <net-snmp/agent/ds_agent.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp-tc.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_client.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpusm.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/snmp_logging.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/large_fd_set.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/pdu_api.h>
diff --git a/snmplib/snmp_debug.c b/snmplib/snmp_debug.c
index 23ecba6be5..b2f5e38906 100644
--- a/snmplib/snmp_debug.c
+++ b/snmplib/snmp_debug.c
@@ -1,57 +1,57 @@
 /*
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #define SYSLOG_NAMES
 
 #include <limits.h>
 #include <stdio.h>
 #ifndef HAVE_PRIORITYNAMES
 #include <errno.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <stdarg.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #ifdef HAVE_PRIORITYNAMES
 #include <sys/syslog.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/library/snmp_debug.h>        /* For this file's "internal" definitions */
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #define SNMP_DEBUG_DISABLED           0
 #define SNMP_DEBUG_ACTIVE             1
 #define SNMP_DEBUG_EXCLUDED           2
 
 #ifndef NETSNMP_NO_DEBUGGING
diff --git a/snmplib/snmp_enum.c b/snmplib/snmp_enum.c
index 9bd0d6f0bd..c7c77ccda1 100644
--- a/snmplib/snmp_enum.c
+++ b/snmplib/snmp_enum.c
@@ -1,29 +1,29 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 /*
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <sys/types.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp_enum.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/system.h>      /* strcasecmp() */
 #include <net-snmp/library/snmp_assert.h>
diff --git a/snmplib/snmp_logging.c b/snmplib/snmp_logging.c
index 8d2e96ed57..78e1e71bd4 100644
--- a/snmplib/snmp_logging.c
+++ b/snmplib/snmp_logging.c
@@ -1,92 +1,92 @@
 /*
  * logging.c - generic logging for snmp-agent
  * * Contributed by Ragnar Kjrstad, ucd@ragnark.vestdata.no 1999-06-26 
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /** @defgroup snmp_logging generic logging for net-snmp 
  *  @ingroup library
  * 
  *  @{
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <stdio.h>
 #ifdef HAVE_MALLOC_H
 #include <malloc.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
 #ifdef HAVE_SYSLOG_H
 #include <syslog.h>
 #ifndef LOG_CONS                /* Interesting Ultrix feature */
 #include <sys/syslog.h>
 #endif
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <stdarg.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/library/snmp_logging.h>      /* For this file's "internal" definitions */
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/callback.h>
 
 #include "snmp_syslog.h"
 
 #ifdef va_copy
 #define NEED_VA_END_AFTER_VA_COPY
 #else
 #ifdef __vacopy
 #define vacopy __vacopy
 #define NEED_VA_END_AFTER_VA_COPY
 #else
 #define va_copy(dest, src) memcpy (&dest, &src, sizeof (va_list))
 #endif
 #endif
 #ifndef HAVE_VSNPRINTF
 #include "snprintf.h"
 #endif
diff --git a/snmplib/snmp_parse_args.c b/snmplib/snmp_parse_args.c
index 868a4cb261..84e4318ea9 100644
--- a/snmplib/snmp_parse_args.c
+++ b/snmplib/snmp_parse_args.c
@@ -1,80 +1,80 @@
 /*
  * snmp_parse_args.c
  */
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright @ 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <errno.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 #include <stdio.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/snmp_parse_args.h>   /* for "internal" definitions */
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_client.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/keytools.h>
 
 #include <net-snmp/version.h>
 #include <net-snmp/library/parse.h>
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/transform_oids.h>
diff --git a/snmplib/snmp_secmod.c b/snmplib/snmp_secmod.c
index 614c31f7ce..1362a68033 100644
--- a/snmplib/snmp_secmod.c
+++ b/snmplib/snmp_secmod.c
@@ -1,40 +1,40 @@
 /*
  * security service wrapper to support pluggable security models 
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_enum.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpv3-security-includes.h>
 
 #include <net-snmp/net-snmp-features.h>
diff --git a/snmplib/snmp_transport.c b/snmplib/snmp_transport.c
index e3a9b6a13c..9110c5247e 100644
--- a/snmplib/snmp_transport.c
+++ b/snmplib/snmp_transport.c
@@ -1,78 +1,78 @@
 /*
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_transport.h>
 
 #include <stdio.h>
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 #include <ctype.h>
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/default_store.h>
 
 #include <net-snmp/library/snmpUDPDomain.h>
 #ifdef NETSNMP_TRANSPORT_TLSBASE_DOMAIN
 #include <net-snmp/library/snmpTLSBaseDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_TLSTCP_DOMAIN
 #include <net-snmp/library/snmpTLSTCPDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_STD_DOMAIN
 #include <net-snmp/library/snmpSTDDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
 #include <net-snmp/library/snmpTCPDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_DTLSUDP_DOMAIN
 #include <net-snmp/library/snmpDTLSUDPDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_SSH_DOMAIN
 #include <net-snmp/library/snmpSSHDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_ALIAS_DOMAIN
 #include <net-snmp/library/snmpAliasDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_IPX_DOMAIN
 #include <net-snmp/library/snmpIPXDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
 #include <net-snmp/library/snmpUnixDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
 #include <net-snmp/library/snmpAAL5PVCDomain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
 #include <net-snmp/library/snmpUDPIPv6Domain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
 #include <net-snmp/library/snmpTCPIPv6Domain.h>
 #endif
 #ifdef NETSNMP_TRANSPORT_UDPSHARED_DOMAIN
 #include <net-snmp/library/snmpUDPsharedDomain.h>
 #endif
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_service.h>
 #include <net-snmp/library/read_config.h>
@@ -1277,46 +1277,46 @@ netsnmp_transport *
 netsnmp_transport_cache_get(int af, int type, int local,
                             const netsnmp_sockaddr_storage *bind_addr,
                             unsigned addr_size)
 {
     trans_cache       *tc;
     netsnmp_transport *t;
 
     DEBUGMSGTL(("transport:cache:get", "%d/%d/%d\n", af, type, local));
 
 #define USE_CACHE 1
 
-#if USE_CACHE
+#ifdef USE_CACHE
     /** check for existing transport */
     tc = _tc_find(af, type, local, bind_addr, addr_size);
     if (tc) {
         DEBUGMSGTL(("transport:cache:get", "using existing transport %p\n",
                     tc->t));
         ++tc->count;
         return tc->t;
     }
 #endif
     /** get transport */
     t = NULL; /* _transport(af, type, 0);*/
     if (NULL == t) {
         snmp_log(LOG_ERR, "could not get new transport for %d/%d/%d\n", af,
                  type, local);
         return NULL;
     }
     DEBUGMSGTL(("transport:cache:get", "new transport %p\n", t));
 
-#if USE_CACHE
+#ifdef USE_CACHE
     /** create transport cache for new transport */
     tc = _tc_add(af, type, local, bind_addr, addr_size, t);
     if (NULL == tc) {
         DEBUGMSGTL(("transport:cache:get", "could not create transport cache entry\n"));
         /*
          * We have a transport, just no cache for it. Let's continue on and
          * hope for the best.
          */
         return t;
     }
     tc->count = 1;
 #endif
 
     return t;
 }
diff --git a/snmplib/snmpksm.c b/snmplib/snmpksm.c
index d30347a9f2..3896ad0347 100644
--- a/snmplib/snmpksm.c
+++ b/snmplib/snmpksm.c
@@ -1,70 +1,70 @@
 /*
  * snmpksm.c
  *
  * This code implements the Kerberos Security Model (KSM) for SNMP.
  *
  * Security number - 2066432
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <sys/types.h>
 #include <stdio.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <errno.h>
 
 
 #ifdef NETSNMP_USE_KERBEROS_HEIMDAL
 #ifndef NETSNMP_USE_KERBEROS_MIT
 #define OLD_HEIMDAL
 #endif 				/* ! NETSNMP_USE_KERBEROS_MIT */
 #else
 #define KRB5_DEPRECATED 1
 #endif 				/* NETSNMP_USE_KERBEROS_HEIMDAL */
 
 #ifdef NETSNMP_USE_KERBEROS_HEIMDAL
 #define oid heimdal_oid_renamed
 #endif				/* NETSNMP_USE_KERBEROS_HEIMDAL */
 #include <krb5.h>
 #ifdef NETSNMP_USE_KERBEROS_HEIMDAL
 #undef oid
 #endif				/* NETSNMP_USE_KERBEROS_HEIMDAL */
 
 #ifdef NETSNMP_USE_KERBEROS_HEIMDAL
 #define CHECKSUM_TYPE(x)	(x)->cksumtype
 #define CHECKSUM_CONTENTS(x)	(x)->checksum.data
 #define CHECKSUM_LENGTH(x)	(x)->checksum.length
 #define TICKET_CLIENT(x)	(x)->client
 #else				/* NETSNMP_USE_KERBEROS_HEIMDAL */
 #define CHECKSUM_TYPE(x)	(x)->checksum_type
 #define CHECKSUM_CONTENTS(x)	(x)->contents
 #define CHECKSUM_LENGTH(x)	(x)->length
 #define TICKET_CLIENT(x)	(x)->enc_part2->client
 #endif				/* NETSNMP_USE_KERBEROS_HEIMDAL */
 
-#if HAVE_ET_COM_ERR_H
+#ifdef HAVE_ET_COM_ERR_H
 #include <et/com_err.h>
-#elif HAVE_COM_ERR_H
+#elif defined(HAVE_COM_ERR_H)
 #include <com_err.h>
 #else
 static const char *error_message(int ret) { return "(?)"; }
diff --git a/snmplib/snmpusm.c b/snmplib/snmpusm.c
index c6d7749259..af9d2f8b85 100644
--- a/snmplib/snmpusm.c
+++ b/snmplib/snmpusm.c
@@ -1,81 +1,81 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /*
  * snmpusm.c
  *
  * Routines to manipulate a information about a "user" as
  * defined by the SNMP-USER-BASED-SM-MIB MIB.
  *
  * All functions usm_set_usmStateReference_*() return 0 on success, -1
  * otherwise.
  *
  * !! Tab stops set to 4 in some parts of this file. !!
  *    (Designated on a per function.)
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #include <stdio.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/keytools.h>
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpusm.h>
 #include <net-snmp/library/transform_oids.h>
 #include <net-snmp/library/snmp_enum.h>
 
 #ifdef HAVE_OPENSSL_DH_H
 #include <openssl/dh.h>
 #endif
diff --git a/snmplib/snmpv3.c b/snmplib/snmpv3.c
index 770ccad892..53486893b4 100644
--- a/snmplib/snmpv3.c
+++ b/snmplib/snmpv3.c
@@ -1,86 +1,86 @@
 /*
  * snmpv3.c
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 #include <errno.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #include <stdio.h>
 #include <sys/types.h>
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_TIMES_H
 #include <sys/times.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #       include <stdlib.h>
 #endif
 
 /*
  * Stuff needed for getHwAddress(...) 
  */
 #ifdef HAVE_SYS_IOCTL_H
 #	include <sys/ioctl.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #	include <net/if.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmpv3.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/keytools.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/snmpusm.h>
 #include <net-snmp/library/transform_oids.h>
 
 #include <net-snmp/net-snmp-features.h>
diff --git a/snmplib/snprintf.c b/snmplib/snprintf.c
index b92fba92e1..82bc658c53 100644
--- a/snmplib/snprintf.c
+++ b/snmplib/snprintf.c
@@ -1,83 +1,83 @@
 /*
  * Copyright Patrick Powell 1995
  * This code is based on code written by Patrick Powell (papowell@astart.com)
  * It may be used for any purpose as long as this notice remains intact
  * on all source code distributions
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /**************************************************************
  * Original:
  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
  * A bombproof version of doprnt (dopr) included.
  * Sigh.  This sort of thing is always nasty do deal with.  Note that
  * the version here does not include floating point...
  *
  * snprintf() is used instead of sprintf() as it does limit checks
  * for string length.  This covers a nasty loophole.
  *
  * The other functions are there to prevent NULL pointers from
  * causing nast effects.
  *
  * More Recently:
  *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
  *  This was ugly.  It is still ugly.  I opted out of floating point
  *  numbers, but the formatter understands just about everything
  *  from the normal C string format, at least as far as I can tell from
  *  the Solaris 2.5 printf(3S) man page.
  *
  *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
  *    Ok, added some minimal floating point support, which means this
  *    probably requires libm on most operating systems.  Don't yet
  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
  *    was pretty badly broken, it just wasn't being exercised in ways
  *    which showed it, so that's been fixed.  Also, formated the code
  *    to mutt conventions, and removed dead code left over from the
  *    original.  Also, there is now a builtin-test, just compile with:
  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
  *    and run snprintf for results.
  * 
  *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
  *    The PGP code was using unsigned hexadecimal formats. 
  *    Unfortunately, unsigned formats simply didn't work.
  *
  *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
  *    The original code assumed that both snprintf() and vsnprintf() were
  *    missing.  Some systems only have snprintf() but not vsnprintf(), so
  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
  *
  *  Andrew Tridgell (tridge@samba.org) Oct 1998
  *    fixed handling of %.0f
  *    added test for HAVE_LONG_DOUBLE
  *
  **************************************************************/
 
 #include <net-snmp/net-snmp-config.h>
 
 #if !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF)
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <ctype.h>
 #include <sys/types.h>
 
 #include <stdarg.h>
 #include "snprintf.h"
 
 # define VA_LOCAL_DECL   va_list ap
 # define VA_START(f)     va_start(ap, f)
 # define VA_SHIFT(v,t)  ;       /* no-op for ANSI */
 # define VA_END          va_end(ap)
 
 #ifdef HAVE_LONG_DOUBLE
 #define LDOUBLE long double
 #else
 #define LDOUBLE double
 #endif
diff --git a/snmplib/strlcat.c b/snmplib/strlcat.c
index 43254107a5..f495c6a040 100644
--- a/snmplib/strlcat.c
+++ b/snmplib/strlcat.c
@@ -1,38 +1,38 @@
 /*	$OpenBSD: strlcat.c,v 1.13 2005/08/08 08:05:37 espie Exp $	*/
 
 /*
  * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifndef HAVE_STRLCAT
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
 
 #include <net-snmp/library/system.h>
 
 /*
  * Appends src to string dst of size siz (unlike strncat, siz is the
  * full size of dst, not space left).  At most siz-1 characters
  * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
  * Returns strlen(src) + MIN(siz, strlen(initial dst)).
  * If retval >= siz, truncation occurred.
  */
diff --git a/snmplib/strlcpy.c b/snmplib/strlcpy.c
index 8b583268d7..dc395b8abb 100644
--- a/snmplib/strlcpy.c
+++ b/snmplib/strlcpy.c
@@ -1,23 +1,23 @@
 /*
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #include <sys/types.h>
 
 #include <net-snmp/library/system.h>
 
 /* 
  * Copies src to the dest buffer. The copy will never overflow the dest buffer
  * and dest will always be null terminated, len is the size of the dest buffer.
  *
  * Returns the length of the src buffer.
  */ 
diff --git a/snmplib/strtol.c b/snmplib/strtol.c
index 4d2c6e83bc..ad9f410376 100644
--- a/snmplib/strtol.c
+++ b/snmplib/strtol.c
@@ -1,46 +1,46 @@
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *        notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *        notice, this list of conditions and the following disclaimer in the
  *        documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *        may be used to endorse or promote products derived from this software
  *        without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.      IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #include <ctype.h>
 #include <errno.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 /*
  * Convert a string to a long integer.
  *
  * Ignores `locale' stuff.  Assumes that the upper and lower case
  * alphabets and digits are each contiguous.
  */
diff --git a/snmplib/strtoul.c b/snmplib/strtoul.c
index ac9be25fbd..d819ba952f 100644
--- a/snmplib/strtoul.c
+++ b/snmplib/strtoul.c
@@ -1,46 +1,46 @@
 /*
  * Copyright (c) 1990, 1993
  *      The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *        notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *        notice, this list of conditions and the following disclaimer in the
  *        documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the University nor the names of its contributors
  *        may be used to endorse or promote products derived from this software
  *        without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.      IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #include <ctype.h>
 #include <errno.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
 /*
  * Convert a string to an unsigned long integer.
  *
  * Ignores `locale' stuff.  Assumes that the upper and lower case
  * alphabets and digits are each contiguous.
  */
diff --git a/snmplib/system.c b/snmplib/system.c
index b45bd1fc2b..9a6a0aec46 100644
--- a/snmplib/system.c
+++ b/snmplib/system.c
@@ -27,177 +27,177 @@ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright (C) 2007 Apple, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 /*
  * System dependent routines go here
  */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <errno.h>
 
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
 #ifdef HAVE_DIRECT_H
 #include <direct.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #include <sys/types.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 
 #ifdef HAVE_SYS_SOCKIO_H
 #include <sys/sockio.h>
 #endif
 
 #ifdef HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
 
 #ifdef HAVE_NLIST_H
 #include <nlist.h>
 #endif
 
-#if HAVE_SYS_FILE_H
+#ifdef HAVE_SYS_FILE_H
 #include <sys/file.h>
 #endif
 
 #ifdef HAVE_KSTAT_H
 #include <kstat.h>
 #endif
 
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 
 #ifdef WIN32
 #include <wchar.h>   /* wcsncmp() */
 #include <winperf.h> /* PERF_DATA_BLOCK */
 #endif
 
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #if defined(hpux10) || defined(hpux11)
 #include <sys/pstat.h>
 #endif
 
 #ifdef HAVE_SYS_UTSNAME_H
 #include <sys/utsname.h>
 #endif
 
 #ifdef HAVE_SYS_SYSTEMCFG_H
 #include <sys/systemcfg.h>
 #endif
 
 #ifdef HAVE_SYS_SYSTEMINFO_H
 #include <sys/systeminfo.h>
 #endif
 
 #ifdef HAVE_CRT_EXTERNS_H
 #include <crt_externs.h>        /* for _NSGetArgv() */
 #endif
 
 #ifdef HAVE_MACH_O_DYLD_H
 #include <mach-o/dyld.h>
 #endif
 
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 #ifdef HAVE_GRP_H
 #include <grp.h>
 #endif
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #ifdef DNSSEC_LOCAL_VALIDATION
 #if 1 /*HAVE_ARPA_NAMESER_H*/
 #include <arpa/nameser.h>
 #endif
 #include <validator/validator.h>
 /* NetSNMP and DNSSEC-Tools both define FREE. We'll not use either here. */
 #undef FREE
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/library/system.h>    /* for "internal" definitions */
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/read_config.h> /* for get_temp_file_pattern() */
 
 #include "inet_ntop.h"
 
 /* NetSNMP and DNSSEC-Tools both define FREE. We'll not use either here. */
 #undef FREE
@@ -771,68 +771,68 @@ netsnmp_validator_context(void)
 int
 netsnmp_gethostbyname_v4(const char* name, in_addr_t *addr_out)
 {
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
     struct addrinfo *addrs = NULL;
     struct addrinfo hint;
     int             err;
 
     memset(&hint, 0, sizeof hint);
     hint.ai_flags = 0;
     hint.ai_family = PF_INET;
     hint.ai_socktype = SOCK_DGRAM;
     hint.ai_protocol = 0;
 
     err = netsnmp_getaddrinfo(name, NULL, &hint, &addrs);
     if (err != 0) {
         return -1;
     }
 
     if (addrs != NULL) {
         memcpy(addr_out,
                &((struct sockaddr_in *) addrs->ai_addr)->sin_addr,
                sizeof(in_addr_t));
         freeaddrinfo(addrs);
     } else {
         DEBUGMSGTL(("get_thisaddr",
                     "Failed to resolve IPv4 hostname\n"));
     }
     return 0;
 
-#elif HAVE_GETHOSTBYNAME
+#elif defined(HAVE_GETHOSTBYNAME)
     struct hostent *hp = NULL;
 
     hp = netsnmp_gethostbyname(name);
     if (hp == NULL) {
         DEBUGMSGTL(("get_thisaddr",
                     "hostname (couldn't resolve)\n"));
         return -1;
     } else if (hp->h_addrtype != AF_INET) {
         DEBUGMSGTL(("get_thisaddr",
                     "hostname (not AF_INET!)\n"));
         return -1;
     } else {
         DEBUGMSGTL(("get_thisaddr",
                     "hostname (resolved okay)\n"));
         memcpy(addr_out, hp->h_addr, sizeof(in_addr_t));
     }
     return 0;
 
-#elif HAVE_GETIPNODEBYNAME
+#elif defined(HAVE_GETIPNODEBYNAME)
     struct hostent *hp = NULL;
     int             err;
 
     hp = getipnodebyname(peername, AF_INET, 0, &err);
     if (hp == NULL) {
         DEBUGMSGTL(("get_thisaddr",
                     "hostname (couldn't resolve = %d)\n", err));
         return -1;
     }
     DEBUGMSGTL(("get_thisaddr",
                 "hostname (resolved okay)\n"));
     memcpy(addr_out, hp->h_addr, sizeof(in_addr_t));
     return 0;
 
 #else /* HAVE_GETIPNODEBYNAME */
     return -1;
 #endif
 }
@@ -841,107 +841,107 @@ int
 netsnmp_getaddrinfo(const char *name, const char *service,
                     const struct addrinfo *hints, struct addrinfo **res)
 {
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
     struct addrinfo *addrs = NULL;
     struct addrinfo hint;
     int             err;
 #ifdef DNSSEC_LOCAL_VALIDATION
     val_status_t    val_status;
 #endif
 
     DEBUGMSGTL(("dns:getaddrinfo", "looking up "));
     if (name)
         DEBUGMSG(("dns:getaddrinfo", "\"%s\"", name));
     else
         DEBUGMSG(("dns:getaddrinfo", "<NULL>"));
 
     if (service)
 	DEBUGMSG(("dns:getaddrinfo", ":\"%s\"", service));
 
     if (hints)
 	DEBUGMSG(("dns:getaddrinfo",
                   " with hints ({.ai_flags = %#x, .ai_family = %s})",
                   hints->ai_flags, hints->ai_family == 0 ? "0" :
                   hints->ai_family == AF_INET ? "AF_INET" :
                   hints->ai_family == AF_INET6 ? "AF_INET6" : "?"));
     else
 	DEBUGMSG(("dns:getaddrinfo", " with no hint"));
 
     DEBUGMSG(("dns:getaddrinfo", "\n"));
 
     if (NULL == hints) {
         memset(&hint, 0, sizeof hint);
         hint.ai_flags = 0;
         hint.ai_family = PF_INET;
         hint.ai_socktype = SOCK_DGRAM;
         hint.ai_protocol = 0;
         hints = &hint;
     } else {
         memcpy(&hint, hints, sizeof hint);
     }
 
 #ifndef DNSSEC_LOCAL_VALIDATION
     err = getaddrinfo(name, NULL, &hint, &addrs);
 #else /* DNSSEC_LOCAL_VALIDATION */
     err = val_getaddrinfo(netsnmp_validator_context(), name, NULL, &hint,
                           &addrs, &val_status);
     DEBUGMSGTL(("dns:sec:val", "err %d, val_status %d / %s; trusted: %d\n",
                 err, val_status, p_val_status(val_status),
                 val_istrusted(val_status)));
     if (! val_istrusted(val_status)) {
         int rc;
         if ((err != 0) && VAL_GETADDRINFO_HAS_STATUS(err)) {
             snmp_log(LOG_WARNING,
                      "WARNING: UNTRUSTED error in DNS resolution for %s!\n",
                      name);
             rc = EAI_FAIL;
         } else {
             snmp_log(LOG_WARNING,
                      "The authenticity of DNS response is not trusted (%s)\n",
                      p_val_status(val_status));
             rc = EAI_NONAME;
         }
         /** continue anyways if DNSSEC_WARN_ONLY is set */
         if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
                                     NETSNMP_DS_LIB_DNSSEC_WARN_ONLY))
             return rc;
     }
 
 
 #endif /* DNSSEC_LOCAL_VALIDATION */
     *res = addrs;
     DEBUGIF("dns:getaddrinfo") {
         if (err == 0 && addrs && addrs->ai_addr) {
             const char *fam = "?";
             char dst[64] = "?";
             uint16_t port = 0;
 
             switch (addrs->ai_addr->sa_family) {
             case AF_INET: {
                 struct sockaddr_in *sin = (struct sockaddr_in *)addrs->ai_addr;
 
                 fam = "AF_INET";
                 inet_ntop(AF_INET, &sin->sin_addr, dst, sizeof(dst));
                 port = ntohs(sin->sin_port);
                 break;
             }
             case AF_INET6: {
                 struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)
                     addrs->ai_addr;
 
                 fam = "AF_INET6";
                 inet_ntop(AF_INET6, &sin6->sin6_addr, dst, sizeof(dst));
                 port = ntohs(sin6->sin6_port);
                 break;
             }
             }
             DEBUGMSGTL(("dns:getaddrinfo", "answer { %s, %s:%hu }\n", fam, dst,
                         port));
         }
     }
     return err;
 #else
     NETSNMP_LOGONCE((LOG_ERR, "getaddrinfo not available"));
     return EAI_FAIL;
 #endif /* getaddrinfo */
 }
@@ -949,72 +949,72 @@ netsnmp_getaddrinfo(const char *name, const char *service,
 struct hostent *
 netsnmp_gethostbyname(const char *name)
 {
-#if HAVE_GETHOSTBYNAME
+#ifdef HAVE_GETHOSTBYNAME
 #ifdef DNSSEC_LOCAL_VALIDATION
     val_status_t val_status;
 #endif
     struct hostent *hp = NULL;
 
     if (NULL == name)
         return NULL;
 
     DEBUGMSGTL(("dns:gethostbyname", "looking up %s\n", name));
 
 #ifdef DNSSEC_LOCAL_VALIDATION
     hp  = val_gethostbyname(netsnmp_validator_context(), name, &val_status);
     DEBUGMSGTL(("dns:sec:val", "val_status %d / %s; trusted: %d\n",
                 val_status, p_val_status(val_status),
                 val_istrusted(val_status)));
     if (!val_istrusted(val_status)) {
         snmp_log(LOG_WARNING,
                  "The authenticity of DNS response is not trusted (%s)\n",
                  p_val_status(val_status));
         /** continue anyways if DNSSEC_WARN_ONLY is set */
         if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
                                     NETSNMP_DS_LIB_DNSSEC_WARN_ONLY))
             hp = NULL;
     }
     else if (val_does_not_exist(val_status) && hp)
         hp = NULL;
 #else
     hp = gethostbyname(name);
 #endif
     if (hp == NULL) {
         DEBUGMSGTL(("dns:gethostbyname",
                     "couldn't resolve %s\n", name));
     } else if (hp->h_addrtype != AF_INET
 #ifdef AF_INET6
                && hp->h_addrtype != AF_INET6
 #endif
         ) {
 #ifdef AF_INET6
         DEBUGMSGTL(("dns:gethostbyname",
                     "warning: response for %s not AF_INET/AF_INET6!\n", name));
 #else
         DEBUGMSGTL(("dns:gethostbyname",
                     "warning: response for %s not AF_INET!\n", name));
 #endif
     } else {
         DEBUGMSGTL(("dns:gethostbyname",
                     "%s resolved okay\n", name));
     }
     return hp;
 #else
     NETSNMP_LOGONCE((LOG_ERR, "gethostbyname not available"));
     return NULL;
 #endif /* HAVE_GETHOSTBYNAME */
 }
 
 /**
  * Look up the host name via DNS.
  *
  * @param[in] addr Pointer to the address to resolve. This argument points e.g.
  *   to a struct in_addr for AF_INET or to a struct in6_addr for AF_INET6.
  * @param[in] len  Length in bytes of *addr.
  * @param[in] type Address family, e.g. AF_INET or AF_INET6.
  *
  * @return Pointer to a hostent structure if address lookup succeeded or NULL
  *   if the lookup failed.
  *
  * @see See also the gethostbyaddr() man page.
  */
diff --git a/snmplib/text_utils.c b/snmplib/text_utils.c
index a326bd3363..da14e693fd 100644
--- a/snmplib/text_utils.c
+++ b/snmplib/text_utils.c
@@ -1,40 +1,40 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 #include <net-snmp/net-snmp-includes.h>
 
 #include <stdio.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #   include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #   include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #   include <string.h>
 #else
 #  include <strings.h>
 #endif
 
 #include <sys/types.h>
 
-#if HAVE_LIMITS_H
+#ifdef HAVE_LIMITS_H
 #   include <limits.h>
 #endif
-#if HAVE_SYS_PARAM_H
+#ifdef HAVE_SYS_PARAM_H
 #   include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_STAT_H
 #   include <sys/stat.h>
 #endif
 #ifdef HAVE_FCNTL_H
 #   include <fcntl.h>
 #endif
 
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/file_utils.h>
 #include <net-snmp/library/text_utils.h>
diff --git a/snmplib/tools.c b/snmplib/tools.c
index cd161b7d31..ca6dc47600 100644
--- a/snmplib/tools.c
+++ b/snmplib/tools.c
@@ -1,78 +1,78 @@
 /*
  * tools.c
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #define NETSNMP_TOOLS_C 1 /* dont re-define malloc wrappers here */
 
 #ifdef HAVE_CRTDBG_H
 /*
  * Define _CRTDBG_MAP_ALLOC such that in debug builds (when _DEBUG has been
  * defined) e.g. malloc() is rerouted to _malloc_dbg().
  */
 #define _CRTDBG_MAP_ALLOC 1
 #include <crtdbg.h>
 #endif
 
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <ctype.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #include <stdio.h>
 #include <sys/types.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_VALGRIND_MEMCHECK_H
 #include <valgrind/memcheck.h>
 #endif
 #if defined(cygwin) || defined(mingw32)
 #include <windows.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/library/tools.h>     /* for "internal" definitions */
 
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/mib.h>
 #include <net-snmp/library/scapi.h>
diff --git a/snmplib/transports/snmpAAL5PVCDomain.c b/snmplib/transports/snmpAAL5PVCDomain.c
index 2e6d101723..4b6c80d70e 100644
--- a/snmplib/transports/snmpAAL5PVCDomain.c
+++ b/snmplib/transports/snmpAAL5PVCDomain.c
@@ -1,32 +1,32 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/library/snmpAAL5PVCDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #include <atm.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/tools.h>
diff --git a/snmplib/transports/snmpAliasDomain.c b/snmplib/transports/snmpAliasDomain.c
index d571d5cf0f..edae6455fc 100644
--- a/snmplib/transports/snmpAliasDomain.c
+++ b/snmplib/transports/snmpAliasDomain.c
@@ -1,26 +1,26 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmpAliasDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/utilities.h>
 #include <net-snmp/config_api.h>
diff --git a/snmplib/transports/snmpCallbackDomain.c b/snmplib/transports/snmpCallbackDomain.c
index e07b95058b..3c673661d4 100644
--- a/snmplib/transports/snmpCallbackDomain.c
+++ b/snmplib/transports/snmpCallbackDomain.c
@@ -1,50 +1,50 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/library/snmpCallbackDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
 #ifdef WIN32
 #include <net-snmp/library/winpipe.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
 #ifdef HAVE_IO_H
 #include <io.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/utilities.h>
 
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/snmp_client.h>
 
 #ifndef NETSNMP_STREAM_QUEUE_LEN
 #define NETSNMP_STREAM_QUEUE_LEN  5
 #endif
 
 #ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
diff --git a/snmplib/transports/snmpDTLSUDPDomain.c b/snmplib/transports/snmpDTLSUDPDomain.c
index 27d92f560d..690ab4238c 100644
--- a/snmplib/transports/snmpDTLSUDPDomain.c
+++ b/snmplib/transports/snmpDTLSUDPDomain.c
@@ -24,68 +24,68 @@ netsnmp_feature_require(cert_util);
 netsnmp_feature_require(sockaddr_size);
 
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpDTLSUDPDomain.h>
 #include <net-snmp/library/snmpUDPIPv6Domain.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_impl.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_SYS_UIO_H
+#ifdef HAVE_SYS_UIO_H
 #include <sys/uio.h>
 #endif
 
 #include "../memcheck.h"
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/callback.h>
 
 #include "openssl/bio.h"
 #include "openssl/ssl.h"
 #include "openssl/err.h"
 #include "openssl/rand.h"
 
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpTLSBaseDomain.h>
 #include <net-snmp/library/snmpUDPDomain.h>
 #include <net-snmp/library/cert_util.h>
 #include <net-snmp/library/snmp_openssl.h>
 
 #ifndef INADDR_NONE
 #define INADDR_NONE	-1
 #endif
 
 #define WE_ARE_SERVER 0
 #define WE_ARE_CLIENT 1
diff --git a/snmplib/transports/snmpIPXDomain.c b/snmplib/transports/snmpIPXDomain.c
index 9421fadc08..e3c035096a 100644
--- a/snmplib/transports/snmpIPXDomain.c
+++ b/snmplib/transports/snmpIPXDomain.c
@@ -1,36 +1,36 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/library/snmpIPXDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/tools.h>
 
 #define SNMP_IPX_DEFAULT_PORT	36879   /*  Specified in RFC 1420.  */
diff --git a/snmplib/transports/snmpIPv4BaseDomain.c b/snmplib/transports/snmpIPv4BaseDomain.c
index f242e3a74e..281a2c20d4 100644
--- a/snmplib/transports/snmpIPv4BaseDomain.c
+++ b/snmplib/transports/snmpIPv4BaseDomain.c
@@ -1,53 +1,53 @@
 /* IPV4 base transport support functions
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpIPv4BaseDomain.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/system.h>
 
 #include "inet_ntop.h"
 
 #ifndef INADDR_NONE
 #define INADDR_NONE     -1
 #endif
 
 /**
  * Convert a "traditional" peername into a sockaddr_in structure which is
  * written to *addr.
  *
  * @return 1 if the conversion was successful, or 0 if it failed.
  */
diff --git a/snmplib/transports/snmpIPv6BaseDomain.c b/snmplib/transports/snmpIPv6BaseDomain.c
index f0eb12ac96..740a38dbd9 100644
--- a/snmplib/transports/snmpIPv6BaseDomain.c
+++ b/snmplib/transports/snmpIPv6BaseDomain.c
@@ -1,74 +1,74 @@
 /* IPV6 base transport support functions
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef NETSNMP_ENABLE_IPV6
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpIPv6BaseDomain.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/snmp_logging.h>
 
 #include "inet_ntop.h"
 #include "inet_pton.h"
 
 
 #if defined(WIN32) && !defined(IF_NAMESIZE)
 #define IF_NAMESIZE 12
 #endif
 
 
 #if defined(HAVE_WINSOCK_H) && !defined(mingw32)
 static const struct in6_addr in6addr_any; /*IN6ADDR_ANY_INIT*/
 #endif
 
 
-#if HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
 static unsigned
 netsnmp_if_nametoindex(const char *ifname)
 {
@@ -189,60 +189,60 @@ int netsnmp_ipv6_ostring_to_sockaddr(struct sockaddr_in6 *sin6, const void *o,
 static int netsnmp_resolve_v6_hostname(struct in6_addr *addr,
                                        const char *hostname)
 {
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
     struct addrinfo hint = { 0 };
     struct addrinfo *addrs;
     int             err;
 
     hint.ai_family = PF_INET6;
     hint.ai_socktype = SOCK_DGRAM;
     err = netsnmp_getaddrinfo(hostname, NULL, &hint, &addrs);
     if (err)
         return 0;
 
     if (addrs) {
         DEBUGMSGTL(("netsnmp_sockaddr_in6", "hostname (resolved okay)\n"));
         *addr = ((struct sockaddr_in6 *)addrs->ai_addr)->sin6_addr;
         freeaddrinfo(addrs);
     } else {
         DEBUGMSGTL(("netsnmp_sockaddr_in6", "Failed to resolve IPv6 hostname\n"));
     }
     return 1;
-#elif HAVE_GETIPNODEBYNAME
+#elif defined(HAVE_GETIPNODEBYNAME)
     struct hostent *hp;
     int             err;
 
     hp = getipnodebyname(hostname, AF_INET6, 0, &err);
     if (hp == NULL) {
         DEBUGMSGTL(("netsnmp_sockaddr_in6",
                     "hostname (couldn't resolve = %d)\n", err));
         return 0;
     }
     DEBUGMSGTL(("netsnmp_sockaddr_in6", "hostname (resolved okay)\n"));
     memcpy(addr, hp->h_addr, hp->h_length);
     return 1;
-#elif HAVE_GETHOSTBYNAME
+#elif defined(HAVE_GETHOSTBYNAME)
     struct hostent *hp;
 
     hp = netsnmp_gethostbyname(hostname);
     if (hp == NULL) {
         DEBUGMSGTL(("netsnmp_sockaddr_in6",
                     "hostname (couldn't resolve)\n"));
         return 0;
     }
     if (hp->h_addrtype != AF_INET6) {
         DEBUGMSGTL(("netsnmp_sockaddr_in6", "hostname (not AF_INET6!)\n"));
         return 0;
     }
     DEBUGMSGTL(("netsnmp_sockaddr_in6", "hostname (resolved okay)\n"));
     memcpy(addr, hp->h_addr, hp->h_length);
     return 1;
 #else                           /*HAVE_GETHOSTBYNAME */
     /*
      * There is no name resolving function available.
      */
     snmp_log(LOG_ERR,
              "no getaddrinfo()/getipnodebyname()/gethostbyname()\n");
     return 0;
 #endif                          /*HAVE_GETHOSTBYNAME */
 }
diff --git a/snmplib/transports/snmpSSHDomain.c b/snmplib/transports/snmpSSHDomain.c
index 68ee66737e..4543d137eb 100644
--- a/snmplib/transports/snmpSSHDomain.c
+++ b/snmplib/transports/snmpSSHDomain.c
@@ -1,61 +1,61 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmpSSHDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <errno.h>
 
 #include <libssh2.h>
 #include <libssh2_sftp.h>
 
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_SYS_UN_H
+#ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <pwd.h>
 
 #ifndef MAXPATHLEN
 #warning no system max path length detected
 #define MAXPATHLEN 2048
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/default_store.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmpIPv4BaseDomain.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/read_config.h>
diff --git a/snmplib/transports/snmpSTDDomain.c b/snmplib/transports/snmpSTDDomain.c
index 7e4e1c4a6f..0822417c2e 100644
--- a/snmplib/transports/snmpSTDDomain.c
+++ b/snmplib/transports/snmpSTDDomain.c
@@ -1,26 +1,26 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/library/snmpSTDDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <signal.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/tools.h>
diff --git a/snmplib/transports/snmpSocketBaseDomain.c b/snmplib/transports/snmpSocketBaseDomain.c
index 02d39e9689..3fa9da994f 100644
--- a/snmplib/transports/snmpSocketBaseDomain.c
+++ b/snmplib/transports/snmpSocketBaseDomain.c
@@ -1,42 +1,42 @@
 /**
  * @file  snmpSocketBaseDomain.c
  *
  * @brief Socket support functions.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/snmp_assert.h>
 
 /* all sockets pretty much close the same way */
diff --git a/snmplib/transports/snmpTCPBaseDomain.c b/snmplib/transports/snmpTCPBaseDomain.c
index 381e025d20..88291cf62b 100644
--- a/snmplib/transports/snmpTCPBaseDomain.c
+++ b/snmplib/transports/snmpTCPBaseDomain.c
@@ -1,43 +1,43 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmpTCPBaseDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 
 #include <net-snmp/library/snmp_transport.h>
 
 /*
  * You can write something into opaque that will subsequently get passed back 
  * to your send function if you like.  For instance, you might want to
  * remember where a PDU came from, so that you can send a reply there...  
  */
diff --git a/snmplib/transports/snmpTCPDomain.c b/snmplib/transports/snmpTCPDomain.c
index bc64ec5692..d4217ba925 100644
--- a/snmplib/transports/snmpTCPDomain.c
+++ b/snmplib/transports/snmpTCPDomain.c
@@ -1,51 +1,51 @@
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpTCPDomain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmpIPv4BaseDomain.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpTCPBaseDomain.h>
 #include <net-snmp/library/tools.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
 
 /*
  * needs to be in sync with the definitions in snmplib/snmpUDPDomain.c
  * and perl/agent/agent.xs
  */
diff --git a/snmplib/transports/snmpTCPIPv6Domain.c b/snmplib/transports/snmpTCPIPv6Domain.c
index 49904a6042..b70636bbe9 100644
--- a/snmplib/transports/snmpTCPIPv6Domain.c
+++ b/snmplib/transports/snmpTCPIPv6Domain.c
@@ -1,54 +1,54 @@
 #include <net-snmp/net-snmp-config.h>
 
 #ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpTCPIPv6Domain.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_FCNTL_H
+#ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpTCPBaseDomain.h>
 #include <net-snmp/library/tools.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
 
 #include "inet_ntop.h"
diff --git a/snmplib/transports/snmpTLSBaseDomain.c b/snmplib/transports/snmpTLSBaseDomain.c
index 5d2485732c..19702ee4b7 100644
--- a/snmplib/transports/snmpTLSBaseDomain.c
+++ b/snmplib/transports/snmpTLSBaseDomain.c
@@ -4,56 +4,56 @@
 
 netsnmp_feature_require(cert_util);
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #include <errno.h>
 #include <ctype.h>
 #include "../memcheck.h"
 
 /* OpenSSL Includes */
 #include <openssl/bio.h>
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 #include <openssl/x509.h>
 #include <openssl/x509_vfy.h>
 #include <openssl/x509v3.h>
 
 #include <net-snmp/config_api.h>
 #include <net-snmp/library/container.h>
 #include <net-snmp/library/cert_util.h>
 #include <net-snmp/library/snmp_openssl.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/snmp_logging.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmp_secmod.h>
 #include <net-snmp/library/read_config.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/snmpTLSBaseDomain.h>
 
 #ifndef X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
 #define X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS 0
 #endif
 
 #define LOGANDDIE(msg) do { snmp_log(LOG_ERR, "%s\n", msg); return 0; } while(0)
diff --git a/snmplib/transports/snmpTLSTCPDomain.c b/snmplib/transports/snmpTLSTCPDomain.c
index f144abcc2c..a9e96bc56c 100644
--- a/snmplib/transports/snmpTLSTCPDomain.c
+++ b/snmplib/transports/snmpTLSTCPDomain.c
@@ -14,65 +14,65 @@
 netsnmp_feature_require(cert_util);
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_SYS_UIO_H
+#ifdef HAVE_SYS_UIO_H
 #include <sys/uio.h>
 #endif
 
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include "../memcheck.h"
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmpIPv4BaseDomain.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpTLSBaseDomain.h>
 #include <net-snmp/library/snmpTLSTCPDomain.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/cert_util.h>
 #include <net-snmp/library/snmp_openssl.h>
 #include <net-snmp/library/callback.h>
 
 #include "openssl/bio.h"
 #include "openssl/ssl.h"
 #include "openssl/err.h"
 
 #ifndef INADDR_NONE
 #define INADDR_NONE	-1
 #endif
 
 #define WE_ARE_SERVER 0
 #define WE_ARE_CLIENT 1
diff --git a/snmplib/transports/snmpUDPBaseDomain.c b/snmplib/transports/snmpUDPBaseDomain.c
index fb90e5166c..5d43a662ab 100644
--- a/snmplib/transports/snmpUDPBaseDomain.c
+++ b/snmplib/transports/snmpUDPBaseDomain.c
@@ -1,61 +1,61 @@
 /* UDP base transport support functions
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmpUDPBaseDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_SYS_UIO_H
 #include <sys/uio.h>
 #endif
 #ifdef WIN32
 #include <mswsock.h>
 #endif
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpUDPDomain.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #ifndef  MSG_DONTWAIT
 #define MSG_DONTWAIT 0
 #endif
diff --git a/snmplib/transports/snmpUDPDomain.c b/snmplib/transports/snmpUDPDomain.c
index c498efbaa8..2724cf2191 100644
--- a/snmplib/transports/snmpUDPDomain.c
+++ b/snmplib/transports/snmpUDPDomain.c
@@ -1,76 +1,76 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpUDPDomain.h>
 #include <net-snmp/library/snmpUDPIPv4BaseDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_SYS_UIO_H
 #include <sys/uio.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/system.h>
 #include <net-snmp/library/tools.h>
 
 #include "inet_ntop.h"
 #include "inet_pton.h"
 
 #ifndef INADDR_NONE
 #define INADDR_NONE	-1
 #endif
 
 #ifndef INET_ADDRSTRLEN
 #define INET_ADDRSTRLEN 16
 #endif
diff --git a/snmplib/transports/snmpUDPIPv4BaseDomain.c b/snmplib/transports/snmpUDPIPv4BaseDomain.c
index f56e0c787c..6a7d81cab5 100644
--- a/snmplib/transports/snmpUDPIPv4BaseDomain.c
+++ b/snmplib/transports/snmpUDPIPv4BaseDomain.c
@@ -1,58 +1,58 @@
 /* IPV4 base transport support functions
  *
  * Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpUDPIPv4BaseDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 #include <net-snmp/library/default_store.h>
 #include <net-snmp/library/snmp_transport.h>
 
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
 
 #if defined(HAVE_IP_PKTINFO) || (defined(HAVE_IP_RECVDSTADDR) && defined(HAVE_IP_SENDSRCADDR))
diff --git a/snmplib/transports/snmpUDPIPv6Domain.c b/snmplib/transports/snmpUDPIPv6Domain.c
index 702771ec07..acae6052bc 100644
--- a/snmplib/transports/snmpUDPIPv6Domain.c
+++ b/snmplib/transports/snmpUDPIPv6Domain.c
@@ -1,71 +1,71 @@
 /*
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 #include <net-snmp/net-snmp-config.h>
 
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpUDPIPv6Domain.h>
 #include <net-snmp/library/system.h>
 
 #include <net-snmp/types.h>
 
 #ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <stddef.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 
-#if HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
+#ifdef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
 #define SS_FAMILY ss_family
-#elif HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY
+#elif defined(HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY)
 #define SS_FAMILY __ss_family
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
 
 #include "inet_ntop.h"
 #include "inet_pton.h"
@@ -588,224 +588,224 @@ void
 netsnmp_udp6_parse_security(const char *token, char *param)
 {
     /** copy_nword does null term, so we need vars of max size + 2. */
     /** (one for null, one to detect param too long */
     char            secName[VACMSTRINGLEN]; /* == VACM_MAX_STRING + 2 */
     size_t          secNameLen;
     char            contextName[VACMSTRINGLEN];
     size_t          contextNameLen;
     char            community[COMMUNITY_MAX_LEN + 2];/* overflow + null char */
     size_t          communityLen;
     char            source[301]; /* !(1)+dns-name(253)+/(1)+mask(45)+\0(1) */
     char            *sourcep;
     struct in6_addr mask;
     int             negate;
 
     /*
      * Get security, source address/netmask and community strings.
      */
 
     param = copy_nword( param, secName, sizeof(secName));
     if (strcmp(secName, "-Cn") == 0) {
         if (!param) {
             config_perror("missing CONTEXT_NAME parameter");
             return;
         }
         param = copy_nword( param, contextName, sizeof(contextName));
         contextNameLen = strlen(contextName);
         if (contextNameLen > VACM_MAX_STRING) {
             config_perror("context name too long");
             return;
         }
         if (!param) {
             config_perror("missing NAME parameter");
             return;
         }
         ++contextNameLen; /* null termination */
         param = copy_nword( param, secName, sizeof(secName));
     } else {
         contextNameLen = 0;
     }
 
     secNameLen = strlen(secName);
     if (secNameLen == 0) {
         config_perror("empty NAME parameter");
         return;
     } else if (secNameLen > VACM_MAX_STRING) {
         config_perror("security name too long");
         return;
     }
     ++secNameLen; /* null termination */
 
     if (!param) {
         config_perror("missing SOURCE parameter");
         return;
     }
     param = copy_nword( param, source, sizeof(source));
     if (source[0] == '\0') {
         config_perror("empty SOURCE parameter");
         return;
     }
     if (strncmp(source, EXAMPLE_NETWORK, strlen(EXAMPLE_NETWORK)) == 0) {
         config_perror("example config NETWORK not properly configured");
         return;
     }
 
     if (!param) {
         config_perror("missing COMMUNITY parameter");
         return;
     }
     param = copy_nword( param, community, sizeof(community));
     if (community[0] == '\0') {
         config_perror("empty COMMUNITY parameter");
         return;
     }
     communityLen = strlen(community);
     if (communityLen > COMMUNITY_MAX_LEN) {
         config_perror("community name too long");
         return;
     }
     ++communityLen; /* null termination */
     if (communityLen == sizeof(EXAMPLE_COMMUNITY) &&
         memcmp(community, EXAMPLE_COMMUNITY, sizeof(EXAMPLE_COMMUNITY)) == 0) {
         config_perror("example config COMMUNITY not properly configured");
         return;
     }
 
     /* Possible mask cases
      * "default" <=> 0::0/0
      * <hostname>[/] <=> <hostname>/128
      * <hostname>/number <=> <hostname>/number
      * <hostname>/<mask> <=> <hostname>/<mask>
      */
     {
         /* Deal with the "default" case first. */
         const int isdefault = strcmp(source, "default") == 0;
 
         if (isdefault) {
             memset(mask.s6_addr, '\0', sizeof(mask.s6_addr));
             negate = 0;
             sourcep = NULL;    /* gcc gets confused about sourcep being used */
         } else {
             char *strmask;
             if (*source == '!') {
                negate = 1;
                sourcep = source + 1;
             } else {
                negate = 0;
                sourcep = source;
             }
 
             /* Split the source/netmask parts */
             strmask = strchr(sourcep, '/');
             if (strmask != NULL)
                 /* Mask given. */
                 *strmask++ = '\0';
 
             /* Try to interpret the mask */
             if (strmask == NULL || *strmask == '\0') {
                 /* No mask was given. Assume /128 */
                 memset(mask.s6_addr, 0xff, sizeof(mask.s6_addr));
             } else {
                 /* Try to interpret mask as a "number of 1 bits". */
                 char* cp;
                 long masklength = strtol(strmask, &cp, 10);
                 if (*cp == '\0') {
                     if (0 <= masklength && masklength <= 128) {
                         const int j = masklength / 8;
                         const int jj = masklength % 8;
 
                         memset(mask.s6_addr, 0xff, j);
                         if (j < 16) {
                             mask.s6_addr[j] = (0xffu << (8 - jj));
                             memset(mask.s6_addr + j + 1, '\0', 15 - j);
                         }
                     } else {
                         config_perror("bad mask length");
                         return;
                     }
                 }
                 /* Try to interpret mask numerically. */
                 else if (inet_pton(AF_INET6, strmask, &mask) != 1) {
                     config_perror("bad mask");
                     return;
                 }
             }
         }
 
         {
             struct sockaddr_in6 pton_addr;
             struct addrinfo hints, *res = NULL;
             memset(&hints, '\0', sizeof(hints));
 
             /* First check if default, otherwise try to parse as a numeric
              * address, if that also fails try to lookup the address */
             if (isdefault) {
                 memset(&pton_addr.sin6_addr.s6_addr, '\0',
                        sizeof(struct in6_addr));
             } else if (inet_pton(AF_INET6, sourcep, &pton_addr.sin6_addr) != 1) {
                 /* Nope, wasn't a numeric IPv6 address. Must be IPv4 or a hostname. */
 
                 /* Try interpreting as dotted quad - IPv4 */
                 struct in_addr network;
                 if (inet_pton(AF_INET, sourcep, &network) > 0){
                     /* Yes, it's IPv4 - so it's already parsed and we can return. */
                     DEBUGMSGTL(("com2sec6", "IPv4 detected for IPv6 parser. Skipping.\n"));
                     return;
                 }
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
                 int             gai_error;
 
                 hints.ai_family = AF_INET6;
                 hints.ai_socktype = SOCK_DGRAM;
                 gai_error = netsnmp_getaddrinfo(sourcep, NULL, &hints, &res);
                 if (gai_error != 0) {
                     config_perror(gai_strerror(gai_error));
                     return;
                 }
 #else
                 config_perror("getaddrinfo() not available");
                 return;
 #endif
             }
             if (res == NULL) {
                 hints.ai_addrlen = sizeof(pton_addr);
                 hints.ai_addr = (struct sockaddr*)&pton_addr;
                 hints.ai_next = NULL;
                 res = &hints;
             }
 
             {
                 struct addrinfo *run;
                 int    failed = 0;
                 com2Sec6Entry *begin = NULL, *end = NULL;
 
                 for (run = res; run && !failed; run = run->ai_next)
                     failed =
                         create_com2Sec6Entry(run, &mask,
                                              secName, secNameLen,
                                              contextName, contextNameLen,
                                              community, communityLen, negate,
                                              &begin, &end);
 
                 if (failed) {
                     /* Free eventually allocated chunks */
                     while (begin) {
                         end = begin;
                         begin = begin->next;
                         free(end);
                     }
                 } else if (com2Sec6ListLast != NULL) {
                     com2Sec6ListLast->next = begin;
                     com2Sec6ListLast = end;
                 } else {
                     com2Sec6List = begin;
                     com2Sec6ListLast = end;
                 }
             }
-#if HAVE_GETADDRINFO
+#ifdef HAVE_GETADDRINFO
             if (res != &hints)
                 freeaddrinfo(res);
 #endif
         }
     }
 }
diff --git a/snmplib/transports/snmpUDPsharedDomain.c b/snmplib/transports/snmpUDPsharedDomain.c
index 5423348cd1..e3776deb01 100644
--- a/snmplib/transports/snmpUDPsharedDomain.c
+++ b/snmplib/transports/snmpUDPsharedDomain.c
@@ -1,48 +1,48 @@
 /* UDPshared transport support functions
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <net-snmp/types.h>
 #include "snmpIPBaseDomain.h"
 #include <net-snmp/library/snmpUDPsharedDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <sys/types.h>
 #include <ctype.h>
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #include <errno.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/snmp_assert.h>
 
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/snmpUDPDomain.h>
 #include <net-snmp/library/snmpUDPIPv4BaseDomain.h>
diff --git a/snmplib/transports/snmpUnixDomain.c b/snmplib/transports/snmpUnixDomain.c
index 6d101c8ff8..8670586fd8 100644
--- a/snmplib/transports/snmpUnixDomain.c
+++ b/snmplib/transports/snmpUnixDomain.c
@@ -1,40 +1,40 @@
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-features.h>
 
 #include <sys/types.h>
 #include <net-snmp/library/snmpUnixDomain.h>
 
 #include <stddef.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <errno.h>
 
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_SYS_SOCKET_H
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp_impl.h>
 #include <net-snmp/library/snmp_transport.h>
 #include <net-snmp/library/snmpSocketBaseDomain.h>
 #include <net-snmp/library/system.h> /* mkdirhier */
 #include <net-snmp/library/tools.h>
 
 #ifndef NETSNMP_NO_SYSTEMD
 #include <net-snmp/library/sd-daemon.h>
 #endif
diff --git a/snmplib/vacm.c b/snmplib/vacm.c
index 63ae0b61f1..48067f0a1c 100644
--- a/snmplib/vacm.c
+++ b/snmplib/vacm.c
@@ -1,64 +1,64 @@
 /* Portions of this file are subject to the following copyright(s).  See
  * the Net-SNMP's COPYING file for more details and other copyrights
  * that may apply:
  */
 /*
  * Portions of this file are copyrighted by:
  * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  *
  * Portions of this file are copyrighted by:
  * Copyright (c) 2016 VMware, Inc. All rights reserved.
  * Use is subject to license terms specified in the COPYING file
  * distributed with the Net-SNMP package.
  */
 
 /*
  * vacm.c
  *
  * SNMPv3 View-based Access Control Model
  */
 
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
 #include <stdio.h>
-#if TIME_WITH_SYS_TIME
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
 # if HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 #include <ctype.h>
 
 #include <net-snmp/types.h>
 #include <net-snmp/output_api.h>
 #include <net-snmp/config_api.h>
 
 #include <net-snmp/library/snmp.h>
 #include <net-snmp/library/snmp-tc.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/system.h> /* strlcpy() */
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/vacm.h>
diff --git a/testing/fulltests/snmpv3/T010scapitest_capp.c b/testing/fulltests/snmpv3/T010scapitest_capp.c
index c48d3633c0..c51186c131 100644
--- a/testing/fulltests/snmpv3/T010scapitest_capp.c
+++ b/testing/fulltests/snmpv3/T010scapitest_capp.c
@@ -1,53 +1,53 @@
 /*
  * scapitest.c
  *
  * HEADER Testing SCAPI API
  *
  * Expected SUCCESSes:  2 + 10 + 1 for all tests.
  *
  * Returns:
  *      Number of FAILUREs.
  *
  *
  * ASSUMES  No key management functions return non-zero success codes.
  *
  * XXX  Split into individual modules?
  * XXX  Error/fringe conditions should be tested.
  *
  *
  * Test of sc_random.                                           SUCCESSes: 2.
  *      REQUIRES a human to spot check for obvious non-randomness...
  *
  * Test of sc_generate_keyed_hash and sc_check_keyed_hash.      SUCCESSes: 10.
  *
  * Test of sc_encrypt and sc_decrypt.                           SUCCESSes: 1.
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #include <sys/types.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/keytools.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/transform_oids.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/snmpusm.h>
 #include <net-snmp/library/getopt.h>
 
 #include <stdlib.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 
 /*
  * Globals, &c...
  */
diff --git a/testing/fulltests/snmpv3/T040keymanagetest_capp.c b/testing/fulltests/snmpv3/T040keymanagetest_capp.c
index 615a31a6ba..e74746787b 100644
--- a/testing/fulltests/snmpv3/T040keymanagetest_capp.c
+++ b/testing/fulltests/snmpv3/T040keymanagetest_capp.c
@@ -1,48 +1,48 @@
 /*
  * keymanagetest.c
  *
  * HEADER Testing key management API functionality
  *
  * Expected SUCCESSes:  2 + 2 + 3 for all tests.
  *
  * Returns:
  *      Number of FAILUREs.
  * 
  *
  * FIX  Or how about passing a usmUser name and looking up the entry as
  *      a means of getting key material?  This means the userList is
  *      available from an application...
  *
  * ASSUMES  No key management functions return non-zero success codes.
  *
  * Test of generate_Ku().                       SUCCESSes: 2
  * Test of generate_kul().                      SUCCESSes: 2
  * Test of {encode,decode}_keychange().         SUCCESSes: 3
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
 #ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/keytools.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/transform_oids.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/getopt.h>
 
 #include <stdlib.h>
diff --git a/testing/fulltests/snmpv3/T050etimetest_capp.c b/testing/fulltests/snmpv3/T050etimetest_capp.c
index bbf872d83c..5499971327 100644
--- a/testing/fulltests/snmpv3/T050etimetest_capp.c
+++ b/testing/fulltests/snmpv3/T050etimetest_capp.c
@@ -1,43 +1,43 @@
 /*
  * etimetest.c
  *
  * HEADER Testing engineID hashing and timing
  *
  * Expected SUCCESSes for all tests:    3
  *
  * Returns:
  *      Number of FAILUREs.
  *
  * Test of hash_engineID().                             SUCCESSes:  0
  * Test of LCD Engine ID and Time List.                 SUCCESSes:  3
  *
  * FIX  Devise a test for {set,get}_enginetime(..., FALSE).
  */
 
 #include <net-snmp/net-snmp-config.h>
 
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 #ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include <net-snmp/library/asn1.h>
 #include <net-snmp/library/snmp_api.h>
 #include <net-snmp/library/scapi.h>
 #include <net-snmp/library/tools.h>
 #include <net-snmp/library/lcd_time.h>
 #include <net-snmp/library/snmp_debug.h>
 #include <net-snmp/library/callback.h>
 #include <net-snmp/library/getopt.h>
diff --git a/testing/fulltests/support/cagentlib_build b/testing/fulltests/support/cagentlib_build
index ccac4f7cb6..2c6c660d65 100755
--- a/testing/fulltests/support/cagentlib_build
+++ b/testing/fulltests/support/cagentlib_build
@@ -6,22 +6,22 @@ rm -f "$2.c"
 cat >>"$2.c" <<EOF
 /* net-snmp standard headers */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include <agentx/protocol.h>
 #include <../agent/mibgroup/agentx/protocol.h>
 
 /* testing specific header */
 #include <net-snmp/library/testing.h>
 
 /* standard headers */
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
diff --git a/testing/fulltests/support/clib_build b/testing/fulltests/support/clib_build
index f4dcd39370..2c3bebb1ff 100755
--- a/testing/fulltests/support/clib_build
+++ b/testing/fulltests/support/clib_build
@@ -13,49 +13,49 @@ rm -f "$2.c"
 cat >>"$2.c" <<EOF
 /* net-snmp standard headers */
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/library/large_fd_set.h>
 #include "snmplib/transports/snmpIPBaseDomain.h"
 #include <utilities/execute.h>
 
 /* testing specific header */
 #include <net-snmp/library/testing.h>
 
 /* standard headers */
 #include <errno.h>
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 #endif
 #include <stdio.h>
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #ifdef HAVE_NETINET_IP6_H
 #include <netinet/ip6.h>
 #endif
 #ifndef HAVE_INET_PTON
 #include "snmplib/inet_pton.h"
 #endif
 #ifndef HAVE_INET_NTOP
 #include "snmplib/inet_ntop.h"
 #endif
 
 #define ABS_SRCDIR "${srcdir}"
diff --git a/win32/mib_module_includes.h b/win32/mib_module_includes.h
index b64cf0588f..646b5807c9 100644
--- a/win32/mib_module_includes.h
+++ b/win32/mib_module_includes.h
@@ -1,180 +1,180 @@
 
 /* This file is automatically generated by configure.  Do not modify by hand. */
 
 /*
  * The defines found in net-snmp/agent/mib_module_config.h
  * are used to include/exclude header files referenced here.
  */
 
 #include "mibgroup/mibII.h"
 #include "mibgroup/ucd_snmp.h"
 #include "mibgroup/snmpv3mibs.h"
 #include "mibgroup/notification.h"
 #include "mibgroup/target.h"
 #include "mibgroup/agent_mibs.h"
 
 #ifdef USING_AGENTX_MODULE
 #include "mibgroup/agentx.h"
 #endif
 
 #include "mibgroup/agent_mibs.h"
 #include "mibgroup/utilities.h"
 
 #ifdef USING_HOST_MODULE
 #include "mibgroup/host.h"
 #endif
 
 #ifdef USING_RMON_MODULE
 #include "mibgroup/Rmon.h"
 #endif
 
 #ifdef USING_DISMAN_EVENT_MODULE
 #include "mibgroup/disman/event.h"
 #endif
 
 #ifdef USING_SMUX_MODULE
 #include "mibgroup/smux.h"
 #endif
 
 #ifndef WIN32
 #include "mibgroup/mibII/ipv6.h"
 #endif
 
 #include "mibgroup/mibII/system_mib.h"
 #include "mibgroup/mibII/sysORTable.h"
 
 #ifdef HAVE_WIN32_PLATFORM_SDK
 #include "mibgroup/mibII/at.h"
 #include "mibgroup/mibII/interfaces.h"
 #include "mibgroup/mibII/tcp.h"
 #include "mibgroup/mibII/icmp.h"
 #include "mibgroup/mibII/ip.h"
 #include "mibgroup/mibII/udp.h"
 #include "mibgroup/mibII/tcpTable.h"
 #include "mibgroup/mibII/ipAddr.h"
 #include "mibgroup/mibII/udpTable.h"
 #include "mibgroup/mibII/var_route.h"
 #endif
 
 #include "mibgroup/mibII/snmp_mib.h"
 #include "mibgroup/mibII/vacm_vars.h"
 #include "mibgroup/mibII/setSerialNo.h"
 
 #ifdef USING_UCD_SNMP_MODULE
 #ifdef USING_UCD_SNMP_DLMOD_MODULE
 #include "mibgroup/ucd-snmp/dlmod.h"
 #endif
 #include "mibgroup/ucd-snmp/memory.h"
 #include "mibgroup/ucd-snmp/vmstat.h"
 #include "mibgroup/ucd-snmp/proc.h"
 #include "mibgroup/ucd-snmp/versioninfo.h"
 #include "mibgroup/ucd-snmp/pass.h"
 #include "mibgroup/ucd-snmp/pass_persist.h"
 #include "mibgroup/ucd-snmp/disk_hw.h"
 #include "mibgroup/ucd-snmp/loadave.h"
 #include "mibgroup/ucd-snmp/extensible.h"
 #include "mibgroup/agent/extend.h"
 #include "mibgroup/ucd-snmp/errormib.h"
 #include "mibgroup/ucd-snmp/file.h"
 #include "mibgroup/ucd-snmp/proxy.h"
 #endif
 
-#if HAVE_REGEX_H
+#ifdef HAVE_REGEX_H
 #include "mibgroup/ucd-snmp/logmatch.h"
 #endif
 
 #include "mibgroup/snmpv3/snmpEngine.h"
 #include "mibgroup/snmpv3/snmpMPDStats.h"
 #include "mibgroup/snmpv3/usmStats.h"
 #include "mibgroup/snmpv3/usmUser.h"
 #include "mibgroup/notification/snmpNotifyTable.h"
 #include "mibgroup/notification/snmpNotifyFilterProfileTable.h"
 #include "mibgroup/snmp-notification-mib/snmpNotifyFilterTable.h"
 #include "mibgroup/snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable.h"
 #include "mibgroup/target/snmpTargetAddrEntry.h"
 #include "mibgroup/target/snmpTargetParamsEntry.h"
 #include "mibgroup/target/target.h"
 #include "mibgroup/target/target_counters.h"
 #include "mibgroup/agent/nsTransactionTable.h"
 #include "mibgroup/agent/nsModuleTable.h"
 #include "mibgroup/agent/nsDebug.h"
 #include "mibgroup/agent/nsCache.h"
 #include "mibgroup/agent/nsLogging.h"
 #include "mibgroup/utilities/iquery.h"
 #include "mibgroup/utilities/override.h"
 
 #ifdef USING_HOST_MODULE
 #include "mibgroup/host/hr_system.h"
 #include "mibgroup/host/hrh_storage.h"
 #include "mibgroup/host/hr_device.h"
 #include "mibgroup/host/hr_other.h"
 #include "mibgroup/host/hr_proc.h"
 #include "mibgroup/host/hr_network.h"
 #include "mibgroup/host/hr_print.h"
 #include "mibgroup/host/hr_disk.h"
 #include "mibgroup/host/hr_partition.h"
 #include "mibgroup/host/hrh_filesys.h"
 #include "mibgroup/host/hrh_swrun.h"
 #include "mibgroup/host/hrh_swinst.h"
 #endif
 
 #ifdef USING_RMON_MODULE
 #include "mibgroup/Rmon/rows.h"
 #include "mibgroup/Rmon/agutil.h"
 #include "mibgroup/Rmon/statistics.h"
 #include "mibgroup/Rmon/alarm.h"
 #include "mibgroup/Rmon/history.h"
 #include "mibgroup/Rmon/event.h"
 #endif
 
 #ifdef USING_DISMAN_EVENT_MODULE
 #include "mibgroup/disman/event/mteEventConf.h"
 #include "mibgroup/disman/event/mteEvent.h"
 #include "mibgroup/disman/event/mteEventNotificationTable.h"
 #include "mibgroup/disman/event/mteEventSetTable.h"
 #include "mibgroup/disman/event/mteEventTable.h"
 #include "mibgroup/disman/event/mteObjectsConf.h"
 #include "mibgroup/disman/event/mteObjects.h"
 #include "mibgroup/disman/event/mteObjectsTable.h"
 #include "mibgroup/disman/event/mteScalars.h"
 #include "mibgroup/disman/event/mteTriggerBooleanTable.h"
 #include "mibgroup/disman/event/mteTriggerConf.h"
 #include "mibgroup/disman/event/mteTriggerDeltaTable.h"
 #include "mibgroup/disman/event/mteTriggerExistenceTable.h"
 #include "mibgroup/disman/event/mteTrigger.h"
 #include "mibgroup/disman/event/mteTriggerTable.h"
 #include "mibgroup/disman/event/mteTriggerThresholdTable.h"
 #endif
 
 #ifdef USING_SMUX_MODULE
 #include "mibgroup/smux/smux.h"
 #endif
 
 #include "mibgroup/mibII/route_write.h"
 #include "mibgroup/util_funcs.h"
 #include "mibgroup/mibII/vacm_context.h"
 #include "mibgroup/mibII/vacm_conf.h"
 #include "mibgroup/utilities/execute.h"
 #include "mibgroup/header_complex.h"
 
 #ifdef USING_AGENTX_MODULE
 #include "mibgroup/agentx/master.h"
 #include "mibgroup/agentx/subagent.h"
 #include "mibgroup/agentx/protocol.h"
 #include "mibgroup/agentx/client.h"
 #include "mibgroup/agentx/master_admin.h"
 #include "mibgroup/agentx/agentx_config.h"
 #endif
 
 #ifdef USING_EXAMPLES_EXAMPLE_MODULE
 #include "mibgroup/examples/example.h"
 #endif
 
 #ifdef USING_EXAMPLES_UCDDEMOPUBLIC_MODULE
 #include "mibgroup/examples/ucdDemoPublic.h"
 #endif
 
 #ifdef USING_WINEXTDLL_MODULE
 #include "mibgroup/winExtDLL.h"
 #endif
 
diff --git a/win32/net-snmp/agent/mib_module_config.h b/win32/net-snmp/agent/mib_module_config.h
index 28f7ba7a79..2f2e97a1ad 100644
--- a/win32/net-snmp/agent/mib_module_config.h
+++ b/win32/net-snmp/agent/mib_module_config.h
@@ -1,370 +1,370 @@
 /* This file is automatically generated by configure.  Do not modify by hand. */
 
 #ifndef MIB_MODULE_CONFIG_H
 #define MIB_MODULE_CONFIG_H
 
 /* Define if compiling with the mibII module files.  */
 #define USING_MIBII_MODULE 1
 
 /* Define if compiling with the ucd_snmp module files.  */
 #define USING_UCD_SNMP_MODULE 1
 
 /* Define if compiling with the snmpv3mibs module files.  */
 #define USING_SNMPV3MIBS_MODULE 1
  
 /* Define if compiling with the notification module files.  */
 #define USING_NOTIFICATION_MODULE 1
  
 /* Define if compiling with the disman/event module files.  */
 #define USING_DISMAN_EVENT_MODULE 1
  
 /* Define if compiling with the notification-log-mib module files. */
 #ifdef HAVE_WIN32_PLATFORM_SDK
 #define USING_NOTIFICATION_LOG_MIB_NOTIFICATION_LOG_MODULE 1
 #endif
 
 /* Define if compiling with the target module files.  */
 #define USING_TARGET_MODULE 1
  
 /* Define if compiling with the examples/ucdDemoPublic module files.  */
 #define USING_EXAMPLES_UCDDEMOPUBLIC_MODULE 1
  
 /* Define if compiling with the examples/example module files.  */
 #define USING_EXAMPLES_EXAMPLE_MODULE 1
  
 /* Define if compiling with the agent_mibs module files.  */
 #define USING_AGENT_MIBS_MODULE 1
  
 /* Define if compiling with the agent_mibs module files.  */
 #define USING_AGENT_MIBS_MODULE 1
  
 /* Define if compiling with the utilities module files.  */
 #define USING_UTILITIES_MODULE 1
 
 /* Define if compiling with the mibII/ipv6 module files.  */
 /* #undef USING_MIBII_IPV6_MODULE */
  
 /* Define if compiling with the mibII/system_mib module files.  */
 #define USING_MIBII_SYSTEM_MIB_MODULE 1
  
 /* Define if compiling with the mibII/sysORTable module files.  */
 #define USING_MIBII_SYSORTABLE_MODULE 1
  
 /* Define if compiling with the mibII/at module files.  */
 #define USING_MIBII_AT_MODULE 1
  
 #if 0
 /* Define if compiling with the mibII/interfaces module files.  */
 #define USING_MIBII_INTERFACES_MODULE 1
 #else
 /* Define if compiling with the if-mib module files.  */
 #define USING_IF_MIB_MODULE 1
 
 /* Define if compiling with the if-mib/ifTable module files.  */
 #define USING_IF_MIB_IFTABLE_MODULE 1
 
 /* Define if compiling with the if-mib/ifXTable module files.  */
 #define USING_IF_MIB_IFXTABLE_MODULE 1
 
 /* Define if compiling with the if-mib/ifTable/ifTable module files.  */
 #define USING_IF_MIB_IFTABLE_IFTABLE_MODULE 1
 
 /* Define if compiling with the if-mib/ifXTable/ifXTable module files.  */
 #define USING_IF_MIB_IFXTABLE_IFXTABLE_MODULE 1
 
 /* Define if compiling with the if-mib/data_access/interface module files.  */
 #define USING_IF_MIB_DATA_ACCESS_INTERFACE_MODULE 1
 
 /* Define if compiling with the if-mib/ifTable/ifTable_interface module files.  */
 #define USING_IF_MIB_IFTABLE_IFTABLE_INTERFACE_MODULE 1
 
 /* Define if compiling with the if-mib/ifTable/ifTable_data_access module files.  */
 #define USING_IF_MIB_IFTABLE_IFTABLE_DATA_ACCESS_MODULE 1
 
 /* Define if compiling with the if-mib/ifXTable/ifXTable_interface module files.  */
 #define USING_IF_MIB_IFXTABLE_IFXTABLE_INTERFACE_MODULE 1
 
 /* Define if compiling with the if-mib/ifXTable/ifXTable_data_access module files.  */
 #define USING_IF_MIB_IFXTABLE_IFXTABLE_DATA_ACCESS_MODULE 1
 
 /* Define if compiling with the if-mib/data_access/interface_iphlpapi module files.  */
 #define USING_IF_MIB_DATA_ACCESS_INTERFACE_IPHLPAPI_MODULE 1
 #endif
  
 /* Define if compiling with the mibII/snmp_mib module files.  */
 #define USING_MIBII_SNMP_MIB_MODULE 1
  
 /* Define if compiling with the mibII/tcp module files.  */
 #define USING_MIBII_TCP_MODULE 1
  
 /* Define if compiling with the mibII/icmp module files.  */
 #define USING_MIBII_ICMP_MODULE 1
  
 /* Define if compiling with the mibII/ip module files.  */
 #define USING_MIBII_IP_MODULE 1
  
 /* Define if compiling with the mibII/udp module files.  */
 #define USING_MIBII_UDP_MODULE 1
  
 /* Define if compiling with the mibII/vacm_vars module files.  */
 #define USING_MIBII_VACM_VARS_MODULE 1
  
 /* Define if compiling with the mibII/setSerialNo module files.  */
 #define USING_MIBII_SETSERIALNO_MODULE 1
 
 
 #ifdef USING_UCD_SNMP_MODULE
 
 /* Define if compiling with the ucd-snmp/memory module files.  */
 #define USING_UCD_SNMP_MEMORY_MODULE 1
  
 /* Define if compiling with the ucd-snmp/vmstat module files.  */
 #define USING_UCD_SNMP_VMSTAT_MODULE 1
  
 /* Define if compiling with the ucd-snmp/proc module files.  */
 #define USING_UCD_SNMP_PROC_MODULE 1
  
 /* Define if compiling with the ucd-snmp/versioninfo module files.  */
 #define USING_UCD_SNMP_VERSIONINFO_MODULE 1
  
 /* Define if compiling with the ucd-snmp/pass module files.  */
 #define USING_UCD_SNMP_PASS_MODULE 1
  
 /* Define if compiling with the ucd-snmp/pass_persist module files.  */
 #define USING_UCD_SNMP_PASS_PERSIST_MODULE 1
  
 /* Define if compiling with the ucd-snmp/disk module files.  */
 #define USING_UCD_SNMP_DISK_MODULE 1
  
 /* Define if compiling with the ucd-snmp/loadave module files.  */
 #define USING_UCD_SNMP_LOADAVE_MODULE 1
  
 /* Define if compiling with the ucd-snmp/extensible module files.  */
 #define USING_UCD_SNMP_EXTENSIBLE_MODULE 1
  
 /* Define if compiling with the agent/extend module files.  */
 #define USING_AGENT_EXTEND_MODULE 1
  
 /* Define if compiling with the ucd-snmp/errormib module files.  */
 #define USING_UCD_SNMP_ERRORMIB_MODULE 1
  
 /* Define if compiling with the ucd-snmp/file module files.  */
 #define USING_UCD_SNMP_FILE_MODULE 1
  
 /* Define if compiling with the ucd-snmp/dlmod module files.  */
 #define USING_UCD_SNMP_DLMOD_MODULE 1
  
 /* Define if compiling with the ucd-snmp/proxy module files.  */
 #define USING_UCD_SNMP_PROXY_MODULE 1
 
 #endif /* USING_UCD_SNMP_MODULE */
 
  
-#if HAVE_REGEX_H
+#ifdef HAVE_REGEX_H
 /* Define if compiling with the ucd-snmp/logmatch module files.  */
 #define USING_UCD_SNMP_LOGMATCH_MODULE 1
 #endif
  
 /* Define if compiling with the snmpv3/snmpEngine module files.  */
 #define USING_SNMPV3_SNMPENGINE_MODULE 1
  
 /* Define if compiling with the snmpv3/snmpMPDStats module files.  */
 #define USING_SNMPV3_SNMPMPDSTATS_MODULE 1
  
 /* Define if compiling with the snmpv3/usmStats module files.  */
 #define USING_SNMPV3_USMSTATS_MODULE 1
  
 /* Define if compiling with the snmpv3/usmUser module files.  */
 #define USING_SNMPV3_USMUSER_MODULE 1
 
 /* Define if compiling with the notification/snmpNotifyTable module files.  */
 #define USING_NOTIFICATION_SNMPNOTIFYTABLE_MODULE 1
  
 /* Define if compiling with the notification/snmpNotifyFilterTable module files.  */
 #define USING_NOTIFICATION_SNMPNOTIFYFILTERTABLE_MODULE 1
  
 /* Define if compiling with the notification/snmpNotifyFilterProfileTable module files.  */
 #define USING_NOTIFICATION_SNMPNOTIFYFILTERPROFILETABLE_MODULE 1
  
 /* Define if compiling with the target/snmpTargetAddrEntry module files.  */
 #define USING_TARGET_SNMPTARGETADDRENTRY_MODULE 1
  
 /* Define if compiling with the target/snmpTargetParamsEntry module files.  */
 #define USING_TARGET_SNMPTARGETPARAMSENTRY_MODULE 1
  
 /* Define if compiling with the target/target module files.  */
 #define USING_TARGET_TARGET_MODULE 1
  
 /* Define if compiling with the target/target_counters module files.  */
 #define USING_TARGET_TARGET_COUNTERS_MODULE 1
  
 /* Define if compiling with the agent/nsTransactionTable module files.  */
 #define USING_AGENT_NSTRANSACTIONTABLE_MODULE 1
  
 /* Define if compiling with the agent/nsModuleTable module files.  */
 #define USING_AGENT_NSMODULETABLE_MODULE 1
  
 /* Define if compiling with the agent/nsDebug module files.  */
 #define USING_AGENT_NSDEBUG_MODULE 1
  
 /* Define if compiling with the agent/nsCache module files.  */
 #define USING_AGENT_NSCACHE_MODULE 1
  
 /* Define if compiling with the agent/nsLogging module files.  */
 #define USING_AGENT_NSLOGGING_MODULE 1
  
 /* Define if compiling with the utilities/override module files.  */
 #define USING_UTILITIES_OVERRIDE_MODULE 1
 
  
 #ifdef USING_HOST_MODULE
 
 /* Define if compiling with the host/hr_system module files.  */
 #define USING_HOST_HR_SYSTEM_MODULE 1
  
 /* Define if compiling with the host/hr_storage module files.  */
 #define USING_HOST_HR_STORAGE_MODULE 1
  
 /* Define if compiling with the host/hr_device module files.  */
 #define USING_HOST_HR_DEVICE_MODULE 1
  
 /* Define if compiling with the host/hr_other module files.  */
 #define USING_HOST_HR_OTHER_MODULE 1
  
 /* Define if compiling with the host/hr_proc module files.  */
 #define USING_HOST_HR_PROC_MODULE 1
  
 /* Define if compiling with the host/hr_network module files.  */
 #define USING_HOST_HR_NETWORK_MODULE 1
  
 /* Define if compiling with the host/hr_print module files.  */
 #define USING_HOST_HR_PRINT_MODULE 1
  
 /* Define if compiling with the host/hr_disk module files.  */
 #define USING_HOST_HR_DISK_MODULE 1
  
 /* Define if compiling with the host/hr_partition module files.  */
 #define USING_HOST_HR_PARTITION_MODULE 1
  
 /* Define if compiling with the host/hr_filesys module files.  */
 #define USING_HOST_HR_FILESYS_MODULE 1
  
 /* Define if compiling with the host/hr_swrun module files.  */
 #define USING_HOST_HR_SWRUN_MODULE 1
  
 /* Define if compiling with the host/hr_swinst module files.  */
 #define USING_HOST_HR_SWINST_MODULE 1
 
 #endif  /* USING_HOST_MODULE */
  
 
 #ifdef USING_RMON_MODULE
 
 /* Define if compiling with the Rmon/rows module files.  */
 #define USING_RMON_ROWS_MODULE 1
  
 /* Define if compiling with the Rmon/agutil module files.  */
 #define USING_RMON_AGUTIL_MODULE 1
  
 /* Define if compiling with the Rmon/statistics module files.  */
 #define USING_RMON_STATISTICS_MODULE 1
  
 /* Define if compiling with the Rmon/alarm module files.  */
 #define USING_RMON_ALARM_MODULE 1
  
 /* Define if compiling with the Rmon/history module files.  */
 #define USING_RMON_HISTORY_MODULE 1
  
 /* Define if compiling with the Rmon/event module files.  */
 #define USING_RMON_EVENT_MODULE 1
  
 #endif /* USING_RMON_MODULE */
 
 
 #ifdef USING_DISMAN_EVENT_MODULE 
  
 /* Define if compiling with the disman/event/mteScalars module files.  */
 #define USING_DISMAN_EVENT_MTESCALARS_MODULE 1
  
 /* Define if compiling with the disman/event/mteTrigger module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGER_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerTable module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGERTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerDeltaTable module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGERDELTATABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerExistenceTable module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGEREXISTENCETABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerBooleanTable module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGERBOOLEANTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerThresholdTable module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGERTHRESHOLDTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteTriggerConf module files.  */
 #define USING_DISMAN_EVENT_MTETRIGGERCONF_MODULE 1
  
 /* Define if compiling with the disman/event/mteEvent module files.  */
 #define USING_DISMAN_EVENT_MTEEVENT_MODULE 1
  
 /* Define if compiling with the disman/event/mteEventTable module files.  */
 #define USING_DISMAN_EVENT_MTEEVENTTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteEventSetTable module files.  */
 #define USING_DISMAN_EVENT_MTEEVENTSETTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteEventNotificationTable module files.  */
 #define USING_DISMAN_EVENT_MTEEVENTNOTIFICATIONTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteEventConf module files.  */
 #define USING_DISMAN_EVENT_MTEEVENTCONF_MODULE 1
  
 /* Define if compiling with the disman/event/mteObjects module files.  */
 #define USING_DISMAN_EVENT_MTEOBJECTS_MODULE 1
  
 /* Define if compiling with the disman/event/mteObjectsTable module files.  */
 #define USING_DISMAN_EVENT_MTEOBJECTSTABLE_MODULE 1
  
 /* Define if compiling with the disman/event/mteObjectsConf module files.  */
 #define USING_DISMAN_EVENT_MTEOBJECTSCONF_MODULE 1
  
 #endif /* USING_DISMAN_EVENT_MODULE */
 
 #ifdef USING_SMUX_MODULE
  
 /* Define if compiling with the smux/smux module files.  */
 #define USING_SMUX_SMUX_MODULE 1
  
 #endif /* USING_SMUX_MODULE */
 
  
 /* Define if compiling with the mibII/var_route module files.  */
 #define USING_MIBII_VAR_ROUTE_MODULE 1
  
 /* Define if compiling with the mibII/route_write module files.  */
 #define USING_MIBII_ROUTE_WRITE_MODULE 1
  
 /* Define if compiling with the util_funcs module files.  */
 #define USING_UTIL_FUNCS_MODULE 1
  
 /* Define if compiling with the mibII/tcpTable module files.  */
 #define USING_MIBII_TCPTABLE_MODULE 1
  
 /* Define if compiling with the mibII/ipAddr module files.  */
 #define USING_MIBII_IPADDR_MODULE 1
  
 /* Define if compiling with the mibII/udpTable module files.  */
 #define USING_MIBII_UDPTABLE_MODULE 1
  
 /* Define if compiling with the mibII/vacm_context module files.  */
 #define USING_MIBII_VACM_CONTEXT_MODULE 1
  
 /* Define if compiling with the header_complex module files.  */
 #define USING_HEADER_COMPLEX_MODULE 1
  
 
 #endif /* MIB_MODULE_CONFIG_H */
  
diff --git a/win32/net-snmp/net-snmp-config.h b/win32/net-snmp/net-snmp-config.h
index 9f8c4f47ce..f792958f3a 100644
--- a/win32/net-snmp/net-snmp-config.h
+++ b/win32/net-snmp/net-snmp-config.h
@@ -1656,240 +1656,240 @@ typedef unsigned int     uintptr_t;
 #ifndef __cplusplus
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable: 4804) // '-' : unsafe use of type 'bool' in operation
 #endif
 enum {
     netsnmp_compile_time_uintptr_t_size_check
         = sizeof(struct netsnmp_compile_time_uintptr_t_size_check_s { int:-!(sizeof(uintptr_t) == sizeof(void*)); })
 };
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 #endif
 
 /* Define if you have the closesocket function.  */
 #define HAVE_CLOSESOCKET 1
 
 /* define to 1 if you do not want to set global snmp_errno */
 #define DONT_SHARE_ERROR_WITH_OTHER_THREADS 1
 
 /* Defining vsnprintf is not necessary for MSVC 2008 or later */
 #if defined(_MSC_VER) && _MSC_VER < 1500
 #define vsnprintf _vsnprintf
 #endif
 #if defined(_MSC_VER) && _MSC_VER < 1900
 #define snprintf  _snprintf
 #endif
 
 #if defined(_MSC_VER) && _MSC_VER < 1600
 #define EADDRINUSE	WSAEADDRINUSE
 #endif
 
 /* Define NETSNMP_USE_DLL when building or using netsnmp.DLL */
 /* #undef NETSNMP_USE_DLL */
 
 #if defined(NETSNMP_DLL) && !defined(NETSNMP_USE_DLL)
 #error NETSNMP_USE_DLL must be defined when building libsnmp as a DLL.
 #endif
 
 /*
  * DLL decoration, if used at all, must be consistent.
  * This is why NETSNMP_IMPORT is really an export decoration
  * when it is encountered in a header file that is included
  * during the compilation of a library source file.
  * NETSNMP_DLL is set by the MSVC libsnmp_dll project
  *  in order to signal that the library sources are being compiled.
  * Not defining NETSNMP_USE_DLL ignores the preceding, and renders
  *  the NETSNMP_IMPORT definitions harmless.
  */
 
 #ifdef NETSNMP_USE_DLL
   #ifdef NETSNMP_DLL
     #if defined(_MSC_VER)
       #define NETSNMP_IMPORT extern __declspec(dllexport)
     #endif
   #else
     #if defined(_MSC_VER)
       #define NETSNMP_IMPORT extern __declspec(dllimport)
     #endif
   #endif   /* NETSNMP_DLL */
 #endif     /* NETSNMP_USE_DLL */
 
 /* MSVC OpenSSL linker settings. */
 #if defined(_MSC_VER)
 #  if defined(NETSNMP_USE_OPENSSL)
 #    ifdef _DLL
 #      ifdef _DEBUG
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MDd.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MDd.lib")
 #            pragma comment(lib, "libssl64MDd.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MDd.lib")
 #            pragma comment(lib, "libssl32MDd.lib")
 #          endif
 #        endif
 #      else
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MD.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MD.lib")
 #            pragma comment(lib, "libssl64MD.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MD.lib")
 #            pragma comment(lib, "libssl32MD.lib")
 #          endif
 #        endif
 #      endif
 #    else
 #      ifdef _DEBUG
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MTd.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MTd.lib")
 #            pragma comment(lib, "libssl64MTd.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MTd.lib")
 #            pragma comment(lib, "libssl32MTd.lib")
 #          endif
 #        endif
 #      else
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MT.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MT.lib")
 #            pragma comment(lib, "libssl64MT.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MT.lib")
 #            pragma comment(lib, "libssl32MT.lib")
 #          endif
 #        endif
 #      endif
 #    endif
 #    pragma comment(lib, "gdi32.lib")
 #    pragma comment(lib, "user32.lib")
 #  endif
 #endif
 
 #endif       /* WIN32 */
 
 #ifndef NETSNMP_IMPORT
 #  define NETSNMP_IMPORT extern
 #endif
 
 #if defined(HAVE_NLIST) && defined(HAVE_STRUCT_NLIST_N_VALUE) && !defined(DONT_USE_NLIST) && !defined(NETSNMP_NO_KMEM_USAGE)
 #define NETSNMP_CAN_USE_NLIST
 #endif
 
-#if HAVE_DMALLOC_H
+#ifdef HAVE_DMALLOC_H
 #define DMALLOC_FUNC_CHECK
 #endif
 
 #define NETSNMP_NO_SYSTEMD
 
 /* #undef NETSNMP_ENABLE_LOCAL_SMUX */
 
 /* define if agentx transport is to use domain sockets only */
 /* #undef NETSNMP_AGENTX_DOM_SOCK_ONLY */
 
 #ifdef UCD_COMPATIBLE
 /* old and in the way */
 #define EXTENSIBLEMIB NETSNMP_UCDAVIS_MIB
 #endif
 
 #ifdef _MSC_VER
 /* Windows Vista and higher have inet_ntop but older Windows does not.
  * We'll use the Net-SNMP version instead. */
 #undef HAVE_INET_NTOP
 #undef HAVE_INET_PTON
 
 /* IPv6 transports */
 #ifdef NETSNMP_ENABLE_IPV6
   #define NETSNMP_TRANSPORT_TCPIPV6_DOMAIN 1
   #define NETSNMP_TRANSPORT_UDPIPV6_DOMAIN 1
   #define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
 #else
   #undef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
   #undef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
 #endif
 #endif
 
 /*
  * Although if_nametoindex() is available on Windows Vista, Windows Server
  * 2008 and later in iphlpapi.dll, do not link with if_nametoindex() such
  * that the Net-SNMP executable can be started on earlier Windows versions.
  */
 #undef HAVE_IF_NAMETOINDEX
 
 #ifndef NI_MAXHOST
 #define NI_MAXHOST	1025
 #endif
 
 /* Define to 1 if you have the `strtoull' function. */
 #if _MSC_VER >= 1800
 #define HAVE_STRTOULL 1
 #else
 /* #undef HAVE_STRTOULL */
 #endif
 
 /*
  * Module configuration and control starts here.
  *
  * Some of the defines herein are used to control
  * groups of modules.  The ones that have "CFG"
  * are used especially to control the include files
  * seen in {agent,mib}_module_includes.h, and the init entries
  * which are invoked in {agent,mib}_module_inits.h.
  *
  * To disable a group, uncomment the associated define.
  */
  
 /* CFG Define if compiling with the ucd_snmp module files.  */
 #define USING_UCD_SNMP_MODULE 1
  
 /* CFG Define if compiling with the agentx module files.  */
 #define USING_AGENTX_MODULE 1
  
 /* CFG Define if compiling with the host module files.  */
 /* #undef USING_HOST_MODULE */
  
 /* CFG Define if compiling with the Rmon module files.  */
 /* #undef USING_RMON_MODULE */
 
 /* CFG Define if compiling with the disman/event-mib module files.  */
 #define USING_DISMAN_EVENT_MIB_MODULE 1
 
 /* CFG Define if compiling with the smux module files.  */
 /* #undef USING_SMUX_MODULE */
 
 /* Define if compiling with the winExtDLL module.  */
 /* #undef USING_WINEXTDLL_MODULE */
 
 /*
  * Module configuration and control ends here.
  */
 #define UDP_ADDRESSES_IN_HOST_ORDER 1
 
 /* Timeout in milliseconds for Win32 function WaitForSingleObject.
    Used by agent pass. */
 #define NETSNMP_TIMEOUT_WAITFORSINGLEOBJECT 5000
 
 #ifdef HAVE_WIN32_PLATFORM_SDK
 #define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
 #endif
 
 #ifdef _MSC_VER
 #ifdef _WIN64
 #define NETSNMP_PRIz "I64"
 #else
 #define NETSNMP_PRIz ""
 #endif
 #endif
 
 #endif /* NET_SNMP_CONFIG_H */
 
diff --git a/win32/net-snmp/net-snmp-config.h.in b/win32/net-snmp/net-snmp-config.h.in
index 4bd139e370..9677abe02e 100644
--- a/win32/net-snmp/net-snmp-config.h.in
+++ b/win32/net-snmp/net-snmp-config.h.in
@@ -1656,240 +1656,240 @@ typedef unsigned int     uintptr_t;
 #ifndef __cplusplus
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable: 4804) // '-' : unsafe use of type 'bool' in operation
 #endif
 enum {
     netsnmp_compile_time_uintptr_t_size_check
         = sizeof(struct netsnmp_compile_time_uintptr_t_size_check_s { int:-!(sizeof(uintptr_t) == sizeof(void*)); })
 };
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 #endif
 
 /* Define if you have the closesocket function.  */
 #define HAVE_CLOSESOCKET 1
 
 /* define to 1 if you do not want to set global snmp_errno */
 #define DONT_SHARE_ERROR_WITH_OTHER_THREADS 1
 
 /* Defining vsnprintf is not necessary for MSVC 2008 or later */
 #if defined(_MSC_VER) && _MSC_VER < 1500
 #define vsnprintf _vsnprintf
 #endif
 #if defined(_MSC_VER) && _MSC_VER < 1900
 #define snprintf  _snprintf
 #endif
 
 #if defined(_MSC_VER) && _MSC_VER < 1600
 #define EADDRINUSE	WSAEADDRINUSE
 #endif
 
 /* Define NETSNMP_USE_DLL when building or using netsnmp.DLL */
 /* #undef NETSNMP_USE_DLL */
 
 #if defined(NETSNMP_DLL) && !defined(NETSNMP_USE_DLL)
 #error NETSNMP_USE_DLL must be defined when building libsnmp as a DLL.
 #endif
 
 /*
  * DLL decoration, if used at all, must be consistent.
  * This is why NETSNMP_IMPORT is really an export decoration
  * when it is encountered in a header file that is included
  * during the compilation of a library source file.
  * NETSNMP_DLL is set by the MSVC libsnmp_dll project
  *  in order to signal that the library sources are being compiled.
  * Not defining NETSNMP_USE_DLL ignores the preceding, and renders
  *  the NETSNMP_IMPORT definitions harmless.
  */
 
 #ifdef NETSNMP_USE_DLL
   #ifdef NETSNMP_DLL
     #if defined(_MSC_VER)
       #define NETSNMP_IMPORT extern __declspec(dllexport)
     #endif
   #else
     #if defined(_MSC_VER)
       #define NETSNMP_IMPORT extern __declspec(dllimport)
     #endif
   #endif   /* NETSNMP_DLL */
 #endif     /* NETSNMP_USE_DLL */
 
 /* MSVC OpenSSL linker settings. */
 #if defined(_MSC_VER)
 #  if defined(NETSNMP_USE_OPENSSL)
 #    ifdef _DLL
 #      ifdef _DEBUG
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MDd.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MDd.lib")
 #            pragma comment(lib, "libssl64MDd.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MDd.lib")
 #            pragma comment(lib, "libssl32MDd.lib")
 #          endif
 #        endif
 #      else
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MD.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MD.lib")
 #            pragma comment(lib, "libssl64MD.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MD.lib")
 #            pragma comment(lib, "libssl32MD.lib")
 #          endif
 #        endif
 #      endif
 #    else
 #      ifdef _DEBUG
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MTd.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MTd.lib")
 #            pragma comment(lib, "libssl64MTd.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MTd.lib")
 #            pragma comment(lib, "libssl32MTd.lib")
 #          endif
 #        endif
 #      else
 #        ifdef OPENSSL_BEFORE_1_1_0
 #          pragma comment(lib, "libeay32MT.lib")
 #        else
 #          ifdef _M_X64
 #            pragma comment(lib, "libcrypto64MT.lib")
 #            pragma comment(lib, "libssl64MT.lib")
 #          else
 #            pragma comment(lib, "libcrypto32MT.lib")
 #            pragma comment(lib, "libssl32MT.lib")
 #          endif
 #        endif
 #      endif
 #    endif
 #    pragma comment(lib, "gdi32.lib")
 #    pragma comment(lib, "user32.lib")
 #  endif
 #endif
 
 #endif       /* WIN32 */
 
 #ifndef NETSNMP_IMPORT
 #  define NETSNMP_IMPORT extern
 #endif
 
 #if defined(HAVE_NLIST) && defined(HAVE_STRUCT_NLIST_N_VALUE) && !defined(DONT_USE_NLIST) && !defined(NETSNMP_NO_KMEM_USAGE)
 #define NETSNMP_CAN_USE_NLIST
 #endif
 
-#if HAVE_DMALLOC_H
+#ifdef HAVE_DMALLOC_H
 #define DMALLOC_FUNC_CHECK
 #endif
 
 #define NETSNMP_NO_SYSTEMD
 
 /* #undef NETSNMP_ENABLE_LOCAL_SMUX */
 
 /* define if agentx transport is to use domain sockets only */
 /* #undef NETSNMP_AGENTX_DOM_SOCK_ONLY */
 
 #ifdef UCD_COMPATIBLE
 /* old and in the way */
 #define EXTENSIBLEMIB NETSNMP_UCDAVIS_MIB
 #endif
 
 #ifdef _MSC_VER
 /* Windows Vista and higher have inet_ntop but older Windows does not.
  * We'll use the Net-SNMP version instead. */
 #undef HAVE_INET_NTOP
 #undef HAVE_INET_PTON
 
 /* IPv6 transports */
 #ifdef NETSNMP_ENABLE_IPV6
   #define NETSNMP_TRANSPORT_TCPIPV6_DOMAIN 1
   #define NETSNMP_TRANSPORT_UDPIPV6_DOMAIN 1
   #define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
 #else
   #undef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
   #undef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
 #endif
 #endif
 
 /*
  * Although if_nametoindex() is available on Windows Vista, Windows Server
  * 2008 and later in iphlpapi.dll, do not link with if_nametoindex() such
  * that the Net-SNMP executable can be started on earlier Windows versions.
  */
 #undef HAVE_IF_NAMETOINDEX
 
 #ifndef NI_MAXHOST
 #define NI_MAXHOST	1025
 #endif
 
 /* Define to 1 if you have the `strtoull' function. */
 #if _MSC_VER >= 1800
 #define HAVE_STRTOULL 1
 #else
 /* #undef HAVE_STRTOULL */
 #endif
 
 /*
  * Module configuration and control starts here.
  *
  * Some of the defines herein are used to control
  * groups of modules.  The ones that have "CFG"
  * are used especially to control the include files
  * seen in {agent,mib}_module_includes.h, and the init entries
  * which are invoked in {agent,mib}_module_inits.h.
  *
  * To disable a group, uncomment the associated define.
  */
  
 /* CFG Define if compiling with the ucd_snmp module files.  */
 #define USING_UCD_SNMP_MODULE 1
  
 /* CFG Define if compiling with the agentx module files.  */
 #define USING_AGENTX_MODULE 1
  
 /* CFG Define if compiling with the host module files.  */
 /* #undef USING_HOST_MODULE */
  
 /* CFG Define if compiling with the Rmon module files.  */
 /* #undef USING_RMON_MODULE */
 
 /* CFG Define if compiling with the disman/event-mib module files.  */
 #define USING_DISMAN_EVENT_MIB_MODULE 1
 
 /* CFG Define if compiling with the smux module files.  */
 /* #undef USING_SMUX_MODULE */
 
 /* Define if compiling with the winExtDLL module.  */
 /* #undef USING_WINEXTDLL_MODULE */
 
 /*
  * Module configuration and control ends here.
  */
 #define UDP_ADDRESSES_IN_HOST_ORDER 1
 
 /* Timeout in milliseconds for Win32 function WaitForSingleObject.
    Used by agent pass. */
 #define NETSNMP_TIMEOUT_WAITFORSINGLEOBJECT 5000
 
 #ifdef HAVE_WIN32_PLATFORM_SDK
 #define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
 #endif
 
 #ifdef _MSC_VER
 #ifdef _WIN64
 #define NETSNMP_PRIz "I64"
 #else
 #define NETSNMP_PRIz ""
 #endif
 #endif
 
 #endif /* NET_SNMP_CONFIG_H */
 
