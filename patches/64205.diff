commit f112d0adcae6b75531894b3c1cb29f97bfdad171
Author: Alex <aleksandrosansan@gmail.com>
Date:   Wed Nov 22 01:55:06 2023 +0100

     Fix oss-fuzz issue 61820 (#1234)
    
    Fix https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=61820

diff --git a/Packet++/header/DhcpLayer.h b/Packet++/header/DhcpLayer.h
index 331ef58c..82d97912 100644
--- a/Packet++/header/DhcpLayer.h
+++ b/Packet++/header/DhcpLayer.h
@@ -12,795 +12,815 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct dhcp_header
 	 * Represents a DHCP protocol header
 	 */
 	#pragma pack(push, 1)
 	struct dhcp_header
 	{
 		/** BootP opcode */
 		uint8_t opCode;
 		/** Hardware type, set to 1 (Ethernet) by default */
 		uint8_t hardwareType;
 		/** Hardware address length, set to 6 (MAC address length) by default */
 		uint8_t hardwareAddressLength;
 		/** Hop count */
 		uint8_t hops;
 		/** DHCP/BootP transaction ID */
 		uint32_t transactionID;
 		/** The elapsed time, in seconds since the client sent its first BOOTREQUEST message */
 		uint16_t secondsElapsed;
 		/** BootP flags */
 		uint16_t flags;
 		/** Client IPv4 address */
 		uint32_t clientIpAddress;
 		/** Your IPv4 address */
 		uint32_t yourIpAddress;
 		/** Server IPv4 address */
 		uint32_t serverIpAddress;
 		/** Gateway IPv4 address */
 		uint32_t gatewayIpAddress;
 		/** Client hardware address, by default contains the MAC address (only 6 first bytes are used) */
 		uint8_t clientHardwareAddress[16];
 		/** BootP server name */
 		uint8_t serverName[64];
 		/** BootP boot file name */
 		uint8_t bootFilename[128];
 		/** DHCP magic number (set to the default value of 0x63538263) */
 		uint32_t magicNumber;
 	};
 	#pragma pack(pop)
 
 
 	/**
 	 * BootP opcodes
 	 */
 	enum BootpOpCodes
 	{
 		/** BootP request */
 		DHCP_BOOTREQUEST = 1,
 		/** BootP reply */
 		DHCP_BOOTREPLY = 2
 	};
 
 	/**
 	 * DHCP message types
 	 */
 	enum DhcpMessageType
 	{
 		/** Unknown message type */
 		DHCP_UNKNOWN_MSG_TYPE = 0,
 		/** Discover message type */
 		DHCP_DISCOVER         = 1,
 		/** Offer message type */
 		DHCP_OFFER            = 2,
 		/** Request message type */
 		DHCP_REQUEST          = 3,
 		/** Decline message type */
 		DHCP_DECLINE          = 4,
 		/** Acknowledge message type */
 		DHCP_ACK              = 5,
 		/** Non-acknowledge message type */
 		DHCP_NAK              = 6,
 		/** Release message type */
 		DHCP_RELEASE          = 7,
 		/** Inform message type */
 		DHCP_INFORM           = 8
 	};
 
 	/**
 	 * DHCP option types.
 	 */
 	enum DhcpOptionTypes
 	{
 		/** Unknown option type */
 		DHCPOPT_UNKNOWN = -1,
 		/** Pad */
 		DHCPOPT_PAD = 0,
 		/** Subnet Mask Value */
 		DHCPOPT_SUBNET_MASK = 1,
 		/** Time Offset in Seconds from UTC */
 		DHCPOPT_TIME_OFFSET = 2,
 		/** N/4 Router addresses */
 		DHCPOPT_ROUTERS = 3,
 		/** N/4 Timeserver addresses */
 		DHCPOPT_TIME_SERVERS = 4,
 		/** N/4 IEN-116 Server addresses */
 		DHCPOPT_NAME_SERVERS = 5,
 		/** N/4 DNS Server addresses */
 		DHCPOPT_DOMAIN_NAME_SERVERS = 6,
 		/** N/4 Logging Server addresses */
 		DHCPOPT_LOG_SERVERS = 7,
 		/** N/4 Quotes Server addresses */
 		DHCPOPT_QUOTES_SERVERS = 8,
 		/** N/4 Quotes Server addresses */
 		DHCPOPT_LPR_SERVERS = 9,
 		/** N/4 Quotes Server addresses */
 		DHCPOPT_IMPRESS_SERVERS = 10,
 		/** N/4 RLP Server addresses */
 		DHCPOPT_RESOURCE_LOCATION_SERVERS = 11,
 		/** Hostname string */
 		DHCPOPT_HOST_NAME = 12,
 		/** Size of boot file in 512 byte chunks */
 		DHCPOPT_BOOT_SIZE = 13,
 		/** Client to dump and name the file to dump it to */
 		DHCPOPT_MERIT_DUMP = 14,
 		/** The DNS domain name of the client */
 		DHCPOPT_DOMAIN_NAME = 15,
 		/** Swap Server address */
 		DHCPOPT_SWAP_SERVER = 16,
 		/** Path name for root disk */
 		DHCPOPT_ROOT_PATH = 17,
 		/** Path name for more BOOTP info */
 		DHCPOPT_EXTENSIONS_PATH = 18,
 		/** Enable/Disable IP Forwarding */
 		DHCPOPT_IP_FORWARDING = 19,
 		/** Enable/Disable Source Routing */
 		DHCPOPT_NON_LOCAL_SOURCE_ROUTING = 20,
 		/** Routing Policy Filters */
 		DHCPOPT_POLICY_FILTER = 21,
 		/** Max Datagram Reassembly Size */
 		DHCPOPT_MAX_DGRAM_REASSEMBLY = 22,
 		/** Default IP Time to Live */
 		DEFAULT_IP_TTL = 23,
 		/** Path MTU Aging Timeout */
 		DHCPOPT_PATH_MTU_AGING_TIMEOUT = 24,
 		/** Path MTU Plateau Table */
 		PATH_MTU_PLATEAU_TABLE = 25,
 		/** Interface MTU Size */
 		DHCPOPT_INTERFACE_MTU = 26,
 		/** All Subnets are Local */
 		DHCPOPT_ALL_SUBNETS_LOCAL = 27,
 		/** Broadcast Address */
 		DHCPOPT_BROADCAST_ADDRESS = 28,
 		/** Perform Mask Discovery */
 		DHCPOPT_PERFORM_MASK_DISCOVERY = 29,
 		/** Provide Mask to Others */
 		DHCPOPT_MASK_SUPPLIER = 30,
 		/** Perform Router Discovery */
 		DHCPOPT_ROUTER_DISCOVERY = 31,
 		/** Router Solicitation Address */
 		DHCPOPT_ROUTER_SOLICITATION_ADDRESS = 32,
 		/** Static Routing Table */
 		DHCPOPT_STATIC_ROUTES = 33,
 		/** Trailer Encapsulation */
 		DHCPOPT_TRAILER_ENCAPSULATION = 34,
 		/** ARP Cache Timeout */
 		DHCPOPT_ARP_CACHE_TIMEOUT = 35,
 		/** IEEE802.3 Encapsulation */
 		DHCPOPT_IEEE802_3_ENCAPSULATION = 36,
 		/** Default TCP Time to Live */
 		DHCPOPT_DEFAULT_TCP_TTL = 37,
 		/** TCP Keepalive Interval */
 		DHCPOPT_TCP_KEEPALIVE_INTERVAL = 38,
 		/** TCP Keepalive Garbage */
 		DHCPOPT_TCP_KEEPALIVE_GARBAGE = 39,
 		/** NIS Domain Name */
 		DHCPOPT_NIS_DOMAIN = 40,
 		/** NIS Server Addresses */
 		DHCPOPT_NIS_SERVERS = 41,
 		/** NTP Server Addresses */
 		DHCPOPT_NTP_SERVERS = 42,
 		/** Vendor Specific Information */
 		DHCPOPT_VENDOR_ENCAPSULATED_OPTIONS = 43,
 		/** NETBIOS Name Servers */
 		DHCPOPT_NETBIOS_NAME_SERVERS = 44,
 		/** NETBIOS Datagram Distribution */
 		DHCPOPT_NETBIOS_DD_SERVER = 45,
 		/** NETBIOS Node Type */
 		DHCPOPT_NETBIOS_NODE_TYPE = 46,
 		/** NETBIOS Scope */
 		DHCPOPT_NETBIOS_SCOPE = 47,
 		/** X Window Font Server */
 		DHCPOPT_FONT_SERVERS = 48,
 		/** X Window Display Manager */
 		DHCPOPT_X_DISPLAY_MANAGER = 49,
 		/** Requested IP Address */
 		DHCPOPT_DHCP_REQUESTED_ADDRESS = 50,
 		/** IP Address Lease Time */
 		DHCPOPT_DHCP_LEASE_TIME = 51,
 		/** Overload "sname" or "file" */
 		DHCPOPT_DHCP_OPTION_OVERLOAD = 52,
 		/** DHCP Message Type */
 		DHCPOPT_DHCP_MESSAGE_TYPE = 53,
 		/** DHCP Server Identification */
 		DHCPOPT_DHCP_SERVER_IDENTIFIER = 54,
 		/** Parameter Request List */
 		DHCPOPT_DHCP_PARAMETER_REQUEST_LIST = 55,
 		/** DHCP Error Message */
 		DHCPOPT_DHCP_MESSAGE = 56,
 		/** DHCP Maximum Message Size */
 		DHCPOPT_DHCP_MAX_MESSAGE_SIZE = 57,
 		/** DHCP Renewal (T1) Time */
 		DHCPOPT_DHCP_RENEWAL_TIME = 58,
 		/** DHCP Rebinding (T2) Time */
 		DHCPOPT_DHCP_REBINDING_TIME = 59,
 		/** Class Identifier */
 		DHCPOPT_VENDOR_CLASS_IDENTIFIER = 60,
 		/** Class Identifier */
 		DHCPOPT_DHCP_CLIENT_IDENTIFIER = 61,
 		/** NetWare/IP Domain Name */
 		DHCPOPT_NWIP_DOMAIN_NAME = 62,
 		/** NetWare/IP sub Options */
 		DHCPOPT_NWIP_SUBOPTIONS = 63,
 		/** NIS+ v3 Client Domain Name */
 		DHCPOPT_NIS_DOMAIN_NAME = 64,
 		/** NIS+ v3 Server Addresses */
 		DHCPOPT_NIS_SERVER_ADDRESS = 65,
 		/** TFTP Server Name */
 		DHCPOPT_TFTP_SERVER_NAME = 66,
 		/** Boot File Name */
 		DHCPOPT_BOOTFILE_NAME = 67,
 		/** Home Agent Addresses */
 		DHCPOPT_HOME_AGENT_ADDRESS = 68,
 		/** Simple Mail Server (SMTP) Addresses */
 		DHCPOPT_SMTP_SERVER = 69,
 		/** Post Office (POP3) Server Addresses */
 		DHCPOPT_POP3_SERVER = 70,
 		/** Network News (NNTP) Server Addresses */
 		DHCPOPT_NNTP_SERVER = 71,
 		/** WWW Server Addresses */
 		DHCPOPT_WWW_SERVER = 72,
 		/** Finger Server Addresses */
 		DHCPOPT_FINGER_SERVER = 73,
 		/** Chat (IRC) Server Addresses */
 		DHCPOPT_IRC_SERVER = 74,
 		/** StreetTalk Server Addresses */
 		DHCPOPT_STREETTALK_SERVER = 75,
 		/** ST Directory Assist. Addresses */
 		DHCPOPT_STDA_SERVER = 76,
 		/** User Class Information */
 		DHCPOPT_USER_CLASS = 77,
 		/** Directory Agent Information */
 		DHCPOPT_DIRECTORY_AGENT = 78,
 		/** Service Location Agent Scope */
 		DHCPOPT_SERVICE_SCOPE = 79,
 		/** Rapid Commit */
 		DHCPOPT_RAPID_COMMIT = 80,
 		/** Fully Qualified Domain Name */
 		DHCPOPT_FQDN = 81,
 		/** Relay Agent Information */
 		DHCPOPT_DHCP_AGENT_OPTIONS = 82,
 		/** Internet Storage Name Service */
 		DHCPOPT_ISNS = 83,
 		/** Novell Directory Services */
 		DHCPOPT_NDS_SERVERS = 85,
 		/** Novell Directory Services */
 		DHCPOPT_NDS_TREE_NAME = 86,
 		/** Novell Directory Services */
 		DHCPOPT_NDS_CONTEXT = 87,
 		/** BCMCS Controller Domain Name list */
 		DHCPOPT_BCMCS_CONTROLLER_DOMAIN_NAME_LIST = 88,
 		/** BCMCS Controller IPv4 address option */
 		DHCPOPT_BCMCS_CONTROLLER_IPV4_ADDRESS = 89,
 		/** Authentication */
 		DHCPOPT_AUTHENTICATION = 90,
 		/** Client Last Transaction Time */
 		DHCPOPT_CLIENT_LAST_TXN_TIME = 91,
 		/** Associated IP */
 		DHCPOPT_ASSOCIATED_IP = 92,
 		/** Client System Architecture */
 		DHCPOPT_CLIENT_SYSTEM = 93,
 		/** Client Network Device Interface */
 		DHCPOPT_CLIENT_NDI = 94,
 		/** Lightweight Directory Access Protocol [ */
 		DHCPOPT_LDAP = 95,
 		/** UUID/GUID-based Client Identifier */
 		DHCPOPT_UUID_GUID = 97,
 		/** Open Group's User Authentication */
 		DHCPOPT_USER_AUTH = 98,
 		/** GEOCONF_CIVIC */
 		DHCPOPT_GEOCONF_CIVIC = 99,
 		/** IEEE 1003.1 TZ String */
 		DHCPOPT_PCODE = 100,
 		/** Reference to the TZ Database */
 		DHCPOPT_TCODE = 101,
 		/** NetInfo Parent Server Address */
 		DHCPOPT_NETINFO_ADDRESS = 112,
 		/** NetInfo Parent Server Tag */
 		DHCPOPT_NETINFO_TAG = 113,
 		/** URL */
 		DHCPOPT_URL = 114,
 		/** DHCP Auto-Configuration */
 		DHCPOPT_AUTO_CONFIG = 116,
 		/** Name Service Search */
 		DHCPOPT_NAME_SERVICE_SEARCH = 117,
 		/** Subnet Selection Option */
 		DHCPOPT_SUBNET_SELECTION = 118,
 		/** DNS Domain Search List */
 		DHCPOPT_DOMAIN_SEARCH = 119,
 		/** SIP Servers DHCP Option */
 		DHCPOPT_SIP_SERVERS = 120,
 		/** Classless Static Route Option */
 		DHCPOPT_CLASSLESS_STATIC_ROUTE = 121,
 		/** CableLabs Client Configuration */
 		DHCPOPT_CCC = 122,
 		/** GeoConf Option */
 		DHCPOPT_GEOCONF = 123,
 		/** Vendor-Identifying Vendor Class */
 		DHCPOPT_V_I_VENDOR_CLASS = 124,
 		/** Vendor-Identifying Vendor-Specific Information */
 		DHCPOPT_V_I_VENDOR_OPTS = 125,
 		/** OPTION_PANA_AGENT */
 		DHCPOPT_OPTION_PANA_AGENT = 136,
 		/** OPTION_V4_LOST */
 		DHCPOPT_OPTION_V4_LOST = 137,
 		/** CAPWAP Access Controller addresses */
 		DHCPOPT_OPTION_CAPWAP_AC_V4 = 138,
 		/** A Series Of Suboptions */
 		DHCPOPT_OPTION_IPV4_ADDRESS_MOS = 139,
 		/** A Series Of Suboptions */
 		DHCPOPT_OPTION_IPV4_FQDN_MOS = 140,
 		/** List of domain names to search for SIP User Agent Configuration */
 		DHCPOPT_SIP_UA_CONFIG = 141,
 		/** ANDSF IPv4 Address Option for DHCPv4 */
 		DHCPOPT_OPTION_IPV4_ADDRESS_ANDSF = 142,
 		/** Geospatial Location with Uncertainty [RF */
 		DHCPOPT_GEOLOC = 144,
 		/** Forcerenew Nonce Capable */
 		DHCPOPT_FORCERENEW_NONCE_CAPABLE = 145,
 		/** Information for selecting RDNSS */
 		DHCPOPT_RDNSS_SELECTION = 146,
 		/** Status code and optional N byte text message describing status */
 		DHCPOPT_STATUS_CODE = 151,
 		/** Absolute time (seconds since Jan 1, 1970) message was sent */
 		DHCPOPT_BASE_TIME = 152,
 		/** Number of seconds in the past when client entered current state */
 		DHCPOPT_START_TIME_OF_STATE = 153,
 		/** Absolute time (seconds since Jan 1, 1970) for beginning of query */
 		DHCPOPT_QUERY_START_TIME = 154,
 		/** Absolute time (seconds since Jan 1, 1970) for end of query */
 		DHCPOPT_QUERY_END_TIME = 155,
 		/** State of IP address */
 		DHCPOPT_DHCP_STATE = 156,
 		/** Indicates information came from local or remote server */
 		DHCPOPT_DATA_SOURCE = 157,
 		/** Includes one or multiple lists of PCP server IP addresses; each list is treated as a separate PCP server */
 		DHCPOPT_OPTION_V4_PCP_SERVER = 158,
 		/** This option is used to configure a set of ports bound to a shared IPv4 address */
 		DHCPOPT_OPTION_V4_PORTPARAMS = 159,
 		/** DHCP Captive-Portal */
 		DHCPOPT_CAPTIVE_PORTAL = 160,
 		/** Manufacturer Usage Descriptions */
 		DHCPOPT_OPTION_MUD_URL_V4 = 161,
 		/** Etherboot */
 		DHCPOPT_ETHERBOOT = 175,
 		/** IP Telephone */
 		DHCPOPT_IP_TELEPHONE = 176,
 		/** Magic string = F1:00:74:7E */
 		DHCPOPT_PXELINUX_MAGIC = 208,
 		/** Configuration file */
 		DHCPOPT_CONFIGURATION_FILE = 209,
 		/** Path Prefix Option */
 		DHCPOPT_PATH_PREFIX = 210,
 		/** Reboot Time */
 		DHCPOPT_REBOOT_TIME = 211,
 		/** OPTION_6RD with N/4 6rd BR addresses */
 		DHCPOPT_OPTION_6RD = 212,
 		/** Access Network Domain Name */
 		DHCPOPT_OPTION_V4_ACCESS_DOMAIN = 213,
 		/** Subnet Allocation Option */
 		DHCPOPT_SUBNET_ALLOCATION = 220,
 		/** Virtual Subnet Selection (VSS) Option */
 		DHCPOPT_VIRTUAL_SUBNET_SELECTION = 221,
 		/** End (last option) */
 		DHCPOPT_END	= 255
 	};
 
 
 	/**
 	 * @class DhcpOption
 	 * A wrapper class for DHCP options. This class does not create or modify DHCP option records, but rather
 	 * serves as a wrapper and provides useful methods for setting and retrieving data to/from them
 	 */
 	class DhcpOption : public TLVRecord<uint8_t, uint8_t>
 	{
 	public:
 
 		/**
 		 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 		 * @param[in] optionRawData A pointer to the option raw data
 		 */
 		explicit DhcpOption(uint8_t* optionRawData) : TLVRecord(optionRawData) { }
 
 		/**
 		 * A d'tor for this class, currently does nothing
 		 */
 		virtual ~DhcpOption() { }
 
 		/**
 		 * Retrieve DHCP option data as IPv4 address. Relevant only if option value is indeed an IPv4 address
 		 * @return DHCP option data as IPv4 address
 		 */
 		IPv4Address getValueAsIpAddr() const
 		{
 			return getValueAs<uint32_t>();
 		}
 
 		/**
 		 * Set DHCP option data as IPv4 address. This method copies the 4 bytes of the IP address to the option value
 		 * @param[in] addr The IPv4 address to set
 		 * @param[in] valueOffset An optional parameter that specifies where to start set the option data (default set to 0). For example:
 		 * if option data is 20 bytes long and you want to set the IP address in the 4 last bytes then use this method like this:
 		 * setValueIpAddr(your_addr, 16)
 		 */
 		void setValueIpAddr(const IPv4Address& addr, int valueOffset = 0)
 		{
 			setValue<uint32_t>(addr.toInt(), valueOffset);
 		}
 
 		/**
 		 * Retrieve DHCP option data as string. Relevant only if option value is indeed a string
 		 * @param[in] valueOffset An optional parameter that specifies where to start copy the DHCP option data. For example:
 		 * when retrieving Client FQDN option, you may ignore the flags and RCODE fields using this method like this:
 		 * getValueAsString(3). The default is 0 - start copying from the beginning of option data
 		 * @return DHCP option data as string
 		 */
 		std::string getValueAsString(int valueOffset = 0) const
 		{
 			if (m_Data == nullptr || m_Data->recordLen - valueOffset < 1)
 				return "";
 
 			return std::string((const char*)m_Data->recordValue + valueOffset, (int)m_Data->recordLen - valueOffset);
 		}
 
 		/**
 		 * Set DHCP option data as string. This method copies the string to the option value. If the string is longer than option length
 		 * the string is trimmed so it will fit the option length
 		 * @param[in] stringValue The string to set
 		 * @param[in] valueOffset An optional parameter that specifies where to start set the option data (default set to 0). For example:
 		 * if option data is 20 bytes long and you want to set a 6 char-long string in the 6 last bytes then use this method like this:
 		 * setValueString("string", 14)
 		 */
 		void setValueString(const std::string& stringValue, int valueOffset = 0)
 		{
 			// calculate the maximum length of the destination buffer
 			size_t len = (size_t)m_Data->recordLen - (size_t)valueOffset;
 
 			// use the length of input string if a buffer is large enough for whole string
 			if (stringValue.length() < len)
 				len = stringValue.length();
 
 			memcpy(m_Data->recordValue + valueOffset, stringValue.data(), len);
 		}
 
+		/**
+		 * Check if a pointer can be assigned to the TLV record data
+		 * @param[in] recordRawData A pointer to the TLV record raw data
+		 * @param[in] tlvDataLen The size of the TLV record raw data
+		 * @return True if data is valid and can be assigned
+		 */
+		static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+		{
+			auto data = (TLVRawData*)recordRawData;
+			if (data == nullptr)
+				return false;
+
+			if (tlvDataLen < sizeof(TLVRawData::recordType))
+				return false;
+
+			if (data->recordType == (uint8_t)DHCPOPT_END || data->recordType == (uint8_t)DHCPOPT_PAD)
+				return true;
+
+			return TLVRecord<uint8_t, uint8_t>::canAssign(recordRawData, tlvDataLen);
+		}
 
 		// implement abstract methods
 
 		size_t getTotalSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (m_Data->recordType == (uint8_t)DHCPOPT_END || m_Data->recordType == (uint8_t)DHCPOPT_PAD)
 				return sizeof(uint8_t);
 
 			return sizeof(uint8_t) * 2 + (size_t)m_Data->recordLen;
 		}
 
 		size_t getDataSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (m_Data->recordType == (uint8_t)DHCPOPT_END || m_Data->recordType == (uint8_t)DHCPOPT_PAD)
 				return 0;
 
 			return m_Data->recordLen;
 		}
 	};
 
 
 	/**
 	 * @class DhcpOptionBuilder
 	 * A class for building DHCP options. This builder receives the option parameters in its c'tor,
 	 * builds the DHCP option raw buffer and provides a build() method to get a DhcpOption object out of it
 	 */
 	class DhcpOptionBuilder : public TLVRecordBuilder
 	{
 	public:
 
 		/**
 		 * A c'tor for building DHCP options which their value is a byte array. The DhcpOption object can later
 		 * be retrieved by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue A buffer containing the option value. This buffer is read-only and isn't modified in any way
 		 * @param[in] optionValueLen DHCP option value length in bytes
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, const uint8_t* optionValue, uint8_t optionValueLen) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue, optionValueLen) { }
 
 		/**
 		 * A c'tor for building DHCP options which have a 1-byte value. The DhcpOption object can later be retrieved
 		 * by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue A 1-byte option value
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, uint8_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { }
 
 		/**
 		 * A c'tor for building DHCP options which have a 2-byte value. The DhcpOption object can later be retrieved
 		 * by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue A 2-byte option value
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, uint16_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { }
 
 		/**
 		 * A c'tor for building DHCP options which have a 4-byte value. The DhcpOption object can later be retrieved
 		 * by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue A 4-byte option value
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, uint32_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { }
 
 		/**
 		 * A c'tor for building DHCP options which have an IPv4Address value. The DhcpOption object can later be
 		 * retrieved by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue The IPv4 address option value
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, const IPv4Address& optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { }
 
 		/**
 		 * A c'tor for building DHCP options which have a string value. The DhcpOption object can later be retrieved
 		 * by calling build()
 		 * @param[in] optionType DHCP option type
 		 * @param[in] optionValue The string option value
 		 */
 		DhcpOptionBuilder(DhcpOptionTypes optionType, const std::string& optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { }
 
 		/**
 		 * A copy c'tor which copies all the data from another instance of DhcpOptionBuilder
 		 * @param[in] other The instance to copy from
 		 */
 		DhcpOptionBuilder(const DhcpOptionBuilder& other) :
 			TLVRecordBuilder(other) { }
 
 		/**
 		 * Assignment operator that copies all data from another instance of DhcpOptionBuilder
 		 * @param[in] other The instance to assign from
 		 * @return A reference to the assignee
 		 */
 		DhcpOptionBuilder& operator=(const DhcpOptionBuilder& other)
 		{
 			TLVRecordBuilder::operator=(other);
 			return *this;
 		}
 
 		/**
 		 * Build the DhcpOption object out of the parameters defined in the c'tor
 		 * @return The DhcpOption object
 		 */
 		DhcpOption build() const;
 	};
 
 
 
 	/**
 	 * @class DhcpLayer
 	 * Represents a DHCP (Dynamic Host Configuration Protocol) protocol layer
 	 */
 	class DhcpLayer : public Layer
 	{
 	public:
 
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		DhcpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
 
 		/**
 		 * A constructor that creates the layer from scratch. Adds a ::DHCPOPT_DHCP_MESSAGE_TYPE and a ::DHCPOPT_END
 		 * options
 		 * @param[in] msgType A DHCP message type to be set
 		 * @param[in] clientMacAddr A client MAC address to set in dhcp_header#clientHardwareAddress field
 		 */
 		DhcpLayer(DhcpMessageType msgType, const MacAddress& clientMacAddr);
 
 		/**
 		 * A constructor that creates the layer from scratch with clean data
 		 */
 		DhcpLayer();
 
 		/**
 		 * A destructor for this layer
 		 */
 		virtual ~DhcpLayer() {}
 
 		/**
 		 * Get a pointer to the DHCP header. Notice this points directly to the data, so every change will change the actual packet data
 		 * @return A pointer to the @ref dhcp_header
 		 */
 		dhcp_header* getDhcpHeader() const { return (dhcp_header*)m_Data; }
 
 		/**
 		 * @return The BootP opcode of this message
 		 */
 		BootpOpCodes getOpCode() const { return (BootpOpCodes)getDhcpHeader()->opCode; }
 
 		/**
 		 * @return The client IPv4 address (as extracted from dhcp_header#clientIpAddress converted to IPv4Address object)
 		 */
 		IPv4Address getClientIpAddress() const { return getDhcpHeader()->clientIpAddress; }
 
 		/**
 		 * Set the client IPv4 address in dhcp_header#clientIpAddress
 		 * @param[in] addr The IPv4 address to set
 		 */
 		void setClientIpAddress(const IPv4Address& addr) { getDhcpHeader()->clientIpAddress = addr.toInt(); }
 
 		/**
 		 * @return The server IPv4 address (as extracted from dhcp_header#serverIpAddress converted to IPv4Address object)
 		 */
 		IPv4Address getServerIpAddress() const { return getDhcpHeader()->serverIpAddress; }
 
 		/**
 		 * Set the server IPv4 address in dhcp_header#serverIpAddress
 		 * @param[in] addr The IPv4 address to set
 		 */
 		void setServerIpAddress(const IPv4Address& addr) { getDhcpHeader()->serverIpAddress = addr.toInt(); }
 
 		/**
 		 * @return Your IPv4 address (as extracted from dhcp_header#yourIpAddress converted to IPv4Address object)
 		 */
 		IPv4Address getYourIpAddress() const { return getDhcpHeader()->yourIpAddress; }
 
 		/**
 		 * Set your IPv4 address in dhcp_header#yourIpAddress
 		 * @param[in] addr The IPv4 address to set
 		 */
 		void setYourIpAddress(const IPv4Address& addr) { getDhcpHeader()->yourIpAddress = addr.toInt(); }
 
 		/**
 		 * @return Gateway IPv4 address (as extracted from dhcp_header#gatewayIpAddress converted to IPv4Address object)
 		 */
 		IPv4Address getGatewayIpAddress() const { return getDhcpHeader()->gatewayIpAddress; }
 
 		/**
 		 * Set the gateway IPv4 address in dhcp_header#gatewayIpAddress
 		 * @param[in] addr The IPv4 address to set
 		 */
 		void setGatewayIpAddress(const IPv4Address& addr) { getDhcpHeader()->gatewayIpAddress = addr.toInt(); }
 
 		/**
 		 * @return The client MAC address as extracted from dhcp_header#clientHardwareAddress, assuming dhcp_header#hardwareType is 1 (Ethernet)
 		 * and dhcp_header#hardwareAddressLength is 6 (MAC address length). Otherwise returns MacAddress#Zero
 		 */
 		MacAddress getClientHardwareAddress() const;
 
 		/**
 		 * Set a MAC address into the first 6 bytes of dhcp_header#clientHardwareAddress. This method also sets dhcp_header#hardwareType
 		 * to 1 (Ethernet) and dhcp_header#hardwareAddressLength to 6 (MAC address length)
 		 * @param[in] addr The MAC address to set
 		 */
 		void setClientHardwareAddress(const MacAddress& addr);
 
 		/**
 		 * @return DHCP message type as extracted from ::DHCPOPT_DHCP_MESSAGE_TYPE option. If this option doesn't exist the value of
 		 * ::DHCP_UNKNOWN_MSG_TYPE is returned
 		 */
 		DhcpMessageType getMessageType() const;
 
 		/**
 		 * Set DHCP message type. This method searches for existing ::DHCPOPT_DHCP_MESSAGE_TYPE option. If found, it sets the requested
 		 * message type as its value. If not, it creates a ::DHCPOPT_DHCP_MESSAGE_TYPE option and sets the requested message type as its
 		 * value
 		 * @param[in] msgType Message type to set
 		 * @return True if message type was set successfully or false if msgType is ::DHCP_UNKNOWN_MSG_TYPE or if failed to add
 		 * ::DHCPOPT_DHCP_MESSAGE_TYPE option
 		 */
 		bool setMessageType(DhcpMessageType msgType);
 
 		/**
 		 * @return The first DHCP option in the packet. If there are no DHCP options the returned value will contain
 		 * a logical NULL (DhcpOption#isNull() == true)
 		 */
 		DhcpOption getFirstOptionData() const;
 
 		/**
 		 * Get the DHCP option that comes after a given option. If the given option was the last one, the
 		 * returned value will contain a logical NULL (DhcpOption#isNull() == true)
 		 * @param[in] dhcpOption A given DHCP option
 		 * @return A DhcpOption object containing the option data that comes next, or logical NULL if the given DHCP
 		 * option: (1) was the last one; (2) contains a logical NULL or (3) doesn't belong to this packet
 		 */
 		DhcpOption getNextOptionData(DhcpOption dhcpOption) const;
 
 		/**
 		 * Get a DHCP option by type
 		 * @param[in] option DHCP option type
 		 * @return A DhcpOption object containing the first DHCP option data that matches this type, or logical NULL
 		 * (DhcpOption#isNull() == true) if no such option found
 		 */
 		DhcpOption getOptionData(DhcpOptionTypes option) const;
 
 		/**
 		 * @return The number of DHCP options in this layer
 		 */
 		size_t getOptionsCount() const;
 
 		/**
 		 * Add a new DHCP option at the end of the layer
 		 * @param[in] optionBuilder A DhcpOptionBuilder object that contains the requested DHCP option data to add
 		 * @return A DhcpOption object containing the newly added DHCP option data or logical NULL
 		 * (DhcpOption#isNull() == true) if addition failed
 		 */
 		DhcpOption addOption(const DhcpOptionBuilder& optionBuilder);
 
 		/**
 		 * Add a new DHCP option after an existing one
 		 * @param[in] optionBuilder A DhcpOptionBuilder object that contains the requested DHCP option data to add
 		 * @param[in] prevOption The DHCP option type which the newly added option will come after
 		 * @return A DhcpOption object containing the newly added DHCP option data or logical NULL
 		 * (DhcpOption#isNull() == true) if addition failed
 		 */
 		DhcpOption addOptionAfter(const DhcpOptionBuilder& optionBuilder, DhcpOptionTypes prevOption);
 
 		/**
 		 * Remove an existing DHCP option from the layer
 		 * @param[in] optionType The DHCP option type to remove
 		 * @return True if DHCP option was successfully removed or false if type wasn't found or if removal failed
 		 */
 		bool removeOption(DhcpOptionTypes optionType);
 
 		/**
 		 * Remove all DHCP options in this layer
 		 * @return True if all DHCP options were successfully removed or false if removal failed for some reason
 		 */
 		bool removeAllOptions();
 
 		// implement abstract methods
 
 		/**
 		 * Does nothing for this layer (DhcpLayer is always last)
 		 */
 		void parseNextLayer() {}
 
 		/**
 		 * @return The size of @ref dhcp_header + size of options
 		 */
 		size_t getHeaderLen() const { return m_DataLen; }
 
 		/**
 		 * Calculate the following fields:
 		 * - @ref dhcp_header#magicNumber = DHCP magic number (0x63538263)
 		 * - @ref dhcp_header#opCode = ::DHCP_BOOTREQUEST for message types: ::DHCP_DISCOVER, ::DHCP_REQUEST, ::DHCP_DECLINE, ::DHCP_RELEASE,
 		 *                            ::DHCP_INFORM, ::DHCP_UNKNOWN_MSG_TYPE
 		 *                            ::DHCP_BOOTREPLY for message types: ::DHCP_OFFER, ::DHCP_ACK, ::DHCP_NAK
 		 * - @ref dhcp_header#hardwareType = 1 (Ethernet)
 		 * - @ref dhcp_header#hardwareAddressLength = 6 (MAC address length)
 		 */
 		void computeCalculateFields();
 
 		std::string toString() const;
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelApplicationLayer; }
 
 	private:
 
 		uint8_t* getOptionsBasePtr() const { return m_Data + sizeof(dhcp_header); }
 
 		TLVRecordReader<DhcpOption> m_OptionReader;
 
 		void initDhcpLayer(size_t numOfBytesToAllocate);
 
 		DhcpOption addOptionAt(const DhcpOptionBuilder& optionBuilder, int offset);
 	};
 }
 
 #endif /* PACKETPP_DHCP_LAYER */
diff --git a/Packet++/header/IPv4Layer.h b/Packet++/header/IPv4Layer.h
index 52762e38..ee959d1b 100644
--- a/Packet++/header/IPv4Layer.h
+++ b/Packet++/header/IPv4Layer.h
@@ -13,647 +13,676 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct iphdr
 	 * Represents an IPv4 protocol header
 	 */
 #pragma pack(push, 1)
 	struct iphdr
 	{
 #if (BYTE_ORDER == LITTLE_ENDIAN)
 		/** IP header length, has the value of 5 for IPv4 */
 		uint8_t internetHeaderLength:4,
 		/** IP version number, has the value of 4 for IPv4 */
 		ipVersion:4;
 #else
 		/** IP version number, has the value of 4 for IPv4 */
 		uint8_t ipVersion:4,
 		/** IP header length, has the value of 5 for IPv4 */
 		internetHeaderLength:4;
 #endif
 		/** type of service, same as Differentiated Services Code Point (DSCP)*/
 		uint8_t typeOfService;
 		/** Entire packet (fragment) size, including header and data, in bytes */
 		uint16_t totalLength;
 		/** Identification field. Primarily used for uniquely identifying the group of fragments of a single IP datagram*/
 		uint16_t ipId;
 		 /** Fragment offset field, measured in units of eight-byte blocks (64 bits) */
 		uint16_t fragmentOffset;
 		/** An eight-bit time to live field helps prevent datagrams from persisting (e.g. going in circles) on an internet.  In practice, the field has become a hop count */
 		uint8_t timeToLive;
 		/** Defines the protocol used in the data portion of the IP datagram. Must be one of ::IPProtocolTypes */
 		uint8_t protocol;
 		/** Error-checking of the header */
 		uint16_t headerChecksum;
 		/** IPv4 address of the sender of the packet */
 		uint32_t ipSrc;
 		/** IPv4 address of the receiver of the packet */
 		uint32_t ipDst;
 		/*The options start here. */
 	};
 #pragma pack(pop)
 
 	/**
 	 * An enum for all possible IPv4 and IPv6 protocol types
 	 */
 	enum IPProtocolTypes
 	{
 		/** Dummy protocol for TCP		*/
 		PACKETPP_IPPROTO_IP = 0,
 		/** IPv6 Hop-by-Hop options		*/
 		PACKETPP_IPPROTO_HOPOPTS = 0,
 		/** Internet Control Message Protocol	*/
 		PACKETPP_IPPROTO_ICMP = 1,
 		/** Internet Gateway Management Protocol */
 		PACKETPP_IPPROTO_IGMP = 2,
 		/** IPIP tunnels (older KA9Q tunnels use 94) */
 		PACKETPP_IPPROTO_IPIP = 4,
 		/** Transmission Control Protocol	*/
 		PACKETPP_IPPROTO_TCP = 6,
 		/** Exterior Gateway Protocol		*/
 		PACKETPP_IPPROTO_EGP = 8,
 		/** PUP protocol				*/
 		PACKETPP_IPPROTO_PUP = 12,
 		/** User Datagram Protocol		*/
 		PACKETPP_IPPROTO_UDP = 17,
 		/** XNS IDP protocol			*/
 		PACKETPP_IPPROTO_IDP = 22,
 		/** IPv6 header				*/
 		PACKETPP_IPPROTO_IPV6 = 41,
 		/** IPv6 Routing header			*/
 		PACKETPP_IPPROTO_ROUTING = 43,
 		/** IPv6 fragmentation header		*/
 		PACKETPP_IPPROTO_FRAGMENT = 44,
 		/** GRE protocol */
 		PACKETPP_IPPROTO_GRE = 47,
 		/** encapsulating security payload	*/
 		PACKETPP_IPPROTO_ESP = 50,
 		/** authentication header		*/
 		PACKETPP_IPPROTO_AH = 51,
 		/** ICMPv6				*/
 		PACKETPP_IPPROTO_ICMPV6 = 58,
 		/** IPv6 no next header			*/
 		PACKETPP_IPPROTO_NONE = 59,
 		/** IPv6 Destination options		*/
 		PACKETPP_IPPROTO_DSTOPTS = 60,
 		/** VRRP protocol */
 		PACKETPP_IPPROTO_VRRP = 112,
 		/** Raw IP packets			*/
 		PACKETPP_IPPROTO_RAW = 255,
 		/** Maximum value */
 		PACKETPP_IPPROTO_MAX
 	};
 
 
 	/**
 	 * An enum for supported IPv4 option types
 	 */
 	enum IPv4OptionTypes
 	{
 		/** End of Options List */
 		IPV4OPT_EndOfOptionsList = 0,
 		/** No Operation */
 		IPV4OPT_NOP = 1,
 		/** Record Route */
 		IPV4OPT_RecordRoute = 7,
 		/** MTU Probe */
 		IPV4OPT_MTUProbe = 11,
 		/** MTU Reply */
 		IPV4OPT_MTUReply = 12,
 		/** Quick-Start */
 		IPV4OPT_QuickStart = 25,
 		/** Timestamp */
 		IPV4OPT_Timestamp = 68,
 		/** Traceroute */
 		IPV4OPT_Traceroute = 82,
 		/** Security */
 		IPV4OPT_Security = 130,
 		/** Loose Source Route */
 		IPV4OPT_LooseSourceRoute = 131,
 		/** Extended Security */
 		IPV4OPT_ExtendedSecurity = 133,
 		/** Commercial Security */
 		IPV4OPT_CommercialSecurity = 134,
 		/** Stream ID */
 		IPV4OPT_StreamID = 136,
 		/** Strict Source Route */
 		IPV4OPT_StrictSourceRoute = 137,
 		/** Extended Internet Protocol */
 		IPV4OPT_ExtendedInternetProtocol = 145,
 		/** Address Extension */
 		IPV4OPT_AddressExtension = 147,
 		/** Router Alert */
 		IPV4OPT_RouterAlert = 148,
 		/** Selective Directed Broadcast */
 		IPV4OPT_SelectiveDirectedBroadcast = 149,
 		/** Dynamic Packet State */
 		IPV4OPT_DynamicPacketState = 151,
 		/** Upstream Multicast Pkt. */
 		IPV4OPT_UpstreamMulticastPkt = 152,
 		/** Unknown IPv4 option */
 		IPV4OPT_Unknown
 	};
 
 #define PCPP_IP_DONT_FRAGMENT  0x40
 #define PCPP_IP_MORE_FRAGMENTS 0x20
 
 	/**
 	 * @struct IPv4TimestampOptionValue
 	 * A struct representing a parsed value of the IPv4 timestamp option. This struct is used returned in IPv4OptionData#getTimestampOptionValue() method
 	 */
 	struct IPv4TimestampOptionValue
 	{
 		/**
 		 * An enum for IPv4 timestamp option types
 		 */
 		enum TimestampType
 		{
 			/** Value containing only timestamps */
 			TimestampOnly = 0,
 			/** Value containing both timestamps and IPv4 addresses */
 			TimestampAndIP = 1,
 			/** The IPv4 addresses are prespecified */
 			TimestampsForPrespecifiedIPs = 2,
 			/** Invalid or unknown value type */
 			Unknown = 3
 		};
 
 		/** The timestamp value type */
 		TimestampType type;
 
 		/** A list of timestamps parsed from the IPv4 timestamp option value */
 		std::vector<uint32_t> timestamps;
 
 		/** A list of IPv4 addresses parsed from the IPv4 timestamp option value */
 		std::vector<IPv4Address> ipAddresses;
 
 		/** The default constructor */
 		IPv4TimestampOptionValue() : type(IPv4TimestampOptionValue::Unknown) {}
 
 		/**
 		 * Clear the structure. Clean the timestamps and IP addresses vectors and set the type as IPv4TimestampOptionValue#Unknown
 		 */
 		void clear()
 		{
 			type = IPv4TimestampOptionValue::Unknown;
 			timestamps.clear();
 			ipAddresses.clear();
 		}
 	};
 
 
 	/**
 	 * @class IPv4Option
 	 * A wrapper class for IPv4 options. This class does not create or modify IPv4 option records, but rather
 	 * serves as a wrapper and provides useful methods for retrieving data from them
 	 */
 	class IPv4Option : public TLVRecord<uint8_t, uint8_t>
 	{
 	public:
 
 		/**
 		 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 		 * @param[in] optionRawData A pointer to the IPv4 option raw data
 		 */
 		explicit IPv4Option(uint8_t* optionRawData) : TLVRecord(optionRawData) { }
 
 		/**
 		 * A d'tor for this class, currently does nothing
 		 */
 		~IPv4Option() { }
 
 		/**
 		 * A method for parsing the IPv4 option value as a list of IPv4 addresses. This method is relevant only for certain types of IPv4 options which their value is a list of IPv4 addresses
 		 * such as ::IPV4OPT_RecordRoute, ::IPV4OPT_StrictSourceRoute, ::IPV4OPT_LooseSourceRoute, etc. This method returns a vector of the IPv4 addresses. Blank IP addresses
 		 * (meaning zeroed addresses - 0.0.0.0) will not be added to the returned list. If some error occurs during the parsing or the value is invalid an empty vector is returned
 		 * @return A vector of IPv4 addresses parsed from the IPv4 option value
 		 */
 		std::vector<IPv4Address> getValueAsIpList() const
 		{
 			std::vector<IPv4Address> res;
 
 			if (m_Data == nullptr)
 				return res;
 
 			size_t dataSize = getDataSize();
 			if (dataSize < 2)
 				return res;
 
 			uint8_t valueOffset = (uint8_t)(1);
 
 			while ((size_t)valueOffset < dataSize)
 			{
 				uint32_t curValue;
 				memcpy(&curValue, m_Data->recordValue + valueOffset, sizeof(uint32_t));
 				if (curValue == 0)
 					break;
 
 				res.push_back(IPv4Address(curValue));
 
 				valueOffset += (uint8_t)(4);
 			}
 
 			return res;
 		}
 
 		/**
 		 * A method for parsing the IPv4 timestamp option value. This method is relevant only for IPv4 timestamp option. For other option types an empty result will be returned.
 		 * The returned structure contains the timestamp value type (timestamp only, timestamp + IP addresses, etc.) as well as 2 vectors containing the list of timestamps and the list
 		 * of IP addresses (if applicable for the timestamp value type). Blank timestamps or IP addresses (meaning zeroed values - timestamp=0 or IP address=0.0.0.0) will not be added to
 		 * the lists. If some error occurs during the parsing or the value is invalid an empty result is returned
 		 * @return A structured containing the IPv4 timestamp value
 		 */
 		IPv4TimestampOptionValue getTimestampOptionValue() const
 		{
 			IPv4TimestampOptionValue res;
 			res.clear();
 
 			if (m_Data == nullptr)
 				return res;
 
 			if (getIPv4OptionType() != IPV4OPT_Timestamp)
 				return res;
 
 			size_t dataSize =  getDataSize();
 			if (dataSize < 2)
 				return res;
 
 			res.type = (IPv4TimestampOptionValue::TimestampType)m_Data->recordValue[1];
 
 			uint8_t valueOffset = (uint8_t)(2);
 			bool readIPAddr = (res.type == IPv4TimestampOptionValue::TimestampAndIP);
 
 			while ((size_t)valueOffset < dataSize)
 			{
 				uint32_t curValue;
 				memcpy(&curValue, m_Data->recordValue + valueOffset, sizeof(uint32_t));
 				if (curValue == 0)
 					break;
 
 				if (readIPAddr)
 					res.ipAddresses.push_back(IPv4Address(curValue));
 				else
 					res.timestamps.push_back(curValue);
 
 				if (res.type == IPv4TimestampOptionValue::TimestampAndIP)
 					readIPAddr = !readIPAddr;
 
 				valueOffset += (uint8_t)(4);
 			}
 
 			return res;
 		}
 
 		/**
 		 * @return IPv4 option type casted as pcpp::IPv4OptionTypes enum
 		 */
 		IPv4OptionTypes getIPv4OptionType() const
 		{
-			if (m_Data == nullptr)
-				return IPV4OPT_Unknown;
-
-			return (IPv4OptionTypes)m_Data->recordType;
+			return getIPv4OptionType(m_Data);
 		}
 
+		/**
+		 * Check if a pointer can be assigned to the TLV record data
+		 * @param[in] recordRawData A pointer to the TLV record raw data
+		 * @param[in] tlvDataLen The size of the TLV record raw data
+		 * @return True if data is valid and can be assigned
+		 */
+		static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+		{
+			auto data = (TLVRawData*)recordRawData;
+			if (data == nullptr)
+				return false;
+
+			if (tlvDataLen < sizeof(TLVRawData::recordType))
+				return false;
+
+			if (getIPv4OptionType(data) == (uint8_t)IPV4OPT_EndOfOptionsList || data->recordType == (uint8_t)IPV4OPT_NOP)
+				return true;
+
+			return TLVRecord<uint8_t, uint8_t>::canAssign(recordRawData, tlvDataLen);
+		}
 
 		// implement abstract methods
 
 		size_t getTotalSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (getIPv4OptionType() == (uint8_t)IPV4OPT_EndOfOptionsList || m_Data->recordType == (uint8_t)IPV4OPT_NOP)
 				return sizeof(uint8_t);
 
 			return (size_t)m_Data->recordLen;
 		}
 
 		size_t getDataSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (getIPv4OptionType() == (uint8_t)IPV4OPT_EndOfOptionsList || m_Data->recordType == (uint8_t)IPV4OPT_NOP)
 				return (size_t)0;
 
 			return (size_t)m_Data->recordLen - (2*sizeof(uint8_t));
 		}
+
+	private:
+		/**
+		 * @return IPv4 option type casted as pcpp::IPv4OptionTypes enum
+		 */
+		static IPv4OptionTypes getIPv4OptionType(const TLVRawData* data)
+		{
+			if (data == nullptr)
+				return IPV4OPT_Unknown;
+
+			return (IPv4OptionTypes)data->recordType;
+		}
 	};
 
 
 	/**
 	 * @class IPv4OptionBuilder
 	 * A class for building IPv4 option records. This builder receives the IPv4 option parameters in its c'tor,
 	 * builds the IPv4 option raw buffer and provides a build() method to get a IPv4Option object out of it
 	 */
 	class IPv4OptionBuilder : public TLVRecordBuilder
 	{
 	private:
 		bool m_BuilderParamsValid;
 
 	public:
 
 		/**
 		 * A c'tor for building IPv4 options which their value is a byte array. The IPv4Option object can be later
 		 * retrieved by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] optionValue A buffer containing the option value. This buffer is read-only and isn't modified in any way.
 		 * For option types ::IPV4OPT_NOP and ::IPV4OPT_EndOfOptionsList this parameter is ignored (expected to be NULL) as these
 		 * option types don't contain any data
 		 * @param[in] optionValueLen Option value length in bytes
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, const uint8_t* optionValue, uint8_t optionValueLen) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue, optionValueLen) { m_BuilderParamsValid = true; }
 
 		/**
 		 * A c'tor for building IPv4 options which have a 2-byte value. The IPv4Option object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] optionValue A 2-byte option value
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, uint16_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { m_BuilderParamsValid = true; }
 
 		/**
 		 * A c'tor for building IPv4 options which their value is a list of IPv4 addresses, for example:
 		 * ::IPV4OPT_RecordRoute, ::IPV4OPT_StrictSourceRoute, ::IPV4OPT_LooseSourceRoute. The IPv4Option object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] ipList A vector of IPv4 addresses that will be used as the option value
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, const std::vector<IPv4Address>& ipList);
 
 		/**
 		 * A c'tor for building IPv4 timestamp option (::IPV4OPT_Timestamp). The IPv4Option object can be later retrieved by calling build()
 		 * @param[in] timestampValue The timestamp value to build the IPv4 option with
 		 */
 		explicit IPv4OptionBuilder(const IPv4TimestampOptionValue& timestampValue);
 
 		/**
 		 * Build the IPv4Option object out of the parameters defined in the c'tor
 		 * @return The IPv4Option object
 		 */
 		IPv4Option build() const;
 	};
 
 
 	/**
 	 * @class IPv4Layer
 	 * Represents an IPv4 protocol layer
 	 */
 	class IPv4Layer : public Layer, public IPLayer
 	{
 	public:
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref iphdr)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		IPv4Layer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
 
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref iphdr)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 * @param[in] setTotalLenAsDataLen When setting this value to "true" or when using the other c'tor, the layer data length is calculated
 		 * from iphdr#totalLength field. When setting to "false" the data length is set as the value of dataLen parameter. Please notice that
 		 * if iphdr#totalLength is equal to zero (which can happen in TCP Segmentation Offloading), this flag is ignored and the layer data
 		 * length is calculated by the actual data captured on the wire
 		 */
 		IPv4Layer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet, bool setTotalLenAsDataLen);
 
 
 		/**
 		 * A constructor that allocates a new IPv4 header with empty fields
 		 */
 		IPv4Layer();
 
 		/**
 		 * A constructor that allocates a new IPv4 header with source and destination IPv4 addresses
 		 * @param[in] srcIP Source IPv4 address
 		 * @param[in] dstIP Destination IPv4 address
 		 */
 		IPv4Layer(const IPv4Address& srcIP, const IPv4Address& dstIP);
 
 		/**
 		 * A copy constructor that copy the entire header from the other IPv4Layer (including IPv4 options)
 		 */
 		IPv4Layer(const IPv4Layer& other);
 
 		/**
 		 * An assignment operator that first delete all data from current layer and then copy the entire header from the other IPv4Layer (including IPv4 options)
 		 */
 		IPv4Layer& operator=(const IPv4Layer& other);
 
 		/**
 		 * Get a pointer to the IPv4 header. Notice this points directly to the data, so every change will change the actual packet data
 		 * @return A pointer to the @ref iphdr
 		 */
 		iphdr* getIPv4Header() const { return (iphdr*)m_Data; }
 
 		/**
 		 * Get the source IP address in the form of IPAddress. This method is very similar to getSrcIPv4Address(),
 		 * but adds a level of abstraction because IPAddress can be used for both IPv4 and IPv6 addresses
 		 * @return An IPAddress containing the source address
 		 */
 		IPAddress getSrcIPAddress() const { return getSrcIPv4Address(); }
 
 		/**
 		 * Get the source IP address in the form of IPv4Address
 		 * @return An IPv4Address containing the source address
 		 */
 		IPv4Address getSrcIPv4Address() const { return getIPv4Header()->ipSrc; }
 
 		/**
 		 * Set the source IP address
 		 * @param[in] ipAddr The IP address to set
 		 */
 		void setSrcIPv4Address(const IPv4Address& ipAddr) { getIPv4Header()->ipSrc = ipAddr.toInt(); }
 
 		/**
 		 * Get the destination IP address in the form of IPAddress. This method is very similar to getDstIPv4Address(),
 		 * but adds a level of abstraction because IPAddress can be used for both IPv4 and IPv6 addresses
 		 * @return An IPAddress containing the destination address
 		 */
 		IPAddress getDstIPAddress() const { return getDstIPv4Address(); }
 
 		/**
 		 * Get the destination IP address in the form of IPv4Address
 		 * @return An IPv4Address containing the destination address
 		 */
 		IPv4Address getDstIPv4Address() const { return getIPv4Header()->ipDst; }
 
 		/**
 		 * Set the dest IP address
 		 * @param[in] ipAddr The IP address to set
 		 */
 		void setDstIPv4Address(const IPv4Address& ipAddr) { getIPv4Header()->ipDst = ipAddr.toInt(); }
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation), false otherwise
 		 */
 		bool isFragment() const;
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation) and is the first fragment
 		 * (which usually contains the L4 header). Return false otherwise (not a fragment or not the first fragment)
 		 */
 		bool isFirstFragment() const;
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation) and is the last fragment.
 		 * Return false otherwise (not a fragment or not the last fragment)
 		 */
 		bool isLastFragment() const;
 
 		/**
 		 * @return A bitmask containing the fragmentation flags (e.g IP_DONT_FRAGMENT or IP_MORE_FRAGMENTS)
 		 */
 		uint8_t getFragmentFlags() const;
 
 		/**
 		 * @return The fragment offset in case this packet is a fragment, 0 otherwise
 		 */
 		uint16_t getFragmentOffset() const;
 
 		/**
 		 * Get an IPv4 option by type.
 		 * @param[in] option IPv4 option type
 		 * @return An IPv4Option object that contains the first option that matches this type, or logical NULL
 		 * (IPv4Option#isNull() == true) if no such option found
 		 */
 		IPv4Option getOption(IPv4OptionTypes option) const;
 
 		/**
 		 * @return The first IPv4 option in the packet. If the current layer contains no options the returned value will contain
 		 * a logical NULL (IPv4Option#isNull() == true)
 		 */
 		IPv4Option getFirstOption() const;
 
 		/**
 		 * Get the IPv4 option that comes after a given option. If the given option was the last one, the
 		 * returned value will contain a logical NULL (IPv4Option#isNull() == true)
 		 * @param[in] option An IPv4 option object that exists in the current layer
 		 * @return A IPv4Option object that contains the IPv4 option data that comes next, or logical NULL if the given
 		 * IPv4 option: (1) was the last one; or (2) contains a logical NULL; or (3) doesn't belong to this packet
 		 */
 		IPv4Option getNextOption(IPv4Option& option) const;
 
 		/**
 		 * @return The number of IPv4 options in this layer
 		 */
 		size_t getOptionCount() const;
 
 		/**
 		 * Add a new IPv4 option at the end of the layer (after the last IPv4 option)
 		 * @param[in] optionBuilder An IPv4OptionBuilder object that contains the IPv4 option data to be added
 		 * @return A IPv4Option object that contains the newly added IPv4 option data or logical NULL
 		 * (IPv4Option#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		IPv4Option addOption(const IPv4OptionBuilder& optionBuilder);
 
 		/**
 		 * Add a new IPv4 option after an existing one
 		 * @param[in] optionBuilder An IPv4OptionBuilder object that contains the requested IPv4 option data to be added
 		 * @param[in] prevOptionType The IPv4 option which the newly added option should come after. This is an optional parameter which
 		 * gets a default value of ::IPV4OPT_Unknown if omitted, which means the new option will be added as the first option in the layer
 		 * @return A IPv4Option object containing the newly added IPv4 option data or logical NULL
 		 * (IPv4Option#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		IPv4Option addOptionAfter(const IPv4OptionBuilder& optionBuilder, IPv4OptionTypes prevOptionType = IPV4OPT_Unknown);
 
 		/**
 		 * Remove an IPv4 option
 		 * @param[in] option The option type to remove
 		 * @return True if option was removed successfully or false if option type wasn't found or failed to shorten the layer. If an option appears twice in the layer, its first instance
 		 * will be removed
 		 */
 		bool removeOption(IPv4OptionTypes option);
 
 		/**
 		 * Remove all IPv4 options from the layer
 		 * @return True if options removed successfully or false if some error occurred (an appropriate error message will be printed to log)
 		 */
 		bool removeAllOptions();
 
 
 		// implement abstract methods
 
 		/**
 		 * Currently identifies the following next layers:
 		 * - UdpLayer
 		 * - TcpLayer
 		 * - IcmpLayer
 		 * - IPv4Layer (IP-in-IP)
 		 * - IPv6Layer (IP-in-IP)
 		 * - GreLayer
 		 * - IgmpLayer
 		 * - AuthenticationHeaderLayer (IPSec)
 		 * - ESPLayer (IPSec)
 		 *
 		 * Otherwise sets PayloadLayer
 		 */
 		void parseNextLayer();
 
 		/**
 		 * @return Size of IPv4 header (including IPv4 options if exist)
 		 */
 		size_t getHeaderLen() const { return (size_t)((uint16_t)(getIPv4Header()->internetHeaderLength) * 4) + m_TempHeaderExtension; }
 
 		/**
 		 * Calculate the following fields:
 		 * - iphdr#ipVersion = 4;
 		 * - iphdr#totalLength = total packet length
 		 * - iphdr#headerChecksum = calculated
 		 * - iphdr#protocol = calculated if next layer is known: ::PACKETPP_IPPROTO_TCP for TCP, ::PACKETPP_IPPROTO_UDP for UDP, ::PACKETPP_IPPROTO_ICMP for ICMP
 		 */
 		void computeCalculateFields();
 
 		std::string toString() const;
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelNetworkLayer; }
 
 		/**
 		 * A static method that validates the input data
 		 * @param[in] data The pointer to the beginning of a byte stream of IP packet
 		 * @param[in] dataLen The length of the byte stream
 		 * @return True if the data is valid and can represent an IPv4 packet
 		 */
 		static inline bool isDataValid(const uint8_t* data, size_t dataLen);
 
 	private:
 		int m_NumOfTrailingBytes;
 		int m_TempHeaderExtension;
 		TLVRecordReader<IPv4Option> m_OptionReader;
 
 		void copyLayerData(const IPv4Layer& other);
 		uint8_t* getOptionsBasePtr() const { return m_Data + sizeof(iphdr); }
 		IPv4Option addOptionAt(const IPv4OptionBuilder& optionBuilder, int offset);
 		void adjustOptionsTrailer(size_t totalOptSize);
 		void initLayer();
 		void initLayerInPacket(bool setTotalLenAsDataLen);
 	};
 
 
 	// implementation of inline methods
 
 	bool IPv4Layer::isDataValid(const uint8_t* data, size_t dataLen)
 	{
 		const iphdr* hdr = reinterpret_cast<const iphdr*>(data);
 		return dataLen >= sizeof(iphdr) && hdr->ipVersion == 4 && hdr->internetHeaderLength >= 5;
 	}
 
 } // namespace pcpp
 
 #endif /* PACKETPP_IPV4_LAYER */
diff --git a/Packet++/header/IPv6Extensions.h b/Packet++/header/IPv6Extensions.h
index a9df47c3..6e48695c 100644
--- a/Packet++/header/IPv6Extensions.h
+++ b/Packet++/header/IPv6Extensions.h
@@ -11,529 +11,550 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @class IPv6Extension
 	 * A base class for all supported IPv6 extensions. This class is abstract, meaning it cannot be instantiated or copied
 	 * (has private c'tor and copy c'tor)
 	 */
 	class IPv6Extension
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * An enum representing all supported IPv6 extension types
 		 */
 		enum IPv6ExtensionType
 		{
 			/** Hop-By-Hop extension type */
 			IPv6HopByHop = 0,
 			/** Routing extension type */
 			IPv6Routing = 43,
 			/** IPv6 fragmentation extension type */
 			IPv6Fragmentation = 44,
 			/** Authentication Header extension type */
 			IPv6AuthenticationHdr = 51,
 			/** Destination extension type */
 			IPv6Destination = 60,
 			/** Unknown or unsupported extension type */
 			IPv6ExtensionUnknown = 255
 		};
 
 		/**
 		 * @return The size of extension in bytes, meaning (for most extensions): 8 * ([headerLen field] + 1)
 		 */
 		virtual size_t getExtensionLen() const { return 8 * (getBaseHeader()->headerLen+1); }
 
 		/**
 		 * @return The type of the extension
 		 */
 		IPv6ExtensionType getExtensionType() const { return m_ExtType; }
 
 		/**
 		 * A destructor for this class
 		 */
 		virtual ~IPv6Extension();
 
 		/**
 		 * @return A pointer to the next header or NULL if the extension is the last one
 		 */
 		IPv6Extension* getNextHeader() const { return m_NextHeader; }
 
 	protected:
 
 		struct ipv6_ext_base_header
 		{
 			uint8_t nextHeader;
 			uint8_t headerLen;
 		};
 
 		// protected c'tor
 		IPv6Extension(IDataContainer* dataContainer, size_t offset) :
 			m_NextHeader(NULL), m_ExtType(IPv6ExtensionUnknown), m_DataContainer(dataContainer), m_Offset(offset), m_ShadowData(NULL) {}
 
 		// protected empty c'tor
 		IPv6Extension() :
 			m_NextHeader(NULL), m_ExtType(IPv6ExtensionUnknown), m_DataContainer(NULL), m_Offset(0), m_ShadowData(NULL) {}
 
 		// protected assignment operator
 		IPv6Extension& operator=(const IPv6Extension& other);
 
 		uint8_t* getDataPtr() const;
 
 		void initShadowPtr(size_t size);
 
 		ipv6_ext_base_header* getBaseHeader() const { return (ipv6_ext_base_header*)getDataPtr(); }
 
 		void setNextHeader(IPv6Extension* nextHeader) { m_NextHeader = nextHeader; }
 
 		IPv6Extension* m_NextHeader;
 		IPv6ExtensionType m_ExtType;
 
 	private:
 		IDataContainer* m_DataContainer;
 		size_t m_Offset;
 		uint8_t* m_ShadowData;
 
 	};
 
 
 
 	/**
 	 * @class IPv6FragmentationHeader
 	 * Represents an IPv6 fragmentation extension header and allows easy access to all fragmentation parameters
 	 */
 	class IPv6FragmentationHeader : public IPv6Extension
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * @struct ipv6_frag_header
 		 * A struct representing IPv6 fragmentation header
 		 */
 		struct ipv6_frag_header
 		{
 			/** Next header type */
 			uint8_t nextHeader;
 			/** Fragmentation header size is fixed 8 bytes, so len is always zero */
 			uint8_t headerLen;
 			/** Offset, in 8-octet units, relative to the start of the fragmentable part of the original packet
 			 * plus 1-bit indicating if more fragments will follow */
 			uint16_t fragOffsetAndFlags;
 			/** packet identification value. Needed for reassembly of the original packet */
 			uint32_t id;
 		};
 
 		/**
 		 * A c'tor for creating a new IPv6 fragmentation extension object not bounded to a packet. Useful for adding new extensions to an
 		 * IPv6 layer with IPv6Layer#addExtension()
 		 * @param[in] fragId Fragmentation ID
 		 * @param[in] fragOffset Fragmentation offset
 		 * @param[in] lastFragment Indicates whether this fragment is the last one
 		 */
 		IPv6FragmentationHeader(uint32_t fragId, uint16_t fragOffset, bool lastFragment);
 
 		/**
 		 * Get a pointer to the fragmentation header. Notice the returned pointer points directly to the data, so every change will modify
 		 * the actual packet data
 		 * @return A pointer to the @ref ipv6_frag_header
 		 */
 		ipv6_frag_header* getFragHeader() const { return (ipv6_frag_header*)getDataPtr(); }
 
 		/**
 		 * @return True if this is the first fragment (which usually contains the L4 header), false otherwise
 		 */
 		bool isFirstFragment() const;
 
 		/**
 		 * @return True if this is the last fragment, false otherwise
 		 */
 		bool isLastFragment() const;
 
 		/**
 		 * @return True if the "more fragments" bit is set, meaning more fragments are expected to follow this fragment
 		 */
 		bool isMoreFragments() const;
 
 		/**
 		 * @return The fragment offset
 		 */
 		uint16_t getFragmentOffset() const;
 
 	private:
 
 		IPv6FragmentationHeader(IDataContainer* dataContainer, size_t offset) : IPv6Extension(dataContainer, offset)
 		{
 			m_ExtType = IPv6Fragmentation;
 		}
 
 	};
 
 
 	/**
 	 * An abstract base class for Hop-By-Hop and Destination IPv6 extensions which their structure contains Type-Length-Value (TLV) options.
 	 * This class provides access to these options and their data as well as methods to create new options. Notice this class is abstract
 	 * and cannot be instantiated
 	 */
 	class IPv6TLVOptionHeader : public IPv6Extension
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * @class IPv6Option
 		 * A class representing a Type-Length-Value (TLV) options that are used inside Hop-By-Hop and Destinations IPv6
 		 * extensions. This class does not create or modify IPv6 option records, but rather serves as a wrapper and
 		 * provides useful methods for retrieving data from them
 		 */
 		class IPv6Option : public TLVRecord<uint8_t, uint8_t>
 		{
 		public:
 
 			static const uint8_t Pad0OptionType = 0;
 			static const uint8_t PadNOptionType = 1;
 
 			/**
 			 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 			 * @param[in] optionRawData A pointer to the attribute raw data
 			 */
 			explicit IPv6Option(uint8_t* optionRawData) : TLVRecord(optionRawData) { }
 
 			/**
 			 * A d'tor for this class, currently does nothing
 			 */
 			~IPv6Option() { }
 
+			/**
+			 * Check if a pointer can be assigned to the TLV record data
+			 * @param[in] recordRawData A pointer to the TLV record raw data
+			 * @param[in] tlvDataLen The size of the TLV record raw data
+			 * @return True if data is valid and can be assigned
+			 */
+			static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+			{
+				auto data = (TLVRawData*)recordRawData;
+				if (data == nullptr)
+					return false;
+
+				if (tlvDataLen < sizeof(TLVRawData::recordType))
+					return false;
+
+				if (data->recordType == Pad0OptionType)
+					return true;
+
+				return TLVRecord<uint8_t, uint8_t>::canAssign(recordRawData, tlvDataLen);
+			}
+
 			// implement abstract methods
 
 			size_t getTotalSize() const
 			{
 				if (m_Data == nullptr)
 					return 0;
 
 				if (m_Data->recordType == Pad0OptionType)
 					return sizeof(uint8_t);
 
 				return (size_t)(m_Data->recordLen + sizeof(uint16_t));
 			}
 
 			size_t getDataSize() const
 			{
 				if (m_Data == nullptr || m_Data->recordType == Pad0OptionType)
 					return 0;
 
 				return (size_t)m_Data->recordLen;
 			}
 		};
 
 
 		/**
 		 * @class IPv6TLVOptionBuilder
 		 * A class for building IPv6 Type-Length-Value (TLV) options. This builder receives the option parameters in its c'tor,
 		 * builds the option raw buffer and provides a method to build a IPv6Option object out of it
 		 */
 		class IPv6TLVOptionBuilder : public TLVRecordBuilder
 		{
 		public:
 
 			/**
 			 * A c'tor for building IPv6 TLV options which their value is a byte array. The IPv6Option object can later
 			 * be retrieved by calling build()
 			 * @param[in] optType IPv6 option type
 			 * @param[in] optValue A buffer containing the option value. This buffer is read-only and isn't modified in any way
 			 * @param[in] optValueLen Option value length in bytes
 			 */
 			IPv6TLVOptionBuilder(uint8_t optType, const uint8_t* optValue, uint8_t optValueLen) :
 				TLVRecordBuilder(optType, optValue, optValueLen) { }
 
 			/**
 			 * A c'tor for building IPv6 TLV options which have a 1-byte value. The IPv6Option object can later be retrieved
 			 * by calling build()
 			 * @param[in] optType IPv6 option type
 			 * @param[in] optValue A 1-byte option value
 			 */
 			IPv6TLVOptionBuilder(uint8_t optType, uint8_t optValue) :
 				TLVRecordBuilder(optType, optValue) { }
 
 			/**
 			 * A c'tor for building IPv6 TLV options which have a 2-byte value. The IPv6Option object can later be retrieved
 			 * by calling build()
 			 * @param[in] optType IPv6 option type
 			 * @param[in] optValue A 2-byte option value
 			 */
 			IPv6TLVOptionBuilder(uint8_t optType, uint16_t optValue) :
 				TLVRecordBuilder(optType, optValue) { }
 
 			/**
 			 * A copy c'tor that creates an instance of this class out of another instance and copies all the data from it
 			 * @param[in] other The instance to copy data from
 			 */
 			IPv6TLVOptionBuilder(const IPv6TLVOptionBuilder& other) :
 				TLVRecordBuilder(other) {}
 
 			/**
 			 * Assignment operator that copies all data from another instance of IPv6TLVOptionBuilder
 			 * @param[in] other The instance to assign from
 			 */
 			IPv6TLVOptionBuilder& operator=(const IPv6TLVOptionBuilder& other)
 			{
 				TLVRecordBuilder::operator=(other);
 				return *this;
 			}
 
 			/**
 			 * Build the IPv6Option object out of the parameters defined in the c'tor
 			 * @return The IPv6Option object
 			 */
 			IPv6Option build() const;
 		};
 
 		/**
 		 * Retrieve an option by its type
 		 * @param[in] optionType Option type
 		 * @return An IPv6Option object that wraps the option data. If option isn't found a logical NULL is returned
 		 * (IPv6Option#isNull() == true)
 		 */
 		IPv6Option getOption(uint8_t optionType) const;
 
 		/**
 		 * @return An IPv6Option that wraps the first option data or logical NULL (IPv6Option#isNull() == true) if no options exist
 		 */
 		IPv6Option getFirstOption() const;
 
 		/**
 		 * Returns a pointer to the option that comes after the option given as the parameter
 		 * @param[in] option A pointer to an option instance
 		 * @return An IPv6Option object that wraps the option data. In the following cases logical NULL (IPv6Option#isNull() == true)
 		 * is returned:
 		 * (1) input parameter is out-of-bounds for this extension or
 		 * (2) the next option doesn't exist or
 		 * (3) the input option is NULL
 		 */
 		IPv6Option getNextOption(IPv6Option& option) const;
 
 		/**
 		 * @returns The number of options this IPv6 extension contains
 		 */
 		size_t getOptionCount() const;
 
 	protected:
 
 		/** A private c'tor to keep this object from being constructed */
 		explicit IPv6TLVOptionHeader(const std::vector<IPv6TLVOptionBuilder>& options);
 
 		IPv6TLVOptionHeader(IDataContainer* dataContainer, size_t offset);
 
 	private:
 
 		TLVRecordReader<IPv6Option> m_OptionReader;
 	};
 
 
 
 	/**
 	 * @class IPv6HopByHopHeader
 	 * Represents IPv6 Hop-By-Hop extension header and allows easy access to all of its data including the TLV options stored
 	 */
 	class IPv6HopByHopHeader : public IPv6TLVOptionHeader
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * A c'tor for creating a new IPv6 Hop-By-Hop extension object not bounded to a packet. Useful for adding new extensions to an
 		 * IPv6 layer with IPv6Layer#addExtension()
 		 * @param[in] options A vector of IPv6TLVOptionHeader#TLVOptionBuilder instances which define the options that will be stored in the
 		 * extension data. Notice this vector is read-only and its content won't be modified
 		 */
 		explicit IPv6HopByHopHeader(const std::vector<IPv6TLVOptionBuilder>& options) : IPv6TLVOptionHeader(options) { m_ExtType = IPv6HopByHop; }
 
 	private:
 
 		IPv6HopByHopHeader(IDataContainer* dataContainer, size_t offset) : IPv6TLVOptionHeader(dataContainer, offset) { m_ExtType = IPv6HopByHop; }
 	};
 
 
 
 	/**
 	 * @class IPv6DestinationHeader
 	 * Represents IPv6 destination extension header and allows easy access to all of its data including the TLV options stored in it
 	 */
 	class IPv6DestinationHeader : public IPv6TLVOptionHeader
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * A c'tor for creating a new IPv6 destination extension object not bounded to a packet. Useful for adding new extensions to an
 		 * IPv6 layer with IPv6Layer#addExtension()
 		 * @param[in] options A vector of IPv6TLVOptionHeader#TLVOptionBuilder instances which define the options that will be stored in the
 		 * extension data. Notice this vector is read-only and its content won't be modified
 		 */
 		explicit IPv6DestinationHeader(const std::vector<IPv6TLVOptionBuilder>& options) : IPv6TLVOptionHeader(options) { m_ExtType = IPv6Destination; }
 
 	private:
 
 		IPv6DestinationHeader(IDataContainer* dataContainer, size_t offset) : IPv6TLVOptionHeader(dataContainer, offset) { m_ExtType = IPv6Destination; }
 	};
 
 
 
 	/**
 	 * @class IPv6RoutingHeader
 	 * Represents IPv6 routing extension header and allows easy access to all of its data
 	 */
 	class IPv6RoutingHeader : public IPv6Extension
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * @struct ipv6_routing_header
 		 * A struct representing the fixed part of the IPv6 routing extension header
 		 */
 		struct ipv6_routing_header
 		{
 			/** Next header type */
 			uint8_t nextHeader;
 			/** The length of this header, in multiples of 8 octets, not including the first 8 octets */
 			uint8_t headerLen;
 			/** A value representing the routing type */
 			uint8_t routingType;
 			/** Number of nodes this packet still has to visit before reaching its final destination */
 			uint8_t segmentsLeft;
 		};
 
 		/**
 		 * A c'tor for creating a new IPv6 routing extension object not bounded to a packet. Useful for adding new extensions to an
 		 * IPv6 layer with IPv6Layer#addExtension()
 		 * @param[in] routingType Routing type value (will be written to ipv6_routing_header#routingType field)
 		 * @param[in] segmentsLeft Segments left value (will be written to ipv6_routing_header#segmentsLeft field)
 		 * @param[in] additionalRoutingData A pointer to a buffer containing the additional routing data for this extension. Notice this
 		 * buffer is read-only and its content isn't modified
 		 * @param[in] additionalRoutingDataLen The length of the additional routing data buffer
 		 */
 		IPv6RoutingHeader(uint8_t routingType, uint8_t segmentsLeft, const uint8_t* additionalRoutingData, size_t additionalRoutingDataLen);
 
 		/**
 		 * Get a pointer to the fixed part of the routing header. Notice the return pointer points directly to the data, so every change will modify
 		 * the actual packet data
 		 * @return A pointer to the @ref ipv6_routing_header
 		 */
 		ipv6_routing_header* getRoutingHeader() const { return (ipv6_routing_header*)getDataPtr(); }
 
 		/**
 		 * @return A pointer to the buffer containing the additional routing data for this extension. Notice that any change in this buffer
 		 * will lead to a change in the extension data
 		 */
 		uint8_t* getRoutingAdditionalData() const;
 
 		/**
 		 * @return The length of the additional routing parameters buffer
 		 */
 		size_t getRoutingAdditionalDataLength() const;
 
 		/**
 		 * In many cases the additional routing data is actually IPv6 address(es). This method converts the raw buffer data into an IPv6 address
 		 * @param[in] offset An offset in the additional routing buffer pointing to where the IPv6 address begins. In some cases there are
 		 * multiple IPv6 addresses in the additional routing data buffer so this offset points to where the request IPv6 address begins. Also,
 		 * even if there is only one IPv6 address in this buffer, sometimes it isn't written in the beginning of the buffer, so the offset points
 		 * to where the IPv6 address begins. This is an optional parameter and the default offset is 0
 		 * @return The IPv6 address stored in the additional routing data buffer from the offset defined by the user. If offset is out-of-bounds
 		 * of the extension of doesn't have 16 bytes (== the length of IPv6 address) until the end of the buffer - IPv6Address#Zero is returned
 		 */
 		IPv6Address getRoutingAdditionalDataAsIPv6Address(size_t offset = 0) const;
 
 	private:
 
 		IPv6RoutingHeader(IDataContainer* dataContainer, size_t offset) : IPv6Extension(dataContainer, offset) { m_ExtType = IPv6Routing; }
 
 	};
 
 
 	/**
 	 * @class IPv6AuthenticationHeader
 	 * Represents IPv6 authentication header extension (used in IPSec protocol) and allows easy access to all of its data
 	 */
 	class IPv6AuthenticationHeader : public IPv6Extension
 	{
 		friend class IPv6Layer;
 
 	public:
 
 		/**
 		 * @struct ipv6_authentication_header
 		 * A struct representing the fixed part of the IPv6 authentication header extension
 		 */
 		struct ipv6_authentication_header
 		{
 			/** Next header type */
 			uint8_t nextHeader;
 			/** The length of this Authentication Header in 4-octet units, minus 2. For example, an AH value of 4
 			 * equals: [ 3(32-bit fixed-length AH fields) + 3(32-bit ICV fields)  2 ] and thus an AH value of 4 means 24 octets */
 			uint8_t headerLen;
 			/** Reserved bytes, all zeros */
 			uint16_t reserved;
 			/** Arbitrary value which is used (together with the destination IP address) to identify the security association of the receiving party */
 			uint32_t securityParametersIndex;
 			/** A monotonic strictly increasing sequence number (incremented by 1 for every packet sent) */
 			uint32_t sequenceNumber;
 		};
 
 		/**
 		 * A c'tor for creating a new IPv6 authentication header extension object not bounded to a packet. Useful for adding new extensions to an
 		 * IPv6 layer with IPv6Layer#addExtension()
 		 * @param[in] securityParametersIndex Security Parameters Index (SPI) value (will be written to ipv6_authentication_header#securityParametersIndex field)
 		 * @param[in] sequenceNumber Sequence number value (will be written to ipv6_authentication_header#sequenceNumber field)
 		 * @param[in] integrityCheckValue A pointer to a buffer containing the integrity check value (ICV) data for this extension. Notice this
 		 * pointer is read-only and its content isn't modified in any way
 		 * @param[in] integrityCheckValueLen The length of the integrity check value (ICV) buffer
 		 */
 		IPv6AuthenticationHeader(uint32_t securityParametersIndex, uint32_t sequenceNumber, const uint8_t* integrityCheckValue, size_t integrityCheckValueLen);
 
 		/**
 		 * Get a pointer to the fixed part of the authentication header. Notice the return pointer points directly to the data, so every change
 		 * will modify the actual packet data
 		 * @return A pointer to the @ref ipv6_authentication_header
 		 */
 		ipv6_authentication_header* getAuthHeader() const { return (ipv6_authentication_header*)getDataPtr(); }
 
 		/**
 		 * @return A pointer to the buffer containing the integrity check value (ICV) for this extension. Notice that any change in this buffer
 		 * will lead to a change in the extension data
 		 */
 		uint8_t* getIntegrityCheckValue() const;
 
 		/**
 		 * @return The length of the integrity check value (ICV) buffer
 		 */
 		size_t getIntegrityCheckValueLength() const;
 
 		// overridden methods
 
 		/**
 		 * In the authentication header the extension length is calculated in a different way than other extensions. The
 		 * calculation is: [ 4 * (ipv6_authentication_header#headerLen + 2) ]
 		 * @return The length of this extension
 		 */
 		size_t getExtensionLen() const { return 4 * (getBaseHeader()->headerLen+2); }
 
 	private:
 
 		IPv6AuthenticationHeader(IDataContainer* dataContainer, size_t offset) : IPv6Extension(dataContainer, offset) { m_ExtType = IPv6AuthenticationHdr; }
 	};
 
 }
 
 #endif // PACKETPP_IPV6_EXTENSION
diff --git a/Packet++/header/NflogLayer.h b/Packet++/header/NflogLayer.h
index 5df6358f..c93d3064 100644
--- a/Packet++/header/NflogLayer.h
+++ b/Packet++/header/NflogLayer.h
@@ -10,222 +10,233 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 	/**
 	 * @struct nflog_header
 	 * Represents Nflog header
 	 */
 #pragma pack(push, 1)
 	struct nflog_header
 	{
 		/** A Linux AF_ value, so it's 2 for IPv4 and 10 for IPv6 */
 		uint8_t addressFamily;
 		/** The version field is 0 for the current version of the pseudo-header */
 		uint8_t version;
 		/** The network byte order (big-endian) */
 		uint16_t resourceId;
 	};
 #pragma pack(pop)
 
 	/**
 	 * @enum NflogTlvType
 	 * Represents TLV types of NFLOG packets
 	*/
 	enum class NflogTlvType
 	{
 		/** the packet header structure */
 		NFULA_PACKET_HDR			= 1,
 		/** packet mark from skbuff */
 		NFULA_MARK					= 2,
 		/** nflog_timestamp_t for skbuff's time stamp */
  		NFULA_TIMESTAMP				= 3,
 		/** ifindex of device on which packet received (possibly bridge group) */
  		NFULA_IFINDEX_INDEV			= 4,
 		/** ifindex of device on which packet transmitted (possibly bridge group) */
  		NFULA_IFINDEX_OUTDEV		= 5,
 		/** ifindex of physical device on which packet received (not bridge group) */
  		NFULA_IFINDEX_PHYSINDEV		= 6,
 		/** ifindex of physical device on which packet transmitted (not bridge group) */
  		NFULA_IFINDEX_PHYSOUTDEV	= 7,
 		/** nflog_hwaddr_t for hardware address */
  		NFULA_HWADDR				= 8,
 		/** packet payload */
  		NFULA_PAYLOAD				= 9,
 		/** text string - null-terminated, count includes NUL */
  		NFULA_PREFIX				= 10,
 		/** UID owning socket on which packet was sent/received */
  		NFULA_UID					= 11,
 		/** sequence number of packets on this NFLOG socket */
  		NFULA_SEQ					= 12,
 		/** sequence number of packets on all NFLOG sockets */
  		NFULA_SEQ_GLOBAL			= 13,
 		/** GID owning socket on which packet was sent/received */
  		NFULA_GID					= 14,
 		/** ARPHRD_ type of skbuff's device */
  		NFULA_HWTYPE				= 15,
 		/** skbuff's MAC-layer header */
  		NFULA_HWHEADER				= 16,
 		/** length of skbuff's MAC-layer header */
  		NFULA_HWLEN					= 17,
 	};
 
 	/**
 	 * @class NflogTlv
 	 * A wrapper class for NFLOG TLV fields. This class does not create or modify TLVs related to NFLOG, but rather
 	 * serves as a wrapper and provides useful methods for setting and retrieving data to/from them
 	 */
 	class NflogTlv
 	{
 	private:
 		struct NflogTLVRawData
 		{
 			/** Record length in bytes */
 			uint16_t recordLen;
 			/** Record type */
 			uint16_t recordType;
 			/** Record value (variable size) */
 			uint8_t recordValue[];
 		};
 		NflogTLVRawData* m_Data;
 	public:
 		/**
 		 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 		 * @param[in] recordRawData A pointer to the option raw data
 		 */
 		explicit NflogTlv(uint8_t* recordRawData)
 		{
 			assign(recordRawData);
 		}
 
 		/**
 		 * @return recordLen attribute in NflogTLVRawData
 		 */
 		size_t getTotalSize() const
 		{
 			// as in https://github.com/the-tcpdump-group/libpcap/blob/766b607d60d8038087b49fc4cf433dac3dcdb49c/pcap-util.c#L371-L374
 			return align<4>(m_Data->recordLen);
 		}
 
 		/**
 		 * Assign a pointer to the TLV record raw data (byte array)
 		 * @param[in] recordRawData A pointer to the TLV record raw data
 		 */
 		void assign(uint8_t* recordRawData)
 		{
 			m_Data = (NflogTLVRawData*)recordRawData;
 		}
 
+		/**
+		 * Check if a pointer can be assigned to the TLV record data
+		 * @param[in] recordRawData A pointer to the TLV record raw data
+		 * @param[in] tlvDataLen The size of the TLV record raw data
+		 * * @return True if data is valid and can be assigned
+		 */
+		static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+		{
+			return recordRawData != nullptr && tlvDataLen >= sizeof(NflogTLVRawData::recordLen);
+		}
+
 		/**
 		 * @return True if the TLV record raw data is nullptr, false otherwise
 		 */
 		bool isNull() const
 		{
 			return (m_Data == nullptr);
 		}
 
 		/**
 		 * @return The type field of the record (the 'T' in __Type__-Length-Value)
 		 */
 		uint16_t getType() const { return m_Data->recordType; }
 
 		/**
 		 * @return A pointer to the TLV record raw data byte stream
 		 */
 		uint8_t* getRecordBasePtr() const { return (uint8_t*)m_Data; }
 
 		/**
 		 * @return A pointer to the value of the record as byte array (the 'V' in Type-Length- __Value__)
 		 */
 		uint8_t* getValue() const { return m_Data->recordValue; }
 	};
 
 	/**
 	 * @class NflogLayer
 	 * Represents an NFLOG protocol layer
 	 */
 	class NflogLayer : public Layer
 	{
 	public:
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to ether_header)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		NflogLayer(uint8_t* data, size_t dataLen, Packet* packet) : Layer(data, dataLen, NULL, packet) { m_Protocol = NFLOG; }
 
 		~NflogLayer() {}
 
 		/**
 		 * Get a pointer to the Nflog header.
 		 * @return A pointer to the nflog_header
 		 */
 		nflog_header* getNflogHeader() const { return (nflog_header*)m_Data; }
 
 		/**
 		 * Get address family of the packet. e.g. 2 for ipv4 and 10 for ipv6
 		 * @return an unsigned char of address family
 		*/
 		uint8_t getFamily();
 
 		/**
 		 * Get Version number inside packet header
 		 * The version field is 0 for the current version of the pseudo-header
 		 * @return an unsigned char for version
 		*/
 		uint8_t getVersion();
 
 		/**
 		 * Get Resource Id in packet header
 		 * On one netlink socket it's possible to listen to several nflog groups; the resource ID is the nflog group for the packet
 		*/
 		uint16_t getResourceId();
 
 		/**
 		 * Get a TLV object found with the input type. if no tlv is found, the internal value of the object will set to nullptr
 		 * @param[in] type type of tlv by using enum class defined as NflogTlvType
 		 * @return NflogTlv obtained by type
 		*/
 		NflogTlv getTlvByType(NflogTlvType type) const;
 
 		// implement abstract methods
 
 		/**
 		 * Currently identifies the following next layers: IPv4Layer, IPv6Layer using address family
 		 * Otherwise sets PayloadLayer
 		 */
 		void parseNextLayer();
 
 		/**
 		 * @return Size of nflog_header
 		 */
 		size_t getHeaderLen() const;
 
 		/**
 		 * Does nothing for this layer
 		*/
 		void computeCalculateFields() {};
 
 		std::string toString() const;
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelDataLinkLayer; }
 
 		/**
 		* A static method that validates the input data
 		* @param[in] data The pointer to the beginning of a byte stream of an NFLOG packet
 		* @param[in] dataLen The length of the byte stream
 		* @return True if the data is valid and can represent an NFLOG packet
 		*/
 		static bool isDataValid(const uint8_t* data, size_t dataLen);
 
 	private:
 		uint8_t* getTlvsBasePtr() const { return m_Data + sizeof(nflog_header); }
 
 		TLVRecordReader<NflogTlv> m_TlvReader;
 	};
 
 } // namespace pcpp
 
 #endif /* PACKETPP_NFLOG_LAYER */
diff --git a/Packet++/header/TLVData.h b/Packet++/header/TLVData.h
index f1731e43..84072931 100644
--- a/Packet++/header/TLVData.h
+++ b/Packet++/header/TLVData.h
@@ -10,402 +10,424 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 	/**
 	 * @class TLVRecord
 	 * A wrapper class for a Type-Length-Value (TLV) record. This class does not create or modify TLV records, but rather
 	 * serves as a wrapper and provides useful methods for retrieving data from them. This class has several abstract methods
 	 * that should be implemented in derived classes. These methods are for record length value calculation (the 'L' in TLV)
 	 * which is implemented differently in different protocols
 	 */
 	template<typename TRecType, typename TRecLen>
 	class TLVRecord
 	{
 	protected:
 
 		/** A struct representing the TLV construct */
 		struct TLVRawData
 		{
 			/** Record type */
 			TRecType recordType;
 			/** Record length in bytes */
 			TRecLen recordLen;
 			/** Record value (variable size) */
 			uint8_t recordValue[];
 		};
 
 		TLVRawData* m_Data;
 
 	public:
 
 		/**
 		 * A c'tor for this class that gets a pointer to the TLV record raw data (byte array)
 		 * @param[in] recordRawData A pointer to the TLV record raw data
 		 */
 		TLVRecord(uint8_t* recordRawData)
 		{
 			assign(recordRawData);
 		}
 
 		/**
 		 * A copy c'tor for this class. This copy c'tor doesn't copy the TLV data, but only the pointer to it,
 		 * which means that after calling it both the old and the new instance will point to the same TLV raw data
 		 * @param[in] other The TLVRecord instance to copy from
 		 */
 		TLVRecord(const TLVRecord& other)
 		{
 			m_Data = other.m_Data;
 		}
 
 		/**
 		 * A d'tor for this class, currently does nothing
 		 */
 		virtual ~TLVRecord() { }
 
 		/**
 		 * Assign a pointer to the TLV record raw data (byte array)
 		 * @param[in] recordRawData A pointer to the TLV record raw data
 		 */
 		void assign(uint8_t* recordRawData)
 		{
-			if(recordRawData == NULL)
-				m_Data = NULL;
-			else
-				m_Data = (TLVRawData*)recordRawData;
+			m_Data = (TLVRawData*)recordRawData;
+		}
+
+		/**
+		 * Check if a pointer can be assigned to the TLV record data
+		 * @param[in] recordRawData A pointer to the TLV record raw data
+		 * @param[in] tlvDataLen The size of the TLV record raw data
+		 * @return True if data is valid and can be assigned
+		 */
+		static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+		{
+			return recordRawData != nullptr && tlvDataLen >= (sizeof(TLVRawData::recordType) + sizeof(TLVRawData::recordLen));
 		}
 
 		/**
 		 * Overload of the assignment operator. This operator doesn't copy the TLV data, but rather copies the pointer to it,
 		 * which means that after calling it both the old and the new instance will point to the same TLV raw data
 		 * @param[in] other The TLVRecord instance to assign
 		 */
 		TLVRecord& operator=(const TLVRecord& other)
 		{
 			m_Data = other.m_Data;
 			return *this;
 		}
 
 		/**
 		 * Overload of the equality operator. Two record are equal if both of them point to the same data, or if they point
 		 * to different data but their total size is equal and the raw data they both contain is similar.
 		 * @param[in] rhs The object to compare to
 		 * @return True if both objects are equal, false otherwise
 		 */
 		bool operator==(const TLVRecord& rhs) const
 		{
 			if (m_Data == rhs.m_Data)
 				return true;
 
 			if (getTotalSize() != rhs.getTotalSize())
 				return false;
 
 			if (isNull() || ((TLVRecord&)rhs).isNull())
 				return false;
 
 			return (memcmp(m_Data, rhs.m_Data, getTotalSize()) == 0);
 		}
 
 		/**
 		 * Overload of the not equal operator.
 		 * @param[in] rhs The object to compare to
 		 * @return True if objects are not equal, false otherwise
 		 */
 		bool operator!=(const TLVRecord& rhs) const
 		{
 			return !operator==(rhs);
 		}
 
 		/**
 		 * @return The type field of the record (the 'T' in __Type__-Length-Value)
 		 */
 		TRecType getType() const {
 			if (m_Data == nullptr)
 				return 0;
 
 			return m_Data->recordType;
 		}
 
 		/**
 		 * @return A pointer to the value of the record as byte array (the 'V' in Type-Length- __Value__)
 		 */
 		uint8_t* getValue() const {
 			if (m_Data == nullptr)
 				return nullptr;
 
 			return m_Data->recordValue;
 		}
 
 		/**
 		 * @return True if the TLV record raw data is NULL, false otherwise
 		 */
 		bool isNull() const { return (m_Data == nullptr); }
 
 		/**
 		 * @return True if the TLV record raw data is not NULL, false otherwise
 		 */
 		bool isNotNull() const { return (m_Data != nullptr); }
 
 		/**
 		 * @return A pointer to the TLV record raw data byte stream
 		 */
 		uint8_t* getRecordBasePtr() const { return (uint8_t*)m_Data; }
 
 		/**
 		 * Free the memory of the TLV record raw data
 		 */
-		void purgeRecordData() { if (!isNull()) delete [] m_Data; }
+		void purgeRecordData()
+		{
+			if (!isNull())
+			{
+				delete [] m_Data;
+				m_Data = nullptr;
+			}
+		}
 
 		/**
 		 * A templated method to retrieve the record data as a certain type T. For example, if record data is 4B long
 		 * (integer) then this method should be used as getValueAs<int>() and it will return the record data as an integer.<BR>
 		 * Notice this return value is a copy of the data, not a pointer to the actual data
 		 * @param[in] offset The offset in the record data to start reading the value from. Useful for cases when you want
 		 * to read some of the data that doesn't start at offset 0. This is an optional parameter and the default value
 		 * is 0, meaning start reading the value at the beginning of the record data
 		 * @return The record data as type T
 		 */
 		template<typename T>
 		T getValueAs(size_t offset = 0) const
 		{
 			if (getDataSize() - offset < sizeof(T))
 				return 0;
 
 			T result;
 			memcpy(&result, m_Data->recordValue + offset, sizeof(T));
 			return result;
 		}
 
 		/**
 		 * A templated method to copy data of type T into the TLV record data. For example: if record data is 4[Bytes] long use
 		 * this method with \<int\> to set an integer value into the record data: setValue<int>(num)
 		 * @param[in] newValue The value of type T to copy to the record data
 		 * @param[in] valueOffset An optional parameter that specifies where to start setting the record data (default set to 0). For example:
 		 * if record data is 20 bytes long and you only need to set the 4 last bytes as integer then use this method like this:
 		 * setValue<int>(num, 16)
 		 * @return True if value was set successfully or false if the size of T is larger than the record data size
 		 */
 		template<typename T>
 		bool setValue(T newValue, int valueOffset = 0)
 		{
 			if (getDataSize() < sizeof(T))
 				return false;
 
 			memcpy(m_Data->recordValue + valueOffset, &newValue, sizeof(T));
 			return true;
 		}
 
 		/**
 		 * @return The total size of the TLV record (in bytes)
 		 */
 		virtual size_t getTotalSize() const = 0;
 
 		/**
 		 * @return The size of the record value (meaning the size of the 'V' part in TLV)
 		 */
 		virtual size_t getDataSize() const = 0;
 	};
 
 
 	/**
 	 * @class TLVRecordReader
 	 * A class for reading TLV records data out of a byte stream. This class contains helper methods for retrieving and
 	 * counting TLV records. This is a template class that expects template argument class derived from TLVRecord.
 	 */
 	template<typename TLVRecordType>
 	class TLVRecordReader
 	{
 	private:
 		mutable size_t m_RecordCount;
 
 	public:
 
 		/**
 		 * A default c'tor for this class
 		 */
 		TLVRecordReader() { m_RecordCount = (size_t)-1; }
 
 		/**
 		 * A default copy c'tor for this class
 		 */
 		TLVRecordReader(const TLVRecordReader& other)
 		{
 			m_RecordCount = other.m_RecordCount;
 		}
 
 		/**
 		 * A d'tor for this class which currently does nothing
 		 */
 		virtual ~TLVRecordReader() { }
 
 		/**
 		 * Overload of the assignment operator for this class
 		 * @param[in] other The TLVRecordReader instance to assign
 		 */
 		TLVRecordReader& operator=(const TLVRecordReader& other)
 		{
 			m_RecordCount = other.m_RecordCount;
 			return *this;
 		}
 
 		/**
 		 * Get the first TLV record out of a byte stream
 		 * @param[in] tlvDataBasePtr A pointer to the TLV data byte stream
 		 * @param[in] tlvDataLen The TLV data byte stream length
 		 * @return An instance of type TLVRecordType that contains the first TLV record. If tlvDataBasePtr is NULL or
 		 * tlvDataLen is zero the returned TLVRecordType instance will be logically NULL, meaning TLVRecordType.isNull() will
 		 * return true
 		 */
 		TLVRecordType getFirstTLVRecord(uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
 		{
-			TLVRecordType resRec(tlvDataBasePtr); // for NRVO optimization
+			TLVRecordType resRec(NULL); // for NRVO optimization
+			if (!TLVRecordType::canAssign(tlvDataBasePtr, tlvDataLen))
+				return resRec;
 
+			resRec.assign(tlvDataBasePtr);
 			// resRec pointer is out-bounds of the TLV records memory
 			if (resRec.getRecordBasePtr() + resRec.getTotalSize() > tlvDataBasePtr + tlvDataLen)
 				resRec.assign(NULL);
 
 			// check if there are records at all and the total size is not zero
 			if (!resRec.isNull() && (tlvDataLen == 0 || resRec.getTotalSize() == 0))
 				resRec.assign(NULL);
 
 			return resRec;
 		}
 
 		/**
 		 * Get a TLV record that follows a given TLV record in a byte stream
 		 * @param[in] record A given TLV record
 		 * @param[in] tlvDataBasePtr A pointer to the TLV data byte stream
 		 * @param[in] tlvDataLen The TLV data byte stream length
 		 * @return An instance of type TLVRecordType that wraps the record following the record given as input. If the
 		 * input record.isNull() is true or if the next record is out of bounds of the byte stream, a logical NULL instance
 		 * of TLVRecordType will be returned, meaning TLVRecordType.isNull() will return true
 		 */
 		TLVRecordType getNextTLVRecord(TLVRecordType& record, const uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
 		{
 			TLVRecordType resRec(NULL); // for NRVO optimization
 
 			if (record.isNull())
 				return resRec;
 
+			if (!TLVRecordType::canAssign(record.getRecordBasePtr() + record.getTotalSize(), tlvDataBasePtr - record.getRecordBasePtr() + tlvDataLen - record.getTotalSize()))
+				return resRec;
+
 			resRec.assign(record.getRecordBasePtr() + record.getTotalSize());
+
 			if (resRec.getTotalSize() == 0)
 				resRec.assign(NULL);
 
 			// resRec pointer is out-bounds of the TLV records memory
 			if ((resRec.getRecordBasePtr() - tlvDataBasePtr) < 0)
 				resRec.assign(NULL);
 
 			// resRec pointer is out-bounds of the TLV records memory
 			if (!resRec.isNull() && resRec.getRecordBasePtr() + resRec.getTotalSize() > tlvDataBasePtr + tlvDataLen)
 				resRec.assign(NULL);
 
 			return resRec;
 		}
 
 		/**
 		 * Search for the first TLV record that corresponds to a given record type (the 'T' in __Type__-Length-Value)
 		 * @param[in] recordType The record type to search for
 		 * @param[in] tlvDataBasePtr A pointer to the TLV data byte stream
 		 * @param[in] tlvDataLen The TLV data byte stream length
 		 * @return An instance of type TLVRecordType that contains the result record. If record was not found a logical
 		 * NULL instance of TLVRecordType will be returned, meaning TLVRecordType.isNull() will return true
 		 */
 		TLVRecordType getTLVRecord(uint32_t recordType, uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
 		{
 			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
 			while (!curRec.isNull())
 			{
 				if (curRec.getType() == recordType)
 				{
 					return curRec;
 				}
 
 				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
 			}
 
 			curRec.assign(NULL);
 			return curRec; // for NRVO optimization
 		}
 
 		/**
 		 * Get the TLV record count in a given TLV data byte stream. For efficiency purposes the count is being cached
 		 * so only the first call to this method will go over all the TLV records, while all consequent calls will return
 		 * the cached number. This implies that if there is a change in the number of records, it's the user's responsibility
 		 * to call changeTLVRecordCount() with the record count change
 		 * @param[in] tlvDataBasePtr A pointer to the TLV data byte stream
 		 * @param[in] tlvDataLen The TLV data byte stream length
 		 * @return The TLV record count
 		 */
 		size_t getTLVRecordCount(uint8_t* tlvDataBasePtr, size_t tlvDataLen) const
 		{
 			if (m_RecordCount != (size_t)-1)
 				return m_RecordCount;
 
 			m_RecordCount = 0;
 			TLVRecordType curRec = getFirstTLVRecord(tlvDataBasePtr, tlvDataLen);
 			while (!curRec.isNull())
 			{
 				m_RecordCount++;
 				curRec = getNextTLVRecord(curRec, tlvDataBasePtr, tlvDataLen);
 			}
 
 			return m_RecordCount;
 		}
 
 		/**
 		 * As described in getTLVRecordCount(), the TLV record count is being cached for efficiency purposes. So if the
 		 * number of TLV records change, it's the user's responsibility to call this method with the number of TLV records
 		 * being added or removed. If records were added the change should be a positive number, or a negative number
 		 * if records were removed
 		 * @param[in] changedBy Number of records that were added or removed
 		 */
 		void changeTLVRecordCount(int changedBy) { if (m_RecordCount != (size_t)-1) m_RecordCount += changedBy; }
 	};
 
 
 	/**
 	 * @class TLVRecordBuilder
 	 * A base class for building Type-Length-Value (TLV) records. This builder receives the record parameters in its c'tor,
 	 * builds the record raw buffer and provides a method to build a TLVRecord object out of it. Please notice this is
 	 * a base class that lacks the capability of actually building TLVRecord objects and also cannot be instantiated. The
 	 * reason for that is that different protocols build TLV records in different ways, so these missing capabilities will
 	 * be implemented by the derived classes which are specific to each protocol. This class only provides the common
 	 * infrastructure that will be used by them
 	 */
 	class TLVRecordBuilder
 	{
 	protected:
 
 		TLVRecordBuilder();
 
 		TLVRecordBuilder(uint32_t recType, const uint8_t* recValue, uint8_t recValueLen);
 
 		TLVRecordBuilder(uint32_t recType, uint8_t recValue);
 
 		TLVRecordBuilder(uint32_t recType, uint16_t recValue);
 
 		TLVRecordBuilder(uint32_t recType, uint32_t recValue);
 
 		TLVRecordBuilder(uint32_t recType, const IPv4Address& recValue);
 
 		TLVRecordBuilder(uint32_t recType, const std::string& recValue, bool valueIsHexString = false);
 
 		TLVRecordBuilder(const TLVRecordBuilder& other);
 
 		TLVRecordBuilder& operator=(const TLVRecordBuilder& other);
 
 		virtual ~TLVRecordBuilder();
 
 		void init(uint32_t recType, const uint8_t* recValue, size_t recValueLen);
 
 		uint8_t* m_RecValue;
 		size_t m_RecValueLen;
 		uint32_t m_RecType;
 
 	private:
 
 		void copyData(const TLVRecordBuilder& other);
 	};
 }
 #endif // PACKETPP_TLV_DATA
diff --git a/Packet++/header/TcpLayer.h b/Packet++/header/TcpLayer.h
index 21e79267..50b89ca9 100644
--- a/Packet++/header/TcpLayer.h
+++ b/Packet++/header/TcpLayer.h
@@ -10,497 +10,518 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct tcphdr
 	 * Represents an TCP protocol header
 	 */
 #pragma pack(push,1)
 	struct tcphdr
 	{
 		/** Source TCP port */
 		uint16_t portSrc;
 		/** Destination TCP port */
 		uint16_t portDst;
 		/** Sequence number */
 		uint32_t sequenceNumber;
 		/** Acknowledgment number */
 		uint32_t ackNumber;
 #if (BYTE_ORDER == LITTLE_ENDIAN)
 		uint16_t reserved:4,
 		/** Specifies the size of the TCP header in 32-bit words */
 		dataOffset:4,
 		/** FIN flag */
 		finFlag:1,
 		/** SYN flag */
 		synFlag:1,
 		/** RST flag */
 		rstFlag:1,
 		/** PSH flag */
 		pshFlag:1,
 		/** ACK flag */
 		ackFlag:1,
 		/** URG flag */
 		urgFlag:1,
 		/** ECE flag */
 		eceFlag:1,
 		/** CWR flag */
 		cwrFlag:1;
 #elif (BYTE_ORDER == BIG_ENDIAN)
 		/** Specifies the size of the TCP header in 32-bit words */
 		uint16_t dataOffset:4,
 		reserved:4,
 		/** CWR flag */
 		cwrFlag:1,
 		/** ECE flag */
 		eceFlag:1,
 		/** URG flag */
 		urgFlag:1,
 		/** ACK flag */
 		ackFlag:1,
 		/** PSH flag */
 		pshFlag:1,
 		/** RST flag */
 		rstFlag:1,
 		/** SYN flag */
 		synFlag:1,
 		/** FIN flag */
 		finFlag:1;
 #else
 #error	"Endian is not LE nor BE..."
 #endif
 		/** The size of the receive window, which specifies the number of window size units (by default, bytes) */
 		uint16_t	windowSize;
 		/** The 16-bit checksum field is used for error-checking of the header and data */
 		uint16_t	headerChecksum;
 		/** If the URG flag (@ref tcphdr#urgFlag) is set, then this 16-bit field is an offset from the sequence number indicating the last urgent data byte */
 		uint16_t	urgentPointer;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * TCP options types
 	 */
 	enum TcpOptionType
 	{
 		/** Padding */
 		PCPP_TCPOPT_NOP =       1,
 		/** End of options */
 		PCPP_TCPOPT_EOL =       0,
 		/** Segment size negotiating */
 		TCPOPT_MSS =          	2,
 		/** Window scaling */
 		PCPP_TCPOPT_WINDOW =    3,
 		/** SACK Permitted */
 		TCPOPT_SACK_PERM =      4,
 		/** SACK Block */
 		PCPP_TCPOPT_SACK =      5,
 		/** Echo (obsoleted by option ::PCPP_TCPOPT_TIMESTAMP) */
 		TCPOPT_ECHO =           6,
 		/** Echo Reply (obsoleted by option ::PCPP_TCPOPT_TIMESTAMP) */
 		TCPOPT_ECHOREPLY =      7,
 		/** TCP Timestamps */
 		PCPP_TCPOPT_TIMESTAMP = 8,
 		/** CC (obsolete) */
 		TCPOPT_CC =             11,
 		/** CC.NEW (obsolete) */
 		TCPOPT_CCNEW =          12,
 		/** CC.ECHO(obsolete) */
 		TCPOPT_CCECHO =         13,
 		/** MD5 Signature Option */
 		TCPOPT_MD5 =            19,
 		/** Multipath TCP */
 		TCPOPT_MPTCP =          0x1e,
 		/** SCPS Capabilities */
 		TCPOPT_SCPS =           20,
 		/** SCPS SNACK */
 		TCPOPT_SNACK =          21,
 		/** SCPS Record Boundary */
 		TCPOPT_RECBOUND =       22,
 		/** SCPS Corruption Experienced */
 		TCPOPT_CORREXP =        23,
 		/** Quick-Start Response */
 		TCPOPT_QS =             27,
 		/** User Timeout Option (also, other known unauthorized use) */
 		TCPOPT_USER_TO =        28,
 		/** RFC3692-style Experiment 1 (also improperly used for shipping products) */
 		TCPOPT_EXP_FD =         0xfd,
 		/** RFC3692-style Experiment 2 (also improperly used for shipping products) */
 		TCPOPT_EXP_FE =         0xfe,
 		/** Riverbed probe option, non IANA registered option number */
 		TCPOPT_RVBD_PROBE =     76,
 		/** Riverbed transparency option, non IANA registered option number */
 		TCPOPT_RVBD_TRPY =      78,
 		/** Unknown option */
 		TCPOPT_Unknown =        255
 	};
 
 
 	// TCP option lengths
 
 	/** pcpp::PCPP_TCPOPT_NOP length */
 #define PCPP_TCPOLEN_NOP            1
 	/** pcpp::PCPP_TCPOPT_EOL length */
 #define PCPP_TCPOLEN_EOL            1
 	/** pcpp::TCPOPT_MSS length */
 #define PCPP_TCPOLEN_MSS            4
 	/** pcpp::PCPP_TCPOPT_WINDOW length */
 #define PCPP_TCPOLEN_WINDOW         3
 	/** pcpp::TCPOPT_SACK_PERM length */
 #define PCPP_TCPOLEN_SACK_PERM      2
 	/** pcpp::PCPP_TCPOPT_SACK length */
 #define PCPP_TCPOLEN_SACK_MIN       2
 	/** pcpp::TCPOPT_ECHO length */
 #define PCPP_TCPOLEN_ECHO           6
 	/** pcpp::TCPOPT_ECHOREPLY length */
 #define PCPP_TCPOLEN_ECHOREPLY      6
 	/** pcpp::PCPP_TCPOPT_TIMESTAMP length */
 #define PCPP_TCPOLEN_TIMESTAMP     10
 	/** pcpp::TCPOPT_CC length */
 #define PCPP_TCPOLEN_CC             6
 	/** pcpp::TCPOPT_CCNEW length */
 #define PCPP_TCPOLEN_CCNEW          6
 	/** pcpp::TCPOPT_CCECHO length */
 #define PCPP_TCPOLEN_CCECHO         6
 	/** pcpp::TCPOPT_MD5 length */
 #define PCPP_TCPOLEN_MD5           18
 	/** pcpp::TCPOPT_MPTCP length */
 #define PCPP_TCPOLEN_MPTCP_MIN      8
 	/** pcpp::TCPOPT_SCPS length */
 #define PCPP_TCPOLEN_SCPS           4
 	/** pcpp::TCPOPT_SNACK length */
 #define PCPP_TCPOLEN_SNACK          6
 	/** pcpp::TCPOPT_RECBOUND length */
 #define PCPP_TCPOLEN_RECBOUND       2
 	/** pcpp::TCPOPT_CORREXP length */
 #define PCPP_TCPOLEN_CORREXP        2
 	/** pcpp::TCPOPT_QS length */
 #define PCPP_TCPOLEN_QS             8
 	/** pcpp::TCPOPT_USER_TO length */
 #define PCPP_TCPOLEN_USER_TO        4
 	/** pcpp::TCPOPT_RVBD_PROBE length */
 #define PCPP_TCPOLEN_RVBD_PROBE_MIN 3
 	/** pcpp::TCPOPT_RVBD_TRPY length */
 #define PCPP_TCPOLEN_RVBD_TRPY_MIN 16
 	/** pcpp::TCPOPT_EXP_FD and pcpp::TCPOPT_EXP_FE length */
 #define PCPP_TCPOLEN_EXP_MIN        2
 
 
 	/**
 	 * @class TcpOption
 	 * A wrapper class for TCP options. This class does not create or modify TCP option records, but rather
 	 * serves as a wrapper and provides useful methods for retrieving data from them
 	 */
 	class TcpOption : public TLVRecord<uint8_t, uint8_t>
 	{
 	public:
 
 		/**
 		 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 		 * @param[in] optionRawData A pointer to the TCP option raw data
 		 */
 		explicit TcpOption(uint8_t* optionRawData) : TLVRecord(optionRawData) { }
 
 		/**
 		 * A d'tor for this class, currently does nothing
 		 */
 		~TcpOption() { }
 
 		/**
 		 * @return TCP option type casted as pcpp::TcpOptionType enum. If the data is null a value
 		 * of ::TCPOPT_Unknown is returned
 		 */
 		TcpOptionType getTcpOptionType() const
 		{
 			if (m_Data == nullptr)
 				return TCPOPT_Unknown;
 
 			return (TcpOptionType)m_Data->recordType;
 		}
 
+		/**
+		 * Check if a pointer can be assigned to the TLV record data
+		 * @param[in] recordRawData A pointer to the TLV record raw data
+		 * @param[in] tlvDataLen The size of the TLV record raw data
+		 * @return True if data is valid and can be assigned
+		 */
+		static bool canAssign(const uint8_t* recordRawData, size_t tlvDataLen)
+		{
+			auto data = (TLVRawData*)recordRawData;
+			if (data == nullptr)
+				return false;
+
+			if (tlvDataLen < sizeof(TLVRawData::recordType))
+				return false;
+
+			if (data->recordType == (uint8_t)PCPP_TCPOPT_NOP || data->recordType == (uint8_t)PCPP_TCPOPT_EOL)
+				return true;
+
+			return TLVRecord<uint8_t, uint8_t>::canAssign(recordRawData, tlvDataLen);
+		}
+
 		// implement abstract methods
 
 		size_t getTotalSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (m_Data->recordType == (uint8_t)PCPP_TCPOPT_NOP || m_Data->recordType == (uint8_t)PCPP_TCPOPT_EOL)
 				return sizeof(uint8_t);
 
 			return (size_t)m_Data->recordLen;
 		}
 
 		size_t getDataSize() const
 		{
 			if (m_Data == nullptr)
 				return 0;
 
 			if (m_Data->recordType == (uint8_t)PCPP_TCPOPT_NOP || m_Data->recordType == (uint8_t)PCPP_TCPOPT_EOL)
 				return 0;
 
 			return (size_t)m_Data->recordLen - (2*sizeof(uint8_t));
 		}
 	};
 
 
 	/**
 	 * @class TcpOptionBuilder
 	 * A class for building TCP option records. This builder receives the TCP option parameters in its c'tor,
 	 * builds the TCP option raw buffer and provides a build() method to get a TcpOption object out of it
 	 */
 	class TcpOptionBuilder : public TLVRecordBuilder
 	{
 
 	public:
 
 		/**
 		 * An enum to describe NOP and EOL TCP options. Used in one of this class's c'tors
 		 */
 		enum NopEolOptionTypes
 		{
 			/** NOP TCP option */
 			NOP,
 			/** EOL TCP option */
 			EOL
 		};
 
 		/**
 		 * A c'tor for building TCP options which their value is a byte array. The TcpOption object can be later
 		 * retrieved by calling build()
 		 * @param[in] optionType TCP option type
 		 * @param[in] optionValue A buffer containing the option value. This buffer is read-only and isn't modified in any way.
 		 * @param[in] optionValueLen Option value length in bytes
 		 */
 		TcpOptionBuilder(TcpOptionType optionType, const uint8_t* optionValue, uint8_t optionValueLen) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue, optionValueLen) {}
 
 		/**
 		 * A c'tor for building TCP options which have a 1-byte value. The TcpOption object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType TCP option type
 		 * @param[in] optionValue A 1-byte option value
 		 */
 		TcpOptionBuilder(TcpOptionType optionType, uint8_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) {}
 
 		/**
 		 * A c'tor for building TCP options which have a 2-byte value. The TcpOption object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType TCP option type
 		 * @param[in] optionValue A 2-byte option value
 		 */
 		TcpOptionBuilder(TcpOptionType optionType, uint16_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) {}
 
 		/**
 		 * A c'tor for building TCP options which have a 4-byte value. The TcpOption object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType TCP option type
 		 * @param[in] optionValue A 4-byte option value
 		 */
 		TcpOptionBuilder(TcpOptionType optionType, uint32_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) {}
 
 		/**
 		 * A c'tor for building TCP NOP and EOL options. These option types are special in that they contain only 1 byte
 		 * which is the TCP option type (NOP or EOL). The TcpOption object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType An enum value indicating which option type to build (NOP or EOL)
 		 */
 		explicit TcpOptionBuilder(NopEolOptionTypes optionType);
 
 		/**
 		 * Build the TcpOption object out of the parameters defined in the c'tor
 		 * @return The TcpOption object
 		 */
 		TcpOption build() const;
 	};
 
 
 	/**
 	 * @class TcpLayer
 	 * Represents a TCP (Transmission Control Protocol) protocol layer
 	 */
 	class TcpLayer : public Layer
 	{
 	public:
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref tcphdr)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		TcpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
 
 		/**
 		 * A constructor that allocates a new TCP header with zero TCP options
 		 */
 		TcpLayer();
 
 		/**
 		 * A constructor that allocates a new TCP header with source port and destination port and zero TCP options
 		 * @param[in] portSrc Source port
 		 * @param[in] portDst Destination port
 		 */
 		TcpLayer(uint16_t portSrc, uint16_t portDst);
 
 		~TcpLayer() {}
 
 		/**
 		 * A copy constructor that copy the entire header from the other TcpLayer (including TCP options)
 		 */
 		TcpLayer(const TcpLayer& other);
 
 		/**
 		 * An assignment operator that first delete all data from current layer and then copy the entire header from the other TcpLayer (including TCP options)
 		 */
 		TcpLayer& operator=(const TcpLayer& other);
 
 		/**
 		 * Get a pointer to the TCP header. Notice this points directly to the data, so every change will change the actual packet data
 		 * @return A pointer to the @ref tcphdr
 		 */
 		tcphdr* getTcpHeader() const { return (tcphdr*)m_Data; }
 
 		/**
 		 * @return TCP source port
 		 */
 		uint16_t getSrcPort() const;
 
 		/**
 		 * @return TCP destination port
 		 */
 		uint16_t getDstPort() const;
 
 		/**
 		 * Get a TCP option by type
 		 * @param[in] option TCP option type to retrieve
 		 * @return An TcpOption object that contains the first option that matches this type, or logical NULL
 		 * (TcpOption#isNull() == true) if no such option found
 		 */
 		TcpOption getTcpOption(TcpOptionType option) const;
 
 		/**
 		 * @return The first TCP option in the packet. If the current layer contains no options the returned value will contain
 		 * a logical NULL (TcpOption#isNull() == true)
 		 */
 		TcpOption getFirstTcpOption() const;
 
 		/**
 		 * Get the TCP option that comes after a given option. If the given option was the last one, the
 		 * returned value will contain a logical NULL (TcpOption#isNull() == true)
 		 * @param[in] tcpOption A TCP option object that exists in the current layer
 		 * @return A TcpOption object that contains the TCP option data that comes next, or logical NULL if the given
 		 * TCP option: (1) was the last one; or (2) contains a logical NULL; or (3) doesn't belong to this packet
 		 */
 		TcpOption getNextTcpOption(TcpOption& tcpOption) const;
 
 		/**
 		 * @return The number of TCP options in this layer
 		 */
 		size_t getTcpOptionCount() const;
 
 		/**
 		 * Add a new TCP option at the end of the layer (after the last TCP option)
 		 * @param[in] optionBuilder A TcpOptionBuilder object that contains the TCP option data to be added
 		 * @return A TcpOption object that contains the newly added TCP option data or logical NULL
 		 * (TcpOption#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		TcpOption addTcpOption(const TcpOptionBuilder& optionBuilder);
 
 		/**
 		 * Add a new TCP option after an existing one
 		 * @param[in] optionBuilder A TcpOptionBuilder object that contains the requested TCP option data to be added
 		 * @param[in] prevOptionType The TCP option which the newly added option should come after. This is an optional parameter which
 		 * gets a default value of ::TCPOPT_Unknown if omitted, which means the new option will be added as the first option in the layer
 		 * @return A TcpOption object containing the newly added TCP option data or logical NULL
 		 * (TcpOption#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		TcpOption addTcpOptionAfter(const TcpOptionBuilder& optionBuilder, TcpOptionType prevOptionType = TCPOPT_Unknown);
 
 		/**
 		 * Remove an existing TCP option from the layer. TCP option is found by type
 		 * @param[in] optionType The TCP option type to remove
 		 * @return True if TCP option was removed or false if type wasn't found or if removal failed (in each case a proper error
 		 * will be written to log)
 		 */
 		bool removeTcpOption(TcpOptionType optionType);
 
 		/**
 		 * Remove all TCP options in this layer
 		 * @return True if all TCP options were successfully removed or false if removal failed for some reason
 		 * (a proper error will be written to log)
 		 */
 		bool removeAllTcpOptions();
 
 
 		/**
 		 * Calculate the checksum from header and data and possibly write the result to @ref tcphdr#headerChecksum
 		 * @param[in] writeResultToPacket If set to true then checksum result will be written to @ref tcphdr#headerChecksum
 		 * @return The checksum result
 		 */
 		uint16_t calculateChecksum(bool writeResultToPacket);
 
 		/**
 		 * The static method makes validation of input data
 		 * @param[in] data The pointer to the beginning of byte stream of TCP packet
 		 * @param[in] dataLen The length of byte stream
 		 * @return True if the data is valid and can represent a TCP packet
 		 */
 		static inline bool isDataValid(const uint8_t* data, size_t dataLen);
 
 		// implement abstract methods
 
 		/**
 		 * Currently identifies the following next layers: HttpRequestLayer, HttpResponseLayer. Otherwise sets PayloadLayer
 		 */
 		void parseNextLayer();
 
 		/**
 		 * @return Size of @ref tcphdr + all TCP options
 		 */
 		size_t getHeaderLen() const { return getTcpHeader()->dataOffset*4 ;}
 
 		/**
 		 * Calculate @ref tcphdr#headerChecksum field
 		 */
 		void computeCalculateFields();
 
 		std::string toString() const;
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelTransportLayer; }
 
 	private:
 
 		TLVRecordReader<TcpOption> m_OptionReader;
 		int m_NumOfTrailingBytes;
 
 		void initLayer();
 		uint8_t* getOptionsBasePtr() const { return m_Data + sizeof(tcphdr); }
 		TcpOption addTcpOptionAt(const TcpOptionBuilder& optionBuilder, int offset);
 		void adjustTcpOptionTrailer(size_t totalOptSize);
 		void copyLayerData(const TcpLayer& other);
 	};
 
 
 	// implementation of inline methods
 
 	bool TcpLayer::isDataValid(const uint8_t* data, size_t dataLen)
 	{
 		const tcphdr* hdr = reinterpret_cast<const tcphdr*>(data);
 		return dataLen >= sizeof(tcphdr)
 			&& hdr->dataOffset >= 5 /* the minimum TCP header size */
 			&& dataLen >= hdr->dataOffset * sizeof(uint32_t);
 	}
 
 } // namespace pcpp
 
 #endif /* PACKETPP_TCP_LAYER */
diff --git a/Packet++/src/NflogLayer.cpp b/Packet++/src/NflogLayer.cpp
index bd3fe5d8..c7a067bd 100644
--- a/Packet++/src/NflogLayer.cpp
+++ b/Packet++/src/NflogLayer.cpp
@@ -79,20 +79,20 @@ void NflogLayer::parseNextLayer()
 size_t NflogLayer::getHeaderLen() const
 {
 	size_t headerLen = sizeof(nflog_header);
 	NflogTlv currentTLV =  m_TlvReader.getFirstTLVRecord(
 		getTlvsBasePtr(),
 		m_DataLen - sizeof(nflog_header));
 
 	while (!currentTLV.isNull() && currentTLV.getType() != static_cast<uint16_t> (NflogTlvType::NFULA_PAYLOAD))
 	{
 		headerLen += currentTLV.getTotalSize();
 		currentTLV = m_TlvReader.getNextTLVRecord(currentTLV, getTlvsBasePtr(), m_DataLen - sizeof(nflog_header));
 	}
-	if (currentTLV.getType() == static_cast<uint16_t> (NflogTlvType::NFULA_PAYLOAD))
+	if (!currentTLV.isNull() && currentTLV.getType() == static_cast<uint16_t> (NflogTlvType::NFULA_PAYLOAD))
 	{
 		// for the length and type of the payload TLV
 		headerLen += 2 * sizeof (uint16_t);
 	}
 	// nflog_header has not a form of TLV and contains 3 fields (family, resource_id, version)
 	return headerLen;
 }
