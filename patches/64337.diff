commit 7fe586b892c9e0cbf3b21d57cfd8135e2311e45c
Author: Philip Hazel <Philip.Hazel@gmail.com>
Date:   Mon Nov 20 15:41:06 2023 +0000

    Fix incorrect patch in c1306126

diff --git a/src/pcre2_compile.c b/src/pcre2_compile.c
index fdaf2ad..9e45580 100644
--- a/src/pcre2_compile.c
+++ b/src/pcre2_compile.c
@@ -2782,6 +2782,7 @@ uint32_t *previous_callout = NULL;
 uint32_t *parsed_pattern = cb->parsed_pattern;
 uint32_t *parsed_pattern_end = cb->parsed_pattern_end;
 uint32_t *this_parsed_item = NULL;
+uint32_t *prev_parsed_item = NULL;
 uint32_t meta_quantifier = 0;
 uint32_t add_after_mark = 0;
 uint32_t xoptions = cb->cx->extra_options;
@@ -2862,2106 +2863,2113 @@ if ((options & PCRE2_EXTENDED_MORE) != 0) options |= PCRE2_EXTENDED;
 while (ptr < ptrend)
   {
   int prev_expect_cond_assert;
   uint32_t min_repeat = 0, max_repeat = 0;
   uint32_t set, unset, *optset;
   uint32_t xset, xunset, *xoptset;
   uint32_t terminator;
   uint32_t prev_meta_quantifier;
-  uint32_t *prev_parsed_item = this_parsed_item; 
   BOOL prev_okquantifier;
   PCRE2_SPTR tempptr;
   PCRE2_SIZE offset;
-  
+
   if (parsed_pattern >= parsed_pattern_end)
     {
     errorcode = ERR63;  /* Internal error (parsed pattern overflow) */
     goto FAILED;
     }
 
   if (nest_depth > cb->cx->parens_nest_limit)
     {
     errorcode = ERR19;
     goto FAILED;        /* Parentheses too deeply nested */
     }
-    
-  /* Remember where this item started */
 
-  this_parsed_item = parsed_pattern;
+  /* If the last time round this loop something was added, parsed_pattern will
+  no longer be equal to this_parsed_item. Remember where the previous item
+  started and reset for the next item. Note that sometimes round the loop,
+  nothing gets added (e.g. for ignored white space). */
+
+  if (this_parsed_item != parsed_pattern)
+    {
+    prev_parsed_item = this_parsed_item;
+    this_parsed_item = parsed_pattern;
+    }
 
   /* Get next input character, save its position for callout handling. */
 
   thisptr = ptr;
   GETCHARINCTEST(c, ptr);
 
   /* Copy quoted literals until \E, allowing for the possibility of automatic
   callouts, except when processing a (*VERB) "name".  */
 
   if (inescq)
     {
     if (c == CHAR_BACKSLASH && ptr < ptrend && *ptr == CHAR_E)
       {
       inescq = FALSE;
       ptr++;   /* Skip E */
       }
     else
       {
       if (expect_cond_assert > 0)   /* A literal is not allowed if we are */
         {                           /* expecting a conditional assertion, */
         ptr--;                      /* but an empty \Q\E sequence is OK.  */
         errorcode = ERR28;
         goto FAILED;
         }
       if (inverbname)
         {                          /* Don't use PARSED_LITERAL() because it */
 #if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */
         if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;
 #endif
         *parsed_pattern++ = c;
         }
       else
         {
         if (after_manual_callout-- <= 0)
           parsed_pattern = manage_callouts(thisptr, &previous_callout,
             auto_callout, parsed_pattern, cb);
         PARSED_LITERAL(c, parsed_pattern);
         }
       meta_quantifier = 0;
       }
     continue;  /* Next character */
     }
 
   /* If we are processing the "name" part of a (*VERB:NAME) item, all
   characters up to the closing parenthesis are literals except when
   PCRE2_ALT_VERBNAMES is set. That causes backslash interpretation, but only \Q
   and \E and escaped characters are allowed (no character types such as \d). If
   PCRE2_EXTENDED is also set, we must ignore white space and # comments. Do
   this by not entering the special (*VERB:NAME) processing - they are then
   picked up below. Note that c is a character, not a code unit, so we must not
   use MAX_255 to test its size because MAX_255 tests code units and is assumed
   TRUE in 8-bit mode. */
 
   if (inverbname &&
        (
         /* EITHER: not both options set */
         ((options & (PCRE2_EXTENDED | PCRE2_ALT_VERBNAMES)) !=
                     (PCRE2_EXTENDED | PCRE2_ALT_VERBNAMES)) ||
 #ifdef SUPPORT_UNICODE
         /* OR: character > 255 AND not Unicode Pattern White Space */
         (c > 255 && (c|1) != 0x200f && (c|1) != 0x2029) ||
 #endif
         /* OR: not a # comment or isspace() white space */
         (c < 256 && c != CHAR_NUMBER_SIGN && (cb->ctypes[c] & ctype_space) == 0
 #ifdef SUPPORT_UNICODE
         /* and not CHAR_NEL when Unicode is supported */
           && c != CHAR_NEL
 #endif
        )))
     {
     PCRE2_SIZE verbnamelength;
 
     switch(c)
       {
       default:                     /* Don't use PARSED_LITERAL() because it */
 #if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */
       if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;
 #endif
       *parsed_pattern++ = c;
       break;
 
       case CHAR_RIGHT_PARENTHESIS:
       inverbname = FALSE;
       /* This is the length in characters */
       verbnamelength = (PCRE2_SIZE)(parsed_pattern - verblengthptr - 1);
       /* But the limit on the length is in code units */
       if (ptr - verbnamestart - 1 > (int)MAX_MARK)
         {
         ptr--;
         errorcode = ERR76;
         goto FAILED;
         }
       *verblengthptr = (uint32_t)verbnamelength;
 
       /* If this name was on a verb such as (*ACCEPT) which does not continue,
       a (*MARK) was generated for the name. We now add the original verb as the
       next item. */
 
       if (add_after_mark != 0)
         {
         *parsed_pattern++ = add_after_mark;
         add_after_mark = 0;
         }
       break;
 
       case CHAR_BACKSLASH:
       if ((options & PCRE2_ALT_VERBNAMES) != 0)
         {
         escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,
           xoptions, FALSE, cb);
         if (errorcode != 0) goto FAILED;
         }
       else escape = 0;   /* Treat all as literal */
 
       switch(escape)
         {
         case 0:                    /* Don't use PARSED_LITERAL() because it */
 #if PCRE2_CODE_UNIT_WIDTH == 32    /* sets okquantifier. */
         if (c >= META_END) *parsed_pattern++ = META_BIGVALUE;
 #endif
         *parsed_pattern++ = c;
         break;
 
         case ESC_ub:
         *parsed_pattern++ = CHAR_u;
         PARSED_LITERAL(CHAR_LEFT_CURLY_BRACKET, parsed_pattern);
         break;
 
         case ESC_Q:
         inescq = TRUE;
         break;
 
         case ESC_E:           /* Ignore */
         break;
 
         default:
         errorcode = ERR40;    /* Invalid in verb name */
         goto FAILED;
         }
       }
     continue;   /* Next character in pattern */
     }
 
   /* Not a verb name character. At this point we must process everything that
   must not change the quantification state. This is mainly comments, but we
   handle \Q and \E here as well, so that an item such as A\Q\E+ is treated as
   A+, as in Perl. An isolated \E is ignored. */
 
   if (c == CHAR_BACKSLASH && ptr < ptrend)
     {
     if (*ptr == CHAR_Q || *ptr == CHAR_E)
       {
       inescq = *ptr == CHAR_Q;
       ptr++;
       continue;
       }
     }
 
   /* Skip over whitespace and # comments in extended mode. Note that c is a
   character, not a code unit, so we must not use MAX_255 to test its size
   because MAX_255 tests code units and is assumed TRUE in 8-bit mode. The
   whitespace characters are those designated as "Pattern White Space" by
   Unicode, which are the isspace() characters plus CHAR_NEL (newline), which is
   U+0085 in Unicode, plus U+200E, U+200F, U+2028, and U+2029. These are a
   subset of space characters that match \h and \v. */
 
   if ((options & PCRE2_EXTENDED) != 0)
     {
     if (c < 256 && (cb->ctypes[c] & ctype_space) != 0) continue;
 #ifdef SUPPORT_UNICODE
     if (c == CHAR_NEL || (c|1) == 0x200f || (c|1) == 0x2029) continue;
 #endif
     if (c == CHAR_NUMBER_SIGN)
       {
       while (ptr < ptrend)
         {
         if (IS_NEWLINE(ptr))      /* For non-fixed-length newline cases, */
           {                       /* IS_NEWLINE sets cb->nllen. */
           ptr += cb->nllen;
           break;
           }
         ptr++;
 #ifdef SUPPORT_UNICODE
         if (utf) FORWARDCHARTEST(ptr, ptrend);
 #endif
         }
       continue;  /* Next character in pattern */
       }
     }
 
   /* Skip over bracketed comments */
 
   if (c == CHAR_LEFT_PARENTHESIS && ptrend - ptr >= 2 &&
       ptr[0] == CHAR_QUESTION_MARK && ptr[1] == CHAR_NUMBER_SIGN)
     {
     while (++ptr < ptrend && *ptr != CHAR_RIGHT_PARENTHESIS);
     if (ptr >= ptrend)
       {
       errorcode = ERR18;  /* A special error for missing ) in a comment */
       goto FAILED;        /* to make it easier to debug. */
       }
     ptr++;
     continue;  /* Next character in pattern */
     }
 
   /* If the next item is not a quantifier, fill in length of any previous
   callout and create an auto callout if required. */
 
   if (c != CHAR_ASTERISK && c != CHAR_PLUS && c != CHAR_QUESTION_MARK &&
        (c != CHAR_LEFT_CURLY_BRACKET ||
          (tempptr = ptr,
          !read_repeat_counts(&tempptr, ptrend, NULL, NULL, &errorcode))))
     {
     if (after_manual_callout-- <= 0)
       parsed_pattern = manage_callouts(thisptr, &previous_callout, auto_callout,
         parsed_pattern, cb);
     }
 
   /* If expect_cond_assert is 2, we have just passed (?( and are expecting an
   assertion, possibly preceded by a callout. If the value is 1, we have just
   had the callout and expect an assertion. There must be at least 3 more
   characters in all cases. When expect_cond_assert is 2, we know that the
   current character is an opening parenthesis, as otherwise we wouldn't be
   here. However, when it is 1, we need to check, and it's easiest just to check
   always. Note that expect_cond_assert may be negative, since all callouts just
   decrement it. */
 
   if (expect_cond_assert > 0)
     {
     BOOL ok = c == CHAR_LEFT_PARENTHESIS && ptrend - ptr >= 3 &&
               (ptr[0] == CHAR_QUESTION_MARK || ptr[0] == CHAR_ASTERISK);
     if (ok)
       {
       if (ptr[0] == CHAR_ASTERISK)  /* New alpha assertion format, possibly */
         {
         ok = MAX_255(ptr[1]) && (cb->ctypes[ptr[1]] & ctype_lcletter) != 0;
         }
       else switch(ptr[1])  /* Traditional symbolic format */
         {
         case CHAR_C:
         ok = expect_cond_assert == 2;
         break;
 
         case CHAR_EQUALS_SIGN:
         case CHAR_EXCLAMATION_MARK:
         break;
 
         case CHAR_LESS_THAN_SIGN:
         ok = ptr[2] == CHAR_EQUALS_SIGN || ptr[2] == CHAR_EXCLAMATION_MARK;
         break;
 
         default:
         ok = FALSE;
         }
       }
 
     if (!ok)
       {
       ptr--;   /* Adjust error offset */
       errorcode = ERR28;
       goto FAILED;
       }
     }
 
   /* Remember whether we are expecting a conditional assertion, and set the
   default for this item. */
 
   prev_expect_cond_assert = expect_cond_assert;
   expect_cond_assert = 0;
 
   /* Remember quantification status for the previous significant item, then set
   default for this item. */
 
   prev_okquantifier = okquantifier;
   prev_meta_quantifier = meta_quantifier;
   okquantifier = FALSE;
   meta_quantifier = 0;
 
   /* If the previous significant item was a quantifier, adjust the parsed code
   if there is a following modifier. The base meta value is always followed by
   the PLUS and QUERY values, in that order. We do this here rather than after
   reading a quantifier so that intervening comments and /x whitespace can be
   ignored without having to replicate code. */
 
   if (prev_meta_quantifier != 0 && (c == CHAR_QUESTION_MARK || c == CHAR_PLUS))
     {
     parsed_pattern[(prev_meta_quantifier == META_MINMAX)? -3 : -1] =
       prev_meta_quantifier + ((c == CHAR_QUESTION_MARK)?
         0x00020000u : 0x00010000u);
     continue;  /* Next character in pattern */
     }
 
   /* Process the next item in the main part of a pattern. */
 
   switch(c)
     {
     default:              /* Non-special character */
     PARSED_LITERAL(c, parsed_pattern);
     break;
 
 
     /* ---- Escape sequence ---- */
 
     case CHAR_BACKSLASH:
     tempptr = ptr;
     escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,
       xoptions, FALSE, cb);
     if (errorcode != 0)
       {
       ESCAPE_FAILED:
       if ((xoptions & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) == 0)
         goto FAILED;
       ptr = tempptr;
       if (ptr >= ptrend) c = CHAR_BACKSLASH; else
         {
         GETCHARINCTEST(c, ptr);   /* Get character value, increment pointer */
         }
       escape = 0;                 /* Treat as literal character */
       }
 
     /* The escape was a data escape or literal character. */
 
     if (escape == 0)
       {
       PARSED_LITERAL(c, parsed_pattern);
       }
 
     /* The escape was a back (or forward) reference. We keep the offset in
     order to give a more useful diagnostic for a bad forward reference. For
     references to groups numbered less than 10 we can't use more than two items
     in parsed_pattern because they may be just two characters in the input (and
     in a 64-bit world an offset may need two elements). So for them, the offset
     of the first occurrent is held in a special vector. */
 
     else if (escape < 0)
       {
       offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 1);
       escape = -escape;
       *parsed_pattern++ = META_BACKREF | (uint32_t)escape;
       if (escape < 10)
         {
         if (cb->small_ref_offset[escape] == PCRE2_UNSET)
           cb->small_ref_offset[escape] = offset;
         }
       else
         {
         PUTOFFSET(offset, parsed_pattern);
         }
       okquantifier = TRUE;
       }
 
     /* The escape was a character class such as \d etc. or other special
     escape indicator such as \A or \X. Most of them generate just a single
     parsed item, but \P and \p are followed by a 16-bit type and a 16-bit
     value. They are supported only when Unicode is available. The type and
     value are packed into a single 32-bit value so that the whole sequences
     uses only two elements in the parsed_vector. This is because the same
     coding is used if \d (for example) is turned into \p{Nd} when PCRE2_UCP is
     set.
 
     There are also some cases where the escape sequence is followed by a name:
     \k{name}, \k<name>, and \k'name' are backreferences by name, and \g<name>
     and \g'name' are subroutine calls by name; \g{name} is a synonym for
     \k{name}. Note that \g<number> and \g'number' are handled by check_escape()
     and returned as a negative value (handled above). A name is coded as an
     offset into the pattern and a length. */
 
     else switch (escape)
       {
       case ESC_C:
 #ifdef NEVER_BACKSLASH_C
       errorcode = ERR85;
       goto ESCAPE_FAILED;
 #else
       if ((options & PCRE2_NEVER_BACKSLASH_C) != 0)
         {
         errorcode = ERR83;
         goto ESCAPE_FAILED;
         }
 #endif
       okquantifier = TRUE;
       *parsed_pattern++ = META_ESCAPE + escape;
       break;
 
       /* This is a special return that happens only in EXTRA_ALT_BSUX mode,
       when \u{ is not followed by hex digits and }. It requests two literal
       characters, u and { and we need this, as otherwise \u{ 12} (for example)
       would be treated as u{12} now that spaces are allowed in quantifiers. */
 
       case ESC_ub:
       *parsed_pattern++ = CHAR_u;
       PARSED_LITERAL(CHAR_LEFT_CURLY_BRACKET, parsed_pattern);
       break;
 
       case ESC_X:
 #ifndef SUPPORT_UNICODE
       errorcode = ERR45;   /* Supported only with Unicode support */
       goto ESCAPE_FAILED;
 #endif
       case ESC_H:
       case ESC_h:
       case ESC_N:
       case ESC_R:
       case ESC_V:
       case ESC_v:
       okquantifier = TRUE;
       *parsed_pattern++ = META_ESCAPE + escape;
       break;
 
       default:  /* \A, \B, \b, \G, \K, \Z, \z cannot be quantified. */
       *parsed_pattern++ = META_ESCAPE + escape;
       break;
 
       /* Escapes that may change in UCP mode. */
 
       case ESC_d:
       case ESC_D:
       case ESC_s:
       case ESC_S:
       case ESC_w:
       case ESC_W:
       okquantifier = TRUE;
       parsed_pattern = handle_escdsw(escape, parsed_pattern, options,
         xoptions);
       break;
 
       /* Unicode property matching */
 
       case ESC_P:
       case ESC_p:
 #ifdef SUPPORT_UNICODE
         {
         BOOL negated;
         uint16_t ptype = 0, pdata = 0;
         if (!get_ucp(&ptr, &negated, &ptype, &pdata, &errorcode, cb))
           goto ESCAPE_FAILED;
         if (negated) escape = (escape == ESC_P)? ESC_p : ESC_P;
         *parsed_pattern++ = META_ESCAPE + escape;
         *parsed_pattern++ = (ptype << 16) | pdata;
         okquantifier = TRUE;
         }
 #else
       errorcode = ERR45;
       goto ESCAPE_FAILED;
 #endif
       break;  /* End \P and \p */
 
       /* When \g is used with quotes or angle brackets as delimiters, it is a
       numerical or named subroutine call, and control comes here. When used
       with brace delimiters it is a numberical back reference and does not come
       here because check_escape() returns it directly as a reference. \k is
       always a named back reference. */
 
       case ESC_g:
       case ESC_k:
       if (ptr >= ptrend || (*ptr != CHAR_LEFT_CURLY_BRACKET &&
           *ptr != CHAR_LESS_THAN_SIGN && *ptr != CHAR_APOSTROPHE))
         {
         errorcode = (escape == ESC_g)? ERR57 : ERR69;
         goto ESCAPE_FAILED;
         }
       terminator = (*ptr == CHAR_LESS_THAN_SIGN)?
         CHAR_GREATER_THAN_SIGN : (*ptr == CHAR_APOSTROPHE)?
         CHAR_APOSTROPHE : CHAR_RIGHT_CURLY_BRACKET;
 
       /* For a non-braced \g, check for a numerical recursion. */
 
       if (escape == ESC_g && terminator != CHAR_RIGHT_CURLY_BRACKET)
         {
         PCRE2_SPTR p = ptr + 1;
 
         if (read_number(&p, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &i,
             &errorcode))
           {
           if (p >= ptrend || *p != terminator)
             {
             errorcode = ERR57;
             goto ESCAPE_FAILED;
             }
           ptr = p;
           goto SET_RECURSION;
           }
         if (errorcode != 0) goto ESCAPE_FAILED;
         }
 
       /* Not a numerical recursion. Perl allows spaces and tabs after { and
       before } but not for other delimiters. */
 
       if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,
           &errorcode, cb)) goto ESCAPE_FAILED;
 
       /* \k and \g when used with braces are back references, whereas \g used
       with quotes or angle brackets is a recursion */
 
       *parsed_pattern++ =
         (escape == ESC_k || terminator == CHAR_RIGHT_CURLY_BRACKET)?
           META_BACKREF_BYNAME : META_RECURSE_BYNAME;
       *parsed_pattern++ = namelen;
 
       PUTOFFSET(offset, parsed_pattern);
       okquantifier = TRUE;
       break;  /* End special escape processing */
       }
     break;    /* End escape sequence processing */
 
 
     /* ---- Single-character special items ---- */
 
     case CHAR_CIRCUMFLEX_ACCENT:
     *parsed_pattern++ = META_CIRCUMFLEX;
     break;
 
     case CHAR_DOLLAR_SIGN:
     *parsed_pattern++ = META_DOLLAR;
     break;
 
     case CHAR_DOT:
     *parsed_pattern++ = META_DOT;
     okquantifier = TRUE;
     break;
 
 
     /* ---- Single-character quantifiers ---- */
 
     case CHAR_ASTERISK:
     meta_quantifier = META_ASTERISK;
     goto CHECK_QUANTIFIER;
 
     case CHAR_PLUS:
     meta_quantifier = META_PLUS;
     goto CHECK_QUANTIFIER;
 
     case CHAR_QUESTION_MARK:
     meta_quantifier = META_QUERY;
     goto CHECK_QUANTIFIER;
 
 
     /* ---- Potential {n,m} quantifier ---- */
 
     case CHAR_LEFT_CURLY_BRACKET:
     if (!read_repeat_counts(&ptr, ptrend, &min_repeat, &max_repeat,
         &errorcode))
       {
       if (errorcode != 0) goto FAILED;     /* Error in quantifier. */
       PARSED_LITERAL(c, parsed_pattern);   /* Not a quantifier */
       break;                               /* No more quantifier processing */
       }
     meta_quantifier = META_MINMAX;
     /* Fall through */
 
 
     /* ---- Quantifier post-processing ---- */
 
-    /* Check that a quantifier is allowed after the previous item. */
+    /* Check that a quantifier is allowed after the previous item. This
+    guarantees that there is a previous item. */
 
     CHECK_QUANTIFIER:
     if (!prev_okquantifier)
       {
       errorcode = ERR9;
       goto FAILED_BACK;
       }
 
     /* Most (*VERB)s are not allowed to be quantified, but an ungreedy
     quantifier can be useful for (*ACCEPT) - meaning "succeed on backtrack", a
     sort of negated (*COMMIT). We therefore allow (*ACCEPT) to be quantified by
     wrapping it in non-capturing brackets, but we have to allow for a preceding
     (*MARK) for when (*ACCEPT) has an argument. */
 
     if (*prev_parsed_item == META_ACCEPT)
       {
       uint32_t *p;
       for (p = parsed_pattern - 1; p >= verbstartptr; p--) p[1] = p[0];
       *verbstartptr = META_NOCAPTURE;
       parsed_pattern[1] = META_KET;
       parsed_pattern += 2;
       }
 
     /* Now we can put the quantifier into the parsed pattern vector. At this
     stage, we have only the basic quantifier. The check for a following + or ?
     modifier happens at the top of the loop, after any intervening comments
     have been removed. */
 
     *parsed_pattern++ = meta_quantifier;
     if (c == CHAR_LEFT_CURLY_BRACKET)
       {
       *parsed_pattern++ = min_repeat;
       *parsed_pattern++ = max_repeat;
       }
     break;
 
 
     /* ---- Character class ---- */
 
     case CHAR_LEFT_SQUARE_BRACKET:
     okquantifier = TRUE;
 
     /* In another (POSIX) regex library, the ugly syntax [[:<:]] and [[:>:]] is
     used for "start of word" and "end of word". As these are otherwise illegal
     sequences, we don't break anything by recognizing them. They are replaced
     by \b(?=\w) and \b(?<=\w) respectively. Sequences like [a[:<:]] are
     erroneous and are handled by the normal code below. */
 
     if (ptrend - ptr >= 6 &&
          (PRIV(strncmp_c8)(ptr, STRING_WEIRD_STARTWORD, 6) == 0 ||
           PRIV(strncmp_c8)(ptr, STRING_WEIRD_ENDWORD, 6) == 0))
       {
       *parsed_pattern++ = META_ESCAPE + ESC_b;
 
       if (ptr[2] == CHAR_LESS_THAN_SIGN)
         {
         *parsed_pattern++ = META_LOOKAHEAD;
         }
       else
         {
         *parsed_pattern++ = META_LOOKBEHIND;
         *has_lookbehind = TRUE;
 
         /* The offset is used only for the "non-fixed length" error; this won't
         occur here, so just store zero. */
 
         PUTOFFSET((PCRE2_SIZE)0, parsed_pattern);
         }
 
       if ((options & PCRE2_UCP) == 0)
         *parsed_pattern++ = META_ESCAPE + ESC_w;
       else
         {
         *parsed_pattern++ = META_ESCAPE + ESC_p;
         *parsed_pattern++ = PT_WORD << 16;
         }
       *parsed_pattern++ = META_KET;
       ptr += 6;
       break;
       }
 
     /* PCRE supports POSIX class stuff inside a class. Perl gives an error if
     they are encountered at the top level, so we'll do that too. */
 
     if (ptr < ptrend && (*ptr == CHAR_COLON || *ptr == CHAR_DOT ||
          *ptr == CHAR_EQUALS_SIGN) &&
         check_posix_syntax(ptr, ptrend, &tempptr))
       {
       errorcode = (*ptr-- == CHAR_COLON)? ERR12 : ERR13;
       goto FAILED;
       }
 
     /* Process a regular character class. If the first character is '^', set
     the negation flag. If the first few characters (either before or after ^)
     are \Q\E or \E or space or tab in extended-more mode, we skip them too.
     This makes for compatibility with Perl. */
 
     negate_class = FALSE;
     while (ptr < ptrend)
       {
       GETCHARINCTEST(c, ptr);
       if (c == CHAR_BACKSLASH)
         {
         if (ptr < ptrend && *ptr == CHAR_E) ptr++;
         else if (ptrend - ptr >= 3 &&
              PRIV(strncmp_c8)(ptr, STR_Q STR_BACKSLASH STR_E, 3) == 0)
           ptr += 3;
         else
           break;
         }
       else if ((options & PCRE2_EXTENDED_MORE) != 0 &&
                (c == CHAR_SPACE || c == CHAR_HT))  /* Note: just these two */
         continue;
       else if (!negate_class && c == CHAR_CIRCUMFLEX_ACCENT)
         negate_class = TRUE;
       else break;
       }
 
     /* Now the real contents of the class; c has the first "real" character.
     Empty classes are permitted only if the option is set. */
 
     if (c == CHAR_RIGHT_SQUARE_BRACKET &&
         (cb->external_options & PCRE2_ALLOW_EMPTY_CLASS) != 0)
       {
       *parsed_pattern++ = negate_class? META_CLASS_EMPTY_NOT : META_CLASS_EMPTY;
       break;  /* End of class processing */
       }
 
     /* Process a non-empty class. */
 
     *parsed_pattern++ = negate_class? META_CLASS_NOT : META_CLASS;
     class_range_state = RANGE_NO;
 
     /* In an EBCDIC environment, Perl treats alphabetic ranges specially
     because there are holes in the encoding, and simply using the range A-Z
     (for example) would include the characters in the holes. This applies only
     to ranges where both values are literal; [\xC1-\xE9] is different to [A-Z]
     in this respect. In order to accommodate this, we keep track of whether
     character values are literal or not, and a state variable for handling
     ranges. */
 
     /* Loop for the contents of the class */
 
     for (;;)
       {
       BOOL char_is_literal = TRUE;
 
       /* Inside \Q...\E everything is literal except \E */
 
       if (inescq)
         {
         if (c == CHAR_BACKSLASH && ptr < ptrend && *ptr == CHAR_E)
           {
           inescq = FALSE;                   /* Reset literal state */
           ptr++;                            /* Skip the 'E' */
           goto CLASS_CONTINUE;
           }
         goto CLASS_LITERAL;
         }
 
       /* Skip over space and tab (only) in extended-more mode. */
 
       if ((options & PCRE2_EXTENDED_MORE) != 0 &&
           (c == CHAR_SPACE || c == CHAR_HT))
         goto CLASS_CONTINUE;
 
       /* Handle POSIX class names. Perl allows a negation extension of the
       form [:^name:]. A square bracket that doesn't match the syntax is
       treated as a literal. We also recognize the POSIX constructions
       [.ch.] and [=ch=] ("collating elements") and fault them, as Perl
       5.6 and 5.8 do. */
 
       if (c == CHAR_LEFT_SQUARE_BRACKET &&
           ptrend - ptr >= 3 &&
           (*ptr == CHAR_COLON || *ptr == CHAR_DOT ||
            *ptr == CHAR_EQUALS_SIGN) &&
           check_posix_syntax(ptr, ptrend, &tempptr))
         {
         BOOL posix_negate = FALSE;
         int posix_class;
 
         /* Perl treats a hyphen before a POSIX class as a literal, not the
         start of a range. However, it gives a warning in its warning mode. PCRE
         does not have a warning mode, so we give an error, because this is
         likely an error on the user's part. */
 
         if (class_range_state == RANGE_STARTED)
           {
           errorcode = ERR50;
           goto FAILED;
           }
 
         if (*ptr != CHAR_COLON)
           {
           errorcode = ERR13;
           goto FAILED_BACK;
           }
 
         if (*(++ptr) == CHAR_CIRCUMFLEX_ACCENT)
           {
           posix_negate = TRUE;
           ptr++;
           }
 
         posix_class = check_posix_name(ptr, (int)(tempptr - ptr));
         if (posix_class < 0)
           {
           errorcode = ERR30;
           goto FAILED;
           }
         ptr = tempptr + 2;
 
         /* Perl treats a hyphen after a POSIX class as a literal, not the
         start of a range. However, it gives a warning in its warning mode
         unless the hyphen is the last character in the class. PCRE does not
         have a warning mode, so we give an error, because this is likely an
         error on the user's part. */
 
         if (ptr < ptrend - 1 && *ptr == CHAR_MINUS &&
             ptr[1] != CHAR_RIGHT_SQUARE_BRACKET)
           {
           errorcode = ERR50;
           goto FAILED;
           }
 
         /* Set "a hyphen is not the start of a range" for the -] case, and also
         in case the POSIX class is followed by \E or \Q\E (possibly repeated -
         fuzzers do that kind of thing) and *then* a hyphen. This causes that
         hyphen to be treated as a literal. I don't think it's worth setting up
         special apparatus to do otherwise. */
 
         class_range_state = RANGE_NO;
 
         /* When PCRE2_UCP is set, unless PCRE2_EXTRA_ASCII_POSIX is set, some
         of the POSIX classes are converted to use Unicode properties \p or \P
         or, in one case, \h or \H. The substitutes table has two values per
         class, containing the type and value of a \p or \P item. The special
         cases are specified with a negative type: a non-zero value causes \h or
         \H to be used, and a zero value falls through to behave like a non-UCP
         POSIX class. There are now also some extra options that force ASCII for
         some classes. */
 
 #ifdef SUPPORT_UNICODE
         if ((options & PCRE2_UCP) != 0 &&
             (xoptions & PCRE2_EXTRA_ASCII_POSIX) == 0 &&
             !((xoptions & PCRE2_EXTRA_ASCII_DIGIT) != 0 &&
               (posix_class == PC_DIGIT || posix_class == PC_XDIGIT)))
           {
           int ptype = posix_substitutes[2*posix_class];
           int pvalue = posix_substitutes[2*posix_class + 1];
 
           if (ptype >= 0)
             {
             *parsed_pattern++ = META_ESCAPE + (posix_negate? ESC_P : ESC_p);
             *parsed_pattern++ = (ptype << 16) | pvalue;
             goto CLASS_CONTINUE;
             }
 
           if (pvalue != 0)
             {
             *parsed_pattern++ = META_ESCAPE + (posix_negate? ESC_H : ESC_h);
             goto CLASS_CONTINUE;
             }
 
           /* Fall through */
           }
 #endif  /* SUPPORT_UNICODE */
 
         /* Non-UCP POSIX class */
 
         *parsed_pattern++ = posix_negate? META_POSIX_NEG : META_POSIX;
         *parsed_pattern++ = posix_class;
         }
 
       /* Handle potential start of range */
 
       else if (c == CHAR_MINUS && class_range_state >= RANGE_OK_ESCAPED)
         {
         *parsed_pattern++ = (class_range_state == RANGE_OK_LITERAL)?
           META_RANGE_LITERAL : META_RANGE_ESCAPED;
         class_range_state = RANGE_STARTED;
         }
 
       /* Handle a literal character */
 
       else if (c != CHAR_BACKSLASH)
         {
         CLASS_LITERAL:
         if (class_range_state == RANGE_STARTED)
           {
           if (c == parsed_pattern[-2])       /* Optimize one-char range */
             parsed_pattern--;
           else if (parsed_pattern[-2] > c)   /* Check range is in order */
             {
             errorcode = ERR8;
             goto FAILED_BACK;
             }
           else
             {
             if (!char_is_literal && parsed_pattern[-1] == META_RANGE_LITERAL)
               parsed_pattern[-1] = META_RANGE_ESCAPED;
             PARSED_LITERAL(c, parsed_pattern);
             }
           class_range_state = RANGE_NO;
           }
         else  /* Potential start of range */
           {
           class_range_state = char_is_literal?
             RANGE_OK_LITERAL : RANGE_OK_ESCAPED;
           PARSED_LITERAL(c, parsed_pattern);
           }
         }
 
       /* Handle escapes in a class */
 
       else
         {
         tempptr = ptr;
         escape = PRIV(check_escape)(&ptr, ptrend, &c, &errorcode, options,
           xoptions, TRUE, cb);
 
         if (errorcode != 0)
           {
           if ((xoptions & PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL) == 0)
             goto FAILED;
           ptr = tempptr;
           if (ptr >= ptrend) c = CHAR_BACKSLASH; else
             {
             GETCHARINCTEST(c, ptr);   /* Get character value, increment pointer */
             }
           escape = 0;                 /* Treat as literal character */
           }
 
         switch(escape)
           {
           case 0:  /* Escaped character code point is in c */
           char_is_literal = FALSE;
           goto CLASS_LITERAL;      /* (a few lines above) */
 
           case ESC_b:
           c = CHAR_BS;    /* \b is backspace in a class */
           char_is_literal = FALSE;
           goto CLASS_LITERAL;
 
           case ESC_Q:
           inescq = TRUE;  /* Enter literal mode */
           goto CLASS_CONTINUE;
 
           case ESC_E:     /* Ignore orphan \E */
           goto CLASS_CONTINUE;
 
           case ESC_B:     /* Always an error in a class */
           case ESC_R:
           case ESC_X:
           errorcode = ERR7;
           ptr--;
           goto FAILED;
           }
 
         /* The second part of a range can be a single-character escape
         sequence (detected above), but not any of the other escapes. Perl
         treats a hyphen as a literal in such circumstances. However, in Perl's
         warning mode, a warning is given, so PCRE now faults it, as it is
         almost certainly a mistake on the user's part. */
 
         if (class_range_state == RANGE_STARTED)
           {
           errorcode = ERR50;
           goto FAILED;  /* Not CLASS_ESCAPE_FAILED; always an error */
           }
 
         /* Of the remaining escapes, only those that define characters are
         allowed in a class. None may start a range. */
 
         class_range_state = RANGE_NO;
         switch(escape)
           {
           case ESC_N:
           errorcode = ERR71;
           goto FAILED;
 
           case ESC_H:
           case ESC_h:
           case ESC_V:
           case ESC_v:
           *parsed_pattern++ = META_ESCAPE + escape;
           break;
 
           /* These escapes may be converted to Unicode property tests when
           PCRE2_UCP is set. */
 
           case ESC_d:
           case ESC_D:
           case ESC_s:
           case ESC_S:
           case ESC_w:
           case ESC_W:
           parsed_pattern = handle_escdsw(escape, parsed_pattern, options,
             xoptions);
           break;
 
           /* Explicit Unicode property matching */
 
           case ESC_P:
           case ESC_p:
 #ifdef SUPPORT_UNICODE
             {
             BOOL negated;
             uint16_t ptype = 0, pdata = 0;
             if (!get_ucp(&ptr, &negated, &ptype, &pdata, &errorcode, cb))
               goto FAILED;
             if (negated) escape = (escape == ESC_P)? ESC_p : ESC_P;
             *parsed_pattern++ = META_ESCAPE + escape;
             *parsed_pattern++ = (ptype << 16) | pdata;
             }
 #else
           errorcode = ERR45;
           goto FAILED;
 #endif
           break;  /* End \P and \p */
 
           default:    /* All others are not allowed in a class */
           errorcode = ERR7;
           ptr--;
           goto FAILED;
           }
 
         /* Perl gives a warning unless a following hyphen is the last character
         in the class. PCRE throws an error. */
 
         if (ptr < ptrend - 1 && *ptr == CHAR_MINUS &&
             ptr[1] != CHAR_RIGHT_SQUARE_BRACKET)
           {
           errorcode = ERR50;
           goto FAILED;
           }
         }
 
       /* Proceed to next thing in the class. */
 
       CLASS_CONTINUE:
       if (ptr >= ptrend)
         {
         errorcode = ERR6;  /* Missing terminating ']' */
         goto FAILED;
         }
       GETCHARINCTEST(c, ptr);
       if (c == CHAR_RIGHT_SQUARE_BRACKET && !inescq) break;
       }     /* End of class-processing loop */
 
     /* -] at the end of a class is a literal '-' */
 
     if (class_range_state == RANGE_STARTED)
       {
       parsed_pattern[-1] = CHAR_MINUS;
       class_range_state = RANGE_NO;
       }
 
     *parsed_pattern++ = META_CLASS_END;
     break;  /* End of character class */
 
 
     /* ---- Opening parenthesis ---- */
 
     case CHAR_LEFT_PARENTHESIS:
     if (ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
 
     /* If ( is not followed by ? it is either a capture or a special verb or an
     alpha assertion or a positive non-atomic lookahead. */
 
     if (*ptr != CHAR_QUESTION_MARK)
       {
       const char *vn;
 
       /* Handle capturing brackets (or non-capturing if auto-capture is turned
       off). */
 
       if (*ptr != CHAR_ASTERISK)
         {
         nest_depth++;
         if ((options & PCRE2_NO_AUTO_CAPTURE) == 0)
           {
           if (cb->bracount >= MAX_GROUP_NUMBER)
             {
             errorcode = ERR97;
             goto FAILED;
             }
           cb->bracount++;
           *parsed_pattern++ = META_CAPTURE | cb->bracount;
           }
         else *parsed_pattern++ = META_NOCAPTURE;
         }
 
       /* Do nothing for (* followed by end of pattern or ) so it gives a "bad
       quantifier" error rather than "(*MARK) must have an argument". */
 
       else if (ptrend - ptr <= 1 || (c = ptr[1]) == CHAR_RIGHT_PARENTHESIS)
         break;
 
       /* Handle "alpha assertions" such as (*pla:...). Most of these are
       synonyms for the historical symbolic assertions, but the script run and
       non-atomic lookaround ones are new. They are distinguished by starting
       with a lower case letter. Checking both ends of the alphabet makes this
       work in all character codes. */
 
       else if (CHMAX_255(c) && (cb->ctypes[c] & ctype_lcletter) != 0)
         {
         uint32_t meta;
 
         vn = alasnames;
         if (!read_name(&ptr, ptrend, utf, 0, &offset, &name, &namelen,
           &errorcode, cb)) goto FAILED;
         if (ptr >= ptrend || *ptr != CHAR_COLON)
           {
           errorcode = ERR95;  /* Malformed */
           goto FAILED;
           }
 
         /* Scan the table of alpha assertion names */
 
         for (i = 0; i < alascount; i++)
           {
           if (namelen == alasmeta[i].len &&
               PRIV(strncmp_c8)(name, vn, namelen) == 0)
             break;
           vn += alasmeta[i].len + 1;
           }
 
         if (i >= alascount)
           {
           errorcode = ERR95;  /* Alpha assertion not recognized */
           goto FAILED;
           }
 
         /* Check for expecting an assertion condition. If so, only atomic
         lookaround assertions are valid. */
 
         meta = alasmeta[i].meta;
         if (prev_expect_cond_assert > 0 &&
             (meta < META_LOOKAHEAD || meta > META_LOOKBEHINDNOT))
           {
           errorcode = (meta == META_LOOKAHEAD_NA || meta == META_LOOKBEHIND_NA)?
             ERR98 : ERR28;  /* (Atomic) assertion expected */
           goto FAILED;
           }
 
         /* The lookaround alphabetic synonyms can mostly be handled by jumping
         to the code that handles the traditional symbolic forms. */
 
         switch(meta)
           {
           default:
           errorcode = ERR89;  /* Unknown code; should never occur because */
           goto FAILED;        /* the meta values come from a table above. */
 
           case META_ATOMIC:
           goto ATOMIC_GROUP;
 
           case META_LOOKAHEAD:
           goto POSITIVE_LOOK_AHEAD;
 
           case META_LOOKAHEAD_NA:
           goto POSITIVE_NONATOMIC_LOOK_AHEAD;
 
           case META_LOOKAHEADNOT:
           goto NEGATIVE_LOOK_AHEAD;
 
           case META_LOOKBEHIND:
           case META_LOOKBEHINDNOT:
           case META_LOOKBEHIND_NA:
           *parsed_pattern++ = meta;
           ptr--;
           goto POST_LOOKBEHIND;
 
           /* The script run facilities are handled here. Unicode support is
           required (give an error if not, as this is a security issue). Always
           record a META_SCRIPT_RUN item. Then, for the atomic version, insert
           META_ATOMIC and remember that we need two META_KETs at the end. */
 
           case META_SCRIPT_RUN:
           case META_ATOMIC_SCRIPT_RUN:
 #ifdef SUPPORT_UNICODE
           *parsed_pattern++ = META_SCRIPT_RUN;
           nest_depth++;
           ptr++;
           if (meta == META_ATOMIC_SCRIPT_RUN)
             {
             *parsed_pattern++ = META_ATOMIC;
             if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);
             else if (++top_nest >= end_nests)
               {
               errorcode = ERR84;
               goto FAILED;
               }
             top_nest->nest_depth = nest_depth;
             top_nest->flags = NSF_ATOMICSR;
             top_nest->options = options & PARSE_TRACKED_OPTIONS;
             top_nest->xoptions = xoptions & PARSE_TRACKED_EXTRA_OPTIONS;
             }
           break;
 #else  /* SUPPORT_UNICODE */
           errorcode = ERR96;
           goto FAILED;
 #endif
           }
         }
 
 
       /* ---- Handle (*VERB) and (*VERB:NAME) ---- */
 
       else
         {
         vn = verbnames;
         if (!read_name(&ptr, ptrend, utf, 0, &offset, &name, &namelen,
           &errorcode, cb)) goto FAILED;
         if (ptr >= ptrend || (*ptr != CHAR_COLON &&
                               *ptr != CHAR_RIGHT_PARENTHESIS))
           {
           errorcode = ERR60;  /* Malformed */
           goto FAILED;
           }
 
         /* Scan the table of verb names */
 
         for (i = 0; i < verbcount; i++)
           {
           if (namelen == verbs[i].len &&
               PRIV(strncmp_c8)(name, vn, namelen) == 0)
             break;
           vn += verbs[i].len + 1;
           }
 
         if (i >= verbcount)
           {
           errorcode = ERR60;  /* Verb not recognized */
           goto FAILED;
           }
 
         /* An empty argument is treated as no argument. */
 
         if (*ptr == CHAR_COLON && ptr + 1 < ptrend &&
              ptr[1] == CHAR_RIGHT_PARENTHESIS)
           ptr++;    /* Advance to the closing parens */
 
         /* Check for mandatory non-empty argument; this is (*MARK) */
 
         if (verbs[i].has_arg > 0 && *ptr != CHAR_COLON)
           {
           errorcode = ERR66;
           goto FAILED;
           }
 
         /* Remember where this verb, possibly with a preceding (*MARK), starts,
         for handling quantified (*ACCEPT). */
 
         verbstartptr = parsed_pattern;
         okquantifier = (verbs[i].meta == META_ACCEPT);
 
         /* It appears that Perl allows any characters whatsoever, other than a
         closing parenthesis, to appear in arguments ("names"), so we no longer
         insist on letters, digits, and underscores. Perl does not, however, do
         any interpretation within arguments, and has no means of including a
         closing parenthesis. PCRE supports escape processing but only when it
         is requested by an option. We set inverbname TRUE here, and let the
         main loop take care of this so that escape and \x processing is done by
         the main code above. */
 
         if (*ptr++ == CHAR_COLON)   /* Skip past : or ) */
           {
           /* Some optional arguments can be treated as a preceding (*MARK) */
 
           if (verbs[i].has_arg < 0)
             {
             add_after_mark = verbs[i].meta;
             *parsed_pattern++ = META_MARK;
             }
 
           /* The remaining verbs with arguments (except *MARK) need a different
           opcode. */
 
           else
             {
             *parsed_pattern++ = verbs[i].meta +
               ((verbs[i].meta != META_MARK)? 0x00010000u:0);
             }
 
           /* Set up for reading the name in the main loop. */
 
           verblengthptr = parsed_pattern++;
           verbnamestart = ptr;
           inverbname = TRUE;
           }
         else  /* No verb "name" argument */
           {
           *parsed_pattern++ = verbs[i].meta;
           }
         }     /* End of (*VERB) handling */
       break;  /* Done with this parenthesis */
       }       /* End of groups that don't start with (? */
 
 
     /* ---- Items starting (? ---- */
 
     /* The type of item is determined by what follows (?. Handle (?| and option
     changes under "default" because both need a new block on the nest stack.
     Comments starting with (?# are handled above. Note that there is some
     ambiguity about the sequence (?- because if a digit follows it's a relative
     recursion or subroutine call whereas otherwise it's an option unsetting. */
 
     if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
 
     switch(*ptr)
       {
       default:
       if (*ptr == CHAR_MINUS && ptrend - ptr > 1 && IS_DIGIT(ptr[1]))
         goto RECURSION_BYNUMBER;  /* The + case is handled by CHAR_PLUS */
 
       /* We now have either (?| or a (possibly empty) option setting,
       optionally followed by a non-capturing group. */
 
       nest_depth++;
       if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);
       else if (++top_nest >= end_nests)
         {
         errorcode = ERR84;
         goto FAILED;
         }
       top_nest->nest_depth = nest_depth;
       top_nest->flags = 0;
       top_nest->options = options & PARSE_TRACKED_OPTIONS;
       top_nest->xoptions = xoptions & PARSE_TRACKED_EXTRA_OPTIONS;
 
       /* Start of non-capturing group that resets the capture count for each
       branch. */
 
       if (*ptr == CHAR_VERTICAL_LINE)
         {
         top_nest->reset_group = (uint16_t)cb->bracount;
         top_nest->max_group = (uint16_t)cb->bracount;
         top_nest->flags |= NSF_RESET;
         cb->external_flags |= PCRE2_DUPCAPUSED;
         *parsed_pattern++ = META_NOCAPTURE;
         ptr++;
         }
 
       /* Scan for options imnrsxJU to be set or unset. */
 
       else
         {
         BOOL hyphenok = TRUE;
         uint32_t oldoptions = options;
         uint32_t oldxoptions = xoptions;
 
         top_nest->reset_group = 0;
         top_nest->max_group = 0;
         set = unset = 0;
         optset = &set;
         xset = xunset = 0;
         xoptset = &xset;
 
         /* ^ at the start unsets irmnsx and disables the subsequent use of - */
 
         if (ptr < ptrend && *ptr == CHAR_CIRCUMFLEX_ACCENT)
           {
           options &= ~(PCRE2_CASELESS|PCRE2_MULTILINE|PCRE2_NO_AUTO_CAPTURE|
                        PCRE2_DOTALL|PCRE2_EXTENDED|PCRE2_EXTENDED_MORE);
           xoptions &= ~(PCRE2_EXTRA_CASELESS_RESTRICT);
           hyphenok = FALSE;
           ptr++;
           }
 
         while (ptr < ptrend && *ptr != CHAR_RIGHT_PARENTHESIS &&
                                *ptr != CHAR_COLON)
           {
           switch (*ptr++)
             {
             case CHAR_MINUS:
             if (!hyphenok)
               {
               errorcode = ERR94;
               ptr--;  /* Correct the offset */
               goto FAILED;
               }
             optset = &unset;
             xoptset = &xunset;
             hyphenok = FALSE;
             break;
 
             /* There are some two-character sequences that start with 'a'. */
 
             case CHAR_a:
             if (ptr < ptrend)
               {
               if (*ptr == CHAR_D)
                 {
                 *xoptset |= PCRE2_EXTRA_ASCII_BSD;
                 ptr++;
                 break;
                 }
               if (*ptr == CHAR_P)
                 {
                 *xoptset |= (PCRE2_EXTRA_ASCII_POSIX|PCRE2_EXTRA_ASCII_DIGIT);
                 ptr++;
                 break;
                 }
               if (*ptr == CHAR_S)
                 {
                 *xoptset |= PCRE2_EXTRA_ASCII_BSS;
                 ptr++;
                 break;
                 }
               if (*ptr == CHAR_T)
                 {
                 *xoptset |= PCRE2_EXTRA_ASCII_DIGIT;
                 ptr++;
                 break;
                 }
               if (*ptr == CHAR_W)
                 {
                 *xoptset |= PCRE2_EXTRA_ASCII_BSW;
                 ptr++;
                 break;
                 }
               }
             *xoptset |= PCRE2_EXTRA_ASCII_BSD|PCRE2_EXTRA_ASCII_BSS|
                         PCRE2_EXTRA_ASCII_BSW|
                         PCRE2_EXTRA_ASCII_DIGIT|PCRE2_EXTRA_ASCII_POSIX;
             break;
 
             case CHAR_J:  /* Record that it changed in the external options */
             *optset |= PCRE2_DUPNAMES;
             cb->external_flags |= PCRE2_JCHANGED;
             break;
 
             case CHAR_i: *optset |= PCRE2_CASELESS; break;
             case CHAR_m: *optset |= PCRE2_MULTILINE; break;
             case CHAR_n: *optset |= PCRE2_NO_AUTO_CAPTURE; break;
             case CHAR_r: *xoptset|= PCRE2_EXTRA_CASELESS_RESTRICT; break;
             case CHAR_s: *optset |= PCRE2_DOTALL; break;
             case CHAR_U: *optset |= PCRE2_UNGREEDY; break;
 
             /* If x appears twice it sets the extended extended option. */
 
             case CHAR_x:
             *optset |= PCRE2_EXTENDED;
             if (ptr < ptrend && *ptr == CHAR_x)
               {
               *optset |= PCRE2_EXTENDED_MORE;
               ptr++;
               }
             break;
 
             default:
             errorcode = ERR11;
             ptr--;    /* Correct the offset */
             goto FAILED;
             }
           }
 
         /* If we are setting extended without extended-more, ensure that any
         existing extended-more gets unset. Also, unsetting extended must also
         unset extended-more. */
 
         if ((set & (PCRE2_EXTENDED|PCRE2_EXTENDED_MORE)) == PCRE2_EXTENDED ||
             (unset & PCRE2_EXTENDED) != 0)
           unset |= PCRE2_EXTENDED_MORE;
 
         options = (options | set) & (~unset);
         xoptions = (xoptions | xset) & (~xunset);
 
         /* If the options ended with ')' this is not the start of a nested
         group with option changes, so the options change at this level.
         In this case, if the previous level set up a nest block, discard the
         one we have just created. Otherwise adjust it for the previous level.
         If the options ended with ':' we are starting a non-capturing group,
         possibly with an options setting. */
 
         if (ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
         if (*ptr++ == CHAR_RIGHT_PARENTHESIS)
           {
           nest_depth--;  /* This is not a nested group after all. */
           if (top_nest > (nest_save *)(cb->start_workspace) &&
               (top_nest-1)->nest_depth == nest_depth) top_nest--;
           else top_nest->nest_depth = nest_depth;
           }
         else *parsed_pattern++ = META_NOCAPTURE;
 
         /* If nothing changed, no need to record. */
 
         if (options != oldoptions || xoptions != oldxoptions)
           {
           *parsed_pattern++ = META_OPTIONS;
           *parsed_pattern++ = options;
           *parsed_pattern++ = xoptions;
           }
         }     /* End options processing */
       break;  /* End default case after (? */
 
 
       /* ---- Python syntax support ---- */
 
       case CHAR_P:
       if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
 
       /* (?P<name> is the same as (?<name>, which defines a named group. */
 
       if (*ptr == CHAR_LESS_THAN_SIGN)
         {
         terminator = CHAR_GREATER_THAN_SIGN;
         goto DEFINE_NAME;
         }
 
       /* (?P>name) is the same as (?&name), which is a recursion or subroutine
       call. */
 
       if (*ptr == CHAR_GREATER_THAN_SIGN) goto RECURSE_BY_NAME;
 
       /* (?P=name) is the same as \k<name>, a back reference by name. Anything
       else after (?P is an error. */
 
       if (*ptr != CHAR_EQUALS_SIGN)
         {
         errorcode = ERR41;
         goto FAILED;
         }
       if (!read_name(&ptr, ptrend, utf, CHAR_RIGHT_PARENTHESIS, &offset, &name,
           &namelen, &errorcode, cb)) goto FAILED;
       *parsed_pattern++ = META_BACKREF_BYNAME;
       *parsed_pattern++ = namelen;
       PUTOFFSET(offset, parsed_pattern);
       okquantifier = TRUE;
       break;   /* End of (?P processing */
 
 
       /* ---- Recursion/subroutine calls by number ---- */
 
       case CHAR_R:
       i = 0;         /* (?R) == (?R0) */
       ptr++;
       if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
         {
         errorcode = ERR58;
         goto FAILED;
         }
       goto SET_RECURSION;
 
       /* An item starting (?- followed by a digit comes here via the "default"
       case because (?- followed by a non-digit is an options setting. */
 
       case CHAR_PLUS:
       if (ptrend - ptr < 2 || !IS_DIGIT(ptr[1]))
         {
         errorcode = ERR29;   /* Missing number */
         goto FAILED;
         }
       /* Fall through */
 
       case CHAR_0: case CHAR_1: case CHAR_2: case CHAR_3: case CHAR_4:
       case CHAR_5: case CHAR_6: case CHAR_7: case CHAR_8: case CHAR_9:
       RECURSION_BYNUMBER:
       if (!read_number(&ptr, ptrend,
           (IS_DIGIT(*ptr))? -1:(int)(cb->bracount), /* + and - are relative */
           MAX_GROUP_NUMBER, ERR61,
           &i, &errorcode)) goto FAILED;
       if (i < 0)  /* NB (?0) is permitted */
         {
         errorcode = ERR15;   /* Unknown group */
         goto FAILED_BACK;
         }
       if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
         goto UNCLOSED_PARENTHESIS;
 
       SET_RECURSION:
       *parsed_pattern++ = META_RECURSE | (uint32_t)i;
       offset = (PCRE2_SIZE)(ptr - cb->start_pattern);
       ptr++;
       PUTOFFSET(offset, parsed_pattern);
       okquantifier = TRUE;
       break;  /* End of recursive call by number handling */
 
 
       /* ---- Recursion/subroutine calls by name ---- */
 
       case CHAR_AMPERSAND:
       RECURSE_BY_NAME:
       if (!read_name(&ptr, ptrend, utf, CHAR_RIGHT_PARENTHESIS, &offset, &name,
           &namelen, &errorcode, cb)) goto FAILED;
       *parsed_pattern++ = META_RECURSE_BYNAME;
       *parsed_pattern++ = namelen;
       PUTOFFSET(offset, parsed_pattern);
       okquantifier = TRUE;
       break;
 
       /* ---- Callout with numerical or string argument ---- */
 
       case CHAR_C:
       if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
 
       /* If the previous item was a condition starting (?(? an assertion,
       optionally preceded by a callout, is expected. This is checked later on,
       during actual compilation. However we need to identify this kind of
       assertion in this pass because it must not be qualified. The value of
       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
       for a callout - still leaving a positive value that identifies the
       assertion. Multiple callouts or any other items will make it zero or
       less, which doesn't matter because they will cause an error later. */
 
       expect_cond_assert = prev_expect_cond_assert - 1;
 
       /* If previous_callout is not NULL, it means this follows a previous
       callout. If it was a manual callout, do nothing; this means its "length
       of next pattern item" field will remain zero. If it was an automatic
       callout, abolish it. */
 
       if (previous_callout != NULL && (options & PCRE2_AUTO_CALLOUT) != 0 &&
           previous_callout == parsed_pattern - 4 &&
           parsed_pattern[-1] == 255)
         parsed_pattern = previous_callout;
 
       /* Save for updating next pattern item length, and skip one item before
       completing. */
 
       previous_callout = parsed_pattern;
       after_manual_callout = 1;
 
       /* Handle a string argument; specific delimiter is required. */
 
       if (*ptr != CHAR_RIGHT_PARENTHESIS && !IS_DIGIT(*ptr))
         {
         PCRE2_SIZE calloutlength;
         PCRE2_SPTR startptr = ptr;
 
         delimiter = 0;
         for (i = 0; PRIV(callout_start_delims)[i] != 0; i++)
           {
           if (*ptr == PRIV(callout_start_delims)[i])
             {
             delimiter = PRIV(callout_end_delims)[i];
             break;
             }
           }
         if (delimiter == 0)
           {
           errorcode = ERR82;
           goto FAILED;
           }
 
         *parsed_pattern = META_CALLOUT_STRING;
         parsed_pattern += 3;   /* Skip pattern info */
 
         for (;;)
           {
           if (++ptr >= ptrend)
             {
             errorcode = ERR81;
             ptr = startptr;   /* To give a more useful message */
             goto FAILED;
             }
           if (*ptr == delimiter && (++ptr >= ptrend || *ptr != delimiter))
             break;
           }
 
         calloutlength = (PCRE2_SIZE)(ptr - startptr);
         if (calloutlength > UINT32_MAX)
           {
           errorcode = ERR72;
           goto FAILED;
           }
         *parsed_pattern++ = (uint32_t)calloutlength;
         offset = (PCRE2_SIZE)(startptr - cb->start_pattern);
         PUTOFFSET(offset, parsed_pattern);
         }
 
       /* Handle a callout with an optional numerical argument, which must be
       less than or equal to 255. A missing argument gives 0. */
 
       else
         {
         int n = 0;
         *parsed_pattern = META_CALLOUT_NUMBER;     /* Numerical callout */
         parsed_pattern += 3;                       /* Skip pattern info */
         while (ptr < ptrend && IS_DIGIT(*ptr))
           {
           n = n * 10 + *ptr++ - CHAR_0;
           if (n > 255)
             {
             errorcode = ERR38;
             goto FAILED;
             }
           }
         *parsed_pattern++ = n;
         }
 
       /* Both formats must have a closing parenthesis */
 
       if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
         {
         errorcode = ERR39;
         goto FAILED;
         }
       ptr++;
 
       /* Remember the offset to the next item in the pattern, and set a default
       length. This should get updated after the next item is read. */
 
       previous_callout[1] = (uint32_t)(ptr - cb->start_pattern);
       previous_callout[2] = 0;
       break;                  /* End callout */
 
 
       /* ---- Conditional group ---- */
 
       /* A condition can be an assertion, a number (referring to a numbered
       group's having been set), a name (referring to a named group), or 'R',
       referring to overall recursion. R<digits> and R&name are also permitted
       for recursion state tests. Numbers may be preceded by + or - to specify a
       relative group number.
 
       There are several syntaxes for testing a named group: (?(name)) is used
       by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).
 
       There are two unfortunate ambiguities. 'R' can be the recursive thing or
       the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
       the Perl DEFINE feature or the Python named test. We look for a name
       first; if not found, we try the other case.
 
       For compatibility with auto-callouts, we allow a callout to be specified
       before a condition that is an assertion. */
 
       case CHAR_LEFT_PARENTHESIS:
       if (++ptr >= ptrend) goto UNCLOSED_PARENTHESIS;
       nest_depth++;
 
       /* If the next character is ? or * there must be an assertion next
       (optionally preceded by a callout). We do not check this here, but
       instead we set expect_cond_assert to 2. If this is still greater than
       zero (callouts decrement it) when the next assertion is read, it will be
       marked as a condition that must not be repeated. A value greater than
       zero also causes checking that an assertion (possibly with callout)
       follows. */
 
       if (*ptr == CHAR_QUESTION_MARK || *ptr == CHAR_ASTERISK)
         {
         *parsed_pattern++ = META_COND_ASSERT;
         ptr--;   /* Pull pointer back to the opening parenthesis. */
         expect_cond_assert = 2;
         break;  /* End of conditional */
         }
 
       /* Handle (?([+-]number)... */
 
       if (read_number(&ptr, ptrend, cb->bracount, MAX_GROUP_NUMBER, ERR61, &i,
           &errorcode))
         {
         if (i <= 0)
           {
           errorcode = ERR15;
           goto FAILED;
           }
         *parsed_pattern++ = META_COND_NUMBER;
         offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 2);
         PUTOFFSET(offset, parsed_pattern);
         *parsed_pattern++ = i;
         }
       else if (errorcode != 0) goto FAILED;   /* Number too big */
 
       /* No number found. Handle the special case (?(VERSION[>]=n.m)... */
 
       else if (ptrend - ptr >= 10 &&
                PRIV(strncmp_c8)(ptr, STRING_VERSION, 7) == 0 &&
                ptr[7] != CHAR_RIGHT_PARENTHESIS)
         {
         uint32_t ge = 0;
         int major = 0;
         int minor = 0;
 
         ptr += 7;
         if (*ptr == CHAR_GREATER_THAN_SIGN)
           {
           ge = 1;
           ptr++;
           }
 
         /* NOTE: cannot write IS_DIGIT(*(++ptr)) here because IS_DIGIT
         references its argument twice. */
 
         if (*ptr != CHAR_EQUALS_SIGN || (ptr++, !IS_DIGIT(*ptr)))
           goto BAD_VERSION_CONDITION;
 
         if (!read_number(&ptr, ptrend, -1, 1000, ERR79, &major, &errorcode))
           goto FAILED;
 
         if (ptr >= ptrend) goto BAD_VERSION_CONDITION;
         if (*ptr == CHAR_DOT)
           {
           if (++ptr >= ptrend || !IS_DIGIT(*ptr)) goto BAD_VERSION_CONDITION;
           minor = (*ptr++ - CHAR_0) * 10;
           if (ptr >= ptrend) goto BAD_VERSION_CONDITION;
           if (IS_DIGIT(*ptr)) minor += *ptr++ - CHAR_0;
           if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
             goto BAD_VERSION_CONDITION;
           }
 
         *parsed_pattern++ = META_COND_VERSION;
         *parsed_pattern++ = ge;
         *parsed_pattern++ = major;
         *parsed_pattern++ = minor;
         }
 
       /* All the remaining cases now require us to read a name. We cannot at
       this stage distinguish ambiguous cases such as (?(R12) which might be a
       recursion test by number or a name, because the named groups have not yet
       all been identified. Those cases are treated as names, but given a
       different META code. */
 
       else
         {
         BOOL was_r_ampersand = FALSE;
 
         if (*ptr == CHAR_R && ptrend - ptr > 1 && ptr[1] == CHAR_AMPERSAND)
           {
           terminator = CHAR_RIGHT_PARENTHESIS;
           was_r_ampersand = TRUE;
           ptr++;
           }
         else if (*ptr == CHAR_LESS_THAN_SIGN)
           terminator = CHAR_GREATER_THAN_SIGN;
         else if (*ptr == CHAR_APOSTROPHE)
           terminator = CHAR_APOSTROPHE;
         else
           {
           terminator = CHAR_RIGHT_PARENTHESIS;
           ptr--;   /* Point to char before name */
           }
         if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,
             &errorcode, cb)) goto FAILED;
 
         /* Handle (?(R&name) */
 
         if (was_r_ampersand)
           {
           *parsed_pattern = META_COND_RNAME;
           ptr--;   /* Back to closing parens */
           }
 
         /* Handle (?(name). If the name is "DEFINE" we identify it with a
         special code. Likewise if the name consists of R followed only by
         digits. Otherwise, handle it like a quoted name. */
 
         else if (terminator == CHAR_RIGHT_PARENTHESIS)
           {
           if (namelen == 6 && PRIV(strncmp_c8)(name, STRING_DEFINE, 6) == 0)
             *parsed_pattern = META_COND_DEFINE;
           else
             {
             for (i = 1; i < (int)namelen; i++)
               if (!IS_DIGIT(name[i])) break;
             *parsed_pattern = (*name == CHAR_R && i >= (int)namelen)?
               META_COND_RNUMBER : META_COND_NAME;
             }
           ptr--;   /* Back to closing parens */
           }
 
         /* Handle (?('name') or (?(<name>) */
 
         else *parsed_pattern = META_COND_NAME;
 
         /* All these cases except DEFINE end with the name length and offset;
         DEFINE just has an offset (for the "too many branches" error). */
 
         if (*parsed_pattern++ != META_COND_DEFINE) *parsed_pattern++ = namelen;
         PUTOFFSET(offset, parsed_pattern);
         }  /* End cases that read a name */
 
       /* Check the closing parenthesis of the condition */
 
       if (ptr >= ptrend || *ptr != CHAR_RIGHT_PARENTHESIS)
         {
         errorcode = ERR24;
         goto FAILED;
         }
       ptr++;
       break;  /* End of condition processing */
 
 
       /* ---- Atomic group ---- */
 
       case CHAR_GREATER_THAN_SIGN:
       ATOMIC_GROUP:                          /* Come from (*atomic: */
       *parsed_pattern++ = META_ATOMIC;
       nest_depth++;
       ptr++;
       break;
 
 
       /* ---- Lookahead assertions ---- */
 
       case CHAR_EQUALS_SIGN:
       POSITIVE_LOOK_AHEAD:                   /* Come from (*pla: */
       *parsed_pattern++ = META_LOOKAHEAD;
       ptr++;
       goto POST_ASSERTION;
 
       case CHAR_ASTERISK:
       POSITIVE_NONATOMIC_LOOK_AHEAD:         /* Come from (?* */
       *parsed_pattern++ = META_LOOKAHEAD_NA;
       ptr++;
       goto POST_ASSERTION;
 
       case CHAR_EXCLAMATION_MARK:
       NEGATIVE_LOOK_AHEAD:                   /* Come from (*nla: */
       *parsed_pattern++ = META_LOOKAHEADNOT;
       ptr++;
       goto POST_ASSERTION;
 
 
       /* ---- Lookbehind assertions ---- */
 
       /* (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<
       is the start of the name of a capturing group. */
 
       case CHAR_LESS_THAN_SIGN:
       if (ptrend - ptr <= 1 ||
          (ptr[1] != CHAR_EQUALS_SIGN &&
           ptr[1] != CHAR_EXCLAMATION_MARK &&
           ptr[1] != CHAR_ASTERISK))
         {
         terminator = CHAR_GREATER_THAN_SIGN;
         goto DEFINE_NAME;
         }
       *parsed_pattern++ = (ptr[1] == CHAR_EQUALS_SIGN)?
         META_LOOKBEHIND : (ptr[1] == CHAR_EXCLAMATION_MARK)?
         META_LOOKBEHINDNOT : META_LOOKBEHIND_NA;
 
       POST_LOOKBEHIND:           /* Come from (*plb: (*naplb: and (*nlb: */
       *has_lookbehind = TRUE;
       offset = (PCRE2_SIZE)(ptr - cb->start_pattern - 2);
       PUTOFFSET(offset, parsed_pattern);
       ptr += 2;
       /* Fall through */
 
       /* If the previous item was a condition starting (?(? an assertion,
       optionally preceded by a callout, is expected. This is checked later on,
       during actual compilation. However we need to identify this kind of
       assertion in this pass because it must not be qualified. The value of
       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
       for a callout - still leaving a positive value that identifies the
       assertion. Multiple callouts or any other items will make it zero or
       less, which doesn't matter because they will cause an error later. */
 
       POST_ASSERTION:
       nest_depth++;
       if (prev_expect_cond_assert > 0)
         {
         if (top_nest == NULL) top_nest = (nest_save *)(cb->start_workspace);
         else if (++top_nest >= end_nests)
           {
           errorcode = ERR84;
           goto FAILED;
           }
         top_nest->nest_depth = nest_depth;
         top_nest->flags = NSF_CONDASSERT;
         top_nest->options = options & PARSE_TRACKED_OPTIONS;
         top_nest->xoptions = xoptions & PARSE_TRACKED_EXTRA_OPTIONS;
         }
       break;
 
 
       /* ---- Define a named group ---- */
 
       /* A named group may be defined as (?'name') or (?<name>). In the latter
       case we jump to DEFINE_NAME from the disambiguation of (?< above with the
       terminator set to '>'. */
 
       case CHAR_APOSTROPHE:
       terminator = CHAR_APOSTROPHE;    /* Terminator */
 
       DEFINE_NAME:
       if (!read_name(&ptr, ptrend, utf, terminator, &offset, &name, &namelen,
           &errorcode, cb)) goto FAILED;
 
       /* We have a name for this capturing group. It is also assigned a number,
       which is its primary means of identification. */
 
       if (cb->bracount >= MAX_GROUP_NUMBER)
         {
         errorcode = ERR97;
         goto FAILED;
         }
       cb->bracount++;
       *parsed_pattern++ = META_CAPTURE | cb->bracount;
       nest_depth++;
 
       /* Check not too many names */
 
       if (cb->names_found >= MAX_NAME_COUNT)
         {
         errorcode = ERR49;
         goto FAILED;
         }
 
       /* Adjust the entry size to accommodate the longest name found. */
 
       if (namelen + IMM2_SIZE + 1 > cb->name_entry_size)
         cb->name_entry_size = (uint16_t)(namelen + IMM2_SIZE + 1);
 
       /* Scan the list to check for duplicates. For duplicate names, if the
       number is the same, break the loop, which causes the name to be
       discarded; otherwise, if DUPNAMES is not set, give an error.
       If it is set, allow the name with a different number, but continue
       scanning in case this is a duplicate with the same number. For
       non-duplicate names, give an error if the number is duplicated. */
 
       isdupname = FALSE;
       ng = cb->named_groups;
       for (i = 0; i < cb->names_found; i++, ng++)
         {
         if (namelen == ng->length &&
             PRIV(strncmp)(name, ng->name, (PCRE2_SIZE)namelen) == 0)
           {
           if (ng->number == cb->bracount) break;
           if ((options & PCRE2_DUPNAMES) == 0)
             {
             errorcode = ERR43;
             goto FAILED;
             }
           isdupname = ng->isdup = TRUE;     /* Mark as a duplicate */
           cb->dupnames = TRUE;              /* Duplicate names exist */
           }
         else if (ng->number == cb->bracount)
           {
           errorcode = ERR65;
           goto FAILED;
           }
         }
 
       if (i < cb->names_found) break;   /* Ignore duplicate with same number */
 
       /* Increase the list size if necessary */
 
       if (cb->names_found >= cb->named_group_list_size)
         {
         uint32_t newsize = cb->named_group_list_size * 2;
         named_group *newspace =
           cb->cx->memctl.malloc(newsize * sizeof(named_group),
           cb->cx->memctl.memory_data);
         if (newspace == NULL)
           {
           errorcode = ERR21;
           goto FAILED;
           }
 
         memcpy(newspace, cb->named_groups,
           cb->named_group_list_size * sizeof(named_group));
         if (cb->named_group_list_size > NAMED_GROUP_LIST_SIZE)
           cb->cx->memctl.free((void *)cb->named_groups,
           cb->cx->memctl.memory_data);
         cb->named_groups = newspace;
         cb->named_group_list_size = newsize;
         }
 
       /* Add this name to the list */
 
       cb->named_groups[cb->names_found].name = name;
       cb->named_groups[cb->names_found].length = (uint16_t)namelen;
       cb->named_groups[cb->names_found].number = cb->bracount;
       cb->named_groups[cb->names_found].isdup = (uint16_t)isdupname;
       cb->names_found++;
       break;
       }        /* End of (? switch */
     break;     /* End of ( handling */
 
 
     /* ---- Branch terminators ---- */
 
     /* Alternation: reset the capture count if we are in a (?| group. */
 
     case CHAR_VERTICAL_LINE:
     if (top_nest != NULL && top_nest->nest_depth == nest_depth &&
         (top_nest->flags & NSF_RESET) != 0)
       {
       if (cb->bracount > top_nest->max_group)
         top_nest->max_group = (uint16_t)cb->bracount;
       cb->bracount = top_nest->reset_group;
       }
     *parsed_pattern++ = META_ALT;
     break;
 
     /* End of group; reset the capture count to the maximum if we are in a (?|
     group and/or reset the options that are tracked during parsing. Disallow
     quantifier for a condition that is an assertion. */
 
     case CHAR_RIGHT_PARENTHESIS:
     okquantifier = TRUE;
     if (top_nest != NULL && top_nest->nest_depth == nest_depth)
       {
       options = (options & ~PARSE_TRACKED_OPTIONS) | top_nest->options;
       xoptions = (xoptions & ~PARSE_TRACKED_EXTRA_OPTIONS) | top_nest->xoptions;
       if ((top_nest->flags & NSF_RESET) != 0 &&
           top_nest->max_group > cb->bracount)
         cb->bracount = top_nest->max_group;
       if ((top_nest->flags & NSF_CONDASSERT) != 0)
         okquantifier = FALSE;
 
       if ((top_nest->flags & NSF_ATOMICSR) != 0)
         {
         *parsed_pattern++ = META_KET;
         }
 
       if (top_nest == (nest_save *)(cb->start_workspace)) top_nest = NULL;
         else top_nest--;
       }
     if (nest_depth == 0)    /* Unmatched closing parenthesis */
       {
       errorcode = ERR22;
       goto FAILED_BACK;
       }
     nest_depth--;
     *parsed_pattern++ = META_KET;
     break;
     }  /* End of switch on pattern character */
   }    /* End of main character scan loop */
 
 /* End of pattern reached. Check for missing ) at the end of a verb name. */
diff --git a/testdata/testinput2 b/testdata/testinput2
index ba292d8..da845c1 100644
--- a/testdata/testinput2
+++ b/testdata/testinput2
@@ -4715,1340 +4715,1342 @@ a)"xI
 "(?|()|())(?<=a()
 ((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
 ((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
 ((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
 a)"xI
 
 # Test the use of malloc for caching group information when there are more
 # groups than fit into the on-stack workspace.
 
 /\[()]{1024}/I,expand
 
 # Test minlength capped at 65535
 
 /(A{65000})\1{65000}/I
 
 # Test group scans when numbers are not unique
 
 /(?|()+|(a)+)/BI
 
 /(?|(a)+|()+)/BI
 
 /(?|()|(a))/BI
 
 /(?|(a)|())/BI
 
 # Test CRLF handling in empty string substitutions
 
 /^$/gm,newline=anycrlf,replace=-
     X\r\n\r\nY
 
 /^$/gm,newline=crlf,replace=-
     X\r\n\r\nY
 
 /^$/gm,newline=any,replace=-
     X\r\n\r\nY
 
 "(*ANYCRLF)(?m)^(.*[^0-9\r\n].*|)$"g,replace=NaN
     15\r\nfoo\r\n20\r\nbar\r\nbaz\r\n\r\n20
 
 /a[[:punct:]b]/bincode
 
 /a[b[:punct:]]/bincode
 
 /L(?#(|++<!(2)?/B
 
 /L(?#(|++<!(2)?/B,no_auto_possess
 
 /L(?#(|++<!(2)?/B,auto_callout
 
 /L(?#(|++<!(2)?/B,no_auto_possess,auto_callout
 
 /(A*)\E+/B,auto_callout
 
 /()\Q\E*]/B,auto_callout
     a[bc]d
 
 /\x8a+f|;T?(*:;.'?`(\xeap ){![^()!y*''C*(?';]{1;(\x08)/B,alt_verbnames,dupnames,extended
 
 # Tests for NULL characters in comments and verb "names" and callouts
 
 # /A#B\x00C\x0aZ/
 /41 23 42 00 43 0a 5a/Bx,hex
 
 # /A+#B\x00C\x0a+/
 /41 2b 23 42 00 43 0a 2b/Bx,hex
 
 # /A(*:B\x00W#X\00Y\x0aC)Z/
 /41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames
 
 # /A(*:B\x00W#X\00Y\x0aC)Z/
 /41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex
 
 # /A(?C{X\x00Y})B/
 /41 28 3f 43 7b 58 00 59 7d 29 42/B,hex
 
 # /A(?#X\x00Y)B/
 /41 28 3f 23 7b 00 7d 29 42/B,hex
 
 # Tests for leading comment in extended patterns
 
 / (?-x):?/extended
 
 /(?-x):?/extended
 
 /0b 28 3f 2d 78 29 3a/hex,extended
 
 /#comment
 (?-x):?/extended
 
 /(8(*:6^\x09x\xa6l\)6!|\xd0:[^:|)\x09d\Z\d{85*m(?'(?<1!)*\W[*\xff]!!h\w]*\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize
 
 /a|(b)c/replace=>$1<,substitute_unset_empty
     cat
     xbcom
 
 /a|(b)c/
     cat\=replace=>$1<
     cat\=replace=>$1<,substitute_unset_empty
     xbcom\=replace=>$1<,substitute_unset_empty
 
 /a|(b)c/substitute_extended
     cat\=replace=>${2:-xx}<
     cat\=replace=>${2:-xx}<,substitute_unknown_unset
     cat\=replace=>${X:-xx}<,substitute_unknown_unset
 
 /a|(?'X'b)c/replace=>$X<,substitute_unset_empty
     cat
     xbcom
 
 /a|(?'X'b)c/replace=>$Y<,substitute_unset_empty
     cat
     cat\=substitute_unknown_unset
     cat\=substitute_unknown_unset,-substitute_unset_empty
 
 /a|(b)c/replace=>$2<,substitute_unset_empty
     cat
     cat\=substitute_unknown_unset
     cat\=substitute_unknown_unset,-substitute_unset_empty
 
 /()()()/use_offset_limit
     \=ovector=11000000000
     \=callout_fail=11000000000
     \=callout_fail=1:11000000000
     \=callout_data=11000000000
     \=callout_data=-11000000000
     \=offset_limit=1100000000000000000000
     \=copy=11000000000
 
 /(*MARK:A\x00b)/mark
     abc
 
 /(*MARK:A\x00b)/mark,alt_verbnames
     abc
 
 /"(*MARK:A" 00 "b)"/mark,hex
     abc
 
 /"(*MARK:A" 00 "b)"/mark,hex,alt_verbnames
     abc
 
 /efg/hex
 
 /eff/hex
 
 /effg/hex
 
 /(?J)(?'a'))(?'a')/
 
 /(?<=((?C)0))/
     9010
 \= Expect no match
     abc
 
 /aaa/
 \[abc]{10000000000000000000000000000}
 \[a]{3}
 
 /\[AB]{6000000000000000000000}/expand
 
 # Hex uses pattern length, not zero-terminated. This tests for overrunning
 # the given length of a pattern.
 
 /'(*U'/hex
 
 /'(*'/hex
 
 /'('/hex
 
 //hex
 
 # These tests are here because Perl never allows a back reference in a
 # lookbehind. PCRE2 supports some limited cases.
 
 /([ab])...(?<=\1)z/
     a11az
     b11bz
 \= Expect no match
     b11az
 
 /(?|([ab]))...(?<=\1)z/
 
 /([ab])(\1)...(?<=\2)z/
     aa11az
 
 /(a\2)(b\1)(?<=\2)/
 
 /(?<A>[ab])...(?<=\k'A')z/
     a11az
     b11bz
 \= Expect no match
     b11az
 
 /(?<A>[ab])...(?<=\k'A')(?<A>)z/dupnames
 
 # Perl does not support \g+n
 
 /((\g+1X)?([ab]))+/
     aaXbbXa
 
 /ab(?C1)c/auto_callout
     abc
 
 /'ab(?C1)c'/hex,auto_callout
     abc
 
 # Perl accepts these, but gives a warning. We can't warn, so give an error.
 
 /[a-[:digit:]]+/
     a-a9-a
 
 /[A-[:digit:]]+/
     A-A9-A
 
 /[a-\d]+/
     a-a9-a
 
 /(?<RA>abc)(?(R)xyz)/B
 
 /(?<R>abc)(?(R)xyz)/B
 
 /(?=.*[A-Z])/I
 
 /()(?<=(?0))/
 
 /(?<!|!(?<!))/
 
 /(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/
 
 /{2,2{2,2/use_length
 
 /.>*?\g'0/use_length
 
 /.>*?\g'0/
 
 /{{'{22{2{{2{'{22{{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2{'{22{2{{2{'{22{{11{2{'{22{2{{2{{'{22{2{{2{'{22{{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout
 
 //
 \=get=i00000000000000000000000000000000
 \=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012
 
 "(?(?C))"
 
 /(?(?(?(?(?(?))))))/
 
 /(?<=(?1))((?s))/anchored
 
 /(*:ab)*/
 
 %(*:(:(svvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[+.+{{2,7}'      _\\\\\\\\\\\\\)?.:..    *w////\\\Q\\\\\\\\\\\\\\\T\\\\\+/?/////'+\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout
 
 /./newline=crlf
     \=ph
 
 /(\x0e00\000000\xc)/replace=\P,substitute_extended
     \x0e00\000000\xc
 
 //replace=0
     \=offset=7
 
 /(?<=\G.)/g,replace=+
     abc
 
 ".+\QX\E+"B,no_auto_possess
 
 ".+\QX\E+"B,auto_callout,no_auto_possess
 
 # This one is here because Perl gives an 'unmatched )' error which goes away
 # if one of the \) sequences is removed - which is weird. PCRE finds it too
 # complicated to find a minimum matching length.
 
 "()X|((((((((()))))))((((())))))\2())((((((\2\2)))\2)(\22((((\2\2)2))\2)))(2\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z+:)Z|91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z((Z*(\2(Z\':))\0)i|||||||||||||||loZ\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0nte!rnal errpr\2\\21r(2\ZZZ)+:)Z!|91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0(2\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0(2\ZZZ)+:)Z^)))int \)\0(2\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \))\ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)))\2))))((((((\2\2))))))"I
 
 # This checks that new code for handling groups that may match an empty string
 # works on a very large number of alternatives. This pattern used to provoke a
 # complaint that it was too complicated.
 
 /(?:\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand
 
 # This one used to compile rubbish instead of a compile error, and then
 # behave unpredictably at match time.
 
 /.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/
     .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X
 
 /[:[:alnum:]-[[a:lnum:]+/
 
 /((?(?C'')\QX\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/
 
 /((?(?C'')\Q\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/
 
 /abcd/auto_callout
     abcd\=callout_error=255:2
 
 /()(\g+65534)/
 
 /()(\g+65533)/
 
 /\x00\x00\x00(\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\x00k\d+\x00\x00\x00\x00\x00\x00\2*\x00\x00\1*.){36}int^\x00\x00\x00(\1{50779}?)J\w2/I
 
 /(a)(b)\2\1\1\1\1/I
 
 /(?<a>a)(?<b>b)\g{b}\g{a}\g{a}\g{a}\g{a}(?<a>xx)(?<b>zz)/I,dupnames
 
 //
     \=ovector=7777777777
 
 # This is here because Perl matches, even though a COMMIT is encountered
 # outside of the recursion.
 
 /(?1)(A(*COMMIT)|B)D/
     BAXBAD
 
 "(?1){2}(a)"B
 
 "(?1){2,4}(a)"B
 
 # This test differs from Perl for the first subject. Perl ends up with
 # $1 set to 'B'; PCRE2 has it unset (which I think is right).
 
 /^(?:
 (?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)
 (Z)
 )+$/x
     AZB
     AZBDZ
 
 # The first of these, when run by Perl, gives the mark 'aa', which is wrong.
 
 '(?>a(*:aa))b|ac' mark
     ac
 
 '(?:a(*:aa))b|ac' mark
     ac
 
 /(R?){65}/
     (R?){65}
 
 /\[(a)]{60}/expand
     aaaa
 
 /(?<!\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended
 
 /\g{3/
 
 /(a(?C1)(b)(c)d)+/
   abcdabcd\=callout_capture
 
 # Perl matches this one, but PCRE does not because (*ACCEPT) clears out any
 # pending backtracks in the recursion.
 
 /^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x
 \= Expect no match
     abc
 
 # Perl gives no match for this one
 
 /(a(*MARK:m)(*ACCEPT)){0}(?1)/mark
     abc
 
 /abc/endanchored
     xyzabc
 \= Expect no match
     xyzabcdef
 \= Expect error
     xyzabc\=ph
 
 /abc/
     xyzabc\=endanchored
 \= Expect no match
     xyzabcdef\=endanchored
 \= Expect error
     xyzabc\=ps,endanchored
 
 /abc(*ACCEPT)d/endanchored
     xyzabc
 \= Expect no match
     xyzabcdef
 
 /abc|bcd/endanchored
     xyzabcd
 \= Expect no match
     xyzabcdef
 
 /a(*ACCEPT)x|aa/endanchored
     aaa
 
 # Check auto-anchoring when there is a group that is never obeyed at
 # the start of a branch.
 
 /(?(DEFINE)(a))^bc/I
 
 /(a){0}.*bc/sI
 
 # This should be anchored, as the condition is always false and there is
 # no alternative branch.
 
 /(?(VERSION>=999)yes)^bc/I
 
 # This should not be anchored.
 
 /(?(VERSION>=999)yes|no)^bc/I
 
 /(*LIMIT_HEAP=0)xxx/I
 
 /\d{0,3}(*:abc)(?C1)xxx/callout_info
 
 # ----------------------------------------------------------------------
 
 # These are a whole pile of tests that touch lines of code that are not
 # used by any other tests (at least when these were created).
 
 /^a+?x/i,no_start_optimize,no_auto_possess
 \= Expect no match
     aaa
 
 /^[^a]{3,}?x/i,no_start_optimize,no_auto_possess
 \= Expect no match
     bbb
     cc
 
 /^X\S/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\W/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\H/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\h/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\V/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\v/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\h/no_start_optimize,no_auto_possess
 \= Expect no match
     XY
 
 /^X\V/no_start_optimize,no_auto_possess
 \= Expect no match
     X\n
 
 /^X\v/no_start_optimize,no_auto_possess
 \= Expect no match
     XX
 
 /^X.+?/s,no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\R+?/no_start_optimize,no_auto_possess
 \= Expect no match
     XX
 
 /^X\H+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\h+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
 
 /^X\V+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
     X\n
 
 /^X\D+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
     X9
 
 /^X\S+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
     X\n
 
 /^X\W+?/no_start_optimize,no_auto_possess
 \= Expect no match
     X
     XX
 
 /^X.+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\n
 
 /(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\r\=ps
 
 /^X\R+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\nX
     X\n\r\n
     X\n\rY
     X\n\nY
     X\n\x{0c}Y
 
 /(*BSR_ANYCRLF)^X\R+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\nX
     X\n\r\n
     X\n\rY
     X\n\nY
     X\n\x{0c}Y
 
 /^X\H+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\t
     XYY
 
 /^X\h+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\t\t
     X\tY
 
 /^X\V+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\n
     XYY
 
 /^X\v+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\n\n
     X\nY
 
 /^X\D+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY9
     XYY
 
 /^X\d+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X99
     X9Y
 
 /^X\S+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\n
     XYY
 
 /^X\s+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\n\n
     X\nY
 
 /^X\W+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X.A
     X++
 
 /^X\w+?Z/no_start_optimize,no_auto_possess
 \= Expect no match
     Xa.
     Xaa
 
 /^X.{1,3}Z/s,no_start_optimize,no_auto_possess
 \= Expect no match
     Xa.bd
 
 /^X\h+Z/no_start_optimize,no_auto_possess
 \= Expect no match
     X\t\t
     X\tY
 
 /^X\V+Z/no_start_optimize,no_auto_possess
 \= Expect no match
     XY\n
     XYY
 
 /^(X(*THEN)Y|AB){0}(?1)/
     ABX
 \= Expect no match
     XAB
 
 /^(?!A(?C1)B)C/
     ABC\=callout_error=1,no_jit
 
 /^(?!A(?C1)B)C/no_start_optimize
     ABC\=callout_error=1
 
 /^(?(?!A(?C1)B)C)/
     ABC\=callout_error=1
 
 # ----------------------------------------------------------------------
 
 /[a b c]/BxxI
 
 /[a b c]/BxxxI
 
 /[a b c]/B,extended_more
 
 /[ a b c ]/B,extended_more
 
 /[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B
 
 # Unsetting /x also unsets /xx
 
 /[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B
 
 /(a)(?-n:(b))(c)/nB
 
 # ----------------------------------------------------------------------
 # These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.
 
 /\j\x{z}\o{82}\L\uabcd\u\U\g{\g/B,\bad_escape_is_literal
 
 /\N{\c/IB,bad_escape_is_literal
 
 /[\j\x{z}\o\gAb\g]/B,bad_escape_is_literal
 
 /[Q-\N]/B,bad_escape_is_literal
 
 /[\s-_]/bad_escape_is_literal
 
 /[_-\s]/bad_escape_is_literal
 
 /[\B\R\X]/B
 
 /[\B\R\X]/B,bad_escape_is_literal
 
 /[A-\BP-\RV-\X]/B
 
 /[A-\BP-\RV-\X]/B,bad_escape_is_literal
 
 # ----------------------------------------------------------------------
 
 /a\b(c/literal
     a\\b(c
 
 /a\b(c/literal,caseless
     a\\b(c
     a\\B(c
 
 /a\b(c/literal,firstline
     XYYa\\b(c
 \= Expect no match
     X\na\\b(c
 
 /a\b?c/literal,use_offset_limit
     XXXXa\\b?c\=offset_limit=4
 \= Expect no match
     XXXXa\\b?c\=offset_limit=3
 
 /a\b(c/literal,anchored,endanchored
     a\\b(c
 \= Expect no match
     Xa\\b(c
     a\\b(cX
     Xa\\b(cX
 
 //literal,extended
 
 /a\b(c/literal,auto_callout,no_start_optimize
     XXXXa\\b(c
 
 /a\b(c/literal,auto_callout
     XXXXa\\b(c
 
 /(*CR)abc/literal
     (*CR)abc
 
 /cat|dog/I,match_word
     the cat sat
 \= Expect no match
     caterpillar
     snowcat
     syndicate
 
 /(cat)|dog/I,match_line,literal
     (cat)|dog
 \= Expect no match
     the cat sat
     caterpillar
     snowcat
     syndicate
 
 /a whole line/match_line,multiline
     Rhubarb \na whole line\n custard
 \= Expect no match
     Not a whole line
 
 # Perl gets this wrong, failing to capture 'b' in group 1.
 
 /^(b+|a){1,2}?bc/
     bbc
     
 # And again here, for the "babc" subject string. 
 
 /^(b*|ba){1,2}?bc/
     babc
     bbabc
     bababc
 \= Expect no match
     bababbc
     babababc
 
 /[[:digit:]-a]/
 
 /[[:digit:]-[:print:]]/
 
 /[\d-a]/
 
 /[\H-z]/
 
 /[\d-[:print:]]/
 
 # Perl gets the second of these wrong, giving no match.
 
 "(?<=(a))\1?b"I
     ab
     aaab 
 
 "(?=(a))\1?b"I
     ab
     aaab
     
 # JIT does not support callout_extra  
     
 /(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess
 \= Expect no match
     aac\=callout_extra 
     
 /(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess
 \= Expect no match
     aac\=callout_extra 
 
 /\n/firstline
     xyz\nabc
 
 /\nabc/firstline
     xyz\nabc
 
 /\x{0a}abc/firstline,newline=crlf
 \= Expect no match
     xyz\r\nabc
 
 /[abc]/firstline
 \= Expect no match
     \na
     
 # These tests are matched in test 1 as they are Perl compatible. Here we are
 # looking at what does and does not get auto-possessified. 
 
 /(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B
 
 /(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B
     
 /^(a?)b(?1)a/B
 
 /^(a?)+b(?1)a/B
 
 /^(a?)++b(?1)a/B
 
 /^(a?)+b/B
 
 /(?=a+)a(a+)++b/B
 
 /(?<=(?=.){4,5}x)/B
 
 # Perl behaves differently with these when optimization is turned off
 
 /a(*PRUNE:X)bc|qq/mark,no_start_optimize
 \= Expect no match
     axy
 
 /a(*THEN:X)bc|qq/mark,no_start_optimize
 \= Expect no match
     axy
 
 /(?^x-i)AB/ 
 
 /(?^-i)AB/ 
 
 /(?x-i-i)/
 
 /(?(?=^))b/I
     abc
 
 /(?(?=^)|)b/I
     abc
 
 /(?(?=^)|^)b/I
     bbc
 \= Expect no match
     abc     
 
 /(?(1)^|^())/I
 
 /(?(1)^())b/I
 
 /(?(1)^())+b/I,aftertext
     abc
 
 /(?(1)^()|^)+b/I,aftertext
     bbc 
 \= Expect no match     
     abc
 
 /(?(1)^()|^)*b/I,aftertext
     bbc 
     abc
     xbc 
 
 /(?(1)^())+b/I,aftertext
     abc
 
 /(?(1)^a()|^a)+b/I,aftertext
     abc 
 \= Expect no match     
     bbc
 
 /(?(1)^|^(a))+b/I,aftertext
     abc 
 \= Expect no match     
     bbc
 
 /(?(1)^a()|^a)*b/I,aftertext
     abc 
     bbc
     xbc 
 
 /a(b)c|xyz/g,allvector,replace=<$0>
     abcdefabcpqr\=ovector=4
     abxyz\=ovector=4
     abcdefxyz\=ovector=4
     
 /a(b)c|xyz/allvector
     abcdef\=ovector=4
     abxyz\=ovector=4
 
 /a(b)c|xyz/g,replace=<$0>,substitute_callout
     abcdefabcpqr
     abxyzpqrabcxyz
     12abc34xyz99abc55\=substitute_stop=2
     12abc34xyz99abc55\=substitute_skip=1
     12abc34xyz99abc55\=substitute_skip=2
 
 /a(b)c|xyz/g,replace=<$0>
     abcdefabcpqr
     abxyzpqrabcxyz
     12abc34xyz\=substitute_stop=2
     12abc34xyz\=substitute_skip=1
 
 /a(b)c|xyz/replace=<$0>
     abcdefabcpqr
     12abc34xyz\=substitute_skip=1
     12abc34xyz\=substitute_stop=1
 
 /abc\rdef/
     abc\ndef
 
 /abc\rdef\x{0d}xyz/escaped_cr_is_lf
     abc\ndef\rxyz
 \= Expect no match     
     abc\ndef\nxyz
 
 /(?(*ACCEPT)xxx)/
 
 /(?(*atomic:xx)xxx)/
 
 /(?(*script_run:xxx)zzz)/
 
 /foobar/
     the foobar thing\=copy_matched_subject
     the foobar thing\=copy_matched_subject,zero_terminate
 
 /foobar/g
     the foobar thing foobar again\=copy_matched_subject
 
 /(*:XX)^abc/I
 
 /(*COMMIT:XX)^abc/I
 
 /(*ACCEPT:XX)^abc/I
 
 /abc/replace=xyz
     abc\=null_context
 
 /abc/replace=xyz,substitute_callout
     abc 
 \= Expect error message
     abc\=null_context
 
 /\[()]{65535}()/expand
 
 /\[()]{65535}(?<A>)/expand
 
 /a(?:(*ACCEPT))??bc/
     abc
     axy
 
 /a(*ACCEPT)??bc/
     abc
     axy
 
 /a(*ACCEPT:XX)??bc/mark
     abc
     axy
 
 /(*:\)?/
 
 /(*:\Q \E){5}/alt_verbnames
 
 /(?=abc)/I
 
 /(?|(X)|(XY))\1abc/I
 
 /(?|(a)|(bcde))(c)\2/I
 
 /(?|(a)|(bcde))(c)\1/I
 
 /(?|(?'A'a)|(?'A'bcde))(?'B'c)\k'B'(?'A')/I,dupnames
 
 /(?|(?'A'a)|(?'A'bcde))(?'B'c)\k'A'(?'A')/I,dupnames
 
 /((a|)+)+Z/I
 
 /((?=a))[abcd]/I
 
 /A(?:(*ACCEPT))?B/info
 
 /(A(*ACCEPT)??B)C/
     ABC
     AXY 
 
 /(?<=(?<=a)b)c.*/I
     abc\=ph
 \= Expect no match
     xbc\=ph
 
 /(?<=ab)c.*/I
     abc\=ph
 \= Expect no match
     xbc\=ph
 
 /(?<=a(?<=a|a)c)/I
 
 /(?<=a(?<=a|ba)c)/I
 
 /(?<=(?<=a)b)(?<!abcd)/I
 
 /(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I
 
 # Addition overflow
 /( {32742} {42})(?<!\1{65481})/
 
 # Multiplication overflow
 /(X{65535})(?<=\1{32770})/
 
 # ---- Non-atomic assertion tests ----
 
 # Expect error: not allowed as a condition
 /(?(*napla:xx)bc)/
 
 /\A(*pla:.*\b(\w++))(?>.*?\b\1\b){3}/
     word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
 
 /\A(*napla:.*\b(\w++))(?>.*?\b\1\b){3}/
     word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
 
 /\A(?*.*\b(\w++))(?>.*?\b\1\b){3}/
     word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
 
 /(*plb:(.)..|(.)...)(\1|\2)/
     abcdb\=offset=4 
     abcda\=offset=4 
 
 /(*naplb:(.)..|(.)...)(\1|\2)/
     abcdb\=offset=4 
     abcda\=offset=4 
     
 /(?<*(.)..|(.)...)(\1|\2)/
     abcdb\=offset=4 
     abcda\=offset=4 
     
 /(*non_atomic_positive_lookahead:ab)/B
  
 /(*non_atomic_positive_lookbehind:ab)/B 
 
 /(*pla:ab+)/B
 
 /(*napla:ab+)/B
 
 /(*napla:)+/
 
 /(*naplb:)+/
 
 /(*napla:^x|^y)/I
 
 /(*napla:abc|abd)/I
 
 /(*napla:a|(.)(*ACCEPT)zz)\1../
     abcd
     
 /(*napla:a(*ACCEPT)zz|(.))\1../
     abcd
     
 /(*napla:a|(*COMMIT)(.))\1\1/
     aabc
 \= Expect no match     
     abbc   
 
 /(*napla:a|(.))\1\1/
     aabc
     abbc   
 
 /(*naplb:ab?c|PQ).../g
     abcdefgacxyzPQR123
 
 # ----
 
 # Expect error (recursion => not fixed length)
 /(\2)((?=(?<=\1)))/
 
 /c*+(?<=[bc])/
     abc\=ph
     ab\=ph
     abc\=ps
     ab\=ps
 
 /c++(?<=[bc])/
     abc\=ph
     ab\=ph
 
 /(?<=(?=.(?<=x)))/
     abx
     ab\=ph
     bxyz 
     xyz
     
 /\z/
    abc\=ph
    abc\=ps 
    
 /\Z/
    abc\=ph
    abc\=ps 
    abc\n\=ph
    abc\n\=ps
 
 /(?![ab]).*/
     ab\=ph
 
 /c*+/
     ab\=ph,offset=2
 
 /\A\s*(a|(?:[^`]{28500}){4})/I
     a
 
 /\A\s*((?:[^`]{28500}){4})/I
 
 /\A\s*((?:[^`]{28500}){4}|a)/I
     a
 
 /(?<A>a)(?(<A>)b)((?<=b).*)/B
 
 /(?(1)b)((?<=b).*)/B
 
 /(?(R1)b)((?<=b).*)/B
 
 /(?(DEFINE)b)((?<=b).*)/B
 
 /(?(VERSION=10.3)b)((?<=b).*)/B
 
 /[aA]b[cC]/IB
 
 /[cc]abcd/I
 
 /[Cc]abcd/I
 
 /[c]abcd/I
 
 /(?:c|C)abcd/I
 
 /(a)?a/I
     manm
 
 /^(?|(\*)(*napla:\S*_(\2?+.+))|(\w)(?=\S*_(\2?+\1)))+_\2$/
     *abc_12345abc
 
 /^(?|(\*)(*napla:\S*_(\3?+.+))|(\w)(?=\S*_((\2?+\1))))+_\2$/
     *abc_12345abc
 
 /^((\1+)(?C)|\d)+133X$/
     111133X\=callout_capture
 
 /abc/replace=xyz,substitute_replacement_only
     123abc456
 
 /a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only
     "abcde-abcde-"
      
 /a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only
     abcdefabcpqr                
     abxyzpqrabcxyz              
     12abc34xyz99abc55\=substitute_stop=2                          
     12abc34xyz99abc55\=substitute_skip=1
     12abc34xyz99abc55\=substitute_skip=2
 
 /a(..)d/replace=>$1<,substitute_matched
     xyzabcdxyzabcdxyz
     xyzabcdxyzabcdxyz\=ovector=2
 \= Expect error     
     xyzabcdxyzabcdxyz\=ovector=1
 
 /a(..)d/g,replace=>$1<,substitute_matched
     xyzabcdxyzabcdxyz
     xyzabcdxyzabcdxyz\=ovector=2
 \= Expect error     
     xyzabcdxyzabcdxyz\=ovector=1
     xyzabcdxyzabcdxyz\=ovector=1,substitute_unset_empty
 
 /55|a(..)d/g,replace=>$1<,substitute_matched
     xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 \= Expect error     
     xyz55abcdxyzabcdxyz\=ovector=2
 
 /55|a(..)d/replace=>$1<,substitute_matched
     xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 
 /55|a(..)d/replace=>$1<
     xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 
 /55|a(..)d/g,replace=>$1<
     xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
     
 /abc/replace=,caseless
     XabcY
     XABCY 
 
 /abc/replace=[4],caseless
     XabcY
     XABCY 
 
 /abc/replace=*,caseless
     XabcY
     XABCY
     XabcY\=replace=  
 
 # Expect non-fixed-length error
 
 "(?<=X(?(DEFINE)(.*))(?1))."
 
 /\sxxx\s/tables=1
 \= Expect no match
     AB\x{85}xxx\x{a0}XYZ
 
 /\sxxx\s/tables=2
     AB\x{85}xxx\x{a0}XYZ
 
 /^\w+/tables=2
     cole
 
 /^\w+/tables=3
     cole
 
 #loadtables ./testbtables
 
 /^\w+/tables=3
     cole
 
 /"(*MARK:>" 00 "<).."/hex,mark,no_start_optimize
     AB
     A\=ph 
 \= Expect no match
     A
 
 /"(*MARK:>" 00 "<).(?C1)."/hex,mark,no_start_optimize
     AB
 
 /(?(VERSION=0.0/
 
 # Perl has made \K in lookarounds an error. PCRE2 now rejects as well, unless
 # explicitly authorized.
 
 /(?=a\Kb)ab/
 
 /(?=a\Kb)ab/allow_lookaround_bsk
     ab 
 
 /(?!a\Kb)ac/
 
 /(?!a\Kb)ac/allow_lookaround_bsk
     ac 
     
 /^abc(?<=b\Kc)d/
 
 /^abc(?<=b\Kc)d/allow_lookaround_bsk
     abcd
 
 /^abc(?<!b\Kq)d/
 
 /^abc(?<!b\Kq)d/,allow_lookaround_bsk
     abcd
     
 # --------- 
 
 # Tests for zero-length NULL to be treated as an empty string.
 
 //
     \=null_subject
 \= Expect error     
     abc\=null_subject
 
 //replace=[20]
     abc\=null_replacement
     \=null_subject
     \=null_replacement
 
 /X*/g,replace=xy
 \= Expect error
     >X<\=null_replacement
 
 /X+/replace=[20]
     >XX<\=null_replacement
 
 # --------- 
 
 /[Aa]{2}/BI
     aabcd
 
 /A{2}/iBI
     aabcd
 
 /[Aa]{2,3}/BI
     aabcd
 
 --
     \[X]{-10}
     
 # Check imposition of maximum by match_data_create().
 
 /abcd/
     abcd\=ovector=65536
 
 # Use recurse to test \K and Mark in atomic scope.
 /(?>this line\s*((?R)|)\K)/
     this line this line this line
 
 /(?>this line\s*((?R)|)(*MARK:A))/
     this line this line this line
     
 # Check use of NULL pattern with zero length.
 
 //null_pattern,use_length
     abc
     
 //null_pattern
 
 /bad null pattern/null_pattern,use_length
 
 /bad null pattern/null_pattern
 
 # -------- Variable length lookbehinds --------
 /12345(?<=\d{1,256})X/
 
 /(?<=(\d{1,256}))X/max_varlookbehind=256
     12345XYZ
 
 /12345(?<=a?bc)X/max_varlookbehind=0
 
 /12345(?<=abc)X/max_varlookbehind=0
 
 /(?<!( {65054}){9,44965})/
 
 /(?(?<!|(|a)))/
     aaaa\=get=0
 
 /(?(?<!|a?))/
     aaaa\=get=0
 
 # --------
 
 /(?<=(()()()()()()()()()()()()()(()()()()(())()()()()(()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()(())()()()()(()()()()()()(()()()()()()()()()()()()()()()()()()()()()(())()()()()(()()()()()()()()()()()()()(()()()()()()()()()()()()()(()())))))))))/
 
 /(?<!( {65054}){0,44965})/auto_callout
 
 /A+{,3}/
 
 /(\g{+1}Z|(A))+/
     BAAZCD 
     ZAAAZAZAZAACD 
 
 # This doesn't work in Perl (though I think it used to)
 
 /^(?=.*(?=(([A-Z]).*(?(1)\1)))(?!.+\2)){26}/i
     The quick brown fox jumps over the lazy dog.
     Jackdaws love my big sphinx of quartz.
     Pack my box with five dozen liquor jugs.
 \= Expect no match
     The quick brown fox jumps over the lazy cat.
     Hackdaws love my big sphinx of quartz.
     Pack my fox with five dozen liquor jugs.
     
 # These are different to Perl because of the different capturing in repeating
 # groups.
 
 /((foo)|(bar))*/
     foobar
 
 /(?:(f)(o)(o)|(b)(a)(r))*/
     foobar
 
 /((Z)+|A)*/
     ZABCDEFG
 
 /(?:(?P=same)?(?:(?P<same>a)|(?P<same>b))(?P=same))+/g,dupnames
     bbbaaabaabb
 
 # --------
 
 /
 /anchored, firstline
     \x0a
 
 /
 /anchored,firstline,no_start_optimize
     \x0a
 
 /
 /firstline
     \x0a
     abc\x0adef
 
 # This test is currently broken in the interpreter
 # /|a(?0)/endanchored
 #    aaaa
 
+/A +/extended
+
 # End of testinput2
diff --git a/testdata/testoutput2 b/testdata/testoutput2
index 888f06a..85de4ae 100644
--- a/testdata/testoutput2
+++ b/testdata/testoutput2
@@ -17874,64 +17874,66 @@ No match
     Pack my fox with five dozen liquor jugs.
 No match
     
 # These are different to Perl because of the different capturing in repeating
 # groups.
 
 /((foo)|(bar))*/
     foobar
  0: foobar
  1: bar
  2: foo
  3: bar
 
 /(?:(f)(o)(o)|(b)(a)(r))*/
     foobar
  0: foobar
  1: f
  2: o
  3: o
  4: b
  5: a
  6: r
 
 /((Z)+|A)*/
     ZABCDEFG
  0: ZA
  1: A
  2: Z
 
 /(?:(?P=same)?(?:(?P<same>a)|(?P<same>b))(?P=same))+/g,dupnames
     bbbaaabaabb
  0: bbbaaaba
  1: a
  2: b
  0: bb
  1: <unset>
  2: b
 
 # --------
 
 /
 /anchored, firstline
     \x0a
  0: \x0a
 
 /
 /anchored,firstline,no_start_optimize
     \x0a
  0: \x0a
 
 /
 /firstline
     \x0a
  0: \x0a
     abc\x0adef
  0: \x0a
 
 # This test is currently broken in the interpreter
 # /|a(?0)/endanchored
 #    aaaa
 
+/A +/extended
+
 # End of testinput2
 Error -70: PCRE2_ERROR_BADDATA (unknown error number)
 Error -62: bad serialized data
